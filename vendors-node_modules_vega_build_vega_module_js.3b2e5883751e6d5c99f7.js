(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_vega_build_vega_module_js"],{

/***/ "../../node_modules/d3-array/src/ascending.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-array/src/ascending.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/bisect.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-array/src/bisect.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bisectRight": () => (/* binding */ bisectRight),
/* harmony export */   "bisectLeft": () => (/* binding */ bisectLeft),
/* harmony export */   "bisectCenter": () => (/* binding */ bisectCenter),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "../../node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisector.js */ "../../node_modules/d3-array/src/bisector.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-array/src/number.js");




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__.default)(_ascending_js__WEBPACK_IMPORTED_MODULE_1__.default);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__.default)(_number_js__WEBPACK_IMPORTED_MODULE_2__.default).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "../../node_modules/d3-array/src/bisector.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-array/src/bisector.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "../../node_modules/d3-array/src/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(f) {
  let delta = f;
  let compare = f;

  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function ascendingComparator(f) {
  return (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__.default)(f(d), x);
}


/***/ }),

/***/ "../../node_modules/d3-array/src/deviation.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-array/src/deviation.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ deviation)
/* harmony export */ });
/* harmony import */ var _variance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance.js */ "../../node_modules/d3-array/src/variance.js");


function deviation(values, valueof) {
  const v = (0,_variance_js__WEBPACK_IMPORTED_MODULE_0__.default)(values, valueof);
  return v ? Math.sqrt(v) : v;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/fsum.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-array/src/fsum.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Adder": () => (/* binding */ Adder),
/* harmony export */   "fsum": () => (/* binding */ fsum),
/* harmony export */   "fcumsum": () => (/* binding */ fcumsum)
/* harmony export */ });
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ "../../node_modules/d3-array/src/max.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-array/src/max.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/mean.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-array/src/mean.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mean)
/* harmony export */ });
function mean(values, valueof) {
  let count = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  }
  if (count) return sum / count;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/median.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-array/src/median.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quantile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quantile.js */ "../../node_modules/d3-array/src/quantile.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  return (0,_quantile_js__WEBPACK_IMPORTED_MODULE_0__.default)(values, 0.5, valueof);
}


/***/ }),

/***/ "../../node_modules/d3-array/src/merge.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-array/src/merge.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ merge)
/* harmony export */ });
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ "../../node_modules/d3-array/src/min.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-array/src/min.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/number.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-array/src/number.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "numbers": () => (/* binding */ numbers)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ "../../node_modules/d3-array/src/permute.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-array/src/permute.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ "../../node_modules/d3-array/src/quantile.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-array/src/quantile.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile),
/* harmony export */   "quantileSorted": () => (/* binding */ quantileSorted)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max.js */ "../../node_modules/d3-array/src/max.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./min.js */ "../../node_modules/d3-array/src/min.js");
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quickselect.js */ "../../node_modules/d3-array/src/quickselect.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-array/src/number.js");





function quantile(values, p, valueof) {
  values = Float64Array.from((0,_number_js__WEBPACK_IMPORTED_MODULE_0__.numbers)(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return (0,_min_js__WEBPACK_IMPORTED_MODULE_1__.default)(values);
  if (p >= 1) return (0,_max_js__WEBPACK_IMPORTED_MODULE_2__.default)(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0,_max_js__WEBPACK_IMPORTED_MODULE_2__.default)((0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__.default)(values, i0).subarray(0, i0 + 1)),
      value1 = (0,_min_js__WEBPACK_IMPORTED_MODULE_1__.default)(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__.default) {
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}


/***/ }),

/***/ "../../node_modules/d3-array/src/quickselect.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-array/src/quickselect.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "../../node_modules/d3-array/src/ascending.js");


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = array.length - 1, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__.default) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/range.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-array/src/range.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/sum.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-array/src/sum.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sum)
/* harmony export */ });
function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/ticks.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-array/src/ticks.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "tickIncrement": () => (/* binding */ tickIncrement),
/* harmony export */   "tickStep": () => (/* binding */ tickStep)
/* harmony export */ });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/variance.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-array/src/variance.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ variance)
/* harmony export */ });
function variance(values, valueof) {
  let count = 0;
  let delta;
  let mean = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  }
  if (count > 1) return sum / (count - 1);
}


/***/ }),

/***/ "../../node_modules/d3-color/src/color.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-color/src/color.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "darker": () => (/* binding */ darker),
/* harmony export */   "brighter": () => (/* binding */ brighter),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   "rgbConvert": () => (/* binding */ rgbConvert),
/* harmony export */   "rgb": () => (/* binding */ rgb),
/* harmony export */   "Rgb": () => (/* binding */ Rgb),
/* harmony export */   "hslConvert": () => (/* binding */ hslConvert),
/* harmony export */   "hsl": () => (/* binding */ hsl)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "../../node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__.default)(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__.default)(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__.default)(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "../../node_modules/d3-color/src/cubehelix.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-color/src/cubehelix.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cubehelix),
/* harmony export */   "Cubehelix": () => (/* binding */ Cubehelix)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./define.js */ "../../node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_2__.default)(Cubehelix, cubehelix, (0,_define_js__WEBPACK_IMPORTED_MODULE_2__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_0__.brighter : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_0__.brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_0__.darker : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_0__.darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "../../node_modules/d3-color/src/define.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-color/src/define.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "extend": () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "../../node_modules/d3-color/src/lab.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-color/src/lab.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gray": () => (/* binding */ gray),
/* harmony export */   "default": () => (/* binding */ lab),
/* harmony export */   "Lab": () => (/* binding */ Lab),
/* harmony export */   "lch": () => (/* binding */ lch),
/* harmony export */   "hcl": () => (/* binding */ hcl),
/* harmony export */   "Hcl": () => (/* binding */ Hcl)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./define.js */ "../../node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__.default)(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__.default)(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "../../node_modules/d3-color/src/math.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-color/src/math.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "radians": () => (/* binding */ radians),
/* harmony export */   "degrees": () => (/* binding */ degrees)
/* harmony export */ });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "../../node_modules/d3-delaunay/src/delaunay.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-delaunay/src/delaunay.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Delaunay)
/* harmony export */ });
/* harmony import */ var delaunator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! delaunator */ "../../node_modules/delaunator/index.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "../../node_modules/d3-delaunay/src/path.js");
/* harmony import */ var _polygon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polygon.js */ "../../node_modules/d3-delaunay/src/polygon.js");
/* harmony import */ var _voronoi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./voronoi.js */ "../../node_modules/d3-delaunay/src/voronoi.js");





const tau = 2 * Math.PI, pow = Math.pow;

function pointX(p) {
  return p[0];
}

function pointY(p) {
  return p[1];
}

// A triangulation is collinear if all its triangles have a non-null area
function collinear(d) {
  const {triangles, coords} = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a = 2 * triangles[i],
          b = 2 * triangles[i + 1],
          c = 2 * triangles[i + 2],
          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
    if (cross > 1e-10) return false;
  }
  return true;
}

function jitter(x, y, r) {
  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
}

class Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new Delaunay("length" in points
        ? flatArray(points, fx, fy, that)
        : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new delaunator__WEBPACK_IMPORTED_MODULE_0__.default(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;

    // check for collinear
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }
      this._delaunator = new delaunator__WEBPACK_IMPORTED_MODULE_0__.default(points);
    } else {
      delete this.collinear;
    }

    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);

    // Compute an index from each point to an (arbitrary) incoming halfedge
    // Used to give the first neighbor of each point; for this reason,
    // on the hull we give priority to exterior halfedges
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }

    // degenerate case: 1 or 2 (distinct) points
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      this.triangles[1] = hull[1];
      this.triangles[2] = hull[1];
      inedges[hull[0]] = 1;
      if (hull.length === 2) inedges[hull[1]] = 0;
    }
  }
  voronoi(bounds) {
    return new _voronoi_js__WEBPACK_IMPORTED_MODULE_1__.default(this, bounds);
  }
  *neighbors(i) {
    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

    // degenerate case with several collinear points
    if (collinear) {
      const l = collinear.indexOf(i);
      if (l > 0) yield collinear[l - 1];
      if (l < collinear.length - 1) yield collinear[l + 1];
      return;
    }

    const e0 = inedges[i];
    if (e0 === -1) return; // coincident point
    let e = e0, p0 = -1;
    do {
      yield p0 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) return; // bad triangulation
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p0) yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x, y, i = 0) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
    const i0 = i;
    let c;
    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
    return c;
  }
  _step(i, x, y) {
    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c = i;
    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c;
  }
  render(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {points, halfedges, triangles} = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r = 2) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {points} = this;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x = points[i], y = points[i + 1];
      context.moveTo(x + r, y);
      context.arc(x, y, r, 0, tau);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {hull, points} = this;
    const h = hull[0] * 2, n = hull.length;
    context.moveTo(points[h], points[h + 1]);
    for (let i = 1; i < n; ++i) {
      const h = 2 * hull[i];
      context.lineTo(points[h], points[h + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new _polygon_js__WEBPACK_IMPORTED_MODULE_3__.default;
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {points, triangles} = this;
    const t0 = triangles[i *= 3] * 2;
    const t1 = triangles[i + 1] * 2;
    const t2 = triangles[i + 2] * 2;
    context.moveTo(points[t0], points[t0 + 1]);
    context.lineTo(points[t1], points[t1 + 1]);
    context.lineTo(points[t2], points[t2 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const {triangles} = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new _polygon_js__WEBPACK_IMPORTED_MODULE_3__.default;
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
}

function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array[i * 2] = fx.call(that, p, i, points);
    array[i * 2 + 1] = fy.call(that, p, i, points);
  }
  return array;
}

function* flatIterable(points, fx, fy, that) {
  let i = 0;
  for (const p of points) {
    yield fx.call(that, p, i, points);
    yield fy.call(that, p, i, points);
    ++i;
  }
}


/***/ }),

/***/ "../../node_modules/d3-delaunay/src/path.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-delaunay/src/path.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Path)
/* harmony export */ });
const epsilon = 1e-6;

class Path {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }
  moveTo(x, y) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x, y) {
    this._ += `L${this._x1 = +x},${this._y1 = +y}`;
  }
  arc(x, y, r) {
    x = +x, y = +y, r = +r;
    const x0 = x + r;
    const y0 = y;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x0},${y0}`;
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += "L" + x0 + "," + y0;
    if (!r) return;
    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
  }
  rect(x, y, w, h) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
  }
  value() {
    return this._ || null;
  }
}


/***/ }),

/***/ "../../node_modules/d3-delaunay/src/polygon.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-delaunay/src/polygon.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Polygon)
/* harmony export */ });
class Polygon {
  constructor() {
    this._ = [];
  }
  moveTo(x, y) {
    this._.push([x, y]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x, y) {
    this._.push([x, y]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}


/***/ }),

/***/ "../../node_modules/d3-delaunay/src/voronoi.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-delaunay/src/voronoi.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Voronoi)
/* harmony export */ });
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.js */ "../../node_modules/d3-delaunay/src/path.js");
/* harmony import */ var _polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polygon.js */ "../../node_modules/d3-delaunay/src/polygon.js");



class Voronoi {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const {delaunay: {points, hull, triangles}, vectors} = this;

    // Compute circumcenters.
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
      const t1 = triangles[i] * 2;
      const t2 = triangles[i + 1] * 2;
      const t3 = triangles[i + 2] * 2;
      const x1 = points[t1];
      const y1 = points[t1 + 1];
      const x2 = points[t2];
      const y2 = points[t2 + 1];
      const x3 = points[t3];
      const y3 = points[t3 + 1];

      const dx = x2 - x1;
      const dy = y2 - y1;
      const ex = x3 - x1;
      const ey = y3 - y1;
      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const ab = (dx * ey - dy * ex) * 2;

      if (!ab) {
        // degenerate case (collinear diagram)
        x = (x1 + x3) / 2 - 1e8 * ey;
        y = (y1 + y3) / 2 + 1e8 * ex;
      }
      else if (Math.abs(ab) < 1e-8) {
        // almost equal points (degenerate triangle)
        x = (x1 + x3) / 2;
        y = (y1 + y3) / 2;
      } else {
        const d = 1 / ab;
        x = x1 + (ey * bl - dy * cl) * d;
        y = y1 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j] = x;
      circumcenters[j + 1] = y;
    }

    // Compute exterior cell rays.
    let h = hull[hull.length - 1];
    let p0, p1 = h * 4;
    let x0, x1 = points[2 * h];
    let y0, y1 = points[2 * h + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }
  render(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_0__.default : undefined;
    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x = circumcenters[t];
      const y = circumcenters[t + 1];
      const v = h0 * 4;
      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
      if (p) this._renderSegment(x, y, p[0], p[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_0__.default : undefined;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_0__.default : undefined;
    const points = this._clip(i);
    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n = points.length;
    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
    for (let i = 2; i < n; i += 2) {
      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
        context.lineTo(points[i], points[i + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const {delaunay: {points}} = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) cell.index = i, yield cell;
    }
  }
  cellPolygon(i) {
    const polygon = new _polygon_js__WEBPACK_IMPORTED_MODULE_1__.default;
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x0, y0, x1, y1, context) {
    let S;
    const c0 = this._regioncode(x0, y0);
    const c1 = this._regioncode(x1, y1);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  }
  contains(i, x, y) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
    return this.delaunay._step(i, x, y) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j);
      // find the common edge
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] == cj[aj]
          && ci[ai + 1] == cj[aj + 1]
          && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
          && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
          ) {
            yield j;
            break loop;
          }
        }
      }
    }
  }
  _cell(i) {
    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
    const e0 = inedges[i];
    if (e0 === -1) return null; // coincident point
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i) {
    // degenerate case (1 valid point: return the box)
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i);
    if (points === null) return null;
    const {vectors: V} = this;
    const v = i * 4;
    return V[v] || V[v + 1]
        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
        : this._clipFinite(i, points);
  }
  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
    let c0, c1 = this._regioncode(x1, y1);
    let e0, e1;
    for (let j = 0; j < n; j += 2) {
      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x1, y1);
        else P = [x1, y1];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x0, y0, x1, y1, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
      if (c0 & c1) return null;
      let x, y, c = c0 || c1;
      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
    }
  }
  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x, y;
      switch (e0) {
        case 0b0101: e0 = 0b0100; continue; // top-left
        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
        case 0b0110: e0 = 0b0010; continue; // top-right
        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
        case 0b1010: e0 = 0b1000; continue; // bottom-right
        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
        case 0b1001: e0 = 0b0001; continue; // bottom-left
        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
      }
      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
        P.splice(j, 0, x, y), j += 2;
      }
    }
    if (P.length > 4) {
      for (let i = 0; i < P.length; i+= 2) {
        const j = (i + 2) % P.length, k = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k]
        || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
          P.splice(j, 2), i -= 2;
      }
    }
    return j;
  }
  _project(x0, y0, vx, vy) {
    let t = Infinity, c, x, y;
    if (vy < 0) { // top
      if (y0 <= this.ymin) return null;
      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
    } else if (vy > 0) { // bottom
      if (y0 >= this.ymax) return null;
      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
    }
    if (vx > 0) { // right
      if (x0 >= this.xmax) return null;
      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
    } else if (vx < 0) { // left
      if (x0 <= this.xmin) return null;
      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
    }
    return [x, y];
  }
  _edgecode(x, y) {
    return (x === this.xmin ? 0b0001
        : x === this.xmax ? 0b0010 : 0b0000)
        | (y === this.ymin ? 0b0100
        : y === this.ymax ? 0b1000 : 0b0000);
  }
  _regioncode(x, y) {
    return (x < this.xmin ? 0b0001
        : x > this.xmax ? 0b0010 : 0b0000)
        | (y < this.ymin ? 0b0100
        : y > this.ymax ? 0b1000 : 0b0000);
  }
}


/***/ }),

/***/ "../../node_modules/d3-dsv/src/dsv.js":
/*!********************************************!*\
  !*** ../../node_modules/d3-dsv/src/dsv.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "../../node_modules/d3-format/src/defaultLocale.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-format/src/defaultLocale.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "formatPrefix": () => (/* binding */ formatPrefix),
/* harmony export */   "default": () => (/* binding */ defaultLocale)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "../../node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__.default)(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "../../node_modules/d3-format/src/exponent.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-format/src/exponent.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "../../node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatDecimal.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-format/src/formatDecimal.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "formatDecimalParts": () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatGroup.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-format/src/formatGroup.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatNumerals.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-format/src/formatNumerals.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatPrefixAuto.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-format/src/formatPrefixAuto.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prefixExponent": () => (/* binding */ prefixExponent),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "../../node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatRounded.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-format/src/formatRounded.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "../../node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatSpecifier.js":
/*!***********************************************************!*\
  !*** ../../node_modules/d3-format/src/formatSpecifier.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatSpecifier),
/* harmony export */   "FormatSpecifier": () => (/* binding */ FormatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "../../node_modules/d3-format/src/formatTrim.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-format/src/formatTrim.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatTypes.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-format/src/formatTypes.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "../../node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "../../node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "../../node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.default,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__.default)(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__.default,
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__.default,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "../../node_modules/d3-format/src/identity.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-format/src/identity.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "../../node_modules/d3-format/src/locale.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-format/src/locale.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "../../node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "../../node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "../../node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "../../node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "../../node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "../../node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "../../node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "../../node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__.default : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__.default)(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__.default : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__.default)(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__.default)(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__.default[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__.default[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__.default)(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__.default)(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__.default)(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "../../node_modules/d3-format/src/precisionFixed.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-format/src/precisionFixed.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "../../node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step) {
  return Math.max(0, -(0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(Math.abs(step)));
}


/***/ }),

/***/ "../../node_modules/d3-format/src/precisionPrefix.js":
/*!***********************************************************!*\
  !*** ../../node_modules/d3-format/src/precisionPrefix.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "../../node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(value) / 3))) * 3 - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(Math.abs(step)));
}


/***/ }),

/***/ "../../node_modules/d3-format/src/precisionRound.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-format/src/precisionRound.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "../../node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(max) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(step)) + 1;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/area.js":
/*!*********************************************!*\
  !*** ../../node_modules/d3-geo/src/area.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areaRingSum": () => (/* binding */ areaRingSum),
/* harmony export */   "areaStream": () => (/* binding */ areaStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noop.js */ "../../node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "../../node_modules/d3-geo/src/stream.js");





var areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();

// hello?

var areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  polygonStart: function() {
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_2__.tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__.default;
  },
  sphere: function() {
    areaSum.add(_math_js__WEBPACK_IMPORTED_MODULE_2__.tau);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  lambda0 = lambda, cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.cos)(phi = phi / 2 + _math_js__WEBPACK_IMPORTED_MODULE_2__.quarterPi), sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sin)(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  phi = phi / 2 + _math_js__WEBPACK_IMPORTED_MODULE_2__.quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.cos)(phi),
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sin)(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.cos)(adLambda),
      v = k * sdLambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sin)(adLambda);
  areaRingSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.atan2)(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_3__.default)(object, areaStream);
  return areaSum * 2;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/bounds.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-geo/src/bounds.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "../../node_modules/d3-geo/src/area.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stream.js */ "../../node_modules/d3-geo/src/stream.js");






var lambda0, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    lambda00, phi00, // first point
    p0, // previous 3D point
    deltaSum,
    ranges,
    range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.polygonStart();
  },
  polygonEnd: function() {
    _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area_js__WEBPACK_IMPORTED_MODULE_1__.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon) phi1 = 90;
    else if (deltaSum < -_math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  },
  sphere: function() {
    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)([lambda * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians, phi * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians]);
  if (p0) {
    var normal = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(equatorial, normal);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianNormalizeInPlace)(inflection);
    inflection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees * sign,
        phii,
        antimeridian = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(delta) > 180;
    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }
  _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);
  _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.lineEnd();
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(deltaSum) > _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_4__.default)(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0, phi0], [lambda1, phi1]];
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/cartesian.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/cartesian.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "spherical": () => (/* binding */ spherical),
/* harmony export */   "cartesian": () => (/* binding */ cartesian),
/* harmony export */   "cartesianDot": () => (/* binding */ cartesianDot),
/* harmony export */   "cartesianCross": () => (/* binding */ cartesianCross),
/* harmony export */   "cartesianAddInPlace": () => (/* binding */ cartesianAddInPlace),
/* harmony export */   "cartesianScale": () => (/* binding */ cartesianScale),
/* harmony export */   "cartesianNormalizeInPlace": () => (/* binding */ cartesianNormalizeInPlace)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");


function spherical(cartesian) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  return [cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/centroid.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-geo/src/centroid.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop.js */ "../../node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "../../node_modules/d3-geo/src/stream.js");





var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00, phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  centroidPointCartesian(cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(cx, cy, cz),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 = 0;
  X2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Y2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Z2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_3__.default)(object, centroidStream);

  var x = +X2,
      y = +Y2,
      z = +Z2,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) x = X0, y = Y0, z = Z0;
    m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);
    // If the feature still has an undefined ccentroid, then return.
    if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) return [NaN, NaN];
  }

  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / m) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/circle.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-geo/src/circle.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "circleStream": () => (/* binding */ circleStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation.js */ "../../node_modules/d3-geo/src/rotation.js");





// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      sinRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.spherical)([cosRadius, -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(t), -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point), point[0] -= cosRadius;
  (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(point);
  var radius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var center = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)([0, 0]),
      radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(90),
      precision = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, x[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
        p = precision.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians;
    ring = [];
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_3__.rotateRadians)(-c[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, -c[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(+_), circle) : precision;
  };

  return circle;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/antimeridian.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/antimeridian.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_index_js__WEBPACK_IMPORTED_MODULE_0__.default)(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
          delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - lambda0);
      if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) { // line crosses antimeridian
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; // handle degeneracies
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0 - lambda1);
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan)(((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0) * (cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda1)
          - (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1) * (cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi;
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(0, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
  } else if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(from[0] - to[0]) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
    var lambda = from[0] < to[0] ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/buffer.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/buffer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/circle.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/circle.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle.js */ "../../node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointEqual.js */ "../../node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/clip/index.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var cr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      delta = 6 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
      smallRadius = cr > 0,
      notHemisphere = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(cr) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.default)(point0, point2) || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.default)(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !(0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.default)(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(a),
        pb = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(pa, pb),
        n2n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(n1, n2),
        A = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n1, c1),
        B = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n2, c2);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, u),
        uu = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(u, u),
        t2 = w * w - uu * ((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, A) - 1);

    if (t2 < 0) return;

    var t = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(t2),
        q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w - t) / uu);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q, A);
    q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon,
        meridian = polar || delta < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(q[0] - lambda0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w + t) / uu);
      (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q1, A);
      return [q, (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : _math_js__WEBPACK_IMPORTED_MODULE_0__.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return (0,_index_js__WEBPACK_IMPORTED_MODULE_4__.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math_js__WEBPACK_IMPORTED_MODULE_0__.pi, radius - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "../../node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "../../node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../polygonContains.js */ "../../node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/merge.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_0__.default)(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(segments);
        var startInside = (0,_polygonContains_js__WEBPACK_IMPORTED_MODULE_2__.default)(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__.default)(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - b[1]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/line.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/line.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/rectangle.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/rectangle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "../../node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "../../node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "../../node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/merge.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__.default)(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__.default)(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__.default)(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/rejoin.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/rejoin.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "../../node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__.default)(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/compose.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-geo/src/compose.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/constant.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-geo/src/constant.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/graticule.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/graticule.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graticule),
/* harmony export */   "graticule10": () => (/* binding */ graticule10)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(y0, y1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(x0, x1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(X0 / DX) * DX, X1, DX).map(X)
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(x0 / dx) * dx, x1, dx).filter(function(x) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(x % DX) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(x))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(y0 / dy) * dy, y1, dy).filter(function(y) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(y % DY) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 90 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]])
      .extentMinor([[-180, -80 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 80 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]]);
}

function graticule10() {
  return graticule()();
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/identity.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-geo/src/identity.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => x);


/***/ }),

/***/ "../../node_modules/d3-geo/src/math.js":
/*!*********************************************!*\
  !*** ../../node_modules/d3-geo/src/math.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "epsilon": () => (/* binding */ epsilon),
/* harmony export */   "epsilon2": () => (/* binding */ epsilon2),
/* harmony export */   "pi": () => (/* binding */ pi),
/* harmony export */   "halfPi": () => (/* binding */ halfPi),
/* harmony export */   "quarterPi": () => (/* binding */ quarterPi),
/* harmony export */   "tau": () => (/* binding */ tau),
/* harmony export */   "degrees": () => (/* binding */ degrees),
/* harmony export */   "radians": () => (/* binding */ radians),
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "atan": () => (/* binding */ atan),
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "exp": () => (/* binding */ exp),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "hypot": () => (/* binding */ hypot),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "pow": () => (/* binding */ pow),
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "sign": () => (/* binding */ sign),
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "tan": () => (/* binding */ tan),
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "asin": () => (/* binding */ asin),
/* harmony export */   "haversin": () => (/* binding */ haversin)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var hypot = Math.hypot;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/noop.js":
/*!*********************************************!*\
  !*** ../../node_modules/d3-geo/src/noop.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/area.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/area.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");




var areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    x00,
    y00,
    x0,
    y0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__.default;
    areaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(areaRingSum));
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (areaStream);


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/bounds.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/bounds.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/centroid.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/centroid.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");


// TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;

var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
        : Z1 ? [X1 / Z1, Y1 / Z1]
        : Z0 ? [X0 / Z0, Y0 / Z0]
        : [NaN, NaN];
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 =
    X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0, dy = y - y0, z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);

  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;

  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (centroidStream);


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/context.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/context.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathContext)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
        break;
      }
    }
  },
  result: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default
};


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../identity.js */ "../../node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "../../node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "../../node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds.js */ "../../node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid.js */ "../../node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./context.js */ "../../node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./measure.js */ "../../node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "../../node_modules/d3-geo/src/path/string.js");









/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_area_js__WEBPACK_IMPORTED_MODULE_1__.default));
    return _area_js__WEBPACK_IMPORTED_MODULE_1__.default.result();
  };

  path.measure = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_measure_js__WEBPACK_IMPORTED_MODULE_2__.default));
    return _measure_js__WEBPACK_IMPORTED_MODULE_2__.default.result();
  };

  path.bounds = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_bounds_js__WEBPACK_IMPORTED_MODULE_3__.default));
    return _bounds_js__WEBPACK_IMPORTED_MODULE_3__.default.result();
  };

  path.centroid = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_centroid_js__WEBPACK_IMPORTED_MODULE_4__.default));
    return _centroid_js__WEBPACK_IMPORTED_MODULE_4__.default.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity_js__WEBPACK_IMPORTED_MODULE_5__.default) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string_js__WEBPACK_IMPORTED_MODULE_6__.default) : new _context_js__WEBPACK_IMPORTED_MODULE_7__.default(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/measure.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/measure.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");




var lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;

var lengthStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__.default;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lengthStream);


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/string.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/string.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathString)
/* harmony export */ });
function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/pointEqual.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-geo/src/pointEqual.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/polygonContains.js":
/*!********************************************************!*\
  !*** ../../node_modules/d3-geo/src/polygonContains.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");




function longitude(point) {
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) <= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi)
    return point[0];
  else
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(point[0]) * (((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) + _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
      normal = [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), 0],
      angle = 0,
      winding = 0;

  var sum = new d3_array__WEBPACK_IMPORTED_MODULE_1__.Adder();

  if (sinPhi === 1) phi = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
  else if (sinPhi === -1) phi = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
        sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi0),
        cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
          sinPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi1),
          cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi,
          k = sinPhi0 * sinPhi1;

      sum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(k * sign * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point0), (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point1));
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(arc);
        var intersection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(normal, arc);
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || angle < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && sum < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) ^ (winding & 1);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/albers.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/albers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _conicEqualArea_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conicEqualArea.js */ "../../node_modules/d3-geo/src/projection/conicEqualArea.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_0__.default)()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/albersUsa.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/albersUsa.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _albers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./albers.js */ "../../node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var _conicEqualArea_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conicEqualArea.js */ "../../node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit.js */ "../../node_modules/d3-geo/src/projection/fit.js");





// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var cache,
      cacheStream,
      lower48 = (0,_albers_js__WEBPACK_IMPORTED_MODULE_0__.default)(), lower48Point,
      alaska = (0,_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_1__.default)().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = (0,_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_1__.default)().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.120 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon], [x - 0.214 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.234 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.166 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon], [x - 0.115 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.234 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitExtent)(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitSize)(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitWidth)(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitHeight)(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/azimuthal.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/azimuthal.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalRaw": () => (/* binding */ azimuthalRaw),
/* harmony export */   "azimuthalInvert": () => (/* binding */ azimuthalInvert)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");


function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x),
        cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y),
        k = scale(cx * cy);
        if (k === Infinity) return [2, 0];
    return [
      k * cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x),
      k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + y * y),
        c = angle(z),
        sc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(c),
        cc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(c);
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x * sc, z * cc),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(z && y * sc / z)
    ];
  }
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalEqualAreaRaw": () => (/* binding */ azimuthalEqualAreaRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




var azimuthalEqualAreaRaw = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalRaw)(function(cxcy) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalInvert)(function(z) {
  return 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / 2);
});

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js":
/*!************************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalEquidistantRaw": () => (/* binding */ azimuthalEquidistantRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




var azimuthalEquidistantRaw = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalRaw)(function(c) {
  return (c = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.acos)(c)) && c / (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(c);
});

azimuthalEquidistantRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalInvert)(function(z) {
  return z;
});

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/conic.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/conic.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicProjection": () => (/* binding */ conicProjection)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");



function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 3,
      m = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.projectionMutator)(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, phi1 = _[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians) : [phi0 * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, phi1 * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees];
  };

  return p;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/conicConformal.js":
/*!******************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/conicConformal.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicConformalRaw": () => (/* binding */ conicConformalRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conic.js */ "../../node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator.js */ "../../node_modules/d3-geo/src/projection/mercator.js");




function tany(y) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.tan)((_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y0),
      n = y0 === y1 ? (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y0) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)(cy0 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y1)) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)(tany(y1) / tany(y0)),
      f = cy0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.pow)(tany(y0), n) / n;

  if (!n) return _mercator_js__WEBPACK_IMPORTED_MODULE_1__.mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) y = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; }
    else { if (y > _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) y = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; }
    var r = f / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.pow)(tany(y), n);
    return [r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(n * x), f - r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(n) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + fy * fy),
      l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(fy)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(fy);
    if (fy * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(x) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(fy);
    return [l / n, 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.pow)(f / r, 1 / n)) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi];
  };

  return project;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic_js__WEBPACK_IMPORTED_MODULE_2__.conicProjection)(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/conicEqualArea.js":
/*!******************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/conicEqualArea.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicEqualAreaRaw": () => (/* binding */ conicEqualAreaRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conic.js */ "../../node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _cylindricalEqualArea_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cylindricalEqualArea.js */ "../../node_modules/d3-geo/src/projection/cylindricalEqualArea.js");




function conicEqualAreaRaw(y0, y1) {
  var sy0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y0), n = (sy0 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(n) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return (0,_cylindricalEqualArea_js__WEBPACK_IMPORTED_MODULE_1__.cylindricalEqualAreaRaw)(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(c) / n;

  function project(x, y) {
    var r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(c - 2 * n * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)) / n;
    return [r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x *= n), r0 - r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y,
        l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r0y)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(r0y);
    if (r0y * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(x) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(r0y);
    return [l / n, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic_js__WEBPACK_IMPORTED_MODULE_2__.conicProjection)(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/conicEquidistant.js":
/*!********************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/conicEquidistant.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicEquidistantRaw": () => (/* binding */ conicEquidistantRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conic.js */ "../../node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _equirectangular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equirectangular.js */ "../../node_modules/d3-geo/src/projection/equirectangular.js");




function conicEquidistantRaw(y0, y1) {
  var cy0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y0),
      n = y0 === y1 ? (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y0) : (cy0 - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(n) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return _equirectangular_js__WEBPACK_IMPORTED_MODULE_1__.equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(nx), g - gy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y,
        l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(gy)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(gy);
    if (gy * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(x) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(gy);
    return [l / n, g - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(n) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + gy * gy)];
  };

  return project;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic_js__WEBPACK_IMPORTED_MODULE_2__.conicProjection)(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/cylindricalEqualArea.js":
/*!************************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/cylindricalEqualArea.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cylindricalEqualAreaRaw": () => (/* binding */ cylindricalEqualAreaRaw)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");


function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(y * cosPhi0)];
  };

  return forward;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/equalEarth.js":
/*!**************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/equalEarth.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equalEarthRaw": () => (/* binding */ equalEarthRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");



var A1 = 1.340264,
    A2 = -0.081106,
    A3 = 0.000893,
    A4 = 0.003796,
    M = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3) / 2,
    iterations = 12;

function equalEarthRaw(lambda, phi) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(M * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}

equalEarthRaw.invert = function(x, y) {
  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) break;
  }
  return [
    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(l),
    (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(l) / M)
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.default)(equalEarthRaw)
      .scale(177.158);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/equirectangular.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/equirectangular.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equirectangularRaw": () => (/* binding */ equirectangularRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");


function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.default)(equirectangularRaw)
      .scale(152.63);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/fit.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/fit.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fitExtent": () => (/* binding */ fitExtent),
/* harmony export */   "fitSize": () => (/* binding */ fitSize),
/* harmony export */   "fitWidth": () => (/* binding */ fitWidth),
/* harmony export */   "fitHeight": () => (/* binding */ fitHeight)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "../../node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "../../node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__.default));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__.default.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/gnomonic.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/gnomonic.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gnomonicRaw": () => (/* binding */ gnomonicRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




function gnomonicRaw(x, y) {
  var cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y), k = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x) * cy;
  return [cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x) / k, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y) / k];
}

gnomonicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(_math_js__WEBPACK_IMPORTED_MODULE_0__.atan);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/identity.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/identity.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle.js */ "../../node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity.js */ "../../node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "../../node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fit.js */ "../../node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
      alpha = 0, ca, sa, // angle
      x0 = null, y0, x1, y1, // clip extent
      kx = 1, ky = 1,
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
        point: function(x, y) {
          var p = projection([x, y])
          this.stream.point(p[0], p[1]);
        }
      }),
      postclip = _identity_js__WEBPACK_IMPORTED_MODULE_1__.default,
      cache,
      cacheStream;

  function reset() {
    kx = k * sx;
    ky = k * sy;
    cache = cacheStream = null;
    return projection;
  }

  function projection (p) {
    var x = p[0] * kx, y = p[1] * ky;
    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }    
    return [x + tx, y + ty];
  }
  projection.invert = function(p) {
    var x = p[0] - tx, y = p[1] - ty;
    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }
    return [x / kx, y / ky];
  };
  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
  };
  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };
  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_1__.default) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };
  projection.scale = function(_) {
    return arguments.length ? (k = +_, reset()) : k;
  };
  projection.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  }
  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_3__.radians, sa = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.sin)(alpha), ca = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.cos)(alpha), reset()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_3__.degrees;
  };
  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitExtent)(projection, extent, object);
  };
  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitSize)(projection, size, object);
  };
  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitWidth)(projection, width, object);
  };
  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitHeight)(projection, height, object);
  };

  return projection;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ projection),
/* harmony export */   "projectionMutator": () => (/* binding */ projectionMutator)
/* harmony export */ });
/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/antimeridian.js */ "../../node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../clip/circle.js */ "../../node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../clip/rectangle.js */ "../../node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../compose.js */ "../../node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../identity.js */ "../../node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rotation.js */ "../../node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "../../node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fit.js */ "../../node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resample.js */ "../../node_modules/d3-geo/src/projection/resample.js");











var transformRadians = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
  point: function(x, y) {
    this.stream.point(x * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, y * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }
});

function transformRotate(rotate) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx; y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(alpha),
      sinAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx; y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate angle
      sx = 1, // reflectX
      sy = 1, // reflectX
      theta = null, preclip = _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__.default, // pre-clip angle
      x0 = null, y0, x1, y1, postclip = _identity_js__WEBPACK_IMPORTED_MODULE_3__.default, // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? (0,_clip_circle_js__WEBPACK_IMPORTED_MODULE_4__.default)(theta = _ * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians) : (theta = null, _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__.default), reset()) : theta * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_3__.default) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : [lambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, phi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaPhi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians : 0, recenter()) : [deltaLambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaPhi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaGamma * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__.default)(projectTransform, delta2 = _ * _), reset()) : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitSize)(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitHeight)(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_8__.rotateRadians)(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__.default)(project, transform);
    projectRotateTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__.default)(rotate, projectTransform);
    projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__.default)(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/mercator.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/mercator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mercatorRaw": () => (/* binding */ mercatorRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mercatorProjection": () => (/* binding */ mercatorProjection)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rotation.js */ "../../node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




function mercatorRaw(lambda, phi) {
  return [lambda, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.tan)((_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.exp)(y)) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
}

function mercatorProjection(project) {
  var m = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.default)(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * scale(),
        t = m((0,_rotation_js__WEBPACK_IMPORTED_MODULE_2__.default)(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/naturalEarth1.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/naturalEarth1.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "naturalEarth1Raw": () => (/* binding */ naturalEarth1Raw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");



function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.default)(naturalEarth1Raw)
      .scale(175.295);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/orthographic.js":
/*!****************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/orthographic.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "orthographicRaw": () => (/* binding */ orthographicRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




function orthographicRaw(x, y) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)];
}

orthographicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(_math_js__WEBPACK_IMPORTED_MODULE_0__.asin);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/resample.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/resample.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "../../node_modules/d3-geo/src/transform.js");




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(30 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians); // cos(minimum angular distance)

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.transformer)({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(a * a + b * b + c * c),
          phi2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(c /= m),
          lambda2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(c) - 1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda0 - lambda1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? (lambda0 + lambda1) / 2 : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/stereographic.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/stereographic.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stereographicRaw": () => (/* binding */ stereographicRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




function stereographicRaw(x, y) {
  var cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y), k = 1 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x) * cy;
  return [cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x) / k, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y) / k];
}

stereographicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(function(z) {
  return 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)(z);
});

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(stereographicRaw)
      .scale(250)
      .clipAngle(142);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/transverseMercator.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/transverseMercator.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transverseMercatorRaw": () => (/* binding */ transverseMercatorRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator.js */ "../../node_modules/d3-geo/src/projection/mercator.js");



function transverseMercatorRaw(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.tan)((_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.exp)(x)) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var m = (0,_mercator_js__WEBPACK_IMPORTED_MODULE_1__.mercatorProjection)(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/rotation.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-geo/src/rotation.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rotateRadians": () => (/* binding */ rotateRadians),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose.js */ "../../node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + Math.round(-lambda / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) ? (deltaPhi || deltaGamma ? (0,_compose_js__WEBPACK_IMPORTED_MODULE_1__.default)(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda - _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda < -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaPhi),
      sinDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaPhi),
      cosDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaGamma),
      sinDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rotate) {
  rotate = rotateRadians(rotate[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate.length > 2 ? rotate[2] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  };

  return forward;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/stream.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-geo/src/stream.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/transform.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/transform.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "transformer": () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/array.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/array.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "genericArray": () => (/* binding */ genericArray)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./value.js */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberArray.js */ "../../node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return ((0,_numberArray_js__WEBPACK_IMPORTED_MODULE_0__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_0__.default : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0,_value_js__WEBPACK_IMPORTED_MODULE_1__.default)(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/basis.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/basis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "basis": () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/basisClosed.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/basisClosed.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/color.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/color.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hue": () => (/* binding */ hue),
/* harmony export */   "gamma": () => (/* binding */ gamma),
/* harmony export */   "default": () => (/* binding */ nogamma)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(a) ? b : a);
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/constant.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/constant.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/cubehelix.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/cubehelix.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "cubehelixLong": () => (/* binding */ cubehelixLong)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/cubehelix.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.default)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.default)(end)).h),
          s = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.s, end.s),
          l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.l, end.l),
          opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__.hue));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__.default);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/date.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/date.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/discrete.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/discrete.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/hcl.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/hcl.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "hclLong": () => (/* binding */ hclLong)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hcl)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hcl)(end)).h),
        c = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.c, end.c),
        l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.l, end.l),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__.hue));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__.default);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/hsl.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/hsl.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "hslLong": () => (/* binding */ hslLong)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hsl)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hsl)(end)).h),
        s = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.s, end.s),
        l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.l, end.l),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__.hue));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__.default);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/hue.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/hue.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.hue)(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interpolate": () => (/* reexport safe */ _value_js__WEBPACK_IMPORTED_MODULE_0__.default),
/* harmony export */   "interpolateArray": () => (/* reexport safe */ _array_js__WEBPACK_IMPORTED_MODULE_1__.default),
/* harmony export */   "interpolateBasis": () => (/* reexport safe */ _basis_js__WEBPACK_IMPORTED_MODULE_2__.default),
/* harmony export */   "interpolateBasisClosed": () => (/* reexport safe */ _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__.default),
/* harmony export */   "interpolateDate": () => (/* reexport safe */ _date_js__WEBPACK_IMPORTED_MODULE_4__.default),
/* harmony export */   "interpolateDiscrete": () => (/* reexport safe */ _discrete_js__WEBPACK_IMPORTED_MODULE_5__.default),
/* harmony export */   "interpolateHue": () => (/* reexport safe */ _hue_js__WEBPACK_IMPORTED_MODULE_6__.default),
/* harmony export */   "interpolateNumber": () => (/* reexport safe */ _number_js__WEBPACK_IMPORTED_MODULE_7__.default),
/* harmony export */   "interpolateNumberArray": () => (/* reexport safe */ _numberArray_js__WEBPACK_IMPORTED_MODULE_8__.default),
/* harmony export */   "interpolateObject": () => (/* reexport safe */ _object_js__WEBPACK_IMPORTED_MODULE_9__.default),
/* harmony export */   "interpolateRound": () => (/* reexport safe */ _round_js__WEBPACK_IMPORTED_MODULE_10__.default),
/* harmony export */   "interpolateString": () => (/* reexport safe */ _string_js__WEBPACK_IMPORTED_MODULE_11__.default),
/* harmony export */   "interpolateTransformCss": () => (/* reexport safe */ _transform_index_js__WEBPACK_IMPORTED_MODULE_12__.interpolateTransformCss),
/* harmony export */   "interpolateTransformSvg": () => (/* reexport safe */ _transform_index_js__WEBPACK_IMPORTED_MODULE_12__.interpolateTransformSvg),
/* harmony export */   "interpolateZoom": () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_13__.default),
/* harmony export */   "interpolateRgb": () => (/* reexport safe */ _rgb_js__WEBPACK_IMPORTED_MODULE_14__.default),
/* harmony export */   "interpolateRgbBasis": () => (/* reexport safe */ _rgb_js__WEBPACK_IMPORTED_MODULE_14__.rgbBasis),
/* harmony export */   "interpolateRgbBasisClosed": () => (/* reexport safe */ _rgb_js__WEBPACK_IMPORTED_MODULE_14__.rgbBasisClosed),
/* harmony export */   "interpolateHsl": () => (/* reexport safe */ _hsl_js__WEBPACK_IMPORTED_MODULE_15__.default),
/* harmony export */   "interpolateHslLong": () => (/* reexport safe */ _hsl_js__WEBPACK_IMPORTED_MODULE_15__.hslLong),
/* harmony export */   "interpolateLab": () => (/* reexport safe */ _lab_js__WEBPACK_IMPORTED_MODULE_16__.default),
/* harmony export */   "interpolateHcl": () => (/* reexport safe */ _hcl_js__WEBPACK_IMPORTED_MODULE_17__.default),
/* harmony export */   "interpolateHclLong": () => (/* reexport safe */ _hcl_js__WEBPACK_IMPORTED_MODULE_17__.hclLong),
/* harmony export */   "interpolateCubehelix": () => (/* reexport safe */ _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__.default),
/* harmony export */   "interpolateCubehelixLong": () => (/* reexport safe */ _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__.cubehelixLong),
/* harmony export */   "piecewise": () => (/* reexport safe */ _piecewise_js__WEBPACK_IMPORTED_MODULE_19__.default),
/* harmony export */   "quantize": () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_20__.default)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "../../node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "../../node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date.js */ "../../node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _discrete_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete.js */ "../../node_modules/d3-interpolate/src/discrete.js");
/* harmony import */ var _hue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue.js */ "../../node_modules/d3-interpolate/src/hue.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "../../node_modules/d3-interpolate/src/numberArray.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "../../node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./round.js */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./string.js */ "../../node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _transform_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/index.js */ "../../node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zoom.js */ "../../node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rgb.js */ "../../node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _hsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hsl.js */ "../../node_modules/d3-interpolate/src/hsl.js");
/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lab.js */ "../../node_modules/d3-interpolate/src/lab.js");
/* harmony import */ var _hcl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hcl.js */ "../../node_modules/d3-interpolate/src/hcl.js");
/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cubehelix.js */ "../../node_modules/d3-interpolate/src/cubehelix.js");
/* harmony import */ var _piecewise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./piecewise.js */ "../../node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./quantize.js */ "../../node_modules/d3-interpolate/src/quantize.js");























/***/ }),

/***/ "../../node_modules/d3-interpolate/src/lab.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/lab.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lab)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.default)(start)).l, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.default)(end)).l),
      a = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.a, end.a),
      b = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/number.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/number.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/numberArray.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/numberArray.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "isNumberArray": () => (/* binding */ isNumberArray)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/object.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/object.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "../../node_modules/d3-interpolate/src/value.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0,_value_js__WEBPACK_IMPORTED_MODULE_0__.default)(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/piecewise.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/piecewise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ piecewise)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "../../node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__.default;
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/quantize.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/quantize.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/rgb.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/rgb.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "rgbBasis": () => (/* binding */ rgbBasis),
/* harmony export */   "rgbBasisClosed": () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "../../node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__.default);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__.default);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/round.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/round.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/string.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/string.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/transform/decompose.js":
/*!********************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/transform/decompose.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/transform/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/transform/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interpolateTransformCss": () => (/* binding */ interpolateTransformCss),
/* harmony export */   "interpolateTransformSvg": () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "../../node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/transform/parse.js":
/*!****************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/transform/parse.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseCss": () => (/* binding */ parseCss),
/* harmony export */   "parseSvg": () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "../../node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__.default)(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__.default)(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/value.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/value.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rgb.js */ "../../node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./array.js */ "../../node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./date.js */ "../../node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./object.js */ "../../node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ "../../node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./numberArray.js */ "../../node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_1__.default
      : t === "string" ? ((c = (0,d3_color__WEBPACK_IMPORTED_MODULE_2__.default)(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_3__.default) : _string_js__WEBPACK_IMPORTED_MODULE_4__.default)
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_2__.default ? _rgb_js__WEBPACK_IMPORTED_MODULE_3__.default
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_5__.default
      : (0,_numberArray_js__WEBPACK_IMPORTED_MODULE_6__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_6__.default
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_7__.genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_8__.default
      : _number_js__WEBPACK_IMPORTED_MODULE_1__.default)(a, b);
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/zoom.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/zoom.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "../../node_modules/d3-path/src/path.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-path/src/path.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (path);


/***/ }),

/***/ "../../node_modules/d3-scale/src/constant.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-scale/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ constants)
/* harmony export */ });
function constants(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/continuous.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-scale/src/continuous.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "transformer": () => (/* binding */ transformer),
/* harmony export */   "default": () => (/* binding */ continuous)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-scale/src/number.js");





var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.default,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_3__.default)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_4__.default), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__.default, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/diverging.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-scale/src/diverging.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ diverging),
/* harmony export */   "divergingLog": () => (/* binding */ divergingLog),
/* harmony export */   "divergingSymlog": () => (/* binding */ divergingSymlog),
/* harmony export */   "divergingPow": () => (/* binding */ divergingPow),
/* harmony export */   "divergingSqrt": () => (/* binding */ divergingSqrt)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./log.js */ "../../node_modules/d3-scale/src/log.js");
/* harmony import */ var _sequential_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sequential.js */ "../../node_modules/d3-scale/src/sequential.js");
/* harmony import */ var _symlog_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symlog.js */ "../../node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pow.js */ "../../node_modules/d3-scale/src/pow.js");









function transformer() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      s = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.default)(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }

  scale.range = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.default);

  scale.rangeRound = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_3__.default);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
    return scale;
  };
}

function diverging() {
  var scale = (0,_linear_js__WEBPACK_IMPORTED_MODULE_4__.linearish)(transformer()(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity));

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, diverging());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = (0,_log_js__WEBPACK_IMPORTED_MODULE_7__.loggish)(transformer()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, divergingLog()).base(scale.base());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = (0,_symlog_js__WEBPACK_IMPORTED_MODULE_8__.symlogish)(transformer());

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, divergingSymlog()).constant(scale.constant());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = (0,_pow_js__WEBPACK_IMPORTED_MODULE_9__.powish)(transformer());

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, divergingPow()).exponent(scale.exponent());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/identity.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-scale/src/identity.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ identity)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-scale/src/number.js");



function identity(domain) {
  var unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_0__.default), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity(domain).unknown(unknown);
  };

  domain = arguments.length ? Array.from(domain, _number_js__WEBPACK_IMPORTED_MODULE_0__.default) : [0, 1];

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/init.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-scale/src/init.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initRange": () => (/* binding */ initRange),
/* harmony export */   "initInterpolator": () => (/* binding */ initInterpolator)
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/linear.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-scale/src/linear.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearish": () => (/* binding */ linearish),
/* harmony export */   "default": () => (/* binding */ linear)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");
/* harmony import */ var _tickFormat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tickFormat.js */ "../../node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return (0,_tickFormat_js__WEBPACK_IMPORTED_MODULE_1__.default)(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.default)();

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.copy)(scale, linear());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/log.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-scale/src/log.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loggish": () => (/* binding */ loggish),
/* harmony export */   "default": () => (/* binding */ log)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _nice_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nice.js */ "../../node_modules/d3-scale/src/nice.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(u, v, n);
    } else {
      z = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.format)(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain((0,_nice_js__WEBPACK_IMPORTED_MODULE_2__.default)(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_3__.transformer)()).domain([1, 10]);

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_3__.copy)(scale, log()).base(scale.base());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_4__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/nice.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-scale/src/nice.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nice)
/* harmony export */ });
function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/number.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-scale/src/number.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number)
/* harmony export */ });
function number(x) {
  return +x;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/ordinal.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-scale/src/ordinal.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "implicit": () => (/* binding */ implicit),
/* harmony export */   "default": () => (/* binding */ ordinal)
/* harmony export */ });
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");


const implicit = Symbol("implicit");

function ordinal() {
  var index = new Map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new Map();
    for (const value of _) {
      const key = value + "";
      if (index.has(key)) continue;
      index.set(key, domain.push(value));
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init_js__WEBPACK_IMPORTED_MODULE_0__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/pow.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-scale/src/pow.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "powish": () => (/* binding */ powish),
/* harmony export */   "default": () => (/* binding */ pow),
/* harmony export */   "sqrt": () => (/* binding */ sqrt)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}

function pow() {
  var scale = powish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, pow()).exponent(scale.exponent());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/quantile.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-scale/src/quantile.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ascending.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.quantileSorted)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_2__.default);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/quantize.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-scale/src/quantize.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantize)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply((0,_linear_js__WEBPACK_IMPORTED_MODULE_2__.linearish)(scale), arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/sequential.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-scale/src/sequential.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "default": () => (/* binding */ sequential),
/* harmony export */   "sequentialLog": () => (/* binding */ sequentialLog),
/* harmony export */   "sequentialSymlog": () => (/* binding */ sequentialSymlog),
/* harmony export */   "sequentialPow": () => (/* binding */ sequentialPow),
/* harmony export */   "sequentialSqrt": () => (/* binding */ sequentialSqrt)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./log.js */ "../../node_modules/d3-scale/src/log.js");
/* harmony import */ var _symlog_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symlog.js */ "../../node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pow.js */ "../../node_modules/d3-scale/src/pow.js");








function transformer() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity,
      clamp = false,
      unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }

  scale.range = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.default);

  scale.rangeRound = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.default);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = (0,_linear_js__WEBPACK_IMPORTED_MODULE_3__.linearish)(transformer()(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity));

  scale.copy = function() {
    return copy(scale, sequential());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = (0,_log_js__WEBPACK_IMPORTED_MODULE_5__.loggish)(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, sequentialLog()).base(scale.base());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = (0,_symlog_js__WEBPACK_IMPORTED_MODULE_6__.symlogish)(transformer());

  scale.copy = function() {
    return copy(scale, sequentialSymlog()).constant(scale.constant());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = (0,_pow_js__WEBPACK_IMPORTED_MODULE_7__.powish)(transformer());

  scale.copy = function() {
    return copy(scale, sequentialPow()).exponent(scale.exponent());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/symlog.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-scale/src/symlog.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "symlogish": () => (/* binding */ symlogish),
/* harmony export */   "default": () => (/* binding */ symlog)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");




function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_0__.linearish)(scale);
}

function symlog() {
  var scale = symlogish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_1__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_1__.copy)(scale, symlog()).constant(scale.constant());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/threshold.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-scale/src/threshold.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ threshold)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/tickFormat.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-scale/src/tickFormat.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tickFormat)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionFixed.js");



function tickFormat(start, stop, count, specifier) {
  var step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start, stop, count),
      precision;
  specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.default)(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(step, value))) specifier.precision = precision;
      return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.formatPrefix)(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.default)(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__.default)(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.format)(specifier);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/time.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-scale/src/time.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calendar": () => (/* binding */ calendar),
/* harmony export */   "default": () => (/* binding */ time)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/ticks.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/month.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/hour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/minute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-time-format */ "../../node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");
/* harmony import */ var _nice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nice.js */ "../../node_modules/d3-scale/src/nice.js");






function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.default)(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain((0,_nice_js__WEBPACK_IMPORTED_MODULE_1__.default)(d, interval)) : scale;
  };

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };

  return scale;
}

function time() {
  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(calendar(d3_time__WEBPACK_IMPORTED_MODULE_3__.timeTicks, d3_time__WEBPACK_IMPORTED_MODULE_3__.timeTickInterval, d3_time__WEBPACK_IMPORTED_MODULE_4__.default, d3_time__WEBPACK_IMPORTED_MODULE_5__.default, d3_time__WEBPACK_IMPORTED_MODULE_6__.sunday, d3_time__WEBPACK_IMPORTED_MODULE_7__.default, d3_time__WEBPACK_IMPORTED_MODULE_8__.default, d3_time__WEBPACK_IMPORTED_MODULE_9__.default, d3_time__WEBPACK_IMPORTED_MODULE_10__.default, d3_time_format__WEBPACK_IMPORTED_MODULE_11__.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/utcTime.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-scale/src/utcTime.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ utcTime)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/ticks.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcYear.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcHour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time-format */ "../../node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./time.js */ "../../node_modules/d3-scale/src/time.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");





function utcTime() {
  return _init_js__WEBPACK_IMPORTED_MODULE_0__.initRange.apply((0,_time_js__WEBPACK_IMPORTED_MODULE_1__.calendar)(d3_time__WEBPACK_IMPORTED_MODULE_2__.utcTicks, d3_time__WEBPACK_IMPORTED_MODULE_2__.utcTickInterval, d3_time__WEBPACK_IMPORTED_MODULE_3__.default, d3_time__WEBPACK_IMPORTED_MODULE_4__.default, d3_time__WEBPACK_IMPORTED_MODULE_5__.utcSunday, d3_time__WEBPACK_IMPORTED_MODULE_6__.default, d3_time__WEBPACK_IMPORTED_MODULE_7__.default, d3_time__WEBPACK_IMPORTED_MODULE_8__.default, d3_time__WEBPACK_IMPORTED_MODULE_9__.default, d3_time_format__WEBPACK_IMPORTED_MODULE_10__.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}


/***/ }),

/***/ "../../node_modules/d3-time-format/src/defaultLocale.js":
/*!**************************************************************!*\
  !*** ../../node_modules/d3-time-format/src/defaultLocale.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timeFormat": () => (/* binding */ timeFormat),
/* harmony export */   "timeParse": () => (/* binding */ timeParse),
/* harmony export */   "utcFormat": () => (/* binding */ utcFormat),
/* harmony export */   "utcParse": () => (/* binding */ utcParse),
/* harmony export */   "default": () => (/* binding */ defaultLocale)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "../../node_modules/d3-time-format/src/locale.js");


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__.default)(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}


/***/ }),

/***/ "../../node_modules/d3-time-format/src/locale.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-time-format/src/locale.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatLocale)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcYear.js");


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.ceil(week) : (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_1__.default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.ceil(week) : (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.monday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_3__.default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_3__.default.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d), d) + ((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_1__.default.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcSunday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d), d) + ((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}


/***/ }),

/***/ "../../node_modules/d3-time/src/day.js":
/*!*********************************************!*\
  !*** ../../node_modules/d3-time/src/day.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "days": () => (/* binding */ days)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var day = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(
  date => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay,
  date => date.getDate() - 1
);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (day);
var days = day.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/duration.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-time/src/duration.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "durationSecond": () => (/* binding */ durationSecond),
/* harmony export */   "durationMinute": () => (/* binding */ durationMinute),
/* harmony export */   "durationHour": () => (/* binding */ durationHour),
/* harmony export */   "durationDay": () => (/* binding */ durationDay),
/* harmony export */   "durationWeek": () => (/* binding */ durationWeek),
/* harmony export */   "durationMonth": () => (/* binding */ durationMonth),
/* harmony export */   "durationYear": () => (/* binding */ durationYear)
/* harmony export */ });
const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;


/***/ }),

/***/ "../../node_modules/d3-time/src/hour.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-time/src/hour.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "hours": () => (/* binding */ hours)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var hour = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond - date.getMinutes() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour;
}, function(date) {
  return date.getHours();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hour);
var hours = hour.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/interval.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-time/src/interval.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ newInterval)
/* harmony export */ });
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),

/***/ "../../node_modules/d3-time/src/millisecond.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-time/src/millisecond.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "milliseconds": () => (/* binding */ milliseconds)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var millisecond = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (millisecond);
var milliseconds = millisecond.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/minute.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-time/src/minute.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "minutes": () => (/* binding */ minutes)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var minute = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute;
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (minute);
var minutes = minute.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/month.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-time/src/month.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "months": () => (/* binding */ months)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var month = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (month);
var months = month.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/second.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-time/src/second.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "seconds": () => (/* binding */ seconds)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var second = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (second);
var seconds = second.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/ticks.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-time/src/ticks.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcTicks": () => (/* binding */ utcTicks),
/* harmony export */   "utcTickInterval": () => (/* binding */ utcTickInterval),
/* harmony export */   "timeTicks": () => (/* binding */ timeTicks),
/* harmony export */   "timeTickInterval": () => (/* binding */ timeTickInterval)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisector.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");
/* harmony import */ var _millisecond_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./millisecond.js */ "../../node_modules/d3-time/src/millisecond.js");
/* harmony import */ var _second_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./second.js */ "../../node_modules/d3-time/src/second.js");
/* harmony import */ var _minute_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./minute.js */ "../../node_modules/d3-time/src/minute.js");
/* harmony import */ var _hour_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hour.js */ "../../node_modules/d3-time/src/hour.js");
/* harmony import */ var _day_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./day.js */ "../../node_modules/d3-time/src/day.js");
/* harmony import */ var _week_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./week.js */ "../../node_modules/d3-time/src/week.js");
/* harmony import */ var _month_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./month.js */ "../../node_modules/d3-time/src/month.js");
/* harmony import */ var _year_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./year.js */ "../../node_modules/d3-time/src/year.js");
/* harmony import */ var _utcMinute_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utcMinute.js */ "../../node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var _utcHour_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utcHour.js */ "../../node_modules/d3-time/src/utcHour.js");
/* harmony import */ var _utcDay_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utcDay.js */ "../../node_modules/d3-time/src/utcDay.js");
/* harmony import */ var _utcWeek_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utcWeek.js */ "../../node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var _utcMonth_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utcMonth.js */ "../../node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var _utcYear_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utcYear.js */ "../../node_modules/d3-time/src/utcYear.js");

















function ticker(year, month, week, day, hour, minute) {

  const tickIntervals = [
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default,  5,  5 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default, 15, 15 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default, 30, 30 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [minute,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [minute,  5,  5 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [minute, 15, 15 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [minute, 30, 30 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [  hour,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [  hour,  3,  3 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [  hour,  6,  6 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [  hour, 12, 12 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [   day,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay   ],
    [   day,  2,  2 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay   ],
    [  week,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek  ],
    [ month,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMonth ],
    [ month,  3,  3 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMonth ],
    [  year,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationYear  ]
  ];

  function ticks(start, stop, count) {
    const reverse = stop < start;
    if (reverse) [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
    return reverse ? ticks.reverse() : ticks;
  }

  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(([,, step]) => step).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every((0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationYear, stop / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationYear, count));
    if (i === 0) return _millisecond_js__WEBPACK_IMPORTED_MODULE_4__.default.every(Math.max((0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }

  return [ticks, tickInterval];
}

const [utcTicks, utcTickInterval] = ticker(_utcYear_js__WEBPACK_IMPORTED_MODULE_5__.default, _utcMonth_js__WEBPACK_IMPORTED_MODULE_6__.default, _utcWeek_js__WEBPACK_IMPORTED_MODULE_7__.utcSunday, _utcDay_js__WEBPACK_IMPORTED_MODULE_8__.default, _utcHour_js__WEBPACK_IMPORTED_MODULE_9__.default, _utcMinute_js__WEBPACK_IMPORTED_MODULE_10__.default);
const [timeTicks, timeTickInterval] = ticker(_year_js__WEBPACK_IMPORTED_MODULE_11__.default, _month_js__WEBPACK_IMPORTED_MODULE_12__.default, _week_js__WEBPACK_IMPORTED_MODULE_13__.sunday, _day_js__WEBPACK_IMPORTED_MODULE_14__.default, _hour_js__WEBPACK_IMPORTED_MODULE_15__.default, _minute_js__WEBPACK_IMPORTED_MODULE_16__.default);




/***/ }),

/***/ "../../node_modules/d3-time/src/utcDay.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-time/src/utcDay.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcDays": () => (/* binding */ utcDays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var utcDay = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcDay);
var utcDays = utcDay.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcHour.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-time/src/utcHour.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcHours": () => (/* binding */ utcHours)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var utcHour = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour;
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcHour);
var utcHours = utcHour.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcMinute.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-time/src/utcMinute.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcMinutes": () => (/* binding */ utcMinutes)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var utcMinute = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcMonth.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-time/src/utcMonth.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcMonths": () => (/* binding */ utcMonths)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var utcMonth = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcWeek.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-time/src/utcWeek.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcSunday": () => (/* binding */ utcSunday),
/* harmony export */   "utcMonday": () => (/* binding */ utcMonday),
/* harmony export */   "utcTuesday": () => (/* binding */ utcTuesday),
/* harmony export */   "utcWednesday": () => (/* binding */ utcWednesday),
/* harmony export */   "utcThursday": () => (/* binding */ utcThursday),
/* harmony export */   "utcFriday": () => (/* binding */ utcFriday),
/* harmony export */   "utcSaturday": () => (/* binding */ utcSaturday),
/* harmony export */   "utcSundays": () => (/* binding */ utcSundays),
/* harmony export */   "utcMondays": () => (/* binding */ utcMondays),
/* harmony export */   "utcTuesdays": () => (/* binding */ utcTuesdays),
/* harmony export */   "utcWednesdays": () => (/* binding */ utcWednesdays),
/* harmony export */   "utcThursdays": () => (/* binding */ utcThursdays),
/* harmony export */   "utcFridays": () => (/* binding */ utcFridays),
/* harmony export */   "utcSaturdays": () => (/* binding */ utcSaturdays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



function utcWeekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcYear.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-time/src/utcYear.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcYears": () => (/* binding */ utcYears)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var utcYear = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcYear);
var utcYears = utcYear.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/week.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-time/src/week.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sunday": () => (/* binding */ sunday),
/* harmony export */   "monday": () => (/* binding */ monday),
/* harmony export */   "tuesday": () => (/* binding */ tuesday),
/* harmony export */   "wednesday": () => (/* binding */ wednesday),
/* harmony export */   "thursday": () => (/* binding */ thursday),
/* harmony export */   "friday": () => (/* binding */ friday),
/* harmony export */   "saturday": () => (/* binding */ saturday),
/* harmony export */   "sundays": () => (/* binding */ sundays),
/* harmony export */   "mondays": () => (/* binding */ mondays),
/* harmony export */   "tuesdays": () => (/* binding */ tuesdays),
/* harmony export */   "wednesdays": () => (/* binding */ wednesdays),
/* harmony export */   "thursdays": () => (/* binding */ thursdays),
/* harmony export */   "fridays": () => (/* binding */ fridays),
/* harmony export */   "saturdays": () => (/* binding */ saturdays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



function weekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/year.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-time/src/year.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "years": () => (/* binding */ years)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var year = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (year);
var years = year.range;


/***/ }),

/***/ "../../node_modules/d3-timer/src/interval.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-timer/src/interval.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "../../node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  t._restart = t.restart;
  t.restart = function(callback, delay, time) {
    delay = +delay, time = time == null ? (0,_timer_js__WEBPACK_IMPORTED_MODULE_0__.now)() : +time;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
  }
  t.restart(callback, delay, time);
  return t;
}


/***/ }),

/***/ "../../node_modules/d3-timer/src/timer.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-timer/src/timer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "Timer": () => (/* binding */ Timer),
/* harmony export */   "timer": () => (/* binding */ timer),
/* harmony export */   "timerFlush": () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "../../node_modules/delaunator/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/delaunator/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Delaunator)
/* harmony export */ });

const EPSILON = Math.pow(2, -52);
const EDGE_STACK = new Uint32Array(512);

class Delaunator {

    static from(points, getX = defaultGetX, getY = defaultGetY) {
        const n = points.length;
        const coords = new Float64Array(n * 2);

        for (let i = 0; i < n; i++) {
            const p = points[i];
            coords[2 * i] = getX(p);
            coords[2 * i + 1] = getY(p);
        }

        return new Delaunator(coords);
    }

    constructor(coords) {
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

        this.coords = coords;

        // arrays that will store the triangulation graph
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);

        // temporary arrays for tracking the edges of the advancing convex hull
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n); // edge to prev edge
        this._hullNext = new Uint32Array(n); // edge to next edge
        this._hullTri = new Uint32Array(n); // edge to adjacent triangle
        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

        // temporary arrays for sorting points
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);

        this.update();
    }

    update() {
        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
        const n = coords.length >> 1;

        // populate an array of point indices; calculate input data bbox
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        for (let i = 0; i < n; i++) {
            const x = coords[2 * i];
            const y = coords[2 * i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            this._ids[i] = i;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;

        let minDist = Infinity;
        let i0, i1, i2;

        // pick a seed point close to the center
        for (let i = 0; i < n; i++) {
            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist) {
                i0 = i;
                minDist = d;
            }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];

        minDist = Infinity;

        // find the point closest to the seed
        for (let i = 0; i < n; i++) {
            if (i === i0) continue;
            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist && d > 0) {
                i1 = i;
                minDist = d;
            }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];

        let minRadius = Infinity;

        // find the third point which forms the smallest circumcircle with the first two
        for (let i = 0; i < n; i++) {
            if (i === i0 || i === i1) continue;
            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
            if (r < minRadius) {
                i2 = i;
                minRadius = r;
            }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];

        if (minRadius === Infinity) {
            // order collinear points by dx (or dy if all x are identical)
            // and return the list as a hull
            for (let i = 0; i < n; i++) {
                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
            }
            quicksort(this._ids, this._dists, 0, n - 1);
            const hull = new Uint32Array(n);
            let j = 0;
            for (let i = 0, d0 = -Infinity; i < n; i++) {
                const id = this._ids[i];
                if (this._dists[id] > d0) {
                    hull[j++] = id;
                    d0 = this._dists[id];
                }
            }
            this.hull = hull.subarray(0, j);
            this.triangles = new Uint32Array(0);
            this.halfedges = new Uint32Array(0);
            return;
        }

        // swap the order of the seed points for counter-clockwise orientation
        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
            const i = i1;
            const x = i1x;
            const y = i1y;
            i1 = i2;
            i1x = i2x;
            i1y = i2y;
            i2 = i;
            i2x = x;
            i2y = y;
        }

        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center.x;
        this._cy = center.y;

        for (let i = 0; i < n; i++) {
            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
        }

        // sort the points by distance from the seed triangle circumcenter
        quicksort(this._ids, this._dists, 0, n - 1);

        // set up the seed triangle as the starting hull
        this._hullStart = i0;
        let hullSize = 3;

        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;

        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;

        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;

        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);

        for (let k = 0, xp, yp; k < this._ids.length; k++) {
            const i = this._ids[k];
            const x = coords[2 * i];
            const y = coords[2 * i + 1];

            // skip near-duplicate points
            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
            xp = x;
            yp = y;

            // skip seed triangle points
            if (i === i0 || i === i1 || i === i2) continue;

            // find a visible edge on the convex hull using edge hash
            let start = 0;
            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                start = hullHash[(key + j) % this._hashSize];
                if (start !== -1 && start !== hullNext[start]) break;
            }

            start = hullPrev[start];
            let e = start, q;
            while (q = hullNext[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
                e = q;
                if (e === start) {
                    e = -1;
                    break;
                }
            }
            if (e === -1) continue; // likely a near-duplicate point; skip it

            // add the first triangle from the point
            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

            // recursively flip triangles from the point until they satisfy the Delaunay condition
            hullTri[i] = this._legalize(t + 2);
            hullTri[e] = t; // keep track of boundary triangles on the hull
            hullSize++;

            // walk forward through the hull, adding more triangles and flipping recursively
            let n = hullNext[e];
            while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1])) {
                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                hullTri[i] = this._legalize(t + 2);
                hullNext[n] = n; // mark as removed
                hullSize--;
                n = q;
            }

            // walk backward from the other side, adding more triangles and flipping
            if (e === start) {
                while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                    this._legalize(t + 2);
                    hullTri[q] = t;
                    hullNext[e] = e; // mark as removed
                    hullSize--;
                    e = q;
                }
            }

            // update the hull indices
            this._hullStart = hullPrev[i] = e;
            hullNext[e] = hullPrev[n] = i;
            hullNext[i] = n;

            // save the two new edges in the hash table
            hullHash[this._hashKey(x, y)] = i;
            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
        }

        this.hull = new Uint32Array(hullSize);
        for (let i = 0, e = this._hullStart; i < hullSize; i++) {
            this.hull[i] = e;
            e = hullNext[e];
        }

        // trim typed triangle mesh arrays
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }

    _hashKey(x, y) {
        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
    }

    _legalize(a) {
        const {_triangles: triangles, _halfedges: halfedges, coords} = this;

        let i = 0;
        let ar = 0;

        // recursion eliminated with a fixed-size stack
        while (true) {
            const b = halfedges[a];

            /* if the pair of triangles doesn't satisfy the Delaunay condition
             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
             * then do the same check/flip recursively for the new pair of triangles
             *
             *           pl                    pl
             *          /||\                  /  \
             *       al/ || \bl            al/    \a
             *        /  ||  \              /      \
             *       /  a||b  \    flip    /___ar___\
             *     p0\   ||   /p1   =>   p0\---bl---/p1
             *        \  ||  /              \      /
             *       ar\ || /br             b\    /br
             *          \||/                  \  /
             *           pr                    pr
             */
            const a0 = a - a % 3;
            ar = a0 + (a + 2) % 3;

            if (b === -1) { // convex hull edge
                if (i === 0) break;
                a = EDGE_STACK[--i];
                continue;
            }

            const b0 = b - b % 3;
            const al = a0 + (a + 1) % 3;
            const bl = b0 + (b + 2) % 3;

            const p0 = triangles[ar];
            const pr = triangles[a];
            const pl = triangles[al];
            const p1 = triangles[bl];

            const illegal = inCircle(
                coords[2 * p0], coords[2 * p0 + 1],
                coords[2 * pr], coords[2 * pr + 1],
                coords[2 * pl], coords[2 * pl + 1],
                coords[2 * p1], coords[2 * p1 + 1]);

            if (illegal) {
                triangles[a] = p1;
                triangles[b] = p0;

                const hbl = halfedges[bl];

                // edge swapped on the other side of the hull (rare); fix the halfedge reference
                if (hbl === -1) {
                    let e = this._hullStart;
                    do {
                        if (this._hullTri[e] === bl) {
                            this._hullTri[e] = a;
                            break;
                        }
                        e = this._hullPrev[e];
                    } while (e !== this._hullStart);
                }
                this._link(a, hbl);
                this._link(b, halfedges[ar]);
                this._link(ar, bl);

                const br = b0 + (b + 1) % 3;

                // don't worry about hitting the cap: it can only happen on extremely degenerate input
                if (i < EDGE_STACK.length) {
                    EDGE_STACK[i++] = br;
                }
            } else {
                if (i === 0) break;
                a = EDGE_STACK[--i];
            }
        }

        return ar;
    }

    _link(a, b) {
        this._halfedges[a] = b;
        if (b !== -1) this._halfedges[b] = a;
    }

    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(i0, i1, i2, a, b, c) {
        const t = this.trianglesLen;

        this._triangles[t] = i0;
        this._triangles[t + 1] = i1;
        this._triangles[t + 2] = i2;

        this._link(t, a);
        this._link(t + 1, b);
        this._link(t + 2, c);

        this.trianglesLen += 3;

        return t;
    }
}

// monotonically increases with real angle, but doesn't need expensive trigonometry
function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
}

function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
}

// return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check
function orientIfSure(px, py, rx, ry, qx, qy) {
    const l = (ry - py) * (qx - px);
    const r = (rx - px) * (qy - py);
    return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;
}

// a more robust orientation test that's stable in a given triangle (to fix robustness issues)
function orient(rx, ry, qx, qy, px, py) {
    const sign = orientIfSure(px, py, rx, ry, qx, qy) ||
    orientIfSure(rx, ry, qx, qy, px, py) ||
    orientIfSure(qx, qy, px, py, rx, ry);
    return sign < 0;
}

function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;

    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;

    return dx * (ey * cp - bp * fy) -
           dy * (ex * cp - bp * fx) +
           ap * (ex * fy - ey * fx) < 0;
}

function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = (ey * bl - dy * cl) * d;
    const y = (dx * cl - ex * bl) * d;

    return x * x + y * y;
}

function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = ax + (ey * bl - dy * cl) * d;
    const y = ay + (dx * cl - ex * bl) * d;

    return {x, y};
}

function quicksort(ids, dists, left, right) {
    if (right - left <= 20) {
        for (let i = left + 1; i <= right; i++) {
            const temp = ids[i];
            const tempDist = dists[temp];
            let j = i - 1;
            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
            ids[j + 1] = temp;
        }
    } else {
        const median = (left + right) >> 1;
        let i = left + 1;
        let j = right;
        swap(ids, median, i);
        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

        const temp = ids[i];
        const tempDist = dists[temp];
        while (true) {
            do i++; while (dists[ids[i]] < tempDist);
            do j--; while (dists[ids[j]] > tempDist);
            if (j < i) break;
            swap(ids, i, j);
        }
        ids[left + 1] = ids[j];
        ids[j] = temp;

        if (right - i + 1 >= j - left) {
            quicksort(ids, dists, i, right);
            quicksort(ids, dists, left, j - 1);
        } else {
            quicksort(ids, dists, left, j - 1);
            quicksort(ids, dists, i, right);
        }
    }
}

function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultGetX(p) {
    return p[0];
}
function defaultGetY(p) {
    return p[1];
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/bbox.js":
/*!******************************************************!*\
  !*** ../../node_modules/topojson-client/src/bbox.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ "../../node_modules/topojson-client/src/transform.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  var t = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.default)(topology.transform), key,
      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/bisect.js":
/*!********************************************************!*\
  !*** ../../node_modules/topojson-client/src/bisect.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/feature.js":
/*!*********************************************************!*\
  !*** ../../node_modules/topojson-client/src/feature.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "object": () => (/* binding */ object)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "../../node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "../../node_modules/topojson-client/src/transform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature(topology, o); })}
      : feature(topology, o);
}

function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.default)(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0) (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__.default)(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/identity.js":
/*!**********************************************************!*\
  !*** ../../node_modules/topojson-client/src/identity.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/topojson-client/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bbox": () => (/* reexport safe */ _bbox_js__WEBPACK_IMPORTED_MODULE_0__.default),
/* harmony export */   "feature": () => (/* reexport safe */ _feature_js__WEBPACK_IMPORTED_MODULE_1__.default),
/* harmony export */   "mesh": () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.default),
/* harmony export */   "meshArcs": () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.meshArcs),
/* harmony export */   "merge": () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.default),
/* harmony export */   "mergeArcs": () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.mergeArcs),
/* harmony export */   "neighbors": () => (/* reexport safe */ _neighbors_js__WEBPACK_IMPORTED_MODULE_4__.default),
/* harmony export */   "quantize": () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_5__.default),
/* harmony export */   "transform": () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_6__.default),
/* harmony export */   "untransform": () => (/* reexport safe */ _untransform_js__WEBPACK_IMPORTED_MODULE_7__.default)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "../../node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ "../../node_modules/topojson-client/src/feature.js");
/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh.js */ "../../node_modules/topojson-client/src/mesh.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge.js */ "../../node_modules/topojson-client/src/merge.js");
/* harmony import */ var _neighbors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./neighbors.js */ "../../node_modules/topojson-client/src/neighbors.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quantize.js */ "../../node_modules/topojson-client/src/quantize.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transform.js */ "../../node_modules/topojson-client/src/transform.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./untransform.js */ "../../node_modules/topojson-client/src/untransform.js");










/***/ }),

/***/ "../../node_modules/topojson-client/src/merge.js":
/*!*******************************************************!*\
  !*** ../../node_modules/topojson-client/src/merge.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mergeArcs": () => (/* binding */ mergeArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "../../node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "../../node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea((0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__.default)(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/mesh.js":
/*!******************************************************!*\
  !*** ../../node_modules/topojson-client/src/mesh.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "meshArcs": () => (/* binding */ meshArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "../../node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "../../node_modules/topojson-client/src/stitch.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__.default)(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/neighbors.js":
/*!***********************************************************!*\
  !*** ../../node_modules/topojson-client/src/neighbors.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bisect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect.js */ "../../node_modules/topojson-client/src/bisect.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__.default)(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__.default)(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/quantize.js":
/*!**********************************************************!*\
  !*** ../../node_modules/topojson-client/src/quantize.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "../../node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./untransform.js */ "../../node_modules/topojson-client/src/untransform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
    box = topology.bbox || (0,_bbox_js__WEBPACK_IMPORTED_MODULE_0__.default)(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
  } else {
    box = topology.bbox;
  }

  var t = (0,_untransform_js__WEBPACK_IMPORTED_MODULE_1__.default)(transform), box, key, inputs = topology.objects, outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
      case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
      case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
      default: return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
    output[0] = t(input[0], 0);
    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
    output.length = j;
    return output;
  }

  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/reverse.js":
/*!*********************************************************!*\
  !*** ../../node_modules/topojson-client/src/reverse.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/stitch.js":
/*!********************************************************!*\
  !*** ../../node_modules/topojson-client/src/stitch.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/transform.js":
/*!***********************************************************!*\
  !*** ../../node_modules/topojson-client/src/transform.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "../../node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__.default;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/untransform.js":
/*!*************************************************************!*\
  !*** ../../node_modules/topojson-client/src/untransform.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "../../node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__.default;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "../../node_modules/vega-canvas/index.browser.js":
/*!*******************************************************!*\
  !*** ../../node_modules/vega-canvas/index.browser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "domCanvas": () => (/* reexport safe */ _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__.domCanvas),
/* harmony export */   "canvas": () => (/* reexport safe */ _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__.domCanvas),
/* harmony export */   "image": () => (/* reexport safe */ _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__.domImage)
/* harmony export */ });
/* harmony import */ var _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/domCanvas */ "../../node_modules/vega-canvas/src/domCanvas.js");



/***/ }),

/***/ "../../node_modules/vega-canvas/src/domCanvas.js":
/*!*******************************************************!*\
  !*** ../../node_modules/vega-canvas/src/domCanvas.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "domCanvas": () => (/* binding */ domCanvas),
/* harmony export */   "domImage": () => (/* binding */ domImage)
/* harmony export */ });
function domCanvas(w, h) {
  if (typeof document !== 'undefined' && document.createElement) {
    const c = document.createElement('canvas');
    if (c && c.getContext) {
      c.width = w;
      c.height = h;
      return c;
    }
  }
  return null;
}

const domImage = () =>
  typeof Image !== 'undefined' ? Image : null;


/***/ }),

/***/ "../../node_modules/vega-crossfilter/build/vega-crossfilter.module.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/vega-crossfilter/build/vega-crossfilter.module.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "crossfilter": () => (/* binding */ CrossFilter),
/* harmony export */   "resolvefilter": () => (/* binding */ ResolveFilter)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/permute.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");




const array8 = n => new Uint8Array(n);
const array16 = n => new Uint16Array(n);
const array32 = n => new Uint32Array(n);

/**
 * Maintains CrossFilter state.
 */

function Bitmaps() {
  let width = 8,
      data = [],
      seen = array32(0),
      curr = array(0, width),
      prev = array(0, width);
  return {
    data: () => data,
    seen: () => seen = lengthen(seen, data.length),

    add(array) {
      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {
        t = array[i];
        t._index = j++;
        data.push(t);
      }
    },

    remove(num, map) {
      // map: index -> boolean (true => remove)
      const n = data.length,
            copy = Array(n - num),
            reindex = data; // reuse old data array for index map

      let t, i, j; // seek forward to first removal

      for (i = 0; !map[i] && i < n; ++i) {
        copy[i] = data[i];
        reindex[i] = i;
      } // condense arrays


      for (j = i; i < n; ++i) {
        t = data[i];

        if (!map[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy[j] = t;
          t._index = j++;
        } else {
          reindex[i] = -1;
        }

        curr[i] = 0; // clear unused bits
      }

      data = copy;
      return reindex;
    },

    size: () => data.length,
    curr: () => curr,
    prev: () => prev,
    reset: k => prev[k] = curr[k],
    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,

    set(k, one) {
      curr[k] |= one;
    },

    clear(k, one) {
      curr[k] &= ~one;
    },

    resize(n, m) {
      const k = curr.length;

      if (n > k || m > width) {
        width = Math.max(m, width);
        curr = array(n, width, curr);
        prev = array(n, width);
      }
    }

  };
}

function lengthen(array, length, copy) {
  if (array.length >= length) return array;
  copy = copy || new array.constructor(length);
  copy.set(array);
  return copy;
}

function array(n, m, array) {
  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);
  if (array) copy.set(array);
  return copy;
}

function Dimension (index, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index.bisect,
    index: index.index,
    size: index.size,

    onAdd(added, curr) {
      const dim = this,
            range = dim.bisect(dim.range, added.value),
            idx = added.index,
            lo = range[0],
            hi = range[1],
            n1 = idx.length;
      let i;

      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;

      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;

      return dim;
    }

  };
}

/**
 * Maintains a list of values, sorted by key.
 */

function SortedIndex() {
  let index = array32(0),
      value = [],
      size = 0;

  function insert(key, data, base) {
    if (!data.length) return [];
    const n0 = size,
          n1 = data.length,
          addi = array32(n1);
    let addv = Array(n1),
        oldv,
        oldi,
        i;

    for (i = 0; i < n1; ++i) {
      addv[i] = key(data[i]);
      addi[i] = i;
    }

    addv = sort(addv, addi);

    if (n0) {
      oldv = value;
      oldi = index;
      value = Array(n0 + n1);
      index = array32(n0 + n1);
      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);
    } else {
      if (base > 0) for (i = 0; i < n1; ++i) {
        addi[i] += base;
      }
      value = addv;
      index = addi;
    }

    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }

  function remove(num, map) {
    // map: index -> remove
    const n = size;
    let idx, i, j; // seek forward to first removal

    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays


    for (j = i; i < n; ++i) {
      if (!map[idx = index[i]]) {
        index[j] = idx;
        value[j] = value[i];
        ++j;
      }
    }

    size = n - num;
  }

  function reindex(map) {
    for (let i = 0, n = size; i < n; ++i) {
      index[i] = map[index[i]];
    }
  }

  function bisect(range, array) {
    let n;

    if (array) {
      n = array.length;
    } else {
      array = value;
      n = size;
    }

    return [(0,d3_array__WEBPACK_IMPORTED_MODULE_2__.bisectLeft)(array, range[0], 0, n), (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.bisectRight)(array, range[1], 0, n)];
  }

  return {
    insert: insert,
    remove: remove,
    bisect: bisect,
    reindex: reindex,
    index: () => index,
    size: () => size
  };
}

function sort(values, index) {
  values.sort.call(index, (a, b) => {
    const x = values[a],
          y = values[b];
    return x < y ? -1 : x > y ? 1 : 0;
  });
  return (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(values, index);
}

function merge(base, value0, index0, n0, value1, index1, n1, value, index) {
  let i0 = 0,
      i1 = 0,
      i;

  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value[i] = value0[i0];
      index[i] = index0[i0++];
    } else {
      value[i] = value1[i1];
      index[i] = index1[i1++] + base;
    }
  }

  for (; i0 < n0; ++i0, ++i) {
    value[i] = value0[i0];
    index[i] = index0[i0];
  }

  for (; i1 < n1; ++i1, ++i) {
    value[i] = value1[i1];
    index[i] = index1[i1] + base;
  }
}

/**
 * An indexed multi-dimensional filter.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.
 * @param {Array} params.query - An array of per-dimension range queries.
 */

function CrossFilter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, Bitmaps(), params);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  'type': 'CrossFilter',
  'metadata': {},
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'query',
    'type': 'array',
    'array': true,
    'required': true,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(CrossFilter, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!this._dims) {
      return this.init(_, pulse);
    } else {
      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));

      return init ? this.reinit(_, pulse) : this.eval(_, pulse);
    }
  },

  init(_, pulse) {
    const fields = _.fields,
          query = _.query,
          indices = this._indices = {},
          dims = this._dims = [],
          m = query.length;
    let i = 0,
        key,
        index; // instantiate indices and dimensions

    for (; i < m; ++i) {
      key = fields[i].fname;
      index = indices[key] || (indices[key] = SortedIndex());
      dims.push(Dimension(index, i, query[i]));
    }

    return this.eval(_, pulse);
  },

  reinit(_, pulse) {
    const output = pulse.materialize().fork(),
          fields = _.fields,
          query = _.query,
          indices = this._indices,
          dims = this._dims,
          bits = this.value,
          curr = bits.curr(),
          prev = bits.prev(),
          all = bits.all(),
          out = output.rem = output.add,
          mod = output.mod,
          m = query.length,
          adds = {};
    let add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state

    prev.set(curr); // if pulse has remove tuples, process them first

    if (pulse.rem.length) {
      remMap = this.remove(_, pulse, output);
    } // if pulse has added tuples, add them to state


    if (pulse.add.length) {
      bits.add(pulse.add);
    } // if pulse has modified tuples, create an index map


    if (pulse.mod.length) {
      modMap = {};

      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    } // re-initialize indices as needed, update curr bitmap


    for (i = 0; i < m; ++i) {
      f = fields[i];

      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {
        key = f.fname;

        if (!(add = adds[key])) {
          indices[key] = index = SortedIndex();
          adds[key] = add = index.insert(f, pulse.source, 0);
        }

        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);
      }
    } // visit each tuple
    // if filter state changed, push index to add/rem
    // else if in mod and passes a filter, push index to mod


    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        // skip if removed tuple
        continue;
      } else if (prev[i] !== curr[i]) {
        // add if state changed
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        // otherwise, pass mods through
        mod.push(i);
      }
    }

    bits.mask = (1 << m) - 1;
    return output;
  },

  eval(_, pulse) {
    const output = pulse.materialize().fork(),
          m = this._dims.length;
    let mask = 0;

    if (pulse.rem.length) {
      this.remove(_, pulse, output);
      mask |= (1 << m) - 1;
    }

    if (_.modified('query') && !_.modified('fields')) {
      mask |= this.update(_, pulse, output);
    }

    if (pulse.add.length) {
      this.insert(_, pulse, output);
      mask |= (1 << m) - 1;
    }

    if (pulse.mod.length) {
      this.modify(pulse, output);
      mask |= (1 << m) - 1;
    }

    this.value.mask = mask;
    return output;
  },

  insert(_, pulse, output) {
    const tuples = pulse.add,
          bits = this.value,
          dims = this._dims,
          indices = this._indices,
          fields = _.fields,
          adds = {},
          out = output.add,
          n = bits.size() + tuples.length,
          m = dims.length;
    let k = bits.size(),
        j,
        key,
        add; // resize bitmaps and add tuples as needed

    bits.resize(n, m);
    bits.add(tuples);
    const curr = bits.curr(),
          prev = bits.prev(),
          all = bits.all(); // add to dimensional indices

    for (j = 0; j < m; ++j) {
      key = fields[j].fname;
      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));
      dims[j].onAdd(add, curr);
    } // set previous filters, output if passes at least one filter


    for (; k < n; ++k) {
      prev[k] = all;
      if (curr[k] !== all) out.push(k);
    }
  },

  modify(pulse, output) {
    const out = output.mod,
          bits = this.value,
          curr = bits.curr(),
          all = bits.all(),
          tuples = pulse.mod;
    let i, n, k;

    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      if (curr[k] !== all) out.push(k);
    }
  },

  remove(_, pulse, output) {
    const indices = this._indices,
          bits = this.value,
          curr = bits.curr(),
          prev = bits.prev(),
          all = bits.all(),
          map = {},
          out = output.rem,
          tuples = pulse.rem;
    let i, n, k, f; // process tuples, output if passes at least one filter

    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      map[k] = 1; // build index map

      prev[k] = f = curr[k];
      curr[k] = all;
      if (f !== all) out.push(k);
    } // remove from dimensional indices


    for (k in indices) {
      indices[k].remove(n, map);
    }

    this.reindex(pulse, n, map);
    return map;
  },

  // reindex filters and indices after propagation completes
  reindex(pulse, num, map) {
    const indices = this._indices,
          bits = this.value;
    pulse.runAfter(() => {
      const indexMap = bits.remove(num, map);

      for (const key in indices) indices[key].reindex(indexMap);
    });
  },

  update(_, pulse, output) {
    const dims = this._dims,
          query = _.query,
          stamp = pulse.stamp,
          m = dims.length;
    let mask = 0,
        i,
        q; // survey how many queries have changed

    output.filters = 0;

    for (q = 0; q < m; ++q) {
      if (_.modified('query', q)) {
        i = q;
        ++mask;
      }
    }

    if (mask === 1) {
      // only one query changed, use more efficient update
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output.add, output.rem);
    } else {
      // multiple queries changed, perform full record keeping
      for (q = 0, mask = 0; q < m; ++q) {
        if (!_.modified('query', q)) continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output.add);
        output.rem = output.add; // duplicate add/rem for downstream resolve
      }
    }

    return mask;
  },

  incrementAll(dim, query, stamp, out) {
    const bits = this.value,
          seen = bits.seen(),
          curr = bits.curr(),
          prev = bits.prev(),
          index = dim.index(),
          old = dim.bisect(dim.range),
          range = dim.bisect(query),
          lo1 = range[0],
          hi1 = range[1],
          lo0 = old[0],
          hi0 = old[1],
          one = dim.one;
    let i, j, k; // Fast incremental update based on previous lo index.

    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    } // Fast incremental update based on previous hi index.


    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    }

    dim.range = query.slice();
  },

  incrementOne(dim, query, add, rem) {
    const bits = this.value,
          curr = bits.curr(),
          index = dim.index(),
          old = dim.bisect(dim.range),
          range = dim.bisect(query),
          lo1 = range[0],
          hi1 = range[1],
          lo0 = old[0],
          hi0 = old[1],
          one = dim.one;
    let i, j, k; // Fast incremental update based on previous lo index.

    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        add.push(k);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        rem.push(k);
      }
    } // Fast incremental update based on previous hi index.


    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        add.push(k);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        rem.push(k);
      }
    }

    dim.range = query.slice();
  }

});

/**
 * Selectively filters tuples by resolving against a filter bitmap.
 * Useful for processing the output of a cross-filter transform.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.ignore - A bit mask indicating which filters to ignore.
 * @param {object} params.filter - The per-tuple filter bitmaps. Typically this
 *   parameter value is a reference to a {@link CrossFilter} transform.
 */

function ResolveFilter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
ResolveFilter.Definition = {
  'type': 'ResolveFilter',
  'metadata': {},
  'params': [{
    'name': 'ignore',
    'type': 'number',
    'required': true,
    'description': 'A bit mask indicating which filters to ignore.'
  }, {
    'name': 'filter',
    'type': 'object',
    'required': true,
    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(ResolveFilter, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const ignore = ~(_.ignore || 0),
          // bit mask where zeros -> dims to ignore
    bitmap = _.filter,
          mask = bitmap.mask; // exit early if no relevant filter changes

    if ((mask & ignore) === 0) return pulse.StopPropagation;

    const output = pulse.fork(pulse.ALL),
          data = bitmap.data(),
          curr = bitmap.curr(),
          prev = bitmap.prev(),
          pass = k => !(curr[k] & ignore) ? data[k] : null; // propagate all mod tuples that pass the filter


    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions
    // for efficiency, we do *not* populate new arrays,
    // instead we add filter functions applied downstream

    if (!(mask & mask - 1)) {
      // only one filter changed
      output.filter(output.ADD, pass);
      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);
    } else {
      // multiple filters changed
      output.filter(output.ADD, k => {
        const c = curr[k] & ignore,
              f = !c && c ^ prev[k] & ignore;
        return f ? data[k] : null;
      });
      output.filter(output.REM, k => {
        const c = curr[k] & ignore,
              f = c && !(c ^ (c ^ prev[k] & ignore));
        return f ? data[k] : null;
      });
    } // add filter to source data in case of reflow...


    return output.filter(output.SOURCE, t => pass(t._index));
  }

});




/***/ }),

/***/ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/vega-dataflow/build/vega-dataflow.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dataflow": () => (/* binding */ Dataflow),
/* harmony export */   "EventStream": () => (/* binding */ EventStream),
/* harmony export */   "MultiPulse": () => (/* binding */ MultiPulse),
/* harmony export */   "Operator": () => (/* binding */ Operator),
/* harmony export */   "Parameters": () => (/* binding */ Parameters),
/* harmony export */   "Pulse": () => (/* binding */ Pulse),
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "UniqueList": () => (/* binding */ UniqueList),
/* harmony export */   "asyncCallback": () => (/* binding */ asyncCallback),
/* harmony export */   "changeset": () => (/* binding */ changeset),
/* harmony export */   "definition": () => (/* binding */ definition),
/* harmony export */   "derive": () => (/* binding */ derive),
/* harmony export */   "ingest": () => (/* binding */ ingest$1),
/* harmony export */   "isChangeSet": () => (/* binding */ isChangeSet),
/* harmony export */   "isTuple": () => (/* binding */ isTuple),
/* harmony export */   "rederive": () => (/* binding */ rederive),
/* harmony export */   "replace": () => (/* binding */ replace),
/* harmony export */   "stableCompare": () => (/* binding */ stableCompare),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transforms": () => (/* binding */ transforms),
/* harmony export */   "tupleid": () => (/* binding */ tupleid)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-loader */ "../../node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-format */ "../../node_modules/vega-format/build/vega-format.module.js");




function UniqueList(idFunc) {
  const $ = idFunc || vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,
        list = [],
        ids = {};

  list.add = _ => {
    const id = $(_);

    if (!ids[id]) {
      ids[id] = 1;
      list.push(_);
    }

    return list;
  };

  list.remove = _ => {
    const id = $(_);

    if (ids[id]) {
      ids[id] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0) list.splice(idx, 1);
    }

    return list;
  };

  return list;
}

/**
 * Invoke and await a potentially async callback function. If
 * an error occurs, trap it and route to Dataflow.error.
 * @param {Dataflow} df - The dataflow instance
 * @param {function} callback - A callback function to invoke
 *   and then await. The dataflow will be passed as the single
 *   argument to the function.
 */
async function asyncCallback (df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}

const TUPLE_ID_KEY = Symbol('vega_id');
let TUPLE_ID = 1;
/**
 * Checks if an input value is a registered tuple.
 * @param {*} t - The value to check.
 * @return {boolean} True if the input is a tuple, false otherwise.
 */

function isTuple(t) {
  return !!(t && tupleid(t));
}
/**
 * Returns the id of a tuple.
 * @param {object} t - The input tuple.
 * @return {*} the tuple id.
 */

function tupleid(t) {
  return t[TUPLE_ID_KEY];
}
/**
 * Sets the id of a tuple.
 * @param {object} t - The input tuple.
 * @param {*} id - The id value to set.
 * @return {object} the input tuple.
 */

function setid(t, id) {
  t[TUPLE_ID_KEY] = id;
  return t;
}
/**
 * Ingest an object or value as a data tuple.
 * If the input value is an object, an id field will be added to it. For
 * efficiency, the input object is modified directly. A copy is not made.
 * If the input value is a literal, it will be wrapped in a new object
 * instance, with the value accessible as the 'data' property.
 * @param datum - The value to ingest.
 * @return {object} The ingested data tuple.
 */


function ingest$1(datum) {
  const t = datum === Object(datum) ? datum : {
    data: datum
  };
  return tupleid(t) ? t : setid(t, TUPLE_ID++);
}
/**
 * Given a source tuple, return a derived copy.
 * @param {object} t - The source tuple.
 * @return {object} The derived tuple.
 */

function derive(t) {
  return rederive(t, ingest$1({}));
}
/**
 * Rederive a derived tuple by copying values from the source tuple.
 * @param {object} t - The source tuple.
 * @param {object} d - The derived tuple.
 * @return {object} The derived tuple.
 */

function rederive(t, d) {
  for (const k in t) d[k] = t[k];

  return d;
}
/**
 * Replace an existing tuple with a new tuple.
 * @param {object} t - The existing data tuple.
 * @param {object} d - The new tuple that replaces the old.
 * @return {object} The new tuple.
 */

function replace(t, d) {
  return setid(d, tupleid(t));
}
/**
 * Generate an augmented comparator function that provides stable
 * sorting by tuple id when the given comparator produces ties.
 * @param {function} cmp - The comparator to augment.
 * @param {function} [f] - Optional tuple accessor function.
 * @return {function} An augmented comparator function.
 */

function stableCompare(cmp, f) {
  return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);
}

function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add = [],
        // insert tuples
  rem = [],
        // remove tuples
  mod = [],
        // modify tuples
  remp = [],
        // remove by predicate
  modp = []; // modify by predicate

  let clean = null,
      reflow = false;
  return {
    constructor: changeset,

    insert(t) {
      const d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(t),
            n = d.length;

      for (let i = 0; i < n; ++i) add.push(d[i]);

      return this;
    },

    remove(t) {
      const a = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t) ? remp : rem,
            d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(t),
            n = d.length;

      for (let i = 0; i < n; ++i) a.push(d[i]);

      return this;
    },

    modify(t, field, value) {
      const m = {
        field: field,
        value: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(value)
      };

      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t)) {
        m.filter = t;
        modp.push(m);
      } else {
        m.tuple = t;
        mod.push(m);
      }

      return this;
    },

    encode(t, set) {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t)) modp.push({
        filter: t,
        field: set
      });else mod.push({
        tuple: t,
        field: set
      });
      return this;
    },

    clean(value) {
      clean = value;
      return this;
    },

    reflow() {
      reflow = true;
      return this;
    },

    pulse(pulse, tuples) {
      const cur = {},
            out = {};
      let i, n, m, f, t, id; // build lookup table of current tuples

      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      } // process individual tuples to remove


      for (i = 0, n = rem.length; i < n; ++i) {
        t = rem[i];
        cur[tupleid(t)] = -1;
      } // process predicate-based removals


      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach(t => {
          if (f(t)) cur[tupleid(t)] = -1;
        });
      } // process all add tuples


      for (i = 0, n = add.length; i < n; ++i) {
        t = add[i];
        id = tupleid(t);

        if (cur[id]) {
          // tuple already resides in dataset
          // if flagged for both add and remove, cancel
          cur[id] = 1;
        } else {
          // tuple does not reside in dataset, add
          pulse.add.push(ingest$1(add[i]));
        }
      } // populate pulse rem list


      for (i = 0, n = tuples.length; i < n; ++i) {
        t = tuples[i];
        if (cur[tupleid(t)] < 0) pulse.rem.push(t);
      } // modify helper method


      function modify(t, f, v) {
        if (v) {
          t[f] = v(t);
        } else {
          pulse.encode = f;
        }

        if (!reflow) out[tupleid(t)] = t;
      } // process individual tuples to modify


      for (i = 0, n = mod.length; i < n; ++i) {
        m = mod[i];
        t = m.tuple;
        f = m.field;
        id = cur[tupleid(t)];

        if (id > 0) {
          modify(t, f, m.value);
          pulse.modifies(f);
        }
      } // process predicate-based modifications


      for (i = 0, n = modp.length; i < n; ++i) {
        m = modp[i];
        f = m.filter;
        tuples.forEach(t => {
          if (f(t) && cur[tupleid(t)] > 0) {
            modify(t, m.field, m.value);
          }
        });
        pulse.modifies(m.field);
      } // upon reflow request, populate mod with all non-removed tuples
      // otherwise, populate mod with modified tuples only


      if (reflow) {
        pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();
      } else {
        for (id in out) pulse.mod.push(out[id]);
      } // set pulse garbage collection request


      if (clean || clean == null && (rem.length || remp.length)) {
        pulse.clean(true);
      }

      return pulse;
    }

  };
}

const CACHE = '_:mod:_';
/**
 * Hash that tracks modifications to assigned values.
 * Callers *must* use the set method to update values.
 */

function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(name, index, value, force) {
    const o = this,
          v = o[name],
          mod = o[CACHE];

    if (index != null && index >= 0) {
      if (v[index] !== value || force) {
        v[index] = value;
        mod[index + ':' + name] = -1;
        mod[name] = -1;
      }
    } else if (v !== value || force) {
      o[name] = value;
      mod[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? 1 + value.length : -1;
    }

    return o;
  },

  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(name, index) {
    const mod = this[CACHE];

    if (!arguments.length) {
      for (const k in mod) {
        if (mod[k]) return true;
      }

      return false;
    } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(name)) {
      for (let k = 0; k < name.length; ++k) {
        if (mod[name[k]]) return true;
      }

      return false;
    }

    return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];
  },

  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    this[CACHE] = {};
    return this;
  }

};

let OP_ID = 0;
const PULSE = 'pulse',
      NO_PARAMS = new Parameters(); // Boolean Flags

const SKIP$1 = 1,
      MODIFIED = 2;
/**
 * An Operator is a processing node in a dataflow graph.
 * Each operator stores a value and an optional value update function.
 * Operators can accept a hash of named parameters. Parameter values can
 * either be direct (JavaScript literals, arrays, objects) or indirect
 * (other operators whose values will be pulled dynamically). Operators
 * included as parameters will have this operator added as a dependency.
 * @constructor
 * @param {*} [init] - The initial value for this operator.
 * @param {function(object, Pulse)} [update] - An update function. Upon
 *   evaluation of this operator, the update function will be invoked and the
 *   return value will be used as the new value of this operator.
 * @param {object} [params] - The parameters for this operator.
 * @param {boolean} [react=true] - Flag indicating if this operator should
 *   listen for changes to upstream operators included as parameters.
 * @see parameters
 */

function Operator(init, update, params, react) {
  this.id = ++OP_ID;
  this.value = init;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;

  if (update) {
    this._update = update;
  }

  if (params) this.parameters(params, react);
}

function flag(bit) {
  return function (state) {
    const f = this.flags;
    if (arguments.length === 0) return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}

Operator.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id));
  },

  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(value) {
    if (this.value !== value) {
      this.value = value;
      return 1;
    } else {
      return 0;
    }
  },

  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: flag(SKIP$1),

  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: flag(MODIFIED),

  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initiatal evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(params, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(),
          argops = this._argops = this._argops || [],
          deps = [];
    let name, value, n, i;

    const add = (name, index, value) => {
      if (value instanceof Operator) {
        if (value !== this) {
          if (react) value.targets().add(this);
          deps.push(value);
        }

        argops.push({
          op: value,
          name: name,
          index: index
        });
      } else {
        argval.set(name, index, value);
      }
    };

    for (name in params) {
      value = params[name];

      if (name === PULSE) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(value).forEach(op => {
          if (!(op instanceof Operator)) {
            (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Pulse parameters must be operator instances.');
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value;
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
        argval.set(name, -1, Array(n = value.length));

        for (i = 0; i < n; ++i) add(name, i, value[i]);
      } else {
        add(name, -1, value);
      }
    }

    this.marshall().clear(); // initialize values

    if (initonly) argops.initonly = true;
    return deps;
  },

  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS,
          argops = this._argops;
    let item, i, op, mod;

    if (argops) {
      const n = argops.length;

      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }

      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }

        this._argops = null;
        this._update = null;
      }
    }

    return argval;
  },

  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const argops = this._argops;
    let i, n, item, op;

    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;

        if (op._targets) {
          op._targets.remove(this);
        }
      }
    } // remove references to the source and pulse object,
    // if present, to prevent memory leaks of old data.


    this.pulse = null;
    this.source = null;
  },

  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(pulse) {
    const update = this._update;

    if (update) {
      const params = this.marshall(pulse.stamp),
            v = update.call(this, params, pulse);
      params.clear();

      if (v !== this.value) {
        this.value = v;
      } else if (!this.modified()) {
        return pulse.StopPropagation;
      }
    }
  },

  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse) {
    if (pulse.stamp < this.stamp) return pulse.StopPropagation;
    let rv;

    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse);
    }

    return this.pulse = rv || pulse;
  }

};

/**
 * Add an operator to the dataflow graph. This function accepts a
 * variety of input argument types. The basic signature supports an
 * initial value, update function and parameters. If the first parameter
 * is an Operator instance, it will be added directly. If it is a
 * constructor for an Operator subclass, a new instance will be instantiated.
 * Otherwise, if the first parameter is a function instance, it will be used
 * as the update function and a null initial value is assumed.
 * @param {*} init - One of: the operator to add, the initial value of
 *   the operator, an operator class to instantiate, or an update function.
 * @param {function} [update] - The operator update function.
 * @param {object} [params] - The operator parameters.
 * @param {boolean} [react=true] - Flag indicating if this operator should
 *   listen for changes to upstream operators included as parameters.
 * @return {Operator} - The added operator.
 */

function add (init, update, params, react) {
  let shift = 1,
      op;

  if (init instanceof Operator) {
    op = init;
  } else if (init && init.prototype instanceof Operator) {
    op = new init();
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(init)) {
    op = new Operator(null, init);
  } else {
    shift = 0;
    op = new Operator(init, update);
  }

  this.rank(op);

  if (shift) {
    react = params;
    params = update;
  }

  if (params) this.connect(op, op.parameters(params, react));
  this.touch(op);
  return op;
}

/**
 * Connect a target operator as a dependent of source operators.
 * If necessary, this method will rerank the target operator and its
 * dependents to ensure propagation proceeds in a topologically sorted order.
 * @param {Operator} target - The target operator.
 * @param {Array<Operator>} - The source operators that should propagate
 *   to the target operator.
 */
function connect (target, sources) {
  const targetRank = target.rank,
        n = sources.length;

  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target);
      return;
    }
  }
}

let STREAM_ID = 0;
/**
 * Models an event stream.
 * @constructor
 * @param {function(Object, number): boolean} [filter] - Filter predicate.
 *   Events pass through when truthy, events are suppressed when falsy.
 * @param {function(Object): *} [apply] - Applied to input events to produce
 *   new event values.
 * @param {function(Object)} [receive] - Event callback function to invoke
 *   upon receipt of a new event. Use to override standard event processing.
 */

function EventStream(filter, apply, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive) this.receive = receive;
  if (filter) this._filter = filter;
  if (apply) this._apply = apply;
}
/**
 * Creates a new event stream instance with the provided
 * (optional) filter, apply and receive functions.
 * @param {function(Object, number): boolean} [filter] - Filter predicate.
 *   Events pass through when truthy, events are suppressed when falsy.
 * @param {function(Object): *} [apply] - Applied to input events to produce
 *   new event values.
 * @see EventStream
 */

function stream(filter, apply, receive) {
  return new EventStream(filter, apply, receive);
}
EventStream.prototype = {
  _filter: vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy,
  _apply: vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,

  targets() {
    return this._targets || (this._targets = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id));
  },

  consume(_) {
    if (!arguments.length) return !!this._consume;
    this._consume = !!_;
    return this;
  },

  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt),
            trg = this._targets,
            n = trg ? trg.length : 0;

      for (let i = 0; i < n; ++i) trg[i].receive(val);

      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },

  filter(filter) {
    const s = stream(filter);
    this.targets().add(s);
    return s;
  },

  apply(apply) {
    const s = stream(null, apply);
    this.targets().add(s);
    return s;
  },

  merge() {
    const s = stream();
    this.targets().add(s);

    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s);
    }

    return s;
  },

  throttle(pause) {
    let t = -1;
    return this.filter(() => {
      const now = Date.now();

      if (now - t > pause) {
        t = now;
        return 1;
      } else {
        return 0;
      }
    });
  },

  debounce(delay) {
    const s = stream();
    this.targets().add(stream(null, null, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(delay, e => {
      const df = e.dataflow;
      s.receive(e);
      if (df && df.run) df.run();
    })));
    return s;
  },

  between(a, b) {
    let active = false;
    a.targets().add(stream(null, null, () => active = true));
    b.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },

  detach() {
    // ensures compatibility with operators (#2753)
    // remove references to other streams and filter functions that may
    // be bound to subcontexts that need to be garbage collected.
    this._filter = vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy;
    this._targets = null;
  }

};

/**
 * Create a new event stream from an event source.
 * @param {object} source - The event source to monitor. The input must
 *  support the addEventListener method.
 * @param {string} type - The event type.
 * @param {function(object): boolean} [filter] - Event filter function.
 * @param {function(object): *} [apply] - Event application function.
 *   If provided, this function will be invoked and the result will be
 *   used as the downstream event value.
 * @return {EventStream}
 */

function events (source, type, filter, apply) {
  const df = this,
        s = stream(filter, apply),
        send = function (e) {
    e.dataflow = df;

    try {
      s.receive(e);
    } catch (error) {
      df.error(error);
    } finally {
      df.run();
    }
  };

  let sources;

  if (typeof source === 'string' && typeof document !== 'undefined') {
    sources = document.querySelectorAll(source);
  } else {
    sources = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(source);
  }

  const n = sources.length;

  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type, send);
  }

  return s;
}

function parse(data, format) {
  const locale = this.locale();
  return (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.read)(data, format, locale.timeParse, locale.utcParse);
}
/**
 * Ingests new data into the dataflow. First parses the data using the
 * vega-loader read method, then pulses a changeset to the target operator.
 * @param {Operator} target - The Operator to target with ingested data,
 *   typically a Collect transform instance.
 * @param {*} data - The input data, prior to parsing. For JSON this may
 *   be a string or an object. For CSV, TSV, etc should be a string.
 * @param {object} format - The data format description for parsing
 *   loaded data. This object is passed to the vega-loader read method.
 * @returns {Dataflow}
 */

function ingest(target, data, format) {
  data = this.parse(data, format);
  return this.pulse(target, this.changeset().insert(data));
}
/**
 * Request data from an external source, parse it, and return a Promise.
 * @param {string} url - The URL from which to load the data. This string
 *   is passed to the vega-loader load method.
 * @param {object} [format] - The data format description for parsing
 *   loaded data. This object is passed to the vega-loader read method.
 * @return {Promise} A Promise that resolves upon completion of the request.
 *   The resolved object contains the following properties:
 *   - data: an array of parsed data (or null upon error)
 *   - status: a code for success (0), load fail (-1), or parse fail (-2)
 */

async function request(url, format) {
  const df = this;
  let status = 0,
      data;

  try {
    data = await df.loader().load(url, {
      context: 'dataflow',
      response: (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.responseType)(format && format.type)
    });

    try {
      data = df.parse(data, format);
    } catch (err) {
      status = -2;
      df.warn('Data ingestion failed', url, err);
    }
  } catch (err) {
    status = -1;
    df.warn('Loading failed', url, err);
  }

  return {
    data,
    status
  };
}
async function preload(target, url, format) {
  const df = this,
        pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format);
  df.pulse(target, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(res.data || []));
  pending.done();
  return res;
}

function loadPending(df) {
  let accept;
  const pending = new Promise(a => accept = a);
  pending.requests = 0;

  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };

  return df._pending = pending;
}

const SKIP = {
  skip: true
};
/**
 * Perform operator updates in response to events. Applies an
 * update function to compute a new operator value. If the update function
 * returns a {@link ChangeSet}, the operator will be pulsed with those tuple
 * changes. Otherwise, the operator value will be updated to the return value.
 * @param {EventStream|Operator} source - The event source to react to.
 *   This argument can be either an EventStream or an Operator.
 * @param {Operator|function(object):Operator} target - The operator to update.
 *   This argument can either be an Operator instance or (if the source
 *   argument is an EventStream), a function that accepts an event object as
 *   input and returns an Operator to target.
 * @param {function(Parameters,Event): *} [update] - Optional update function
 *   to compute the new operator value, or a literal value to set. Update
 *   functions expect to receive a parameter object and event as arguments.
 *   This function can either return a new operator value or (if the source
 *   argument is an EventStream) a {@link ChangeSet} instance to pulse
 *   the target operator with tuple changes.
 * @param {object} [params] - The update function parameters.
 * @param {object} [options] - Additional options hash. If not overridden,
 *   updated operators will be skipped by default.
 * @param {boolean} [options.skip] - If true, the operator will
 *  be skipped: it will not be evaluated, but its dependents will be.
 * @param {boolean} [options.force] - If true, the operator will
 *   be re-evaluated even if its value has not changed.
 * @return {Dataflow}
 */

function on (source, target, update, params, options) {
  const fn = source instanceof Operator ? onOperator : onStream;
  fn(this, source, target, update, params, options);
  return this;
}

function onStream(df, stream, target, update, params, options) {
  const opt = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, SKIP);
  let func, op;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target)) target = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(target);

  if (update === undefined) {
    func = e => df.touch(target(e));
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(update)) {
    op = new Operator(null, update, params, false);

    func = e => {
      op.evaluate(e);
      const t = target(e),
            v = op.value;
      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);
    };
  } else {
    func = e => df.update(target(e), update, opt);
  }

  stream.apply(func);
}

function onOperator(df, source, target, update, params, options) {
  if (update === undefined) {
    source.targets().add(target);
  } else {
    const opt = options || {},
          op = new Operator(null, updater(target, update), params, false);
    op.modified(opt.force);
    op.rank = source.rank; // immediately follow source

    source.targets().add(op); // add dependency

    if (target) {
      op.skip(true); // skip first invocation

      op.value = target.value; // initialize value

      op.targets().add(target); // chain dependencies

      df.connect(target, [op]); // rerank as needed, #1672
    }
  }
}

function updater(target, update) {
  update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(update) ? update : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(update);
  return target ? function (_, pulse) {
    const value = update(_, pulse);

    if (!target.skip()) {
      target.skip(value !== this.value).value = value;
    }

    return value;
  } : update;
}

/**
 * Assigns a rank to an operator. Ranks are assigned in increasing order
 * by incrementing an internal rank counter.
 * @param {Operator} op - The operator to assign a rank.
 */

function rank(op) {
  op.rank = ++this._rank;
}
/**
 * Re-ranks an operator and all downstream target dependencies. This
 * is necessary when upstream dependencies of higher rank are added to
 * a target operator.
 * @param {Operator} op - The operator to re-rank.
 */

function rerank(op) {
  const queue = [op];
  let cur, list, i;

  while (queue.length) {
    this.rank(cur = queue.pop());

    if (list = cur._targets) {
      for (i = list.length; --i >= 0;) {
        queue.push(cur = list[i]);
        if (cur === op) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Cycle detected in dataflow graph.');
      }
    }
  }
}

/**
 * Sentinel value indicating pulse propagation should stop.
 */

const StopPropagation = {}; // Pulse visit type flags

const ADD = 1 << 0,
      REM = 1 << 1,
      MOD = 1 << 2,
      ADD_REM = ADD | REM,
      ADD_MOD = ADD | MOD,
      ALL = ADD | REM | MOD,
      REFLOW = 1 << 3,
      SOURCE = 1 << 4,
      NO_SOURCE = 1 << 5,
      NO_FIELDS = 1 << 6;
/**
 * A Pulse enables inter-operator communication during a run of the
 * dataflow graph. In addition to the current timestamp, a pulse may also
 * contain a change-set of added, removed or modified data tuples, as well as
 * a pointer to a full backing data source. Tuple change sets may not
 * be fully materialized; for example, to prevent needless array creation
 * a change set may include larger arrays and corresponding filter functions.
 * The pulse provides a {@link visit} method to enable proper and efficient
 * iteration over requested data tuples.
 *
 * In addition, each pulse can track modification flags for data tuple fields.
 * Responsible transform operators should call the {@link modifies} method to
 * indicate changes to data fields. The {@link modified} method enables
 * querying of this modification state.
 *
 * @constructor
 * @param {Dataflow} dataflow - The backing dataflow instance.
 * @param {number} stamp - The current propagation timestamp.
 * @param {string} [encode] - An optional encoding set name, which is then
 *   accessible as Pulse.encode. Operators can respond to (or ignore) this
 *   setting as appropriate. This parameter can be used in conjunction with
 *   the Encode transform in the vega-encode module.
 */

function Pulse(dataflow, stamp, encode) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode || null;
}

function materialize(data, filter) {
  const out = [];
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(data, filter, _ => out.push(_));
  return out;
}

function filter(pulse, flags) {
  const map = {};
  pulse.visit(flags, t => {
    map[tupleid(t)] = 1;
  });
  return t => map[tupleid(t)] ? null : t;
}

function addFilter(a, b) {
  return a ? (t, i) => a(t, i) && b(t, i) : b;
}

Pulse.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation,

  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD,

  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM,

  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD,

  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM,

  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD,

  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL,

  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW,

  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE,

  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE,

  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS,

  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },

  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source) p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },

  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)
    || !p.rem.length && p.source.length === p.add.length;

    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = []; // new operators can ignore rem #2769

      return p;
    }
  },

  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;

    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }

    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }

    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }

    if (flags & MOD) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }

    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans) p.cleans = src.cleans;
    }

    return p;
  },

  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(func) {
    this.dataflow.runAfter(func);
  },

  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
  },

  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(fork) {
    if (fork) return this.fork(ALL).reflow();
    const len = this.add.length,
          src = this.source && this.source.length;

    if (src && src !== len) {
      this.mod = this.source;
      if (len) this.filter(MOD, filter(this, ADD));
    }

    return this;
  },

  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(value) {
    if (arguments.length) {
      this.cleans = !!value;
      return this;
    } else {
      return this.cleans;
    }
  },

  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(_) {
    const hash = this.fields || (this.fields = {});

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_)) {
      _.forEach(f => hash[f] = true);
    } else {
      hash[_] = true;
    }

    return this;
  },

  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.some(f => fields[f]) : fields[_];
  },

  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(flags, filter) {
    const p = this;
    if (flags & ADD) p.addF = addFilter(p.addF, filter);
    if (flags & REM) p.remF = addFilter(p.remF, filter);
    if (flags & MOD) p.modF = addFilter(p.modF, filter);
    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);
    return p;
  },

  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(flags) {
    flags = flags || ALL;
    const p = this;

    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }

    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }

    if (flags & MOD && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }

    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }

    return p;
  },

  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(flags, visitor) {
    const p = this,
          v = visitor;

    if (flags & SOURCE) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.source, p.srcF, v);
      return p;
    }

    if (flags & ADD) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.add, p.addF, v);
    if (flags & REM) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.rem, p.remF, v);
    if (flags & MOD) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.mod, p.modF, v);
    const src = p.source;

    if (flags & REFLOW && src) {
      const sum = p.add.length + p.mod.length;

      if (sum === src.length) ; else if (sum) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(src, filter(p, ADD_MOD), v);
      } else {
        // if no add/rem/mod tuples, visit source
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(src, p.srcF, v);
      }
    }

    return p;
  }

};

/**
 * Represents a set of multiple pulses. Used as input for operators
 * that accept multiple pulses at a time. Contained pulses are
 * accessible via the public "pulses" array property. This pulse doe
 * not carry added, removed or modified tuples directly. However,
 * the visit method can be used to traverse all such tuples contained
 * in sub-pulses with a timestamp matching this parent multi-pulse.
 * @constructor
 * @param {Dataflow} dataflow - The backing dataflow instance.
 * @param {number} stamp - The timestamp.
 * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.
 */

function MultiPulse(dataflow, stamp, pulses, encode) {
  const p = this,
        n = pulses.length;
  let c = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode || null;
  this.pulses = pulses;

  for (let i = 0; i < n; ++i) {
    const pulse = pulses[i];
    if (pulse.stamp !== stamp) continue;

    if (pulse.fields) {
      const hash = p.fields || (p.fields = {});

      for (const f in pulse.fields) {
        hash[f] = 1;
      }
    }

    if (pulse.changed(p.ADD)) c |= p.ADD;
    if (pulse.changed(p.REM)) c |= p.REM;
    if (pulse.changed(p.MOD)) c |= p.MOD;
  }

  this.changes = c;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiPulse, Pulse, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);

    if (flags !== undefined) {
      if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));
      if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));
      if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));
    }

    return p;
  },

  changed(flags) {
    return this.changes & flags;
  },

  modified(_) {
    const p = this,
          fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.some(f => fields[f]) : fields[_];
  },

  filter() {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('MultiPulse does not support filtering.');
  },

  materialize() {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('MultiPulse does not support materialization.');
  },

  visit(flags, visitor) {
    const p = this,
          pulses = p.pulses,
          n = pulses.length;
    let i = 0;

    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }

    return p;
  }

});

/* eslint-disable require-atomic-updates */
/**
 * Evaluates the dataflow and returns a Promise that resolves when pulse
 * propagation completes. This method will increment the current timestamp
 * and process all updated, pulsed and touched operators. When invoked for
 * the first time, all registered operators will be processed. This method
 * should not be invoked by third-party clients, use {@link runAsync} or
 * {@link run} instead.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode package.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Promise} - A promise that resolves to this dataflow after
 *   evaluation completes.
 */

async function evaluate(encode, prerun, postrun) {
  const df = this,
        async = []; // if the pulse value is set, this is a re-entrant call

  if (df._pulse) return reentrant(df); // wait for pending datasets to load

  if (df._pending) await df._pending; // invoke prerun function, if provided

  if (prerun) await asyncCallback(df, prerun); // exit early if there are no updates

  if (!df._touched.length) {
    df.debug('Dataflow invoked, but nothing to do.');
    return df;
  } // increment timestamp clock


  const stamp = ++df._clock; // set the current pulse

  df._pulse = new Pulse(df, stamp, encode); // initialize priority queue, reset touched operators

  df._touched.forEach(op => df._enqueue(op, true));

  df._touched = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id);
  let count = 0,
      op,
      next,
      error;

  try {
    while (df._heap.size() > 0) {
      // dequeue operator with highest priority
      op = df._heap.pop(); // re-queue if rank changed

      if (op.rank !== op.qrank) {
        df._enqueue(op, true);

        continue;
      } // otherwise, evaluate the operator


      next = op.run(df._getPulse(op, encode));

      if (next.then) {
        // await if operator returns a promise directly
        next = await next;
      } else if (next.async) {
        // queue parallel asynchronous execution
        async.push(next.async);
        next = StopPropagation;
      } // propagate evaluation, enqueue dependent operators


      if (next !== StopPropagation) {
        if (op._targets) op._targets.forEach(op => df._enqueue(op));
      } // increment visit counter


      ++count;
    }
  } catch (err) {
    df._heap.clear();

    error = err;
  } // reset pulse map


  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count} operators`);

  if (error) {
    df._postrun = [];
    df.error(error);
  } // invoke callbacks queued via runAfter


  if (df._postrun.length) {
    const pr = df._postrun.sort((a, b) => b.priority - a.priority);

    df._postrun = [];

    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  } // invoke postrun function, if provided


  if (postrun) await asyncCallback(df, postrun); // handle non-blocking asynchronous callbacks

  if (async.length) {
    Promise.all(async).then(cb => df.runAsync(null, () => {
      cb.forEach(f => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }

  return df;
}
/**
 * Queues dataflow evaluation to run once any other queued evaluations have
 * completed and returns a Promise that resolves when the queued pulse
 * propagation completes. If provided, a callback function will be invoked
 * immediately before evaluation commences. This method will ensure a
 * separate evaluation is invoked for each time it is called.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode package.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Promise} - A promise that resolves to this dataflow after
 *   evaluation completes.
 */

async function runAsync(encode, prerun, postrun) {
  // await previously queued functions
  while (this._running) await this._running; // run dataflow, manage running promise


  const clear = () => this._running = null;

  (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);
  return this._running;
}
/**
 * Requests dataflow evaluation and the immediately returns this dataflow
 * instance. If there are pending data loading or other asynchronous
 * operations, the dataflow will evaluate asynchronously after this method
 * has been invoked. To track when dataflow evaluation completes, use the
 * {@link runAsync} method instead. This method will raise an error if
 * invoked while the dataflow is already in the midst of evaluation.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode module.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Dataflow} - This dataflow instance.
 */

function run(encode, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);
}
/**
 * Schedules a callback function to be invoked after the current pulse
 * propagation completes. If no propagation is currently occurring,
 * the function is invoked immediately. Callbacks scheduled via runAfter
 * are invoked immediately upon completion of the current cycle, before
 * any request queued via runAsync. This method is primarily intended for
 * internal use. Third-party callers using runAfter to schedule a callback
 * that invokes {@link run} or {@link runAsync} should not use this method,
 * but instead use {@link runAsync} with prerun or postrun arguments.
 * @param {function(Dataflow)} callback - The callback function to run.
 *   The callback will be invoked with this Dataflow instance as its
 *   sole argument.
 * @param {boolean} enqueue - A boolean flag indicating that the
 *   callback should be queued up to run after the next propagation
 *   cycle, suppressing immediate invocation when propagation is not
 *   currently occurring.
 * @param {number} [priority] - A priority value used to sort registered
 *   callbacks to determine execution order. This argument is intended
 *   for internal Vega use only.
 */

function runAfter(callback, enqueue, priority) {
  if (this._pulse || enqueue) {
    // pulse propagation is currently running, queue to run after
    this._postrun.push({
      priority: priority || 0,
      callback: callback
    });
  } else {
    // pulse propagation already complete, invoke immediately
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
/**
 * Raise an error for re-entrant dataflow evaluation.
 */

function reentrant(df) {
  df.error('Dataflow already running. Use runAsync() to chain invocations.');
  return df;
}
/**
 * Enqueue an operator into the priority queue for evaluation. The operator
 * will be enqueued if it has no registered pulse for the current cycle, or if
 * the force argument is true. Upon enqueue, this method also sets the
 * operator's qrank to the current rank value.
 * @param {Operator} op - The operator to enqueue.
 * @param {boolean} [force] - A flag indicating if the operator should be
 *   forceably added to the queue, even if it has already been previously
 *   enqueued during the current pulse propagation. This is useful when the
 *   dataflow graph is dynamically modified and the operator rank changes.
 */


function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q) op.stamp = this._clock;

  if (q || force) {
    op.qrank = op.rank;

    this._heap.push(op);
  }
}
/**
 * Provide a correct pulse for evaluating an operator. If the operator has an
 * explicit source operator, we will try to pull the pulse(s) from it.
 * If there is an array of source operators, we build a multi-pulse.
 * Otherwise, we return a current pulse with correct source data.
 * If the pulse is the pulse map has an explicit target set, we use that.
 * Else if the pulse on the upstream source operator is current, we use that.
 * Else we use the pulse from the pulse map, but copy the source tuple array.
 * @param {Operator} op - The operator for which to get an input pulse.
 * @param {string} [encode] - An (optional) encoding set name with which to
 *   annotate the returned pulse. See {@link run} for more information.
 */

function getPulse(op, encode) {
  const s = op.source,
        stamp = this._clock;
  return s && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
}

function singlePulse(p, s) {
  if (s && s.stamp === p.stamp) {
    return s;
  }

  p = p.fork();

  if (s && s !== StopPropagation) {
    p.source = s.source;
  }

  return p;
}

const NO_OPT = {
  skip: false,
  force: false
};
/**
 * Touches an operator, scheduling it to be evaluated. If invoked outside of
 * a pulse propagation, the operator will be evaluated the next time this
 * dataflow is run. If invoked in the midst of pulse propagation, the operator
 * will be queued for evaluation if and only if the operator has not yet been
 * evaluated on the current propagation timestamp.
 * @param {Operator} op - The operator to touch.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */

function touch(op, options) {
  const opt = options || NO_OPT;

  if (this._pulse) {
    // if in midst of propagation, add to priority queue
    this._enqueue(op);
  } else {
    // otherwise, queue for next propagation
    this._touched.add(op);
  }

  if (opt.skip) op.skip(true);
  return this;
}
/**
 * Updates the value of the given operator.
 * @param {Operator} op - The operator to update.
 * @param {*} value - The value to set.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.force] - If true, the operator will
 *   be re-evaluated even if its value has not changed.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */

function update(op, value, options) {
  const opt = options || NO_OPT;

  if (op.set(value) || opt.force) {
    this.touch(op, opt);
  }

  return this;
}
/**
 * Pulses an operator with a changeset of tuples. If invoked outside of
 * a pulse propagation, the pulse will be applied the next time this
 * dataflow is run. If invoked in the midst of pulse propagation, the pulse
 * will be added to the set of active pulses and will be applied if and
 * only if the target operator has not yet been evaluated on the current
 * propagation timestamp.
 * @param {Operator} op - The operator to pulse.
 * @param {ChangeSet} value - The tuple changeset to apply.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */

function pulse(op, changeset, options) {
  this.touch(op, options || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),
        t = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset.pulse(p, t);
  return this;
}

function Heap(cmp) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: x => {
      nodes.push(x);
      return siftdown(nodes, 0, nodes.length - 1, cmp);
    },
    pop: () => {
      const last = nodes.pop();
      let item;

      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp);
      } else {
        item = last;
      }

      return item;
    }
  };
}

function siftdown(array, start, idx, cmp) {
  let parent, pidx;
  const item = array[idx];

  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array[pidx];

    if (cmp(item, parent) < 0) {
      array[idx] = parent;
      idx = pidx;
      continue;
    }

    break;
  }

  return array[idx] = item;
}

function siftup(array, idx, cmp) {
  const start = idx,
        end = array.length,
        item = array[idx];
  let cidx = (idx << 1) + 1,
      ridx;

  while (cidx < end) {
    ridx = cidx + 1;

    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {
      cidx = ridx;
    }

    array[idx] = array[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }

  array[idx] = item;
  return siftdown(array, start, idx, cmp);
}

/**
 * A dataflow graph for reactive processing of data streams.
 * @constructor
 */

function Dataflow() {
  this.logger((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.logger)());
  this.logLevel(vega_util__WEBPACK_IMPORTED_MODULE_0__.Error);
  this._clock = 0;
  this._rank = 0;
  this._locale = (0,vega_format__WEBPACK_IMPORTED_MODULE_2__.defaultLocale)();

  try {
    this._loader = (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.loader)();
  } catch (e) {// do nothing if loader module is unavailable
  }

  this._touched = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a, b) => a.qrank - b.qrank);
  this._postrun = [];
}

function logMethod(method) {
  return function () {
    return this._log[method].apply(this, arguments);
  };
}

Dataflow.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },

  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },

  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },

  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(logger) {
    if (arguments.length) {
      this._log = logger;
      return this;
    } else {
      return this._log;
    }
  },

  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: logMethod('error'),

  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: logMethod('warn'),

  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: logMethod('info'),

  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: logMethod('debug'),

  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: logMethod('level'),

  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add,
  connect,
  rank,
  rerank,
  // OPERATOR UPDATES
  pulse,
  touch,
  update,
  changeset,
  // DATA LOADING
  ingest,
  parse,
  preload,
  request,
  // EVENT HANDLING
  events,
  on,
  // PULSE PROPAGATION
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};

/**
 * Abstract class for operators that process data tuples.
 * Subclasses must provide a {@link transform} method for operator processing.
 * @constructor
 * @param {*} [init] - The initial value for this operator.
 * @param {object} [params] - The parameters for this operator.
 * @param {Operator} [source] - The operator from which to receive pulses.
 */

function Transform(init, params) {
  Operator.call(this, init, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Transform, Operator, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse) {
    if (pulse.stamp < this.stamp) return pulse.StopPropagation;
    let rv;

    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse);
    }

    rv = rv || pulse;

    if (rv.then) {
      rv = rv.then(_ => this.pulse = _);
    } else if (rv !== pulse.StopPropagation) {
      this.pulse = rv;
    }

    return rv;
  },

  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(pulse) {
    const params = this.marshall(pulse.stamp),
          out = this.transform(params, pulse);
    params.clear();
    return out;
  },

  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {}

});

const transforms = {};
function definition(type) {
  const t = transform(type);
  return t && t.Definition || null;
}
function transform(type) {
  type = type && type.toLowerCase();
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(transforms, type) ? transforms[type] : null;
}




/***/ }),

/***/ "../../node_modules/vega-encode/build/vega-encode.module.js":
/*!******************************************************************!*\
  !*** ../../node_modules/vega-encode/build/vega-encode.module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "axisticks": () => (/* binding */ AxisTicks),
/* harmony export */   "datajoin": () => (/* binding */ DataJoin),
/* harmony export */   "encode": () => (/* binding */ Encode),
/* harmony export */   "legendentries": () => (/* binding */ LegendEntries),
/* harmony export */   "linkpath": () => (/* binding */ LinkPath),
/* harmony export */   "pie": () => (/* binding */ Pie),
/* harmony export */   "scale": () => (/* binding */ Scale),
/* harmony export */   "sortitems": () => (/* binding */ SortItems),
/* harmony export */   "stack": () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/sum.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/value.js");






/**
 * Generates axis ticks for visualizing a spatial scale.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Scale} params.scale - The scale to generate ticks for.
 * @param {*} [params.count=10] - The approximate number of ticks, or
 *   desired tick interval, to use.
 * @param {Array<*>} [params.values] - The exact tick values to use.
 *   These must be legal domain values for the provided scale.
 *   If provided, the count argument is ignored.
 * @param {function(*):string} [params.formatSpecifier] - A format specifier
 *   to use in conjunction with scale.tickFormat. Legal values are
 *   any valid d3 4.0 format specifier.
 * @param {function(*):string} [params.format] - The format function to use.
 *   If provided, the formatSpecifier argument is ignored.
 */

function AxisTicks(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(AxisTicks, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !_.modified()) {
      return pulse.StopPropagation;
    }

    var locale = pulse.dataflow.locale(),
        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        ticks = this.value,
        scale = _.scale,
        tally = _.count == null ? _.values ? _.values.length : 10 : _.count,
        count = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, tally, _.minstep),
        format = _.format || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickFormat)(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),
        values = _.values ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.validTicks)(scale, _.values, count) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickValues)(scale, count);
    if (ticks) out.rem = ticks;
    ticks = values.map((value, i) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
      index: i / (values.length - 1 || 1),
      value: value,
      label: format(value)
    }));

    if (_.extra && ticks.length) {
      // add an extra tick pegged to the initial domain value
      // this is used to generate axes with 'binned' domains
      ticks.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: -1,
        extra: {
          value: ticks[0].value
        },
        label: ''
      }));
    }

    out.source = ticks;
    out.add = ticks;
    this.value = ticks;
    return out;
  }

});

/**
 * Joins a set of data elements against a set of visual items.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): object} [params.item] - An item generator function.
 * @param {function(object): *} [params.key] - The key field associating data and visual items.
 */

function DataJoin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}

function defaultItemCreate() {
  return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({});
}

function newMap(key) {
  const map = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.fastmap)().test(t => t.exit);

  map.lookup = t => map.get(key(t));

  return map;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(DataJoin, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var df = pulse.dataflow,
        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        item = _.item || defaultItemCreate,
        key = _.key || vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid,
        map = this.value; // prevent transient (e.g., hover) requests from
    // cascading across marks derived from marks

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(out.encode)) {
      out.encode = null;
    }

    if (map && (_.modified('key') || pulse.modified(key))) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('DataJoin does not support modified key function or fields.');
    }

    if (!map) {
      pulse = pulse.addAll();
      this.value = map = newMap(key);
    }

    pulse.visit(pulse.ADD, t => {
      const k = key(t);
      let x = map.get(k);

      if (x) {
        if (x.exit) {
          map.empty--;
          out.add.push(x);
        } else {
          out.mod.push(x);
        }
      } else {
        x = item(t);
        map.set(k, x);
        out.add.push(x);
      }

      x.datum = t;
      x.exit = false;
    });
    pulse.visit(pulse.MOD, t => {
      const k = key(t),
            x = map.get(k);

      if (x) {
        x.datum = t;
        out.mod.push(x);
      }
    });
    pulse.visit(pulse.REM, t => {
      const k = key(t),
            x = map.get(k);

      if (t === x.datum && !x.exit) {
        out.rem.push(x);
        x.exit = true;
        ++map.empty;
      }
    });
    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');

    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {
      df.runAfter(map.clean);
    }

    return out;
  }

});

/**
 * Invokes encoding functions for visual items.
 * @constructor
 * @param {object} params - The parameters to the encoding functions. This
 *   parameter object will be passed through to all invoked encoding functions.
 * @param {object} [params.mod=false] - Flag indicating if tuples in the input
 *   mod set that are unmodified by encoders should be included in the output.
 * @param {object} param.encoders - The encoding functions
 * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set
 * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set
 * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set
 */

function Encode(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Encode, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ADD_REM),
        fmod = _.mod || false,
        encoders = _.encoders,
        encode = pulse.encode; // if an array, the encode directive includes additional sets
    // that must be defined in order for the primary set to be invoked
    // e.g., only run the update set if the hover set is defined

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(encode)) {
      if (out.changed() || encode.every(e => encoders[e])) {
        encode = encode[0];
        out.encode = null; // consume targeted encode directive
      } else {
        return pulse.StopPropagation;
      }
    } // marshall encoder functions


    var reenter = encode === 'enter',
        update = encoders.update || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
        enter = encoders.enter || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
        exit = encoders.exit || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
        set = (encode && !reenter ? encoders[encode] : update) || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy;

    if (pulse.changed(pulse.ADD)) {
      pulse.visit(pulse.ADD, t => {
        enter(t, _);
        update(t, _);
      });
      out.modifies(enter.output);
      out.modifies(update.output);

      if (set !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy && set !== update) {
        pulse.visit(pulse.ADD, t => {
          set(t, _);
        });
        out.modifies(set.output);
      }
    }

    if (pulse.changed(pulse.REM) && exit !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy) {
      pulse.visit(pulse.REM, t => {
        exit(t, _);
      });
      out.modifies(exit.output);
    }

    if (reenter || set !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy) {
      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);

      if (reenter) {
        pulse.visit(flag, t => {
          const mod = enter(t, _) || fmod;
          if (set(t, _) || mod) out.mod.push(t);
        });
        if (out.mod.length) out.modifies(enter.output);
      } else {
        pulse.visit(flag, t => {
          if (set(t, _) || fmod) out.mod.push(t);
        });
      }

      if (out.mod.length) out.modifies(set.output);
    }

    return out.changed() ? out : pulse.StopPropagation;
  }

});

/**
 * Generates legend entries for visualizing a scale.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Scale} params.scale - The scale to generate items for.
 * @param {*} [params.count=5] - The approximate number of items, or
 *   desired tick interval, to use.
 * @param {*} [params.limit] - The maximum number of entries to
 *   include in a symbol legend.
 * @param {Array<*>} [params.values] - The exact tick values to use.
 *   These must be legal domain values for the provided scale.
 *   If provided, the count argument is ignored.
 * @param {string} [params.formatSpecifier] - A format specifier
 *   to use in conjunction with scale.tickFormat. Legal values are
 *   any valid D3 format specifier string.
 * @param {function(*):string} [params.format] - The format function to use.
 *   If provided, the formatSpecifier argument is ignored.
 */

function LegendEntries(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(LegendEntries, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value != null && !_.modified()) {
      return pulse.StopPropagation;
    }

    var locale = pulse.dataflow.locale(),
        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        items = this.value,
        type = _.type || vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend,
        scale = _.scale,
        limit = +_.limit,
        count = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, _.count == null ? 5 : _.count, _.minstep),
        lskip = !!_.values || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend,
        format = _.format || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelFormat)(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),
        values = _.values || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelValues)(scale, count),
        domain,
        fraction,
        size,
        offset,
        ellipsis;
    if (items) out.rem = items;

    if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend) {
      if (limit && values.length > limit) {
        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');
        items = values.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items = values;
      }

      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(size = _.size)) {
        // if first value maps to size zero, remove from list (vega#717)
        if (!_.values && scale(items[0]) === 0) {
          items = items.slice(1);
        } // compute size offset for legend entries


        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);
      } else {
        size = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.constant)(offset = size || 8);
      }

      items = items.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, items),
        value: value,
        offset: offset,
        size: size(value, _)
      }));

      if (ellipsis) {
        ellipsis = values[items.length];
        items.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
          index: items.length,
          label: "\u2026".concat(values.length - items.length, " entries"),
          value: ellipsis,
          offset: offset,
          size: size(ellipsis, _)
        }));
      }
    } else if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.GradientLegend) {
      domain = scale.domain(), fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scaleFraction)(scale, domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)); // if automatic label generation produces 2 or fewer values,
      // use the domain end points instead (fixes vega/vega#1364)

      if (values.length < 3 && !_.values && domain[0] !== (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)) {
        values = [domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)];
      }

      items = values.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, values),
        value: value,
        perc: fraction(value)
      }));
    } else {
      size = values.length - 1;
      fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelFraction)(scale);
      items = values.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, values),
        value: value,
        perc: index ? fraction(value) : 0,
        perc2: index === size ? 1 : fraction(values[index + 1])
      }));
    }

    out.source = items;
    out.add = items;
    this.value = items;
    return out;
  }

});

const sourceX = t => t.source.x;

const sourceY = t => t.source.y;

const targetX = t => t.target.x;

const targetY = t => t.target.y;
/**
 * Layout paths linking source and target elements.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */


function LinkPath(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, {}, params);
}
LinkPath.Definition = {
  'type': 'LinkPath',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'sourceX',
    'type': 'field',
    'default': 'source.x'
  }, {
    'name': 'sourceY',
    'type': 'field',
    'default': 'source.y'
  }, {
    'name': 'targetX',
    'type': 'field',
    'default': 'target.x'
  }, {
    'name': 'targetY',
    'type': 'field',
    'default': 'target.y'
  }, {
    'name': 'orient',
    'type': 'enum',
    'default': 'vertical',
    'values': ['horizontal', 'vertical', 'radial']
  }, {
    'name': 'shape',
    'type': 'enum',
    'default': 'line',
    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']
  }, {
    'name': 'require',
    'type': 'signal'
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(LinkPath, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var sx = _.sourceX || sourceX,
        sy = _.sourceY || sourceY,
        tx = _.targetX || targetX,
        ty = _.targetY || targetY,
        as = _.as || 'path',
        orient = _.orient || 'vertical',
        shape = _.shape || 'line',
        path = Paths.get(shape + '-' + orient) || Paths.get(shape);

    if (!path) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));
    }

    pulse.visit(pulse.SOURCE, t => {
      t[as] = path(sx(t), sy(t), tx(t), ty(t));
    });
    return pulse.reflow(_.modified()).modifies(as);
  }

});

const line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;

const lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));

const arc = (sx, sy, tx, ty) => {
  var dx = tx - sx,
      dy = ty - sy,
      rr = Math.sqrt(dx * dx + dy * dy) / 2,
      ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;
};

const arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));

const curve = (sx, sy, tx, ty) => {
  const dx = tx - sx,
        dy = ty - sy,
        ix = 0.2 * (dx + dy),
        iy = 0.2 * (dy - dx);
  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;
};

const curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));

const orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;

const orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;

const orthoR = (sa, sr, ta, tr) => {
  const sc = Math.cos(sa),
        ss = Math.sin(sa),
        tc = Math.cos(ta),
        ts = Math.sin(ta),
        sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;
  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;
};

const diagonalX = (sx, sy, tx, ty) => {
  const m = (sx + tx) / 2;
  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;
};

const diagonalY = (sx, sy, tx, ty) => {
  const m = (sy + ty) / 2;
  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;
};

const diagonalR = (sa, sr, ta, tr) => {
  const sc = Math.cos(sa),
        ss = Math.sin(sa),
        tc = Math.cos(ta),
        ts = Math.sin(ta),
        mr = (sr + tr) / 2;
  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;
};

const Paths = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.fastmap)({
  'line': line,
  'line-radial': lineR,
  'arc': arc,
  'arc-radial': arcR,
  'curve': curve,
  'curve-radial': curveR,
  'orthogonal-horizontal': orthoX,
  'orthogonal-vertical': orthoY,
  'orthogonal-radial': orthoR,
  'diagonal-horizontal': diagonalX,
  'diagonal-vertical': diagonalY,
  'diagonal-radial': diagonalR
});

/**
 * Pie and donut chart layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size pie segments.
 * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.
 * @param {number} [params.endAngle=2π] - The end angle (in radians) of the layout.
 * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.
 */

function Pie(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Pie.Definition = {
  'type': 'Pie',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'startAngle',
    'type': 'number',
    'default': 0
  }, {
    'name': 'endAngle',
    'type': 'number',
    'default': 6.283185307179586
  }, {
    'name': 'sort',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['startAngle', 'endAngle']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Pie, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var as = _.as || ['startAngle', 'endAngle'],
        startAngle = as[0],
        endAngle = as[1],
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_2__.one,
        start = _.startAngle || 0,
        stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,
        data = pulse.source,
        values = data.map(field),
        n = values.length,
        a = start,
        k = (stop - start) / (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(values),
        index = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.default)(n),
        i,
        t,
        v;

    if (_.sort) {
      index.sort((a, b) => values[a] - values[b]);
    }

    for (i = 0; i < n; ++i) {
      v = values[index[i]];
      t = data[index[i]];
      t[startAngle] = a;
      t[endAngle] = a += v * k;
    }

    this.value = values;
    return pulse.reflow(_.modified()).modifies(as);
  }

});

const DEFAULT_COUNT = 5;

function includeZero(scale) {
  const type = scale.type;
  return !scale.bins && (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Pow || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sqrt);
}

function includePad(type) {
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isContinuous)(type) && type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential;
}

const SKIP = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.toSet)(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);
/**
 * Maintains a scale function mapping data values to visual channels.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Scale(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Scale, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var df = pulse.dataflow,
        scale$1 = this.value,
        key = scaleKey(_);

    if (!scale$1 || key !== scale$1.type) {
      this.value = scale$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scale)(key)();
    }

    for (key in _) if (!SKIP[key]) {
      // padding is a scale property for band/point but not others
      if (key === 'padding' && includePad(scale$1.type)) continue; // invoke scale property setter, raise warning if not found

      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);
    }

    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
  }

});

function scaleKey(_) {
  var t = _.type,
      d = '',
      n; // backwards compatibility pre Vega 5.

  if (t === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential) return vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential + '-' + vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear;

  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential + '-' : n === 3 ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.Diverging + '-' : '';
  }

  return (d + t || vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear).toLowerCase();
}

function isContinuousColor(_) {
  const t = _.type;
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isContinuous)(t) && t !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Time && t !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.UTC && (_.scheme || _.range && _.range.length && _.range.every(vega_util__WEBPACK_IMPORTED_MODULE_2__.isString));
}

function configureDomain(scale, _, df) {
  // check raw domain, if provided use that and exit early
  const raw = rawDomain(scale, _.domainRaw, df);
  if (raw > -1) return raw;
  var domain = _.domain,
      type = scale.type,
      zero = _.zero || _.zero === undefined && includeZero(scale),
      n,
      mid;
  if (!domain) return 0; // adjust continuous domain for minimum pixel padding

  if (includePad(type) && _.padding && domain[0] !== (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)) {
    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);
  } // adjust domain based on zero, min, max settings


  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain = domain.slice()).length - 1 || 1;

    if (zero) {
      if (domain[0] > 0) domain[0] = 0;
      if (domain[n] < 0) domain[n] = 0;
    }

    if (_.domainMin != null) domain[0] = _.domainMin;
    if (_.domainMax != null) domain[n] = _.domainMax;

    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;
      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);
      domain.splice(i, 0, mid);
    }
  } // set the scale domain


  scale.domain(domainCheck(type, domain, df)); // if ordinal scale domain is defined, prevent implicit
  // domain construction as side-effect of scale lookup

  if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Ordinal) {
    scale.unknown(_.domainImplicit ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.scaleImplicit : undefined);
  } // perform 'nice' adjustment as requested


  if (_.nice && scale.nice) {
    scale.nice(_.nice !== true && (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, _.nice) || null);
  } // return the cardinality of the domain


  return domain.length;
}

function rawDomain(scale, raw, df) {
  if (raw) {
    scale.domain(domainCheck(scale.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}

function padDomain(type, domain, range, pad, exponent, constant) {
  var span = Math.abs((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(range) - range[0]),
      frac = span / (span - 2 * pad),
      d = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Log ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomLog)(domain, null, frac) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sqrt ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomPow)(domain, null, frac, 0.5) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Pow ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomPow)(domain, null, frac, exponent || 1) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Symlog ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomSymlog)(domain, null, frac, constant || 1) : (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomLinear)(domain, null, frac);
  domain = domain.slice();
  domain[0] = d[0];
  domain[domain.length - 1] = d[1];
  return domain;
}

function domainCheck(type, domain, df) {
  if ((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isLogarithmic)(type)) {
    // sum signs of domain values
    // if all pos or all neg, abs(sum) === domain.length
    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));

    if (s !== domain.length) {
      df.warn('Log scale domain includes zero: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.stringValue)(domain));
    }
  }

  return domain;
}

function configureBins(scale, _, count) {
  let bins = _.bins;

  if (bins && !(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(bins)) {
    // generate bin boundary array
    const domain = scale.domain(),
          lo = domain[0],
          hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain),
          step = bins.step;
    let start = bins.start == null ? lo : bins.start,
        stop = bins.stop == null ? hi : bins.stop;
    if (!step) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Scale bins parameter missing step property.');
    if (start < lo) start = step * Math.ceil(lo / step);
    if (stop > hi) stop = step * Math.floor(hi / step);
    bins = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.default)(start, stop + step / 2, step);
  }

  if (bins) {
    // assign bin boundaries to scale instance
    scale.bins = bins;
  } else if (scale.bins) {
    // no current bins, remove bins if previously set
    delete scale.bins;
  } // special handling for bin-ordinal scales


  if (scale.type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.BinOrdinal) {
    if (!bins) {
      // the domain specifies the bins
      scale.bins = scale.domain();
    } else if (!_.domain && !_.domainRaw) {
      // the bins specify the domain
      scale.domain(bins);
      count = bins.length;
    }
  } // return domain cardinality


  return count;
}

function configureRange(scale, _, count) {
  var type = scale.type,
      round = _.round || false,
      range = _.range; // if range step specified, calculate full range extent

  if (_.rangeStep != null) {
    range = configureRangeStep(type, _, count);
  } // else if a range scheme is defined, use that
  else if (_.scheme) {
      range = configureScheme(type, _, count);

      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(range)) {
        if (scale.interpolator) {
          return scale.interpolator(range);
        } else {
          (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)("Scale type ".concat(type, " does not support interpolating color schemes."));
        }
      }
    } // given a range array for an interpolating scale, convert to interpolator


  if (range && (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isInterpolating)(type)) {
    return scale.interpolator((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateColors)(flip(range, _.reverse), _.interpolate, _.interpolateGamma));
  } // configure rounding / interpolation


  if (range && _.interpolate && scale.interpolate) {
    scale.interpolate((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolate)(_.interpolate, _.interpolateGamma));
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale.round)) {
    scale.round(round);
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale.rangeRound)) {
    scale.interpolate(round ? d3_interpolate__WEBPACK_IMPORTED_MODULE_5__.default : d3_interpolate__WEBPACK_IMPORTED_MODULE_6__.default);
  }

  if (range) scale.range(flip(range, _.reverse));
}

function configureRangeStep(type, _, count) {
  if (type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Band && type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Point) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Only band and point scales support rangeStep.');
  } // calculate full range based on requested step size and padding


  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,
      inner = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.bandSpace)(count, inner, outer)];
}

function configureScheme(type, _, count) {
  var extent = _.schemeExtent,
      name,
      scheme$1;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(_.scheme)) {
    scheme$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateColors)(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name = _.scheme.toLowerCase();
    scheme$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scheme)(name);
    if (!scheme$1) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)("Unrecognized scheme name: ".concat(_.scheme));
  } // determine size for potential discrete range


  count = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Threshold ? count + 1 : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.BinOrdinal ? count - 1 : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Quantile || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Quantize ? +_.schemeCount || DEFAULT_COUNT : count; // adjust and/or quantize scheme as appropriate

  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isInterpolating)(type) ? adjustScheme(scheme$1, extent, _.reverse) : (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scheme$1) ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.quantizeInterpolator)(adjustScheme(scheme$1, extent), count) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Ordinal ? scheme$1 : scheme$1.slice(0, count);
}

function adjustScheme(scheme, extent, reverse) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scheme) && (extent || reverse) ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateRange)(scheme, flip(extent || [0, 1], reverse)) : scheme;
}

function flip(array, reverse) {
  return reverse ? array.slice().reverse() : array;
}

/**
 * Sorts scenegraph items in the pulse source array.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator
 *   function for sorting tuples.
 */

function SortItems(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(SortItems, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');
    if (mod) pulse.source.sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort));
    this.modified(mod);
    return pulse;
  }

});

const Zero = 'zero',
      Center = 'center',
      Normalize = 'normalize',
      DefOutput = ['y0', 'y1'];
/**
 * Stack layout for visualization elements.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to stack.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.
 * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.
 */

function Stack(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Stack.Definition = {
  'type': 'Stack',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'offset',
    'type': 'enum',
    'default': Zero,
    'values': [Zero, Center, Normalize]
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': DefOutput
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Stack, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var as = _.as || DefOutput,
        y0 = as[0],
        y1 = as[1],
        sort = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort),
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_2__.one,
        stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,
        groups,
        i,
        n,
        max; // partition, sum, and sort the stack groups

    groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group

    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {
      stack(groups[i], max, field, y0, y1);
    }

    return pulse.reflow(_.modified()).modifies(as);
  }

});

function stackCenter(group, max, field, y0, y1) {
  var last = (max - group.sum) / 2,
      m = group.length,
      j = 0,
      t;

  for (; j < m; ++j) {
    t = group[j];
    t[y0] = last;
    t[y1] = last += Math.abs(field(t));
  }
}

function stackNormalize(group, max, field, y0, y1) {
  var scale = 1 / group.sum,
      last = 0,
      m = group.length,
      j = 0,
      v = 0,
      t;

  for (; j < m; ++j) {
    t = group[j];
    t[y0] = last;
    t[y1] = last = scale * (v += Math.abs(field(t)));
  }
}

function stackZero(group, max, field, y0, y1) {
  var lastPos = 0,
      lastNeg = 0,
      m = group.length,
      j = 0,
      v,
      t;

  for (; j < m; ++j) {
    t = group[j];
    v = +field(t);

    if (v < 0) {
      t[y0] = lastNeg;
      t[y1] = lastNeg += v;
    } else {
      t[y0] = lastPos;
      t[y1] = lastPos += v;
    }
  }
}

function partition(data, groupby, sort, field) {
  var groups = [],
      get = f => f(t),
      map,
      i,
      n,
      m,
      t,
      k,
      g,
      s,
      max; // partition data points into stack groups


  if (groupby == null) {
    groups.push(data.slice());
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        groups.push(g);
      }

      g.push(t);
    }
  } // compute sums of groups, sort groups as needed


  for (k = 0, max = 0, m = groups.length; k < m; ++k) {
    g = groups[k];

    for (i = 0, s = 0, n = g.length; i < n; ++i) {
      s += Math.abs(field(g[i]));
    }

    g.sum = s;
    if (s > max) max = s;
    if (sort) g.sort(sort);
  }

  groups.max = max;
  return groups;
}




/***/ }),

/***/ "../../node_modules/vega-event-selector/build/vega-event-selector.module.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/vega-event-selector/build/vega-event-selector.module.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseSelector": () => (/* binding */ eventSelector)
/* harmony export */ });
const VIEW = 'view',
      LBRACK = '[',
      RBRACK = ']',
      LBRACE = '{',
      RBRACE = '}',
      COLON = ':',
      COMMA = ',',
      NAME = '@',
      GT = '>',
      ILLEGAL = /[[\]{}]/,
      DEFAULT_MARKS = {
  '*': 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
let DEFAULT_SOURCE, MARKS;
/**
 * Parse an event selector string.
 * Returns an array of event stream definitions.
 */

function eventSelector (selector, source, marks) {
  DEFAULT_SOURCE = source || VIEW;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}

function isMarkType(type) {
  return MARKS[type];
}

function find(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count = 0,
      c;

  for (; i < n; ++i) {
    c = s[i];
    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;
  }

  return i;
}

function parseMerge(s) {
  const output = [],
        n = s.length;
  let start = 0,
      i = 0;

  while (i < n) {
    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output.push(s.substring(start, i).trim());
    start = ++i;
  }

  if (output.length === 0) {
    throw 'Empty event selector: ' + s;
  }

  return output;
}

function parseSelector(s) {
  return s[0] === '[' ? parseBetween(s) : parseStream(s);
}

function parseBetween(s) {
  const n = s.length;
  let i = 1,
      b;
  i = find(s, i, RBRACK, LBRACK, RBRACK);

  if (i === n) {
    throw 'Empty between selector: ' + s;
  }

  b = parseMerge(s.substring(1, i));

  if (b.length !== 2) {
    throw 'Between selector must have two elements: ' + s;
  }

  s = s.slice(i + 1).trim();

  if (s[0] !== GT) {
    throw 'Expected \'>\' after between selector: ' + s;
  }

  b = b.map(parseSelector);
  const stream = parseSelector(s.slice(1).trim());

  if (stream.between) {
    return {
      between: b,
      stream: stream
    };
  } else {
    stream.between = b;
  }

  return stream;
}

function parseStream(s) {
  const stream = {
    source: DEFAULT_SOURCE
  },
        source = [];
  let throttle = [0, 0],
      markname = 0,
      start = 0,
      n = s.length,
      i = 0,
      j,
      filter; // extract throttle from end

  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);

    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e) {
        throw 'Invalid throttle specification: ' + s;
      }

      s = s.slice(0, i).trim();
      n = s.length;
    } else throw 'Unmatched right brace: ' + s;

    i = 0;
  }

  if (!n) throw s; // set name flag based on first char

  if (s[0] === NAME) markname = ++i; // extract first part of multi-part stream selector

  j = find(s, i, COLON);

  if (j < n) {
    source.push(s.substring(start, j).trim());
    start = i = ++j;
  } // extract remaining part of stream selector


  i = find(s, i, LBRACK);

  if (i === n) {
    source.push(s.substring(start, n).trim());
  } else {
    source.push(s.substring(start, i).trim());
    filter = [];
    start = ++i;
    if (start === n) throw 'Unmatched left bracket: ' + s;
  } // extract filters


  while (i < n) {
    i = find(s, i, RBRACK);
    if (i === n) throw 'Unmatched left bracket: ' + s;
    filter.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;
    start = ++i;
  } // marshall event stream specification


  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {
    throw 'Invalid event selector: ' + s;
  }

  if (n > 1) {
    stream.type = source[1];

    if (markname) {
      stream.markname = source[0].slice(1);
    } else if (isMarkType(source[0])) {
      stream.marktype = source[0];
    } else {
      stream.source = source[0];
    }
  } else {
    stream.type = source[0];
  }

  if (stream.type.slice(-1) === '!') {
    stream.consume = true;
    stream.type = stream.type.slice(0, -1);
  }

  if (filter != null) stream.filter = filter;
  if (throttle[0]) stream.throttle = throttle[0];
  if (throttle[1]) stream.debounce = throttle[1];
  return stream;
}

function parseThrottle(s) {
  const a = s.split(COMMA);
  if (!s.length || a.length > 2) throw s;
  return a.map(_ => {
    const x = +_;
    if (x !== x) throw s;
    return x;
  });
}




/***/ }),

/***/ "../../node_modules/vega-expression/build/vega-expression.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-expression/build/vega-expression.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ASTNode": () => (/* binding */ ASTNode),
/* harmony export */   "ArrayExpression": () => (/* binding */ ArrayExpression),
/* harmony export */   "BinaryExpression": () => (/* binding */ BinaryExpression),
/* harmony export */   "CallExpression": () => (/* binding */ CallExpression),
/* harmony export */   "ConditionalExpression": () => (/* binding */ ConditionalExpression),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Literal": () => (/* binding */ Literal),
/* harmony export */   "LogicalExpression": () => (/* binding */ LogicalExpression),
/* harmony export */   "MemberExpression": () => (/* binding */ MemberExpression),
/* harmony export */   "ObjectExpression": () => (/* binding */ ObjectExpression),
/* harmony export */   "Property": () => (/* binding */ Property),
/* harmony export */   "RawCode": () => (/* binding */ RawCode),
/* harmony export */   "UnaryExpression": () => (/* binding */ UnaryExpression),
/* harmony export */   "codegenExpression": () => (/* binding */ codegen),
/* harmony export */   "constants": () => (/* binding */ Constants),
/* harmony export */   "functions": () => (/* binding */ Functions),
/* harmony export */   "parseExpression": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");


const RawCode = 'RawCode';
const Literal = 'Literal';
const Property = 'Property';
const Identifier = 'Identifier';
const ArrayExpression = 'ArrayExpression';
const BinaryExpression = 'BinaryExpression';
const CallExpression = 'CallExpression';
const ConditionalExpression = 'ConditionalExpression';
const LogicalExpression = 'LogicalExpression';
const MemberExpression = 'MemberExpression';
const ObjectExpression = 'ObjectExpression';
const UnaryExpression = 'UnaryExpression';
function ASTNode(type) {
  this.type = type;
}

ASTNode.prototype.visit = function (visitor) {
  let c, i, n;
  if (visitor(this)) return 1;

  for (c = children(this), i = 0, n = c.length; i < n; ++i) {
    if (c[i].visit(visitor)) return 1;
  }
};

function children(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;

    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];

    case CallExpression:
      return [node.callee].concat(node.arguments);

    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];

    case MemberExpression:
      return [node.object, node.property];

    case ObjectExpression:
      return node.properties;

    case Property:
      return [node.key, node.value];

    case UnaryExpression:
      return [node.argument];

    case Identifier:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}

/*
  The following expression parser is based on Esprima (http://esprima.org/).
  Original header comment and license for Esprima is included here:

  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var TokenName, source, index, length, lookahead;
var TokenBooleanLiteral = 1,
    TokenEOF = 2,
    TokenIdentifier = 3,
    TokenKeyword = 4,
    TokenNullLiteral = 5,
    TokenNumericLiteral = 6,
    TokenPunctuator = 7,
    TokenStringLiteral = 8,
    TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = 'Boolean';
TokenName[TokenEOF] = '<end>';
TokenName[TokenIdentifier] = 'Identifier';
TokenName[TokenKeyword] = 'Keyword';
TokenName[TokenNullLiteral] = 'Null';
TokenName[TokenNumericLiteral] = 'Numeric';
TokenName[TokenPunctuator] = 'Punctuator';
TokenName[TokenStringLiteral] = 'String';
TokenName[TokenRegularExpression] = 'RegularExpression';
var SyntaxArrayExpression = 'ArrayExpression',
    SyntaxBinaryExpression = 'BinaryExpression',
    SyntaxCallExpression = 'CallExpression',
    SyntaxConditionalExpression = 'ConditionalExpression',
    SyntaxIdentifier = 'Identifier',
    SyntaxLiteral = 'Literal',
    SyntaxLogicalExpression = 'LogicalExpression',
    SyntaxMemberExpression = 'MemberExpression',
    SyntaxObjectExpression = 'ObjectExpression',
    SyntaxProperty = 'Property',
    SyntaxUnaryExpression = 'UnaryExpression'; // Error messages should be identical to V8.

var MessageUnexpectedToken = 'Unexpected token %0',
    MessageUnexpectedNumber = 'Unexpected number',
    MessageUnexpectedString = 'Unexpected string',
    MessageUnexpectedIdentifier = 'Unexpected identifier',
    MessageUnexpectedReserved = 'Unexpected reserved word',
    MessageUnexpectedEOS = 'Unexpected end of input',
    MessageInvalidRegExp = 'Invalid regular expression',
    MessageUnterminatedRegExp = 'Invalid regular expression: missing /',
    MessageStrictOctalLiteral = 'Octal literals are not allowed in strict mode.',
    MessageStrictDuplicateProperty = 'Duplicate data property in object literal not allowed in strict mode';
var ILLEGAL = 'ILLEGAL',
    DISABLED = 'Disabled.'; // See also tools/generate-unicode-regex.py.

var RegexNonAsciiIdentifierStart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),
    // eslint-disable-next-line no-misleading-character-class
RegexNonAsciiIdentifierPart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'); // Ensure the condition is true, otherwise throw an error.
// This is only to have a better contract semantic, i.e. another safety net
// to catch a logic error. The condition shall be fulfilled in normal case.
// Do NOT use this to enforce a certain condition on any user input.

function assert(condition, message) {
  /* istanbul ignore next */
  if (!condition) {
    throw new Error('ASSERT: ' + message);
  }
}

function isDecimalDigit(ch) {
  return ch >= 0x30 && ch <= 0x39; // 0..9
}

function isHexDigit(ch) {
  return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
}

function isOctalDigit(ch) {
  return '01234567'.indexOf(ch) >= 0;
} // 7.2 White Space


function isWhiteSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;
} // 7.3 Line Terminators


function isLineTerminator(ch) {
  return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
} // 7.6 Identifier Names and Identifiers


function isIdentifierStart(ch) {
  return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch === 0x5C || ch >= 0x80 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch));
}

function isIdentifierPart(ch) {
  return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch >= 0x30 && ch <= 0x39 || ch === 0x5C || ch >= 0x80 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch));
} // 7.6.1.1 Keywords


const keywords = {
  'if': 1,
  'in': 1,
  'do': 1,
  'var': 1,
  'for': 1,
  'new': 1,
  'try': 1,
  'let': 1,
  'this': 1,
  'else': 1,
  'case': 1,
  'void': 1,
  'with': 1,
  'enum': 1,
  'while': 1,
  'break': 1,
  'catch': 1,
  'throw': 1,
  'const': 1,
  'yield': 1,
  'class': 1,
  'super': 1,
  'return': 1,
  'typeof': 1,
  'delete': 1,
  'switch': 1,
  'export': 1,
  'import': 1,
  'public': 1,
  'static': 1,
  'default': 1,
  'finally': 1,
  'extends': 1,
  'package': 1,
  'private': 1,
  'function': 1,
  'continue': 1,
  'debugger': 1,
  'interface': 1,
  'protected': 1,
  'instanceof': 1,
  'implements': 1
};

function skipComment() {
  while (index < length) {
    const ch = source.charCodeAt(index);

    if (isWhiteSpace(ch) || isLineTerminator(ch)) {
      ++index;
    } else {
      break;
    }
  }
}

function scanHexEscape(prefix) {
  var i,
      len,
      ch,
      code = 0;
  len = prefix === 'u' ? 4 : 2;

  for (i = 0; i < len; ++i) {
    if (index < length && isHexDigit(source[index])) {
      ch = source[index++];
      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }

  return String.fromCharCode(code);
}

function scanUnicodeCodePointEscape() {
  var ch, code, cu1, cu2;
  ch = source[index];
  code = 0; // At least, one hex digit is required.

  if (ch === '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  while (index < length) {
    ch = source[index++];

    if (!isHexDigit(ch)) {
      break;
    }

    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
  }

  if (code > 0x10FFFF || ch !== '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  } // UTF-16 Encoding


  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  }

  cu1 = (code - 0x10000 >> 10) + 0xD800;
  cu2 = (code - 0x10000 & 1023) + 0xDC00;
  return String.fromCharCode(cu1, cu2);
}

function getEscapedIdentifier() {
  var ch, id;
  ch = source.charCodeAt(index++);
  id = String.fromCharCode(ch); // '\u' (U+005C, U+0075) denotes an escaped character.

  if (ch === 0x5C) {
    if (source.charCodeAt(index) !== 0x75) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }

    ++index;
    ch = scanHexEscape('u');

    if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }

    id = ch;
  }

  while (index < length) {
    ch = source.charCodeAt(index);

    if (!isIdentifierPart(ch)) {
      break;
    }

    ++index;
    id += String.fromCharCode(ch); // '\u' (U+005C, U+0075) denotes an escaped character.

    if (ch === 0x5C) {
      id = id.substr(0, id.length - 1);

      if (source.charCodeAt(index) !== 0x75) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }

      ++index;
      ch = scanHexEscape('u');

      if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }

      id += ch;
    }
  }

  return id;
}

function getIdentifier() {
  var start, ch;
  start = index++;

  while (index < length) {
    ch = source.charCodeAt(index);

    if (ch === 0x5C) {
      // Blackslash (U+005C) marks Unicode escape sequence.
      index = start;
      return getEscapedIdentifier();
    }

    if (isIdentifierPart(ch)) {
      ++index;
    } else {
      break;
    }
  }

  return source.slice(start, index);
}

function scanIdentifier() {
  var start, id, type;
  start = index; // Backslash (U+005C) starts an escaped character.

  id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier(); // There is no keyword or literal with only one character.
  // Thus, it must be an identifier.

  if (id.length === 1) {
    type = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id)) {
    // eslint-disable-line no-prototype-builtins
    type = TokenKeyword;
  } else if (id === 'null') {
    type = TokenNullLiteral;
  } else if (id === 'true' || id === 'false') {
    type = TokenBooleanLiteral;
  } else {
    type = TokenIdentifier;
  }

  return {
    type: type,
    value: id,
    start: start,
    end: index
  };
} // 7.7 Punctuators


function scanPunctuator() {
  var start = index,
      code = source.charCodeAt(index),
      code2,
      ch1 = source[index],
      ch2,
      ch3,
      ch4;

  switch (code) {
    // Check for most common single-character punctuators.
    case 0x2E: // . dot

    case 0x28: // ( open bracket

    case 0x29: // ) close bracket

    case 0x3B: // ; semicolon

    case 0x2C: // , comma

    case 0x7B: // { open curly brace

    case 0x7D: // } close curly brace

    case 0x5B: // [

    case 0x5D: // ]

    case 0x3A: // :

    case 0x3F: // ?

    case 0x7E:
      // ~
      ++index;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start: start,
        end: index
      };

    default:
      code2 = source.charCodeAt(index + 1); // '=' (U+003D) marks an assignment or comparison operator.

      if (code2 === 0x3D) {
        switch (code) {
          case 0x2B: // +

          case 0x2D: // -

          case 0x2F: // /

          case 0x3C: // <

          case 0x3E: // >

          case 0x5E: // ^

          case 0x7C: // |

          case 0x25: // %

          case 0x26: // &

          case 0x2A:
            // *
            index += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start: start,
              end: index
            };

          case 0x21: // !

          case 0x3D:
            // =
            index += 2; // !== and ===

            if (source.charCodeAt(index) === 0x3D) {
              ++index;
            }

            return {
              type: TokenPunctuator,
              value: source.slice(start, index),
              start: start,
              end: index
            };
        }
      }

  } // 4-character punctuator: >>>=


  ch4 = source.substr(index, 4);

  if (ch4 === '>>>=') {
    index += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start: start,
      end: index
    };
  } // 3-character punctuators: === !== >>> <<= >>=


  ch3 = ch4.substr(0, 3);

  if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
    index += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start: start,
      end: index
    };
  } // Other 2-character punctuators: ++ -- << >> && ||


  ch2 = ch3.substr(0, 2);

  if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {
    index += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start: start,
      end: index
    };
  }

  if (ch2 === '//') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  } // 1-character punctuators: < > = ! + - * % & | ^ /


  if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
    ++index;
    return {
      type: TokenPunctuator,
      value: ch1,
      start: start,
      end: index
    };
  }

  throwError({}, MessageUnexpectedToken, ILLEGAL);
} // 7.8.3 Numeric Literals


function scanHexLiteral(start) {
  let number = '';

  while (index < length) {
    if (!isHexDigit(source[index])) {
      break;
    }

    number += source[index++];
  }

  if (number.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseInt('0x' + number, 16),
    start: start,
    end: index
  };
}

function scanOctalLiteral(start) {
  let number = '0' + source[index++];

  while (index < length) {
    if (!isOctalDigit(source[index])) {
      break;
    }

    number += source[index++];
  }

  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseInt(number, 8),
    octal: true,
    start: start,
    end: index
  };
}

function scanNumericLiteral() {
  var number, start, ch;
  ch = source[index];
  assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
  start = index;
  number = '';

  if (ch !== '.') {
    number = source[index++];
    ch = source[index]; // Hex number starts with '0x'.
    // Octal number starts with '0'.

    if (number === '0') {
      if (ch === 'x' || ch === 'X') {
        ++index;
        return scanHexLiteral(start);
      }

      if (isOctalDigit(ch)) {
        return scanOctalLiteral(start);
      } // decimal number starts with '0' such as '09' is illegal.


      if (ch && isDecimalDigit(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }

    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }

    ch = source[index];
  }

  if (ch === '.') {
    number += source[index++];

    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }

    ch = source[index];
  }

  if (ch === 'e' || ch === 'E') {
    number += source[index++];
    ch = source[index];

    if (ch === '+' || ch === '-') {
      number += source[index++];
    }

    if (isDecimalDigit(source.charCodeAt(index))) {
      while (isDecimalDigit(source.charCodeAt(index))) {
        number += source[index++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }

  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseFloat(number),
    start: start,
    end: index
  };
} // 7.8.4 String Literals


function scanStringLiteral() {
  var str = '',
      quote,
      start,
      ch,
      code,
      octal = false;
  quote = source[index];
  assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
  start = index;
  ++index;

  while (index < length) {
    ch = source[index++];

    if (ch === quote) {
      quote = '';
      break;
    } else if (ch === '\\') {
      ch = source[index++];

      if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
        switch (ch) {
          case 'u':
          case 'x':
            if (source[index] === '{') {
              ++index;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch);
            }

            break;

          case 'n':
            str += '\n';
            break;

          case 'r':
            str += '\r';
            break;

          case 't':
            str += '\t';
            break;

          case 'b':
            str += '\b';
            break;

          case 'f':
            str += '\f';
            break;

          case 'v':
            str += '\x0B';
            break;

          default:
            if (isOctalDigit(ch)) {
              code = '01234567'.indexOf(ch); // \0 is not octal escape sequence

              if (code !== 0) {
                octal = true;
              }

              if (index < length && isOctalDigit(source[index])) {
                octal = true;
                code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts
                // with 0, 1, 2, 3

                if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                  code = code * 8 + '01234567'.indexOf(source[index++]);
                }
              }

              str += String.fromCharCode(code);
            } else {
              str += ch;
            }

            break;
        }
      } else {
        if (ch === '\r' && source[index] === '\n') {
          ++index;
        }
      }
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      break;
    } else {
      str += ch;
    }
  }

  if (quote !== '') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenStringLiteral,
    value: str,
    octal: octal,
    start: start,
    end: index
  };
}

function testRegExp(pattern, flags) {
  let tmp = pattern;

  if (flags.indexOf('u') >= 0) {
    // Replace each astral symbol and every Unicode code point
    // escape sequence with a single ASCII symbol to avoid throwing on
    // regular expressions that are only valid in combination with the
    // `/u` flag.
    // Note: replacing with the ASCII symbol `x` might cause false
    // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
    // perfectly valid pattern that is equivalent to `[a-b]`, but it
    // would be replaced by `[x-b]` which throws an error.
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 0x10FFFF) {
        return 'x';
      }

      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
  } // First, detect invalid regular expressions.


  try {
    new RegExp(tmp);
  } catch (e) {
    throwError({}, MessageInvalidRegExp);
  } // Return a regular expression object for this pattern-flag pair, or
  // `null` in case the current environment doesn't support the flags it
  // uses.


  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}

function scanRegExpBody() {
  var ch, str, classMarker, terminated, body;
  ch = source[index];
  assert(ch === '/', 'Regular expression literal must start with a slash');
  str = source[index++];
  classMarker = false;
  terminated = false;

  while (index < length) {
    ch = source[index++];
    str += ch;

    if (ch === '\\') {
      ch = source[index++]; // ECMA-262 7.8.5

      if (isLineTerminator(ch.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }

      str += ch;
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch === ']') {
        classMarker = false;
      }
    } else {
      if (ch === '/') {
        terminated = true;
        break;
      } else if (ch === '[') {
        classMarker = true;
      }
    }
  }

  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  } // Exclude leading and trailing slash.


  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}

function scanRegExpFlags() {
  var ch, str, flags;
  str = '';
  flags = '';

  while (index < length) {
    ch = source[index];

    if (!isIdentifierPart(ch.charCodeAt(0))) {
      break;
    }

    ++index;

    if (ch === '\\' && index < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch;
      str += ch;
    }
  }

  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }

  return {
    value: flags,
    literal: str
  };
}

function scanRegExp() {
  var start, body, flags, value;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start: start,
    end: index
  };
}

function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}

function advance() {
  skipComment();

  if (index >= length) {
    return {
      type: TokenEOF,
      start: index,
      end: index
    };
  }

  const ch = source.charCodeAt(index);

  if (isIdentifierStart(ch)) {
    return scanIdentifier();
  } // Very common: ( and ) and ;


  if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
    return scanPunctuator();
  } // String literal starts with single quote (U+0027) or double quote (U+0022).


  if (ch === 0x27 || ch === 0x22) {
    return scanStringLiteral();
  } // Dot (.) U+002E can also start a floating-point number, hence the need
  // to check the next character.


  if (ch === 0x2E) {
    if (isDecimalDigit(source.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }

    return scanPunctuator();
  }

  if (isDecimalDigit(ch)) {
    return scanNumericLiteral();
  }

  return scanPunctuator();
}

function lex() {
  const token = lookahead;
  index = token.end;
  lookahead = advance();
  index = token.end;
  return token;
}

function peek() {
  const pos = index;
  lookahead = advance();
  index = pos;
}

function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}

function finishBinaryExpression(operator, left, right) {
  const node = new ASTNode(operator === '||' || operator === '&&' ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator;
  node.left = left;
  node.right = right;
  return node;
}

function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}

function finishConditionalExpression(test, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}

function finishIdentifier(name) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name;
  return node;
}

function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source.slice(token.start, token.end);

  if (token.regex) {
    if (node.raw === '//') {
      node.raw = '/(?:)/';
    }

    node.regex = token.regex;
  }

  return node;
}

function finishMemberExpression(accessor, object, property) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor === '[';
  node.object = object;
  node.property = property;
  if (!node.computed) property.member = true;
  return node;
}

function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}

function finishProperty(kind, key, value) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key;
  node.value = value;
  node.kind = kind;
  return node;
}

function finishUnaryExpression(operator, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator;
  node.argument = argument;
  node.prefix = true;
  return node;
} // Throw an exception


function throwError(token, messageFormat) {
  var error,
      args = Array.prototype.slice.call(arguments, 2),
      msg = messageFormat.replace(/%(\d)/g, (whole, index) => {
    assert(index < args.length, 'Message reference must be in range');
    return args[index];
  });
  error = new Error(msg);
  error.index = index;
  error.description = msg;
  throw error;
} // Throw an exception because of the token.


function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }

  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }

  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }

  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }

  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  } // BooleanLiteral, NullLiteral, or Punctuator.


  throwError(token, MessageUnexpectedToken, token.value);
} // Expect the next token to match the specified punctuator.
// If not, an exception will be thrown.


function expect(value) {
  const token = lex();

  if (token.type !== TokenPunctuator || token.value !== value) {
    throwUnexpected(token);
  }
} // Return true if the next token matches the specified punctuator.


function match(value) {
  return lookahead.type === TokenPunctuator && lookahead.value === value;
} // Return true if the next token matches the specified keyword


function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
} // 11.1.4 Array Initialiser


function parseArrayInitialiser() {
  const elements = [];
  index = lookahead.start;
  expect('[');

  while (!match(']')) {
    if (match(',')) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());

      if (!match(']')) {
        expect(',');
      }
    }
  }

  lex();
  return finishArrayExpression(elements);
} // 11.1.5 Object Initialiser


function parseObjectPropertyKey() {
  index = lookahead.start;
  const token = lex(); // Note: This function is called only from parseObjectProperty(), where
  // EOF and Punctuator tokens are already filtered out.

  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }

    return finishLiteral(token);
  }

  return finishIdentifier(token.value);
}

function parseObjectProperty() {
  var token, key, id, value;
  index = lookahead.start;
  token = lookahead;

  if (token.type === TokenIdentifier) {
    id = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', id, value);
  }

  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', key, value);
  }
}

function parseObjectInitialiser() {
  var properties = [],
      property,
      name,
      key,
      map = {},
      toString = String;
  index = lookahead.start;
  expect('{');

  while (!match('}')) {
    property = parseObjectProperty();

    if (property.key.type === SyntaxIdentifier) {
      name = property.key.name;
    } else {
      name = toString(property.key.value);
    }

    key = '$' + name;

    if (Object.prototype.hasOwnProperty.call(map, key)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map[key] = true;
    }

    properties.push(property);

    if (!match('}')) {
      expect(',');
    }
  }

  expect('}');
  return finishObjectExpression(properties);
} // 11.1.6 The Grouping Operator


function parseGroupExpression() {
  expect('(');
  const expr = parseExpression();
  expect(')');
  return expr;
} // 11.1 Primary Expressions


const legalKeywords = {
  'if': 1
};

function parsePrimaryExpression() {
  var type, token, expr;

  if (match('(')) {
    return parseGroupExpression();
  }

  if (match('[')) {
    return parseArrayInitialiser();
  }

  if (match('{')) {
    return parseObjectInitialiser();
  }

  type = lookahead.type;
  index = lookahead.start;

  if (type === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr = finishIdentifier(lex().value);
  } else if (type === TokenStringLiteral || type === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }

    expr = finishLiteral(lex());
  } else if (type === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === 'true';
    expr = finishLiteral(token);
  } else if (type === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr = finishLiteral(token);
  } else if (match('/') || match('/=')) {
    expr = finishLiteral(scanRegExp());
    peek();
  } else {
    throwUnexpected(lex());
  }

  return expr;
} // 11.2 Left-Hand-Side Expressions


function parseArguments() {
  const args = [];
  expect('(');

  if (!match(')')) {
    while (index < length) {
      args.push(parseConditionalExpression());

      if (match(')')) {
        break;
      }

      expect(',');
    }
  }

  expect(')');
  return args;
}

function parseNonComputedProperty() {
  index = lookahead.start;
  const token = lex();

  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }

  return finishIdentifier(token.value);
}

function parseNonComputedMember() {
  expect('.');
  return parseNonComputedProperty();
}

function parseComputedMember() {
  expect('[');
  const expr = parseExpression();
  expect(']');
  return expr;
}

function parseLeftHandSideExpressionAllowCall() {
  var expr, args, property;
  expr = parsePrimaryExpression();

  for (;;) {
    if (match('.')) {
      property = parseNonComputedMember();
      expr = finishMemberExpression('.', expr, property);
    } else if (match('(')) {
      args = parseArguments();
      expr = finishCallExpression(expr, args);
    } else if (match('[')) {
      property = parseComputedMember();
      expr = finishMemberExpression('[', expr, property);
    } else {
      break;
    }
  }

  return expr;
} // 11.3 Postfix Expressions


function parsePostfixExpression() {
  const expr = parseLeftHandSideExpressionAllowCall();

  if (lookahead.type === TokenPunctuator) {
    if (match('++') || match('--')) {
      throw new Error(DISABLED);
    }
  }

  return expr;
} // 11.4 Unary Operators


function parseUnaryExpression() {
  var token, expr;

  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr = parsePostfixExpression();
  } else if (match('++') || match('--')) {
    throw new Error(DISABLED);
  } else if (match('+') || match('-') || match('~') || match('!')) {
    token = lex();
    expr = parseUnaryExpression();
    expr = finishUnaryExpression(token.value, expr);
  } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
    throw new Error(DISABLED);
  } else {
    expr = parsePostfixExpression();
  }

  return expr;
}

function binaryPrecedence(token) {
  let prec = 0;

  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }

  switch (token.value) {
    case '||':
      prec = 1;
      break;

    case '&&':
      prec = 2;
      break;

    case '|':
      prec = 3;
      break;

    case '^':
      prec = 4;
      break;

    case '&':
      prec = 5;
      break;

    case '==':
    case '!=':
    case '===':
    case '!==':
      prec = 6;
      break;

    case '<':
    case '>':
    case '<=':
    case '>=':
    case 'instanceof':
    case 'in':
      prec = 7;
      break;

    case '<<':
    case '>>':
    case '>>>':
      prec = 8;
      break;

    case '+':
    case '-':
      prec = 9;
      break;

    case '*':
    case '/':
    case '%':
      prec = 11;
      break;
  }

  return prec;
} // 11.5 Multiplicative Operators
// 11.6 Additive Operators
// 11.7 Bitwise Shift Operators
// 11.8 Relational Operators
// 11.9 Equality Operators
// 11.10 Binary Bitwise Operators
// 11.11 Binary Logical Operators


function parseBinaryExpression() {
  var marker, markers, expr, token, prec, stack, right, operator, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);

  if (prec === 0) {
    return left;
  }

  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack = [left, token, right];

  while ((prec = binaryPrecedence(lookahead)) > 0) {
    // Reduce: make a binary expression from the three topmost entries.
    while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
      right = stack.pop();
      operator = stack.pop().value;
      left = stack.pop();
      markers.pop();
      expr = finishBinaryExpression(operator, left, right);
      stack.push(expr);
    } // Shift.


    token = lex();
    token.prec = prec;
    stack.push(token);
    markers.push(lookahead);
    expr = parseUnaryExpression();
    stack.push(expr);
  } // Final reduce to clean-up the stack.


  i = stack.length - 1;
  expr = stack[i];
  markers.pop();

  while (i > 1) {
    markers.pop();
    expr = finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
    i -= 2;
  }

  return expr;
} // 11.12 Conditional Operator


function parseConditionalExpression() {
  var expr, consequent, alternate;
  expr = parseBinaryExpression();

  if (match('?')) {
    lex();
    consequent = parseConditionalExpression();
    expect(':');
    alternate = parseConditionalExpression();
    expr = finishConditionalExpression(expr, consequent, alternate);
  }

  return expr;
} // 11.14 Comma Operator


function parseExpression() {
  const expr = parseConditionalExpression();

  if (match(',')) {
    throw new Error(DISABLED); // no sequence expressions
  }

  return expr;
}

function parser (code) {
  source = code;
  index = 0;
  length = source.length;
  lookahead = null;
  peek();
  const expr = parseExpression();

  if (lookahead.type !== TokenEOF) {
    throw new Error('Unexpect token after expression.');
  }

  return expr;
}

var Constants = {
  NaN: 'NaN',
  E: 'Math.E',
  LN2: 'Math.LN2',
  LN10: 'Math.LN10',
  LOG2E: 'Math.LOG2E',
  LOG10E: 'Math.LOG10E',
  PI: 'Math.PI',
  SQRT1_2: 'Math.SQRT1_2',
  SQRT2: 'Math.SQRT2',
  MIN_VALUE: 'Number.MIN_VALUE',
  MAX_VALUE: 'Number.MAX_VALUE'
};

function Functions (codegen) {
  function fncall(name, args, cast, type) {
    let obj = codegen(args[0]);

    if (cast) {
      obj = cast + '(' + obj + ')';
      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';
    }

    return obj + '.' + name + (type < 0 ? '' : type === 0 ? '()' : '(' + args.slice(1).map(codegen).join(',') + ')');
  }

  function fn(name, cast, type) {
    return args => fncall(name, args, cast, type);
  }

  const DATE = 'new Date',
        STRING = 'String',
        REGEXP = 'RegExp';
  return {
    // MATH functions
    isNaN: 'Number.isNaN',
    isFinite: 'Number.isFinite',
    abs: 'Math.abs',
    acos: 'Math.acos',
    asin: 'Math.asin',
    atan: 'Math.atan',
    atan2: 'Math.atan2',
    ceil: 'Math.ceil',
    cos: 'Math.cos',
    exp: 'Math.exp',
    floor: 'Math.floor',
    log: 'Math.log',
    max: 'Math.max',
    min: 'Math.min',
    pow: 'Math.pow',
    random: 'Math.random',
    round: 'Math.round',
    sin: 'Math.sin',
    sqrt: 'Math.sqrt',
    tan: 'Math.tan',
    clamp: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to clamp function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to clamp function.');
      const a = args.map(codegen);
      return 'Math.max(' + a[1] + ', Math.min(' + a[2] + ',' + a[0] + '))';
    },
    // DATE functions
    now: 'Date.now',
    utc: 'Date.UTC',
    datetime: DATE,
    date: fn('getDate', DATE, 0),
    day: fn('getDay', DATE, 0),
    year: fn('getFullYear', DATE, 0),
    month: fn('getMonth', DATE, 0),
    hours: fn('getHours', DATE, 0),
    minutes: fn('getMinutes', DATE, 0),
    seconds: fn('getSeconds', DATE, 0),
    milliseconds: fn('getMilliseconds', DATE, 0),
    time: fn('getTime', DATE, 0),
    timezoneoffset: fn('getTimezoneOffset', DATE, 0),
    utcdate: fn('getUTCDate', DATE, 0),
    utcday: fn('getUTCDay', DATE, 0),
    utcyear: fn('getUTCFullYear', DATE, 0),
    utcmonth: fn('getUTCMonth', DATE, 0),
    utchours: fn('getUTCHours', DATE, 0),
    utcminutes: fn('getUTCMinutes', DATE, 0),
    utcseconds: fn('getUTCSeconds', DATE, 0),
    utcmilliseconds: fn('getUTCMilliseconds', DATE, 0),
    // sequence functions
    length: fn('length', null, -1),
    // STRING functions
    parseFloat: 'parseFloat',
    parseInt: 'parseInt',
    upper: fn('toUpperCase', STRING, 0),
    lower: fn('toLowerCase', STRING, 0),
    substring: fn('substring', STRING),
    split: fn('split', STRING),
    trim: fn('trim', STRING, 0),
    // REGEXP functions
    regexp: REGEXP,
    test: fn('test', REGEXP),
    // Control Flow functions
    if: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to if function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to if function.');
      const a = args.map(codegen);
      return '(' + a[0] + '?' + a[1] + ':' + a[2] + ')';
    }
  };
}

function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === '\'' && s[n] === '\'') ? s.slice(1, -1) : s;
}

function codegen (opt) {
  opt = opt || {};
  const allowed = opt.allowed ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.allowed) : {},
        forbidden = opt.forbidden ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.forbidden) : {},
        constants = opt.constants || Constants,
        functions = (opt.functions || Functions)(visit),
        globalvar = opt.globalvar,
        fieldvar = opt.fieldvar,
        outputGlobal = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(globalvar) ? globalvar : id => `${globalvar}["${id}"]`;
  let globals = {},
      fields = {},
      memberDepth = 0;

  function visit(ast) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(ast)) return ast;
    const generator = Generators[ast.type];
    if (generator == null) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported type: ' + ast.type);
    return generator(ast);
  }

  const Generators = {
    Literal: n => n.raw,
    Identifier: n => {
      const id = n.name;

      if (memberDepth > 0) {
        return id;
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(forbidden, id)) {
        return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal identifier: ' + id);
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(constants, id)) {
        return constants[id];
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(allowed, id)) {
        return id;
      } else {
        globals[id] = 1;
        return outputGlobal(id);
      }
    },
    MemberExpression: n => {
      const d = !n.computed,
            o = visit(n.object);
      if (d) memberDepth += 1;
      const p = visit(n.property);

      if (o === fieldvar) {
        // strip quotes to sanitize field name (#1653)
        fields[stripQuotes(p)] = 1;
      }

      if (d) memberDepth -= 1;
      return o + (d ? '.' + p : '[' + p + ']');
    },
    CallExpression: n => {
      if (n.callee.type !== 'Identifier') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal callee type: ' + n.callee.type);
      }

      const callee = n.callee.name,
            args = n.arguments,
            fn = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(functions, callee) && functions[callee];
      if (!fn) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized function: ' + callee);
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(fn) ? fn(args) : fn + '(' + args.map(visit).join(',') + ')';
    },
    ArrayExpression: n => '[' + n.elements.map(visit).join(',') + ']',
    BinaryExpression: n => '(' + visit(n.left) + ' ' + n.operator + ' ' + visit(n.right) + ')',
    UnaryExpression: n => '(' + n.operator + visit(n.argument) + ')',
    ConditionalExpression: n => '(' + visit(n.test) + '?' + visit(n.consequent) + ':' + visit(n.alternate) + ')',
    LogicalExpression: n => '(' + visit(n.left) + n.operator + visit(n.right) + ')',
    ObjectExpression: n => '{' + n.properties.map(visit).join(',') + '}',
    Property: n => {
      memberDepth += 1;
      const k = visit(n.key);
      memberDepth -= 1;
      return k + ':' + visit(n.value);
    }
  };

  function codegen(ast) {
    const result = {
      code: visit(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }

  codegen.functions = functions;
  codegen.constants = constants;
  return codegen;
}




/***/ }),

/***/ "../../node_modules/vega-force/build/vega-force.module.js":
/*!****************************************************************!*\
  !*** ../../node_modules/vega-force/build/vega-force.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "force": () => (/* binding */ Force)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-force */ "../../node_modules/vega-force/node_modules/d3-force/src/center.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-force */ "../../node_modules/vega-force/node_modules/d3-force/src/collide.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-force */ "../../node_modules/vega-force/node_modules/d3-force/src/manyBody.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-force */ "../../node_modules/vega-force/node_modules/d3-force/src/link.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-force */ "../../node_modules/vega-force/node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-force */ "../../node_modules/vega-force/node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-force */ "../../node_modules/vega-force/node_modules/d3-force/src/simulation.js");




const ForceMap = {
  center: d3_force__WEBPACK_IMPORTED_MODULE_2__.default,
  collide: d3_force__WEBPACK_IMPORTED_MODULE_3__.default,
  nbody: d3_force__WEBPACK_IMPORTED_MODULE_4__.default,
  link: d3_force__WEBPACK_IMPORTED_MODULE_5__.default,
  x: d3_force__WEBPACK_IMPORTED_MODULE_6__.default,
  y: d3_force__WEBPACK_IMPORTED_MODULE_7__.default
};
const Forces = 'forces',
      ForceParams = ['alpha', 'alphaMin', 'alphaTarget', 'velocityDecay', 'forces'],
      ForceConfig = ['static', 'iterations'],
      ForceOutput = ['x', 'y', 'vx', 'vy'];
/**
 * Force simulation layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<object>} params.forces - The forces to apply.
 */

function Force(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Force.Definition = {
  'type': 'Force',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'static',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'restart',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'iterations',
    'type': 'number',
    'default': 300
  }, {
    'name': 'alpha',
    'type': 'number',
    'default': 1
  }, {
    'name': 'alphaMin',
    'type': 'number',
    'default': 0.001
  }, {
    'name': 'alphaTarget',
    'type': 'number',
    'default': 0
  }, {
    'name': 'velocityDecay',
    'type': 'number',
    'default': 0.4
  }, {
    'name': 'forces',
    'type': 'param',
    'array': true,
    'params': [{
      'key': {
        'force': 'center'
      },
      'params': [{
        'name': 'x',
        'type': 'number',
        'default': 0
      }, {
        'name': 'y',
        'type': 'number',
        'default': 0
      }]
    }, {
      'key': {
        'force': 'collide'
      },
      'params': [{
        'name': 'radius',
        'type': 'number',
        'expr': true
      }, {
        'name': 'strength',
        'type': 'number',
        'default': 0.7
      }, {
        'name': 'iterations',
        'type': 'number',
        'default': 1
      }]
    }, {
      'key': {
        'force': 'nbody'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': -30
      }, {
        'name': 'theta',
        'type': 'number',
        'default': 0.9
      }, {
        'name': 'distanceMin',
        'type': 'number',
        'default': 1
      }, {
        'name': 'distanceMax',
        'type': 'number'
      }]
    }, {
      'key': {
        'force': 'link'
      },
      'params': [{
        'name': 'links',
        'type': 'data'
      }, {
        'name': 'id',
        'type': 'field'
      }, {
        'name': 'distance',
        'type': 'number',
        'default': 30,
        'expr': true
      }, {
        'name': 'strength',
        'type': 'number',
        'expr': true
      }, {
        'name': 'iterations',
        'type': 'number',
        'default': 1
      }]
    }, {
      'key': {
        'force': 'x'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': 0.1
      }, {
        'name': 'x',
        'type': 'field'
      }]
    }, {
      'key': {
        'force': 'y'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': 0.1
      }, {
        'name': 'y',
        'type': 'field'
      }]
    }]
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'modify': false,
    'default': ForceOutput
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Force, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var sim = this.value,
        change = pulse.changed(pulse.ADD_REM),
        params = _.modified(ForceParams),
        iters = _.iterations || 300; // configure simulation


    if (!sim) {
      this.value = sim = simulation(pulse.source, _);
      sim.on('tick', rerun(pulse.dataflow, this));

      if (!_.static) {
        change = true;
        sim.tick(); // ensure we run on init
      }

      pulse.modifies('index');
    } else {
      if (change) {
        pulse.modifies('index');
        sim.nodes(pulse.source);
      }

      if (params || pulse.changed(pulse.MOD)) {
        setup(sim, _, 0, pulse);
      }
    } // run simulation


    if (params || change || _.modified(ForceConfig) || pulse.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));

      if (_.static) {
        for (sim.stop(); --iters >= 0;) sim.tick();
      } else {
        if (sim.stopped()) sim.restart();
        if (!change) return pulse.StopPropagation; // defer to sim ticks
      }
    }

    return this.finish(_, pulse);
  },

  finish(_, pulse) {
    const dataflow = pulse.dataflow; // inspect dependencies, touch link source data

    for (let args = this._argops, j = 0, m = args.length, arg; j < m; ++j) {
      arg = args[j];

      if (arg.name !== Forces || arg.op._argval.force !== 'link') {
        continue;
      }

      for (var ops = arg.op._argops, i = 0, n = ops.length, op; i < n; ++i) {
        if (ops[i].name === 'links' && (op = ops[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    } // reflow all nodes


    return pulse.reflow(_.modified()).modifies(ForceOutput);
  }

});

function rerun(df, op) {
  return () => df.touch(op).run();
}

function simulation(nodes, _) {
  const sim = (0,d3_force__WEBPACK_IMPORTED_MODULE_8__.default)(nodes),
        stop = sim.stop,
        restart = sim.restart;
  let stopped = false;

  sim.stopped = () => stopped;

  sim.restart = () => (stopped = false, restart());

  sim.stop = () => (stopped = true, stop());

  return setup(sim, _, true).on('end', () => stopped = true);
}

function setup(sim, _, init, pulse) {
  var f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_.forces),
      i,
      n,
      p,
      name;

  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p)) sim[p](_[p]);
  }

  for (i = 0, n = f.length; i < n; ++i) {
    name = Forces + i;
    p = init || _.modified(Forces, i) ? getForce(f[i]) : pulse && modified(f[i], pulse) ? sim.force(name) : null;
    if (p) sim.force(name, p);
  }

  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null); // remove
  }

  sim.numForces = f.length;
  return sim;
}

function modified(f, pulse) {
  var k, v;

  for (k in f) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(v = f[k]) && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(v))) return 1;
  }

  return 0;
}

function getForce(_) {
  var f, p;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(ForceMap, _.force)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized force: ' + _.force);
  }

  f = ForceMap[_.force]();

  for (p in _) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f[p])) setForceParam(f[p], _[p], _);
  }

  return f;
}

function setForceParam(f, v, _) {
  f((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(v) ? d => v(d, _) : v);
}




/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-dispatch/src/dispatch.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-dispatch/src/dispatch.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/center.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/center.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var nodes, strength = 1;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/collide.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/collide.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/vega-force/node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jiggle.js */ "../../node_modules/vega-force/node_modules/d3-force/src/jiggle.js");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__.default)(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__.default)(random), l += x * x;
            if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__.default)(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/constant.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/constant.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/jiggle.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/jiggle.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/lcg.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/lcg.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/link.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/link.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/vega-force/node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jiggle.js */ "../../node_modules/vega-force/node_modules/d3-force/src/jiggle.js");



function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(30),
      distances,
      nodes,
      count,
      bias,
      random,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__.default)(random);
        y = target.y + target.vy - source.y - source.vy || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__.default)(random);
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initializeDistance(), force) : distance;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/manyBody.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/manyBody.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/vega-force/node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jiggle.js */ "../../node_modules/vega-force/node_modules/d3-force/src/jiggle.js");
/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./simulation.js */ "../../node_modules/vega-force/node_modules/d3-force/src/simulation.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes,
      node,
      random,
      alpha,
      strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__.default)(nodes, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.x, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.y).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += x * x;
        if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += x * x;
      if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/simulation.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/simulation.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ x),
/* harmony export */   "y": () => (/* binding */ y),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "../../node_modules/vega-force/node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "../../node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "../../node_modules/vega-force/node_modules/d3-force/src/lcg.js");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__.default)("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__.default)();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/x.js":
/*!********************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/x.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/vega-force/node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-force/src/y.js":
/*!********************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-force/src/y.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/vega-force/node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/add.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/add.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "addAll": () => (/* binding */ addAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/cover.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/cover.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/data.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/data.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/extent.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/extent.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/find.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/find.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/quad.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/quad.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/quadtree.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/quadtree.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__.default;
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__.default;
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__.default;
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__.default;
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__.default;
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__.default;
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__.default;
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__.default;
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__.default;
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__.default;
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__.default;
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__.default;


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/remove.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/remove.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "removeAll": () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/root.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/root.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/size.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/size.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/visit.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/visit.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/visitAfter.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/visitAfter.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "../../node_modules/vega-force/node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/x.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/x.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultX": () => (/* binding */ defaultX),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "../../node_modules/vega-force/node_modules/d3-quadtree/src/y.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/vega-force/node_modules/d3-quadtree/src/y.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultY": () => (/* binding */ defaultY),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "../../node_modules/vega-format/build/vega-format.module.js":
/*!******************************************************************!*\
  !*** ../../node_modules/vega-format/build/vega-format.module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultLocale": () => (/* binding */ defaultLocale),
/* harmony export */   "locale": () => (/* binding */ locale),
/* harmony export */   "numberFormatDefaultLocale": () => (/* binding */ numberFormatDefaultLocale),
/* harmony export */   "numberFormatLocale": () => (/* binding */ numberFormatLocale),
/* harmony export */   "resetDefaultLocale": () => (/* binding */ resetDefaultLocale),
/* harmony export */   "resetNumberFormatDefaultLocale": () => (/* binding */ resetNumberFormatDefaultLocale),
/* harmony export */   "resetTimeFormatDefaultLocale": () => (/* binding */ resetTimeFormatDefaultLocale),
/* harmony export */   "timeFormatDefaultLocale": () => (/* binding */ timeFormatDefaultLocale),
/* harmony export */   "timeFormatLocale": () => (/* binding */ timeFormatLocale)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionFixed.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/locale.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time-format */ "../../node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time-format */ "../../node_modules/d3-time-format/src/locale.js");






function memoize (method) {
  const cache = {};
  return spec => cache[spec] || (cache[spec] = method(spec));
}

function trimZeroes(numberFormat, decimalChar) {
  return x => {
    const str = numberFormat(x),
          dec = str.indexOf(decimalChar);
    if (dec < 0) return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : '';

    while (--idx > dec) if (str[idx] !== '0') {
      ++idx;
      break;
    }

    return str.slice(0, idx) + end;
  };
}

function rightmostDigit(str, dec) {
  let i = str.lastIndexOf('e'),
      c;
  if (i > 0) return i;

  for (i = str.length; --i > dec;) {
    c = str.charCodeAt(i);
    if (c >= 48 && c <= 57) return i + 1; // is digit
  }
}

function numberLocale(locale) {
  const format = memoize(locale.format),
        formatPrefix = locale.formatPrefix;
  return {
    format,
    formatPrefix,

    formatFloat(spec) {
      const s = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(spec || ',');

      if (s.precision == null) {
        s.precision = 12;

        switch (s.type) {
          case '%':
            s.precision -= 2;
            break;

          case 'e':
            s.precision -= 1;
            break;
        }

        return trimZeroes(format(s), // number format
        format('.1f')(1)[1] // decimal point character
        );
      } else {
        return format(s);
      }
    },

    formatSpan(start, stop, count, specifier) {
      specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(specifier == null ? ',f' : specifier);
      const step = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start, stop, count),
            value = Math.max(Math.abs(start), Math.abs(stop));
      let precision;

      if (specifier.precision == null) {
        switch (specifier.type) {
          case 's':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.default)(step, value))) {
                specifier.precision = precision;
              }

              return formatPrefix(specifier, value);
            }

          case '':
          case 'e':
          case 'g':
          case 'p':
          case 'r':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__.default)(step, value))) {
                specifier.precision = precision - (specifier.type === 'e');
              }

              break;
            }

          case 'f':
          case '%':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_6__.default)(step))) {
                specifier.precision = precision - (specifier.type === '%') * 2;
              }

              break;
            }
        }
      }

      return format(specifier);
    }

  };
}

let defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format: d3_format__WEBPACK_IMPORTED_MODULE_7__.format,
    formatPrefix: d3_format__WEBPACK_IMPORTED_MODULE_7__.formatPrefix
  });
}
function numberFormatLocale(definition) {
  return numberLocale((0,d3_format__WEBPACK_IMPORTED_MODULE_8__.default)(definition));
}
function numberFormatDefaultLocale(definition) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition) : defaultNumberLocale;
}

function timeMultiFormat(format, interval, spec) {
  spec = spec || {};

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(spec)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)("Invalid time multi-format specifier: ".concat(spec));
  }

  const second = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.SECONDS),
        minute = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.MINUTES),
        hour = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.HOURS),
        day = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.DATE),
        week = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.WEEK),
        month = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.MONTH),
        quarter = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.QUARTER),
        year = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.YEAR),
        L = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MILLISECONDS] || '.%L'),
        S = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.SECONDS] || ':%S'),
        M = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MINUTES] || '%I:%M'),
        H = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.HOURS] || '%I %p'),
        d = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.DATE] || spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.DAY] || '%a %d'),
        w = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.WEEK] || '%b %d'),
        m = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MONTH] || '%B'),
        q = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.QUARTER] || '%B'),
        y = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.YEAR] || '%Y');
  return date => (second(date) < date ? L : minute(date) < date ? S : hour(date) < date ? M : day(date) < date ? H : month(date) < date ? week(date) < date ? d : w : year(date) < date ? quarter(date) < date ? m : q : y)(date);
}

function timeLocale(locale) {
  const timeFormat = memoize(locale.format),
        utcFormat = memoize(locale.utcFormat);
  return {
    timeFormat: spec => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isString)(spec) ? timeFormat(spec) : timeMultiFormat(timeFormat, vega_time__WEBPACK_IMPORTED_MODULE_0__.timeInterval, spec),
    utcFormat: spec => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isString)(spec) ? utcFormat(spec) : timeMultiFormat(utcFormat, vega_time__WEBPACK_IMPORTED_MODULE_0__.utcInterval, spec),
    timeParse: memoize(locale.parse),
    utcParse: memoize(locale.utcParse)
  };
}

let defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.timeFormat,
    parse: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.timeParse,
    utcFormat: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.utcFormat,
    utcParse: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.utcParse
  });
}
function timeFormatLocale(definition) {
  return timeLocale((0,d3_time_format__WEBPACK_IMPORTED_MODULE_10__.default)(definition));
}
function timeFormatDefaultLocale(definition) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition) : defaultTimeLocale;
}

const createLocale = (number, time) => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, number, time);

function locale(numberSpec, timeSpec) {
  const number = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
  const time = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
  return createLocale(number, time);
}
function defaultLocale(numberSpec, timeSpec) {
  const args = arguments.length;

  if (args && args !== 2) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('defaultLocale expects either zero or two arguments.');
  }

  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale();
  resetTimeFormatDefaultLocale();
  return defaultLocale();
}




/***/ }),

/***/ "../../node_modules/vega-functions/build/vega-functions.module.js":
/*!************************************************************************!*\
  !*** ../../node_modules/vega-functions/build/vega-functions.module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataPrefix": () => (/* binding */ DataPrefix),
/* harmony export */   "IndexPrefix": () => (/* binding */ IndexPrefix),
/* harmony export */   "ScalePrefix": () => (/* binding */ ScalePrefix),
/* harmony export */   "SignalPrefix": () => (/* binding */ SignalPrefix),
/* harmony export */   "bandspace": () => (/* binding */ bandspace),
/* harmony export */   "bandwidth": () => (/* binding */ bandwidth),
/* harmony export */   "codeGenerator": () => (/* binding */ codeGenerator),
/* harmony export */   "codegenParams": () => (/* binding */ codegenParams),
/* harmony export */   "containerSize": () => (/* binding */ containerSize),
/* harmony export */   "contrast": () => (/* binding */ contrast),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "data": () => (/* binding */ data),
/* harmony export */   "dataVisitor": () => (/* binding */ dataVisitor),
/* harmony export */   "dayAbbrevFormat": () => (/* binding */ dayAbbrevFormat),
/* harmony export */   "dayFormat": () => (/* binding */ dayFormat),
/* harmony export */   "debug": () => (/* binding */ debug),
/* harmony export */   "domain": () => (/* binding */ domain),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "expressionFunction": () => (/* binding */ expressionFunction),
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "functionContext": () => (/* binding */ functionContext),
/* harmony export */   "geoArea": () => (/* binding */ geoArea),
/* harmony export */   "geoBounds": () => (/* binding */ geoBounds),
/* harmony export */   "geoCentroid": () => (/* binding */ geoCentroid),
/* harmony export */   "geoShape": () => (/* binding */ geoShape),
/* harmony export */   "inScope": () => (/* binding */ inScope),
/* harmony export */   "indata": () => (/* binding */ indata),
/* harmony export */   "indataVisitor": () => (/* binding */ indataVisitor),
/* harmony export */   "indexof": () => (/* binding */ indexof),
/* harmony export */   "info": () => (/* binding */ info),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "join": () => (/* binding */ join),
/* harmony export */   "lastindexof": () => (/* binding */ lastindexof),
/* harmony export */   "luminance": () => (/* binding */ luminance),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "modify": () => (/* binding */ modify),
/* harmony export */   "monthAbbrevFormat": () => (/* binding */ monthAbbrevFormat),
/* harmony export */   "monthFormat": () => (/* binding */ monthFormat),
/* harmony export */   "parseExpression": () => (/* binding */ parser),
/* harmony export */   "pathShape": () => (/* binding */ pathShape),
/* harmony export */   "pinchAngle": () => (/* binding */ pinchAngle),
/* harmony export */   "pinchDistance": () => (/* binding */ pinchDistance),
/* harmony export */   "pluck": () => (/* binding */ pluck),
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "replace": () => (/* binding */ replace),
/* harmony export */   "reverse": () => (/* binding */ reverse),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleGradient": () => (/* binding */ scaleGradient),
/* harmony export */   "scaleVisitor": () => (/* binding */ scaleVisitor),
/* harmony export */   "screen": () => (/* binding */ screen),
/* harmony export */   "setdata": () => (/* binding */ setdata),
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "timeFormat": () => (/* binding */ timeFormat),
/* harmony export */   "timeParse": () => (/* binding */ timeParse),
/* harmony export */   "treeAncestors": () => (/* binding */ treeAncestors),
/* harmony export */   "treePath": () => (/* binding */ treePath),
/* harmony export */   "utcFormat": () => (/* binding */ utcFormat),
/* harmony export */   "utcParse": () => (/* binding */ utcParse),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "windowSize": () => (/* binding */ windowSize)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-expression */ "../../node_modules/vega-expression/build/vega-expression.module.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/area.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/bounds.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/centroid.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/lab.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_selections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-selections */ "../../node_modules/vega-selections/build/vega-selection.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");












function data(name) {
  const data = this.context.data[name];
  return data ? data.values.value : [];
}
function indata(name, field, value) {
  const index = this.context.data[name]['index:' + field],
        entry = index ? index.value.get(value) : undefined;
  return entry ? entry.count : entry;
}
function setdata(name, tuples) {
  const df = this.context.dataflow,
        data = this.context.data[name],
        input = data.input;
  df.pulse(input, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(tuples));
  return 1;
}

function encode (item, name, retval) {
  if (item) {
    const df = this.context.dataflow,
          target = item.mark.source;
    df.pulse(target, df.changeset().encode(item, name));
  }

  return retval !== undefined ? retval : item;
}

const wrap = method => function (value, spec) {
  const locale = this.context.dataflow.locale();
  return locale[method](spec)(value);
};

const format = wrap('format');
const timeFormat = wrap('timeFormat');
const utcFormat = wrap('utcFormat');
const timeParse = wrap('timeParse');
const utcParse = wrap('utcParse');
const dateObj = new Date(2000, 0, 1);

function time(month, day, specifier) {
  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';
  dateObj.setYear(2000);
  dateObj.setMonth(month);
  dateObj.setDate(day);
  return timeFormat.call(this, dateObj, specifier);
}

function monthFormat(month) {
  return time.call(this, month, 1, '%B');
}
function monthAbbrevFormat(month) {
  return time.call(this, month, 1, '%b');
}
function dayFormat(day) {
  return time.call(this, 0, 2 + day, '%A');
}
function dayAbbrevFormat(day) {
  return time.call(this, 0, 2 + day, '%a');
}

const DataPrefix = ':';
const IndexPrefix = '@';
const ScalePrefix = '%';
const SignalPrefix = '$';

function dataVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to data functions must be a string literal.');
  }

  const data = args[0].value,
        dataName = DataPrefix + data;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(dataName, params)) {
    try {
      params[dataName] = scope.getData(data).tuplesRef();
    } catch (err) {// if data set does not exist, there's nothing to track
    }
  }
}
function indataVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to indata must be a string literal.');
  if (args[1].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Second argument to indata must be a string literal.');
  const data = args[0].value,
        field = args[1].value,
        indexName = IndexPrefix + field;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(indexName, params)) {
    params[indexName] = scope.getData(data).indataRef(scope, field);
  }
}
function scaleVisitor(name, args, scope, params) {
  if (args[0].type === vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) {
    // add scale dependency
    addScaleDependency(scope, params, args[0].value);
  } else {
    // indirect scale lookup; add all scales as parameters
    for (name in scope.scales) {
      addScaleDependency(scope, params, name);
    }
  }
}

function addScaleDependency(scope, params, name) {
  const scaleName = ScalePrefix + name;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, scaleName)) {
    try {
      params[scaleName] = scope.scaleRef(name);
    } catch (err) {// TODO: error handling? warning?
    }
  }
}

function getScale(name, ctx) {
  let s;
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(name) ? name : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? (s = ctx.scales[name]) && s.value : undefined;
}
function internalScaleFunctions(codegen, fnctx, visitors) {
  // add helper method to the 'this' expression function context
  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0; // register AST visitors for internal scale functions


  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor; // resolve scale reference directly to the signal hash argument

  const ref = arg => '_[' + (arg.type === vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ScalePrefix + arg.value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ScalePrefix) + '+' + codegen(arg)) + ']'; // define and return internal scale function code generators
  // these internal functions are called by mark encoders


  return {
    _bandwidth: args => `this.__bandwidth(${ref(args[0])})`,
    _range: args => `${ref(args[0])}.range()`,
    _scale: args => `${ref(args[0])}(${codegen(args[1])})`
  };
}

function geoMethod(methodName, globalMethod) {
  return function (projection, geojson, group) {
    if (projection) {
      // projection defined, use it
      const p = getScale(projection, (group || this).context);
      return p && p.path[methodName](geojson);
    } else {
      // projection undefined, use global method
      return globalMethod(geojson);
    }
  };
}

const geoArea = geoMethod('area', d3_geo__WEBPACK_IMPORTED_MODULE_8__.default);
const geoBounds = geoMethod('bounds', d3_geo__WEBPACK_IMPORTED_MODULE_9__.default);
const geoCentroid = geoMethod('centroid', d3_geo__WEBPACK_IMPORTED_MODULE_10__.default);

function inScope (item) {
  const group = this.context.group;
  let value = false;
  if (group) while (item) {
    if (item === group) {
      value = true;
      break;
    }

    item = item.mark.group;
  }
  return value;
}

function log(df, method, args) {
  try {
    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }

  return args[args.length - 1];
}

function warn() {
  return log(this.context.dataflow, 'warn', arguments);
}
function info() {
  return log(this.context.dataflow, 'info', arguments);
}
function debug() {
  return log(this.context.dataflow, 'debug', arguments);
}

function channel_luminance_value(channelValue) {
  const val = channelValue / 255;

  if (val <= 0.03928) {
    return val / 12.92;
  }

  return Math.pow((val + 0.055) / 1.055, 2.4);
}

function luminance(color) {
  const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_11__.rgb)(color),
        r = channel_luminance_value(c.r),
        g = channel_luminance_value(c.g),
        b = channel_luminance_value(c.b);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
} // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef

function contrast(color1, color2) {
  const lum1 = luminance(color1),
        lum2 = luminance(color2),
        lumL = Math.max(lum1, lum2),
        lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}

function merge () {
  const args = [].slice.call(arguments);
  args.unshift({});
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(...args);
}

function equal(a, b) {
  return a === b || a !== a && b !== b ? true : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(a) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(b) && a.length === b.length ? equalArray(a, b) : false : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(b) ? equalObject(a, b) : false;
}

function equalArray(a, b) {
  for (let i = 0, n = a.length; i < n; ++i) {
    if (!equal(a[i], b[i])) return false;
  }

  return true;
}

function equalObject(a, b) {
  for (const key in a) {
    if (!equal(a[key], b[key])) return false;
  }

  return true;
}

function removePredicate(props) {
  return _ => equalObject(props, _);
}

function modify (name, insert, remove, toggle, modify, values) {
  const df = this.context.dataflow,
        data = this.context.data[name],
        input = data.input,
        stamp = df.stamp();
  let changes = data.changes,
      predicate,
      key;

  if (df._trigger === false || !(input.value.length || insert || toggle)) {
    // nothing to do!
    return 0;
  }

  if (!changes || changes.stamp < stamp) {
    data.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }

  if (remove) {
    predicate = remove === true ? vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(remove) || (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_2__.isTuple)(remove) ? remove : removePredicate(remove);
    changes.remove(predicate);
  }

  if (insert) {
    changes.insert(insert);
  }

  if (toggle) {
    predicate = removePredicate(toggle);

    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle);
    }
  }

  if (modify) {
    for (key in values) {
      changes.modify(modify, key, values[key]);
    }
  }

  return 1;
}

function pinchDistance(event) {
  const t = event.touches,
        dx = t[0].clientX - t[1].clientX,
        dy = t[0].clientY - t[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function pinchAngle(event) {
  const t = event.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}

const accessors = {};
function pluck (data, name) {
  const accessor = accessors[name] || (accessors[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(name));
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data) ? data.map(accessor) : accessor(data);
}

function array(seq) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(seq) || ArrayBuffer.isView(seq) ? seq : null;
}

function sequence(seq) {
  return array(seq) || ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(seq) ? seq : null);
}

function join(seq, ...args) {
  return array(seq).join(...args);
}
function indexof(seq, ...args) {
  return sequence(seq).indexOf(...args);
}
function lastindexof(seq, ...args) {
  return sequence(seq).lastIndexOf(...args);
}
function slice(seq, ...args) {
  return sequence(seq).slice(...args);
}
function replace(str, pattern, repl) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(repl)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Function argument passed to replace.');
  return String(str).replace(pattern, repl);
}
function reverse(seq) {
  return array(seq).slice().reverse();
}

function bandspace(count, paddingInner, paddingOuter) {
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.bandSpace)(count || 0, paddingInner || 0, paddingOuter || 0);
}
function bandwidth(name, group) {
  const s = getScale(name, (group || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy(name, group) {
  const s = getScale(name, (group || this).context);
  return s ? s.copy() : undefined;
}
function domain(name, group) {
  const s = getScale(name, (group || this).context);
  return s ? s.domain() : [];
}
function invert(name, range, group) {
  const s = getScale(name, (group || this).context);
  return !s ? undefined : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);
}
function range(name, group) {
  const s = getScale(name, (group || this).context);
  return s && s.range ? s.range() : [];
}
function scale(name, value, group) {
  const s = getScale(name, (group || this).context);
  return s ? s(value) : undefined;
}

function scaleGradient (scale, p0, p1, count, group) {
  scale = getScale(scale, (group || this).context);
  const gradient = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.Gradient)(p0, p1);
  let stops = scale.domain(),
      min = stops[0],
      max = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(stops),
      fraction = vega_util__WEBPACK_IMPORTED_MODULE_0__.identity;

  if (!(max - min)) {
    // expand scale if domain has zero span, fix #1479
    scale = (scale.interpolator ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('sequential')().interpolator(scale.interpolator()) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);
  } else {
    fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scaleFraction)(scale, min, max);
  }

  if (scale.ticks) {
    stops = scale.ticks(+count || 15);
    if (min !== stops[0]) stops.unshift(min);
    if (max !== (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(stops)) stops.push(max);
  }

  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));
  return gradient;
}

function geoShape(projection, geojson, group) {
  const p = getScale(projection, (group || this).context);
  return function (context) {
    return p ? p.path.context(context)(geojson) : '';
  };
}
function pathShape(path) {
  let p = null;
  return function (context) {
    return context ? (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.pathRender)(context, p = p || (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.pathParse)(path)) : path;
  };
}

const datum = d => d.data;

function treeNodes(name, context) {
  const tree = data.call(context, name);
  return tree.root && tree.root.lookup || {};
}

function treePath(name, source, target) {
  const nodes = treeNodes(name, this),
        s = nodes[source],
        t = nodes[target];
  return s && t ? s.path(t).map(datum) : undefined;
}
function treeAncestors(name, node) {
  const n = treeNodes(name, this)[node];
  return n ? n.ancestors().map(datum) : undefined;
}

const _window = () => typeof window !== 'undefined' && window || null;

function screen() {
  const w = _window();

  return w ? w.screen : {};
}
function windowSize() {
  const w = _window();

  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];
}
function containerSize() {
  const view = this.context.dataflow,
        el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];
}

function intersect (b, opt, group) {
  if (!b) return [];
  const [u, v] = b,
        box = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.Bounds().set(u[0], u[1], v[0], v[1]),
        scene = group || this.context.dataflow.scenegraph().root;
  return (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.intersect)(scene, box, filter(opt));
}

function filter(opt) {
  let p = null;

  if (opt) {
    const types = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(opt.marktype),
          names = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(opt.markname);

    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));
  }

  return p;
}

const functionContext = {
  random() {
    return (0,vega_statistics__WEBPACK_IMPORTED_MODULE_6__.random)();
  },

  // override default
  cumulativeNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeNormal,
  cumulativeLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeLogNormal,
  cumulativeUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeUniform,
  densityNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityNormal,
  densityLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityLogNormal,
  densityUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityUniform,
  quantileNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileNormal,
  quantileLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileLogNormal,
  quantileUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileUniform,
  sampleNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleNormal,
  sampleLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleLogNormal,
  sampleUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleUniform,
  isArray: vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray,
  isBoolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.isBoolean,
  isDate: vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate,

  isDefined(_) {
    return _ !== undefined;
  },

  isNumber: vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber,
  isObject: vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject,
  isRegExp: vega_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp,
  isString: vega_util__WEBPACK_IMPORTED_MODULE_0__.isString,
  isTuple: vega_dataflow__WEBPACK_IMPORTED_MODULE_2__.isTuple,

  isValid(_) {
    return _ != null && _ === _;
  },

  toBoolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean,
  toDate: vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate,
  toNumber: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  toString: vega_util__WEBPACK_IMPORTED_MODULE_0__.toString,
  indexof,
  join,
  lastindexof,
  replace,
  reverse,
  slice,
  flush: vega_util__WEBPACK_IMPORTED_MODULE_0__.flush,
  lerp: vega_util__WEBPACK_IMPORTED_MODULE_0__.lerp,
  merge,
  pad: vega_util__WEBPACK_IMPORTED_MODULE_0__.pad,
  peek: vega_util__WEBPACK_IMPORTED_MODULE_0__.peek,
  pluck,
  span: vega_util__WEBPACK_IMPORTED_MODULE_0__.span,
  inrange: vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange,
  truncate: vega_util__WEBPACK_IMPORTED_MODULE_0__.truncate,
  rgb: d3_color__WEBPACK_IMPORTED_MODULE_11__.rgb,
  lab: d3_color__WEBPACK_IMPORTED_MODULE_12__.default,
  hcl: d3_color__WEBPACK_IMPORTED_MODULE_12__.hcl,
  hsl: d3_color__WEBPACK_IMPORTED_MODULE_11__.hsl,
  luminance,
  contrast,
  sequence: d3_array__WEBPACK_IMPORTED_MODULE_13__.default,
  format,
  utcFormat,
  utcParse,
  utcOffset: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcOffset,
  utcSequence: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcSequence,
  timeFormat,
  timeParse,
  timeOffset: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeOffset,
  timeSequence: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeSequence,
  timeUnitSpecifier: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeUnitSpecifier,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter: vega_util__WEBPACK_IMPORTED_MODULE_0__.quarter,
  utcquarter: vega_util__WEBPACK_IMPORTED_MODULE_0__.utcquarter,
  week: vega_time__WEBPACK_IMPORTED_MODULE_7__.week,
  utcweek: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcweek,
  dayofyear: vega_time__WEBPACK_IMPORTED_MODULE_7__.dayofyear,
  utcdayofyear: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcdayofyear,
  warn,
  info,
  debug,
  extent: vega_util__WEBPACK_IMPORTED_MODULE_0__.extent,
  inScope,
  intersect,
  clampRange: vega_util__WEBPACK_IMPORTED_MODULE_0__.clampRange,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear: vega_util__WEBPACK_IMPORTED_MODULE_0__.panLinear,
  panLog: vega_util__WEBPACK_IMPORTED_MODULE_0__.panLog,
  panPow: vega_util__WEBPACK_IMPORTED_MODULE_0__.panPow,
  panSymlog: vega_util__WEBPACK_IMPORTED_MODULE_0__.panSymlog,
  zoomLinear: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLinear,
  zoomLog: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLog,
  zoomPow: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomPow,
  zoomSymlog: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomSymlog,
  encode,
  modify
};
const eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],
      // event functions
eventPrefix = 'event.vega.',
      // event function prefix
thisPrefix = 'this.',
      // function context prefix
astVisitors = {}; // AST visitors for dependency analysis
// export code generator parameters

const codegenParams = {
  forbidden: ['_'],
  allowed: ['datum', 'event', 'item'],
  fieldvar: 'datum',
  globalvar: id => `_[${(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(SignalPrefix + id)}]`,
  functions: buildFunctions,
  constants: vega_expression__WEBPACK_IMPORTED_MODULE_1__.constants,
  visitors: astVisitors
}; // export code generator

const codeGenerator = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.codegenExpression)(codegenParams); // Build expression function registry

function buildFunctions(codegen) {
  const fn = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.functions)(codegen);
  eventFunctions.forEach(name => fn[name] = eventPrefix + name);

  for (const name in functionContext) {
    fn[name] = thisPrefix + name;
  }

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(fn, internalScaleFunctions(codegen, functionContext, astVisitors));
  return fn;
} // Register an expression function


function expressionFunction(name, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name];
  } // register with the functionContext


  functionContext[name] = fn; // if there is an astVisitor register that, too

  if (visitor) astVisitors[name] = visitor; // if the code generator has already been initialized,
  // we need to also register the function with it

  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;
  return this;
} // register expression functions with ast visitors

expressionFunction('bandwidth', bandwidth, scaleVisitor);
expressionFunction('copy', copy, scaleVisitor);
expressionFunction('domain', domain, scaleVisitor);
expressionFunction('range', range, scaleVisitor);
expressionFunction('invert', invert, scaleVisitor);
expressionFunction('scale', scale, scaleVisitor);
expressionFunction('gradient', scaleGradient, scaleVisitor);
expressionFunction('geoArea', geoArea, scaleVisitor);
expressionFunction('geoBounds', geoBounds, scaleVisitor);
expressionFunction('geoCentroid', geoCentroid, scaleVisitor);
expressionFunction('geoShape', geoShape, scaleVisitor);
expressionFunction('indata', indata, indataVisitor);
expressionFunction('data', data, dataVisitor);
expressionFunction('treePath', treePath, dataVisitor);
expressionFunction('treeAncestors', treeAncestors, dataVisitor); // register Vega-Lite selection functions

expressionFunction('vlSelectionTest', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionTest, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionIdTest', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionIdTest, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionResolve', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionResolve, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionTuples', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionTuples);

function parser (expr, scope) {
  const params = {}; // parse the expression to an abstract syntax tree (ast)

  let ast;

  try {
    expr = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(expr) ? expr : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(expr) + '';
    ast = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(expr);
  } catch (err) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expression parse error: ' + expr);
  } // analyze ast function calls for dependencies


  ast.visit(node => {
    if (node.type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.CallExpression) return;
    const name = node.callee.name,
          visit = codegenParams.visitors[name];
    if (visit) visit(name, node.arguments, scope, params);
  }); // perform code generation

  const gen = codeGenerator(ast); // collect signal dependencies

  gen.globals.forEach(name => {
    const signalName = SignalPrefix + name;

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, signalName) && scope.getSignal(name)) {
      params[signalName] = scope.signalRef(name);
    }
  }); // return generated expression code and dependencies

  return {
    $expr: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params
  };
}




/***/ }),

/***/ "../../node_modules/vega-geo/build/vega-geo.module.js":
/*!************************************************************!*\
  !*** ../../node_modules/vega-geo/build/vega-geo.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "contour": () => (/* binding */ Contour),
/* harmony export */   "geojson": () => (/* binding */ GeoJSON),
/* harmony export */   "geopath": () => (/* binding */ GeoPath),
/* harmony export */   "geopoint": () => (/* binding */ GeoPoint),
/* harmony export */   "geoshape": () => (/* binding */ GeoShape),
/* harmony export */   "graticule": () => (/* binding */ Graticule),
/* harmony export */   "heatmap": () => (/* binding */ Heatmap),
/* harmony export */   "isocontour": () => (/* binding */ Isocontour),
/* harmony export */   "kde2d": () => (/* binding */ KDE2D),
/* harmony export */   "projection": () => (/* binding */ Projection)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/sum.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_projection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-projection */ "../../node_modules/vega-projection/build/vega-projection.module.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/graticule.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-canvas */ "../../node_modules/vega-canvas/index.browser.js");









function noop() {}

const cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []]; // Implementation adapted from d3/d3-contour. Thanks!

function contours () {
  var dx = 1,
      dy = 1,
      smooth = smoothLinear;

  function contours(values, tz) {
    return tz.map(value => contour(values, value));
  } // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js


  function contour(values, value) {
    var polygons = [],
        holes = [];
    isorings(values, value, ring => {
      smooth(ring, values, value);
      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);
    });
    holes.forEach(hole => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: 'MultiPolygon',
      value: value,
      coordinates: polygons
    };
  } // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js


  function isorings(values, value, callback) {
    var fragmentByStart = new Array(),
        fragmentByEnd = new Array(),
        x,
        y,
        t0,
        t1,
        t2,
        t3; // Special case for the first row (y = -1, t2 = t3 = 0).

    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);

    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }

    cases[t1 << 0].forEach(stitch); // General case for the intermediate rows.

    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);

      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }

      cases[t1 | t2 << 3].forEach(stitch);
    } // Special case for the last row (y = dy - 1, t0 = t1 = 0).


    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);

    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }

    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f,
          g;

      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];

          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];

          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(point => {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];

      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }

      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function (_) {
    if (!arguments.length) return [dx, dy];

    var _0 = Math.floor(_[0]),
        _1 = Math.floor(_[1]);

    if (!(_0 >= 0 && _1 >= 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid size');
    return dx = _0, dy = _1, contours;
  };

  contours.smooth = function (_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
  };

  return contours;
}

function area(ring) {
  var i = 0,
      n = ring.length,
      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];

  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];

  return area;
}

function contains(ring, hole) {
  var i = -1,
      n = hole.length,
      c;

  while (++i < n) if (c = ringContains(ring, hole[i])) return c;

  return 0;
}

function ringContains(ring, point) {
  var x = point[0],
      y = point[1],
      contains = -1;

  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i],
        xi = pi[0],
        yi = pi[1],
        pj = ring[j],
        xj = pj[0],
        yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;
  }

  return contains;
}

function segmentContains(a, b, c) {
  var i;
  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

function quantize (k, nice, zero) {
  return function (values) {
    var ex = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extent)(values),
        start = zero ? Math.min(ex[0], 0) : ex[0],
        stop = ex[1],
        span = stop - start,
        step = nice ? (0,d3_array__WEBPACK_IMPORTED_MODULE_5__.tickStep)(start, stop, k) : span / (k + 1);
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_6__.default)(start + step, stop, step);
  };
}

/**
 * Generate isocontours (level sets) based on input raster grid data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} [params.field] - The field with raster grid
 *   data. If unspecified, the tuple itself is interpreted as a raster grid.
 * @param {Array<number>} [params.thresholds] - Contour threshold array. If
 *   specified, the levels, nice, resolve, and zero parameters are ignored.
 * @param {number} [params.levels] - The desired number of contour levels.
 * @param {boolean} [params.nice] - Boolean flag indicating if the contour
 *   threshold values should be automatically aligned to "nice"
 *   human-friendly values. Setting this flag may cause the number of
 *   thresholds to deviate from the specified levels.
 * @param {string} [params.resolve] - The method for resolving thresholds
 *   across multiple input grids. If 'independent' (the default), threshold
 *   calculation will be performed separately for each grid. If 'shared', a
 *   single set of threshold values will be used for all input grids.
 * @param {boolean} [params.zero] - Boolean flag indicating if the contour
 *   threshold values should include zero.
 * @param {boolean} [params.smooth] - Boolean flag indicating if the contour
 *   polygons should be smoothed using linear interpolation. The default is
 *   true. The parameter is ignored when using density estimation.
 * @param {boolean} [params.scale] - Optional numerical value by which to
 *   scale the output isocontour coordinates. This parameter can be useful
 *   to scale the contours to match a desired output resolution.
 * @param {string} [params.as='contour'] - The output field in which to store
 *   the generated isocontour data (default 'contour').
 */

function Isocontour(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Isocontour.Definition = {
  'type': 'Isocontour',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'thresholds',
    'type': 'number',
    'array': true
  }, {
    'name': 'levels',
    'type': 'number'
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'zero',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'scale',
    'type': 'number',
    'expr': true
  }, {
    'name': 'translate',
    'type': 'number',
    'array': true,
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'default': 'contour'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Isocontour, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }

    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        source = pulse.materialize(pulse.SOURCE).source,
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        contour = contours().smooth(_.smooth !== false),
        tz = _.thresholds || levels(source, field, _),
        as = _.as === null ? null : _.as || 'contour',
        values = [];
    source.forEach(t => {
      const grid = field(t); // generate contour paths in GeoJSON format

      const paths = contour.size([grid.width, grid.height])(grid.values, (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(tz) ? tz : tz(grid.values)); // adjust contour path coordinates as needed

      transformPaths(paths, grid, t, _); // ingest; copy source data properties to output

      paths.forEach(p => {
        values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.rederive)(t, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values;
    return out;
  }

});

function levels(values, f, _) {
  const q = quantize(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== 'shared' ? q : q(values.map(t => (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(f(t).values)));
}

function transformPaths(paths, grid, datum, _) {
  let s = _.scale || grid.scale,
      t = _.translate || grid.translate;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) s = s(datum, _);
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(t)) t = t(datum, _);
  if ((s === 1 || s == null) && !t) return;
  const sx = ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(s) ? s : s[0]) || 1,
        sy = ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(s) ? s : s[1]) || 1,
        tx = t && t[0] || 0,
        ty = t && t[1] || 0;
  paths.forEach(transform(grid, sx, sy, tx, ty));
}

function transform(grid, sx, sy, tx, ty) {
  const x1 = grid.x1 || 0,
        y1 = grid.y1 || 0,
        flip = sx * sy < 0;

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    if (flip) coordinates.reverse(); // maintain winding order

    coordinates.forEach(transformPoint);
  }

  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x1) * sx + tx;
    coordinates[1] = (coordinates[1] - y1) * sy + ty;
  }

  return function (geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}

function radius(bw, data, f) {
  const v = bw >= 0 ? bw : (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bandwidthNRD)(data, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}

function number(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(_) ? _ : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(+_);
} // Implementation adapted from d3/d3-contour. Thanks!


function density2D () {
  var x = d => d[0],
      y = d => d[1],
      weight = vega_util__WEBPACK_IMPORTED_MODULE_1__.one,
      bandwidth = [-1, -1],
      dx = 960,
      dy = 500,
      k = 2; // log2(cellSize)


  function density(data, counts) {
    const rx = radius(bandwidth[0], data, x) >> k,
          // blur x-radius
    ry = radius(bandwidth[1], data, y) >> k,
          // blur y-radius
    ox = rx ? rx + 2 : 0,
          // x-offset padding for blur
    oy = ry ? ry + 2 : 0,
          // y-offset padding for blur
    n = 2 * ox + (dx >> k),
          // grid width
    m = 2 * oy + (dy >> k),
          // grid height
    values0 = new Float32Array(n * m),
          values1 = new Float32Array(n * m);
    let values = values0;
    data.forEach(d => {
      const xi = ox + (+x(d) >> k),
            yi = oy + (+y(d) >> k);

      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += +weight(d);
      }
    });

    if (rx > 0 && ry > 0) {
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m, values0, values1, rx);
      blurX(n, m, values1, values0, rx);
      blurX(n, m, values0, values1, rx);
      values = values1;
    } else if (ry > 0) {
      blurY(n, m, values0, values1, ry);
      blurY(n, m, values1, values0, ry);
      blurY(n, m, values0, values1, ry);
      values = values1;
    } // scale density estimates
    // density in points per square pixel or probability density


    const s = counts ? Math.pow(2, -2 * k) : 1 / (0,d3_array__WEBPACK_IMPORTED_MODULE_8__.default)(values);

    for (let i = 0, sz = n * m; i < sz; ++i) values[i] *= s;

    return {
      values: values,
      scale: 1 << k,
      width: n,
      height: m,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k),
      y2: oy + (dy >> k)
    };
  }

  density.x = function (_) {
    return arguments.length ? (x = number(_), density) : x;
  };

  density.y = function (_) {
    return arguments.length ? (y = number(_), density) : y;
  };

  density.weight = function (_) {
    return arguments.length ? (weight = number(_), density) : weight;
  };

  density.size = function (_) {
    if (!arguments.length) return [dx, dy];

    var _0 = +_[0],
        _1 = +_[1];

    if (!(_0 >= 0 && _1 >= 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid size');
    return dx = _0, dy = _1, density;
  };

  density.cellSize = function (_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid cell size');
    k = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };

  density.bandwidth = function (_) {
    if (!arguments.length) return bandwidth;
    _ = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_);
    if (_.length === 1) _ = [+_[0], +_[0]];
    if (_.length !== 2) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid bandwidth');
    return bandwidth = _, density;
  };

  return density;
}

function blurX(n, m, source, target, r) {
  const w = (r << 1) + 1;

  for (let j = 0; j < m; ++j) {
    for (let i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source[i + j * n];
      }

      if (i >= r) {
        if (i >= w) {
          sr -= source[i - w + j * n];
        }

        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

function blurY(n, m, source, target, r) {
  const w = (r << 1) + 1;

  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source[i + j * n];
      }

      if (j >= r) {
        if (j >= w) {
          sr -= source[i + (j - w) * n];
        }

        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

/**
 * Perform 2D kernel-density estimation of point data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The [width, height] extent (in
 *   units of input pixels) over which to perform density estimation.
 * @param {function(object): number} params.x - The x-coordinate accessor.
 * @param {function(object): number} params.y - The y-coordinate accessor.
 * @param {function(object): number} [params.weight] - The weight accessor.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {number} [params.cellSize] - Contour density calculation cell size.
 *   This parameter determines the level of spatial approximation. For example,
 *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.
 *   A value of 1 will result in an output raster grid whose dimensions exactly
 *   matches the size parameter.
 * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,
 *   in pixels. The input can be a two-element array specifying separate
 *   x and y bandwidths, or a single-element array specifying both. If the
 *   bandwidth is unspecified or less than zero, the bandwidth will be
 *   automatically determined.
 * @param {boolean} [params.counts=false] - A boolean flag indicating if the
 *   output values should be probability estimates (false, default) or
 *   smoothed counts (true).
 * @param {string} [params.as='grid'] - The output field in which to store
 *   the generated raster grid (default 'grid').
 */

function KDE2D(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
KDE2D.Definition = {
  'type': 'KDE2D',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'weight',
    'type': 'field'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'cellSize',
    'type': 'number'
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'counts',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'grid'
  }]
};
const PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];
function params(obj, _) {
  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);
  return obj;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(KDE2D, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;
    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        source = pulse.materialize(pulse.SOURCE).source,
        groups = partition(source, _.groupby),
        names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorName),
        kde = params(density2D(), _),
        as = _.as || 'grid',
        values = [];

    function set(t, vals) {
      for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];

      return t;
    } // generate density raster grids


    values = groups.map(g => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(set({
      [as]: kde(g, _.counts)
    }, g.dims)));
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values;
    return out;
  }

});
function partition(data, groupby) {
  var groups = [],
      get = f => f(t),
      map,
      i,
      n,
      t,
      k,
      g; // partition data points into groups


  if (groupby == null) {
    groups.push(data);
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }

      g.push(t);
    }
  }

  return groups;
}

/**
 * Generate contours based on kernel-density estimation of point data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.
 *  If the values parameter is provided, this must be the dimensions of the input data.
 *  If density estimation is performed, this is the output view dimensions in pixels.
 * @param {Array<number>} [params.values] - An array of numeric values representing an
 *  width x height grid of values over which to compute contours. If unspecified, this
 *  transform will instead attempt to compute contours for the kernel density estimate
 *  using values drawn from data tuples in the input pulse.
 * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.
 * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.
 * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.
 * @param {number} [params.cellSize] - Contour density calculation cell size.
 * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.
 * @param {Array<number>} [params.thresholds] - Contour threshold array. If
 *   this parameter is set, the count and nice parameters will be ignored.
 * @param {number} [params.count] - The desired number of contours.
 * @param {boolean} [params.nice] - Boolean flag indicating if the contour
 *   threshold values should be automatically aligned to "nice"
 *   human-friendly values. Setting this flag may cause the number of
 *   thresholds to deviate from the specified count.
 * @param {boolean} [params.smooth] - Boolean flag indicating if the contour
 *   polygons should be smoothed using linear interpolation. The default is
 *   true. The parameter is ignored when using density estimation.
 */

function Contour(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Contour.Definition = {
  'type': 'Contour',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'values',
    'type': 'number',
    'array': true
  }, {
    'name': 'x',
    'type': 'field'
  }, {
    'name': 'y',
    'type': 'field'
  }, {
    'name': 'weight',
    'type': 'field'
  }, {
    'name': 'cellSize',
    'type': 'number'
  }, {
    'name': 'bandwidth',
    'type': 'number'
  }, {
    'name': 'count',
    'type': 'number'
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'thresholds',
    'type': 'number',
    'array': true
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Contour, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }

    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        contour = contours().smooth(_.smooth !== false),
        values = _.values,
        thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),
        size = _.size,
        grid,
        post;

    if (!values) {
      values = pulse.materialize(pulse.SOURCE).source;
      grid = params(density2D(), _)(values, true);
      post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values = grid.values;
    }

    thresh = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(thresh) ? thresh : thresh(values);
    values = contour.size(size)(values, thresh);
    if (post) values.forEach(post);
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = (values || []).map(vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest);
    return out;
  }

});

const Feature = 'Feature';
const FeatureCollection = 'FeatureCollection';
const MultiPoint = 'MultiPoint';

/**
 * Consolidate an array of [longitude, latitude] points or GeoJSON features
 * into a combined GeoJSON object. This transform is particularly useful for
 * combining geo data for a Projection's fit argument. The resulting GeoJSON
 * data is available as this transform's value. Input pulses are unchanged.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.fields] - A two-element array
 *   of field accessors for the longitude and latitude values.
 * @param {function(object): *} params.geojson - A field accessor for
 *   retrieving GeoJSON feature data.
 */

function GeoJSON(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoJSON.Definition = {
  'type': 'GeoJSON',
  'metadata': {},
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'length': 2
  }, {
    'name': 'geojson',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoJSON, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var features = this._features,
        points = this._points,
        fields = _.fields,
        lon = fields && fields[0],
        lat = fields && fields[1],
        geojson = _.geojson || !fields && vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        flag = pulse.ADD,
        mod;
    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(geojson)) || lon && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(lon)) || lat && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(lat));

    if (!this.value || mod) {
      flag = pulse.SOURCE;
      this._features = features = [];
      this._points = points = [];
    }

    if (geojson) {
      pulse.visit(flag, t => features.push(geojson(t)));
    }

    if (lon && lat) {
      pulse.visit(flag, t => {
        var x = lon(t),
            y = lat(t);

        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {
          points.push([x, y]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points
        }
      });
    }

    this.value = {
      type: FeatureCollection,
      features: features
    };
  }

});

/**
 * Map GeoJSON data to an SVG path string.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {function(object): *} [params.field] - The field with GeoJSON data,
 *   or null if the tuple itself is a GeoJSON feature.
 * @param {string} [params.as='path'] - The output field in which to store
 *   the generated path data (default 'path').
 */

function GeoPath(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoPath.Definition = {
  'type': 'GeoPath',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection'
  }, {
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'pointRadius',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoPath, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
        path = this.value,
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        as = _.as || 'path',
        flag = out.SOURCE;

    if (!path || _.modified()) {
      // parameters updated, reset and reflow
      this.value = path = (0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.getProjectionPath)(_.projection);
      out.materialize().reflow();
    } else {
      flag = field === vega_util__WEBPACK_IMPORTED_MODULE_1__.identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;
    }

    const prev = initPath(path, _.pointRadius);
    out.visit(flag, t => t[as] = path(field(t)));
    path.pointRadius(prev);
    return out.modifies(as);
  }

});

function initPath(path, pointRadius) {
  const prev = path.pointRadius();
  path.context(null);

  if (pointRadius != null) {
    path.pointRadius(pointRadius);
  }

  return prev;
}

/**
 * Geo-code a longitude/latitude point to an x/y coordinate.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {Array<function(object): *>} params.fields - A two-element array of
 *   field accessors for the longitude and latitude values.
 * @param {Array<string>} [params.as] - A two-element array of field names
 *   under which to store the result. Defaults to ['x','y'].
 */

function GeoPoint(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoPoint.Definition = {
  'type': 'GeoPoint',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection',
    'required': true
  }, {
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['x', 'y']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoPoint, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var proj = _.projection,
        lon = _.fields[0],
        lat = _.fields[1],
        as = _.as || ['x', 'y'],
        x = as[0],
        y = as[1],
        mod;

    function set(t) {
      const xy = proj([lon(t), lat(t)]);

      if (xy) {
        t[x] = xy[0];
        t[y] = xy[1];
      } else {
        t[x] = undefined;
        t[y] = undefined;
      }
    }

    if (_.modified()) {
      // parameters updated, reflow
      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);
    } else {
      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);
      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);
    }

    return pulse.modifies(as);
  }

});

/**
 * Annotate items with a geopath shape generator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {function(object): *} [params.field] - The field with GeoJSON data,
 *   or null if the tuple itself is a GeoJSON feature.
 * @param {string} [params.as='shape'] - The output field in which to store
 *   the generated path data (default 'shape').
 */

function GeoShape(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoShape.Definition = {
  'type': 'GeoShape',
  'metadata': {
    'modifies': true,
    'nomod': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection'
  }, {
    'name': 'field',
    'type': 'field',
    'default': 'datum'
  }, {
    'name': 'pointRadius',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'shape'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoShape, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
        shape = this.value,
        as = _.as || 'shape',
        flag = out.ADD;

    if (!shape || _.modified()) {
      // parameters updated, reset and reflow
      this.value = shape = shapeGenerator((0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.getProjectionPath)(_.projection), _.field || (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.field)('datum'), _.pointRadius);
      out.materialize().reflow();
      flag = out.SOURCE;
    }

    out.visit(flag, t => t[as] = shape);
    return out.modifies(as);
  }

});

function shapeGenerator(path, field, pointRadius) {
  const shape = pointRadius == null ? _ => path(field(_)) : _ => {
    var prev = path.pointRadius(),
        value = path.pointRadius(pointRadius)(field(_));
    path.pointRadius(prev);
    return value;
  };

  shape.context = _ => {
    path.context(_);
    return shape;
  };

  return shape;
}

/**
 * GeoJSON feature generator for creating graticules.
 * @constructor
 */

function Graticule(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
  this.generator = (0,d3_geo__WEBPACK_IMPORTED_MODULE_9__.default)();
}
Graticule.Definition = {
  'type': 'Graticule',
  'metadata': {
    'changes': true,
    'generates': true
  },
  'params': [{
    'name': 'extent',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'extentMajor',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'extentMinor',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'step',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'stepMajor',
    'type': 'number',
    'array': true,
    'length': 2,
    'default': [90, 360]
  }, {
    'name': 'stepMinor',
    'type': 'number',
    'array': true,
    'length': 2,
    'default': [10, 10]
  }, {
    'name': 'precision',
    'type': 'number',
    'default': 2.5
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Graticule, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var src = this.value,
        gen = this.generator,
        t;

    if (!src.length || _.modified()) {
      for (const prop in _) {
        if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }

    t = gen();

    if (src.length) {
      pulse.mod.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.replace)(src[0], t));
    } else {
      pulse.add.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(t));
    }

    src[0] = t;
    return pulse;
  }

});

/**
 * Render a heatmap image for input raster grid data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} [params.field] - The field with raster grid
 *   data. If unspecified, the tuple itself is interpreted as a raster grid.
 * @param {string} [params.color] - A constant color value or function for
 *   individual pixel color. If a function, it will be invoked with an input
 *   object that includes $x, $y, $value, and $max fields for the grid.
 * @param {number} [params.opacity] - A constant opacity value or function for
 *   individual pixel opacity. If a function, it will be invoked with an input
 *   object that includes $x, $y, $value, and $max fields for the grid.
 * @param {string} [params.resolve] - The method for resolving maximum values
 *   across multiple input grids. If 'independent' (the default), maximum
 *   calculation will be performed separately for each grid. If 'shared',
 *   a single global maximum will be used for all input grids.
 * @param {string} [params.as='image'] - The output field in which to store
 *   the generated bitmap canvas images (default 'image').
 */

function Heatmap(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Heatmap.Definition = {
  'type': 'heatmap',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'color',
    'type': 'string',
    'expr': true
  }, {
    'name': 'opacity',
    'type': 'number',
    'expr': true
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'image'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Heatmap, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }

    var source = pulse.materialize(pulse.SOURCE).source,
        shared = _.resolve === 'shared',
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        opacity = opacity_(_.opacity, _),
        color = color_(_.color, _),
        as = _.as || 'image',
        obj = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: shared ? (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(source.map(t => (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(field(t).values))) : 0
    };
    source.forEach(t => {
      const v = field(t); // build proxy data object

      const o = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, t, obj); // set maximum value if not globally shared

      if (!shared) o.$max = (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(v.values || []); // generate canvas image
      // optimize color/opacity if not pixel-dependent

      t[as] = toCanvas(v, o, color.dep ? color : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(color(o)), opacity.dep ? opacity : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(opacity(o)));
    });
    return pulse.reflow(true).modifies(as);
  }

}); // get image color function

function color_(color, _) {
  let f;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(color)) {
    f = obj => (0,d3_color__WEBPACK_IMPORTED_MODULE_10__.rgb)(color(obj, _));

    f.dep = dependency(color);
  } else {
    // default to mid-grey
    f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)((0,d3_color__WEBPACK_IMPORTED_MODULE_10__.rgb)(color || '#888'));
  }

  return f;
} // get image opacity function


function opacity_(opacity, _) {
  let f;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opacity)) {
    f = obj => opacity(obj, _);

    f.dep = dependency(opacity);
  } else if (opacity) {
    f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(opacity);
  } else {
    // default to [0, max] opacity gradient
    f = obj => obj.$value / obj.$max || 0;

    f.dep = true;
  }

  return f;
} // check if function depends on individual pixel data


function dependency(f) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f)) return false;
  const set = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.toSet)((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(f));
  return set.$x || set.$y || set.$value || set.$max;
} // render raster grid to canvas


function toCanvas(grid, obj, color, opacity) {
  const n = grid.width,
        m = grid.height,
        x1 = grid.x1 || 0,
        y1 = grid.y1 || 0,
        x2 = grid.x2 || n,
        y2 = grid.y2 || m,
        val = grid.values,
        value = val ? i => val[i] : vega_util__WEBPACK_IMPORTED_MODULE_1__.zero,
        can = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_4__.canvas)(x2 - x1, y2 - y1),
        ctx = can.getContext('2d'),
        img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),
        pix = img.data;

  for (let j = y1, k = 0; j < y2; ++j) {
    obj.$y = j - y1;

    for (let i = x1, r = j * n; i < x2; ++i, k += 4) {
      obj.$x = i - x1;
      obj.$value = value(i + r);
      const v = color(obj);
      pix[k + 0] = v.r;
      pix[k + 1] = v.g;
      pix[k + 2] = v.b;
      pix[k + 3] = ~~(255 * opacity(obj));
    }
  }

  ctx.putImageData(img, 0, 0);
  return can;
}

/**
 * Maintains a cartographic projection.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Projection(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Projection, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    let proj = this.value;

    if (!proj || _.modified('type')) {
      this.value = proj = create(_.type);
      vega_projection__WEBPACK_IMPORTED_MODULE_3__.projectionProperties.forEach(prop => {
        if (_[prop] != null) set(proj, prop, _[prop]);
      });
    } else {
      vega_projection__WEBPACK_IMPORTED_MODULE_3__.projectionProperties.forEach(prop => {
        if (_.modified(prop)) set(proj, prop, _[prop]);
      });
    }

    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);
    if (_.fit) fit(proj, _);
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
  }

});

function fit(proj, _) {
  const data = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;
}

function create(type) {
  const constructor = (0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.projection)((type || 'mercator').toLowerCase());
  if (!constructor) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized projection type: ' + type);
  return constructor();
}

function set(proj, key, value) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(proj[key])) proj[key](value);
}

function collectGeoJSON(data) {
  data = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(data);
  return data.length === 1 ? data[0] : {
    type: FeatureCollection,
    features: data.reduce((a, f) => a.concat(featurize(f)), [])
  };
}

function featurize(f) {
  return f.type === FeatureCollection ? f.features : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(f).filter(d => d != null).map(d => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}




/***/ }),

/***/ "../../node_modules/vega-hierarchy/build/vega-hierarchy.module.js":
/*!************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/build/vega-hierarchy.module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nest": () => (/* binding */ Nest),
/* harmony export */   "pack": () => (/* binding */ Pack),
/* harmony export */   "partition": () => (/* binding */ Partition),
/* harmony export */   "stratify": () => (/* binding */ Stratify),
/* harmony export */   "tree": () => (/* binding */ Tree),
/* harmony export */   "treelinks": () => (/* binding */ TreeLinks),
/* harmony export */   "treemap": () => (/* binding */ Treemap)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/index.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/index.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/partition.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/stratify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/tree.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/cluster.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/binary.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/slice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/sliceDice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/squarify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/resquarify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/index.js");




// Build lookup table mapping tuple keys to tree node instances
function lookup (tree, key, filter) {
  const map = {};
  tree.each(node => {
    const t = node.data;
    if (filter(t)) map[key(t)] = node;
  });
  tree.lookup = map;
  return tree;
}

/**
 * Nest tuples into a tree structure, grouped by key values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.
 * @param {boolean} [params.generate=false] - A boolean flag indicating if
 *   non-leaf nodes generated by this transform should be included in the
 *   output. The default (false) includes only the input data (leaf nodes)
 *   in the data stream.
 */

function Nest(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Nest.Definition = {
  'type': 'Nest',
  'metadata': {
    'treesource': true,
    'changes': true
  },
  'params': [{
    'name': 'keys',
    'type': 'field',
    'array': true
  }, {
    'name': 'generate',
    'type': 'boolean'
  }]
};

const children = n => n.values;

(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Nest, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Nest transform requires an upstream data source.');
    }

    var gen = _.generate,
        mod = _.modified(),
        out = pulse.clone(),
        tree = this.value;

    if (!tree || mod || pulse.changed()) {
      // collect nodes to remove
      if (tree) {
        tree.each(node => {
          if (node.children && (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.isTuple)(node.data)) {
            out.rem.push(node.data);
          }
        });
      } // generate new tree structure


      this.value = tree = (0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_2__.default)({
        values: (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_.keys).reduce((n, k) => {
          n.key(k);
          return n;
        }, nest()).entries(out.source)
      }, children); // collect nodes to add

      if (gen) {
        tree.each(node => {
          if (node.children) {
            node = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(node.data);
            out.add.push(node);
            out.source.push(node);
          }
        });
      } // build lookup table


      lookup(tree, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid);
    }

    out.source.root = tree;
    return out;
  }

});

function nest() {
  const keys = [],
        nest = {
    entries: array => entries(apply(array, 0), 0),
    key: d => (keys.push(d), nest)
  };

  function apply(array, depth) {
    if (depth >= keys.length) {
      return array;
    }

    const n = array.length,
          key = keys[depth++],
          valuesByKey = {},
          result = {};
    let i = -1,
        keyValue,
        value,
        values;

    while (++i < n) {
      keyValue = key(value = array[i]) + '';

      if (values = valuesByKey[keyValue]) {
        values.push(value);
      } else {
        valuesByKey[keyValue] = [value];
      }
    }

    for (keyValue in valuesByKey) {
      result[keyValue] = apply(valuesByKey[keyValue], depth);
    }

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    const array = [];

    for (const key in map) {
      array.push({
        key,
        values: entries(map[key], depth)
      });
    }

    return array;
  }

  return nest;
}

/**
 * Abstract class for tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function HierarchyLayout(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}

const defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;

(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(HierarchyLayout, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source || !pulse.source.root) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)(this.constructor.name + ' transform requires a backing tree data source.');
    }

    const layout = this.layout(_.method),
          fields = this.fields,
          root = pulse.source.root,
          as = _.as || fields;
    if (_.field) root.sum(_.field);else root.count();
    if (_.sort) root.sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort, d => d.data));
    setParams(layout, this.params, _);

    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation : vega_util__WEBPACK_IMPORTED_MODULE_1__.one);
    }

    try {
      this.value = layout(root);
    } catch (err) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)(err);
    }

    root.each(node => setFields(node, fields, as));
    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');
  }

});

function setParams(layout, params, _) {
  for (let p, i = 0, n = params.length; i < n; ++i) {
    p = params[i];
    if (p in _) layout[p](_[p]);
  }
}

function setFields(node, fields, as) {
  const t = node.data,
        n = fields.length - 1;

  for (let i = 0; i < n; ++i) {
    t[as[i]] = node[fields[i]];
  }

  t[as[n]] = node.children ? node.children.length : 0;
}

const Output = ['x', 'y', 'r', 'depth', 'children'];
/**
 * Packed circle tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */

function Pack(params) {
  HierarchyLayout.call(this, params);
}
Pack.Definition = {
  'type': 'Pack',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'radius',
    'type': 'field',
    'default': null
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output.length,
    'default': Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Pack, HierarchyLayout, {
  layout: d3_hierarchy__WEBPACK_IMPORTED_MODULE_3__.default,
  params: ['radius', 'size', 'padding'],
  fields: Output
});

const Output$1 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];
/**
 * Partition tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */

function Partition(params) {
  HierarchyLayout.call(this, params);
}
Partition.Definition = {
  'type': 'Partition',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'round',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$1.length,
    'default': Output$1
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Partition, HierarchyLayout, {
  layout: d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__.default,
  params: ['size', 'round', 'padding'],
  fields: Output$1
});

/**
 * Stratify a collection of tuples into a tree structure based on
 * id and parent id fields.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.key - Unique key field for each tuple.
 * @param {function(object): *} params.parentKey - Field with key for parent tuple.
 */

function Stratify(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Stratify.Definition = {
  'type': 'Stratify',
  'metadata': {
    'treesource': true
  },
  'params': [{
    'name': 'key',
    'type': 'field',
    'required': true
  }, {
    'name': 'parentKey',
    'type': 'field',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Stratify, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Stratify transform requires an upstream data source.');
    }

    let tree = this.value;

    const mod = _.modified(),
          out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),
          run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution


    out.source = out.source.slice();

    if (run) {
      tree = out.source.length ? lookup((0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__.default)().id(_.key).parentId(_.parentKey)(out.source), _.key, vega_util__WEBPACK_IMPORTED_MODULE_1__.truthy) : lookup((0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__.default)()([{}]), _.key, _.key);
    }

    out.source.root = this.value = tree;
    return out;
  }

});

const Layouts = {
  tidy: d3_hierarchy__WEBPACK_IMPORTED_MODULE_6__.default,
  cluster: d3_hierarchy__WEBPACK_IMPORTED_MODULE_7__.default
};
const Output$2 = ['x', 'y', 'depth', 'children'];
/**
 * Tree layout. Depending on the method parameter, performs either
 * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Tree(params) {
  HierarchyLayout.call(this, params);
}
Tree.Definition = {
  'type': 'Tree',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'tidy',
    'values': ['tidy', 'cluster']
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'nodeSize',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'separation',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$2.length,
    'default': Output$2
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Tree, HierarchyLayout, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(method) {
    const m = method || 'tidy';
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(Layouts, m)) return Layouts[m]();else (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized Tree layout method: ' + m);
  },

  params: ['size', 'nodeSize'],
  fields: Output$2
});

/**
 * Generate tuples representing links between tree nodes.
 * The resulting tuples will contain 'source' and 'target' fields,
 * which point to parent and child node tuples, respectively.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function TreeLinks(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
}
TreeLinks.Definition = {
  'type': 'TreeLinks',
  'metadata': {
    'tree': true,
    'generates': true,
    'changes': true
  },
  'params': []
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(TreeLinks, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const links = this.value,
          tree = pulse.source && pulse.source.root,
          out = pulse.fork(pulse.NO_SOURCE),
          lut = {};
    if (!tree) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('TreeLinks transform requires a tree data source.');

    if (pulse.changed(pulse.ADD_REM)) {
      // remove previous links
      out.rem = links; // build lookup table of valid tuples

      pulse.visit(pulse.SOURCE, t => lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] = 1); // generate links for all edges incident on valid tuples

      tree.each(node => {
        const t = node.data,
              p = node.parent && node.parent.data;

        if (p && lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] && lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(p)]) {
          out.add.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
            source: p,
            target: t
          }));
        }
      });
      this.value = out.add;
    } else if (pulse.changed(pulse.MOD)) {
      // build lookup table of modified tuples
      pulse.visit(pulse.MOD, t => lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] = 1); // gather links incident on modified tuples

      links.forEach(link => {
        if (lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(link.source)] || lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(link.target)]) {
          out.mod.push(link);
        }
      });
    }

    return out;
  }

});

const Tiles = {
  binary: d3_hierarchy__WEBPACK_IMPORTED_MODULE_8__.default,
  dice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_9__.default,
  slice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_10__.default,
  slicedice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_11__.default,
  squarify: d3_hierarchy__WEBPACK_IMPORTED_MODULE_12__.default,
  resquarify: d3_hierarchy__WEBPACK_IMPORTED_MODULE_13__.default
};
const Output$3 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];
/**
 * Treemap layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */

function Treemap(params) {
  HierarchyLayout.call(this, params);
}
Treemap.Definition = {
  'type': 'Treemap',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'squarify',
    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingInner',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingOuter',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingTop',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingRight',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingBottom',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingLeft',
    'type': 'number',
    'default': 0
  }, {
    'name': 'ratio',
    'type': 'number',
    'default': 1.618033988749895
  }, {
    'name': 'round',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$3.length,
    'default': Output$3
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Treemap, HierarchyLayout, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const x = (0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_14__.default)();

    x.ratio = _ => {
      const t = x.tile();
      if (t.ratio) x.tile(t.ratio(_));
    };

    x.method = _ => {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(Tiles, _)) x.tile(Tiles[_]);else (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized Treemap layout method: ' + _);
    };

    return x;
  },

  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
  fields: Output$3
});




/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/accessors.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/accessors.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "optional": () => (/* binding */ optional),
/* harmony export */   "required": () => (/* binding */ required)
/* harmony export */ });
function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/array.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/array.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "shuffle": () => (/* binding */ shuffle)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/cluster.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/cluster.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/constant.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/constant.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "constantZero": () => (/* binding */ constantZero),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function constantZero() {
  return 0;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/ancestors.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/ancestors.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/count.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/count.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.eachAfter(count);
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/descendants.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/descendants.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/each.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/each.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  let index = -1;
  for (const node of this) {
    callback.call(that, node, ++index, this);
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  var node = this, nodes = [node], children, i, index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/find.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/find.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  let index = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index, this)) {
      return node;
    }
  }
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/index.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hierarchy),
/* harmony export */   "computeHeight": () => (/* binding */ computeHeight),
/* harmony export */   "Node": () => (/* binding */ Node)
/* harmony export */ });
/* harmony import */ var _count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./count.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/count.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/each.js");
/* harmony import */ var _eachBefore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eachBefore.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js");
/* harmony import */ var _eachAfter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./eachAfter.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./find.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/find.js");
/* harmony import */ var _sum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sum.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/sum.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/sort.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./path.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/path.js");
/* harmony import */ var _ancestors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ancestors.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/ancestors.js");
/* harmony import */ var _descendants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./descendants.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/descendants.js");
/* harmony import */ var _leaves_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./leaves.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/leaves.js");
/* harmony import */ var _links_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./links.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/links.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./iterator.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/iterator.js");














function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [undefined, data];
    if (children === undefined) children = mapChildren;
  } else if (children === undefined) {
    children = objectChildren;
  }

  var root = new Node(data),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function objectChildren(d) {
  return d.children;
}

function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}

function copyData(node) {
  if (node.data.value !== undefined) node.value = node.data.value;
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: _count_js__WEBPACK_IMPORTED_MODULE_0__.default,
  each: _each_js__WEBPACK_IMPORTED_MODULE_1__.default,
  eachAfter: _eachAfter_js__WEBPACK_IMPORTED_MODULE_2__.default,
  eachBefore: _eachBefore_js__WEBPACK_IMPORTED_MODULE_3__.default,
  find: _find_js__WEBPACK_IMPORTED_MODULE_4__.default,
  sum: _sum_js__WEBPACK_IMPORTED_MODULE_5__.default,
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_6__.default,
  path: _path_js__WEBPACK_IMPORTED_MODULE_7__.default,
  ancestors: _ancestors_js__WEBPACK_IMPORTED_MODULE_8__.default,
  descendants: _descendants_js__WEBPACK_IMPORTED_MODULE_9__.default,
  leaves: _leaves_js__WEBPACK_IMPORTED_MODULE_10__.default,
  links: _links_js__WEBPACK_IMPORTED_MODULE_11__.default,
  copy: node_copy,
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_12__.default
};


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/iterator.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/iterator.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/leaves.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/leaves.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/links.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/links.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/path.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/path.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/sort.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/sort.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/sum.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/sum.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/enclose.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/enclose.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/array.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(circles) {
  var i = 0, n = (circles = (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.shuffle)(Array.from(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/index.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _siblings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./siblings.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/siblings.js");
/* harmony import */ var _accessors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../accessors.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/accessors.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constant.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/constant.js");




function defaultRadius(d) {
  return Math.sqrt(d.value);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = _constant_js__WEBPACK_IMPORTED_MODULE_0__.constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(_constant_js__WEBPACK_IMPORTED_MODULE_0__.constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_1__.optional)(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = (0,_siblings_js__WEBPACK_IMPORTED_MODULE_2__.packEnclose)(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/siblings.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/siblings.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "packEnclose": () => (/* binding */ packEnclose),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/array.js");
/* harmony import */ var _enclose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enclose.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/pack/enclose.js");



function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = (circles = (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.default)(circles)).length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = (0,_enclose_js__WEBPACK_IMPORTED_MODULE_1__.default)(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(circles) {
  packEnclose(circles);
  return circles;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/partition.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/partition.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _treemap_round_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./treemap/round.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/round.js");
/* harmony import */ var _treemap_dice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./treemap/dice.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/dice.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(_treemap_round_js__WEBPACK_IMPORTED_MODULE_0__.default);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        (0,_treemap_dice_js__WEBPACK_IMPORTED_MODULE_1__.default)(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/stratify.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/stratify.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _accessors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accessors.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/accessors.js");
/* harmony import */ var _hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hierarchy/index.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/index.js");



var preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var nodes = Array.from(data),
        n = nodes.length,
        d,
        i,
        root,
        parent,
        node,
        nodeId,
        nodeKey,
        nodeByKey = new Map;

    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new _hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__.Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root) throw new Error("multiple roots");
        root = node;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(_hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__.computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_1__.required)(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_1__.required)(x), stratify) : parentId;
  };

  return stratify;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/tree.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/tree.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hierarchy/index.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/hierarchy/index.js");


function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(_hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__.Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/binary.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/binary.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/dice.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/dice.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/index.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./round.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/round.js");
/* harmony import */ var _squarify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./squarify.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/squarify.js");
/* harmony import */ var _accessors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../accessors.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/accessors.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/constant.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var tile = _squarify_js__WEBPACK_IMPORTED_MODULE_0__.default,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingTop = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingRight = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingBottom = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingLeft = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(_round_js__WEBPACK_IMPORTED_MODULE_2__.default);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_3__.required)(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingLeft;
  };

  return treemap;
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/resquarify.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/resquarify.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dice.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var _slice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/slice.js");
/* harmony import */ var _squarify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./squarify.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/squarify.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) (0,_dice_js__WEBPACK_IMPORTED_MODULE_0__.default)(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
        else (0,_slice_js__WEBPACK_IMPORTED_MODULE_1__.default)(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = (0,_squarify_js__WEBPACK_IMPORTED_MODULE_2__.squarifyRatio)(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(_squarify_js__WEBPACK_IMPORTED_MODULE_2__.phi));


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/round.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/round.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/slice.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/slice.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/sliceDice.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/sliceDice.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dice.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var _slice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slice.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/slice.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? _slice_js__WEBPACK_IMPORTED_MODULE_0__.default : _dice_js__WEBPACK_IMPORTED_MODULE_1__.default)(parent, x0, y0, x1, y1);
}


/***/ }),

/***/ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/squarify.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/squarify.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "phi": () => (/* binding */ phi),
/* harmony export */   "squarifyRatio": () => (/* binding */ squarifyRatio),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dice.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var _slice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice.js */ "../../node_modules/vega-hierarchy/node_modules/d3-hierarchy/src/treemap/slice.js");



var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) (0,_dice_js__WEBPACK_IMPORTED_MODULE_0__.default)(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else (0,_slice_js__WEBPACK_IMPORTED_MODULE_1__.default)(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi));


/***/ }),

/***/ "../../node_modules/vega-label/build/vega-label.module.js":
/*!****************************************************************!*\
  !*** ../../node_modules/vega-label/build/vega-label.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "label": () => (/* binding */ Label)
/* harmony export */ });
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-canvas */ "../../node_modules/vega-canvas/index.browser.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");





const ALPHA_MASK = 0xff000000; // alpha value equivalent to opacity 0.0625

const INSIDE_OPACITY_IN_ALPHA = 0x10000000;
const INSIDE_OPACITY = 0.0625;
function baseBitmaps($, data) {
  const bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided

  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));
  return [bitmap, undefined];
}
function markBitmaps($, avoidMarks, labelInside, isGroupArea) {
  // create canvas
  const width = $.width,
        height = $.height,
        border = labelInside || isGroupArea,
        context = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_0__.canvas)(width, height).getContext('2d'); // render all marks to be avoided into canvas

  avoidMarks.forEach(items => draw(context, items, border)); // get canvas buffer, create bitmaps

  const buffer = new Uint32Array(context.getImageData(0, 0, width, height).data.buffer),
        layer1 = $.bitmap(),
        layer2 = border && $.bitmap(); // populate bitmap layers

  let x, y, u, v, alpha;

  for (y = 0; y < height; ++y) {
    for (x = 0; x < width; ++x) {
      alpha = buffer[y * width + x] & ALPHA_MASK;

      if (alpha) {
        u = $(x);
        v = $(y);
        if (!isGroupArea) layer1.set(u, v); // update interior bitmap

        if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA) layer2.set(u, v); // update border bitmap
      }
    }
  }

  return [layer1, layer2];
}

function draw(context, items, interior) {
  if (!items.length) return;
  const type = items[0].mark.marktype;

  if (type === 'group') {
    items.forEach(group => {
      group.items.forEach(mark => draw(context, mark.items, interior));
    });
  } else {
    vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.Marks[type].draw(context, {
      items: interior ? items.map(prepare) : items
    });
  }
}
/**
 * Prepare item before drawing into canvas (setting stroke and opacity)
 * @param {object} source item to be prepared
 * @returns prepared item
 */


function prepare(source) {
  const item = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.rederive)(source, {});

  if (item.stroke) {
    item.strokeOpacity = 1;
  }

  if (item.fill) {
    item.fillOpacity = INSIDE_OPACITY;
    item.stroke = '#000';
    item.strokeOpacity = 1;
    item.strokeWidth = 2;
  }

  return item;
}

const DIV = 5,
      // bit shift from x, y index to bit vector array index
MOD = 31,
      // bit mask for index lookup within a bit vector
SIZE = 32,
      // individual bit vector size
RIGHT0 = new Uint32Array(SIZE + 1),
      // left-anchored bit vectors, full -> 0
RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full

RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];

for (let i = 1; i <= SIZE; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}

function Bitmap (w, h) {
  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));

  function _set(index, mask) {
    array[index] |= mask;
  }

  function _clear(index, mask) {
    array[index] &= mask;
  }

  return {
    array: array,
    get: (x, y) => {
      const index = y * w + x;
      return array[index >>> DIV] & 1 << (index & MOD);
    },
    set: (x, y) => {
      const index = y * w + x;

      _set(index >>> DIV, 1 << (index & MOD));
    },
    clear: (x, y) => {
      const index = y * w + x;

      _clear(index >>> DIV, ~(1 << (index & MOD)));
    },
    getRange: (x, y, x2, y2) => {
      let r = y2,
          start,
          end,
          indexStart,
          indexEnd;

      for (; r >= y; --r) {
        start = r * w + x;
        end = r * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;

        if (indexStart === indexEnd) {
          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {
            return true;
          }
        } else {
          if (array[indexStart] & RIGHT0[start & MOD]) return true;
          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;

          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array[i]) return true;
          }
        }
      }

      return false;
    },
    setRange: (x, y, x2, y2) => {
      let start, end, indexStart, indexEnd, i;

      for (; y <= y2; ++y) {
        start = y * w + x;
        end = y * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;

        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD]);

          _set(indexEnd, RIGHT1[(end & MOD) + 1]);

          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);
        }
      }
    },
    clearRange: (x, y, x2, y2) => {
      let start, end, indexStart, indexEnd, i;

      for (; y <= y2; ++y) {
        start = y * w + x;
        end = y * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;

        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD]);

          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);

          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);
        }
      }
    },
    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w
  };
}

function scaler (width, height, padding) {
  const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),
        w = ~~((width + 2 * padding + ratio) / ratio),
        h = ~~((height + 2 * padding + ratio) / ratio),
        scale = _ => ~~((_ + padding) / ratio);

  scale.invert = _ => _ * ratio - padding;

  scale.bitmap = () => Bitmap(w, h);

  scale.ratio = ratio;
  scale.padding = padding;
  scale.width = width;
  scale.height = height;
  return scale;
}

function placeAreaLabelNaive ($, bitmaps, avoidBaseMark, markIndex) {
  const width = $.width,
        height = $.height; // try to place a label within an input area mark

  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
          // area points
    n = items.length,
          // number of points
    textHeight = d.datum.fontSize,
          // label width
    textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text); // label height

    let maxAreaWidth = 0,
        x1,
        x2,
        y1,
        y2,
        x,
        y,
        areaWidth; // for each area sample point

    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2;
      x = (x1 + x2) / 2;
      y = (y1 + y2) / 2;
      areaWidth = Math.abs(x2 - x1 + y2 - y1);

      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x;
        d.y = y;
      }
    }

    x = textWidth / 2;
    y = textHeight / 2;
    x1 = d.x - x;
    x2 = d.x + x;
    y1 = d.y - y;
    y2 = d.y + y;
    d.align = 'center';

    if (x1 < 0 && x2 <= width) {
      d.align = 'left';
    } else if (0 <= x1 && width < x2) {
      d.align = 'right';
    }

    d.baseline = 'middle';

    if (y1 < 0 && y2 <= height) {
      d.baseline = 'top';
    } else if (0 <= y1 && height < y2) {
      d.baseline = 'bottom';
    }

    return true;
  };
}

function outOfBounds(x, y, textWidth, textHeight, width, height) {
  let r = textWidth / 2;
  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;
}

function _outOfBounds() {
  return false;
}

function collision($, x, y, textHeight, textWidth, h, bm0, bm1) {
  const w = textWidth * h / (textHeight * 2),
        x1 = $(x - w),
        x2 = $(x + w),
        y1 = $(y - (h = h / 2)),
        y2 = $(y + h);
  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);
}

function _collision($, x, y, textHeight, textWidth, h, bm0, bm1) {
  const w = textWidth * h / (textHeight * 2);
  let x1 = $(x - w),
      x2 = $(x + w),
      y1 = $(y - (h = h / 2)),
      y2 = $(y + h);
  x1 = x1 > 0 ? x1 : 0;
  y1 = y1 > 0 ? y1 : 0;
  x2 = x2 < $.width ? x2 : $.width - 1;
  y2 = y2 < $.height ? y2 : $.height - 1;
  return bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);
}

function getTests(infPadding) {
  return infPadding ? [_collision, _outOfBounds] : [collision, outOfBounds];
}

function placeAreaLabelReducedSearch ($, bitmaps, avoidBaseMark, markIndex, infPadding) {
  const width = $.width,
        height = $.height,
        [collision, outOfBounds] = getTests(infPadding),
        bm0 = bitmaps[0],
        // where labels have been placed
  bm1 = bitmaps[1]; // area outlines

  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {
    const x = $.invert(_x),
          y = $.invert(_y);
    let lo = maxSize,
        hi = height,
        mid;

    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
      // if the label fits at the current sample point,
      // perform binary search to find the largest font size that fits
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;

        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      } // place label if current lower bound exceeds prior max font size


      if (lo > maxSize) {
        return [x, y, lo, true];
      }
    }
  } // try to place a label within an input area mark


  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
          // area points
    n = items.length,
          // number of points
    textHeight = d.datum.fontSize,
          // label width
    textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text); // label height

    let maxSize = avoidBaseMark ? textHeight : 0,
        labelPlaced = false,
        labelPlaced2 = false,
        maxAreaWidth = 0,
        x1,
        x2,
        y1,
        y2,
        x,
        y,
        _x,
        _y,
        _x1,
        _xMid,
        _x2,
        _y1,
        _yMid,
        _y2,
        areaWidth,
        result,
        swapTmp; // for each area sample point


    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2;

      if (x1 > x2) {
        swapTmp = x1;
        x1 = x2;
        x2 = swapTmp;
      }

      if (y1 > y2) {
        swapTmp = y1;
        y1 = y2;
        y2 = swapTmp;
      }

      _x1 = $(x1);
      _x2 = $(x2);
      _xMid = ~~((_x1 + _x2) / 2);
      _y1 = $(y1);
      _y2 = $(y2);
      _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border

      for (_x = _xMid; _x >= _x1; --_x) {
        for (_y = _yMid; _y >= _y1; --_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);

          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      } // search along the line from mid point between the 2 border to upper border


      for (_x = _xMid; _x <= _x2; ++_x) {
        for (_y = _yMid; _y <= _y2; ++_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);

          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      } // place label at slice center if not placed through other means
      // and if we're not avoiding overlap with other areas


      if (!labelPlaced && !avoidBaseMark) {
        // one span is zero, hence we can add
        areaWidth = Math.abs(x2 - x1 + y2 - y1);
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2; // place label if it fits and improves the max area width

        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x;
          d.y = y;
          labelPlaced2 = true;
        }
      }
    } // record current label placement information, update label bitmap


    if (labelPlaced || labelPlaced2) {
      x = textWidth / 2;
      y = textHeight / 2;
      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));
      d.align = 'center';
      d.baseline = 'middle';
      return true;
    } else {
      return false;
    }
  };
}

const X_DIR = [-1, -1, 1, 1];
const Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill ($, bitmaps, avoidBaseMark, markIndex, infPadding) {
  const width = $.width,
        height = $.height,
        [collision, outOfBounds] = getTests(infPadding),
        bm0 = bitmaps[0],
        // where labels have been placed
  bm1 = bitmaps[1],
        // area outlines
  bm2 = $.bitmap(); // flood-fill visitations
  // try to place a label within an input area mark

  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
          // area points
    n = items.length,
          // number of points
    textHeight = d.datum.fontSize,
          // label width
    textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text),
          // label height
    stack = []; // flood fill stack

    let maxSize = avoidBaseMark ? textHeight : 0,
        labelPlaced = false,
        labelPlaced2 = false,
        maxAreaWidth = 0,
        x1,
        x2,
        y1,
        y2,
        x,
        y,
        _x,
        _y,
        lo,
        hi,
        mid,
        areaWidth; // for each area sample point


    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2; // add scaled center point to stack

      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points

      while (stack.length) {
        [_x, _y] = stack.pop(); // exit if point already marked

        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap
        // add search points for all (in bound) directions

        bm2.set(_x, _y);

        for (let j = 0; j < 4; ++j) {
          x = _x + X_DIR[j];
          y = _y + Y_DIR[j];
          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);
        } // unscale point back to x, y space


        x = $.invert(_x);
        y = $.invert(_y);
        lo = maxSize;
        hi = height; // TODO: make this bound smaller

        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          // if the label fits at the current sample point,
          // perform binary search to find the largest font size that fits
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;

            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          } // place label if current lower bound exceeds prior max font size


          if (lo > maxSize) {
            d.x = x;
            d.y = y;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      } // place label at slice center if not placed through other means
      // and if we're not avoiding overlap with other areas


      if (!labelPlaced && !avoidBaseMark) {
        // one span is zero, hence we can add
        areaWidth = Math.abs(x2 - x1 + y2 - y1);
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2; // place label if it fits and improves the max area width

        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x;
          d.y = y;
          labelPlaced2 = true;
        }
      }
    } // record current label placement information, update label bitmap


    if (labelPlaced || labelPlaced2) {
      x = textWidth / 2;
      y = textHeight / 2;
      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));
      d.align = 'center';
      d.baseline = 'middle';
      return true;
    } else {
      return false;
    }
  };
}

const Aligns = ['right', 'center', 'left'],
      Baselines = ['bottom', 'middle', 'top'];
function placeMarkLabel ($, bitmaps, anchors, offsets, infPadding) {
  const width = $.width,
        height = $.height,
        bm0 = bitmaps[0],
        bm1 = bitmaps[1],
        n = offsets.length;
  return function (d) {
    const boundary = d.boundary,
          textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound

    if (!infPadding && (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height)) {
      return false;
    }

    let textWidth = 0,
        dx,
        dy,
        isInside,
        sizeFactor,
        insideFactor,
        x1,
        x2,
        y1,
        y2,
        xc,
        yc,
        _x1,
        _x2,
        _y1,
        _y2; // for each anchor and offset


    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 0x3) - 1;
      dy = (anchors[i] >>> 0x2 & 0x3) - 1;
      isInside = dx === 0 && dy === 0 || offsets[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets[i] < 0 ? -1 : 1;
      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;
      y1 = yc - textHeight / 2;
      y2 = yc + textHeight / 2;
      _x1 = $(x1);
      _y1 = $(y1);
      _y2 = $(y2);

      if (infPadding) {
        _x1 = _x1 < 0 ? 0 : _x1;
        _y1 = _y1 < 0 ? 0 : _y1;
        _y2 = _y2 >= $.height ? $.height - 1 : _y2;
      }

      if (!textWidth) {
        // to avoid finding width of text label,
        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {
          // skip this anchor/offset option if we fail to place a label with 1px width
          continue;
        } else {
          // Otherwise, find the label width
          textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text);
        }
      }

      xc = x1 + insideFactor * textWidth * dx / 2;
      x1 = xc - textWidth / 2;
      x2 = xc + textWidth / 2;
      _x1 = $(x1);
      _x2 = $(x2);

      if (infPadding) {
        _x1 = _x1 < 0 ? 0 : _x1;
        _x2 = _x2 >= $.width ? $.width - 1 : _x2;
      }

      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {
        // place label if the position is placeable
        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x2, _y2);
        return true;
      }
    }

    return false;
  };
} // Test if a label with the given dimensions can be added without overlap

function test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x1, y1, x2, y2, boundary) : bm0.getRange(_x1, _y1, _x2, _y2)));
}

function isInMarkBound(x1, y1, x2, y2, boundary) {
  return boundary[0] <= x1 && x2 <= boundary[2] && boundary[3] <= y1 && y2 <= boundary[5];
}

const TOP = 0x0,
      MIDDLE = 0x4,
      BOTTOM = 0x8,
      LEFT = 0x0,
      CENTER = 0x1,
      RIGHT = 0x2; // Mapping from text anchor to number representation

const anchorCode = {
  'top-left': TOP + LEFT,
  'top': TOP + CENTER,
  'top-right': TOP + RIGHT,
  'left': MIDDLE + LEFT,
  'middle': MIDDLE + CENTER,
  'right': MIDDLE + RIGHT,
  'bottom-left': BOTTOM + LEFT,
  'bottom': BOTTOM + CENTER,
  'bottom-right': BOTTOM + RIGHT
};
const placeAreaLabel = {
  'naive': placeAreaLabelNaive,
  'reduced-search': placeAreaLabelReducedSearch,
  'floodfill': placeAreaLabelFloodFill
};
function labelLayout (texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {
  // early exit for empty data
  if (!texts.length) return texts;
  const positions = Math.max(offset.length, anchor.length),
        offsets = getOffsets(offset, positions),
        anchors = getAnchors(anchor, positions),
        marktype = markType(texts[0].datum),
        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,
        isGroupArea = grouptype === 'area',
        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),
        infPadding = padding === null || padding === Infinity,
        $ = scaler(size[0], size[1], infPadding ? 0 : padding),
        isNaiveGroupArea = isGroupArea && method === 'naive'; // prepare text mark data for placing

  const data = texts.map(d => ({
    datum: d,
    opacity: 0,
    x: undefined,
    y: undefined,
    align: undefined,
    baseline: undefined,
    boundary: boundary(d)
  }));
  let bitmaps;

  if (!isNaiveGroupArea) {
    // sort labels in priority order, if comparator is provided
    if (compare) {
      data.sort((a, b) => compare(a.datum, b.datum));
    } // flag indicating if label can be placed inside its base mark


    let labelInside = false;

    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      // label inside if anchor is at center
      // label inside if offset to be inside the mark bound
      labelInside = anchors[i] === 0x5 || offsets[i] < 0;
    } // extract data information from base mark when base mark is to be avoided
    // base mark is implicitly avoided if it is a group area


    if (marktype && (avoidBaseMark || isGroupArea)) {
      avoidMarks = [texts.map(d => d.datum)].concat(avoidMarks);
    } // generate bitmaps for layout calculation


    bitmaps = avoidMarks.length ? markBitmaps($, avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);
  } // generate label placement function


  const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex, infPadding) : placeMarkLabel($, bitmaps, anchors, offsets, infPadding); // place all labels

  data.forEach(d => d.opacity = +place(d));
  return data;
}

function getOffsets(_, count) {
  const offsets = new Float64Array(count),
        n = _.length;

  for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;

  for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];

  return offsets;
}

function getAnchors(_, count) {
  const anchors = new Int8Array(count),
        n = _.length;

  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];

  for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];

  return anchors;
}

function markType(item) {
  return item && item.mark && item.mark.marktype;
}
/**
 * Factory function for function for getting base mark boundary, depending
 * on mark and group type. When mark type is undefined, line or area: boundary
 * is the coordinate of each data point. When base mark is grouped line,
 * boundary is either at the beginning or end of the line depending on the
 * value of lineAnchor. Otherwise, use bounds of base mark.
 */


function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];

  if (!marktype) {
    return xy; // no reactive geometry
  } else if (marktype === 'line' || marktype === 'area') {
    return d => xy(d.datum);
  } else if (grouptype === 'line') {
    return d => {
      const items = d.datum.items[markIndex].items;
      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return d => {
      const b = d.datum.bounds;
      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];
    };
  }
}

const Output = ['x', 'y', 'opacity', 'align', 'baseline'];
const Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];
/**
 * Compute text label layout to annotate marks.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for sorting label data in priority order.
 * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.
 *   The available options are 'top-left', 'left', 'bottom-left', 'top',
 *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.
 * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.
 *   This parameter is parallel to the list of anchor points.
 * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.
 *   If this parameter is null, a label may exceed the layout size without any boundary.
 * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor
 *   position for labels. One of 'start' or 'end'.
 * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating
 *   which mark within the group should be labeled.
 * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label
 *   layout should avoid overlap.
 * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid
 *   overlap with the underlying base mark being labeled.
 * @param {string} [params.method='naive'] - For area make labels only, a method for
 *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.
 * @param {Array<string>} [params.as] - The output fields written by the transform.
 *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].
 */

function Label(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Label.Definition = {
  type: 'Label',
  metadata: {
    modifies: true
  },
  params: [{
    name: 'size',
    type: 'number',
    array: true,
    length: 2,
    required: true
  }, {
    name: 'sort',
    type: 'compare'
  }, {
    name: 'anchor',
    type: 'string',
    array: true,
    default: Anchors
  }, {
    name: 'offset',
    type: 'number',
    array: true,
    default: [1]
  }, {
    name: 'padding',
    type: 'number',
    default: 0,
    null: true
  }, {
    name: 'lineAnchor',
    type: 'string',
    values: ['start', 'end'],
    default: 'end'
  }, {
    name: 'markIndex',
    type: 'number',
    default: 0
  }, {
    name: 'avoidBaseMark',
    type: 'boolean',
    default: true
  }, {
    name: 'avoidMarks',
    type: 'data',
    array: true
  }, {
    name: 'method',
    type: 'string',
    default: 'naive'
  }, {
    name: 'as',
    type: 'string',
    array: true,
    length: Output.length,
    default: Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_3__.inherits)(Label, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    function modp(param) {
      const p = _[param];
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.isFunction)(p) && pulse.modified(p.fields);
    }

    const mod = _.modified();

    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;

    if (!_.size || _.size.length !== 2) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.error)('Size parameter should be specified as a [width, height] array.');
    }

    const as = _.as || Output; // run label layout

    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.array)(_.offset == null ? 1 : _.offset), (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.array)(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(l => {
      // write layout results to data stream
      const t = l.datum;
      t[as[0]] = l.x;
      t[as[1]] = l.y;
      t[as[2]] = l.opacity;
      t[as[3]] = l.align;
      t[as[4]] = l.baseline;
    });
    return pulse.reflow(mod).modifies(as);
  }

});




/***/ }),

/***/ "../../node_modules/vega-loader/build/vega-loader.browser.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-loader/build/vega-loader.browser.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "formats": () => (/* binding */ formats),
/* harmony export */   "inferType": () => (/* binding */ inferType),
/* harmony export */   "inferTypes": () => (/* binding */ inferTypes),
/* harmony export */   "loader": () => (/* binding */ loader),
/* harmony export */   "read": () => (/* binding */ read),
/* harmony export */   "responseType": () => (/* binding */ responseType),
/* harmony export */   "typeParsers": () => (/* binding */ typeParsers)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "../../node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! topojson-client */ "../../node_modules/topojson-client/src/index.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-format */ "../../node_modules/vega-format/build/vega-format.module.js");





//   https://...    file://...    //...

const protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/; // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://

const allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i; // eslint-disable-line no-useless-escape

const whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; // eslint-disable-line no-control-regex
// Special treatment in node.js for the file: protocol

const fileProtocol = 'file://';
/**
 * Factory for a loader constructor that provides methods for requesting
 * files from either the network or disk, and for sanitizing request URIs.
 * @param {function} fetch - The Fetch API for HTTP network requests.
 *   If null or undefined, HTTP loading will be disabled.
 * @param {object} fs - The file system interface for file loading.
 *   If null or undefined, local file loading will be disabled.
 * @return {function} A loader constructor with the following signature:
 *   param {object} [options] - Optional default loading options to use.
 *   return {object} - A new loader instance.
 */

function loaderFactory (fetch, fs) {
  return options => ({
    options: options || {},
    sanitize: sanitize,
    load: load,
    fileAccess: !!fs,
    file: fileLoader(fs),
    http: httpLoader(fetch)
  });
}
/**
 * Load an external resource, typically either from the web or from the local
 * filesystem. This function uses {@link sanitize} to first sanitize the uri,
 * then calls either {@link http} (for web requests) or {@link file} (for
 * filesystem loading).
 * @param {string} uri - The resource indicator (e.g., URL or filename).
 * @param {object} [options] - Optional loading options. These options will
 *   override any existing default options.
 * @return {Promise} - A promise that resolves to the loaded content.
 */

async function load(uri, options) {
  const opt = await this.sanitize(uri, options),
        url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options);
}
/**
 * URI sanitizer function.
 * @param {string} uri - The uri (url or filename) to check.
 * @param {object} options - An options hash.
 * @return {Promise} - A promise that resolves to an object containing
 *  sanitized uri data, or rejects it the input uri is deemed invalid.
 *  The properties of the resolved object are assumed to be
 *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be
 *  provided by the 'href' property of the returned object.
 */


async function sanitize(uri, options) {
  options = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.options, options);
  const fileAccess = this.fileAccess,
        result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));

  if (uri == null || typeof uri !== 'string' || !isAllowed) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Sanitize failure, invalid URI: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(uri));
  }

  const hasProtocol = protocol_re.test(uri); // if relative url (no protocol/host), prepend baseURL

  if ((base = options.baseURL) && !hasProtocol) {
    // Ensure that there is a slash between the baseURL (e.g. hostname) and url
    if (!uri.startsWith('/') && !base.endsWith('/')) {
      uri = '/' + uri;
    }

    uri = base + uri;
  } // should we load from file system?


  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;

  if (isFile) {
    // strip file protocol
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith('//')) {
    if (options.defaultProtocol === 'file') {
      // if is file, strip protocol and set loadFile flag
      uri = uri.slice(2);
      loadFile = true;
    } else {
      // if relative protocol (starts with '//'), prepend default protocol
      uri = (options.defaultProtocol || 'http') + ':' + uri;
    }
  } // set non-enumerable mode flag to indicate local file load


  Object.defineProperty(result, 'localFile', {
    value: !!loadFile
  }); // set uri

  result.href = uri; // set default result target, if specified

  if (options.target) {
    result.target = options.target + '';
  } // set default result rel, if specified (#1542)


  if (options.rel) {
    result.rel = options.rel + '';
  } // provide control over cross-origin image handling (#2238)
  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image


  if (options.context === 'image' && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + '';
  } // return


  return result;
}
/**
 * File system loader factory.
 * @param {object} fs - The file system interface.
 * @return {function} - A file loader with the following signature:
 *   param {string} filename - The file system path to load.
 *   param {string} filename - The file system path to load.
 *   return {Promise} A promise that resolves to the file contents.
 */


function fileLoader(fs) {
  return fs ? filename => new Promise((accept, reject) => {
    fs.readFile(filename, (error, data) => {
      if (error) reject(error);else accept(data);
    });
  }) : fileReject;
}
/**
 * Default file system loader that simply rejects.
 */


async function fileReject() {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No file system access.');
}
/**
 * HTTP request handler factory.
 * @param {function} fetch - The Fetch API method.
 * @return {function} - An http loader with the following signature:
 *   param {string} url - The url to request.
 *   param {object} options - An options hash.
 *   return {Promise} - A promise that resolves to the file contents.
 */


function httpLoader(fetch) {
  return fetch ? async function (url, options) {
    const opt = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.options.http, options),
          type = options && options.response,
          response = await fetch(url, opt);
    return !response.ok ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(response.status + '' + response.statusText) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(response[type]) ? response[type]() : response.text();
  } : httpReject;
}
/**
 * Default http request handler that simply rejects.
 */


async function httpReject() {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No HTTP fetch method available.');
}

const isValid = _ => _ != null && _ === _;

const isBoolean = _ => _ === 'true' || _ === 'false' || _ === true || _ === false;

const isDate = _ => !Number.isNaN(Date.parse(_));

const isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);

const isInteger = _ => isNumber(_) && Number.isInteger(+_);

const typeParsers = {
  boolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean,
  integer: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  number: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  date: vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate,
  string: vega_util__WEBPACK_IMPORTED_MODULE_0__.toString,
  unknown: vega_util__WEBPACK_IMPORTED_MODULE_0__.identity
};
const typeTests = [isBoolean, isInteger, isNumber, isDate];
const typeList = ['boolean', 'integer', 'number', 'date'];
function inferType(values, field) {
  if (!values || !values.length) return 'unknown';
  const n = values.length,
        m = typeTests.length,
        a = typeTests.map((_, i) => i + 1);

  for (let i = 0, t = 0, j, value; i < n; ++i) {
    value = field ? values[i][field] : values[i];

    for (j = 0; j < m; ++j) {
      if (a[j] && isValid(value) && !typeTests[j](value)) {
        a[j] = 0;
        ++t;
        if (t === typeTests.length) return 'string';
      }
    }
  }

  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes(data, fields) {
  return fields.reduce((types, field) => {
    types[field] = inferType(data, field);
    return types;
  }, {});
}

function delimitedFormat(delimiter) {
  const parse = function (data, format) {
    const delim = {
      delimiter: delimiter
    };
    return dsv(data, format ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(format, delim) : delim);
  };

  parse.responseType = 'text';
  return parse;
}
function dsv(data, format) {
  if (format.header) {
    data = format.header.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join(format.delimiter) + '\n' + data;
  }

  return (0,d3_dsv__WEBPACK_IMPORTED_MODULE_3__.default)(format.delimiter).parse(data + '');
}
dsv.responseType = 'text';

function isBuffer(_) {
  return typeof Buffer === 'function' && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}

function json(data, format) {
  const prop = format && format.property ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(format.property) : vega_util__WEBPACK_IMPORTED_MODULE_0__.identity;
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(data) && !isBuffer(data) ? parseJSON(prop(data), format) : prop(JSON.parse(data));
}
json.responseType = 'json';

function parseJSON(data, format) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isIterable)(data)) {
    data = [...data];
  }

  return format && format.copy ? JSON.parse(JSON.stringify(data)) : data;
}

const filters = {
  interior: (a, b) => a !== b,
  exterior: (a, b) => a === b
};
function topojson(data, format) {
  let method, object, property, filter;
  data = json(data, format);

  if (format && format.feature) {
    method = topojson_client__WEBPACK_IMPORTED_MODULE_1__.feature;
    property = format.feature;
  } else if (format && format.mesh) {
    method = topojson_client__WEBPACK_IMPORTED_MODULE_1__.mesh;
    property = format.mesh;
    filter = filters[format.filter];
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing TopoJSON feature or mesh parameter.');
  }

  object = (object = data.objects[property]) ? method(data, object, filter) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid TopoJSON object: ' + property);
  return object && object.features || [object];
}
topojson.responseType = 'json';

const format = {
  dsv: dsv,
  csv: delimitedFormat(','),
  tsv: delimitedFormat('\t'),
  json: json,
  topojson: topojson
};
function formats(name, reader) {
  if (arguments.length > 1) {
    format[name] = reader;
    return this;
  } else {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(format, name) ? format[name] : null;
  }
}
function responseType(type) {
  const f = formats(type);
  return f && f.responseType || 'text';
}

function read (data, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || 'json');
  if (!reader) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unknown data format type: ' + schema.type);
  data = reader(data, schema);
  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(data, 'columns')) delete data.columns;
  return data;
}

function parse(data, types, timeParser, utcParser) {
  if (!data.length) return; // early exit for empty data

  const locale = (0,vega_format__WEBPACK_IMPORTED_MODULE_2__.timeFormatDefaultLocale)();
  timeParser = timeParser || locale.timeParse;
  utcParser = utcParser || locale.utcParse;
  let fields = data.columns || Object.keys(data[0]),
      datum,
      field,
      i,
      j,
      n,
      m;
  if (types === 'auto') types = inferTypes(data, fields);
  fields = Object.keys(types);
  const parsers = fields.map(field => {
    const type = types[field];
    let parts, pattern;

    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {
      parts = type.split(/:(.+)?/, 2); // split on first :

      pattern = parts[1];

      if (pattern[0] === '\'' && pattern[pattern.length - 1] === '\'' || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }

      const parse = parts[0] === 'utc' ? utcParser : timeParser;
      return parse(pattern);
    }

    if (!typeParsers[type]) {
      throw Error('Illegal format pattern: ' + field + ':' + type);
    }

    return typeParsers[type];
  });

  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {
    datum = data[i];

    for (j = 0; j < m; ++j) {
      field = fields[j];
      datum[field] = parsers[j](datum[field]);
    }
  }
}

const loader = loaderFactory(typeof fetch !== 'undefined' && fetch, // use built-in fetch API
null // no file system access
);




/***/ }),

/***/ "../../node_modules/vega-parser/build/vega-parser.module.js":
/*!******************************************************************!*\
  !*** ../../node_modules/vega-parser/build/vega-parser.module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AxisDomainRole": () => (/* binding */ AxisDomainRole),
/* harmony export */   "AxisGridRole": () => (/* binding */ AxisGridRole),
/* harmony export */   "AxisLabelRole": () => (/* binding */ AxisLabelRole),
/* harmony export */   "AxisRole": () => (/* binding */ AxisRole),
/* harmony export */   "AxisTickRole": () => (/* binding */ AxisTickRole),
/* harmony export */   "AxisTitleRole": () => (/* binding */ AxisTitleRole),
/* harmony export */   "DataScope": () => (/* binding */ DataScope),
/* harmony export */   "FrameRole": () => (/* binding */ FrameRole),
/* harmony export */   "LegendEntryRole": () => (/* binding */ LegendEntryRole),
/* harmony export */   "LegendLabelRole": () => (/* binding */ LegendLabelRole),
/* harmony export */   "LegendRole": () => (/* binding */ LegendRole),
/* harmony export */   "LegendSymbolRole": () => (/* binding */ LegendSymbolRole),
/* harmony export */   "LegendTitleRole": () => (/* binding */ LegendTitleRole),
/* harmony export */   "MarkRole": () => (/* binding */ MarkRole),
/* harmony export */   "Scope": () => (/* binding */ Scope),
/* harmony export */   "ScopeRole": () => (/* binding */ ScopeRole),
/* harmony export */   "config": () => (/* binding */ defaults),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "signal": () => (/* binding */ parseSignal),
/* harmony export */   "signalUpdates": () => (/* binding */ parseSignalUpdates),
/* harmony export */   "stream": () => (/* binding */ parseStream)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-functions */ "../../node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_event_selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-event-selector */ "../../node_modules/vega-event-selector/build/vega-event-selector.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");






function parseAutosize (spec) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? spec : {
    type: spec || 'pad'
  };
}

const number = _ => +_ || 0;

const paddingObject = _ => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});

function parsePadding (spec) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {
    top: number(spec.top),
    bottom: number(spec.bottom),
    left: number(spec.left),
    right: number(spec.right)
  };
}

const encoder = _ => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _) : {
  value: _
};
function addEncode(object, name, value, set) {
  if (value != null) {
    const isEncoder = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) && value.length && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value[0]); // Always assign signal to update, even if the signal is from the enter block

    if (isEncoder) {
      object.update[name] = value;
    } else {
      object[set || 'enter'][name] = {
        value: value
      };
    }

    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object, enter, update) {
  for (const name in enter) {
    addEncode(object, name, enter[name]);
  }

  for (const name in update) {
    addEncode(object, name, update[name], 'update');
  }
}
function extendEncode(encode, extra, skip) {
  for (const name in extra) {
    if (skip && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(skip, name)) continue;
    encode[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(encode[name] || {}, extra[name]);
  }

  return encode;
}
function has(key, encode) {
  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);
}

const MarkRole = 'mark';
const FrameRole = 'frame';
const ScopeRole = 'scope';
const AxisRole = 'axis';
const AxisDomainRole = 'axis-domain';
const AxisGridRole = 'axis-grid';
const AxisLabelRole = 'axis-label';
const AxisTickRole = 'axis-tick';
const AxisTitleRole = 'axis-title';
const LegendRole = 'legend';
const LegendBandRole = 'legend-band';
const LegendEntryRole = 'legend-entry';
const LegendGradientRole = 'legend-gradient';
const LegendLabelRole = 'legend-label';
const LegendSymbolRole = 'legend-symbol';
const LegendTitleRole = 'legend-title';
const TitleRole = 'title';
const TitleTextRole = 'title-text';
const TitleSubtitleRole = 'title-subtitle';

function applyDefaults (encode, type, role, style, config) {
  const defaults = {},
        enter = {};
  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)

  key = 'lineBreak';

  if (type === 'text' && config[key] != null && !has(key, encode)) {
    applyDefault(defaults, key, config[key]);
  } // ignore legend and axis roles


  if (role == 'legend' || String(role).startsWith('axis')) {
    role = null;
  } // resolve mark config


  props = role === FrameRole ? config.group : role === MarkRole ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, config.mark, config[type]) : null;

  for (key in props) {
    // do not apply defaults if relevant fields are defined
    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));
    if (!skip) applyDefault(defaults, key, props[key]);
  } // resolve styles, apply with increasing precedence


  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(style).forEach(name => {
    const props = config.style && config.style[name];

    for (const key in props) {
      if (!has(key, encode)) {
        applyDefault(defaults, key, props[key]);
      }
    }
  });
  encode = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, encode); // defensive copy

  for (key in defaults) {
    props = defaults[key];

    if (props.signal) {
      (update = update || {})[key] = props;
    } else {
      enter[key] = props;
    }
  }

  encode.enter = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(enter, encode.enter);
  if (update) encode.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(update, encode.update);
  return encode;
}

function applyDefault(defaults, key, value) {
  defaults[key] = value && value.signal ? {
    signal: value.signal
  } : {
    value: value
  };
}

const scaleRef = scale => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(scale) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(scale) : scale.signal ? `(${scale.signal})` : field(scale);

function entry$1(enc) {
  if (enc.gradient != null) {
    return gradient(enc);
  }

  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(enc.value) : undefined;

  if (enc.scale != null) {
    value = scale(enc, value);
  }

  if (value === undefined) {
    value = null;
  }

  if (enc.exponent != null) {
    value = `pow(${value},${property(enc.exponent)})`;
  }

  if (enc.mult != null) {
    value += `*${property(enc.mult)}`;
  }

  if (enc.offset != null) {
    value += `+${property(enc.offset)}`;
  }

  if (enc.round) {
    value = `round(${value})`;
  }

  return value;
}

const _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;

function color(enc) {
  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;
}

function gradient(enc) {
  // map undefined to null; expression lang does not allow undefined
  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(_)); // trim null inputs from the end

  while (args.length && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(args) == null) args.pop();

  args.unshift(scaleRef(enc.gradient));
  return `gradient(${args.join(',')})`;
}

function property(property) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(property) ? '(' + entry$1(property) + ')' : property;
}

function field(ref) {
  return resolveField((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(ref) ? ref : {
    datum: ref
  });
}

function resolveField(ref) {
  let object, level, field;

  if (ref.signal) {
    object = 'datum';
    field = ref.signal;
  } else if (ref.group || ref.parent) {
    level = Math.max(1, ref.level || 1);
    object = 'item';

    while (level-- > 0) {
      object += '.mark.group';
    }

    if (ref.parent) {
      field = ref.parent;
      object += '.datum';
    } else {
      field = ref.group;
    }
  } else if (ref.datum) {
    object = 'datum';
    field = ref.datum;
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid field reference: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ref));
  }

  if (!ref.signal) {
    field = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.splitAccessPath)(field).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join('][') : resolveField(field);
  }

  return object + '[' + field + ']';
}

function scale(enc, value) {
  const scale = scaleRef(enc.scale);

  if (enc.range != null) {
    // pull value from scale range
    value = `lerp(_range(${scale}), ${+enc.range})`;
  } else {
    // run value through scale and/or pull scale bandwidth
    if (value !== undefined) value = `_scale(${scale}, ${value})`;

    if (enc.band) {
      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));

      if (enc.extra) {
        // include logic to handle extraneous elements
        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;
      }
    }

    if (value == null) value = '0';
  }

  return value;
}

function rule (enc) {
  let code = '';
  enc.forEach(rule => {
    const value = entry$1(rule);
    code += rule.test ? `(${rule.test})?${value}:` : value;
  }); // if no else clause, terminate with null (#1366)

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(code) === ':') {
    code += 'null';
  }

  return code;
}

function parseEncode (encode, type, role, style, scope, params) {
  const enc = {};
  params = params || {};
  params.encoders = {
    $encode: enc
  };
  encode = applyDefaults(encode, type, role, style, scope.config);

  for (const key in encode) {
    enc[key] = parseBlock(encode[key], type, params, scope);
  }

  return params;
}

function parseBlock(block, marktype, params, scope) {
  const channels = {},
        fields = {};

  for (const name in block) {
    if (block[name] != null) {
      // skip any null entries
      channels[name] = parse$1(expr(block[name]), scope, params, fields);
    }
  }

  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}

function expr(enc) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(enc) ? rule(enc) : entry$1(enc);
}

function parse$1(code, scope, params, fields) {
  const expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(code, scope);
  expr.$fields.forEach(name => fields[name] = 1);
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(params, expr.$params);
  return expr.$expr;
}

const OUTER = 'outer',
      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];

function outerError(prefix, name) {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(prefix + ' for "outer" push: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
}

function parseSignal (signal, scope) {
  const name = signal.name;

  if (signal.push === OUTER) {
    // signal must already be defined, raise error if not
    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition

    OUTER_INVALID.forEach(prop => {
      if (signal[prop] !== undefined) outerError('Invalid property ', prop);
    });
  } else {
    // define a new signal in the current scope
    const op = scope.addSignal(name, signal.value);
    if (signal.react === false) op.react = false;
    if (signal.bind) scope.addBinding(name, signal.bind);
  }
}

function Entry(type, value, params, parent) {
  this.id = -1;
  this.type = type;
  this.value = value;
  this.params = params;
  if (parent) this.parent = parent;
}
function entry(type, value, params, parent) {
  return new Entry(type, value, params, parent);
}
function operator(value, params) {
  return entry('operator', value, params);
} // -----

function ref(op) {
  const ref = {
    $ref: op.id
  }; // if operator not yet registered, cache ref to resolve later

  if (op.id < 0) (op.refs = op.refs || []).push(ref);
  return ref;
}
function fieldRef$1(field, name) {
  return name ? {
    $field: field,
    $name: name
  } : {
    $field: field
  };
}
const keyFieldRef = fieldRef$1('key');
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref = {
    $key: fields
  };
  if (flat) ref.$flat = true;
  return ref;
} // -----

const Ascending = 'ascending';
const Descending = 'descending';
function sortKey(sort) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);
}
function aggrField(op, field) {
  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');
} // -----

const Scope$1 = 'scope';
const View = 'view';
function isSignal(_) {
  return _ && _.signal;
}
function isExpr$1(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_)) return true;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_)) for (const key in _) {
    if (hasSignal(_[key])) return true;
  }
  return false;
}
function value(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}

const Timer = 'timer';
function parseStream(stream, scope) {
  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid stream specification: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(stream));
  return method(stream, scope);
}

function eventSource(source) {
  return source === Scope$1 ? View : source || View;
}

function mergeStream(stream, scope) {
  const list = stream.merge.map(s => parseStream(s, scope)),
        entry = streamParameters({
    merge: list
  }, stream, scope);
  return scope.addStream(entry).id;
}

function nestedStream(stream, scope) {
  const id = parseStream(stream.stream, scope),
        entry = streamParameters({
    stream: id
  }, stream, scope);
  return scope.addStream(entry).id;
}

function eventStream(stream, scope) {
  let id;

  if (stream.type === Timer) {
    id = scope.event(Timer, stream.throttle);
    stream = {
      between: stream.between,
      filter: stream.filter
    };
  } else {
    id = scope.event(eventSource(stream.source), stream.type);
  }

  const entry = streamParameters({
    stream: id
  }, stream, scope);
  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;
}

function streamParameters(entry, stream, scope) {
  let param = stream.between;

  if (param) {
    if (param.length !== 2) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Stream "between" parameter must have 2 entries: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(stream));
    }

    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];
  }

  param = stream.filter ? [].concat(stream.filter) : [];

  if (stream.marktype || stream.markname || stream.markrole) {
    // add filter for mark type, name and/or role
    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));
  }

  if (stream.source === Scope$1) {
    // add filter to limit events from sub-scope only
    param.push('inScope(event.item)');
  }

  if (param.length) {
    entry.filter = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)('(' + param.join(')&&(') + ')', scope).$expr;
  }

  if ((param = stream.throttle) != null) {
    entry.throttle = +param;
  }

  if ((param = stream.debounce) != null) {
    entry.debounce = +param;
  }

  if (stream.consume) {
    entry.consume = true;
  }

  return entry;
}

function filterMark(type, name, role) {
  const item = 'event.item';
  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\'' + type + '\'' : '') + (role ? '&&' + item + '.mark.role===\'' + role + '\'' : '') + (name ? '&&' + item + '.mark.name===\'' + name + '\'' : '');
}

const OP_VALUE_EXPR = {
  code: '_.$value',
  ast: {
    type: 'Identifier',
    value: 'value'
  }
};
function parseUpdate (spec, scope, target) {
  const encode = spec.encode,
        entry = {
    target: target
  };
  let events = spec.events,
      update = spec.update,
      sources = [];

  if (!events) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signal update missing events specification.');
  } // interpret as an event selector string


  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(events)) {
    events = (0,vega_event_selector__WEBPACK_IMPORTED_MODULE_2__.parseSelector)(events, scope.isSubscope() ? Scope$1 : View);
  } // separate event streams from signal updates


  events = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners

  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  } // merge event streams, include as source


  if (events.length) {
    sources.push(events.length > 1 ? {
      merge: events
    } : events[0]);
  }

  if (encode != null) {
    if (update) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signal encode and update are mutually exclusive.');
    update = 'encode(item(),' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(encode) + ')';
  } // resolve update value


  entry.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(update) ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update, scope) : update.expr != null ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update.signal)
    }
  } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid signal update specification.');

  if (spec.force) {
    entry.options = {
      force: true
    };
  }

  sources.forEach(source => scope.addUpdate((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(streamSource(source, scope), entry)));
}

function streamSource(stream, scope) {
  return {
    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)
  };
}

function mergeSources(sources) {
  return {
    signal: '[' + sources.map(s => s.scale ? 'scale("' + s.scale + '")' : s.signal) + ']'
  };
}

function parseSignalUpdates (signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr = signal.update;

  if (signal.init) {
    if (expr) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signals can not include both init and update expressions.');
    } else {
      expr = signal.init;
      op.initonly = true;
    }
  }

  if (expr) {
    expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(expr, scope);
    op.update = expr.$expr;
    op.params = expr.$params;
  }

  if (signal.on) {
    signal.on.forEach(_ => parseUpdate(_, scope, op.id));
  }
}

const transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);

const Aggregate = transform('aggregate');
const AxisTicks = transform('axisticks');
const Bound = transform('bound');
const Collect = transform('collect');
const Compare = transform('compare');
const DataJoin = transform('datajoin');
const Encode = transform('encode');
const Expression = transform('expression');
const Facet = transform('facet');
const Field = transform('field');
const Key = transform('key');
const LegendEntries = transform('legendentries');
const Load = transform('load');
const Mark = transform('mark');
const MultiExtent = transform('multiextent');
const MultiValues = transform('multivalues');
const Overlap = transform('overlap');
const Params = transform('params');
const PreFacet = transform('prefacet');
const Projection = transform('projection');
const Proxy = transform('proxy');
const Relay = transform('relay');
const Render = transform('render');
const Scale = transform('scale');
const Sieve = transform('sieve');
const SortItems = transform('sortitems');
const ViewLayout = transform('viewlayout');
const Values = transform('values');

let FIELD_REF_ID = 0;
const MULTIDOMAIN_SORT_OPS = {
  min: 'min',
  max: 'max',
  count: 'sum'
};
function initScale(spec, scope) {
  const type = spec.type || 'linear';

  if (!(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isValidScaleType)(type)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(type));
  }

  scope.addScale(spec.name, {
    type,
    domain: undefined
  });
}
function parseScale(spec, scope) {
  const params = scope.getScale(spec.name).params;
  let key;
  params.domain = parseScaleDomain(spec.domain, spec, scope);

  if (spec.range != null) {
    params.range = parseScaleRange(spec, scope, params);
  }

  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params);
  }

  if (spec.nice != null) {
    params.nice = parseScaleNice(spec.nice);
  }

  if (spec.bins != null) {
    params.bins = parseScaleBins(spec.bins, scope);
  }

  for (key in spec) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, key) || key === 'name') continue;
    params[key] = parseLiteral(spec[key], scope);
  }
}

function parseLiteral(v, scope) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(v) ? v : v.signal ? scope.signalRef(v.signal) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported object: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(v));
}

function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));
}

function dataLookupError(name) {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Can not find data set: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
} // -- SCALE DOMAIN ----


function parseScaleDomain(domain, spec, scope) {
  if (!domain) {
    if (spec.domainMin != null || spec.domainMax != null) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No scale domain defined for domainMin/domainMax to override.');
    }

    return; // default domain
  }

  return domain.signal ? scope.signalRef(domain.signal) : ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);
}

function explicitDomain(domain, spec, scope) {
  return domain.map(v => parseLiteral(v, scope));
}

function singularDomain(domain, spec, scope) {
  const data = scope.getData(domain.data);
  if (!data) dataLookupError(domain.data);
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isQuantile)(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);
}

function multipleDomain(domain, spec, scope) {
  const data = domain.data,
        fields = domain.fields.reduce((dom, d) => {
    d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(d) ? {
      data: data,
      field: d
    } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(d) || d.signal ? fieldRef(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return ((0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? ordinalMultipleDomain : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isQuantile)(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);
}

function fieldRef(data, scope) {
  const name = '_:vega:_' + FIELD_REF_ID++,
        coll = Collect({});

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data)) {
    coll.value = {
      $ingest: data
    };
  } else if (data.signal) {
    const code = 'setdata(' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name) + ',' + data.signal + ')';
    coll.params.input = scope.signalRef(code);
  }

  scope.addDataPipeline(name, [coll, Sieve({})]);
  return {
    data: name,
    field: 'data'
  };
}

function ordinalMultipleDomain(domain, scope, fields) {
  const sort = parseSort(domain.sort, true);
  let a, v; // get value counts for each domain field

  const counts = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.countsRef(scope, f.field, sort);
  }); // aggregate the results from each domain field

  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };

  if (sort) {
    a = sort.op || 'count';
    v = sort.field ? aggrField(a, sort.field) : 'count';
    p.ops = [MULTIDOMAIN_SORT_OPS[a]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }

  a = scope.add(Aggregate(p)); // collect aggregate output

  const c = scope.add(Collect({
    pulse: ref(a)
  })); // extract values for combined domain

  v = scope.add(Values({
    field: keyFieldRef,
    sort: scope.sortRef(sort),
    pulse: ref(c)
  }));
  return ref(v);
}

function parseSort(sort, multidomain) {
  if (sort) {
    if (!sort.field && !sort.op) {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sort)) sort.field = 'key';else sort = {
        field: 'key'
      };
    } else if (!sort.field && sort.op !== 'count') {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No field provided for sort aggregate op: ' + sort.op);
    } else if (multidomain && sort.field) {
      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Multiple domain scales can not be sorted using ' + sort.op);
      }
    }
  }

  return sort;
}

function quantileMultipleDomain(domain, scope, fields) {
  // get value arrays for each domain field
  const values = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.domainRef(scope, f.field);
  }); // combine value arrays

  return ref(scope.add(MultiValues({
    values: values
  })));
}

function numericMultipleDomain(domain, scope, fields) {
  // get extents for each domain field
  const extents = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.extentRef(scope, f.field);
  }); // combine extents

  return ref(scope.add(MultiExtent({
    extents: extents
  })));
} // -- SCALE BINS -----


function parseScaleBins(v, scope) {
  return v.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? parseArray(v, scope) : scope.objectProperty(v);
} // -- SCALE NICE -----


function parseScaleNice(nice) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(nice) ? {
    interval: parseLiteral(nice.interval),
    step: parseLiteral(nice.step)
  } : parseLiteral(nice);
} // -- SCALE INTERPOLATION -----


function parseScaleInterpolate(interpolate, params) {
  params.interpolate = parseLiteral(interpolate.type || interpolate);

  if (interpolate.gamma != null) {
    params.interpolateGamma = parseLiteral(interpolate.gamma);
  }
} // -- SCALE RANGE -----


function parseScaleRange(spec, scope, params) {
  const config = scope.config.range;
  let range = spec.range;

  if (range.signal) {
    return scope.signalRef(range.signal);
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(range)) {
    if (config && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(config, range)) {
      spec = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, spec, {
        range: config[range]
      });
      return parseScaleRange(spec, scope, params);
    } else if (range === 'width') {
      range = [0, {
        signal: 'width'
      }];
    } else if (range === 'height') {
      range = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? [0, {
        signal: 'height'
      }] : [{
        signal: 'height'
      }, 0];
    } else {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale range value: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(range));
    }
  } else if (range.scheme) {
    params.scheme = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);
    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);
    if (range.count) params.schemeCount = parseLiteral(range.count, scope);
    return;
  } else if (range.step) {
    params.rangeStep = parseLiteral(range.step, scope);
    return;
  } else if ((0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range)) {
    return parseScaleDomain(range, spec, scope);
  } else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported range type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(range));
  }

  return range.map(v => ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? parseArray : parseLiteral)(v, scope));
}

function parseProjection (proj, scope) {
  const config = scope.config.projection || {},
        params = {};

  for (const name in proj) {
    if (name === 'name') continue;
    params[name] = parseParameter$1(proj[name], name, scope);
  } // apply projection defaults from config


  for (const name in config) {
    if (params[name] == null) {
      params[name] = parseParameter$1(config[name], name, scope);
    }
  }

  scope.addProjection(proj.name, params);
}

function parseParameter$1(_, name, scope) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported parameter object: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(_));
}

const Top = 'top';
const Left = 'left';
const Right = 'right';
const Bottom = 'bottom';
const Center = 'center';
const Vertical = 'vertical';
const Start = 'start';
const Middle = 'middle';
const End = 'end';
const Index = 'index';
const Label = 'label';
const Offset = 'offset';
const Perc = 'perc';
const Perc2 = 'perc2';
const Value = 'value';
const GuideLabelStyle = 'guide-label';
const GuideTitleStyle = 'guide-title';
const GroupTitleStyle = 'group-title';
const GroupSubtitleStyle = 'group-subtitle';
const Symbols = 'symbol';
const Gradient = 'gradient';
const Discrete = 'discrete';
const Size = 'size';
const Shape = 'shape';
const Fill = 'fill';
const Stroke = 'stroke';
const StrokeWidth = 'strokeWidth';
const StrokeDash = 'strokeDash';
const Opacity = 'opacity'; // Encoding channels supported by legends
// In priority order of 'canonical' scale

const LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
const Skip = {
  name: 1,
  style: 1,
  interactive: 1
};
const zero = {
  value: 0
};
const one = {
  value: 1
};

const GroupMark = 'group';
const RectMark = 'rect';
const RuleMark = 'rule';
const SymbolMark = 'symbol';
const TextMark = 'text';

function guideGroup (mark) {
  mark.type = GroupMark;
  mark.interactive = mark.interactive || false;
  return mark;
}

function lookup(spec, config) {
  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));

  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));

  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);

  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);

  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));

  return _;
}
function getEncoding(name, encode) {
  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name, scope, style) {
  const s = scope.config.style[style];
  return s && s[name];
}
function anchorExpr(s, e, m) {
  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;
}
const alignExpr$1 = anchorExpr((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Left), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Right), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Center));
function tickBand(_) {
  const v = _('tickBand');

  let offset = _('tickOffset'),
      band,
      extra;

  if (!v) {
    // if no tick band entry, fall back on other properties
    band = _('bandPosition');
    extra = _('tickExtra');
  } else if (v.signal) {
    // if signal, augment code to interpret values
    band = {
      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`
    };
    extra = {
      signal: `(${v.signal}) === 'extent'`
    };

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(offset)) {
      offset = {
        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`
      };
    }
  } else if (v === 'extent') {
    // if constant, simply set values
    band = 1;
    extra = true;
    offset = 0;
  } else {
    band = 0.5;
    extra = false;
  }

  return {
    extra,
    band,
    offset
  };
}
function extendOffset(value, offset) {
  return !offset ? value : !value ? offset : !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? {
    value,
    offset
  } : Object.assign({}, value, {
    offset: extendOffset(value.offset, offset)
  });
}

function guideMark (mark, extras) {
  if (extras) {
    mark.name = extras.name;
    mark.style = extras.style || mark.style;
    mark.interactive = !!extras.interactive;
    mark.encode = extendEncode(mark.encode, extras, Skip);
  } else {
    mark.interactive = false;
  }

  return mark;
}

function legendGradient (spec, scale, config, userEncode) {
  const _ = lookup(spec, config),
        vertical = _.isVertical(),
        thickness = _.gradientThickness(),
        length = _.gradientLength();

  let enter, start, stop, width, height;

  if (vertical) {
    start = [0, 1];
    stop = [0, 0];
    width = thickness;
    height = length;
  } else {
    start = [0, 0];
    stop = [1, 0];
    width = length;
    height = thickness;
  }

  const encode = {
    enter: enter = {
      opacity: zero,
      x: zero,
      y: zero,
      width: encoder(width),
      height: encoder(height)
    },
    update: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one,
      fill: {
        gradient: scale,
        start: start,
        stop: stop
      }
    }),
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gradientStrokeColor'),
    strokeWidth: _('gradientStrokeWidth')
  }, {
    // update
    opacity: _('gradientOpacity')
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode
  }, userEncode);
}

function legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        vertical = _.isVertical(),
        thickness = _.gradientThickness(),
        length = _.gradientLength();

  let u,
      v,
      uu,
      vv,
      adjust = '';
  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');
  const enter = {
    opacity: zero,
    fill: {
      scale: scale,
      field: Value
    }
  };
  enter[u] = {
    signal: adjust + 'datum.' + Perc,
    mult: length
  };
  enter[v] = zero;
  enter[uu] = {
    signal: adjust + 'datum.' + Perc2,
    mult: length
  };
  enter[vv] = encoder(thickness);
  const encode = {
    enter: enter,
    update: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one
    }),
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gradientStrokeColor'),
    strokeWidth: _('gradientStrokeWidth')
  }, {
    // update
    opacity: _('gradientOpacity')
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

const alignExpr = `datum.${Perc}<=0?"${Left}":datum.${Perc}>=1?"${Right}":"${Center}"`,
      baselineExpr = `datum.${Perc}<=0?"${Bottom}":datum.${Perc}>=1?"${Top}":"${Middle}"`;
function legendGradientLabels (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        vertical = _.isVertical(),
        thickness = encoder(_.gradientThickness()),
        length = _.gradientLength();

  let overlap = _('labelOverlap'),
      enter,
      update,
      u,
      v,
      adjust = '';

  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one,
      text: {
        field: Label
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontStyle: _('labelFontStyle'),
    fontWeight: _('labelFontWeight'),
    limit: value(spec.labelLimit, config.gradientLabelLimit)
  });

  if (vertical) {
    enter.align = {
      value: 'left'
    };
    enter.baseline = update.baseline = {
      signal: baselineExpr
    };
    u = 'y';
    v = 'x';
    adjust = '1-';
  } else {
    enter.align = update.align = {
      signal: alignExpr
    };
    enter.baseline = {
      value: 'top'
    };
    u = 'x';
    v = 'y';
  }

  enter[u] = update[u] = {
    signal: adjust + 'datum.' + Perc,
    mult: length
  };
  enter[v] = update[v] = thickness;
  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _('labelSeparation'),
    method: overlap,
    order: 'datum.' + Index
  } : undefined; // type, role, style, key, dataRef, encode, extras

  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode,
    overlap
  }, userEncode);
}

function legendSymbolGroups (spec, config, userEncode, dataRef, columns) {
  const _ = lookup(spec, config),
        entries = userEncode.entries,
        interactive = !!(entries && entries.interactive),
        name = entries ? entries.name : undefined,
        height = _('clipHeight'),
        symbolOffset = _('symbolOffset'),
        valueRef = {
    data: 'value'
  },
        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,
        yEncode = height ? encoder(height) : {
    field: Size
  },
        index = `datum.${Index}`,
        ncols = `max(1, ${columns})`;

  let encode, enter, update, nrows, sort;
  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --

  encode = {
    enter: enter = {
      opacity: zero,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update = {
      opacity: one,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero
    }
  };
  let baseFill = null,
      baseStroke = null;

  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }

  addEncoders(encode, {
    fill: _('symbolFillColor', baseFill),
    shape: _('symbolType'),
    size: _('symbolSize'),
    stroke: _('symbolStrokeColor', baseStroke),
    strokeDash: _('symbolDash'),
    strokeDashOffset: _('symbolDashOffset'),
    strokeWidth: _('symbolStrokeWidth')
  }, {
    // update
    opacity: _('symbolOpacity')
  });
  LegendScales.forEach(scale => {
    if (spec[scale]) {
      update[scale] = enter[scale] = {
        scale: spec[scale],
        field: Value
      };
    }
  });
  const symbols = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height ? true : undefined,
    encode
  }, userEncode.symbols); // -- LEGEND LABELS --

  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _('labelOffset');
  encode = {
    enter: enter = {
      opacity: zero,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update = {
      opacity: one,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    align: _('labelAlign'),
    baseline: _('labelBaseline'),
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontStyle: _('labelFontStyle'),
    fontWeight: _('labelFontWeight'),
    limit: _('labelLimit')
  });
  const labels = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode
  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --

  encode = {
    enter: {
      noBound: {
        value: !height
      },
      // ignore width/height in bounds calc
      width: zero,
      height: height ? encoder(height) : zero,
      opacity: zero
    },
    exit: {
      opacity: zero
    },
    update: update = {
      opacity: one,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  }; // annotate and sort groups to ensure correct ordering

  if (_.isVertical(true)) {
    nrows = `ceil(item.mark.items.length / ${ncols})`;
    update.row.signal = `${index}%${nrows}`;
    update.column.signal = `floor(${index} / ${nrows})`;
    sort = {
      field: ['row', index]
    };
  } else {
    update.row.signal = `floor(${index} / ${ncols})`;
    update.column.signal = `${index} % ${ncols}`;
    sort = {
      field: index
    };
  } // handle zero column case (implies infinite columns)


  update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups

  dataRef = {
    facet: {
      data: dataRef,
      name: 'value',
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole,
    from: dataRef,
    encode: extendEncode(encode, entries, Skip),
    marks: [symbols, labels],
    name,
    interactive,
    sort
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup(spec, config); // layout parameters for legend entries


  return {
    align: _('gridAlign'),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _('rowPadding'),
      column: _('columnPadding')
    }
  };
}

const isL = 'item.orient === "left"',
      isR = 'item.orient === "right"',
      isLR = `(${isL} || ${isR})`,
      isVG = `datum.vgrad && ${isLR}`,
      baseline = anchorExpr('"top"', '"bottom"', '"middle"'),
      alignFlip = anchorExpr('"right"', '"left"', '"center"'),
      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`,
      exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`,
      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,
      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline}) : "top"`;
function legendTitle (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config);

  const encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: one,
      x: {
        field: {
          group: 'padding'
        }
      },
      y: {
        field: {
          group: 'padding'
        }
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    orient: _('titleOrient'),
    _anchor: _('titleAnchor'),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _('titleColor'),
    fillOpacity: _('titleOpacity'),
    font: _('titleFont'),
    fontSize: _('titleFontSize'),
    fontStyle: _('titleFontStyle'),
    fontWeight: _('titleFontWeight'),
    limit: _('titleLimit'),
    lineHeight: _('titleLineHeight')
  }, {
    // require update
    align: _('titleAlign'),
    baseline: _('titleBaseline')
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function clip (clip, scope) {
  let expr;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(clip)) {
    if (clip.signal) {
      expr = clip.signal;
    } else if (clip.path) {
      expr = 'pathShape(' + param(clip.path) + ')';
    } else if (clip.sphere) {
      expr = 'geoShape(' + param(clip.sphere) + ', {type: "Sphere"})';
    }
  }

  return expr ? scope.signalRef(expr) : !!clip;
}

function param(value) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && value.signal ? value.signal : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value);
}

function getRole (spec) {
  const role = spec.role || '';
  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;
}

function definition (spec) {
  return {
    marktype: spec.type,
    name: spec.name || undefined,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || undefined,
    aria: spec.aria,
    description: spec.description
  };
}

function interactive (spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}

/**
 * Parse a data transform specification.
 */

function parseTransform (spec, scope) {
  const def = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_4__.definition)(spec.type);
  if (!def) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized transform type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(spec.type));
  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));
  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));
  t.metadata = def.metadata || {};
  return t;
}
/**
 * Parse all parameters of a data transform.
 */

function parseParameters(def, spec, scope) {
  const params = {},
        n = def.params.length;

  for (let i = 0; i < n; ++i) {
    const pdef = def.params[i];
    params[pdef.name] = parseParameter(pdef, spec, scope);
  }

  return params;
}
/**
 * Parse a data transform parameter.
 */


function parseParameter(def, spec, scope) {
  const type = def.type,
        value = spec[def.name];

  if (type === 'index') {
    return parseIndexParameter(def, spec, scope);
  } else if (value === undefined) {
    if (def.required) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing required ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(spec.type) + ' parameter: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(def.name));
    }

    return;
  } else if (type === 'param') {
    return parseSubParameters(def, spec, scope);
  } else if (type === 'projection') {
    return scope.projectionRef(spec[def.name]);
  }

  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);
}
/**
 * Parse a single parameter value.
 */


function parameterValue(def, value, scope) {
  const type = def.type;

  if (isSignal(value)) {
    return isExpr(type) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);
  } else {
    const expr = def.expr || isField(type);
    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;
  }
}
/**
 * Parse parameter for accessing an index of another data set.
 */


function parseIndexParameter(def, spec, scope) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec.from)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Lookup "from" parameter must be a string literal.');
  }

  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
/**
 * Parse a parameter that contains one or more sub-parameter objects.
 */


function parseSubParameters(def, spec, scope) {
  const value = spec[def.name];

  if (def.array) {
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
      // signals not allowed!
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expected an array of sub-parameters. Instead: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
    }

    return value.map(v => parseSubParameter(def, v, scope));
  } else {
    return parseSubParameter(def, value, scope);
  }
}
/**
 * Parse a sub-parameter object.
 */


function parseSubParameter(def, value, scope) {
  const n = def.params.length;
  let pdef; // loop over defs to find matching key

  for (let i = 0; i < n; ++i) {
    pdef = def.params[i];

    for (const k in pdef.key) {
      if (pdef.key[k] !== value[k]) {
        pdef = null;
        break;
      }
    }

    if (pdef) break;
  } // raise error if matching key not found


  if (!pdef) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported parameter: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value)); // parse params, create Params transform, return ref

  const params = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(parseParameters(pdef, value, scope), pdef.key);
  return ref(scope.add(Params(params)));
} // -- Utilities -----


const outerExpr = _ => _ && _.expr;
const outerField = _ => _ && _.field;
const isData = _ => _ === 'data';
const isExpr = _ => _ === 'expr';
const isField = _ => _ === 'field';
const isCompare = _ => _ === 'compare';

function parseData$1 (from, group, scope) {
  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum

  if (!from) {
    dataRef = ref(scope.add(Collect(null, [{}])));
  } // if faceted, process facet specification
  else if (facet = from.facet) {
    if (!group) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Only group marks can be faceted.'); // use pre-faceted source data, if available

    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      // generate facet aggregates if no direct data specification
      if (!from.data) {
        op = parseTransform((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
          type: 'aggregate',
          groupby: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }

      key = scope.keyRef(facet.groupby, true);
    }
  } // if not yet defined, get source data reference


  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }

  return {
    key: key,
    pulse: dataRef,
    parent: parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}

function DataScope(scope, input, output, values, aggr) {
  this.scope = scope; // parent scope object

  this.input = input; // first operator in pipeline (tuple input)

  this.output = output; // last operator in pipeline (tuple output)

  this.values = values; // operator for accessing tuples (but not tuple flow)
  // last aggregate in transform pipeline

  this.aggregate = aggr; // lookup table of field indices

  this.index = {};
}

DataScope.fromEntries = function (scope, entries) {
  const n = entries.length,
        values = entries[n - 1],
        output = entries[n - 2];
  let input = entries[0],
      aggr = null,
      i = 1;

  if (input && input.type === 'load') {
    input = entries[1];
  } // add operator entries to this scope, wire up pulse chain


  scope.add(entries[0]);

  for (; i < n; ++i) {
    entries[i].params.pulse = ref(entries[i - 1]);
    scope.add(entries[i]);
    if (entries[i].type === 'aggregate') aggr = entries[i];
  }

  return new DataScope(scope, input, output, values, aggr);
};

function fieldKey(field) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field) ? field : null;
}

function addSortField(scope, p, sort) {
  const as = aggrField(sort.op, sort.field);
  let s;

  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as) return;
    }
  } else {
    p.ops = ['count'];
    p.fields = [null];
    p.as = ['count'];
  }

  if (sort.op) {
    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);
    p.fields.push(scope.fieldRef(sort.field));
    p.as.push(as);
  }
}

function cache(scope, ds, name, optype, field, counts, index) {
  const cache = ds[name] || (ds[name] = {}),
        sort = sortKey(counts);
  let k = fieldKey(field),
      v,
      op;

  if (k != null) {
    scope = ds.scope;
    k = k + (sort ? '|' + sort : '');
    v = cache[k];
  }

  if (!v) {
    const params = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field, counts)
    } : {
      field: scope.fieldRef(field),
      pulse: ref(ds.output)
    };
    if (sort) params.sort = scope.sortRef(counts);
    op = scope.add(entry(optype, undefined, params));
    if (index) ds.index[field] = op;
    v = ref(op);
    if (k != null) cache[k] = v;
  }

  return v;
}

DataScope.prototype = {
  countsRef(scope, field, sort) {
    const ds = this,
          cache = ds.counts || (ds.counts = {}),
          k = fieldKey(field);
    let v, a, p;

    if (k != null) {
      scope = ds.scope;
      v = cache[k];
    }

    if (!v) {
      p = {
        groupby: scope.fieldRef(field, 'key'),
        pulse: ref(ds.output)
      };
      if (sort && sort.field) addSortField(scope, p, sort);
      a = scope.add(Aggregate(p));
      v = scope.add(Collect({
        pulse: ref(a)
      }));
      v = {
        agg: a,
        ref: ref(v)
      };
      if (k != null) cache[k] = v;
    } else if (sort && sort.field) {
      addSortField(scope, v.agg.params, sort);
    }

    return v.ref;
  },

  tuplesRef() {
    return ref(this.values);
  },

  extentRef(scope, field) {
    return cache(scope, this, 'extent', 'extent', field, false);
  },

  domainRef(scope, field) {
    return cache(scope, this, 'domain', 'values', field, false);
  },

  valuesRef(scope, field, sort) {
    return cache(scope, this, 'vals', 'values', field, sort || true);
  },

  lookupRef(scope, field) {
    return cache(scope, this, 'lookup', 'tupleindex', field, false);
  },

  indataRef(scope, field) {
    return cache(scope, this, 'indata', 'tupleindex', field, true, true);
  }

};

function parseFacet (spec, scope, group) {
  const facet = spec.from.facet,
        name = facet.name,
        data = getDataRef(facet, scope);
  let op;

  if (!facet.name) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must have a name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  }

  if (!facet.data) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must reference a data set: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  }

  if (facet.field) {
    op = scope.add(PreFacet({
      field: scope.fieldRef(facet.field),
      pulse: data
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group.parent)),
      pulse: data
    }));
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must specify groupby or field: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  } // initialize facet subscope


  const subscope = scope.fork(),
        source = subscope.add(Collect()),
        values = subscope.add(Sieve({
    pulse: ref(source)
  }));
  subscope.addData(name, new DataScope(subscope, source, source, values));
  subscope.addSignal('parent', null); // parse faceted subflow

  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}

function parseSubflow (spec, scope, input) {
  const op = scope.add(PreFacet({
    pulse: input.pulse
  })),
        subscope = scope.fork();
  subscope.add(Sieve());
  subscope.addSignal('parent', null); // parse group mark subflow

  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}

function parseTrigger (spec, scope, name) {
  const remove = spec.remove,
        insert = spec.insert,
        toggle = spec.toggle,
        modify = spec.modify,
        values = spec.values,
        op = scope.add(operator());
  const update = 'if(' + spec.trigger + ',modify("' + name + '",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';
  const expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update, scope);
  op.update = expr.$expr;
  op.params = expr.$params;
}

function parseMark (spec, scope) {
  const role = getRole(spec),
        group = spec.type === GroupMark,
        facet = spec.from && spec.from.facet,
        overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole || role === FrameRole,
      ops,
      op,
      store,
      enc,
      name,
      layoutRef,
      boundRef;
  const nested = role === MarkRole || layout || facet; // resolve input data

  const input = parseData$1(spec.from, group, scope); // data join to map tuples to visual items

  op = scope.add(DataJoin({
    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),
    pulse: input.pulse,
    clean: !group
  }));
  const joinRef = ref(op); // collect visual items

  op = store = scope.add(Collect({
    pulse: joinRef
  })); // connect visual items to scenegraph

  op = scope.add(Mark({
    markdef: definition(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef('parent') : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op); // add visual encoders

  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  }))); // monitor parent marks to propagate changes

  op.params.parent = scope.encode(); // add post-encoding transforms, if defined

  if (spec.transform) {
    spec.transform.forEach(_ => {
      const tx = parseTransform(_, scope),
            md = tx.metadata;

      if (md.generates || md.changes) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Mark transforms should not generate new data.');
      }

      if (!md.nomod) enc.params.mod = true; // update encode mod handling

      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  } // if item sort specified, perform post-encoding


  if (spec.sort) {
    op = scope.add(SortItems({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }

  const encodeRef = ref(op); // add view layout operator if needed

  if (facet || layout) {
    layout = scope.add(ViewLayout({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  } // compute bounding boxes


  const bound = scope.add(Bound({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound); // if group mark, recurse to parse nested content

  if (group) {
    // juggle layout & bounds to ensure they run *after* any faceting transforms
    if (nested) {
      ops = scope.operators;
      ops.pop();
      if (layout) ops.pop();
    }

    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) // explicit facet
    : nested ? parseSubflow(spec, scope, input) // standard mark group
    : scope.parse(spec); // guide group, we can avoid nested scopes

    scope.popState();

    if (nested) {
      if (layout) ops.push(layout);
      ops.push(bound);
    }
  } // if requested, add overlap removal transform


  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  } // render / sieve items


  const render = scope.add(Render({
    pulse: boundRef
  })),
        sieve = scope.add(Sieve({
    pulse: ref(render)
  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry
  // add trigger updates if defined

  if (spec.name != null) {
    name = spec.name;
    scope.addData(name, new DataScope(scope, store, render, sieve));
    if (spec.on) spec.on.forEach(on => {
      if (on.insert || on.remove || on.toggle) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Marks only support modify triggers.');
      }

      parseTrigger(on, scope, name);
    });
  }
}

function parseOverlap(overlap, source, scope) {
  const method = overlap.method,
        bound = overlap.bound,
        sep = overlap.separation;
  const params = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method) ? scope.signalRef(method.signal) : method,
    pulse: source
  };

  if (overlap.order) {
    params.sort = scope.compareRef({
      field: overlap.order
    });
  }

  if (bound) {
    const tol = bound.tolerance;
    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params.boundScale = scope.scaleRef(bound.scale);
    params.boundOrient = bound.orient;
  }

  return ref(scope.add(Overlap(params)));
}

function parseLegend (spec, scope) {
  const config = scope.config.legend,
        encode = spec.encode || {},
        _ = lookup(spec, config),
        legendEncode = encode.legend || {},
        name = legendEncode.name || undefined,
        interactive = legendEncode.interactive,
        style = legendEncode.style,
        scales = {};

  let scale = 0,
      entryLayout,
      params,
      children; // resolve scales and 'canonical' scale name

  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);
  if (!scale) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)

  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group

  const datum = {
    title: spec.title != null,
    scales: scales,
    type: type,
    vgrad: type !== 'symbol' && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group

  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  }; // data source for legend values

  const entryRef = ref(scope.add(LegendEntries(params = {
    type: type,
    scale: scope.scaleRef(scale),
    count: scope.objectProperty(_('tickCount')),
    limit: scope.property(_('symbolLimit')),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  }))); // continuous gradient legend

  if (type === Gradient) {
    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length

    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
  } // discrete gradient legend
  else if (type === Discrete) {
    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];
  } // symbol legend
  else {
    // determine legend symbol group layout
    entryLayout = legendSymbolLayout(spec, config);
    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator

    params.size = sizeExpression(spec, scope, children[0].marks);
  } // generate legend marks


  children = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children,
    layout: entryLayout,
    interactive
  })]; // include legend title if defined

  if (datum.title) {
    children.push(legendTitle(spec, config, encode.title, dataRef));
  } // parse legend specification


  return parseMark(guideGroup({
    role: LegendRole,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
}

function legendType(spec, scaleType) {
  let type = spec.type || Symbols;

  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isContinuous)(scaleType) ? Gradient : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscretizing)(scaleType) ? Discrete : Symbols;
  }

  return type !== Gradient ? type : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscretizing)(scaleType) ? Discrete : Gradient;
}

function scaleCount(spec) {
  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);
}

function buildLegendEncode(_, spec, config) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    offset: _('offset'),
    padding: _('padding'),
    titlePadding: _('titlePadding'),
    cornerRadius: _('cornerRadius'),
    fill: _('fillColor'),
    stroke: _('strokeColor'),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _('legendX'),
    y: _('legendY'),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode;
}

function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel('size', spec, marks)),
        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),
        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);
}

function getChannel(name, spec, marks) {
  return spec[name] ? `scale("${spec[name]}",datum)` : getEncoding(name, marks[0].encode);
}

function getFontSize(encode, scope, style) {
  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);
}

const angleExpr = `item.orient==="${Left}"?-90:item.orient==="${Right}"?90:0`;
function parseTitle (spec, scope) {
  spec = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec) ? {
    text: spec
  } : spec;

  const _ = lookup(spec, scope.config.title),
        encode = spec.encode || {},
        userEncode = encode.group || {},
        name = userEncode.name || undefined,
        interactive = userEncode.interactive,
        style = userEncode.style,
        children = []; // single-element data source for group title


  const datum = {},
        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text

  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text

  if (spec.subtitle) {
    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));
  } // parse title specification


  return parseMark(guideGroup({
    role: TitleRole,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
} // provide backwards-compatibility for title custom encode;
// the top-level encode block has been *deprecated*.

function titleEncode(spec) {
  const encode = spec.encode;
  return encode && encode.title || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode);
}

function groupEncode(_, userEncode) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    anchor: _('anchor'),
    align: {
      signal: alignExpr$1
    },
    angle: {
      signal: angleExpr
    },
    limit: _('limit'),
    frame: _('frame'),
    offset: _('offset') || 0,
    padding: _('subtitlePadding')
  });
  return extendEncode(encode, userEncode, Skip);
}

function buildTitle(spec, _, userEncode, dataRef) {
  const zero = {
    value: 0
  },
        text = spec.text,
        encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    text: text,
    align: {
      signal: 'item.mark.group.align'
    },
    angle: {
      signal: 'item.mark.group.angle'
    },
    limit: {
      signal: 'item.mark.group.limit'
    },
    baseline: 'top',
    dx: _('dx'),
    dy: _('dy'),
    fill: _('color'),
    font: _('font'),
    fontSize: _('fontSize'),
    fontStyle: _('fontStyle'),
    fontWeight: _('fontWeight'),
    lineHeight: _('lineHeight')
  }, {
    // update
    align: _('align'),
    angle: _('angle'),
    baseline: _('baseline')
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero = {
    value: 0
  },
        text = spec.subtitle,
        encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    text: text,
    align: {
      signal: 'item.mark.group.align'
    },
    angle: {
      signal: 'item.mark.group.angle'
    },
    limit: {
      signal: 'item.mark.group.limit'
    },
    baseline: 'top',
    dx: _('dx'),
    dy: _('dy'),
    fill: _('subtitleColor'),
    font: _('subtitleFont'),
    fontSize: _('subtitleFontSize'),
    fontStyle: _('subtitleFontStyle'),
    fontWeight: _('subtitleFontWeight'),
    lineHeight: _('subtitleLineHeight')
  }, {
    // update
    align: _('align'),
    angle: _('angle'),
    baseline: _('baseline')
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function parseData(data, scope) {
  const transforms = [];

  if (data.transform) {
    data.transform.forEach(tx => {
      transforms.push(parseTransform(tx, scope));
    });
  }

  if (data.on) {
    data.on.forEach(on => {
      parseTrigger(on, scope, data.name);
    });
  }

  scope.addDataPipeline(data.name, analyze(data, scope, transforms));
}
/**
 * Analyze a data pipeline, add needed operators.
 */

function analyze(data, scope, ops) {
  const output = [];
  let source = null,
      modify = false,
      generate = false,
      upstream,
      i,
      n,
      t,
      m;

  if (data.values) {
    // hard-wired input data set
    if (isSignal(data.values) || hasSignal(data.format)) {
      // if either values is signal or format has signal, use dynamic loader
      output.push(load(scope, data));
      output.push(source = collect());
    } else {
      // otherwise, ingest upon dataflow init
      output.push(source = collect({
        $ingest: data.values,
        $format: data.format
      }));
    }
  } else if (data.url) {
    // load data from external source
    if (hasSignal(data.url) || hasSignal(data.format)) {
      // if either url or format has signal, use dynamic loader
      output.push(load(scope, data));
      output.push(source = collect());
    } else {
      // otherwise, request load upon dataflow init
      output.push(source = collect({
        $request: data.url,
        $format: data.format
      }));
    }
  } else if (data.source) {
    // derives from one or more other data sets
    source = upstream = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(data.source).map(d => ref(scope.getData(d).output));
    output.push(null); // populate later
  } // scan data transforms, add collectors as needed


  for (i = 0, n = ops.length; i < n; ++i) {
    t = ops[i];
    m = t.metadata;

    if (!source && !m.source) {
      output.push(source = collect());
    }

    output.push(t);
    if (m.generates) generate = true;
    if (m.modifies && !generate) modify = true;
    if (m.source) source = t;else if (m.changes) source = null;
  }

  if (upstream) {
    n = upstream.length - 1;
    output[0] = Relay({
      derive: modify,
      pulse: n ? upstream : upstream[0]
    });

    if (modify || n) {
      // collect derived and multi-pulse tuples
      output.splice(1, 0, collect());
    }
  }

  if (!source) output.push(collect());
  output.push(Sieve({}));
  return output;
}

function collect(values) {
  const s = Collect({}, values);
  s.metadata = {
    source: true
  };
  return s;
}

function load(scope, data) {
  return Load({
    url: data.url ? scope.property(data.url) : undefined,
    async: data.async ? scope.property(data.async) : undefined,
    values: data.values ? scope.property(data.values) : undefined,
    format: scope.objectProperty(data.format)
  });
}

const isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient


const getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction

const ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction

const ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;
const ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {
  value: a
} : {
  value: b
};
const ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {
  value: a
} : {
  value: b
};

const ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);

const ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);

const ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);

const ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);

const ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);

const ifEnc = (test, a, b) => {
  // ensure inputs are encoder objects (or null)
  a = a != null ? encoder(a) : a;
  b = b != null ? encoder(b) : b;

  if (isSimple(a) && isSimple(b)) {
    // if possible generate simple signal expression
    a = a ? a.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(a.value) : null;
    b = b ? b.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(b.value) : null;
    return {
      signal: `${test} ? (${a}) : (${b})`
    };
  } else {
    // otherwise generate rule set
    return [(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      test
    }, a)].concat(b || []);
  }
};

const isSimple = enc => enc == null || Object.keys(enc).length === 1;

const ifExpr = (test, a, b) => ({
  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`
});

const ifOrient = ($orient, t, b, l, r) => ({
  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'
});

const toExpr = v => isSignal(v) ? v.signal : v == null ? null : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(v);

const mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {
  signal: `(${sign.signal}) * ${value}`
} : {
  value: sign * value
};
const patch = (value, base) => {
  const s = value.signal;
  return s && s.endsWith('(null)') ? {
    signal: s.slice(0, -6) + base.signal
  } : value;
};

function fallback(prop, config, axisConfig, style) {
  let styleProp;

  if (config && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(config, prop)) {
    return config[prop];
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(axisConfig, prop)) {
    return axisConfig[prop];
  } else if (prop.startsWith('title')) {
    switch (prop) {
      case 'titleColor':
        styleProp = 'fill';
        break;

      case 'titleFont':
      case 'titleFontSize':
      case 'titleFontWeight':
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }

    return style[GuideTitleStyle][styleProp];
  } else if (prop.startsWith('label')) {
    switch (prop) {
      case 'labelColor':
        styleProp = 'fill';
        break;

      case 'labelFont':
      case 'labelFontSize':
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }

    return style[GuideLabelStyle][styleProp];
  }

  return null;
}

function keys(objects) {
  const map = {};

  for (const obj of objects) {
    if (!obj) continue;

    for (const key in obj) map[key] = 1;
  }

  return Object.keys(map);
}

function axisConfig (spec, scope) {
  var config = scope.config,
      style = config.style,
      axis = config.axis,
      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,
      orient = spec.orient,
      xy,
      or,
      key;

  if (isSignal(orient)) {
    const xyKeys = keys([config.axisX, config.axisY]),
          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};

    for (key of xyKeys) {
      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));
    }

    or = {};

    for (key of orientKeys) {
      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));
    }
  } else {
    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;
    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];
  }

  const result = xy || or || band ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, axis, xy, or, band) : axis;
  return result;
}

function axisDomain (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        orient = spec.orient;

  let enter, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('domainColor'),
    strokeCap: _('domainCap'),
    strokeDash: _('domainDash'),
    strokeDashOffset: _('domainDashOffset'),
    strokeWidth: _('domainWidth'),
    strokeOpacity: _('domainOpacity')
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update.x = ifX(orient, pos0, zero);
  enter.x2 = update.x2 = ifX(orient, pos1);
  enter.y = update.y = ifY(orient, pos0, zero);
  enter.y2 = update.y2 = ifY(orient, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode
  }, userEncode);
}

function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}

function axisGrid (spec, config, userEncode, dataRef, band) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        vscale = spec.gridScale,
        sign = getSign(orient, 1, -1),
        offset = offsetValue(spec.offset, sign);

  let enter, exit, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: exit = {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gridColor'),
    strokeCap: _('gridCap'),
    strokeDash: _('gridDash'),
    strokeDashOffset: _('gridDashOffset'),
    strokeOpacity: _('gridOpacity'),
    strokeWidth: _('gridWidth')
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band.band,
    extra: band.extra,
    offset: band.offset,
    round: _('tickRound')
  };
  const sz = ifX(orient, {
    signal: 'height'
  }, {
    signal: 'width'
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign,
    offset: offset
  } : {
    value: 0,
    offset: offset
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign,
    offset: offset
  } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(sz, {
    mult: sign,
    offset: offset
  });
  enter.x = update.x = ifX(orient, tickPos, gridStart);
  enter.y = update.y = ifY(orient, tickPos, gridStart);
  enter.x2 = update.x2 = ifY(orient, gridEnd);
  enter.y2 = update.y2 = ifX(orient, gridEnd);
  exit.x = ifX(orient, tickPos);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

function offsetValue(offset, sign) {
  if (sign === 1) ; else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(offset)) {
    offset = isSignal(sign) ? {
      signal: `(${sign.signal}) * (${offset || 0})`
    } : sign * (offset || 0);
  } else {
    let entry = offset = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, offset);

    while (entry.mult != null) {
      if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(entry.mult)) {
        entry.mult = isSignal(sign) // no offset if sign === 1
        ? {
          signal: `(${entry.mult}) * (${sign.signal})`
        } : entry.mult * sign;
        return offset;
      } else {
        entry = entry.mult = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, entry.mult);
      }
    }

    entry.mult = sign;
  }

  return offset;
}

function axisTicks (spec, config, userEncode, dataRef, size, band) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        sign = getSign(orient, -1, 1);

  let enter, exit, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: exit = {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('tickColor'),
    strokeCap: _('tickCap'),
    strokeDash: _('tickDash'),
    strokeDashOffset: _('tickDashOffset'),
    strokeOpacity: _('tickOpacity'),
    strokeWidth: _('tickWidth')
  });
  const tickSize = encoder(size);
  tickSize.mult = sign;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band.band,
    extra: band.extra,
    offset: band.offset,
    round: _('tickRound')
  };
  update.y = enter.y = ifX(orient, zero, tickPos);
  update.y2 = enter.y2 = ifX(orient, tickSize);
  exit.x = ifX(orient, tickPos);
  update.x = enter.x = ifY(orient, zero, tickPos);
  update.x2 = enter.x2 = ifY(orient, tickSize);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

function flushExpr(scale, threshold, a, b, c) {
  return {
    signal: 'flush(range("' + scale + '"), ' + 'scale("' + scale + '", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'
  };
}

function axisLabels (spec, config, userEncode, dataRef, size, band) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        scale = spec.scale,
        sign = getSign(orient, -1, 1),
        flush = deref(_('labelFlush')),
        flushOffset = deref(_('labelFlushOffset')),
        labelAlign = _('labelAlign'),
        labelBaseline = _('labelBaseline');

  let flushOn = flush === 0 || !!flush,
      update;
  const tickSize = encoder(size);
  tickSize.mult = sign;
  tickSize.offset = encoder(_('labelPadding') || 0);
  tickSize.offset.mult = sign;
  const tickPos = {
    scale: scale,
    field: Value,
    band: 0.5,
    offset: extendOffset(band.offset, _('labelOffset'))
  };
  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '"left"', '"right"', '"center"') : {
    value: 'center'
  }, ifRight(orient, 'left', 'right'));
  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '"top"', '"bottom"', '"middle"') : {
    value: 'middle'
  });
  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero,
    x: ifX(orient, tickPos, tickSize),
    y: ifY(orient, tickPos, tickSize)
  };
  const encode = {
    enter: enter,
    update: update = {
      opacity: one,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y,
      align,
      baseline
    },
    exit: {
      opacity: zero,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode, {
    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null
  });
  addEncoders(encode, {
    angle: _('labelAngle'),
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontWeight: _('labelFontWeight'),
    fontStyle: _('labelFontStyle'),
    limit: _('labelLimit'),
    lineHeight: _('labelLineHeight')
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });

  const bound = _('labelBound');

  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal


  overlap = overlap || bound ? {
    separation: _('labelSeparation'),
    method: overlap,
    order: 'datum.index',
    bound: bound ? {
      scale,
      orient,
      tolerance: bound
    } : null
  } : undefined;

  if (update.align !== align) {
    update.align = patch(update.align, align);
  }

  if (update.baseline !== baseline) {
    update.baseline = patch(update.baseline, baseline);
  }

  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode,
    overlap
  }, userEncode);
}

function axisTitle (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        sign = getSign(orient, -1, 1);

  let enter, update;
  const encode = {
    enter: enter = {
      opacity: zero,
      anchor: encoder(_('titleAnchor', null)),
      align: {
        signal: alignExpr$1
      }
    },
    update: update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero
    }
  };
  const titlePos = {
    signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
  };
  update.x = ifX(orient, titlePos);
  update.y = ifY(orient, titlePos);
  enter.angle = ifX(orient, zero, mult(sign, 90));
  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {
    value: Bottom
  });
  update.angle = enter.angle;
  update.baseline = enter.baseline;
  addEncoders(encode, {
    fill: _('titleColor'),
    fillOpacity: _('titleOpacity'),
    font: _('titleFont'),
    fontSize: _('titleFontSize'),
    fontStyle: _('titleFontStyle'),
    fontWeight: _('titleFontWeight'),
    limit: _('titleLimit'),
    lineHeight: _('titleLineHeight')
  }, {
    // require update
    align: _('titleAlign'),
    angle: _('titleAngle'),
    baseline: _('titleBaseline')
  });
  autoLayout(_, orient, encode, userEncode);
  encode.update.align = patch(encode.update.align, enter.align);
  encode.update.angle = patch(encode.update.angle, enter.angle);
  encode.update.baseline = patch(encode.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function autoLayout(_, orient, encode, userEncode) {
  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;

  const autoY = auto(_('titleX'), 'x'),
        autoX = auto(_('titleY'), 'y');
  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));
}

function parseAxis (spec, scope) {
  const config = axisConfig(spec, scope),
        encode = spec.encode || {},
        axisEncode = encode.axis || {},
        name = axisEncode.name || undefined,
        interactive = axisEncode.interactive,
        style = axisEncode.style,
        _ = lookup(spec, config),
        band = tickBand(_); // single-element data source for axis group


  const datum = {
    scale: spec.scale,
    ticks: !!_('ticks'),
    labels: !!_('labels'),
    grid: !!_('grid'),
    domain: !!_('domain'),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks

  const ticksRef = ref(scope.add(AxisTicks({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  }))); // generate axis marks

  const children = [];
  let size; // include axis gridlines if requested

  if (datum.grid) {
    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));
  } // include axis ticks if requested


  if (datum.ticks) {
    size = _('tickSize');
    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));
  } // include axis labels if requested


  if (datum.labels) {
    size = datum.ticks ? size : 0;
    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));
  } // include axis domain path if requested


  if (datum.domain) {
    children.push(axisDomain(spec, config, encode.domain, dataRef));
  } // include axis title if defined


  if (datum.title) {
    children.push(axisTitle(spec, config, encode.title, dataRef));
  } // parse axis specification


  return parseMark(guideGroup({
    role: AxisRole,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
}

function buildAxisEncode(_, spec) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    offset: _('offset') || 0,
    position: value(spec.position, 0),
    titlePadding: _('titlePadding'),
    minExtent: _('minExtent'),
    maxExtent: _('maxExtent'),
    range: {
      signal: `abs(span(range("${spec.scale}")))`
    },
    translate: _('translate'),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode;
}

function parseScope (spec, scope, preprocessed) {
  const signals = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.signals),
        scales = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.scales); // parse signal definitions, if not already preprocessed

  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references

  scales.forEach(_ => initScale(_, scope)); // parse data sources

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.data).forEach(_ => parseData(_, scope)); // parse scale definitions

  scales.forEach(_ => parseScale(_, scope)); // parse signal updates

  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined

  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions

  scope.parseLambdas();
  return scope;
}

const rootEncode = spec => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: 'width'
    },
    height: {
      signal: 'height'
    }
  }
}, spec);

function parseView(spec, scope) {
  const config = scope.config; // add scenegraph root

  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions

  const signals = collectSignals(spec, config);
  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration

  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale; // store root group item

  const input = scope.add(Collect()); // encode root group item

  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {
    pulse: ref(input)
  }))); // perform view layout

  const parent = scope.add(ViewLayout({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef('autosize'),
    mark: root,
    pulse: ref(encode)
  }));
  scope.operators.pop(); // parse remainder of specification

  scope.pushState(ref(encode), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent); // bound / render / sieve root item

  let op = scope.add(Bound({
    mark: root,
    pulse: ref(parent)
  }));
  op = scope.add(Render({
    pulse: ref(op)
  }));
  op = scope.add(Sieve({
    pulse: ref(op)
  })); // track metadata for root item

  scope.addData('root', new DataScope(scope, input, input, op));
  return scope;
}

function signalObject(name, value) {
  return value && value.signal ? {
    name,
    update: value.signal
  } : {
    name,
    value
  };
}
/**
 * Collect top-level signals, merging values as needed. Signals
 * defined in the config signals arrays are added only if that
 * signal is not explicitly defined in the specification.
 * Built-in signals (autosize, background, padding, width, height)
 * receive special treatment. They are initialized using the
 * top-level spec property, or, if undefined in the spec, using
 * the corresponding top-level config property. If this property
 * is a signal reference object, the signal expression maps to the
 * signal 'update' property. If the spec's top-level signal array
 * contains an entry that matches a built-in signal, that entry
 * will be merged with the built-in specification, potentially
 * overwriting existing 'value' or 'update' properties.
 */


function collectSignals(spec, config) {
  const _ = name => value(spec[name], config[name]),
        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],
        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),
        map = {}; // add spec signal array


  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.signals).forEach(s => {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(pre, s.name)) {
      // merge if built-in signal
      s = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(pre[s.name], s);
    } else {
      // otherwise add to signal list
      signals.push(s);
    }

    map[s.name] = s;
  }); // add config signal array

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(config.signals).forEach(s => {
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(map, s.name) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(pre, s.name)) {
      // add to signal list if not already defined
      signals.push(s);
    }
  });
  return signals;
}

function Scope(config, options) {
  this.config = config || {};
  this.options = options || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}

function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}

Scope.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },

  fork() {
    return new Subscope(this);
  },

  isSubscope() {
    return this._subid > 0;
  },

  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },

  id() {
    return (this._subid ? this._subid + ':' : 0) + this._id++;
  },

  add(op) {
    this.operators.push(op);
    op.id = this.id(); // if pre-registration references exist, resolve them now

    if (op.refs) {
      op.refs.forEach(ref => {
        ref.$ref = op.id;
      });
      op.refs = null;
    }

    return op;
  },

  proxy(op) {
    const vref = op instanceof Entry ? ref(op) : op;
    return this.add(Proxy({
      value: vref
    }));
  },

  addStream(stream) {
    this.streams.push(stream);
    stream.id = this.id();
    return stream;
  },

  addUpdate(update) {
    this.updates.push(update);
    return update;
  },

  // Apply metadata
  finish() {
    let name, ds; // annotate root

    if (this.root) this.root.root = true; // annotate signals

    for (name in this.signals) {
      this.signals[name].signal = name;
    } // annotate scales


    for (name in this.scales) {
      this.scales[name].scale = name;
    } // annotate data sets


    function annotate(op, name, type) {
      let data, list;

      if (op) {
        data = op.data || (op.data = {});
        list = data[name] || (data[name] = []);
        list.push(type);
      }
    }

    for (name in this.data) {
      ds = this.data[name];
      annotate(ds.input, name, 'input');
      annotate(ds.output, name, 'output');
      annotate(ds.values, name, 'values');

      for (const field in ds.index) {
        annotate(ds.index[field], name, 'index:' + field);
      }
    }

    return this;
  },

  // ----
  pushState(encode, parent, lookup) {
    this._encode.push(ref(this.add(Sieve({
      pulse: encode
    }))));

    this._parent.push(parent);

    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);

    this._markpath.push(-1);
  },

  popState() {
    this._encode.pop();

    this._parent.pop();

    this._lookup.pop();

    this._markpath.pop();
  },

  parent() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._parent);
  },

  encode() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._encode);
  },

  lookup() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._lookup);
  },

  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },

  // ----
  fieldRef(field, name) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field)) return fieldRef$1(field, name);

    if (!field.signal) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported field reference: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(field));
    }

    const s = field.signal;
    let f = this.field[s];

    if (!f) {
      const params = {
        name: this.signalRef(s)
      };
      if (name) params.as = name;
      this.field[s] = f = ref(this.add(Field(params)));
    }

    return f;
  },

  compareRef(cmp) {
    let signal = false;

    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;

    const fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(cmp.field).map(check),
          orders = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(cmp.order).map(check);
    return signal ? ref(this.add(Compare({
      fields: fields,
      orders: orders
    }))) : compareRef(fields, orders);
  },

  keyRef(fields, flat) {
    let signal = false;

    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;

    const sig = this.signals;
    fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(fields).map(check);
    return signal ? ref(this.add(Key({
      fields: fields,
      flat: flat
    }))) : keyRef(fields, flat);
  },

  sortRef(sort) {
    if (!sort) return sort; // including id ensures stable sorting

    const a = aggrField(sort.op, sort.field),
          o = sort.order || Ascending;
    return o.signal ? ref(this.add(Compare({
      fields: a,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a, o);
  },

  // ----
  event(source, type) {
    const key = source + ':' + type;

    if (!this.events[key]) {
      const id = this.id();
      this.streams.push({
        id: id,
        source: source,
        type: type
      });
      this.events[key] = id;
    }

    return this.events[key];
  },

  // ----
  hasOwnSignal(name) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.signals, name);
  },

  addSignal(name, value) {
    if (this.hasOwnSignal(name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    const op = value instanceof Entry ? value : this.add(operator(value));
    return this.signals[name] = op;
  },

  getSignal(name) {
    if (!this.signals[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.signals[name];
  },

  signalRef(s) {
    if (this.signals[s]) {
      return ref(this.signals[s]);
    } else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.lambdas, s)) {
      this.lambdas[s] = this.add(operator(null));
    }

    return ref(this.lambdas[s]);
  },

  parseLambdas() {
    const code = Object.keys(this.lambdas);

    for (let i = 0, n = code.length; i < n; ++i) {
      const s = code[i],
            e = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(s, this),
            op = this.lambdas[s];
      op.params = e.$params;
      op.update = e.$expr;
    }
  },

  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },

  objectProperty(spec) {
    return !spec || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },

  exprRef(code, name) {
    const params = {
      expr: (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(code, this)
    };
    if (name) params.expr.$name = name;
    return ref(this.add(Expression(params)));
  },

  addBinding(name, bind) {
    if (!this.bindings) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Nested signals do not support binding: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    this.bindings.push((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      signal: name
    }, bind));
  },

  // ----
  addScaleProj(name, transform) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.scales, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate scale or projection name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    this.scales[name] = this.add(transform);
  },

  addScale(name, params) {
    this.addScaleProj(name, Scale(params));
  },

  addProjection(name, params) {
    this.addScaleProj(name, Projection(params));
  },

  getScale(name) {
    if (!this.scales[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.scales[name];
  },

  scaleRef(name) {
    return ref(this.getScale(name));
  },

  scaleType(name) {
    return this.getScale(name).params.type;
  },

  projectionRef(name) {
    return this.scaleRef(name);
  },

  projectionType(name) {
    return this.scaleType(name);
  },

  // ----
  addData(name, dataScope) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.data, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.data[name] = dataScope;
  },

  getData(name) {
    if (!this.data[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Undefined data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.data[name];
  },

  addDataPipeline(name, entries) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.data, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.addData(name, DataScope.fromEntries(this, entries));
  }

};

function propertyLambda(spec) {
  return ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(spec) ? arrayLambda : objectLambda)(spec);
}

function arrayLambda(array) {
  const n = array.length;
  let code = '[';

  for (let i = 0; i < n; ++i) {
    const value = array[i];
    code += (i > 0 ? ',' : '') + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? value.signal || propertyLambda(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
  }

  return code + ']';
}

function objectLambda(obj) {
  let code = '{',
      i = 0,
      key,
      value;

  for (key in obj) {
    value = obj[key];
    code += (++i > 1 ? ',' : '') + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(key) + ':' + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? value.signal || propertyLambda(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
  }

  return code + '}';
}

/**
 * Standard configuration defaults for Vega specification parsing.
 * Users can provide their own (sub-)set of these default values
 * by passing in a config object to the top-level parse method.
 */
function defaults () {
  const defaultFont = 'sans-serif',
        defaultSymbolSize = 30,
        defaultStrokeWidth = 2,
        defaultColor = '#4c78a8',
        black = '#000',
        gray = '#888',
        lightGray = '#ddd';
  return {
    // default visualization description
    description: 'Vega visualization',
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: 'pad',
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ['wheel']
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    // style definitions
    style: {
      // axis & legend labels
      'guide-label': {
        fill: black,
        font: defaultFont,
        fontSize: 10
      },
      // axis & legend titles
      'guide-title': {
        fill: black,
        font: defaultFont,
        fontSize: 11,
        fontWeight: 'bold'
      },
      // headers, including chart title
      'group-title': {
        fill: black,
        font: defaultFont,
        fontSize: 13,
        fontWeight: 'bold'
      },
      // chart subtitle
      'group-subtitle': {
        fill: black,
        font: defaultFont,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: 'circle'
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: 'square'
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: 'transparent',
        stroke: lightGray
      }
    },
    // defaults for title
    title: {
      orient: 'top',
      anchor: 'middle',
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: 'mercator'
    },
    // defaults for legends
    legend: {
      orient: 'right',
      padding: 0,
      gridAlign: 'each',
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: 'vertical',
      gradientDirection: 'vertical',
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: 'left',
      labelBaseline: 'middle',
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: 'circle',
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: 'transparent',
      symbolBaseStrokeColor: gray,
      titleLimit: 180,
      titleOrient: 'top',
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: 'horizontal',
        left: {
          direction: 'vertical'
        },
        right: {
          direction: 'vertical'
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: 'tableau10'
      },
      ordinal: {
        scheme: 'blues'
      },
      heatmap: {
        scheme: 'yellowgreenblue'
      },
      ramp: {
        scheme: 'blues'
      },
      diverging: {
        scheme: 'blueorange',
        extent: [1, 0]
      },
      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']
    }
  };
}

function parse (spec, config, options) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Input Vega specification must be an object.');
  }

  config = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.mergeConfig)(defaults(), config, spec.config);
  return parseView(spec, new Scope(config, options)).toRuntime();
}




/***/ }),

/***/ "../../node_modules/vega-projection/build/vega-projection.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-projection/build/vega-projection.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getProjectionPath": () => (/* binding */ getProjectionPath),
/* harmony export */   "projection": () => (/* binding */ projection),
/* harmony export */   "projectionProperties": () => (/* binding */ projectionProperties)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/path/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/albersUsa.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/conicConformal.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/conicEquidistant.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/equalEarth.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/equirectangular.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/gnomonic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/identity.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/mercator.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/naturalEarth1.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/orthographic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/stereographic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/transverseMercator.js");
/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-geo-projection */ "../../node_modules/vega-projection/node_modules/d3-geo-projection/src/mollweide.js");



const defaultPath = (0,d3_geo__WEBPACK_IMPORTED_MODULE_0__.default)();
const projectionProperties = [// standard properties in d3-geo
'clipAngle', 'clipExtent', 'scale', 'translate', 'center', 'rotate', 'parallels', 'precision', 'reflectX', 'reflectY', // extended properties in d3-geo-projections
'coefficient', 'distance', 'fraction', 'lobes', 'parallel', 'radius', 'ratio', 'spacing', 'tilt'];
/**
 * Augment projections with their type and a copy method.
 */

function create(type, constructor) {
  return function projection() {
    const p = constructor();
    p.type = type;
    p.path = (0,d3_geo__WEBPACK_IMPORTED_MODULE_0__.default)().projection(p);

    p.copy = p.copy || function () {
      const c = projection();
      projectionProperties.forEach(prop => {
        if (p[prop]) c[prop](p[prop]());
      });
      c.path.pointRadius(p.path.pointRadius());
      return c;
    };

    return p;
  };
}

function projection(type, proj) {
  if (!type || typeof type !== 'string') {
    throw new Error('Projection type must be a name string.');
  }

  type = type.toLowerCase();

  if (arguments.length > 1) {
    projections[type] = create(type, proj);
    return this;
  } else {
    return projections[type] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
const projections = {
  // base d3-geo projection types
  albers: d3_geo__WEBPACK_IMPORTED_MODULE_1__.default,
  albersusa: d3_geo__WEBPACK_IMPORTED_MODULE_2__.default,
  azimuthalequalarea: d3_geo__WEBPACK_IMPORTED_MODULE_3__.default,
  azimuthalequidistant: d3_geo__WEBPACK_IMPORTED_MODULE_4__.default,
  conicconformal: d3_geo__WEBPACK_IMPORTED_MODULE_5__.default,
  conicequalarea: d3_geo__WEBPACK_IMPORTED_MODULE_6__.default,
  conicequidistant: d3_geo__WEBPACK_IMPORTED_MODULE_7__.default,
  equalEarth: d3_geo__WEBPACK_IMPORTED_MODULE_8__.default,
  equirectangular: d3_geo__WEBPACK_IMPORTED_MODULE_9__.default,
  gnomonic: d3_geo__WEBPACK_IMPORTED_MODULE_10__.default,
  identity: d3_geo__WEBPACK_IMPORTED_MODULE_11__.default,
  mercator: d3_geo__WEBPACK_IMPORTED_MODULE_12__.default,
  mollweide: d3_geo_projection__WEBPACK_IMPORTED_MODULE_13__.default,
  naturalEarth1: d3_geo__WEBPACK_IMPORTED_MODULE_14__.default,
  orthographic: d3_geo__WEBPACK_IMPORTED_MODULE_15__.default,
  stereographic: d3_geo__WEBPACK_IMPORTED_MODULE_16__.default,
  transversemercator: d3_geo__WEBPACK_IMPORTED_MODULE_17__.default
};

for (const key in projections) {
  projection(key, projections[key]);
}




/***/ }),

/***/ "../../node_modules/vega-projection/node_modules/d3-geo-projection/src/math.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/vega-projection/node_modules/d3-geo-projection/src/math.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "atan": () => (/* binding */ atan),
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "exp": () => (/* binding */ exp),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "pow": () => (/* binding */ pow),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "sign": () => (/* binding */ sign),
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "tan": () => (/* binding */ tan),
/* harmony export */   "epsilon": () => (/* binding */ epsilon),
/* harmony export */   "epsilon2": () => (/* binding */ epsilon2),
/* harmony export */   "pi": () => (/* binding */ pi),
/* harmony export */   "halfPi": () => (/* binding */ halfPi),
/* harmony export */   "quarterPi": () => (/* binding */ quarterPi),
/* harmony export */   "sqrt1_2": () => (/* binding */ sqrt1_2),
/* harmony export */   "sqrt2": () => (/* binding */ sqrt2),
/* harmony export */   "sqrtPi": () => (/* binding */ sqrtPi),
/* harmony export */   "tau": () => (/* binding */ tau),
/* harmony export */   "degrees": () => (/* binding */ degrees),
/* harmony export */   "radians": () => (/* binding */ radians),
/* harmony export */   "sinci": () => (/* binding */ sinci),
/* harmony export */   "asin": () => (/* binding */ asin),
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "tanh": () => (/* binding */ tanh),
/* harmony export */   "sinh": () => (/* binding */ sinh),
/* harmony export */   "cosh": () => (/* binding */ cosh),
/* harmony export */   "arsinh": () => (/* binding */ arsinh),
/* harmony export */   "arcosh": () => (/* binding */ arcosh)
/* harmony export */ });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sin = Math.sin;
var tan = Math.tan;

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;

function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}

function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}

function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}

function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}

function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}

function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}


/***/ }),

/***/ "../../node_modules/vega-projection/node_modules/d3-geo-projection/src/mollweide.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/vega-projection/node_modules/d3-geo-projection/src/mollweide.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mollweideBromleyTheta": () => (/* binding */ mollweideBromleyTheta),
/* harmony export */   "mollweideBromleyRaw": () => (/* binding */ mollweideBromleyRaw),
/* harmony export */   "mollweideRaw": () => (/* binding */ mollweideRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/vega-projection/node_modules/d3-geo-projection/src/math.js");



function mollweideBromleyTheta(cp, phi) {
  var cpsinPhi = cp * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi), i = 30, delta;
  do phi -= delta = (phi + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi) - cpsinPhi) / (1 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi));
  while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && --i > 0);
  return phi / 2;
}

function mollweideBromleyRaw(cx, cy, cp) {

  function forward(lambda, phi) {
    return [cx * lambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi = mollweideBromleyTheta(cp, phi)), cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
  }

  forward.invert = function(x, y) {
    return y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(y / cy), [x / (cx * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y)), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((2 * y + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(2 * y)) / cp)];
  };

  return forward;
}

var mollweideRaw = mollweideBromleyRaw(_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt2 / _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi, _math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt2, _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__.default)(mollweideRaw)
      .scale(169.529);
}


/***/ }),

/***/ "../../node_modules/vega-regression/build/vega-regression.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-regression/build/vega-regression.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loess": () => (/* binding */ Loess),
/* harmony export */   "regression": () => (/* binding */ Regression)
/* harmony export */ });
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");




function partition (data, groupby) {
  var groups = [],
      get = function (f) {
    return f(t);
  },
      map,
      i,
      n,
      t,
      k,
      g; // partition data points into stack groups


  if (groupby == null) {
    groups.push(data);
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }

      g.push(t);
    }
  }

  return groups;
}

/**
 * Compute locally-weighted regression fits for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.x - An accessor for the predictor data field.
 * @param {function(object): *} params.y - An accessor for the predicted data field.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {number} [params.bandwidth=0.3] - The loess bandwidth.
 */

function Loess(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Loess.Definition = {
  'type': 'Loess',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0.3
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Loess, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
            groups = partition(source, _.groupby),
            names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName),
            m = names.length,
            as = _.as || [(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.x), (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.y)],
            values = [];
      groups.forEach(g => {
        (0,vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLoess)(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {
          const t = {};

          for (let i = 0; i < m; ++i) {
            t[names[i]] = g.dims[i];
          }

          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});

const Methods = {
  linear: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLinear,
  log: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLog,
  exp: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionExp,
  pow: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionPow,
  quad: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionQuad,
  poly: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionPoly
};

const degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;
/**
 * Compute regression fits for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.x - An accessor for the predictor data field.
 * @param {function(object): *} params.y - An accessor for the predicted data field.
 * @param {string} [params.method='linear'] - The regression method to apply.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.
 * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.
 */


function Regression(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Regression.Definition = {
  'type': 'Regression',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'method',
    'type': 'string',
    'default': 'linear',
    'values': Object.keys(Methods)
  }, {
    'name': 'order',
    'type': 'number',
    'default': 3
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'params',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Regression, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
            groups = partition(source, _.groupby),
            names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName),
            method = _.method || 'linear',
            order = _.order || 3,
            dof = degreesOfFreedom(method, order),
            as = _.as || [(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.x), (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.y)],
            fit = Methods[method],
            values = [];
      let domain = _.extent;

      if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.hasOwnProperty)(Methods, method)) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Invalid regression method: ' + method);
      }

      if (domain != null) {
        if (method === 'log' && domain[0] <= 0) {
          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');
          domain = null;
        }
      }

      groups.forEach(g => {
        const n = g.length;

        if (n <= dof) {
          pulse.dataflow.warn('Skipping regression with more parameters than data points.');
          return;
        }

        const model = fit(g, _.x, _.y, order);

        if (_.params) {
          // if parameter vectors requested return those
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }

        const dom = domain || (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.extent)(g, _.x),
              add = p => {
          const t = {};

          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }

          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        };

        if (method === 'linear') {
          // for linear regression we only need the end points
          dom.forEach(x => add([x, model.predict(x)]));
        } else {
          // otherwise return trend line sample points
          (0,vega_statistics__WEBPACK_IMPORTED_MODULE_0__.sampleCurve)(model.predict, dom, 25, 200).forEach(add);
        }
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});




/***/ }),

/***/ "../../node_modules/vega-runtime/build/vega-runtime.module.js":
/*!********************************************************************!*\
  !*** ../../node_modules/vega-runtime/build/vega-runtime.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "context": () => (/* binding */ context)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");



/**
 * Parse a serialized dataflow specification.
 */
function parse (spec) {
  const ctx = this,
        operators = spec.operators || []; // parse background

  if (spec.background) {
    ctx.background = spec.background;
  } // parse event configuration


  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  } // parse locale configuration


  if (spec.locale) {
    ctx.locale = spec.locale;
  } // parse operators


  operators.forEach(entry => ctx.parseOperator(entry)); // parse operator parameters

  operators.forEach(entry => ctx.parseOperatorParameters(entry)); // parse streams

  (spec.streams || []).forEach(entry => ctx.parseStream(entry)); // parse updates

  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));
  return ctx.resolve();
}

const Skip = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['rule']),
      Swap = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['group', 'image', 'rect']);
function adjustSpatial(encode, marktype) {
  let code = '';
  if (Skip[marktype]) return code;

  if (encode.x2) {
    if (encode.x) {
      if (Swap[marktype]) {
        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';
      }

      code += 'o.width=o.x2-o.x;';
    } else {
      code += 'o.x=o.x2-(o.width||0);';
    }
  }

  if (encode.xc) {
    code += 'o.x=o.xc-(o.width||0)/2;';
  }

  if (encode.y2) {
    if (encode.y) {
      if (Swap[marktype]) {
        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';
      }

      code += 'o.height=o.y2-o.y;';
    } else {
      code += 'o.y=o.y2-(o.height||0);';
    }
  }

  if (encode.yc) {
    code += 'o.y=o.yc-(o.height||0)/2;';
  }

  return code;
}
function canonicalType(type) {
  return (type + '').toLowerCase();
}
function isOperator(type) {
  return canonicalType(type) === 'operator';
}
function isCollect(type) {
  return canonicalType(type) === 'collect';
}

function expression(ctx, args, code) {
  // wrap code in return statement if expression does not terminate
  if (code[code.length - 1] !== ';') {
    code = 'return(' + code + ');';
  }

  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
} // generate code for comparing a single field


function _compare(u, v, lt, gt) {
  return "((u = ".concat(u, ") < (v = ").concat(v, ") || u == null) && v != null ? ").concat(lt, "\n  : (u > v || v == null) && u != null ? ").concat(gt, "\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ").concat(lt, "\n  : v !== v && u === u ? ").concat(gt, " : ");
}

var expressionCodegen = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),

  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),

  /**
   * Parse an expression applied to an event stream.
   */
  event: (ctx, expr) => expression(ctx, ['event'], expr.code),

  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (ctx, expr) => {
    const code = "var datum=event.item&&event.item.datum;return ".concat(expr.code, ";");
    return expression(ctx, ['_', 'event'], code);
  },

  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (ctx, encode) => {
    const {
      marktype,
      channels
    } = encode;
    let code = 'var o=item,datum=o.datum,m=0,$;';

    for (const name in channels) {
      const o = 'o[' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name) + ']';
      code += "$=".concat(channels[name].code, ";if(").concat(o, "!==$)").concat(o, "=$,m=1;");
    }

    code += adjustSpatial(channels, marktype);
    code += 'return m;';
    return expression(ctx, ['item', '_'], code);
  },

  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(path) {
      const ref = "[".concat(path.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join(']['), "]");
      const get = Function('_', "return _".concat(ref, ";"));
      get.path = ref;
      return get;
    },

    comparator(fields, orders) {
      let t;

      const map = (f, i) => {
        const o = orders[i];
        let u, v;

        if (f.path) {
          u = "a".concat(f.path);
          v = "b".concat(f.path);
        } else {
          (t = t || {})['f' + i] = f;
          u = "this.f".concat(i, "(a)");
          v = "this.f".concat(i, "(b)");
        }

        return _compare(u, v, -o, o);
      };

      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');
      return t ? fn.bind(t) : fn;
    }

  }
};

/**
 * Parse a dataflow operator.
 */

function parseOperator(spec) {
  const ctx = this;

  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
/**
 * Parse and assign operator parameters.
 */

function parseOperatorParameters(spec) {
  const ctx = this;

  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid operator id: ' + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}

/**
 * Parse a set of operator parameters.
 */

function parseParameters(spec, params) {
  params = params || {};
  const ctx = this;

  for (const key in spec) {
    const value = spec[key];
    params[key] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);
  }

  return params;
}
/**
 * Parse a single parameter.
 */

function parseParameter(spec, ctx, params) {
  if (!spec || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec)) return spec;

  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(spec, p.key)) {
      return p.parse(spec, ctx, params);
    }
  }

  return spec;
}
/** Reference parsers. */


var PARSERS = [{
  key: '$ref',
  parse: getOperator
}, {
  key: '$key',
  parse: getKey
}, {
  key: '$expr',
  parse: getExpression
}, {
  key: '$field',
  parse: getField
}, {
  key: '$encode',
  parse: getEncode
}, {
  key: '$compare',
  parse: getCompare
}, {
  key: '$context',
  parse: getContext
}, {
  key: '$subflow',
  parse: getSubflow
}, {
  key: '$tupleid',
  parse: getTupleId
}];
/**
 * Resolve an operator reference.
 */

function getOperator(_, ctx) {
  return ctx.get(_.$ref) || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Operator not defined: ' + _.$ref);
}
/**
 * Resolve an expression reference.
 */


function getExpression(_, ctx, params) {
  if (_.$params) {
    // parse expression parameters
    ctx.parseParameters(_.$params, params);
  }

  const k = 'e:' + _.$expr.code + '_' + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(ctx.parameterExpression(_.$expr), _.$fields, _.$name));
}
/**
 * Resolve a key accessor reference.
 */


function getKey(_, ctx) {
  const k = 'k:' + _.$key + '_' + !!_.$flat;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.key)(_.$key, _.$flat, ctx.expr.codegen));
}
/**
 * Resolve a field accessor reference.
 */


function getField(_, ctx) {
  if (!_.$field) return null;
  const k = 'f:' + _.$field + '_' + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(_.$field, _.$name, ctx.expr.codegen));
}
/**
 * Resolve a comparator function reference.
 */


function getCompare(_, ctx) {
  // As of Vega 5.5.3, $tupleid sort is no longer used.
  // Keep here for now for backwards compatibility.
  const k = 'c:' + _.$compare + '_' + _.$order,
        c = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.$compare).map(_ => _ && _.$tupleid ? vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid : _);
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.compare)(c, _.$order, ctx.expr.codegen));
}
/**
 * Resolve an encode operator reference.
 */


function getEncode(_, ctx) {
  const spec = _.$encode,
        encode = {};

  for (const name in spec) {
    const enc = spec[name];
    encode[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode[name].output = enc.$output;
  }

  return encode;
}
/**
 * Resolve a context reference.
 */


function getContext(_, ctx) {
  return ctx;
}
/**
 * Resolve a recursive subflow specification.
 */


function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function (dataflow, key, parent) {
    const subctx = ctx.fork().parse(spec),
          op = subctx.get(spec.operators[0].id),
          p = subctx.signals.parent;
    if (p) p.set(parent);

    op.detachSubflow = () => ctx.detach(subctx);

    return op;
  };
}
/**
 * Resolve a tuple id reference.
 */


function getTupleId() {
  return vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid;
}

/**
 * Parse an event stream specification.
 */

function parseStream (spec) {
  var ctx = this,
      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,
      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,
      args;

  if (spec.source) {
    stream = ctx.events(spec.source, spec.type, filter);
  } else if (spec.merge) {
    args = spec.merge.map(_ => ctx.get(_));
    stream = args[0].merge.apply(args[0], args.slice(1));
  }

  if (spec.between) {
    args = spec.between.map(_ => ctx.get(_));
    stream = stream.between(args[0], args[1]);
  }

  if (spec.filter) {
    stream = stream.filter(filter);
  }

  if (spec.throttle != null) {
    stream = stream.throttle(+spec.throttle);
  }

  if (spec.debounce != null) {
    stream = stream.debounce(+spec.debounce);
  }

  if (stream == null) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid stream definition: ' + JSON.stringify(spec));
  }

  if (spec.consume) stream.consume(true);
  ctx.stream(spec, stream);
}

/**
 * Parse an event-driven operator update.
 */

function parseUpdate (spec) {
  var ctx = this,
      srcid = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(srcid = spec.source) ? srcid.$ref : srcid,
      source = ctx.get(srcid),
      target = null,
      update = spec.update,
      params = undefined;
  if (!source) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Source not defined: ' + spec.source);
  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);

  if (update && update.$expr) {
    if (update.$params) {
      params = ctx.parseParameters(update.$params);
    }

    update = ctx.handlerExpression(update.$expr);
  }

  ctx.update(spec, source, target, update, params);
}

const SKIP = {
  skip: true
};
function getState(options) {
  var ctx = this,
      state = {};

  if (options.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach(key => {
      const op = ctx.signals[key];

      if (options.signals(key, op)) {
        signals[key] = op.value;
      }
    });
  }

  if (options.data) {
    var data = state.data = {};
    Object.keys(ctx.data).forEach(key => {
      const dataset = ctx.data[key];

      if (options.data(key, dataset)) {
        data[key] = dataset.input.value;
      }
    });
  }

  if (ctx.subcontext && options.recurse !== false) {
    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));
  }

  return state;
}
function setState(state) {
  var ctx = this,
      df = ctx.dataflow,
      data = state.data,
      signals = state.signals;
  Object.keys(signals || {}).forEach(key => {
    df.update(ctx.signals[key], signals[key], SKIP);
  });
  Object.keys(data || {}).forEach(key => {
    df.pulse(ctx.data[key].input, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(data[key]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx) subctx.setState(substate);
  });
}

/**
 * Context objects store the current parse state.
 * Enables lookup of parsed operators, event streams, accessors, etc.
 * Provides a 'fork' method for creating child contexts for subflows.
 */

function context (df, transforms, functions, expr) {
  return new Context(df, transforms, functions, expr);
}

function Context(df, transforms, functions, expr) {
  this.dataflow = df;
  this.transforms = transforms;
  this.events = df.events.bind(df);
  this.expr = expr || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};

  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}

function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);

  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}

Context.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },

  detach(ctx) {
    this.subcontext = this.subcontext.filter(c => c !== ctx); // disconnect all nodes in the subcontext
    // wipe out targets first for better efficiency

    const keys = Object.keys(ctx.nodes);

    for (const key of keys) ctx.nodes[key]._targets = null;

    for (const key of keys) ctx.nodes[key].detach();

    ctx.nodes = null;
  },

  get(id) {
    return this.nodes[id];
  },

  set(id, node) {
    return this.nodes[id] = node;
  },

  add(spec, op) {
    const ctx = this,
          df = ctx.dataflow,
          data = spec.value;
    ctx.set(spec.id, op);

    if (isCollect(spec.type) && data) {
      if (data.$ingest) {
        df.ingest(op, data.$ingest, data.$format);
      } else if (data.$request) {
        df.preload(op, data.$request, data.$format);
      } else {
        df.pulse(op, df.changeset().insert(data));
      }
    }

    if (spec.root) {
      ctx.root = op;
    }

    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);

      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }

    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }

    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }

    if (spec.data) {
      for (const name in spec.data) {
        const data = ctx.data[name] || (ctx.data[name] = {});
        spec.data[name].forEach(role => data[role] = op);
      }
    }
  },

  resolve() {
    (this.unresolved || []).forEach(fn => fn());
    delete this.unresolved;
    return this;
  },

  operator(spec, update) {
    this.add(spec, this.dataflow.add(spec.value, update));
  },

  transform(spec, type) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));
  },

  stream(spec, stream) {
    this.set(spec.id, stream);
  },

  update(spec, stream, target, update, params) {
    this.dataflow.on(stream, target, update, params, spec.options);
  },

  // expression parsing
  operatorExpression(expr) {
    return this.expr.operator(this, expr);
  },

  parameterExpression(expr) {
    return this.expr.parameter(this, expr);
  },

  eventExpression(expr) {
    return this.expr.event(this, expr);
  },

  handlerExpression(expr) {
    return this.expr.handler(this, expr);
  },

  encodeExpression(encode) {
    return this.expr.encode(this, encode);
  },

  // parse methods
  parse,
  parseOperator,
  parseOperatorParameters,
  parseParameters,
  parseStream,
  parseUpdate,
  // state methods
  getState,
  setState
};




/***/ }),

/***/ "../../node_modules/vega-scale/build/vega-scale.module.js":
/*!****************************************************************!*\
  !*** ../../node_modules/vega-scale/build/vega-scale.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scaleImplicit": () => (/* reexport safe */ d3_scale__WEBPACK_IMPORTED_MODULE_1__.implicit),
/* harmony export */   "Band": () => (/* binding */ Band),
/* harmony export */   "BinOrdinal": () => (/* binding */ BinOrdinal),
/* harmony export */   "DiscreteLegend": () => (/* binding */ DiscreteLegend),
/* harmony export */   "Diverging": () => (/* binding */ Diverging),
/* harmony export */   "GradientLegend": () => (/* binding */ GradientLegend),
/* harmony export */   "Identity": () => (/* binding */ Identity),
/* harmony export */   "Linear": () => (/* binding */ Linear),
/* harmony export */   "Log": () => (/* binding */ Log),
/* harmony export */   "Ordinal": () => (/* binding */ Ordinal),
/* harmony export */   "Point": () => (/* binding */ Point),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "Quantile": () => (/* binding */ Quantile),
/* harmony export */   "Quantize": () => (/* binding */ Quantize),
/* harmony export */   "Sequential": () => (/* binding */ Sequential),
/* harmony export */   "Sqrt": () => (/* binding */ Sqrt),
/* harmony export */   "SymbolLegend": () => (/* binding */ SymbolLegend),
/* harmony export */   "Symlog": () => (/* binding */ Symlog),
/* harmony export */   "Threshold": () => (/* binding */ Threshold),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "UTC": () => (/* binding */ UTC),
/* harmony export */   "bandSpace": () => (/* binding */ bandSpace),
/* harmony export */   "domainCaption": () => (/* binding */ domainCaption),
/* harmony export */   "interpolate": () => (/* binding */ interpolate),
/* harmony export */   "interpolateColors": () => (/* binding */ interpolateColors),
/* harmony export */   "interpolateRange": () => (/* binding */ interpolateRange),
/* harmony export */   "isContinuous": () => (/* binding */ isContinuous),
/* harmony export */   "isDiscrete": () => (/* binding */ isDiscrete),
/* harmony export */   "isDiscretizing": () => (/* binding */ isDiscretizing),
/* harmony export */   "isInterpolating": () => (/* binding */ isInterpolating),
/* harmony export */   "isLogarithmic": () => (/* binding */ isLogarithmic),
/* harmony export */   "isQuantile": () => (/* binding */ isQuantile),
/* harmony export */   "isTemporal": () => (/* binding */ isTemporal),
/* harmony export */   "isValidScaleType": () => (/* binding */ isValidScaleType),
/* harmony export */   "labelFormat": () => (/* binding */ labelFormat),
/* harmony export */   "labelFraction": () => (/* binding */ labelFraction),
/* harmony export */   "labelValues": () => (/* binding */ labelValues),
/* harmony export */   "quantizeInterpolator": () => (/* binding */ quantizeInterpolator),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleCopy": () => (/* binding */ scaleCopy),
/* harmony export */   "scaleFraction": () => (/* binding */ scaleFraction),
/* harmony export */   "scheme": () => (/* binding */ scheme),
/* harmony export */   "tickCount": () => (/* binding */ tickCount),
/* harmony export */   "tickFormat": () => (/* binding */ tickFormat),
/* harmony export */   "tickValues": () => (/* binding */ tickValues),
/* harmony export */   "validTicks": () => (/* binding */ validTicks)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/ordinal.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/tickFormat.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/identity.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/log.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/symlog.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/time.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/utcTime.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/sequential.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/diverging.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");








function bandSpace (count, paddingInner, paddingOuter) {
  const space = count - paddingInner + paddingOuter * 2;
  return count ? space > 0 ? space : 1 : 0;
}

const Identity = 'identity';
const Linear = 'linear';
const Log = 'log';
const Pow = 'pow';
const Sqrt = 'sqrt';
const Symlog = 'symlog';
const Time = 'time';
const UTC = 'utc';
const Sequential = 'sequential';
const Diverging = 'diverging';
const Quantile = 'quantile';
const Quantize = 'quantize';
const Threshold = 'threshold';
const Ordinal = 'ordinal';
const Point = 'point';
const Band = 'band';
const BinOrdinal = 'bin-ordinal'; // categories

const Continuous = 'continuous';
const Discrete = 'discrete';
const Discretizing = 'discretizing';
const Interpolating = 'interpolating';
const Temporal = 'temporal';

function invertRange (scale) {
  return function (_) {
    let lo = _[0],
        hi = _[1],
        t;

    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }

    return [scale.invert(lo), scale.invert(hi)];
  };
}

function invertRangeExtent (scale) {
  return function (_) {
    const range = scale.range();
    let lo = _[0],
        hi = _[1],
        min = -1,
        max,
        t,
        i,
        n;

    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }

    for (i = 0, n = range.length; i < n; ++i) {
      if (range[i] >= lo && range[i] <= hi) {
        if (min < 0) min = i;
        max = i;
      }
    }

    if (min < 0) return undefined;
    lo = scale.invertExtent(range[min]);
    hi = scale.invertExtent(range[max]);
    return [lo[0] === undefined ? lo[1] : lo[0], hi[1] === undefined ? hi[0] : hi[1]];
  };
}

function band() {
  const scale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__.default)().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range;
  let range$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;
  delete scale.unknown;

  function rescale() {
    const n = domain().length,
          reverse = range$1[1] < range$1[0],
          stop = range$1[1 - reverse],
          space = bandSpace(n, paddingInner, paddingOuter);
    let start = range$1[reverse - 0];
    step = (stop - start) / (space || 1);

    if (round) {
      step = Math.floor(step);
    }

    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);

    if (round) {
      start = Math.round(start);
      bandwidth = Math.round(bandwidth);
    }

    const values = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(n).map(i => start + step * i);
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function (_) {
    if (arguments.length) {
      domain(_);
      return rescale();
    } else {
      return domain();
    }
  };

  scale.range = function (_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };

  scale.rangeRound = function (_) {
    range$1 = [+_[0], +_[1]];
    round = true;
    return rescale();
  };

  scale.bandwidth = function () {
    return bandwidth;
  };

  scale.step = function () {
    return step;
  };

  scale.round = function (_) {
    if (arguments.length) {
      round = !!_;
      return rescale();
    } else {
      return round;
    }
  };

  scale.padding = function (_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      paddingInner = paddingOuter;
      return rescale();
    } else {
      return paddingInner;
    }
  };

  scale.paddingInner = function (_) {
    if (arguments.length) {
      paddingInner = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner;
    }
  };

  scale.paddingOuter = function (_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter;
    }
  };

  scale.align = function (_) {
    if (arguments.length) {
      align = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align;
    }
  };

  scale.invertRange = function (_) {
    // bail if range has null or undefined values
    if (_[0] == null || _[1] == null) return;
    const reverse = range$1[1] < range$1[0],
          values = reverse ? ordinalRange().reverse() : ordinalRange(),
          n = values.length - 1;
    let lo = +_[0],
        hi = +_[1],
        a,
        b,
        t; // bail if either range endpoint is invalid

    if (lo !== lo || hi !== hi) return; // order range inputs, bail if outside of scale range

    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }

    if (hi < values[0] || lo > range$1[1 - reverse]) return; // binary search to index into scale range

    a = Math.max(0, (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.bisectRight)(values, lo) - 1);
    b = lo === hi ? a : (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.bisectRight)(values, hi) - 1; // increment index a if lo is within padding gap

    if (lo - values[a] > bandwidth + 1e-10) ++a;

    if (reverse) {
      // map + swap
      t = a;
      a = n - b;
      b = n - t;
    }

    return a > b ? undefined : domain().slice(a, b + 1);
  };

  scale.invert = function (_) {
    const value = scale.invertRange([_, _]);
    return value ? value[0] : value;
  };

  scale.copy = function () {
    return band().domain(domain()).range(range$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };

  return rescale();
}

function pointish(scale) {
  const copy = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;

  scale.copy = function () {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

var map = Array.prototype.map;
function numbers(_) {
  return map.call(_, vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber);
}

const slice = Array.prototype.slice;

function scaleBinOrdinal() {
  let domain = [],
      range = [];

  function scale(x) {
    return x == null || x !== x ? undefined : range[((0,d3_array__WEBPACK_IMPORTED_MODULE_4__.default)(domain, x) - 1) % range.length];
  }

  scale.domain = function (_) {
    if (arguments.length) {
      domain = numbers(_);
      return scale;
    } else {
      return domain.slice();
    }
  };

  scale.range = function (_) {
    if (arguments.length) {
      range = slice.call(_);
      return scale;
    } else {
      return range.slice();
    }
  };

  scale.tickFormat = function (count, specifier) {
    return (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__.default)(domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(domain), count == null ? 10 : count, specifier);
  };

  scale.copy = function () {
    return scaleBinOrdinal().domain(scale.domain()).range(scale.range());
  };

  return scale;
}

const scales = {};
/**
 * Augment scales with their type and needed inverse methods.
 */

function create(type, constructor, metadata) {
  const ctr = function scale() {
    const s = constructor();

    if (!s.invertRange) {
      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : undefined;
    }

    s.type = type;
    return s;
  };

  ctr.metadata = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(metadata));
  return ctr;
}

function scale(type, scale, metadata) {
  if (arguments.length > 1) {
    scales[type] = create(type, scale, metadata);
    return this;
  } else {
    return isValidScaleType(type) ? scales[type] : undefined;
  }
} // identity scale

scale(Identity, d3_scale__WEBPACK_IMPORTED_MODULE_6__.default); // continuous scales

scale(Linear, d3_scale__WEBPACK_IMPORTED_MODULE_7__.default, Continuous);
scale(Log, d3_scale__WEBPACK_IMPORTED_MODULE_8__.default, [Continuous, Log]);
scale(Pow, d3_scale__WEBPACK_IMPORTED_MODULE_9__.default, Continuous);
scale(Sqrt, d3_scale__WEBPACK_IMPORTED_MODULE_9__.sqrt, Continuous);
scale(Symlog, d3_scale__WEBPACK_IMPORTED_MODULE_10__.default, Continuous);
scale(Time, d3_scale__WEBPACK_IMPORTED_MODULE_11__.default, [Continuous, Temporal]);
scale(UTC, d3_scale__WEBPACK_IMPORTED_MODULE_12__.default, [Continuous, Temporal]); // sequential scales

scale(Sequential, d3_scale__WEBPACK_IMPORTED_MODULE_13__.default, [Continuous, Interpolating]); // backwards compat

scale("".concat(Sequential, "-").concat(Linear), d3_scale__WEBPACK_IMPORTED_MODULE_13__.default, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Log), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialLog, [Continuous, Interpolating, Log]);
scale("".concat(Sequential, "-").concat(Pow), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialPow, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Sqrt), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialSqrt, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Symlog), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialSymlog, [Continuous, Interpolating]); // diverging scales

scale("".concat(Diverging, "-").concat(Linear), d3_scale__WEBPACK_IMPORTED_MODULE_14__.default, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Log), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingLog, [Continuous, Interpolating, Log]);
scale("".concat(Diverging, "-").concat(Pow), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingPow, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Sqrt), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingSqrt, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Symlog), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingSymlog, [Continuous, Interpolating]); // discretizing scales

scale(Quantile, d3_scale__WEBPACK_IMPORTED_MODULE_15__.default, [Discretizing, Quantile]);
scale(Quantize, d3_scale__WEBPACK_IMPORTED_MODULE_16__.default, Discretizing);
scale(Threshold, d3_scale__WEBPACK_IMPORTED_MODULE_17__.default, Discretizing); // discrete scales

scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
scale(Ordinal, d3_scale__WEBPACK_IMPORTED_MODULE_1__.default, Discrete);
scale(Band, band, Discrete);
scale(Point, point, Discrete);
function isValidScaleType(type) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(scales, type);
}

function hasType(key, type) {
  const s = scales[key];
  return s && s.metadata[type];
}

function isContinuous(key) {
  return hasType(key, Continuous);
}
function isDiscrete(key) {
  return hasType(key, Discrete);
}
function isDiscretizing(key) {
  return hasType(key, Discretizing);
}
function isLogarithmic(key) {
  return hasType(key, Log);
}
function isTemporal(key) {
  return hasType(key, Temporal);
}
function isInterpolating(key) {
  return hasType(key, Interpolating);
}
function isQuantile(key) {
  return hasType(key, Quantile);
}

const scaleProps = ['clamp', 'base', 'constant', 'exponent'];
function interpolateRange(interpolator, range) {
  const start = range[0],
        span = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(range) - start;
  return function (i) {
    return interpolator(start + i * span);
  };
}
function interpolateColors(colors, type, gamma) {
  return (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_18__.default)(interpolate(type || 'rgb', gamma), colors);
}
function quantizeInterpolator(interpolator, count) {
  const samples = new Array(count),
        n = count + 1;

  for (let i = 0; i < count;) samples[i] = interpolator(++i / n);

  return samples;
}
function scaleCopy(scale) {
  const t = scale.type,
        s = scale.copy();
  s.type = t;
  return s;
}
function scaleFraction(scale$1, min, max) {
  const delta = max - min;
  let i, t, s;

  if (!delta || !Number.isFinite(delta)) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(0.5);
  } else {
    i = (t = scale$1.type).indexOf('-');
    t = i < 0 ? t : t.slice(i + 1);
    s = scale(t)().domain([min, max]).range([0, 1]);
    scaleProps.forEach(m => scale$1[m] ? s[m](scale$1[m]()) : 0);
    return s;
  }
}
function interpolate(type, gamma) {
  const interp = d3_interpolate__WEBPACK_IMPORTED_MODULE_19__[method(type)];
  return gamma != null && interp && interp.gamma ? interp.gamma(gamma) : interp;
}

function method(type) {
  return 'interpolate' + type.toLowerCase().split('-').map(s => s[0].toUpperCase() + s.slice(1)).join('');
}

const continuous = {
  blues: 'cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90',
  greens: 'd3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429',
  greys: 'e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e',
  oranges: 'fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303',
  purples: 'e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c',
  reds: 'fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13',
  blueGreen: 'd5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429',
  bluePurple: 'ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71',
  greenBlue: 'd3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1',
  orangeRed: 'fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403',
  purpleBlue: 'dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281',
  purpleBlueGreen: 'dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353',
  purpleRed: 'dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a',
  redPurple: 'fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174',
  yellowGreen: 'e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034',
  yellowOrangeBrown: 'feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204',
  yellowOrangeRed: 'fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225',
  blueOrange: '134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07',
  brownBlueGreen: '704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147',
  purpleGreen: '5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29',
  purpleOrange: '4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07',
  redBlue: '8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85',
  redGrey: '8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434',
  yellowGreenBlue: 'eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185',
  redYellowBlue: 'a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695',
  redYellowGreen: 'a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837',
  pinkYellowGreen: '8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419',
  spectral: '9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2',
  viridis: '440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725',
  magma: '0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf',
  inferno: '0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4',
  plasma: '0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921',
  cividis: '00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647',
  rainbow: '6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa',
  sinebow: 'ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040',
  turbo: '23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00',
  browns: 'eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632',
  tealBlues: 'bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985',
  teals: 'bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667',
  warmGreys: 'dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e',
  goldGreen: 'f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36',
  goldOrange: 'f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26',
  goldRed: 'f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e',
  lightGreyRed: 'efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b',
  lightGreyTeal: 'e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc',
  lightMulti: 'e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c',
  lightOrange: 'f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b',
  lightTealBlue: 'e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988',
  darkBlue: '3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff',
  darkGold: '3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff',
  darkGreen: '3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa',
  darkMulti: '3737371f5287197d8c29a86995ce3fffe800ffffff',
  darkRed: '3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c'
};
const discrete = {
  category10: '1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf',
  category20: '1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5',
  category20b: '393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6',
  category20c: '3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9',
  tableau10: '4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac',
  tableau20: '4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5',
  accent: '7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666',
  dark2: '1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666',
  paired: 'a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928',
  pastel1: 'fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2',
  pastel2: 'b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc',
  set1: 'e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999',
  set2: '66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3',
  set3: '8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f'
};

function colors(palette) {
  const n = palette.length / 6 | 0,
        c = new Array(n);

  for (let i = 0; i < n;) {
    c[i] = '#' + palette.slice(i * 6, ++i * 6);
  }

  return c;
}

function apply(_, f) {
  for (const k in _) scheme(k, f(_[k]));
}

const schemes = {};
apply(discrete, colors);
apply(continuous, _ => interpolateColors(colors(_)));
function scheme(name, scheme) {
  name = name && name.toLowerCase();

  if (arguments.length > 1) {
    schemes[name] = scheme;
    return this;
  } else {
    return schemes[name];
  }
}

const SymbolLegend = 'symbol';
const DiscreteLegend = 'discrete';
const GradientLegend = 'gradient';

const defaultFormatter = value => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? value.map(v => String(v)) : String(value);

const ascending = (a, b) => a[1] - b[1];

const descending = (a, b) => b[1] - a[1];
/**
 * Determine the tick count or interval function.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {*} count - The desired tick count or interval specifier.
 * @param {number} minStep - The desired minimum step between tick values.
 * @return {*} - The tick count or interval function.
 */


function tickCount(scale, count, minStep) {
  let step;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(count)) {
    if (scale.bins) {
      count = Math.max(count, scale.bins.length);
    }

    if (minStep != null) {
      count = Math.min(count, Math.floor((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)(scale.domain()) / minStep || 1));
    }
  }

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(count)) {
    step = count.step;
    count = count.interval;
  }

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(count)) {
    count = scale.type === Time ? (0,vega_time__WEBPACK_IMPORTED_MODULE_2__.timeInterval)(count) : scale.type == UTC ? (0,vega_time__WEBPACK_IMPORTED_MODULE_2__.utcInterval)(count) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Only time and utc scales accept interval strings.');
    if (step) count = count.every(step);
  }

  return count;
}
/**
 * Filter a set of candidate tick values, ensuring that only tick values
 * that lie within the scale range are included.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {Array<*>} ticks - The candidate tick values.
 * @param {*} count - The tick count or interval function.
 * @return {Array<*>} - The filtered tick values.
 */

function validTicks(scale, ticks, count) {
  let range = scale.range(),
      lo = range[0],
      hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(range),
      cmp = ascending;

  if (lo > hi) {
    range = hi;
    hi = lo;
    lo = range;
    cmp = descending;
  }

  lo = Math.floor(lo);
  hi = Math.ceil(hi); // filter ticks to valid values within the range
  // additionally sort ticks in range order (#2579)

  ticks = ticks.map(v => [v, scale(v)]).filter(_ => lo <= _[1] && _[1] <= hi).sort(cmp).map(_ => _[0]);

  if (count > 0 && ticks.length > 1) {
    const endpoints = [ticks[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(ticks)];

    while (ticks.length > count && ticks.length >= 3) {
      ticks = ticks.filter((_, i) => !(i % 2));
    }

    if (ticks.length < 3) {
      ticks = endpoints;
    }
  }

  return ticks;
}
/**
 * Generate tick values for the given scale and approximate tick count or
 * interval value. If the scale has a 'ticks' method, it will be used to
 * generate the ticks, with the count argument passed as a parameter. If the
 * scale lacks a 'ticks' method, the full scale domain will be returned.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {*} [count] - The approximate number of desired ticks.
 * @return {Array<*>} - The generated tick values.
 */

function tickValues(scale, count) {
  return scale.bins ? validTicks(scale, scale.bins) : scale.ticks ? scale.ticks(count) : scale.domain();
}
/**
 * Generate a label format function for a scale. If the scale has a
 * 'tickFormat' method, it will be used to generate the formatter, with the
 * count and specifier arguments passed as parameters. If the scale lacks a
 * 'tickFormat' method, the returned formatter performs simple string coercion.
 * If the input scale is a logarithmic scale and the format specifier does not
 * indicate a desired decimal precision, a special variable precision formatter
 * that automatically trims trailing zeroes will be generated.
 * @param {Scale} scale - The scale for which to generate the label formatter.
 * @param {*} [count] - The approximate number of desired ticks.
 * @param {string} [specifier] - The format specifier. Must be a legal d3
 *   specifier string (see https://github.com/d3/d3-format#formatSpecifier) or
 *   time multi-format specifier object.
 * @return {function(*):string} - The generated label formatter.
 */

function tickFormat(locale, scale, count, specifier, formatType, noSkip) {
  const type = scale.type;
  let format = defaultFormatter;

  if (type === Time || formatType === Time) {
    format = locale.timeFormat(specifier);
  } else if (type === UTC || formatType === UTC) {
    format = locale.utcFormat(specifier);
  } else if (isLogarithmic(type)) {
    const varfmt = locale.formatFloat(specifier);

    if (noSkip || scale.bins) {
      format = varfmt;
    } else {
      const test = tickLog(scale, count, false);

      format = _ => test(_) ? varfmt(_) : '';
    }
  } else if (scale.tickFormat) {
    // if d3 scale has tickFormat, it must be continuous
    const d = scale.domain();
    format = locale.formatSpan(d[0], d[d.length - 1], count, specifier);
  } else if (specifier) {
    format = locale.format(specifier);
  }

  return format;
}
function tickLog(scale, count, values) {
  const ticks = tickValues(scale, count),
        base = scale.base(),
        logb = Math.log(base),
        k = Math.max(1, base * count / ticks.length); // apply d3-scale's log format filter criteria

  const test = d => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5) i *= base;
    return i <= k;
  };

  return values ? ticks.filter(test) : test;
}

const symbols = {
  [Quantile]: 'quantiles',
  [Quantize]: 'thresholds',
  [Threshold]: 'domain'
};
const formats = {
  [Quantile]: 'quantiles',
  [Quantize]: 'domain'
};
function labelValues(scale, count) {
  return scale.bins ? binValues(scale.bins) : scale.type === Log ? tickLog(scale, count, true) : symbols[scale.type] ? thresholdValues(scale[symbols[scale.type]]()) : tickValues(scale, count);
}
function thresholdFormat(locale, scale, specifier) {
  const _ = scale[formats[scale.type]](),
        n = _.length;

  let d = n > 1 ? _[1] - _[0] : _[0],
      i;

  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  } // tickCount = 3 ticks times 10 for increased resolution


  return locale.formatSpan(0, d, 3 * 10, specifier);
}

function thresholdValues(thresholds) {
  const values = [-Infinity].concat(thresholds);
  values.max = +Infinity;
  return values;
}

function binValues(bins) {
  const values = bins.slice(0, -1);
  values.max = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(bins);
  return values;
}

const isDiscreteRange = scale => symbols[scale.type] || scale.bins;

function labelFormat(locale, scale, count, type, specifier, formatType, noSkip) {
  const format = formats[scale.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale, scale, specifier) : tickFormat(locale, scale, count, specifier, formatType, noSkip);
  return type === SymbolLegend && isDiscreteRange(scale) ? formatRange(format) : type === DiscreteLegend ? formatDiscrete(format) : formatPoint(format);
}

const formatRange = format => (value, index, array) => {
  const limit = get(array[index + 1], get(array.max, +Infinity)),
        lo = formatValue(value, format),
        hi = formatValue(limit, format);
  return lo && hi ? lo + ' \u2013 ' + hi : hi ? '< ' + hi : '\u2265 ' + lo;
};

const get = (value, dflt) => value != null ? value : dflt;

const formatDiscrete = format => (value, index) => index ? format(value) : null;

const formatPoint = format => value => format(value);

const formatValue = (value, format) => Number.isFinite(value) ? format(value) : null;

function labelFraction(scale) {
  const domain = scale.domain(),
        count = domain.length - 1;
  let lo = +domain[0],
      hi = +(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(domain),
      span = hi - lo;

  if (scale.type === Threshold) {
    const adjust = count ? span / count : 0.1;
    lo -= adjust;
    hi += adjust;
    span = hi - lo;
  }

  return value => (value - lo) / span;
}

function format(locale, scale, specifier, formatType) {
  const type = formatType || scale.type; // replace abbreviated time specifiers to improve screen reader experience

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(specifier) && isTemporal(type)) {
    specifier = specifier.replace(/%a/g, '%A').replace(/%b/g, '%B');
  }

  return !specifier && type === Time ? locale.timeFormat('%A, %d %B %Y, %X') : !specifier && type === UTC ? locale.utcFormat('%A, %d %B %Y, %X UTC') : labelFormat(locale, scale, 5, null, specifier, formatType, true);
}

function domainCaption(locale, scale, opt) {
  opt = opt || {};
  const max = Math.max(3, opt.maxlen || 7),
        fmt = format(locale, scale, opt.format, opt.formatType); // if scale breaks domain into bins, describe boundaries

  if (isDiscretizing(scale.type)) {
    const v = labelValues(scale).slice(1).map(fmt),
          n = v.length;
    return "".concat(n, " boundar").concat(n === 1 ? 'y' : 'ies', ": ").concat(v.join(', '));
  } // if scale domain is discrete, list values
  else if (isDiscrete(scale.type)) {
      const d = scale.domain(),
            n = d.length,
            v = n > max ? d.slice(0, max - 2).map(fmt).join(', ') + ', ending with ' + d.slice(-1).map(fmt) : d.map(fmt).join(', ');
      return "".concat(n, " value").concat(n === 1 ? '' : 's', ": ").concat(v);
    } // if scale domain is continuous, describe value range
    else {
        const d = scale.domain();
        return "values from ".concat(fmt(d[0]), " to ").concat(fmt((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(d)));
      }
}




/***/ }),

/***/ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bounds": () => (/* binding */ Bounds),
/* harmony export */   "CanvasHandler": () => (/* binding */ CanvasHandler),
/* harmony export */   "CanvasRenderer": () => (/* binding */ CanvasRenderer),
/* harmony export */   "Gradient": () => (/* binding */ Gradient),
/* harmony export */   "GroupItem": () => (/* binding */ GroupItem),
/* harmony export */   "Handler": () => (/* binding */ Handler),
/* harmony export */   "Item": () => (/* binding */ Item),
/* harmony export */   "Marks": () => (/* binding */ Marks),
/* harmony export */   "RenderType": () => (/* binding */ RenderType),
/* harmony export */   "Renderer": () => (/* binding */ Renderer),
/* harmony export */   "ResourceLoader": () => (/* binding */ ResourceLoader),
/* harmony export */   "SVGHandler": () => (/* binding */ SVGHandler),
/* harmony export */   "SVGRenderer": () => (/* binding */ SVGRenderer),
/* harmony export */   "SVGStringRenderer": () => (/* binding */ SVGStringRenderer),
/* harmony export */   "Scenegraph": () => (/* binding */ Scenegraph),
/* harmony export */   "boundClip": () => (/* binding */ boundClip),
/* harmony export */   "boundContext": () => (/* binding */ boundContext),
/* harmony export */   "boundItem": () => (/* binding */ boundItem),
/* harmony export */   "boundMark": () => (/* binding */ boundMark),
/* harmony export */   "boundStroke": () => (/* binding */ boundStroke),
/* harmony export */   "domChild": () => (/* binding */ domChild),
/* harmony export */   "domClear": () => (/* binding */ domClear),
/* harmony export */   "domCreate": () => (/* binding */ domCreate),
/* harmony export */   "domFind": () => (/* binding */ domFind),
/* harmony export */   "font": () => (/* binding */ font),
/* harmony export */   "fontFamily": () => (/* binding */ fontFamily),
/* harmony export */   "fontSize": () => (/* binding */ fontSize),
/* harmony export */   "intersect": () => (/* binding */ intersect),
/* harmony export */   "intersectBoxLine": () => (/* binding */ intersectBoxLine),
/* harmony export */   "intersectPath": () => (/* binding */ intersectPath),
/* harmony export */   "intersectPoint": () => (/* binding */ intersectPoint),
/* harmony export */   "intersectRule": () => (/* binding */ intersectRule),
/* harmony export */   "lineHeight": () => (/* binding */ lineHeight),
/* harmony export */   "markup": () => (/* binding */ markup),
/* harmony export */   "multiLineOffset": () => (/* binding */ multiLineOffset),
/* harmony export */   "pathCurves": () => (/* binding */ curves),
/* harmony export */   "pathEqual": () => (/* binding */ pathEqual),
/* harmony export */   "pathParse": () => (/* binding */ pathParse),
/* harmony export */   "pathRectangle": () => (/* binding */ vg_rect),
/* harmony export */   "pathRender": () => (/* binding */ pathRender),
/* harmony export */   "pathSymbols": () => (/* binding */ symbols),
/* harmony export */   "pathTrail": () => (/* binding */ vg_trail),
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "renderModule": () => (/* binding */ renderModule),
/* harmony export */   "resetSVGClipId": () => (/* binding */ resetSVGClipId),
/* harmony export */   "resetSVGDefIds": () => (/* binding */ resetSVGDefIds),
/* harmony export */   "sceneEqual": () => (/* binding */ sceneEqual),
/* harmony export */   "sceneFromJSON": () => (/* binding */ sceneFromJSON),
/* harmony export */   "scenePickVisit": () => (/* binding */ pickVisit),
/* harmony export */   "sceneToJSON": () => (/* binding */ sceneToJSON),
/* harmony export */   "sceneVisit": () => (/* binding */ visit),
/* harmony export */   "sceneZOrder": () => (/* binding */ zorder),
/* harmony export */   "serializeXML": () => (/* binding */ serializeXML),
/* harmony export */   "textMetrics": () => (/* binding */ textMetrics)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basis.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/bundle.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinal.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/monotone.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/natural.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/step.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/area.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/line.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! d3-shape */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol.js");
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-canvas */ "../../node_modules/vega-canvas/index.browser.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-loader */ "../../node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");







let gradient_id = 0;
function resetSVGGradientId() {
  gradient_id = 0;
}
const patternPrefix = 'p_';
function isGradient(value) {
  return value && value.gradient;
}
function gradientRef(g, defs, base) {
  const type = g.gradient;
  let id = g.id,
      prefix = type === 'radial' ? patternPrefix : ''; // check id, assign default values as needed

  if (!id) {
    id = g.id = 'gradient_' + gradient_id++;

    if (type === 'radial') {
      g.x1 = get(g.x1, 0.5);
      g.y1 = get(g.y1, 0.5);
      g.r1 = get(g.r1, 0);
      g.x2 = get(g.x2, 0.5);
      g.y2 = get(g.y2, 0.5);
      g.r2 = get(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get(g.x1, 0);
      g.y1 = get(g.y1, 0);
      g.x2 = get(g.x2, 1);
      g.y2 = get(g.y2, 0);
    }
  } // register definition


  defs[id] = g; // return url reference

  return 'url(' + (base || '') + '#' + prefix + id + ')';
}

function get(val, def) {
  return val != null ? val : def;
}

function Gradient (p0, p1) {
  var stops = [],
      gradient;
  return gradient = {
    gradient: 'linear',
    x1: p0 ? p0[0] : 0,
    y1: p0 ? p0[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops: stops,
    stop: function (offset, color) {
      stops.push({
        offset: offset,
        color: color
      });
      return gradient;
    }
  };
}

const lookup = {
  'basis': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_4__.default
  },
  'basis-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_5__.default
  },
  'basis-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_6__.default
  },
  'bundle': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_7__.default,
    tension: 'beta',
    value: 0.85
  },
  'cardinal': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_8__.default,
    tension: 'tension',
    value: 0
  },
  'cardinal-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_9__.default,
    tension: 'tension',
    value: 0
  },
  'cardinal-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_10__.default,
    tension: 'tension',
    value: 0
  },
  'catmull-rom': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_11__.default,
    tension: 'alpha',
    value: 0.5
  },
  'catmull-rom-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_12__.default,
    tension: 'alpha',
    value: 0.5
  },
  'catmull-rom-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_13__.default,
    tension: 'alpha',
    value: 0.5
  },
  'linear': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_14__.default
  },
  'linear-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_15__.default
  },
  'monotone': {
    horizontal: d3_shape__WEBPACK_IMPORTED_MODULE_16__.monotoneY,
    vertical: d3_shape__WEBPACK_IMPORTED_MODULE_16__.monotoneX
  },
  'natural': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_17__.default
  },
  'step': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__.default
  },
  'step-after': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__.stepAfter
  },
  'step-before': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__.stepBefore
  }
};
function curves(type, orientation, tension) {
  var entry = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(lookup, type) && lookup[type],
      curve = null;

  if (entry) {
    curve = entry.curve || entry[orientation || 'vertical'];

    if (entry.tension && tension != null) {
      curve = curve[entry.tension](tension);
    }
  }

  return curve;
}

// Path parsing and rendering code adapted from fabric.js -- Thanks!
const cmdlen = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
},
      regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\.\d+)(\.\d)/g, /(\d)([-+])/g, /\s|,|###/];
function pathParse (pathstr) {
  const result = [];
  let curr, chunks, parsed, param, cmd, len, i, j, n, m; // First, break path into command sequence

  const path = pathstr.slice().replace(regexp[0], '###$1').split(regexp[1]).slice(1); // Next, parse each command in turn

  for (i = 0, n = path.length; i < n; ++i) {
    curr = path[i];
    chunks = curr.slice(1).trim().replace(regexp[2], '$1###$2').replace(regexp[3], '$1###$2').split(regexp[4]);
    cmd = curr.charAt(0);
    parsed = [cmd];

    for (j = 0, m = chunks.length; j < m; ++j) {
      if ((param = +chunks[j]) === param) {
        // not NaN
        parsed.push(param);
      }
    }

    len = cmdlen[cmd.toLowerCase()];

    if (parsed.length - 1 > len) {
      const m = parsed.length;
      j = 1;
      result.push([cmd].concat(parsed.slice(j, j += len))); // handle implicit lineTo (#2803)

      cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;

      for (; j < m; j += len) {
        result.push([cmd].concat(parsed.slice(j, j + len)));
      }
    } else {
      result.push(parsed);
    }
  }

  return result;
}

const DegToRad = Math.PI / 180;
const Epsilon = 1e-14;
const HalfPi = Math.PI / 2;
const Tau = Math.PI * 2;
const HalfSqrt3 = Math.sqrt(3) / 2;

var segmentCache = {};
var bezierCache = {};
var join = [].join; // Copied from Inkscape svgtopdf, thanks!

function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  const key = join.call(arguments);

  if (segmentCache[key]) {
    return segmentCache[key];
  }

  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / (rx * rx) + py * py / (ry * ry);

  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }

  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x0 = a00 * ox + a01 * oy;
  const y0 = a10 * ox + a11 * oy;
  const x1 = a00 * x + a01 * y;
  const y1 = a10 * x + a11 * y;
  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large) sfactor = -sfactor;
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  const th0 = Math.atan2(y0 - yc, x0 - xc);
  const th1 = Math.atan2(y1 - yc, x1 - xc);
  let th_arc = th1 - th0;

  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }

  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));
  const result = [];

  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }

  return segmentCache[key] = result;
}
function bezier(params) {
  const key = join.call(params);

  if (bezierCache[key]) {
    return bezierCache[key];
  }

  var cx = params[0],
      cy = params[1],
      th0 = params[2],
      th1 = params[3],
      rx = params[4],
      ry = params[5],
      sin_th = params[6],
      cos_th = params[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x1 = cx + cos_th0 - t * sin_th0;
  const y1 = cy + sin_th0 + t * cos_th0;
  const x3 = cx + cos_th1;
  const y3 = cy + sin_th1;
  const x2 = x3 + t * sin_th1;
  const y2 = y3 - t * cos_th1;
  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}

const temp = ['l', 0, 0, 0, 0, 0, 0, 0];

function scale$1(current, sX, sY) {
  const c = temp[0] = current[0];

  if (c === 'a' || c === 'A') {
    temp[1] = sX * current[1];
    temp[2] = sY * current[2];
    temp[3] = current[3];
    temp[4] = current[4];
    temp[5] = current[5];
    temp[6] = sX * current[6];
    temp[7] = sY * current[7];
  } else if (c === 'h' || c === 'H') {
    temp[1] = sX * current[1];
  } else if (c === 'v' || c === 'V') {
    temp[1] = sY * current[1];
  } else {
    for (var i = 1, n = current.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
    }
  }

  return temp;
}

function pathRender (context, path, l, t, sX, sY) {
  var current,
      // current instruction
  previous = null,
      x = 0,
      // current x
  y = 0,
      // current y
  controlX = 0,
      // current control point x
  controlY = 0,
      // current control point y
  tempX,
      tempY,
      tempControlX,
      tempControlY;
  if (l == null) l = 0;
  if (t == null) t = 0;
  if (sX == null) sX = 1;
  if (sY == null) sY = sX;
  if (context.beginPath) context.beginPath();

  for (var i = 0, len = path.length; i < len; ++i) {
    current = path[i];

    if (sX !== 1 || sY !== 1) {
      current = scale$1(current, sX, sY);
    }

    switch (current[0]) {
      // first letter
      case 'l':
        // lineto, relative
        x += current[1];
        y += current[2];
        context.lineTo(x + l, y + t);
        break;

      case 'L':
        // lineto, absolute
        x = current[1];
        y = current[2];
        context.lineTo(x + l, y + t);
        break;

      case 'h':
        // horizontal lineto, relative
        x += current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'H':
        // horizontal lineto, absolute
        x = current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'v':
        // vertical lineto, relative
        y += current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'V':
        // verical lineto, absolute
        y = current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'm':
        // moveTo, relative
        x += current[1];
        y += current[2];
        context.moveTo(x + l, y + t);
        break;

      case 'M':
        // moveTo, absolute
        x = current[1];
        y = current[2];
        context.moveTo(x + l, y + t);
        break;

      case 'c':
        // bezierCurveTo, relative
        tempX = x + current[5];
        tempY = y + current[6];
        controlX = x + current[3];
        controlY = y + current[4];
        context.bezierCurveTo(x + current[1] + l, // x1
        y + current[2] + t, // y1
        controlX + l, // x2
        controlY + t, // y2
        tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;

      case 'C':
        // bezierCurveTo, absolute
        x = current[5];
        y = current[6];
        controlX = current[3];
        controlY = current[4];
        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
        break;

      case 's':
        // shorthand cubic bezierCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4]; // calculate reflection of previous control points

        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t); // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.

        controlX = x + current[1];
        controlY = y + current[2];
        x = tempX;
        y = tempY;
        break;

      case 'S':
        // shorthand cubic bezierCurveTo, absolute
        tempX = current[3];
        tempY = current[4]; // calculate reflection of previous control points

        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY; // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.

        controlX = current[1];
        controlY = current[2];
        break;

      case 'q':
        // quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];
        controlX = x + current[1];
        controlY = y + current[2];
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;

      case 'Q':
        // quadraticCurveTo, absolute
        tempX = current[3];
        tempY = current[4];
        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        controlX = current[1];
        controlY = current[2];
        break;

      case 't':
        // shorthand quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[1];
        tempY = y + current[2];

        if (previous[0].match(/[QqTt]/) === null) {
          // If there is no previous command or if the previous command was not a Q, q, T or t,
          // assume the control point is coincident with the current point
          controlX = x;
          controlY = y;
        } else if (previous[0] === 't') {
          // calculate reflection of previous control points for t
          controlX = 2 * x - tempControlX;
          controlY = 2 * y - tempControlY;
        } else if (previous[0] === 'q') {
          // calculate reflection of previous control points for q
          controlX = 2 * x - controlX;
          controlY = 2 * y - controlY;
        }

        tempControlX = controlX;
        tempControlY = controlY;
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        controlX = x + current[1];
        controlY = y + current[2];
        break;

      case 'T':
        tempX = current[1];
        tempY = current[2]; // calculate reflection of previous control points

        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;

      case 'a':
        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);
        x += current[6];
        y += current[7];
        break;

      case 'A':
        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);
        x = current[6];
        y = current[7];
        break;

      case 'z':
      case 'Z':
        context.closePath();
        break;
    }

    previous = current;
  }
}

function drawArc(context, x, y, coords) {
  const seg = segments(coords[5], // end x
  coords[6], // end y
  coords[0], // radius x
  coords[1], // radius y
  coords[3], // large flag
  coords[4], // sweep flag
  coords[2], // rotation
  x, y);

  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}

const Tan30 = 0.5773502691896257;
const builtins = {
  'circle': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, Tau);
    }
  },
  'cross': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          s = r / 2.5;
      context.moveTo(-r, -s);
      context.lineTo(-r, s);
      context.lineTo(-s, s);
      context.lineTo(-s, r);
      context.lineTo(s, r);
      context.lineTo(s, s);
      context.lineTo(r, s);
      context.lineTo(r, -s);
      context.lineTo(s, -s);
      context.lineTo(s, -r);
      context.lineTo(-s, -r);
      context.lineTo(-s, -s);
      context.closePath();
    }
  },
  'diamond': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(-r, 0);
      context.lineTo(0, -r);
      context.lineTo(r, 0);
      context.lineTo(0, r);
      context.closePath();
    }
  },
  'square': {
    draw: function (context, size) {
      var w = Math.sqrt(size),
          x = -w / 2;
      context.rect(x, x, w, w);
    }
  },
  'arrow': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          s = r / 7,
          t = r / 2.5,
          v = r / 8;
      context.moveTo(-s, r);
      context.lineTo(s, r);
      context.lineTo(s, -v);
      context.lineTo(t, -v);
      context.lineTo(0, -r);
      context.lineTo(-t, -v);
      context.lineTo(-s, -v);
      context.closePath();
    }
  },
  'wedge': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r,
          o = h - r * Tan30,
          b = r / 4;
      context.moveTo(0, -h - o);
      context.lineTo(-b, h - o);
      context.lineTo(b, h - o);
      context.closePath();
    }
  },
  'triangle': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r,
          o = h - r * Tan30;
      context.moveTo(0, -h - o);
      context.lineTo(-r, h - o);
      context.lineTo(r, h - o);
      context.closePath();
    }
  },
  'triangle-up': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(0, -h);
      context.lineTo(-r, h);
      context.lineTo(r, h);
      context.closePath();
    }
  },
  'triangle-down': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(0, h);
      context.lineTo(-r, -h);
      context.lineTo(r, -h);
      context.closePath();
    }
  },
  'triangle-right': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(h, 0);
      context.lineTo(-h, -r);
      context.lineTo(-h, r);
      context.closePath();
    }
  },
  'triangle-left': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(-h, 0);
      context.lineTo(h, -r);
      context.lineTo(h, r);
      context.closePath();
    }
  },
  'stroke': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(-r, 0);
      context.lineTo(r, 0);
    }
  }
};
function symbols(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom = {};

function customSymbol(path) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(custom, path)) {
    const parsed = pathParse(path);
    custom[path] = {
      draw: function (context, size) {
        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }

  return custom[path];
}

const C = 0.448084975506; // C = 1 - c

function rectangleX(d) {
  return d.x;
}

function rectangleY(d) {
  return d.y;
}

function rectangleWidth(d) {
  return d.width;
}

function rectangleHeight(d) {
  return d.height;
}

function number(_) {
  return typeof _ === 'function' ? _ : () => +_;
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(value, max));
}

function vg_rect () {
  var x = rectangleX,
      y = rectangleY,
      width = rectangleWidth,
      height = rectangleHeight,
      crTL = number(0),
      crTR = crTL,
      crBL = crTL,
      crBR = crTL,
      context = null;

  function rectangle(_, x0, y0) {
    var buffer,
        x1 = x0 != null ? x0 : +x.call(this, _),
        y1 = y0 != null ? y0 : +y.call(this, _),
        w = +width.call(this, _),
        h = +height.call(this, _),
        s = Math.min(w, h) / 2,
        tl = clamp(+crTL.call(this, _), 0, s),
        tr = clamp(+crTR.call(this, _), 0, s),
        bl = clamp(+crBL.call(this, _), 0, s),
        br = clamp(+crBR.call(this, _), 0, s);
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_19__.default)();

    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
      context.rect(x1, y1, w, h);
    } else {
      var x2 = x1 + w,
          y2 = y1 + h;
      context.moveTo(x1 + tl, y1);
      context.lineTo(x2 - tr, y1);
      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);
      context.lineTo(x2, y2 - br);
      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);
      context.lineTo(x1 + bl, y2);
      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);
      context.lineTo(x1, y1 + tl);
      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);
      context.closePath();
    }

    if (buffer) {
      context = null;
      return buffer + '' || null;
    }
  }

  rectangle.x = function (_) {
    if (arguments.length) {
      x = number(_);
      return rectangle;
    } else {
      return x;
    }
  };

  rectangle.y = function (_) {
    if (arguments.length) {
      y = number(_);
      return rectangle;
    } else {
      return y;
    }
  };

  rectangle.width = function (_) {
    if (arguments.length) {
      width = number(_);
      return rectangle;
    } else {
      return width;
    }
  };

  rectangle.height = function (_) {
    if (arguments.length) {
      height = number(_);
      return rectangle;
    } else {
      return height;
    }
  };

  rectangle.cornerRadius = function (tl, tr, br, bl) {
    if (arguments.length) {
      crTL = number(tl);
      crTR = tr != null ? number(tr) : crTL;
      crBR = br != null ? number(br) : crTL;
      crBL = bl != null ? number(bl) : crTR;
      return rectangle;
    } else {
      return crTL;
    }
  };

  rectangle.context = function (_) {
    if (arguments.length) {
      context = _ == null ? null : _;
      return rectangle;
    } else {
      return context;
    }
  };

  return rectangle;
}

function vg_trail () {
  var x,
      y,
      size,
      defined,
      context = null,
      ready,
      x1,
      y1,
      r1;

  function point(x2, y2, w2) {
    const r2 = w2 / 2;

    if (ready) {
      var ux = y1 - y2,
          uy = x2 - x1;

      if (ux || uy) {
        // get normal vector
        var ud = Math.sqrt(ux * ux + uy * uy),
            rx = (ux /= ud) * r1,
            ry = (uy /= ud) * r1,
            t = Math.atan2(uy, ux); // draw segment

        context.moveTo(x1 - rx, y1 - ry);
        context.lineTo(x2 - ux * r2, y2 - uy * r2);
        context.arc(x2, y2, r2, t - Math.PI, t);
        context.lineTo(x1 + rx, y1 + ry);
        context.arc(x1, y1, r1, t, t + Math.PI);
      } else {
        context.arc(x2, y2, r2, 0, Tau);
      }

      context.closePath();
    } else {
      ready = 1;
    }

    x1 = x2;
    y1 = y2;
    r1 = r2;
  }

  function trail(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;
    if (context == null) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_19__.default)();

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) ready = 0;
      }

      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));
    }

    if (buffer) {
      context = null;
      return buffer + '' || null;
    }
  }

  trail.x = function (_) {
    if (arguments.length) {
      x = _;
      return trail;
    } else {
      return x;
    }
  };

  trail.y = function (_) {
    if (arguments.length) {
      y = _;
      return trail;
    } else {
      return y;
    }
  };

  trail.size = function (_) {
    if (arguments.length) {
      size = _;
      return trail;
    } else {
      return size;
    }
  };

  trail.defined = function (_) {
    if (arguments.length) {
      defined = _;
      return trail;
    } else {
      return defined;
    }
  };

  trail.context = function (_) {
    if (arguments.length) {
      if (_ == null) {
        context = null;
      } else {
        context = _;
      }

      return trail;
    } else {
      return context;
    }
  };

  return trail;
}

function value$1(a, b) {
  return a != null ? a : b;
}

const x = item => item.x || 0,
      y = item => item.y || 0,
      w = item => item.width || 0,
      h = item => item.height || 0,
      xw = item => (item.x || 0) + (item.width || 0),
      yh = item => (item.y || 0) + (item.height || 0),
      sa = item => item.startAngle || 0,
      ea = item => item.endAngle || 0,
      pa = item => item.padAngle || 0,
      ir = item => item.innerRadius || 0,
      or = item => item.outerRadius || 0,
      cr = item => item.cornerRadius || 0,
      tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,
      tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,
      br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,
      bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,
      sz = item => value$1(item.size, 64),
      ts = item => item.size || 1,
      def = item => !(item.defined === false),
      type = item => symbols(item.shape || 'circle');

const arcShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_20__.default)().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),
      areavShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_21__.default)().x(x).y1(y).y0(yh).defined(def),
      areahShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_21__.default)().y(y).x1(x).x0(xw).defined(def),
      lineShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_22__.default)().x(x).y(y).defined(def),
      rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),
      symbolShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_23__.default)().type(type).size(sz),
      trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1(context, item) {
  return arcShape.context(context)(item);
}
function area$1(context, items) {
  const item = items[0],
        interp = item.interpolate || 'linear';
  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);
}
function line$1(context, items) {
  const item = items[0],
        interp = item.interpolate || 'linear';
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);
}
function rectangle(context, item, x, y) {
  return rectShape.context(context)(item, x, y);
}
function shape$1(context, item) {
  return (item.mark.shape || item.shape).context(context)(item);
}
function symbol$1(context, item) {
  return symbolShape.context(context)(item);
}
function trail$1(context, items) {
  return trailShape.context(context)(items);
}

var clip_id = 1;
function resetSVGClipId() {
  clip_id = 1;
}
function clip$1 (renderer, item, size) {
  var clip = item.clip,
      defs = renderer._defs,
      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),
      c = defs.clipping[id] || (defs.clipping[id] = {
    id: id
  });

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    c.path = clip(null);
  } else if (hasCornerRadius(size)) {
    c.path = rectangle(null, size, 0, 0);
  } else {
    c.width = size.width || 0;
    c.height = size.height || 0;
  }

  return 'url(#' + id + ')';
}

function Bounds(b) {
  this.clear();
  if (b) this.union(b);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },

  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },

  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },

  equals(b) {
    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
  },

  set(x1, y1, x2, y2) {
    if (x2 < x1) {
      this.x2 = x1;
      this.x1 = x2;
    } else {
      this.x1 = x1;
      this.x2 = x2;
    }

    if (y2 < y1) {
      this.y2 = y1;
      this.y1 = y2;
    } else {
      this.y1 = y1;
      this.y2 = y2;
    }

    return this;
  },

  add(x, y) {
    if (x < this.x1) this.x1 = x;
    if (y < this.y1) this.y1 = y;
    if (x > this.x2) this.x2 = x;
    if (y > this.y2) this.y2 = y;
    return this;
  },

  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },

  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },

  scale(s) {
    this.x1 *= s;
    this.y1 *= s;
    this.x2 *= s;
    this.y2 *= s;
    return this;
  },

  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },

  rotate(angle, x, y) {
    const p = this.rotatedPoints(angle, x, y);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },

  rotatedPoints(angle, x, y) {
    var {
      x1,
      y1,
      x2,
      y2
    } = this,
        cos = Math.cos(angle),
        sin = Math.sin(angle),
        cx = x - x * cos + y * sin,
        cy = y - x * sin - y * cos;
    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
  },

  union(b) {
    if (b.x1 < this.x1) this.x1 = b.x1;
    if (b.y1 < this.y1) this.y1 = b.y1;
    if (b.x2 > this.x2) this.x2 = b.x2;
    if (b.y2 > this.y2) this.y2 = b.y2;
    return this;
  },

  intersect(b) {
    if (b.x1 > this.x1) this.x1 = b.x1;
    if (b.y1 > this.y1) this.y1 = b.y1;
    if (b.x2 < this.x2) this.x2 = b.x2;
    if (b.y2 < this.y2) this.y2 = b.y2;
    return this;
  },

  encloses(b) {
    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
  },

  alignsWith(b) {
    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);
  },

  intersects(b) {
    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
  },

  contains(x, y) {
    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
  },

  width() {
    return this.x2 - this.x1;
  },

  height() {
    return this.y2 - this.y1;
  }

};

function Item(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds();
}

function GroupItem(mark) {
  Item.call(this, mark);
  this.items = this.items || [];
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(GroupItem, Item);

function ResourceLoader(customLoader) {
  this._pending = 0;
  this._loader = customLoader || (0,vega_loader__WEBPACK_IMPORTED_MODULE_2__.loader)();
}

function increment(loader) {
  loader._pending += 1;
}

function decrement(loader) {
  loader._pending -= 1;
}

ResourceLoader.prototype = {
  pending() {
    return this._pending;
  },

  sanitizeURL(uri) {
    const loader = this;
    increment(loader);
    return loader._loader.sanitize(uri, {
      context: 'href'
    }).then(opt => {
      decrement(loader);
      return opt;
    }).catch(() => {
      decrement(loader);
      return null;
    });
  },

  loadImage(uri) {
    const loader = this,
          Image = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.image)();
    increment(loader);
    return loader._loader.sanitize(uri, {
      context: 'image'
    }).then(opt => {
      const url = opt.href;
      if (!url || !Image) throw {
        url: url
      };
      const img = new Image(); // set crossOrigin only if cors is defined; empty string sets anonymous mode
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin

      const cors = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';
      if (cors != null) img.crossOrigin = cors; // attempt to load image resource

      img.onload = () => decrement(loader);

      img.onerror = () => decrement(loader);

      img.src = url;
      return img;
    }).catch(e => {
      decrement(loader);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e && e.url || ''
      };
    });
  },

  ready() {
    const loader = this;
    return new Promise(accept => {
      function poll(value) {
        if (!loader.pending()) accept(value);else setTimeout(() => {
          poll(true);
        }, 10);
      }

      poll(false);
    });
  }

};

function boundStroke (bounds, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }

  return bounds;
}

function miterAdjustment(item, strokeWidth) {
  // TODO: more sophisticated adjustment? Or miter support in boundContext?
  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;
}

const circleThreshold = Tau - 1e-8;
let bounds, lx, ly, rot, ma, mb, mc, md;

const add = (x, y) => bounds.add(x, y);

const addL = (x, y) => add(lx = x, ly = y);

const addX = x => add(x, bounds.y1);

const addY = y => add(bounds.x1, y);

const px = (x, y) => ma * x + mc * y;

const py = (x, y) => mb * x + md * y;

const addp = (x, y) => add(px(x, y), py(x, y));

const addpL = (x, y) => addL(px(x, y), py(x, y));

function boundContext (_, deg) {
  bounds = _;

  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }

  return context$1;
}
const context$1 = {
  beginPath() {},

  closePath() {},

  moveTo: addpL,
  lineTo: addpL,

  rect(x, y, w, h) {
    if (rot) {
      addp(x + w, y);
      addp(x + w, y + h);
      addp(x, y + h);
      addpL(x, y);
    } else {
      add(x + w, y + h);
      addL(x, y);
    }
  },

  quadraticCurveTo(x1, y1, x2, y2) {
    const px1 = px(x1, y1),
          py1 = py(x1, y1),
          px2 = px(x2, y2),
          py2 = py(x2, y2);
    quadExtrema(lx, px1, px2, addX);
    quadExtrema(ly, py1, py2, addY);
    addL(px2, py2);
  },

  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    const px1 = px(x1, y1),
          py1 = py(x1, y1),
          px2 = px(x2, y2),
          py2 = py(x2, y2),
          px3 = px(x3, y3),
          py3 = py(x3, y3);
    cubicExtrema(lx, px1, px2, px3, addX);
    cubicExtrema(ly, py1, py2, py3, addY);
    addL(px3, py3);
  },

  arc(cx, cy, r, sa, ea, ccw) {
    sa += rot;
    ea += rot; // store last point on path

    lx = r * Math.cos(ea) + cx;
    ly = r * Math.sin(ea) + cy;

    if (Math.abs(ea - sa) > circleThreshold) {
      // treat as full circle
      add(cx - r, cy - r);
      add(cx + r, cy + r);
    } else {
      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);

      let s, i; // sample end points

      update(sa);
      update(ea); // sample interior points aligned with 90 degrees

      if (ea !== sa) {
        sa = sa % Tau;
        if (sa < 0) sa += Tau;
        ea = ea % Tau;
        if (ea < 0) ea += Tau;

        if (ea < sa) {
          ccw = !ccw; // flip direction

          s = sa;
          sa = ea;
          ea = s; // swap end-points
        }

        if (ccw) {
          ea -= Tau;
          s = sa - sa % HalfPi;

          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);
        } else {
          s = sa - sa % HalfPi + HalfPi;

          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);
        }
      }
    }
  }

};

function quadExtrema(x0, x1, x2, cb) {
  const t = (x0 - x1) / (x0 + x2 - 2 * x1);
  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);
}

function cubicExtrema(x0, x1, x2, x3, cb) {
  const a = x3 - x0 + 3 * x1 - 3 * x2,
        b = x0 + x2 - 2 * x1,
        c = x0 - x1;
  let t0 = 0,
      t1 = 0,
      r; // solve for parameter t

  if (Math.abs(a) > Epsilon) {
    // quadratic equation
    r = b * b + c * a;

    if (r >= 0) {
      r = Math.sqrt(r);
      t0 = (-b + r) / a;
      t1 = (-b - r) / a;
    }
  } else {
    // linear equation
    t0 = 0.5 * c / b;
  } // calculate position


  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));
  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));
}

function cubic(t, x0, x1, x2, x3) {
  const s = 1 - t,
        s2 = s * s,
        t2 = t * t;
  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;
}

var context = (context = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(1, 1)) ? context.getContext('2d') : null;

const b = new Bounds();
function intersectPath(draw) {
  return function (item, brush) {
    // rely on (inaccurate) bounds intersection if no context
    if (!context) return true; // add path to offscreen graphics context

    draw(context, item); // get bounds intersection region

    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1,
      y1,
      x2,
      y2
    } = b; // iterate over intersection region
    // perform fine grained inclusion test

    for (let y = y1; y <= y2; ++y) {
      for (let x = x1; x <= x2; ++x) {
        if (context.isPointInPath(x, y)) {
          return true;
        }
      }
    } // false if no hits in intersection region


    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x = item.x || 0,
        y = item.y || 0,
        w = item.width || 0,
        h = item.height || 0;
  return box.intersects(b.set(x, y, x + w, y + h));
}
function intersectRule(item, box) {
  const x = item.x || 0,
        y = item.y || 0,
        x2 = item.x2 != null ? item.x2 : x,
        y2 = item.y2 != null ? item.y2 : y;
  return intersectBoxLine(box, x, y, x2, y2);
}
function intersectBoxLine(box, x, y, u, v) {
  const {
    x1,
    y1,
    x2,
    y2
  } = box,
        dx = u - x,
        dy = v - y;
  let t0 = 0,
      t1 = 1,
      p,
      q,
      r,
      e;

  for (e = 0; e < 4; ++e) {
    if (e === 0) {
      p = -dx;
      q = -(x1 - x);
    }

    if (e === 1) {
      p = dx;
      q = x2 - x;
    }

    if (e === 2) {
      p = -dy;
      q = -(y1 - y);
    }

    if (e === 3) {
      p = dy;
      q = y2 - y;
    }

    if (Math.abs(p) < 1e-10 && q < 0) return false;
    r = q / p;

    if (p < 0) {
      if (r > t1) return false;else if (r > t0) t0 = r;
    } else if (p > 0) {
      if (r < t0) return false;else if (r < t1) t1 = r;
    }
  }

  return true;
}

function blend (context, item) {
  context.globalCompositeOperation = item.blend || 'source-over';
}

function value (value, dflt) {
  return value == null ? dflt : value;
}

function addStops(gradient, stops) {
  const n = stops.length;

  for (let i = 0; i < n; ++i) {
    gradient.addColorStop(stops[i].offset, stops[i].color);
  }

  return gradient;
}

function gradient (context, spec, bounds) {
  const w = bounds.width(),
        h = bounds.height();
  let gradient;

  if (spec.gradient === 'radial') {
    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));
  } else {
    // linear gradient
    const x1 = value(spec.x1, 0),
          y1 = value(spec.y1, 0),
          x2 = value(spec.x2, 1),
          y2 = value(spec.y2, 0);

    if (x1 === x2 || y1 === y2 || w === h) {
      // axis aligned: use normal gradient
      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);
    } else {
      // not axis aligned: render gradient into a pattern (#2365)
      // this allows us to use normalized bounding box coordinates
      const image = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(Math.ceil(w), Math.ceil(h)),
            ictx = image.getContext('2d');
      ictx.scale(w, h);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);
      ictx.fillRect(0, 0, w, h);
      return context.createPattern(image, 'no-repeat');
    }
  }

  return addStops(gradient, spec.stops);
}

function color (context, item, value) {
  return isGradient(value) ? gradient(context, value, item.bounds) : value;
}

function fill (context, item, opacity) {
  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;

  if (opacity > 0) {
    context.globalAlpha = opacity;
    context.fillStyle = color(context, item, item.fill);
    return true;
  } else {
    return false;
  }
}

var Empty = [];
function stroke (context, item, opacity) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0) return false;
  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;

  if (opacity > 0) {
    context.globalAlpha = opacity;
    context.strokeStyle = color(context, item, item.stroke);
    context.lineWidth = lw;
    context.lineCap = item.strokeCap || 'butt';
    context.lineJoin = item.strokeJoin || 'miter';
    context.miterLimit = item.strokeMiterLimit || 10;

    if (context.setLineDash) {
      context.setLineDash(item.strokeDash || Empty);
      context.lineDashOffset = item.strokeDashOffset || 0;
    }

    return true;
  } else {
    return false;
  }
}

function compare(a, b) {
  return a.zindex - b.zindex || a.index - b.index;
}

function zorder(scene) {
  if (!scene.zdirty) return scene.zitems;
  var items = scene.items,
      output = [],
      item,
      i,
      n;

  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex) output.push(item);
  }

  scene.zdirty = false;
  return scene.zitems = output.sort(compare);
}
function visit(scene, visitor) {
  var items = scene.items,
      i,
      n;
  if (!items || !items.length) return;
  const zitems = zorder(scene);

  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex) visitor(items[i]);
    }

    items = zitems;
  }

  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit(scene, visitor) {
  var items = scene.items,
      hit,
      i;
  if (!items || !items.length) return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length) items = zitems;

  for (i = items.length; --i >= 0;) {
    if (hit = visitor(items[i])) return hit;
  }

  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0;) {
      if (!items[i].zindex) {
        if (hit = visitor(items[i])) return hit;
      }
    }
  }

  return null;
}

function drawAll(path) {
  return function (context, scene, bounds) {
    visit(scene, item => {
      if (!bounds || bounds.intersects(item.bounds)) {
        drawPath(path, context, item, item);
      }
    });
  };
}
function drawOne(path) {
  return function (context, scene, bounds) {
    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {
      drawPath(path, context, scene.items[0], scene.items);
    }
  };
}

function drawPath(path, context, item, items) {
  var opacity = item.opacity == null ? 1 : item.opacity;
  if (opacity === 0) return;
  if (path(context, items)) return;
  blend(context, item);

  if (item.fill && fill(context, item, opacity)) {
    context.fill();
  }

  if (item.stroke && stroke(context, item, opacity)) {
    context.stroke();
  }
}

function pick$1(test) {
  test = test || vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy;
  return function (context, scene, x, y, gx, gy) {
    x *= context.pixelRatio;
    y *= context.pixelRatio;
    return pickVisit(scene, item => {
      const b = item.bounds; // first hit test against bounding box

      if (b && !b.contains(gx, gy) || !b) return; // if in bounding box, perform more careful test

      if (test(context, item, x, y, gx, gy)) return item;
    });
  };
}
function hitPath(path, filled) {
  return function (context, o, x, y) {
    var item = Array.isArray(o) ? o[0] : o,
        fill = filled == null ? item.fill : filled,
        stroke = item.stroke && context.isPointInStroke,
        lw,
        lc;

    if (stroke) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context.lineWidth = lw != null ? lw : 1;
      context.lineCap = lc != null ? lc : 'butt';
    }

    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);
  };
}
function pickPath(path) {
  return pick$1(hitPath(path));
}

function translate(x, y) {
  return 'translate(' + x + ',' + y + ')';
}
function rotate(a) {
  return 'rotate(' + a + ')';
}
function scale(scaleX, scaleY) {
  return 'scale(' + scaleX + ',' + scaleY + ')';
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');
}

function markItemPath (type, shape, isect) {
  function attr(emit, item) {
    emit('transform', rotateItem(item));
    emit('d', shape(null, item));
  }

  function bound(bounds, item) {
    shape(boundContext(bounds, item.angle), item);
    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);
  }

  function draw(context, item) {
    var x = item.x || 0,
        y = item.y || 0,
        a = item.angle || 0;
    context.translate(x, y);
    if (a) context.rotate(a *= DegToRad);
    context.beginPath();
    shape(context, item);
    if (a) context.rotate(-a);
    context.translate(-x, -y);
  }

  return {
    type: type,
    tag: 'path',
    nested: false,
    attr: attr,
    bound: bound,
    draw: drawAll(draw),
    pick: pickPath(draw),
    isect: isect || intersectPath(draw)
  };
}

var arc = markItemPath('arc', arc$1);

function pickArea(a, p) {
  var v = a[0].orient === 'horizontal' ? p[1] : p[0],
      z = a[0].orient === 'horizontal' ? 'y' : 'x',
      i = a.length,
      min = +Infinity,
      hit,
      d;

  while (--i >= 0) {
    if (a[i].defined === false) continue;
    d = Math.abs(a[i][z] - v);

    if (d < min) {
      min = d;
      hit = a[i];
    }
  }

  return hit;
}
function pickLine(a, p) {
  var t = Math.pow(a[0].strokeWidth || 1, 2),
      i = a.length,
      dx,
      dy,
      dd;

  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t) return a[i];
  }

  return null;
}
function pickTrail(a, p) {
  var i = a.length,
      dx,
      dy,
      dd;

  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a[i].size || 1;
    if (dd < dx * dx) return a[i];
  }

  return null;
}

function markMultiItemPath (type, shape, tip) {
  function attr(emit, item) {
    var items = item.mark.items;
    if (items.length) emit('d', shape(null, items));
  }

  function bound(bounds, mark) {
    var items = mark.items;

    if (items.length === 0) {
      return bounds;
    } else {
      shape(boundContext(bounds), items);
      return boundStroke(bounds, items[0]);
    }
  }

  function draw(context, items) {
    context.beginPath();
    shape(context, items);
  }

  const hit = hitPath(draw);

  function pick(context, scene, x, y, gx, gy) {
    var items = scene.items,
        b = scene.bounds;

    if (!items || !items.length || b && !b.contains(gx, gy)) {
      return null;
    }

    x *= context.pixelRatio;
    y *= context.pixelRatio;
    return hit(context, items, x, y) ? items[0] : null;
  }

  return {
    type: type,
    tag: 'path',
    nested: true,
    attr: attr,
    bound: bound,
    draw: drawOne(draw),
    pick: pick,
    isect: intersectPoint,
    tip: tip
  };
}

var area = markMultiItemPath('area', area$1, pickArea);

function clip (context, scene) {
  var clip = scene.clip;
  context.save();

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    context.beginPath();
    clip(context);
    context.clip();
  } else {
    clipGroup(context, scene.group);
  }
}
function clipGroup(context, group) {
  context.beginPath();
  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);
  context.clip();
}

function offset$1(item) {
  const sw = value(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}

function attr$5(emit, item) {
  emit('transform', translateItem(item));
}

function emitRectangle(emit, item) {
  const off = offset$1(item);
  emit('d', rectangle(null, item, off, off));
}

function background(emit, item) {
  emit('class', 'background');
  emit('aria-hidden', true);
  emitRectangle(emit, item);
}

function foreground(emit, item) {
  emit('class', 'foreground');
  emit('aria-hidden', true);

  if (item.strokeForeground) {
    emitRectangle(emit, item);
  } else {
    emit('d', '');
  }
}

function content(emit, item, renderer) {
  const url = item.clip ? clip$1(renderer, item, item) : null;
  emit('clip-path', url);
}

function bound$5(bounds, group) {
  if (!group.clip && group.items) {
    const items = group.items,
          m = items.length;

    for (let j = 0; j < m; ++j) {
      bounds.union(items[j].bounds);
    }
  }

  if ((group.clip || group.width || group.height) && !group.noBound) {
    bounds.add(0, 0).add(group.width || 0, group.height || 0);
  }

  boundStroke(bounds, group);
  return bounds.translate(group.x || 0, group.y || 0);
}

function rectanglePath(context, group, x, y) {
  const off = offset$1(group);
  context.beginPath();
  rectangle(context, group, (x || 0) + off, (y || 0) + off);
}

const hitBackground = hitPath(rectanglePath);
const hitForeground = hitPath(rectanglePath, false);
const hitCorner = hitPath(rectanglePath, true);

function draw$4(context, scene, bounds) {
  visit(scene, group => {
    const gx = group.x || 0,
          gy = group.y || 0,
          fore = group.strokeForeground,
          opacity = group.opacity == null ? 1 : group.opacity; // draw group background

    if ((group.stroke || group.fill) && opacity) {
      rectanglePath(context, group, gx, gy);
      blend(context, group);

      if (group.fill && fill(context, group, opacity)) {
        context.fill();
      }

      if (group.stroke && !fore && stroke(context, group, opacity)) {
        context.stroke();
      }
    } // setup graphics context, set clip and bounds


    context.save();
    context.translate(gx, gy);
    if (group.clip) clipGroup(context, group);
    if (bounds) bounds.translate(-gx, -gy); // draw group contents

    visit(group, item => {
      this.draw(context, item, bounds);
    }); // restore graphics context

    if (bounds) bounds.translate(gx, gy);
    context.restore(); // draw group foreground

    if (fore && group.stroke && opacity) {
      rectanglePath(context, group, gx, gy);
      blend(context, group);

      if (stroke(context, group, opacity)) {
        context.stroke();
      }
    }
  });
}

function pick(context, scene, x, y, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }

  const cx = x * context.pixelRatio,
        cy = y * context.pixelRatio;
  return pickVisit(scene, group => {
    let hit, dx, dy; // first hit test bounding box

    const b = group.bounds;
    if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip

    dx = group.x || 0;
    dy = group.y || 0;
    const dw = dx + (group.width || 0),
          dh = dy + (group.height || 0),
          c = group.clip;
    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return; // adjust coordinate system

    context.save();
    context.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy; // test background for rounded corner clip

    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {
      context.restore();
      return null;
    }

    const fore = group.strokeForeground,
          ix = scene.interactive !== false; // hit test against group foreground

    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {
      context.restore();
      return group;
    } // hit test against contained marks


    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null); // hit test against group background

    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {
      hit = group;
    } // restore state and return


    context.restore();
    return hit || null;
  });
}

function pickMark(mark, x, y) {
  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);
}

var group = {
  type: 'group',
  tag: 'g',
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick: pick,
  isect: intersectRect,
  content: content,
  background: background,
  foreground: foreground
};

var metadata = {
  'xmlns': 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  'version': '1.1'
};

function getImage(item, renderer) {
  var image = item.image;

  if (!image || item.url && item.url !== image.url) {
    image = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then(image => {
      item.image = image;
      item.image.url = item.url;
    });
  }

  return image;
}

function imageWidth(item, image) {
  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;
}

function imageHeight(item, image) {
  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;
}

function imageXOffset(align, w) {
  return align === 'center' ? w / 2 : align === 'right' ? w : 0;
}

function imageYOffset(baseline, h) {
  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;
}

function attr$4(emit, item, renderer) {
  const img = getImage(item, renderer),
        w = imageWidth(item, img),
        h = imageHeight(item, img),
        x = (item.x || 0) - imageXOffset(item.align, w),
        y = (item.y || 0) - imageYOffset(item.baseline, h),
        i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';
  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');
  emit('transform', translate(x, y));
  emit('width', w);
  emit('height', h);
  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');
}

function bound$4(bounds, item) {
  const img = item.image,
        w = imageWidth(item, img),
        h = imageHeight(item, img),
        x = (item.x || 0) - imageXOffset(item.align, w),
        y = (item.y || 0) - imageYOffset(item.baseline, h);
  return bounds.set(x, y, x + w, y + h);
}

function draw$3(context, scene, bounds) {
  visit(scene, item => {
    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check

    const img = getImage(item, this);
    let w = imageWidth(item, img);
    let h = imageHeight(item, img);
    if (w === 0 || h === 0) return; // early exit

    let x = (item.x || 0) - imageXOffset(item.align, w),
        y = (item.y || 0) - imageYOffset(item.baseline, h),
        opacity,
        ar0,
        ar1,
        t;

    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;

      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w / ar0;
          y += (h - t) / 2;
          h = t;
        } else {
          t = h * ar0;
          x += (w - t) / 2;
          w = t;
        }
      }
    }

    if (img.complete || img.toDataURL) {
      blend(context, item);
      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;
      context.imageSmoothingEnabled = item.smooth !== false;
      context.drawImage(img, x, y, w, h);
    }
  });
}

var image = {
  type: 'image',
  tag: 'image',
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick$1(),
  isect: vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy,
  // bounds check is sufficient
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};

var line = markMultiItemPath('line', line$1, pickLine);

function attr$3(emit, item) {
  var sx = item.scaleX || 1,
      sy = item.scaleY || 1;

  if (sx !== 1 || sy !== 1) {
    emit('vector-effect', 'non-scaling-stroke');
  }

  emit('transform', transformItem(item));
  emit('d', item.path);
}

function path$1(context, item) {
  var path = item.path;
  if (path == null) return true;
  var x = item.x || 0,
      y = item.y || 0,
      sx = item.scaleX || 1,
      sy = item.scaleY || 1,
      a = (item.angle || 0) * DegToRad,
      cache = item.pathCache;

  if (!cache || cache.path !== path) {
    (item.pathCache = cache = pathParse(path)).path = path;
  }

  if (a && context.rotate && context.translate) {
    context.translate(x, y);
    context.rotate(a);
    pathRender(context, cache, 0, 0, sx, sy);
    context.rotate(-a);
    context.translate(-x, -y);
  } else {
    pathRender(context, cache, x, y, sx, sy);
  }
}

function bound$3(bounds, item) {
  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);
}

var path$2 = {
  type: 'path',
  tag: 'path',
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(path$1),
  pick: pickPath(path$1),
  isect: intersectPath(path$1)
};

function attr$2(emit, item) {
  emit('d', rectangle(null, item));
}

function bound$2(bounds, item) {
  var x, y;
  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);
}

function draw$2(context, item) {
  context.beginPath();
  rectangle(context, item);
}

var rect = {
  type: 'rect',
  tag: 'path',
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};

function attr$1(emit, item) {
  emit('transform', translateItem(item));
  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);
}

function bound$1(bounds, item) {
  var x1, y1;
  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);
}

function path(context, item, opacity) {
  var x1, y1, x2, y2;

  if (item.stroke && stroke(context, item, opacity)) {
    x1 = item.x || 0;
    y1 = item.y || 0;
    x2 = item.x2 != null ? item.x2 : x1;
    y2 = item.y2 != null ? item.y2 : y1;
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    return true;
  }

  return false;
}

function draw$1(context, scene, bounds) {
  visit(scene, item => {
    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check

    var opacity = item.opacity == null ? 1 : item.opacity;

    if (opacity && path(context, item, opacity)) {
      blend(context, item);
      context.stroke();
    }
  });
}

function hit$1(context, item, x, y) {
  if (!context.isPointInStroke) return false;
  return path(context, item, 1) && context.isPointInStroke(x, y);
}

var rule = {
  type: 'rule',
  tag: 'line',
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick$1(hit$1),
  isect: intersectRule
};

var shape = markItemPath('shape', shape$1);

var symbol = markItemPath('symbol', symbol$1, intersectPoint);

const widthCache = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.lruCache)();
var textMetrics = {
  height: fontSize,
  measureWidth: measureWidth,
  estimateWidth: estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);

function useCanvas(use) {
  textMetrics.width = use && context ? measureWidth : estimateWidth;
} // make simple estimate if no canvas is available


function estimateWidth(item, text) {
  return _estimateWidth(textValue(item, text), fontSize(item));
}

function _estimateWidth(text, currentFontHeight) {
  return ~~(0.8 * text.length * currentFontHeight);
} // measure text width if canvas is available


function measureWidth(item, text) {
  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));
}

function _measureWidth(text, currentFont) {
  const key = `(${currentFont}) ${text}`;
  let width = widthCache.get(key);

  if (width === undefined) {
    context.font = currentFont;
    width = context.measureText(text).width;
    widthCache.set(key, width);
  }

  return width;
}

function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}

function lineArray(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.length > 1 ? _ : _[0] : _;
}

function textLines(item) {
  return lineArray(item.lineBreak && item.text && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl = textLines(item);
  return ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl) ? tl.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line) {
  const text = line == null ? '' : (line + '').trim();
  return item.limit > 0 && text.length ? truncate(item, text) : text;
}

function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    // we are using canvas
    const currentFont = font(item);
    return text => _measureWidth(text, currentFont);
  } else {
    // we are relying on estimates
    const currentFontHeight = fontSize(item);
    return text => _estimateWidth(text, currentFontHeight);
  }
}

function truncate(item, text) {
  var limit = +item.limit,
      width = widthGetter(item);
  if (width(text) < limit) return text;
  var ellipsis = item.ellipsis || '\u2026',
      rtl = item.dir === 'rtl',
      lo = 0,
      hi = text.length,
      mid;
  limit -= width(ellipsis);

  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;
    }

    return ellipsis + text.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;
    }

    return text.slice(0, lo) + ellipsis;
  }
}

function fontFamily(item, quote) {
  var font = item.font;
  return (quote && font ? String(font).replace(/"/g, '\'') : font) || 'sans-serif';
}
function font(item, quote) {
  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);
}
function offset(item) {
  // perform our own font baseline calculation
  // why? not all browsers support SVG 1.1 'alignment-baseline' :(
  // this also ensures consistent layout across renderers
  var baseline = item.baseline,
      h = fontSize(item);
  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);
}

const textAlign = {
  'left': 'start',
  'center': 'middle',
  'right': 'end'
};
const tempBounds = new Bounds();

function anchorPoint(item) {
  var x = item.x || 0,
      y = item.y || 0,
      r = item.radius || 0,
      t;

  if (r) {
    t = (item.theta || 0) - HalfPi;
    x += r * Math.cos(t);
    y += r * Math.sin(t);
  }

  tempBounds.x1 = x;
  tempBounds.y1 = y;
  return tempBounds;
}

function attr(emit, item) {
  var dx = item.dx || 0,
      dy = (item.dy || 0) + offset(item),
      p = anchorPoint(item),
      x = p.x1,
      y = p.y1,
      a = item.angle || 0,
      t;
  emit('text-anchor', textAlign[item.align] || 'start');

  if (a) {
    t = translate(x, y) + ' ' + rotate(a);
    if (dx || dy) t += ' ' + translate(dx, dy);
  } else {
    t = translate(x + dx, y + dy);
  }

  emit('transform', t);
}

function bound(bounds, item, mode) {
  var h = textMetrics.height(item),
      a = item.align,
      p = anchorPoint(item),
      x = p.x1,
      y = p.y1,
      dx = item.dx || 0,
      dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),
      // use 4/5 offset
  tl = textLines(item),
      w; // get dimensions

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
    // multi-line text
    h += lineHeight(item) * (tl.length - 1);
    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);
  } else {
    // single-line text
    w = textMetrics.width(item, tl);
  } // horizontal alignment


  if (a === 'center') {
    dx -= w / 2;
  } else if (a === 'right') {
    dx -= w;
  } else ;

  bounds.set(dx += x, dy += y, dx + w, dy + h);

  if (item.angle && !mode) {
    bounds.rotate(item.angle * DegToRad, x, y);
  } else if (mode === 2) {
    return bounds.rotatedPoints(item.angle * DegToRad, x, y);
  }

  return bounds;
}

function draw(context, scene, bounds) {
  visit(scene, item => {
    var opacity = item.opacity == null ? 1 : item.opacity,
        p,
        x,
        y,
        i,
        lh,
        tl,
        str;
    if (bounds && !bounds.intersects(item.bounds) || // bounds check
    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;
    context.font = font(item);
    context.textAlign = item.align || 'left';
    p = anchorPoint(item);
    x = p.x1, y = p.y1;

    if (item.angle) {
      context.save();
      context.translate(x, y);
      context.rotate(item.angle * DegToRad);
      x = y = 0; // reset x, y
    }

    x += item.dx || 0;
    y += (item.dy || 0) + offset(item);
    tl = textLines(item);
    blend(context, item);

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
      lh = lineHeight(item);

      for (i = 0; i < tl.length; ++i) {
        str = textValue(item, tl[i]);

        if (item.fill && fill(context, item, opacity)) {
          context.fillText(str, x, y);
        }

        if (item.stroke && stroke(context, item, opacity)) {
          context.strokeText(str, x, y);
        }

        y += lh;
      }
    } else {
      str = textValue(item, tl);

      if (item.fill && fill(context, item, opacity)) {
        context.fillText(str, x, y);
      }

      if (item.stroke && stroke(context, item, opacity)) {
        context.strokeText(str, x, y);
      }
    }

    if (item.angle) context.restore();
  });
}

function hit(context, item, x, y, gx, gy) {
  if (item.fontSize <= 0) return false;
  if (!item.angle) return true; // bounds sufficient if no rotation
  // project point into space of unrotated bounds

  var p = anchorPoint(item),
      ax = p.x1,
      ay = p.y1,
      b = bound(tempBounds, item, 1),
      a = -item.angle * DegToRad,
      cos = Math.cos(a),
      sin = Math.sin(a),
      px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),
      py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);
  return b.contains(px, py);
}

function intersectText(item, box) {
  const p = bound(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}

var text = {
  type: 'text',
  tag: 'text',
  nested: false,
  attr: attr,
  bound: bound,
  draw: draw,
  pick: pick$1(hit),
  isect: intersectText
};

var trail = markMultiItemPath('trail', trail$1, pickTrail);

var Marks = {
  arc: arc,
  area: area,
  group: group,
  image: image,
  line: line,
  path: path$2,
  rect: rect,
  rule: rule,
  shape: shape,
  symbol: symbol,
  text: text,
  trail: trail
};

function boundItem (item, func, opt) {
  var type = Marks[item.mark.marktype],
      bound = func || type.bound;
  if (type.nested) item = item.mark;
  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);
}

var DUMMY = {
  mark: null
};
function boundMark (mark, bounds, opt) {
  var type = Marks[mark.marktype],
      bound = type.bound,
      items = mark.items,
      hasItems = items && items.length,
      i,
      n,
      item,
      b;

  if (type.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      // no items, fake it
      DUMMY.mark = mark;
      item = DUMMY;
    }

    b = boundItem(item, bound, opt);
    bounds = bounds && bounds.union(b) || b;
    return bounds;
  }

  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();

  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds.union(boundItem(items[i], bound, opt));
    }
  }

  return mark.bounds = bounds;
}

const keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline', // layout
'fill', 'fillOpacity', 'opacity', 'blend', // fill
'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap', // stroke
'strokeDash', 'strokeDashOffset', // stroke dash
'strokeForeground', 'strokeOffset', // group
'startAngle', 'endAngle', 'innerRadius', 'outerRadius', // arc
'cornerRadius', 'padAngle', // arc, rect
'cornerRadiusTopLeft', 'cornerRadiusTopRight', // rect, group
'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined', // area, line
'url', 'aspect', 'smooth', // image
'path', 'scaleX', 'scaleY', // path
'x2', 'y2', // rule
'size', 'shape', // symbol
'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy', // text
'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font
'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json) {
  const scene = typeof json === 'string' ? JSON.parse(json) : json;
  return initialize(scene);
}

function initialize(scene) {
  var type = scene.marktype,
      items = scene.items,
      parent,
      i,
      n;

  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type ? 'mark' : 'group';
      items[i][parent] = scene;
      if (items[i].zindex) items[i][parent].zdirty = true;
      if ('group' === (type || parent)) initialize(items[i]);
    }
  }

  if (type) boundMark(scene);
  return scene;
}

function Scenegraph(scene) {
  if (arguments.length) {
    this.root = sceneFromJSON(scene);
  } else {
    this.root = createMark({
      marktype: 'group',
      name: 'root',
      role: 'frame'
    });
    this.root.items = [new GroupItem(this.root)];
  }
}
Scenegraph.prototype = {
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  },

  mark(markdef, group, index) {
    group = group || this.root.items[0];
    const mark = createMark(markdef, group);
    group.items[index] = mark;
    if (mark.zindex) mark.group.zdirty = true;
    return mark;
  }

};

function createMark(def, group) {
  const mark = {
    bounds: new Bounds(),
    clip: !!def.clip,
    group: group,
    interactive: def.interactive === false ? false : true,
    items: [],
    marktype: def.marktype,
    name: def.name || undefined,
    role: def.role || undefined,
    zindex: def.zindex || 0
  }; // add accessibility properties if defined

  if (def.aria != null) {
    mark.aria = def.aria;
  }

  if (def.description) {
    mark.description = def.description;
  }

  return mark;
}

// create a new DOM element
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== 'undefined' && document.createElement) {
    doc = document;
  }

  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
} // find first child element with matching tag

function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes,
      i = 0,
      n = nodes.length;

  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {
    return nodes[i];
  }
} // retrieve child element at given index
// create & insert if doesn't exist or if tags do not match

function domChild(el, index, tag, ns) {
  var a = el.childNodes[index],
      b;

  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {
    b = a || null;
    a = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a, b);
  }

  return a;
} // remove all child elements at or above the given index

function domClear(el, index) {
  var nodes = el.childNodes,
      curr = nodes.length;

  while (curr > index) el.removeChild(nodes[--curr]);

  return el;
} // generate css class name for mark

function cssClass(mark) {
  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');
}

function point (event, el) {
  const rect = el.getBoundingClientRect();
  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];
}

function resolveItem (item, event, el, origin) {
  var mark = item && item.mark,
      mdef,
      p;

  if (mark && (mdef = Marks[mark.marktype]).tip) {
    p = point(event, el);
    p[0] -= origin[0];
    p[1] -= origin[1];

    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }

    item = mdef.tip(mark.items, p);
  }

  return item;
}

/**
 * Create a new Handler instance.
 * @param {object} [customLoader] - Optional loader instance for
 *   href URL sanitization. If not specified, a standard loader
 *   instance will be generated.
 * @param {function} [customTooltip] - Optional tooltip handler
 *   function for custom tooltip display.
 * @constructor
 */

function Handler(customLoader, customTooltip) {
  this._active = null;
  this._handlers = {};
  this._loader = customLoader || (0,vega_loader__WEBPACK_IMPORTED_MODULE_2__.loader)();
  this._tooltip = customTooltip || defaultTooltip;
} // The default tooltip display handler.
// Sets the HTML title attribute on the visualization container.

function defaultTooltip(handler, event, item, value) {
  handler.element().setAttribute('title', value || '');
}

Handler.prototype = {
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  },

  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },

  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },

  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  },

  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length) return this._scene;
    this._scene = scene;
    return this;
  },

  /**
   * Add an event handler. Subclasses should override this method.
   */
  on()
  /*type, handler*/
  {},

  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off()
  /*type, handler*/
  {},

  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h, type, handler) {
    for (let i = h ? h.length : 0; --i >= 0;) {
      if (h[i].type === type && (!handler || h[i].handler === handler)) {
        return i;
      }
    }

    return -1;
  },

  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type) {
    const h = this._handlers,
          a = [];

    if (type) {
      a.push(...h[this.eventName(type)]);
    } else {
      for (const k in h) {
        a.push(...h[k]);
      }
    }

    return a;
  },

  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf('.');
    return i < 0 ? name : name.slice(0, i);
  },

  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event, item, href) {
    this._loader.sanitize(href, {
      context: 'href'
    }).then(opt => {
      const e = new MouseEvent(event.type, event),
            a = domCreate(null, 'a');

      for (const name in opt) a.setAttribute(name, opt[name]);

      a.dispatchEvent(e);
    }).catch(() => {
      /* do nothing */
    });
  },

  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event, this.canvas(), this._origin);
      const value = show && item && item.tooltip || null;

      this._tooltip.call(this._obj, this, event, item, value);
    }
  },

  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el) return;
    const rect = el.getBoundingClientRect(),
          origin = this._origin,
          bounds = item.bounds,
          width = bounds.width(),
          height = bounds.height();
    let x = bounds.x1 + origin[0] + rect.left,
        y = bounds.y1 + origin[1] + rect.top; // translate coordinate for each parent group

    while (item.mark && (item = item.mark.group)) {
      x += item.x || 0;
      y += item.y || 0;
    } // return DOMRect-compatible bounding box


    return {
      x,
      y,
      width,
      height,
      left: x,
      top: y,
      right: x + width,
      bottom: y + height
    };
  }

};

/**
 * Create a new Renderer instance.
 * @param {object} [loader] - Optional loader instance for
 *   image and href URL sanitization. If not specified, a
 *   standard loader instance will be generated.
 * @constructor
 */

function Renderer(loader) {
  this._el = null;
  this._bgcolor = null;
  this._loader = new ResourceLoader(loader);
}
Renderer.prototype = {
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width, height, origin, scaleFactor) {
    this._el = el;
    return this.resize(width, height, origin, scaleFactor);
  },

  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },

  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },

  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0) return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  },

  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width, height, origin, scaleFactor) {
    this._width = width;
    this._height = height;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  },

  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty()
  /*item*/
  {},

  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Renderer} - This renderer instance.
   */
  render(scene) {
    const r = this; // bind arguments into a render call, and cache it
    // this function may be subsequently called for async redraw

    r._call = function () {
      r._render(scene);
    }; // invoke the renderer


    r._call(); // clear the cached call for garbage collection
    // async redraws will stash their own copy


    r._call = null;
    return r;
  },

  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render()
  /*scene*/
  {// subclasses to override
  },

  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene) {
    const r = this.render(scene);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  },

  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method, uri) {
    var r = this,
        p = r._loader[method](uri);

    if (!r._ready) {
      // re-render the scene when loading completes
      const call = r._call;
      r._ready = r._loader.ready().then(redraw => {
        if (redraw) call();
        r._ready = null;
      });
    }

    return p;
  },

  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load('sanitizeURL', uri);
  },

  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load('loadImage', uri);
  }

};

const KeyDownEvent = 'keydown';
const KeyPressEvent = 'keypress';
const KeyUpEvent = 'keyup';
const DragEnterEvent = 'dragenter';
const DragLeaveEvent = 'dragleave';
const DragOverEvent = 'dragover';
const MouseDownEvent = 'mousedown';
const MouseUpEvent = 'mouseup';
const MouseMoveEvent = 'mousemove';
const MouseOutEvent = 'mouseout';
const MouseOverEvent = 'mouseover';
const ClickEvent = 'click';
const DoubleClickEvent = 'dblclick';
const WheelEvent = 'wheel';
const MouseWheelEvent = 'mousewheel';
const TouchStartEvent = 'touchstart';
const TouchMoveEvent = 'touchmove';
const TouchEndEvent = 'touchend';
const Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
const TooltipShowEvent = MouseMoveEvent;
const TooltipHideEvent = MouseOutEvent;
const HrefEvent = ClickEvent;

function CanvasHandler(loader, tooltip) {
  Handler.call(this, loader, tooltip);
  this._down = null;
  this._touch = null;
  this._first = true;
  this._events = {};
}

const eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type]; // lazily add listeners to the canvas as needed


function eventListenerCheck(handler, type) {
  eventBundle(type).forEach(_ => addEventListener(handler, _));
}

function addEventListener(handler, type) {
  const canvas = handler.canvas();

  if (canvas && !handler._events[type]) {
    handler._events[type] = 1;
    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));
  }
}

function move(moveEvent, overEvent, outEvent) {
  return function (evt) {
    const a = this._active,
          p = this.pickEvent(evt);

    if (p === a) {
      // active item and picked item are the same
      this.fire(moveEvent, evt); // fire move
    } else {
      // active item and picked item are different
      if (!a || !a.exit) {
        // fire out for prior active item
        // suppress if active item was removed from scene
        this.fire(outEvent, evt);
      }

      this._active = p; // set new active item

      this.fire(overEvent, evt); // fire over for new active item

      this.fire(moveEvent, evt); // fire move for new active item
    }
  };
}

function inactive(type) {
  return function (evt) {
    this.fire(type, evt);
    this._active = null;
  };
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CanvasHandler, Handler, {
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, 'canvas'); // add minimal events required for proper state management

    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));
    return Handler.prototype.initialize.call(this, el, origin, obj);
  },

  // return the backing canvas instance
  canvas() {
    return this._canvas;
  },

  // retrieve the current canvas context
  context() {
    return this._canvas.getContext('2d');
  },

  // supported events
  events: Events,

  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  },

  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),
  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),
  mouseout: inactive(MouseOutEvent),
  dragleave: inactive(DragLeaveEvent),

  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  },

  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  },

  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);

    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }

    this.fire(TouchStartEvent, evt, true);
  },

  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  },

  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  },

  // fire an event
  fire(type, evt, touch) {
    const a = touch ? this._touch : this._active,
          h = this._handlers[type]; // set event type relative to scenegraph items

    evt.vegaType = type; // handle hyperlinks and tooltips first

    if (type === HrefEvent && a && a.href) {
      this.handleHref(evt, a, a.href);
    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {
      this.handleTooltip(evt, a, type !== TooltipHideEvent);
    } // invoke all registered handlers


    if (h) {
      for (let i = 0, len = h.length; i < len; ++i) {
        h[i].handler.call(this._obj, evt, a);
      }
    }
  },

  // add an event handler
  on(type, handler) {
    const name = this.eventName(type),
          h = this._handlers,
          i = this._handlerIndex(h[name], type, handler);

    if (i < 0) {
      eventListenerCheck(this, type);
      (h[name] || (h[name] = [])).push({
        type: type,
        handler: handler
      });
    }

    return this;
  },

  // remove an event handler
  off(type, handler) {
    const name = this.eventName(type),
          h = this._handlers[name],
          i = this._handlerIndex(h, type, handler);

    if (i >= 0) {
      h.splice(i, 1);
    }

    return this;
  },

  pickEvent(evt) {
    const p = point(evt, this._canvas),
          o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  },

  // find the scenegraph item at the current mouse position
  // x, y -- the absolute x, y mouse coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x, y, gx, gy) {
    const g = this.context(),
          mark = Marks[scene.marktype];
    return mark.pick.call(this, g, scene, x, y, gx, gy);
  }

});

function devicePixelRatio() {
  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;
}

var pixelRatio = devicePixelRatio();
function resize (canvas, width, height, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,
        context = canvas.getContext('2d'),
        ratio = inDOM ? pixelRatio : scaleFactor;
  canvas.width = width * ratio;
  canvas.height = height * ratio;

  for (const key in opt) {
    context[key] = opt[key];
  }

  if (inDOM && ratio !== 1) {
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  context.pixelRatio = ratio;
  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}

function CanvasRenderer(loader) {
  Renderer.call(this, loader);
  this._options = {};
  this._redraw = false;
  this._dirty = new Bounds();
  this._tempb = new Bounds();
}
const base$1 = Renderer.prototype;

const viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);

function clipToBounds(g, b, origin) {
  // expand bounds by 1 pixel, then round to pixel boundaries
  b.expand(1).round(); // align to base pixel grid in case of non-integer scaling (#2425)

  if (g.pixelRatio % 1) {
    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  } // to avoid artifacts translate if origin has fractional pixels


  b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clip path

  g.beginPath();
  g.rect(b.x1, b.y1, b.width(), b.height());
  g.clip();
  return b;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CanvasRenderer, Renderer, {
  initialize(el, width, height, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(1, 1, this._options.type); // instantiate a small canvas

    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);

      this._canvas.setAttribute('class', 'marks');
    } // this method will invoke resize to size the canvas appropriately


    return base$1.initialize.call(this, el, width, height, origin, scaleFactor);
  },

  resize(width, height, origin, scaleFactor) {
    base$1.resize.call(this, width, height, origin, scaleFactor);

    if (this._canvas) {
      // configure canvas size and transform
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      // external context needs to be scaled and positioned to origin
      const ctx = this._options.externalContext;
      if (!ctx) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('CanvasRenderer is missing a valid canvas or context');
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }

    this._redraw = true;
    return this;
  },

  canvas() {
    return this._canvas;
  },

  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);
  },

  dirty(item) {
    const b = this._tempb.clear().union(item.bounds);

    let g = item.mark.group;

    while (g) {
      b.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }

    this._dirty.union(b);
  },

  _render(scene) {
    const g = this.context(),
          o = this._origin,
          w = this._width,
          h = this._height,
          db = this._dirty,
          vb = viewBounds(o, w, h); // setup

    g.save();
    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w, h); // render

    this.draw(g, scene, b); // takedown

    g.restore();
    db.clear();
    return this;
  },

  draw(ctx, scene, bounds) {
    const mark = Marks[scene.marktype];
    if (scene.clip) clip(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds);
    if (scene.clip) ctx.restore();
  },

  clear(x, y, w, h) {
    const opt = this._options,
          g = this.context();

    if (opt.type !== 'pdf' && !opt.externalContext) {
      // calling clear rect voids vector output in pdf mode
      // and could remove external context content (#2615)
      g.clearRect(x, y, w, h);
    }

    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x, y, w, h);
    }
  }

});

function SVGHandler(loader, tooltip) {
  Handler.call(this, loader, tooltip);
  const h = this;
  h._hrefHandler = listener(h, (evt, item) => {
    if (item && item.href) h.handleHref(evt, item, item.href);
  });
  h._tooltipHandler = listener(h, (evt, item) => {
    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
  });
} // wrap an event listener for the SVG DOM

const listener = (context, handler) => evt => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context._obj, evt, item);
};

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(SVGHandler, Handler, {
  initialize(el, origin, obj) {
    let svg = this._svg;

    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }

    this._svg = svg = el && domFind(el, 'svg');

    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }

    return Handler.prototype.initialize.call(this, el, origin, obj);
  },

  canvas() {
    return this._svg;
  },

  // add an event handler
  on(type, handler) {
    const name = this.eventName(type),
          h = this._handlers,
          i = this._handlerIndex(h[name], type, handler);

    if (i < 0) {
      const x = {
        type,
        handler,
        listener: listener(this, handler)
      };
      (h[name] || (h[name] = [])).push(x);

      if (this._svg) {
        this._svg.addEventListener(name, x.listener);
      }
    }

    return this;
  },

  // remove an event handler
  off(type, handler) {
    const name = this.eventName(type),
          h = this._handlers[name],
          i = this._handlerIndex(h, type, handler);

    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h[i].listener);
      }

      h.splice(i, 1);
    }

    return this;
  }

});

const ARIA_HIDDEN = 'aria-hidden';
const ARIA_LABEL = 'aria-label';
const ARIA_ROLE = 'role';
const ARIA_ROLEDESCRIPTION = 'aria-roledescription';
const GRAPHICS_OBJECT = 'graphics-object';
const GRAPHICS_SYMBOL = 'graphics-symbol';

const bundle = (role, roledesc, label) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label || undefined
}); // these roles are covered by related roles
// we can ignore them, no need to generate attributes


const AriaIgnore = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']); // aria attribute generators for guide roles

const AriaGuides = {
  'axis': {
    desc: 'axis',
    caption: axisCaption
  },
  'legend': {
    desc: 'legend',
    caption: legendCaption
  },
  'title-text': {
    desc: 'title',
    caption: item => `Title text '${titleCaption(item)}'`
  },
  'title-subtitle': {
    desc: 'subtitle',
    caption: item => `Subtitle text '${titleCaption(item)}'`
  }
}; // aria properties generated for mark item encoding channels

const AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit, item) {
  const hide = item.aria === false;
  emit(ARIA_HIDDEN, hide || undefined);

  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit(AriaEncode[prop], undefined);
    }
  } else {
    const type = item.mark.marktype;
    emit(ARIA_LABEL, item.description);
    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type} mark`);
  }
}
function ariaMarkAttributes(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
}

function ariaMark(mark) {
  const type = mark.marktype;
  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);
  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type} mark container`, mark.description);
}

function ariaGuide(mark, opt) {
  try {
    const item = mark.items[0],
          caption = opt.caption || (() => '');

    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}

function titleCaption(item) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(item.text).join(' ');
}

function axisCaption(item) {
  const datum = item.datum,
        orient = item.orient,
        title = datum.title ? extractTitle(item) : null,
        ctx = item.context,
        scale = ctx.scales[datum.scale].value,
        locale = ctx.dataflow.locale(),
        type = scale.type,
        xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';
  return `${xy}-axis` + (title ? ` titled '${title}'` : '') + ` for a ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(type) ? 'discrete' : type} scale` + ` with ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.domainCaption)(locale, scale, item)}`;
}

function legendCaption(item) {
  const datum = item.datum,
        title = datum.title ? extractTitle(item) : null,
        type = `${datum.type || ''} legend`.trim(),
        scales = datum.scales,
        props = Object.keys(scales),
        ctx = item.context,
        scale = ctx.scales[scales[props[0]]].value,
        locale = ctx.dataflow.locale();
  return capitalize(type) + (title ? ` titled '${title}'` : '') + ` for ${channelCaption(props)}` + ` with ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.domainCaption)(locale, scale, item)}`;
}

function extractTitle(item) {
  try {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(item.items).items[0].text).join(' ');
  } catch (err) {
    return null;
  }
}

function channelCaption(props) {
  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(props);
}

function capitalize(s) {
  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
}

const innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

const attrText = val => innerText(val).replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');

function markup() {
  let buf = '',
      outer = '',
      inner = '';

  const stack = [],
        clear = () => outer = inner = '',
        push = tag => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear();
    }

    stack.push(tag);
  },
        attr = (name, value) => {
    if (value != null) outer += ` ${name}="${attrText(value)}"`;
    return m;
  },
        m = {
    open(tag, ...attrs) {
      push(tag);
      outer = '<' + tag;

      for (const set of attrs) {
        for (const key in set) attr(key, set[key]);
      }

      return m;
    },

    close() {
      const tag = stack.pop();

      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : '/>');
      } else {
        buf += `</${tag}>`;
      }

      clear();
      return m;
    },

    attr,
    text: t => (inner += innerText(t), m),
    toString: () => buf
  };

  return m;
}
const serializeXML = node => _serialize(markup(), node) + '';

function _serialize(m, node) {
  m.open(node.tagName);

  if (node.hasAttributes()) {
    const attrs = node.attributes,
          n = attrs.length;

    for (let i = 0; i < n; ++i) {
      m.attr(attrs[i].name, attrs[i].value);
    }
  }

  if (node.hasChildNodes()) {
    const children = node.childNodes,
          n = children.length;

    for (let i = 0; i < n; i++) {
      const child = children[i];
      child.nodeType === 3 // text node
      ? m.text(child.nodeValue) : _serialize(m, child);
    }
  }

  return m.close();
}

const styles = {
  fill: 'fill',
  fillOpacity: 'fill-opacity',
  stroke: 'stroke',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  strokeCap: 'stroke-linecap',
  strokeJoin: 'stroke-linejoin',
  strokeDash: 'stroke-dasharray',
  strokeDashOffset: 'stroke-dashoffset',
  strokeMiterLimit: 'stroke-miterlimit',
  opacity: 'opacity',
  blend: 'mix-blend-mode'
}; // ensure miter limit default is consistent with canvas (#2498)

const rootAttributes = {
  'fill': 'none',
  'stroke-miterlimit': 10
};

const RootIndex = 0,
      xmlns = 'http://www.w3.org/2000/xmlns/',
      svgns = metadata.xmlns;
function SVGRenderer(loader) {
  Renderer.call(this, loader);
  this._dirtyID = 0;
  this._dirty = [];
  this._svg = null;
  this._root = null;
  this._defs = null;
}
const base = Renderer.prototype;
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(SVGRenderer, Renderer, {
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width, height, origin, scaleFactor) {
    // create the svg definitions cache
    this._defs = {};

    this._clearDefs();

    if (el) {
      this._svg = domChild(el, 0, 'svg', svgns);

      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);

      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);

      this._svg.setAttribute('version', metadata['version']);

      this._svg.setAttribute('class', 'marks');

      domClear(el, 1); // set the svg root group

      this._root = domChild(this._svg, RootIndex, 'g', svgns);
      setAttributes(this._root, rootAttributes); // ensure no additional child elements

      domClear(this._svg, RootIndex + 1);
    } // set background color if defined


    this.background(this._bgcolor);
    return base.initialize.call(this, el, width, height, origin, scaleFactor);
  },

  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty('background-color', bgcolor);
    }

    return base.background.apply(this, arguments);
  },

  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width, height, origin, scaleFactor) {
    base.resize.call(this, width, height, origin, scaleFactor);

    if (this._svg) {
      setAttributes(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });

      this._root.setAttribute('transform', `translate(${this._origin})`);
    }

    this._dirty = [];
    return this;
  },

  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  },

  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg,
          bg = this._bgcolor;
    if (!svg) return null;
    let node;

    if (bg) {
      svg.removeAttribute('style');
      node = domChild(svg, RootIndex, 'rect', svgns);
      setAttributes(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }

    const text = serializeXML(svg);

    if (bg) {
      svg.removeChild(node);

      this._svg.style.setProperty('background-color', bg);
    }

    return text;
  },

  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    // perform spot updates and re-render markup
    if (this._dirtyCheck()) {
      if (this._dirtyAll) this._clearDefs();
      this.mark(this._root, scene);
      domClear(this._root, 1);
    }

    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  },

  // -- Manage rendering of items marked as dirty --

  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;

      this._dirty.push(item);
    }
  },

  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;
  },

  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID) return true;
    const id = ++this._dirtyID;
    let item, mark, type, mdef, i, n, o;

    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;

      if (mark.marktype !== type) {
        // memoize mark instance lookup
        type = mark.marktype;
        mdef = Marks[type];
      }

      if (mark.zdirty && mark.dirty !== id) {
        this._dirtyAll = false;
        dirtyParents(item, id);
        mark.items.forEach(i => {
          i.dirty = id;
        });
      }

      if (mark.zdirty) continue; // handle in standard drawing pass

      if (item.exit) {
        // EXIT
        if (mdef.nested && mark.items.length) {
          // if nested mark with remaining points, update instead
          o = mark.items[0];
          if (o._svg) this._update(mdef, o._svg, o);
        } else if (item._svg) {
          // otherwise remove from DOM
          o = item._svg.parentNode;
          if (o) o.removeChild(item._svg);
        }

        item._svg = null;
        continue;
      }

      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id) continue; // already visited

      if (!item._svg || !item._svg.ownerSVGElement) {
        // ENTER
        this._dirtyAll = false;
        dirtyParents(item, id);
      } else {
        // IN-PLACE UPDATE
        this._update(mdef, item._svg, item);
      }

      item._update = id;
    }

    return !this._dirtyAll;
  },

  // -- Construct & maintain scenegraph to SVG mapping ---

  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   */
  mark(el, scene, prev) {
    if (!this.isDirty(scene)) return scene._svg;
    const svg = this._svg,
          mdef = Marks[scene.marktype],
          events = scene.interactive === false ? 'none' : null,
          isGroup = mdef.tag === 'g';
    let sibling = null,
        i = 0;
    const parent = bind(scene, el, prev, 'g', svg);
    parent.setAttribute('class', cssClass(scene)); // apply aria attributes to parent container element

    const aria = ariaMarkAttributes(scene);

    for (const key in aria) setAttribute(parent, key, aria[key]);

    if (!isGroup) {
      setAttribute(parent, 'pointer-events', events);
    }

    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);

    const process = item => {
      const dirty = this.isDirty(item),
            node = bind(item, parent, sibling, mdef.tag, svg);

      if (dirty) {
        this._update(mdef, node, item);

        if (isGroup) recurse(this, node, item);
      }

      sibling = node;
      ++i;
    };

    if (mdef.nested) {
      if (scene.items.length) process(scene.items[0]);
    } else {
      visit(scene, process);
    }

    domClear(parent, i);
    return parent;
  },

  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    // set dom element and values cache
    // provides access to emit method
    element = el;
    values = el.__values__; // apply aria-specific properties

    ariaItemAttributes(emit, item); // apply svg attributes

    mdef.attr(emit, item, this); // some marks need special treatment

    const extra = mark_extras[mdef.type];
    if (extra) extra.call(this, mdef, el, item); // apply svg style attributes
    // note: element state may have been modified by 'extra' method

    if (element) this.style(element, item);
  },

  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null) return;

    for (const prop in styles) {
      let value = prop === 'font' ? fontFamily(item) : item[prop];
      if (value === values[prop]) continue;
      const name = styles[prop];

      if (value == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient(value)) {
          value = gradientRef(value, this._defs.gradient, href());
        }

        el.setAttribute(name, value + '');
      }

      values[prop] = value;
    }
  },

  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg,
          defs = this._defs;
    let el = defs.el,
        index = 0;

    for (const id in defs.gradient) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
      index = updateGradient(el, defs.gradient[id], index);
    }

    for (const id in defs.clipping) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
      index = updateClipping(el, defs.clipping[id], index);
    } // clean-up


    if (el) {
      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);
    }
  },

  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def = this._defs;
    def.gradient = {};
    def.clipping = {};
  }

}); // mark ancestor chain with a dirty id

function dirtyParents(item, id) {
  for (; item && item.dirty !== id; item = item.mark.group) {
    item.dirty = id;

    if (item.mark && item.mark.dirty !== id) {
      item.mark.dirty = id;
    } else return;
  }
} // update gradient definitions


function updateGradient(el, grad, index) {
  let i, n, stop;

  if (grad.gradient === 'radial') {
    // SVG radial gradients automatically transform to normalized bbox
    // coordinates, in a way that is cumbersome to replicate in canvas.
    // We wrap the radial gradient in a pattern element, allowing us to
    // maintain a circular gradient that matches what canvas provides.
    let pt = domChild(el, index++, 'pattern', svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: '0,0,1,1',
      width: '100%',
      height: '100%',
      preserveAspectRatio: 'xMidYMid slice'
    });
    pt = domChild(pt, 0, 'rect', svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: `url(${href()}#${grad.id})`
    });
    el = domChild(el, index++, 'radialGradient', svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index++, 'linearGradient', svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }

  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop = domChild(el, i, 'stop', svgns);
    stop.setAttribute('offset', grad.stops[i].offset);
    stop.setAttribute('stop-color', grad.stops[i].color);
  }

  domClear(el, i);
  return index;
} // update clipping path definitions


function updateClipping(el, clip, index) {
  let mask;
  el = domChild(el, index, 'clipPath', svgns);
  el.setAttribute('id', clip.id);

  if (clip.path) {
    mask = domChild(el, 0, 'path', svgns);
    mask.setAttribute('d', clip.path);
  } else {
    mask = domChild(el, 0, 'rect', svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip.width,
      height: clip.height
    });
  }

  domClear(el, 1);
  return index + 1;
} // Recursively process group contents.


function recurse(renderer, el, group) {
  el = el.lastChild.previousSibling;
  let prev,
      idx = 0;
  visit(group, item => {
    prev = renderer.mark(el, item, prev);
    ++idx;
  }); // remove any extraneous DOM elements

  domClear(el, 1 + idx);
} // Bind a scenegraph item to an SVG DOM element.
// Create new SVG elements as needed.


function bind(item, el, sibling, tag, svg) {
  let node = item._svg,
      doc; // create a new dom node if needed

  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;

    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: 'default'
      }; // if group, create background, content, and foreground elements

      if (tag === 'g') {
        const bg = domCreate(doc, 'path', svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, 'g', svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, 'path', svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: 'default'
        };
      }
    }
  } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed


  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }

  return node;
} // check if two nodes are ordered siblings


function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same
} // -- Set attributes & styles on SVG elements ---


let element = null,
    // temp var for current SVG element
values = null; // temp var for current values hash
// Extra configuration for certain mark types

const mark_extras = {
  group(mdef, el, item) {
    const fg = element = el.childNodes[2];
    values = fg.__values__;
    mdef.foreground(emit, item, this);
    values = el.__values__; // use parent's values hash

    element = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element = el.childNodes[0];
    mdef.background(emit, item, this);
    const value = item.mark.interactive === false ? 'none' : null;

    if (value !== values.events) {
      setAttribute(fg, 'pointer-events', value);
      setAttribute(bg, 'pointer-events', value);
      values.events = value;
    }

    if (item.strokeForeground && item.stroke) {
      const fill = item.fill;
      setAttribute(fg, 'display', null); // set style of background

      this.style(bg, item);
      setAttribute(bg, 'stroke', null); // set style of foreground

      if (fill) item.fill = null;
      values = fg.__values__;
      this.style(fg, item);
      if (fill) item.fill = fill; // leave element null to prevent downstream styling

      element = null;
    } else {
      // ensure foreground is ignored
      setAttribute(fg, 'display', 'none');
    }
  },

  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, 'image-rendering', 'optimizeSpeed');
      setStyle(el, 'image-rendering', 'pixelated');
    } else {
      setStyle(el, 'image-rendering', null);
    }
  },

  text(mdef, el, item) {
    const tl = textLines(item);
    let key, value, doc, lh;

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
      // multi-line text
      value = tl.map(_ => textValue(item, _));
      key = value.join('\n'); // content cache key

      if (key !== values.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value.forEach((t, i) => {
          const ts = domCreate(doc, 'tspan', svgns);
          ts.__data__ = item; // data binding

          ts.textContent = t;

          if (i) {
            ts.setAttribute('x', 0);
            ts.setAttribute('dy', lh);
          }

          el.appendChild(ts);
        });
        values.text = key;
      }
    } else {
      // single-line text
      value = textValue(item, tl);

      if (value !== values.text) {
        el.textContent = value;
        values.text = value;
      }
    }

    setAttribute(el, 'font-family', fontFamily(item));
    setAttribute(el, 'font-size', fontSize(item) + 'px');
    setAttribute(el, 'font-style', item.fontStyle);
    setAttribute(el, 'font-variant', item.fontVariant);
    setAttribute(el, 'font-weight', item.fontWeight);
  }

};

function emit(name, value, ns) {
  // early exit if value is unchanged
  if (value === values[name]) return; // use appropriate method given namespace (ns)

  if (ns) {
    setAttributeNS(element, name, value, ns);
  } else {
    setAttribute(element, name, value);
  } // note current value for future comparison


  values[name] = value;
}

function setStyle(el, name, value) {
  if (value !== values[name]) {
    if (value == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value + '');
    }

    values[name] = value;
  }
}

function setAttributes(el, attrs) {
  for (const key in attrs) {
    setAttribute(el, key, attrs[key]);
  }
}

function setAttribute(el, name, value) {
  if (value != null) {
    // if value is provided, update DOM attribute
    el.setAttribute(name, value);
  } else {
    // else remove DOM attribute
    el.removeAttribute(name);
  }
}

function setAttributeNS(el, name, value, ns) {
  if (value != null) {
    // if value is provided, update DOM attribute
    el.setAttributeNS(ns, name, value);
  } else {
    // else remove DOM attribute
    el.removeAttributeNS(ns, name);
  }
}

function href() {
  let loc;
  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}

function SVGStringRenderer(loader) {
  Renderer.call(this, loader);
  this._text = null;
  this._defs = {
    gradient: {},
    clipping: {}
  };
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(SVGStringRenderer, Renderer, {
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  },

  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m = markup(); // svg tag

    m.open('svg', (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, metadata, {
      class: 'marks',
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    })); // background, if defined

    const bg = this._bgcolor;

    if (bg && bg !== 'transparent' && bg !== 'none') {
      m.open('rect', {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    } // root content group


    m.open('g', rootAttributes, {
      transform: 'translate(' + this._origin + ')'
    });
    this.mark(m, scene);
    m.close(); // </g>
    // defs

    this.defs(m); // get SVG text string

    this._text = m.close() + '';
    return this;
  },

  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m, scene) {
    const mdef = Marks[scene.marktype],
          tag = mdef.tag,
          attrList = [ariaItemAttributes, mdef.attr]; // render opening group tag

    m.open('g', {
      'class': cssClass(scene),
      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null
    }); // render contained elements

    const process = item => {
      const href = this.href(item);
      if (href) m.open('a', href);
      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));

      if (tag === 'text') {
        const tl = textLines(item);

        if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
          // multi-line text
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };

          for (let i = 0; i < tl.length; ++i) {
            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();
          }
        } else {
          // single-line text
          m.text(textValue(item, tl));
        }
      } else if (tag === 'g') {
        const fore = item.strokeForeground,
              fill = item.fill,
              stroke = item.stroke;

        if (fore && stroke) {
          item.stroke = null;
        }

        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close(); // recurse for group content

        m.open('g', this.attr(scene, item, mdef.content));
        visit(item, scene => this.mark(m, scene));
        m.close();

        if (fore && stroke) {
          if (fill) item.fill = null;
          item.stroke = stroke;
          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();
          if (fill) item.fill = fill;
        } else {
          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();
        }
      }

      m.close(); // </tag>

      if (href) m.close(); // </a>
    };

    if (mdef.nested) {
      if (scene.items && scene.items.length) process(scene.items[0]);
    } else {
      visit(scene, process);
    } // render closing group tag


    return m.close(); // </g>
  },

  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href = item.href;
    let attr;

    if (href) {
      if (attr = this._hrefs && this._hrefs[href]) {
        return attr;
      } else {
        this.sanitizeURL(href).then(attr => {
          // rewrite to use xlink namespace
          attr['xlink:href'] = attr.href;
          attr.href = null;
          (this._hrefs || (this._hrefs = {}))[href] = attr;
        });
      }
    }

    return null;
  },

  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object = {},
          emit = (name, value, ns, prefixed) => {
      object[prefixed || name] = value;
    }; // apply mark specific attributes


    if (Array.isArray(attrs)) {
      attrs.forEach(fn => fn(emit, item, this));
    } else {
      attrs(emit, item, this);
    } // apply style attributes


    if (tag) {
      style(object, item, scene, tag, this._defs);
    }

    return object;
  },

  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m) {
    const gradient = this._defs.gradient,
          clipping = this._defs.clipping,
          count = Object.keys(gradient).length + Object.keys(clipping).length;
    if (count === 0) return; // nothing to do

    m.open('defs');

    for (const id in gradient) {
      const def = gradient[id],
            stops = def.stops;

      if (def.gradient === 'radial') {
        // SVG radial gradients automatically transform to normalized bbox
        // coordinates, in a way that is cumbersome to replicate in canvas.
        // We wrap the radial gradient in a pattern element, allowing us to
        // maintain a circular gradient that matches what canvas provides.
        m.open('pattern', {
          id: patternPrefix + id,
          viewBox: '0,0,1,1',
          width: '100%',
          height: '100%',
          preserveAspectRatio: 'xMidYMid slice'
        });
        m.open('rect', {
          width: '1',
          height: '1',
          fill: 'url(#' + id + ')'
        }).close();
        m.close(); // </pattern>

        m.open('radialGradient', {
          id: id,
          fx: def.x1,
          fy: def.y1,
          fr: def.r1,
          cx: def.x2,
          cy: def.y2,
          r: def.r2
        });
      } else {
        m.open('linearGradient', {
          id: id,
          x1: def.x1,
          x2: def.x2,
          y1: def.y1,
          y2: def.y2
        });
      }

      for (let i = 0; i < stops.length; ++i) {
        m.open('stop', {
          offset: stops[i].offset,
          'stop-color': stops[i].color
        }).close();
      }

      m.close();
    }

    for (const id in clipping) {
      const def = clipping[id];
      m.open('clipPath', {
        id: id
      });

      if (def.path) {
        m.open('path', {
          d: def.path
        }).close();
      } else {
        m.open('rect', {
          x: 0,
          y: 0,
          width: def.width,
          height: def.height
        }).close();
      }

      m.close();
    }

    m.close();
  }

}); // Helper function for attr for style presentation attributes

function style(s, item, scene, tag, defs) {
  if (item == null) return s;

  if (tag === 'bgrect' && scene.interactive === false) {
    s['pointer-events'] = 'none';
  }

  if (tag === 'bgfore') {
    if (scene.interactive === false) {
      s['pointer-events'] = 'none';
    }

    s.display = 'none';
    if (item.fill !== null) return s;
  }

  if (tag === 'image' && item.smooth === false) {
    s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';
  }

  if (tag === 'text') {
    s['font-family'] = fontFamily(item);
    s['font-size'] = fontSize(item) + 'px';
    s['font-style'] = item.fontStyle;
    s['font-variant'] = item.fontVariant;
    s['font-weight'] = item.fontWeight;
  }

  for (const prop in styles) {
    let value = item[prop];
    const name = styles[prop];

    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {
      if (isGradient(value)) {
        value = gradientRef(value, defs.gradient, '');
      }

      s[name] = value;
    }
  }

  return s;
}

const Canvas = 'canvas';
const PNG = 'png';
const SVG = 'svg';
const None = 'none';
const RenderType = {
  Canvas: Canvas,
  PNG: PNG,
  SVG: SVG,
  None: None
};
const modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[None] = {};
function renderModule(name, _) {
  name = String(name || '').toLowerCase();

  if (arguments.length > 1) {
    modules[name] = _;
    return this;
  } else {
    return modules[name];
  }
}

function intersect(scene, bounds, filter) {
  const hits = [],
        // intersection results
  box = new Bounds().union(bounds),
        // defensive copy
  type = scene.marktype;
  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Intersect scene must be mark node or group item.');
}

function intersectMark(mark, box, filter, hits) {
  if (visitMark(mark, box, filter)) {
    const items = mark.items,
          type = mark.marktype,
          n = items.length;
    let i = 0;

    if (type === 'group') {
      for (; i < n; ++i) {
        intersectGroup(items[i], box, filter, hits);
      }
    } else {
      for (const test = Marks[type].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem(item, box, test)) hits.push(item);
      }
    }
  }

  return hits;
}

function visitMark(mark, box, filter) {
  // process if bounds intersect and if
  // (1) mark is a group mark (so we must recurse), or
  // (2) mark is interactive and passes filter
  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));
}

function intersectGroup(group, box, filter, hits) {
  // test intersect against group
  // skip groups by default unless filter says otherwise
  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {
    hits.push(group);
  } // recursively test children marks
  // translate box to group coordinate space


  const marks = group.items,
        n = marks && marks.length;

  if (n) {
    const x = group.x || 0,
          y = group.y || 0;
    box.translate(-x, -y);

    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter, hits);
    }

    box.translate(x, y);
  }

  return hits;
}

function intersectItem(item, box, test) {
  // test bounds enclosure, bounds intersection, then detailed test
  const bounds = item.bounds;
  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);
}

const clipBounds = new Bounds();
function boundClip (mark) {
  const clip = mark.clip;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    clip(boundContext(clipBounds.clear()));
  } else if (clip) {
    clipBounds.set(0, 0, mark.group.width, mark.group.height);
  } else return;

  mark.bounds.intersect(clipBounds);
}

const TOLERANCE = 1e-9;
function sceneEqual(a, b, key) {
  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(a) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(b) ? a == b : objectEqual(a, b);
}
function pathEqual(a, b) {
  return sceneEqual(pathParse(a), pathParse(b));
}

function objectEqual(a, b) {
  var ka = Object.keys(a),
      kb = Object.keys(b),
      key,
      i;
  if (ka.length !== kb.length) return false;
  ka.sort();
  kb.sort();

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) return false;
  }

  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!sceneEqual(a[key], b[key], key)) return false;
  }

  return typeof a === typeof b;
}

function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}




/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/arc.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/arc.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/math.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        da = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_2__.default)();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
      context.moveTo(r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a0), r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        context.moveTo(r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a1), r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(r0 * r0 + r1 * r1)),
          rc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var p0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap)),
            p1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a01),
          y01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a01),
          x10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a10),
          y10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var x11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a11),
            y11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a11),
            x00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a00),
            y00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_0__.pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)((ax * bx + ay * by) / ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(ax * ax + ay * ay) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(bx * bx + by * by))) / 2),
              lc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r0 - lc) / (kc - 1));
          rc1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 2;
    return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a) * r, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/area.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/area.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/line.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/point.js");







/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x0, y0, y1) {
  var x1 = null,
      defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__.default,
      output = null;

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(0) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.default)(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__.default)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line_js__WEBPACK_IMPORTED_MODULE_5__.default)().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/array.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/array.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var slice = Array.prototype.slice;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/constant.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/constant.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basis.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basis.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "Basis": () => (/* binding */ Basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Basis(context);
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basisClosed.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basisClosed.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: (0,_basis_js__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisClosed(context);
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basisOpen.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basisOpen.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisOpen(context);
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/bundle.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/bundle.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis_js__WEBPACK_IMPORTED_MODULE_0__.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis_js__WEBPACK_IMPORTED_MODULE_0__.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinal.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinal.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "Cardinal": () => (/* binding */ Cardinal),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CardinalClosed": () => (/* binding */ CardinalClosed),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_cardinal_js__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CardinalOpen": () => (/* binding */ CardinalOpen),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_cardinal_js__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRom.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRom.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal_js__WEBPACK_IMPORTED_MODULE_1__.Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cardinalClosed.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_catmullRom_js__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_2__.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinalOpen.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./catmullRom.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_catmullRom_js__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_1__.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linear.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linear.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linearClosed.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linearClosed.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new LinearClosed(context);
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/monotone.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/monotone.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "monotoneX": () => (/* binding */ monotoneX),
/* harmony export */   "monotoneY": () => (/* binding */ monotoneY)
/* harmony export */ });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/natural.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/natural.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Natural(context);
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/step.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/step.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "stepBefore": () => (/* binding */ stepBefore),
/* harmony export */   "stepAfter": () => (/* binding */ stepAfter)
/* harmony export */ });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/line.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/line.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__.default,
      output = null;

  x = typeof x === "function" ? x : (x === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(x);
  y = typeof y === "function" ? y : (y === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(y);

  function line(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.default)(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__.default)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/math.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/math.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "epsilon": () => (/* binding */ epsilon),
/* harmony export */   "pi": () => (/* binding */ pi),
/* harmony export */   "halfPi": () => (/* binding */ halfPi),
/* harmony export */   "tau": () => (/* binding */ tau),
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "asin": () => (/* binding */ asin)
/* harmony export */ });
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/noop.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/noop.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/point.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/point.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ x),
/* harmony export */   "y": () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "symbols": () => (/* binding */ symbols),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/star.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/square.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/constant.js");










var symbols = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__.default,
  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__.default,
  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__.default,
  _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__.default,
  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__.default,
  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__.default,
  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__.default
];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, size) {
  var context = null;
  type = typeof type === "function" ? type : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(type || _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__.default);
  size = typeof size === "function" ? size : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(size === undefined ? 64 : +size);

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_8__.default)();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/circle.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/circle.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/cross.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/cross.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/diamond.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/diamond.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/square.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/square.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/star.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/star.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/math.js");


var ka = 0.89081309152928522810,
    kr = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / Math.sin(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10),
    kx = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr,
    ky = -Math.cos(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = _math_js__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/triangle.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/triangle.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var sqrt3 = Math.sqrt(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/wye.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/node_modules/d3-shape/src/symbol/wye.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/vega-selections/build/vega-selection.module.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/vega-selections/build/vega-selection.module.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "selectionIdTest": () => (/* binding */ selectionIdTest),
/* harmony export */   "selectionResolve": () => (/* binding */ selectionResolve),
/* harmony export */   "selectionTest": () => (/* binding */ selectionTest),
/* harmony export */   "selectionTuples": () => (/* binding */ selectionTuples),
/* harmony export */   "selectionVisitor": () => (/* binding */ selectionVisitor)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-expression */ "../../node_modules/vega-expression/build/vega-expression.module.js");



function ascending (a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector (f) {
  let delta = f;
  let compare = f;

  if (f.length === 1) {
    delta = (d, x) => f(d) - x;

    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
    }

    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
    }

    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {
    left,
    center,
    right
  };
}

function ascendingComparator(f) {
  return (d, x) => ascending(f(d), x);
}

const Intersect = 'intersect';
const Union = 'union';
const VlMulti = 'vlMulti';
const VlPoint = 'vlPoint';
const Or = 'or';
const And = 'and';

const SELECTION_ID = '_vgsid_',
      TYPE_ENUM = 'E',
      TYPE_RANGE_INC = 'R',
      TYPE_RANGE_EXC = 'R-E',
      TYPE_RANGE_LE = 'R-LE',
      TYPE_RANGE_RE = 'R-RE',
      UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?

function testPoint(datum, entry) {
  var fields = entry.fields,
      values = entry.values,
      n = fields.length,
      i = 0,
      dval,
      f;

  for (; i < n; ++i) {
    f = fields[i];
    f.getter = vega_util__WEBPACK_IMPORTED_MODULE_0__.field.getter || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f.field);
    dval = f.getter(datum);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(dval)) dval = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(dval);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(values[i])) values[i] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(values[i]);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(values[i][0])) values[i] = values[i].map(vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber);

    if (f.type === TYPE_ENUM) {
      // Enumerated fields can either specify individual values (single/multi selections)
      // or an array of values (interval selections).
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i])) return false;
      } else if (f.type === TYPE_RANGE_RE) {
        // Discrete selection of bins test within the range [bin_start, bin_end).
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], true, false)) return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        // 'R-E'/'R-LE' included for completeness.
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], false, false)) return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], false, true)) return false;
      }
    }
  }

  return true;
}
/**
 * Tests if a tuple is contained within an interactive selection.
 * @param {string} name - The name of the data set representing the selection.
 *  Tuples in the dataset are of the form
 *  {unit: string, fields: array<fielddef>, values: array<*>}.
 *  Fielddef is of the form
 *  {field: string, channel: string, type: 'E' | 'R'} where
 *  'type' identifies whether tuples in the dataset enumerate
 *  values for the field, or specify a continuous range.
 * @param {object} datum - The tuple to test for inclusion.
 * @param {string} op - The set operation for combining selections.
 *   One of 'intersect' or 'union' (default).
 * @return {boolean} - True if the datum is in the selection, false otherwise.
 */


function selectionTest(name, datum, op) {
  var data = this.context.data[name],
      entries = data ? data.values.value : [],
      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,
      intersect = op === Intersect,
      n = entries.length,
      i = 0,
      entry,
      miss,
      count,
      unit,
      b;

  for (; i < n; ++i) {
    entry = entries[i];

    if (unitIdx && intersect) {
      // multi selections union within the same unit and intersect across units.
      miss = miss || {};
      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.

      if (count === -1) continue;
      b = testPoint(datum, entry);
      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true
      // if we've missed against all tuples in this unit return false

      if (b && unitIdx.size === 1) return true;
      if (!b && count === unitIdx.get(unit).count) return false;
    } else {
      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false
      // if we find a match and we don't require intersection return true

      if (intersect ^ b) return b;
    }
  } // if intersecting and we made it here, then we saw no misses
  // if not intersecting, then we saw no matches
  // if no active selections, return false


  return n && intersect;
}
const selectionId = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(SELECTION_ID),
      bisect = bisector(selectionId),
      bisectLeft = bisect.left,
      bisectRight = bisect.right;
function selectionIdTest(name, datum, op) {
  const data = this.context.data[name],
        entries = data ? data.values.value : [],
        unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,
        intersect = op === Intersect,
        value = selectionId(datum),
        index = bisectLeft(entries, value);
  if (index === entries.length) return false;
  if (selectionId(entries[index]) !== value) return false;

  if (unitIdx && intersect) {
    if (unitIdx.size === 1) return true;
    if (bisectRight(entries, value) - index < unitIdx.size) return false;
  }

  return true;
}

/**
 * Maps an array of scene graph items to an array of selection tuples.
 * @param {string} name  - The name of the dataset representing the selection.
 * @param {string} unit  - The name of the unit view.
 *
 * @returns {array} An array of selection entries for the given unit.
 */

function selectionTuples(array, base) {
  return array.map(x => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    values: base.fields.map(f => (f.getter || (f.getter = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f.field)))(x.datum))
  }, base));
}

/**
 * Resolves selection for use as a scale domain or reads via the API.
 * @param {string} name - The name of the dataset representing the selection
 * @param {string} [op='union'] - The set operation for combining selections.
 *                 One of 'intersect' or 'union' (default).
 * @param {boolean} isMulti - Identifies a "multi" selection to perform more
 *                 expensive resolution computation.
 * @param {boolean} vl5 - With Vega-Lite v5, "multi" selections are now called "point"
 *                 selections, and thus the resolved tuple should reflect this name.
 *                 This parameter allows us to reflect this change without triggering
 *                 a major version bump for Vega.
 * @returns {object} An object of selected fields and values.
 */

function selectionResolve(name, op, isMulti, vl5) {
  var data = this.context.data[name],
      entries = data ? data.values.value : [],
      resolved = {},
      multiRes = {},
      types = {},
      entry,
      fields,
      values,
      unit,
      field,
      res,
      resUnit,
      type,
      union,
      n = entries.length,
      i = 0,
      j,
      m; // First union all entries within the same unit.

  for (; i < n; ++i) {
    entry = entries[i];
    unit = entry.unit;
    fields = entry.fields;
    values = entry.values;

    for (j = 0, m = fields.length; j < m; ++j) {
      field = fields[j];
      res = resolved[field.field] || (resolved[field.field] = {});
      resUnit = res[unit] || (res[unit] = []);
      types[field.field] = type = field.type.charAt(0);
      union = ops[type + '_union'];
      res[unit] = union(resUnit, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(values[j]));
    } // If the same multi-selection is repeated over views and projected over
    // an encoding, it may operate over different fields making it especially
    // tricky to reliably resolve it. At best, we can de-dupe identical entries
    // but doing so may be more computationally expensive than it is worth.
    // Instead, for now, we simply transform our store representation into
    // a more human-friendly one.


    if (isMulti) {
      resUnit = multiRes[unit] || (multiRes[unit] = []);
      resUnit.push((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));
    }
  } // Then resolve fields across units as per the op.


  op = op || Union;
  Object.keys(resolved).forEach(field => {
    resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));
  });
  entries = Object.keys(multiRes);

  if (isMulti && entries.length) {
    const key = vl5 ? VlPoint : VlMulti;
    resolved[key] = op === Union ? {
      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])
    } : {
      [And]: entries.map(k => ({
        [Or]: multiRes[k]
      }))
    };
  }

  return resolved;
}
var ops = {
  E_union: function (base, value) {
    if (!base.length) return value;
    var i = 0,
        n = value.length;

    for (; i < n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);

    return base;
  },
  E_intersect: function (base, value) {
    return !base.length ? value : base.filter(v => value.indexOf(v) >= 0);
  },
  R_union: function (base, value) {
    var lo = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[0]),
        hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[1]);

    if (lo > hi) {
      lo = value[1];
      hi = value[0];
    }

    if (!base.length) return [lo, hi];
    if (base[0] > lo) base[0] = lo;
    if (base[1] < hi) base[1] = hi;
    return base;
  },
  R_intersect: function (base, value) {
    var lo = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[0]),
        hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[1]);

    if (lo > hi) {
      lo = value[1];
      hi = value[0];
    }

    if (!base.length) return [lo, hi];

    if (hi < base[0] || base[1] < lo) {
      return [];
    } else {
      if (base[0] < lo) base[0] = lo;
      if (base[1] > hi) base[1] = hi;
    }

    return base;
  }
};

const DataPrefix = ':',
      IndexPrefix = '@';
function selectionVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to selection functions must be a string literal.');
  const data = args[0].value,
        op = args.length >= 2 && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(args).value,
        field = 'unit',
        indexName = IndexPrefix + field,
        dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins

  if (op === Intersect && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, indexName)) {
    params[indexName] = scope.getData(data).indataRef(scope, field);
  } // eslint-disable-next-line no-prototype-builtins


  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, dataName)) {
    params[dataName] = scope.getData(data).tuplesRef();
  }
}




/***/ }),

/***/ "../../node_modules/vega-statistics/build/vega-statistics.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-statistics/build/vega-statistics.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bandwidthNRD": () => (/* binding */ estimateBandwidth),
/* harmony export */   "bin": () => (/* binding */ bin),
/* harmony export */   "bootstrapCI": () => (/* binding */ bootstrapCI),
/* harmony export */   "cumulativeLogNormal": () => (/* binding */ cumulativeLogNormal),
/* harmony export */   "cumulativeNormal": () => (/* binding */ cumulativeNormal),
/* harmony export */   "cumulativeUniform": () => (/* binding */ cumulativeUniform),
/* harmony export */   "densityLogNormal": () => (/* binding */ densityLogNormal),
/* harmony export */   "densityNormal": () => (/* binding */ densityNormal),
/* harmony export */   "densityUniform": () => (/* binding */ densityUniform),
/* harmony export */   "dotbin": () => (/* binding */ dotbin),
/* harmony export */   "quantileLogNormal": () => (/* binding */ quantileLogNormal),
/* harmony export */   "quantileNormal": () => (/* binding */ quantileNormal),
/* harmony export */   "quantileUniform": () => (/* binding */ quantileUniform),
/* harmony export */   "quantiles": () => (/* binding */ quantiles),
/* harmony export */   "quartiles": () => (/* binding */ quartiles),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "randomInteger": () => (/* binding */ integer),
/* harmony export */   "randomKDE": () => (/* binding */ kde),
/* harmony export */   "randomLCG": () => (/* binding */ lcg),
/* harmony export */   "randomLogNormal": () => (/* binding */ lognormal),
/* harmony export */   "randomMixture": () => (/* binding */ mixture),
/* harmony export */   "randomNormal": () => (/* binding */ gaussian),
/* harmony export */   "randomUniform": () => (/* binding */ uniform),
/* harmony export */   "regressionExp": () => (/* binding */ exp),
/* harmony export */   "regressionLinear": () => (/* binding */ linear),
/* harmony export */   "regressionLoess": () => (/* binding */ loess),
/* harmony export */   "regressionLog": () => (/* binding */ log),
/* harmony export */   "regressionPoly": () => (/* binding */ poly),
/* harmony export */   "regressionPow": () => (/* binding */ pow),
/* harmony export */   "regressionQuad": () => (/* binding */ quad),
/* harmony export */   "sampleCurve": () => (/* binding */ sampleCurve),
/* harmony export */   "sampleLogNormal": () => (/* binding */ sampleLogNormal),
/* harmony export */   "sampleNormal": () => (/* binding */ sampleNormal),
/* harmony export */   "sampleUniform": () => (/* binding */ sampleUniform),
/* harmony export */   "setRandom": () => (/* binding */ setRandom)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ascending.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/deviation.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/median.js");


function* numbers (values, valueof) {
  if (valueof == null) {
    for (let value of values) {
      if (value != null && value !== '' && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;

    for (let value of values) {
      value = valueof(value, ++index, values);

      if (value != null && value !== '' && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

function quantiles (array, p, f) {
  const values = Float64Array.from(numbers(array, f)); // don't depend on return value from typed array sort call
  // protects against undefined sort results in Safari (vega/vega-lite#4964)

  values.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__.default);
  return p.map(_ => (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.quantileSorted)(values, _));
}

function quartiles (array, f) {
  return quantiles(array, [0.25, 0.50, 0.75], f);
}

// Theory, Practice, and Visualization. Wiley.

function estimateBandwidth (array, f) {
  const n = array.length,
        d = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(array, f),
        q = quartiles(array, f),
        h = (q[2] - q[0]) / 1.34,
        v = Math.min(d, h) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}

function bin (_) {
  // determine range
  const maxb = _.maxbins || 20,
        base = _.base || 10,
        logb = Math.log(base),
        div = _.divide || [5, 2];
  let min = _.extent[0],
      max = _.extent[1],
      step,
      level,
      minstep,
      v,
      i,
      n;
  const span = _.span || max - min || Math.abs(min) || 1;

  if (_.step) {
    // if step size is explicitly given, use that
    step = _.step;
  } else if (_.steps) {
    // if provided, limit choice to acceptable step sizes
    v = span / maxb;

    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i);

    step = _.steps[Math.max(0, i - 1)];
  } else {
    // else use span to determine step size
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base, Math.round(Math.log(span) / logb) - level)); // increase step size if too many bins

    while (Math.ceil(span / step) > maxb) {
      step *= base;
    } // decrease step size if allowed


    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span / v <= maxb) step = v;
    }
  } // update precision, min and max


  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1,
        eps = Math.pow(base, -precision - 1);

  if (_.nice || _.nice === undefined) {
    v = Math.floor(min / step + eps) * step;
    min = min < v ? v - step : v;
    max = Math.ceil(max / step) * step;
  }

  return {
    start: min,
    stop: max === min ? min + step : max,
    step: step
  };
}

var random = Math.random;
function setRandom(r) {
  random = r;
}

function bootstrapCI (array, samples, alpha, f) {
  if (!array.length) return [undefined, undefined];
  const values = Float64Array.from(numbers(array, f)),
        n = values.length,
        m = samples;
  let a, i, j, mu;

  for (j = 0, mu = Array(m); j < m; ++j) {
    for (a = 0, i = 0; i < n; ++i) {
      a += values[~~(random() * n)];
    }

    mu[j] = a / n;
  }

  mu.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__.default);
  return [(0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(mu, alpha / 2), (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(mu, 1 - alpha / 2)];
}

// Dot density binning for dot plot construction.
// Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.
// https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf
function dotbin (array, step, smooth, f) {
  f = f || (_ => _);

  const n = array.length,
        v = new Float64Array(n);
  let i = 0,
      j = 1,
      a = f(array[0]),
      b = a,
      w = a + step,
      x;

  for (; j < n; ++j) {
    x = f(array[j]);

    if (x >= w) {
      b = (a + b) / 2;

      for (; i < j; ++i) v[i] = b;

      w = x + step;
      a = x;
    }

    b = x;
  }

  b = (a + b) / 2;

  for (; i < j; ++i) v[i] = b;

  return smooth ? smoothing(v, step + step / 4) : v;
} // perform smoothing to reduce variance
// swap points between "adjacent" stacks
// Wilkinson defines adjacent as within step/4 units

function smoothing(v, thresh) {
  const n = v.length;
  let a = 0,
      b = 1,
      c,
      d; // get left stack

  while (v[a] === v[b]) ++b;

  while (b < n) {
    // get right stack
    c = b + 1;

    while (v[b] === v[c]) ++c; // are stacks adjacent?
    // if so, compare sizes and swap as needed


    if (v[b] - v[b - 1] < thresh) {
      d = b + (a + c - b - b >> 1);

      while (d < b) v[d++] = v[b];

      while (d > b) v[d--] = v[a];
    } // update left stack indices


    a = b;
    b = c;
  }

  return v;
}

function lcg (seed) {
  // Random numbers using a Linear Congruential Generator with seed value
  // Uses glibc values from https://en.wikipedia.org/wiki/Linear_congruential_generator
  return function () {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}

function integer (min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }

  let a, b, d;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        d = b - a;
        return dist;
      } else {
        return a;
      }
    },

    max(_) {
      if (arguments.length) {
        b = _ || 0;
        d = b - a;
        return dist;
      } else {
        return b;
      }
    },

    sample() {
      return a + Math.floor(d * random());
    },

    pdf(x) {
      return x === Math.floor(x) && x >= a && x < b ? 1 / d : 0;
    },

    cdf(x) {
      const v = Math.floor(x);
      return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;
    },

    icdf(p) {
      return p >= 0 && p <= 1 ? a - 1 + Math.floor(p * d) : NaN;
    }

  };
  return dist.min(min).max(max);
}

const SQRT2PI = Math.sqrt(2 * Math.PI);
const SQRT2 = Math.SQRT2;

let nextSample = NaN;
function sampleNormal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  let x = 0,
      y = 0,
      rds,
      c;

  if (nextSample === nextSample) {
    x = nextSample;
    nextSample = NaN;
  } else {
    do {
      x = random() * 2 - 1;
      y = random() * 2 - 1;
      rds = x * x + y * y;
    } while (rds === 0 || rds > 1);

    c = Math.sqrt(-2 * Math.log(rds) / rds); // Box-Muller transform

    x *= c;
    nextSample = y * c;
  }

  return mean + x * stdev;
}
function densityNormal(value, mean, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value - (mean || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
} // Approximation from West (2009)
// Better Approximations to Cumulative Normal Functions

function cumulativeNormal(value, mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value - mean) / stdev,
        Z = Math.abs(z);
  let cd;

  if (Z > 37) {
    cd = 0;
  } else {
    const exp = Math.exp(-Z * Z / 2);
    let sum;

    if (Z < 7.07106781186547) {
      sum = 3.52624965998911e-02 * Z + 0.700383064443688;
      sum = sum * Z + 6.37396220353165;
      sum = sum * Z + 33.912866078383;
      sum = sum * Z + 112.079291497871;
      sum = sum * Z + 221.213596169931;
      sum = sum * Z + 220.206867912376;
      cd = exp * sum;
      sum = 8.83883476483184e-02 * Z + 1.75566716318264;
      sum = sum * Z + 16.064177579207;
      sum = sum * Z + 86.7807322029461;
      sum = sum * Z + 296.564248779674;
      sum = sum * Z + 637.333633378831;
      sum = sum * Z + 793.826512519948;
      sum = sum * Z + 440.413735824752;
      cd = cd / sum;
    } else {
      sum = Z + 0.65;
      sum = Z + 4 / sum;
      sum = Z + 3 / sum;
      sum = Z + 2 / sum;
      sum = Z + 1 / sum;
      cd = exp / sum / 2.506628274631;
    }
  }

  return z > 0 ? 1 - cd : cd;
} // Approximation of Probit function using inverse error function.

function quantileNormal(p, mean, stdev) {
  if (p < 0 || p > 1) return NaN;
  return (mean || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
} // Approximate inverse error function. Implementation from "Approximating
// the erfinv function" by Mike Giles, GPU Computing Gems, volume 2, 2010.
// Ported from Apache Commons Math, http://www.apache.org/licenses/LICENSE-2.0

function erfinv(x) {
  // beware that the logarithm argument must be
  // commputed as (1.0 - x) * (1.0 + x),
  // it must NOT be simplified as 1.0 - x * x as this
  // would induce rounding errors near the boundaries +/-1
  let w = -Math.log((1 - x) * (1 + x)),
      p;

  if (w < 6.25) {
    w -= 3.125;
    p = -3.6444120640178196996e-21;
    p = -1.685059138182016589e-19 + p * w;
    p = 1.2858480715256400167e-18 + p * w;
    p = 1.115787767802518096e-17 + p * w;
    p = -1.333171662854620906e-16 + p * w;
    p = 2.0972767875968561637e-17 + p * w;
    p = 6.6376381343583238325e-15 + p * w;
    p = -4.0545662729752068639e-14 + p * w;
    p = -8.1519341976054721522e-14 + p * w;
    p = 2.6335093153082322977e-12 + p * w;
    p = -1.2975133253453532498e-11 + p * w;
    p = -5.4154120542946279317e-11 + p * w;
    p = 1.051212273321532285e-09 + p * w;
    p = -4.1126339803469836976e-09 + p * w;
    p = -2.9070369957882005086e-08 + p * w;
    p = 4.2347877827932403518e-07 + p * w;
    p = -1.3654692000834678645e-06 + p * w;
    p = -1.3882523362786468719e-05 + p * w;
    p = 0.0001867342080340571352 + p * w;
    p = -0.00074070253416626697512 + p * w;
    p = -0.0060336708714301490533 + p * w;
    p = 0.24015818242558961693 + p * w;
    p = 1.6536545626831027356 + p * w;
  } else if (w < 16.0) {
    w = Math.sqrt(w) - 3.25;
    p = 2.2137376921775787049e-09;
    p = 9.0756561938885390979e-08 + p * w;
    p = -2.7517406297064545428e-07 + p * w;
    p = 1.8239629214389227755e-08 + p * w;
    p = 1.5027403968909827627e-06 + p * w;
    p = -4.013867526981545969e-06 + p * w;
    p = 2.9234449089955446044e-06 + p * w;
    p = 1.2475304481671778723e-05 + p * w;
    p = -4.7318229009055733981e-05 + p * w;
    p = 6.8284851459573175448e-05 + p * w;
    p = 2.4031110387097893999e-05 + p * w;
    p = -0.0003550375203628474796 + p * w;
    p = 0.00095328937973738049703 + p * w;
    p = -0.0016882755560235047313 + p * w;
    p = 0.0024914420961078508066 + p * w;
    p = -0.0037512085075692412107 + p * w;
    p = 0.005370914553590063617 + p * w;
    p = 1.0052589676941592334 + p * w;
    p = 3.0838856104922207635 + p * w;
  } else if (Number.isFinite(w)) {
    w = Math.sqrt(w) - 5.0;
    p = -2.7109920616438573243e-11;
    p = -2.5556418169965252055e-10 + p * w;
    p = 1.5076572693500548083e-09 + p * w;
    p = -3.7894654401267369937e-09 + p * w;
    p = 7.6157012080783393804e-09 + p * w;
    p = -1.4960026627149240478e-08 + p * w;
    p = 2.9147953450901080826e-08 + p * w;
    p = -6.7711997758452339498e-08 + p * w;
    p = 2.2900482228026654717e-07 + p * w;
    p = -9.9298272942317002539e-07 + p * w;
    p = 4.5260625972231537039e-06 + p * w;
    p = -1.9681778105531670567e-05 + p * w;
    p = 7.5995277030017761139e-05 + p * w;
    p = -0.00021503011930044477347 + p * w;
    p = -0.00013871931833623122026 + p * w;
    p = 1.0103004648645343977 + p * w;
    p = 4.8499064014085844221 + p * w;
  } else {
    p = Infinity;
  }

  return p * x;
}

function gaussian (mean, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },

    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },

    sample: () => sampleNormal(mu, sigma),
    pdf: value => densityNormal(value, mu, sigma),
    cdf: value => cumulativeNormal(value, mu, sigma),
    icdf: p => quantileNormal(p, mu, sigma)
  };
  return dist.mean(mean).stdev(stdev);
}

function kde (support, bandwidth) {
  const kernel = gaussian();
  let n = 0;
  const dist = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist.bandwidth(bandwidth);
      } else {
        return support;
      }
    },

    bandwidth(_) {
      if (!arguments.length) return bandwidth;
      bandwidth = _;
      if (!bandwidth && support) bandwidth = estimateBandwidth(support);
      return dist;
    },

    sample() {
      return support[~~(random() * n)] + bandwidth * kernel.sample();
    },

    pdf(x) {
      let y = 0,
          i = 0;

      for (; i < n; ++i) {
        y += kernel.pdf((x - support[i]) / bandwidth);
      }

      return y / bandwidth / n;
    },

    cdf(x) {
      let y = 0,
          i = 0;

      for (; i < n; ++i) {
        y += kernel.cdf((x - support[i]) / bandwidth);
      }

      return y / n;
    },

    icdf() {
      throw Error('KDE icdf not supported.');
    }

  };
  return dist.data(support);
}

function sampleLogNormal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean + sampleNormal() * stdev);
}
function densityLogNormal(value, mean, stdev) {
  if (value <= 0) return 0;
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value) - mean) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value);
}
function cumulativeLogNormal(value, mean, stdev) {
  return cumulativeNormal(Math.log(value), mean, stdev);
}
function quantileLogNormal(p, mean, stdev) {
  return Math.exp(quantileNormal(p, mean, stdev));
}
function lognormal (mean, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },

    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },

    sample: () => sampleLogNormal(mu, sigma),
    pdf: value => densityLogNormal(value, mu, sigma),
    cdf: value => cumulativeLogNormal(value, mu, sigma),
    icdf: p => quantileLogNormal(p, mu, sigma)
  };
  return dist.mean(mean).stdev(stdev);
}

function mixture (dists, weights) {
  let m = 0,
      w;

  function normalize(x) {
    const w = [];
    let sum = 0,
        i;

    for (i = 0; i < m; ++i) {
      sum += w[i] = x[i] == null ? 1 : +x[i];
    }

    for (i = 0; i < m; ++i) {
      w[i] /= sum;
    }

    return w;
  }

  const dist = {
    weights(_) {
      if (arguments.length) {
        w = normalize(weights = _ || []);
        return dist;
      }

      return weights;
    },

    distributions(_) {
      if (arguments.length) {
        if (_) {
          m = _.length;
          dists = _;
        } else {
          m = 0;
          dists = [];
        }

        return dist.weights(weights);
      }

      return dists;
    },

    sample() {
      const r = random();
      let d = dists[m - 1],
          v = w[0],
          i = 0; // first select distribution

      for (; i < m - 1; v += w[++i]) {
        if (r < v) {
          d = dists[i];
          break;
        }
      } // then sample from it


      return d.sample();
    },

    pdf(x) {
      let p = 0,
          i = 0;

      for (; i < m; ++i) {
        p += w[i] * dists[i].pdf(x);
      }

      return p;
    },

    cdf(x) {
      let p = 0,
          i = 0;

      for (; i < m; ++i) {
        p += w[i] * dists[i].cdf(x);
      }

      return p;
    },

    icdf() {
      throw Error('Mixture icdf not supported.');
    }

  };
  return dist.distributions(dists).weights(weights);
}

function sampleUniform(min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return min + (max - min) * random();
}
function densityUniform(value, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return value >= min && value <= max ? 1 / (max - min) : 0;
}
function cumulativeUniform(value, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return value < min ? 0 : value > max ? 1 : (value - min) / (max - min);
}
function quantileUniform(p, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return p >= 0 && p <= 1 ? min + p * (max - min) : NaN;
}
function uniform (min, max) {
  let a, b;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        return dist;
      } else {
        return a;
      }
    },

    max(_) {
      if (arguments.length) {
        b = _ == null ? 1 : _;
        return dist;
      } else {
        return b;
      }
    },

    sample: () => sampleUniform(a, b),
    pdf: value => densityUniform(value, a, b),
    cdf: value => cumulativeUniform(value, a, b),
    icdf: p => quantileUniform(p, a, b)
  };

  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return dist.min(min).max(max);
}

// Ordinary Least Squares
function ols (uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX,
        slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta,
        intercept = uY - slope * uX;
  return [intercept, slope];
}

function points(data, x, y, sort) {
  data = data.filter(d => {
    let u = x(d),
        v = y(d);
    return u != null && (u = +u) >= u && v != null && (v = +v) >= v;
  });

  if (sort) {
    data.sort((a, b) => x(a) - x(b));
  }

  const n = data.length,
        X = new Float64Array(n),
        Y = new Float64Array(n); // extract values, calculate means

  let i = 0,
      ux = 0,
      uy = 0,
      xv,
      yv,
      d;

  for (d of data) {
    X[i] = xv = +x(d);
    Y[i] = yv = +y(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  } // mean center the data


  for (i = 0; i < n; ++i) {
    X[i] -= ux;
    Y[i] -= uy;
  }

  return [X, Y, ux, uy];
}
function visitPoints(data, x, y, callback) {
  let i = -1,
      u,
      v;

  for (const d of data) {
    u = x(d);
    v = y(d);

    if (u != null && (u = +u) >= u && v != null && (v = +v) >= v) {
      callback(u, v, ++i);
    }
  }
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function rSquared (data, x, y, uY, predict) {
  let SSE = 0,
      SST = 0;
  visitPoints(data, x, y, (dx, dy) => {
    const sse = dy - predict(dx),
          sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function linear (data, x, y) {
  let X = 0,
      Y = 0,
      XY = 0,
      X2 = 0,
      n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n;
    X += (dx - X) / n;
    Y += (dy - Y) / n;
    XY += (dx * dy - XY) / n;
    X2 += (dx * dx - X2) / n;
  });

  const coef = ols(X, Y, XY, X2),
        predict = x => coef[0] + coef[1] * x;

  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function log (data, x, y) {
  let X = 0,
      Y = 0,
      XY = 0,
      X2 = 0,
      n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X += (dx - X) / n;
    Y += (dy - Y) / n;
    XY += (dx * dy - XY) / n;
    X2 += (dx * dx - X2) / n;
  });

  const coef = ols(X, Y, XY, X2),
        predict = x => coef[0] + coef[1] * Math.log(x);

  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

function exp (data, x, y) {
  // eslint-disable-next-line no-unused-vars
  const [xv, yv, ux, uy] = points(data, x, y);
  let YL = 0,
      XY = 0,
      XYL = 0,
      X2Y = 0,
      n = 0,
      dx,
      ly,
      xy;
  visitPoints(data, x, y, (_, dy) => {
    dx = xv[n++];
    ly = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });

  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy),
        predict = x => Math.exp(c0 + c1 * (x - ux));

  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function pow (data, x, y) {
  let X = 0,
      Y = 0,
      XY = 0,
      X2 = 0,
      YS = 0,
      n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    const lx = Math.log(dx),
          ly = Math.log(dy);
    ++n;
    X += (lx - X) / n;
    Y += (ly - Y) / n;
    XY += (lx * ly - XY) / n;
    X2 += (lx * lx - X2) / n;
    YS += (dy - YS) / n;
  });

  const coef = ols(X, Y, XY, X2),
        predict = x => coef[0] * Math.pow(x, coef[1]);

  coef[0] = Math.exp(coef[0]);
  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, YS, predict)
  };
}

function quad (data, x, y) {
  const [xv, yv, ux, uy] = points(data, x, y),
        n = xv.length;
  let X2 = 0,
      X3 = 0,
      X4 = 0,
      XY = 0,
      X2Y = 0,
      i,
      dx,
      dy,
      x2;

  for (i = 0; i < n;) {
    dx = xv[i];
    dy = yv[i++];
    x2 = dx * dx;
    X2 += (x2 - X2) / i;
    X3 += (x2 * dx - X3) / i;
    X4 += (x2 * x2 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x2 * dy - X2Y) / i;
  }

  const X2X2 = X4 - X2 * X2,
        d = X2 * X2X2 - X3 * X3,
        a = (X2Y * X2 - XY * X3) / d,
        b = (XY * X2X2 - X2Y * X3) / d,
        c = -a * X2,
        predict = x => {
    x = x - ux;
    return a * x * x + b * x + c + uy;
  }; // transform coefficients back from mean-centered space


  return {
    coef: [c - b * ux + a * ux * ux + uy, b - 2 * a * ux, a],
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE
// ... which was adapted from regression-js by Tom Alexander
// Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246
// License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE

function poly (data, x, y, order) {
  // use more efficient methods for lower orders
  if (order === 1) return linear(data, x, y);
  if (order === 2) return quad(data, x, y);
  const [xv, yv, ux, uy] = points(data, x, y),
        n = xv.length,
        lhs = [],
        rhs = [],
        k = order + 1;
  let i, j, l, v, c;

  for (i = 0; i < k; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }

    lhs.push(v);
    c = new Float64Array(k);

    for (j = 0; j < k; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }

      c[j] = v;
    }

    rhs.push(c);
  }

  rhs.push(lhs);

  const coef = gaussianElimination(rhs),
        predict = x => {
    x -= ux;
    let y = uy + coef[0] + coef[1] * x + coef[2] * x * x;

    for (i = 3; i < k; ++i) y += coef[i] * Math.pow(x, i);

    return y;
  };

  return {
    coef: uncenter(k, coef, -ux, uy),
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

function uncenter(k, a, x, y) {
  const z = Array(k);
  let i, j, v, c; // initialize to zero

  for (i = 0; i < k; ++i) z[i] = 0; // polynomial expansion


  for (i = k - 1; i >= 0; --i) {
    v = a[i];
    c = 1;
    z[i] += v;

    for (j = 1; j <= i; ++j) {
      c *= (i + 1 - j) / j; // binomial coefficent

      z[i - j] += v * Math.pow(x, j) * c;
    }
  } // bias term


  z[0] += y;
  return z;
} // Given an array for a two-dimensional matrix and the polynomial order,
// solve A * x = b using Gaussian elimination.


function gaussianElimination(matrix) {
  const n = matrix.length - 1,
        coef = [];
  let i, j, k, r, t;

  for (i = 0; i < n; ++i) {
    r = i; // max row

    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }

    for (k = i; k < n + 1; ++k) {
      t = matrix[k][i];
      matrix[k][i] = matrix[k][r];
      matrix[k][r] = t;
    }

    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }

  for (j = n - 1; j >= 0; --j) {
    t = 0;

    for (k = j + 1; k < n; ++k) {
      t += matrix[k][j] * coef[k];
    }

    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }

  return coef;
}

const maxiters = 2,
      epsilon = 1e-12; // Adapted from science.js by Jason Davies
// Source: https://github.com/jasondavies/science.js/blob/master/src/stats/loess.js
// License: https://github.com/jasondavies/science.js/blob/master/LICENSE

function loess (data, x, y, bandwidth) {
  const [xv, yv, ux, uy] = points(data, x, y, true),
        n = xv.length,
        bw = Math.max(2, ~~(bandwidth * n)),
        // # nearest neighbors
  yhat = new Float64Array(n),
        residuals = new Float64Array(n),
        robustWeights = new Float64Array(n).fill(1);

  for (let iter = -1; ++iter <= maxiters;) {
    const interval = [0, bw - 1];

    for (let i = 0; i < n; ++i) {
      const dx = xv[i],
            i0 = interval[0],
            i1 = interval[1],
            edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0,
          X = 0,
          Y = 0,
          XY = 0,
          X2 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1); // avoid singularity!

      for (let k = i0; k <= i1; ++k) {
        const xk = xv[k],
              yk = yv[k],
              w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],
              xkw = xk * w;
        W += w;
        X += xkw;
        Y += yk * w;
        XY += yk * xkw;
        X2 += xk * xkw;
      } // linear regression fit


      const [a, b] = ols(X / W, Y / W, XY / W, X2 / W);
      yhat[i] = a + b * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval);
    }

    if (iter === maxiters) {
      break;
    }

    const medianResidual = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(residuals);
    if (Math.abs(medianResidual) < epsilon) break;

    for (let i = 0, arg, w; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual); // default to epsilon (rather than zero) for large deviations
      // keeping weights tiny but non-zero prevents singularites

      robustWeights[i] = arg >= 1 ? epsilon : (w = 1 - arg * arg) * w;
    }
  }

  return output(xv, yhat, ux, uy);
} // weighting kernel for local regression

function tricube(x) {
  return (x = 1 - x * x * x) * x * x;
} // advance sliding window interval of nearest neighbors


function updateInterval(xv, i, interval) {
  const val = xv[i];
  let left = interval[0],
      right = interval[1] + 1;
  if (right >= xv.length) return; // step right if distance to new right edge is <= distance to old left edge
  // step when distance is equal to ensure movement over duplicate x values

  while (i > left && xv[right] - val <= val - xv[left]) {
    interval[0] = ++left;
    interval[1] = right;
    ++right;
  }
} // generate smoothed output points
// average points with repeated x values


function output(xv, yhat, ux, uy) {
  const n = xv.length,
        out = [];
  let i = 0,
      cnt = 0,
      prev = [],
      v;

  for (; i < n; ++i) {
    v = xv[i] + ux;

    if (prev[0] === v) {
      // average output values via online update
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      // add new output point
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }

  prev[1] += uy;
  return out;
}

// subdivide up to accuracy of 0.5 degrees
const MIN_RADIANS = 0.5 * Math.PI / 180; // Adaptively sample an interpolated function over a domain extent

function sampleCurve (f, extent, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);

  const point = x => [x, f(x)],
        minX = extent[0],
        maxX = extent[1],
        span = maxX - minX,
        stop = span / maxSteps,
        prev = [point(minX)],
        next = [];

  if (minSteps === maxSteps) {
    // no adaptation, sample uniform grid directly and return
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point(minX + i / minSteps * span));
    }

    prev.push(point(maxX));
    return prev;
  } else {
    // sample minimum points on uniform grid
    // then move on to perform adaptive refinement
    next.push(point(maxX));

    for (let i = minSteps; --i > 0;) {
      next.push(point(minX + i / minSteps * span));
    }
  }

  let p0 = prev[0];
  let p1 = next[next.length - 1];
  const sx = 1 / span;
  const sy = scaleY(p0[1], next);

  while (p1) {
    // midpoint for potential curve subdivision
    const pm = point((p0[0] + p1[0]) / 2);
    const dx = pm[0] - p0[0] >= stop;

    if (dx && angleDelta(p0, pm, p1, sx, sy) > MIN_RADIANS) {
      // maximum resolution has not yet been met, and
      // subdivision midpoint is sufficiently different from endpoint
      // save subdivision, push midpoint onto the visitation stack
      next.push(pm);
    } else {
      // subdivision midpoint sufficiently similar to endpoint
      // skip subdivision, store endpoint, move to next point on the stack
      p0 = p1;
      prev.push(p1);
      next.pop();
    }

    p1 = next[next.length - 1];
  }

  return prev;
}

function scaleY(init, points) {
  let ymin = init;
  let ymax = init;
  const n = points.length;

  for (let i = 0; i < n; ++i) {
    const y = points[i][1];
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;
  }

  return 1 / (ymax - ymin);
}

function angleDelta(p, q, r, sx, sy) {
  const a0 = Math.atan2(sy * (r[1] - p[1]), sx * (r[0] - p[0])),
        a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}




/***/ }),

/***/ "../../node_modules/vega-time/build/vega-time.module.js":
/*!**************************************************************!*\
  !*** ../../node_modules/vega-time/build/vega-time.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DATE": () => (/* binding */ DATE),
/* harmony export */   "DAY": () => (/* binding */ DAY),
/* harmony export */   "DAYOFYEAR": () => (/* binding */ DAYOFYEAR),
/* harmony export */   "HOURS": () => (/* binding */ HOURS),
/* harmony export */   "MILLISECONDS": () => (/* binding */ MILLISECONDS),
/* harmony export */   "MINUTES": () => (/* binding */ MINUTES),
/* harmony export */   "MONTH": () => (/* binding */ MONTH),
/* harmony export */   "QUARTER": () => (/* binding */ QUARTER),
/* harmony export */   "SECONDS": () => (/* binding */ SECONDS),
/* harmony export */   "TIME_UNITS": () => (/* binding */ TIME_UNITS),
/* harmony export */   "WEEK": () => (/* binding */ WEEK),
/* harmony export */   "YEAR": () => (/* binding */ YEAR),
/* harmony export */   "dayofyear": () => (/* binding */ dayofyear),
/* harmony export */   "timeBin": () => (/* binding */ bin),
/* harmony export */   "timeFloor": () => (/* binding */ timeFloor),
/* harmony export */   "timeInterval": () => (/* binding */ timeInterval),
/* harmony export */   "timeOffset": () => (/* binding */ timeOffset),
/* harmony export */   "timeSequence": () => (/* binding */ timeSequence),
/* harmony export */   "timeUnitSpecifier": () => (/* binding */ timeUnitSpecifier),
/* harmony export */   "timeUnits": () => (/* binding */ timeUnits),
/* harmony export */   "utcFloor": () => (/* binding */ utcFloor),
/* harmony export */   "utcInterval": () => (/* binding */ utcInterval),
/* harmony export */   "utcOffset": () => (/* binding */ utcOffset),
/* harmony export */   "utcSequence": () => (/* binding */ utcSequence),
/* harmony export */   "utcdayofyear": () => (/* binding */ utcdayofyear),
/* harmony export */   "utcweek": () => (/* binding */ utcweek),
/* harmony export */   "week": () => (/* binding */ week)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/month.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/hour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/minute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/millisecond.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcYear.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcHour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisector.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");




const YEAR = 'year';
const QUARTER = 'quarter';
const MONTH = 'month';
const WEEK = 'week';
const DATE = 'date';
const DAY = 'day';
const DAYOFYEAR = 'dayofyear';
const HOURS = 'hours';
const MINUTES = 'minutes';
const SECONDS = 'seconds';
const MILLISECONDS = 'milliseconds';
const TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
const UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {});
function timeUnits(units) {
  const u = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(units).slice(),
        m = {}; // check validity

  if (!u.length) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing time unit.');
  u.forEach(unit => {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(UNITS, unit)) {
      m[unit] = 1;
    } else {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)("Invalid time unit: ".concat(unit, "."));
    }
  });
  const numTypes = (m[WEEK] || m[DAY] ? 1 : 0) + (m[QUARTER] || m[MONTH] || m[DATE] ? 1 : 0) + (m[DAYOFYEAR] ? 1 : 0);

  if (numTypes > 1) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)("Incompatible time units: ".concat(units));
  } // ensure proper sort order


  u.sort((a, b) => UNITS[a] - UNITS[b]);
  return u;
}
const defaultSpecifiers = {
  [YEAR]: '%Y ',
  [QUARTER]: 'Q%q ',
  [MONTH]: '%b ',
  [DATE]: '%d ',
  [WEEK]: 'W%U ',
  [DAY]: '%a ',
  [DAYOFYEAR]: '%j ',
  [HOURS]: '%H:00',
  [MINUTES]: '00:%M',
  [SECONDS]: ':%S',
  [MILLISECONDS]: '.%L',
  ["".concat(YEAR, "-").concat(MONTH)]: '%Y-%m ',
  ["".concat(YEAR, "-").concat(MONTH, "-").concat(DATE)]: '%Y-%m-%d ',
  ["".concat(HOURS, "-").concat(MINUTES)]: '%H:%M'
};
function timeUnitSpecifier(units, specifiers) {
  const s = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultSpecifiers, specifiers),
        u = timeUnits(units),
        n = u.length;
  let fmt = '',
      start = 0,
      end,
      key;

  for (start = 0; start < n;) {
    for (end = u.length; end > start; --end) {
      key = u.slice(start, end).join('-');

      if (s[key] != null) {
        fmt += s[key];
        start = end;
        break;
      }
    }
  }

  return fmt.trim();
}

const t0 = new Date();

function localYear(y) {
  t0.setFullYear(y);
  t0.setMonth(0);
  t0.setDate(1);
  t0.setHours(0, 0, 0, 0);
  return t0;
}

function dayofyear(d) {
  return localDayOfYear(new Date(d));
}
function week(d) {
  return localWeekNum(new Date(d));
}
function localDayOfYear(d) {
  return d3_time__WEBPACK_IMPORTED_MODULE_1__.default.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y) {
  return localYear(y).getDay();
}
function localDate(y, m, d, H, M, S, L) {
  if (0 <= y && y < 100) {
    const date = new Date(-1, m, d, H, M, S, L);
    date.setFullYear(y);
    return date;
  }

  return new Date(y, m, d, H, M, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear(new Date(d));
}
function utcweek(d) {
  return utcWeekNum(new Date(d));
}
function utcDayOfYear(d) {
  const y = Date.UTC(d.getUTCFullYear(), 0, 1);
  return d3_time__WEBPACK_IMPORTED_MODULE_3__.default.count(y - 1, d);
}
function utcWeekNum(d) {
  const y = Date.UTC(d.getUTCFullYear(), 0, 1);
  return d3_time__WEBPACK_IMPORTED_MODULE_4__.utcSunday.count(y - 1, d);
}
function utcFirst(y) {
  t0.setTime(Date.UTC(y, 0, 1));
  return t0.getUTCDay();
}
function utcDate(y, m, d, H, M, S, L) {
  if (0 <= y && y < 100) {
    const date = new Date(Date.UTC(-1, m, d, H, M, S, L));
    date.setUTCFullYear(d.y);
    return date;
  }

  return new Date(Date.UTC(y, m, d, H, M, S, L));
}

function floor(units, step, get, inv, newDate) {
  const s = step || 1,
        b = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(units),
        _ = (unit, p, key) => {
    key = key || unit;
    return getUnit(get[key], inv[key], unit === b && s, p);
  };

  const t = new Date(),
        u = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(units),
        y = u[YEAR] ? _(YEAR) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(2012),
        m = u[MONTH] ? _(MONTH) : u[QUARTER] ? _(QUARTER) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        d = u[WEEK] && u[DAY] ? _(DAY, 1, WEEK + DAY) : u[WEEK] ? _(WEEK, 1) : u[DAY] ? _(DAY, 1) : u[DATE] ? _(DATE, 1) : u[DAYOFYEAR] ? _(DAYOFYEAR, 1) : vega_util__WEBPACK_IMPORTED_MODULE_0__.one,
        H = u[HOURS] ? _(HOURS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        M = u[MINUTES] ? _(MINUTES) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        S = u[SECONDS] ? _(SECONDS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        L = u[MILLISECONDS] ? _(MILLISECONDS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero;
  return function (v) {
    t.setTime(+v);
    const year = y(t);
    return newDate(year, m(t), d(t, year), H(t), M(t), S(t), L(t));
  };
}

function getUnit(f, inv, step, phase) {
  const u = step <= 1 ? f : phase ? (d, y) => phase + step * Math.floor((f(d, y) - phase) / step) : (d, y) => step * Math.floor(f(d, y) / step);
  return inv ? (d, y) => inv(u(d, y), y) : u;
} // returns the day of the year based on week number, day of week,
// and the day of the week for the first day of the year


function weekday(week, day, firstDay) {
  return day + week * 7 - (firstDay + 6) % 7;
} // -- LOCAL TIME --


const localGet = {
  [YEAR]: d => d.getFullYear(),
  [QUARTER]: d => Math.floor(d.getMonth() / 3),
  [MONTH]: d => d.getMonth(),
  [DATE]: d => d.getDate(),
  [HOURS]: d => d.getHours(),
  [MINUTES]: d => d.getMinutes(),
  [SECONDS]: d => d.getSeconds(),
  [MILLISECONDS]: d => d.getMilliseconds(),
  [DAYOFYEAR]: d => localDayOfYear(d),
  [WEEK]: d => localWeekNum(d),
  [WEEK + DAY]: (d, y) => weekday(localWeekNum(d), d.getDay(), localFirst(y)),
  [DAY]: (d, y) => weekday(1, d.getDay(), localFirst(y))
};
const localInv = {
  [QUARTER]: q => 3 * q,
  [WEEK]: (w, y) => weekday(w, 0, localFirst(y))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet, localInv, localDate);
} // -- UTC TIME --

const utcGet = {
  [YEAR]: d => d.getUTCFullYear(),
  [QUARTER]: d => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: d => d.getUTCMonth(),
  [DATE]: d => d.getUTCDate(),
  [HOURS]: d => d.getUTCHours(),
  [MINUTES]: d => d.getUTCMinutes(),
  [SECONDS]: d => d.getUTCSeconds(),
  [MILLISECONDS]: d => d.getUTCMilliseconds(),
  [DAYOFYEAR]: d => utcDayOfYear(d),
  [WEEK]: d => utcWeekNum(d),
  [DAY]: (d, y) => weekday(1, d.getUTCDay(), utcFirst(y)),
  [WEEK + DAY]: (d, y) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y))
};
const utcInv = {
  [QUARTER]: q => 3 * q,
  [WEEK]: (w, y) => weekday(w, 0, utcFirst(y))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet, utcInv, utcDate);
}

const timeIntervals = {
  [YEAR]: d3_time__WEBPACK_IMPORTED_MODULE_5__.default,
  [QUARTER]: d3_time__WEBPACK_IMPORTED_MODULE_6__.default.every(3),
  [MONTH]: d3_time__WEBPACK_IMPORTED_MODULE_6__.default,
  [WEEK]: d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday,
  [DATE]: d3_time__WEBPACK_IMPORTED_MODULE_1__.default,
  [DAY]: d3_time__WEBPACK_IMPORTED_MODULE_1__.default,
  [DAYOFYEAR]: d3_time__WEBPACK_IMPORTED_MODULE_1__.default,
  [HOURS]: d3_time__WEBPACK_IMPORTED_MODULE_7__.default,
  [MINUTES]: d3_time__WEBPACK_IMPORTED_MODULE_8__.default,
  [SECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_9__.default,
  [MILLISECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_10__.default
};
const utcIntervals = {
  [YEAR]: d3_time__WEBPACK_IMPORTED_MODULE_11__.default,
  [QUARTER]: d3_time__WEBPACK_IMPORTED_MODULE_12__.default.every(3),
  [MONTH]: d3_time__WEBPACK_IMPORTED_MODULE_12__.default,
  [WEEK]: d3_time__WEBPACK_IMPORTED_MODULE_4__.utcSunday,
  [DATE]: d3_time__WEBPACK_IMPORTED_MODULE_3__.default,
  [DAY]: d3_time__WEBPACK_IMPORTED_MODULE_3__.default,
  [DAYOFYEAR]: d3_time__WEBPACK_IMPORTED_MODULE_3__.default,
  [HOURS]: d3_time__WEBPACK_IMPORTED_MODULE_13__.default,
  [MINUTES]: d3_time__WEBPACK_IMPORTED_MODULE_14__.default,
  [SECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_9__.default,
  [MILLISECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_10__.default
};
function timeInterval(unit) {
  return timeIntervals[unit];
}
function utcInterval(unit) {
  return utcIntervals[unit];
}

function offset(ival, date, step) {
  return ival ? ival.offset(date, step) : undefined;
}

function timeOffset(unit, date, step) {
  return offset(timeInterval(unit), date, step);
}
function utcOffset(unit, date, step) {
  return offset(utcInterval(unit), date, step);
}

function sequence(ival, start, stop, step) {
  return ival ? ival.range(start, stop, step) : undefined;
}

function timeSequence(unit, start, stop, step) {
  return sequence(timeInterval(unit), start, stop, step);
}
function utcSequence(unit, start, stop, step) {
  return sequence(utcInterval(unit), start, stop, step);
}

const durationSecond = 1000,
      durationMinute = durationSecond * 60,
      durationHour = durationMinute * 60,
      durationDay = durationHour * 24,
      durationWeek = durationDay * 7,
      durationMonth = durationDay * 30,
      durationYear = durationDay * 365;
const Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS],
      Seconds = Milli.slice(0, -1),
      Minutes = Seconds.slice(0, -1),
      Hours = Minutes.slice(0, -1),
      Day = Hours.slice(0, -1),
      Week = [YEAR, WEEK],
      Month = [YEAR, MONTH],
      Year = [YEAR];
const intervals = [[Seconds, 1, durationSecond], [Seconds, 5, 5 * durationSecond], [Seconds, 15, 15 * durationSecond], [Seconds, 30, 30 * durationSecond], [Minutes, 1, durationMinute], [Minutes, 5, 5 * durationMinute], [Minutes, 15, 15 * durationMinute], [Minutes, 30, 30 * durationMinute], [Hours, 1, durationHour], [Hours, 3, 3 * durationHour], [Hours, 6, 6 * durationHour], [Hours, 12, 12 * durationHour], [Day, 1, durationDay], [Week, 1, durationWeek], [Month, 1, durationMonth], [Month, 3, 3 * durationMonth], [Year, 1, durationYear]];
function bin (opt) {
  const ext = opt.extent,
        max = opt.maxbins || 40,
        target = Math.abs((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)(ext)) / max;
  let i = (0,d3_array__WEBPACK_IMPORTED_MODULE_15__.default)(i => i[2]).right(intervals, target),
      units,
      step;

  if (i === intervals.length) {
    units = Year, step = (0,d3_array__WEBPACK_IMPORTED_MODULE_16__.tickStep)(ext[0] / durationYear, ext[1] / durationYear, max);
  } else if (i) {
    i = intervals[target / intervals[i - 1][2] < intervals[i][2] / target ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli;
    step = Math.max((0,d3_array__WEBPACK_IMPORTED_MODULE_16__.tickStep)(ext[0], ext[1], max), 1);
  }

  return {
    units,
    step
  };
}




/***/ }),

/***/ "../../node_modules/vega-transforms/build/vega-transforms.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-transforms/build/vega-transforms.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "aggregate": () => (/* binding */ Aggregate),
/* harmony export */   "bin": () => (/* binding */ Bin),
/* harmony export */   "collect": () => (/* binding */ Collect),
/* harmony export */   "compare": () => (/* binding */ Compare),
/* harmony export */   "countpattern": () => (/* binding */ CountPattern),
/* harmony export */   "cross": () => (/* binding */ Cross),
/* harmony export */   "density": () => (/* binding */ Density),
/* harmony export */   "dotbin": () => (/* binding */ DotBin),
/* harmony export */   "expression": () => (/* binding */ Expression),
/* harmony export */   "extent": () => (/* binding */ Extent),
/* harmony export */   "facet": () => (/* binding */ Facet),
/* harmony export */   "field": () => (/* binding */ Field),
/* harmony export */   "filter": () => (/* binding */ Filter),
/* harmony export */   "flatten": () => (/* binding */ Flatten),
/* harmony export */   "fold": () => (/* binding */ Fold),
/* harmony export */   "formula": () => (/* binding */ Formula),
/* harmony export */   "generate": () => (/* binding */ Generate),
/* harmony export */   "impute": () => (/* binding */ Impute),
/* harmony export */   "joinaggregate": () => (/* binding */ JoinAggregate),
/* harmony export */   "kde": () => (/* binding */ KDE),
/* harmony export */   "key": () => (/* binding */ Key),
/* harmony export */   "load": () => (/* binding */ Load),
/* harmony export */   "lookup": () => (/* binding */ Lookup),
/* harmony export */   "multiextent": () => (/* binding */ MultiExtent),
/* harmony export */   "multivalues": () => (/* binding */ MultiValues),
/* harmony export */   "params": () => (/* binding */ Params),
/* harmony export */   "pivot": () => (/* binding */ Pivot),
/* harmony export */   "prefacet": () => (/* binding */ PreFacet),
/* harmony export */   "project": () => (/* binding */ Project),
/* harmony export */   "proxy": () => (/* binding */ Proxy),
/* harmony export */   "quantile": () => (/* binding */ Quantile),
/* harmony export */   "relay": () => (/* binding */ Relay),
/* harmony export */   "sample": () => (/* binding */ Sample),
/* harmony export */   "sequence": () => (/* binding */ Sequence),
/* harmony export */   "sieve": () => (/* binding */ Sieve),
/* harmony export */   "subflow": () => (/* binding */ Subflow),
/* harmony export */   "timeunit": () => (/* binding */ TimeUnit),
/* harmony export */   "tupleindex": () => (/* binding */ TupleIndex),
/* harmony export */   "values": () => (/* binding */ Values),
/* harmony export */   "window": () => (/* binding */ Window)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/median.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/mean.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisector.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");






function multikey(f) {
  return x => {
    const n = f.length;
    let i = 1,
        k = String(f[0](x));

    for (; i < n; ++i) {
      k += '|' + f[i](x);
    }

    return k;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function () {
    return '';
  } : fields.length === 1 ? fields[0] : multikey(fields);
}

function measureName(op, field, as) {
  return as || op + (!field ? '' : '_' + field);
}

const noop = () => {};

const base_op = {
  init: noop,
  add: noop,
  rem: noop,
  idx: 0
};
const AggregateOps = {
  values: {
    init: m => m.cell.store = true,
    value: m => m.cell.data.values(),
    idx: -1
  },
  count: {
    value: m => m.cell.num
  },
  __count__: {
    value: m => m.missing + m.valid
  },
  missing: {
    value: m => m.missing
  },
  valid: {
    value: m => m.valid
  },
  sum: {
    init: m => m.sum = 0,
    value: m => m.sum,
    add: (m, v) => m.sum += +v,
    rem: (m, v) => m.sum -= v
  },
  product: {
    init: m => m.product = 1,
    value: m => m.valid ? m.product : undefined,
    add: (m, v) => m.product *= v,
    rem: (m, v) => m.product /= v
  },
  mean: {
    init: m => m.mean = 0,
    value: m => m.valid ? m.mean : undefined,
    add: (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),
    rem: (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)
  },
  average: {
    value: m => m.valid ? m.mean : undefined,
    req: ['mean'],
    idx: 1
  },
  variance: {
    init: m => m.dev = 0,
    value: m => m.valid > 1 ? m.dev / (m.valid - 1) : undefined,
    add: (m, v) => m.dev += m.mean_d * (v - m.mean),
    rem: (m, v) => m.dev -= m.mean_d * (v - m.mean),
    req: ['mean'],
    idx: 1
  },
  variancep: {
    value: m => m.valid > 1 ? m.dev / m.valid : undefined,
    req: ['variance'],
    idx: 2
  },
  stdev: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : undefined,
    req: ['variance'],
    idx: 2
  },
  stdevp: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : undefined,
    req: ['variance'],
    idx: 2
  },
  stderr: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : undefined,
    req: ['variance'],
    idx: 2
  },
  distinct: {
    value: m => m.cell.data.distinct(m.get),
    req: ['values'],
    idx: 3
  },
  ci0: {
    value: m => m.cell.data.ci0(m.get),
    req: ['values'],
    idx: 3
  },
  ci1: {
    value: m => m.cell.data.ci1(m.get),
    req: ['values'],
    idx: 3
  },
  median: {
    value: m => m.cell.data.q2(m.get),
    req: ['values'],
    idx: 3
  },
  q1: {
    value: m => m.cell.data.q1(m.get),
    req: ['values'],
    idx: 3
  },
  q3: {
    value: m => m.cell.data.q3(m.get),
    req: ['values'],
    idx: 3
  },
  min: {
    init: m => m.min = undefined,
    value: m => m.min = Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min,
    add: (m, v) => {
      if (v < m.min || m.min === undefined) m.min = v;
    },
    rem: (m, v) => {
      if (v <= m.min) m.min = NaN;
    },
    req: ['values'],
    idx: 4
  },
  max: {
    init: m => m.max = undefined,
    value: m => m.max = Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max,
    add: (m, v) => {
      if (v > m.max || m.max === undefined) m.max = v;
    },
    rem: (m, v) => {
      if (v >= m.max) m.max = NaN;
    },
    req: ['values'],
    idx: 4
  },
  argmin: {
    init: m => m.argmin = undefined,
    value: m => m.argmin || m.cell.data.argmin(m.get),
    add: (m, v, t) => {
      if (v < m.min) m.argmin = t;
    },
    rem: (m, v) => {
      if (v <= m.min) m.argmin = undefined;
    },
    req: ['min', 'values'],
    idx: 3
  },
  argmax: {
    init: m => m.argmax = undefined,
    value: m => m.argmax || m.cell.data.argmax(m.get),
    add: (m, v, t) => {
      if (v > m.max) m.argmax = t;
    },
    rem: (m, v) => {
      if (v >= m.max) m.argmax = undefined;
    },
    req: ['max', 'values'],
    idx: 3
  }
};
const ValidAggregateOps = Object.keys(AggregateOps);

function measure(key, value) {
  return out => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    name: key,
    out: out || key
  }, base_op, value);
}

ValidAggregateOps.forEach(key => {
  AggregateOps[key] = measure(key, AggregateOps[key]);
});
function createMeasure(op, name) {
  return AggregateOps[op](name);
}

function compareIndex(a, b) {
  return a.idx - b.idx;
}

function resolve(agg) {
  const map = {};
  agg.forEach(a => map[a.name] = a);

  const getreqs = a => {
    if (!a.req) return;
    a.req.forEach(key => {
      if (!map[key]) getreqs(map[key] = AggregateOps[key]());
    });
  };

  agg.forEach(getreqs);
  return Object.values(map).sort(compareIndex);
}

function init() {
  this.valid = 0;
  this.missing = 0;

  this._ops.forEach(op => op.init(this));
}

function add(v, t) {
  if (v == null || v === '') {
    ++this.missing;
    return;
  }

  if (v !== v) return;
  ++this.valid;

  this._ops.forEach(op => op.add(this, v, t));
}

function rem(v, t) {
  if (v == null || v === '') {
    --this.missing;
    return;
  }

  if (v !== v) return;
  --this.valid;

  this._ops.forEach(op => op.rem(this, v, t));
}

function set(t) {
  this._out.forEach(op => t[op.out] = op.value(this));

  return t;
}

function compileMeasures(agg, field) {
  const get = field || vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,
        ops = resolve(agg),
        out = agg.slice().sort(compareIndex);

  function ctr(cell) {
    this._ops = ops;
    this._out = out;
    this.cell = cell;
    this.init();
  }

  ctr.prototype.init = init;
  ctr.prototype.add = add;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set;
  ctr.prototype.get = get;
  ctr.fields = agg.map(op => op.out);
  return ctr;
}

function TupleStore(key) {
  this._key = key ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(key) : vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid;
  this.reset();
}
const prototype$1 = TupleStore.prototype;

prototype$1.reset = function () {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};

prototype$1.add = function (v) {
  this._add.push(v);
};

prototype$1.rem = function (v) {
  this._rem.push(v);
};

prototype$1.values = function () {
  this._get = null;
  if (this._rem.length === 0) return this._add;
  const a = this._add,
        r = this._rem,
        k = this._key,
        n = a.length,
        m = r.length,
        x = Array(n - m),
        map = {};
  let i, j, v; // use unique key field to clear removed values

  for (i = 0; i < m; ++i) {
    map[k(r[i])] = 1;
  }

  for (i = 0, j = 0; i < n; ++i) {
    if (map[k(v = a[i])]) {
      map[k(v)] = 0;
    } else {
      x[j++] = v;
    }
  }

  this._rem = [];
  return this._add = x;
}; // memoizing statistics methods


prototype$1.distinct = function (get) {
  const v = this.values(),
        map = {};
  let n = v.length,
      count = 0,
      s;

  while (--n >= 0) {
    s = get(v[n]) + '';

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(map, s)) {
      map[s] = 1;
      ++count;
    }
  }

  return count;
};

prototype$1.extent = function (get) {
  if (this._get !== get || !this._ext) {
    const v = this.values(),
          i = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extentIndex)(v, get);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get;
  }

  return this._ext;
};

prototype$1.argmin = function (get) {
  return this.extent(get)[0] || {};
};

prototype$1.argmax = function (get) {
  return this.extent(get)[1] || {};
};

prototype$1.min = function (get) {
  const m = this.extent(get)[0];
  return m != null ? get(m) : undefined;
};

prototype$1.max = function (get) {
  const m = this.extent(get)[1];
  return m != null ? get(m) : undefined;
};

prototype$1.quartile = function (get) {
  if (this._get !== get || !this._q) {
    this._q = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.quartiles)(this.values(), get);
    this._get = get;
  }

  return this._q;
};

prototype$1.q1 = function (get) {
  return this.quartile(get)[0];
};

prototype$1.q2 = function (get) {
  return this.quartile(get)[1];
};

prototype$1.q3 = function (get) {
  return this.quartile(get)[2];
};

prototype$1.ci = function (get) {
  if (this._get !== get || !this._ci) {
    this._ci = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bootstrapCI)(this.values(), 1000, 0.05, get);
    this._get = get;
  }

  return this._ci;
};

prototype$1.ci0 = function (get) {
  return this.ci(get)[0];
};

prototype$1.ci1 = function (get) {
  return this.ci(get)[1];
};

/**
 * Group-by aggregation operator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.
 * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.
 * @param {Array<string>} [params.as] - An array of output field names for aggregated values.
 * @param {boolean} [params.cross=false] - A flag indicating that the full
 *   cross-product of groupby values should be generated, including empty cells.
 *   If true, the drop parameter is ignored and empty cells are retained.
 * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.
 */

function Aggregate(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
  this._adds = []; // array of added output tuples

  this._mods = []; // array of modified output tuples

  this._alen = 0; // number of active added tuples

  this._mlen = 0; // number of active modified tuples

  this._drop = true; // should empty aggregation cells be removed

  this._cross = false; // produce full cross-product of group-by values

  this._dims = []; // group-by dimension accessors

  this._dnames = []; // group-by dimension names

  this._measures = []; // collection of aggregation monoids

  this._countOnly = false; // flag indicating only count aggregation

  this._counts = null; // collection of count fields

  this._prev = null; // previous aggregation cells

  this._inputs = null; // array of dependent input tuple field names

  this._outputs = null; // array of output tuple field names
}
Aggregate.Definition = {
  'type': 'Aggregate',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidAggregateOps
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'drop',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'cross',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Aggregate, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const aggr = this,
          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
          mod = _.modified();

    aggr.stamp = out.stamp;

    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : {};
      pulse.visit(pulse.SOURCE, t => aggr.add(t));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse.visit(pulse.REM, t => aggr.rem(t));
      pulse.visit(pulse.ADD, t => aggr.add(t));
    } // Indicate output fields and return aggregate tuples.


    out.modifies(aggr._outputs); // Should empty cells be dropped?

    aggr._drop = _.drop !== false; // If domain cross-product requested, generate empty cells as needed
    // and ensure that empty cells are not dropped

    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }

    if (pulse.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }

    return aggr.changes(out);
  },

  cross() {
    const aggr = this,
          curr = aggr.value,
          dims = aggr._dnames,
          vals = dims.map(() => ({})),
          n = dims.length; // collect all group-by domain values

    function collect(cells) {
      let key, i, t, v;

      for (key in cells) {
        t = cells[key].tuple;

        for (i = 0; i < n; ++i) {
          vals[i][v = t[dims[i]]] = v;
        }
      }
    }

    collect(aggr._prev);
    collect(curr); // iterate over key cross-product, create cells as needed

    function generate(base, tuple, index) {
      const name = dims[index],
            v = vals[index++];

      for (const k in v) {
        const key = base ? base + '|' + k : k;
        tuple[name] = v[k];
        if (index < n) generate(key, tuple, index);else if (!curr[key]) aggr.cell(key, tuple);
      }
    }

    generate('', {}, 0);
  },

  init(_) {
    // initialize input and output fields
    const inputs = this._inputs = [],
          outputs = this._outputs = [],
          inputMap = {};

    function inputVisit(get) {
      const fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(get)),
            n = fields.length;
      let i = 0,
          f;

      for (; i < n; ++i) {
        if (!inputMap[f = fields[i]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    } // initialize group-by dimensions


    this._dims = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.groupby);
    this._dnames = this._dims.map(d => {
      const dname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims); // initialize aggregate measures

    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null],
          ops = _.ops || ['count'],
          as = _.as || [],
          n = fields.length,
          map = {};
    let field, op, m, mname, outname, i;

    if (n !== ops.length) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unmatched number of fields and aggregate ops.');
    }

    for (i = 0; i < n; ++i) {
      field = fields[i];
      op = ops[i];

      if (field == null && op !== 'count') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Null aggregate field specified.');
      }

      mname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);

      if (op === 'count') {
        this._counts.push(outname);

        continue;
      }

      m = map[mname];

      if (!m) {
        inputVisit(field);
        m = map[mname] = [];
        m.field = field;

        this._measures.push(m);
      }

      if (op !== 'count') this._countOnly = false;
      m.push(createMeasure(op, outname));
    }

    this._measures = this._measures.map(m => compileMeasures(m, m.field));
    return {}; // aggregation cells (this.value)
  },

  // -- Cell Management -----
  cellkey: groupkey(),

  cell(key, t) {
    let cell = this.value[key];

    if (!cell) {
      cell = this.value[key] = this.newcell(key, t);
      this._adds[this._alen++] = cell;
    } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {
      cell.stamp = this.stamp;
      this._adds[this._alen++] = cell;
    } else if (cell.stamp < this.stamp) {
      cell.stamp = this.stamp;
      this._mods[this._mlen++] = cell;
    }

    return cell;
  },

  newcell(key, t) {
    const cell = {
      key: key,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[key]),
      stamp: this.stamp,
      store: false
    };

    if (!this._countOnly) {
      const measures = this._measures,
            n = measures.length;
      cell.agg = Array(n);

      for (let i = 0; i < n; ++i) {
        cell.agg[i] = new measures[i](cell);
      }
    }

    if (cell.store) {
      cell.data = new TupleStore();
    }

    return cell;
  },

  newtuple(t, p) {
    const names = this._dnames,
          dims = this._dims,
          n = dims.length,
          x = {};

    for (let i = 0; i < n; ++i) {
      x[names[i]] = dims[i](t);
    }

    return p ? (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.replace)(p.tuple, x) : (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(x);
  },

  clean() {
    const cells = this.value;

    for (const key in cells) {
      if (cells[key].num === 0) {
        delete cells[key];
      }
    }
  },

  // -- Process Tuples -----
  add(t) {
    const key = this.cellkey(t),
          cell = this.cell(key, t);
    cell.num += 1;
    if (this._countOnly) return;
    if (cell.store) cell.data.add(t);
    const agg = cell.agg;

    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t), t);
    }
  },

  rem(t) {
    const key = this.cellkey(t),
          cell = this.cell(key, t);
    cell.num -= 1;
    if (this._countOnly) return;
    if (cell.store) cell.data.rem(t);
    const agg = cell.agg;

    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t), t);
    }
  },

  celltuple(cell) {
    const tuple = cell.tuple,
          counts = this._counts; // consolidate stored values

    if (cell.store) {
      cell.data.values();
    } // update tuple properties


    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell.num;
    }

    if (!this._countOnly) {
      const agg = cell.agg;

      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }

    return tuple;
  },

  changes(out) {
    const adds = this._adds,
          mods = this._mods,
          prev = this._prev,
          drop = this._drop,
          add = out.add,
          rem = out.rem,
          mod = out.mod;
    let cell, key, i, n;
    if (prev) for (key in prev) {
      cell = prev[key];
      if (!drop || cell.num) rem.push(cell.tuple);
    }

    for (i = 0, n = this._alen; i < n; ++i) {
      add.push(this.celltuple(adds[i]));
      adds[i] = null; // for garbage collection
    }

    for (i = 0, n = this._mlen; i < n; ++i) {
      cell = mods[i];
      (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));
      mods[i] = null; // for garbage collection
    }

    this._alen = this._mlen = 0; // reset list of active cells

    this._prev = null;
    return out;
  }

});

const EPSILON$1 = 1e-14;
/**
 * Generates a binning function for discretizing data.
 * @constructor
 * @param {object} params - The parameters for this operator. The
 *   provided values should be valid options for the {@link bin} function.
 * @param {function(object): *} params.field - The data field to bin.
 */

function Bin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Bin.Definition = {
  'type': 'Bin',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'interval',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'anchor',
    'type': 'number'
  }, {
    'name': 'maxbins',
    'type': 'number',
    'default': 20
  }, {
    'name': 'base',
    'type': 'number',
    'default': 10
  }, {
    'name': 'divide',
    'type': 'number',
    'array': true,
    'default': [5, 2]
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'span',
    'type': 'number'
  }, {
    'name': 'step',
    'type': 'number'
  }, {
    'name': 'steps',
    'type': 'number',
    'array': true
  }, {
    'name': 'minstep',
    'type': 'number',
    'default': 0
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'name',
    'type': 'string'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['bin0', 'bin1']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Bin, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const band = _.interval !== false,
          bins = this._bins(_),
          start = bins.start,
          step = bins.step,
          as = _.as || ['bin0', 'bin1'],
          b0 = as[0],
          b1 = as[1];

    let flag;

    if (_.modified()) {
      pulse = pulse.reflow(true);
      flag = pulse.SOURCE;
    } else {
      flag = pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(_.field)) ? pulse.ADD_MOD : pulse.ADD;
    }

    pulse.visit(flag, band ? t => {
      const v = bins(t); // minimum bin value (inclusive)

      t[b0] = v; // maximum bin value (exclusive)
      // use convoluted math for better floating point agreement
      // see https://github.com/vega/vega/issues/830
      // infinite values propagate through this formula! #2227

      t[b1] = v == null ? null : start + step * (1 + (v - start) / step);
    } : t => t[b0] = bins(t));
    return pulse.modifies(band ? as : b0);
  },

  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }

    const field = _.field,
          bins = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bin)(_),
          step = bins.step;
    let start = bins.start,
        stop = start + Math.ceil((bins.stop - start) / step) * step,
        a,
        d;

    if ((a = _.anchor) != null) {
      d = a - (start + step * Math.floor((a - start) / step));
      start += d;
      stop += d;
    }

    const f = function (t) {
      let v = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(field(t));
      return v == null ? null : v < start ? -Infinity : v > stop ? +Infinity : (v = Math.max(start, Math.min(v, stop - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));
    };

    f.start = start;
    f.stop = bins.stop;
    f.step = step;
    return this.value = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(f, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field), _.name || 'bin_' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field));
  }

});

function SortedList (idFunc, source, input) {
  const $ = idFunc;
  let data = source || [],
      add = input || [],
      rem = {},
      cnt = 0;
  return {
    add: t => add.push(t),
    remove: t => rem[$(t)] = ++cnt,
    size: () => data.length,
    data: (compare, resort) => {
      if (cnt) {
        data = data.filter(t => !rem[$(t)]);
        rem = {};
        cnt = 0;
      }

      if (resort && compare) {
        data.sort(compare);
      }

      if (add.length) {
        data = compare ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.merge)(compare, data, add.sort(compare)) : data.concat(add);
        add = [];
      }

      return data;
    }
  };
}

/**
 * Collects all data tuples that pass through this operator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for additionally sorting the collected tuples.
 */

function Collect(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Collect.Definition = {
  'type': 'Collect',
  'metadata': {
    'source': true
  },
  'params': [{
    'name': 'sort',
    'type': 'compare'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Collect, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.ALL),
          list = SortedList(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid, this.value, out.materialize(out.ADD).add),
          sort = _.sort,
          mod = pulse.changed() || sort && (_.modified('sort') || pulse.modified(sort.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(sort), mod); // propagate tree root if defined

    if (pulse.source && pulse.source.root) {
      this.value.root = pulse.source.root;
    }

    return out;
  }

});

/**
 * Generates a comparator function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<string|function>} params.fields - The fields to compare.
 * @param {Array<string>} [params.orders] - The sort orders.
 *   Each entry should be one of "ascending" (default) or "descending".
 */

function Compare(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$5, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Compare, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$5(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.compare)(_.fields, _.orders);
}

/**
 * Count regexp-defined pattern occurrences in a text field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - An accessor for the text field.
 * @param {string} [params.pattern] - RegExp string defining the text pattern.
 * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.
 * @param {string} [params.stopwords] - RegExp string of words to ignore.
 */

function CountPattern(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
CountPattern.Definition = {
  'type': 'CountPattern',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'case',
    'type': 'enum',
    'values': ['upper', 'lower', 'mixed'],
    'default': 'mixed'
  }, {
    'name': 'pattern',
    'type': 'string',
    'default': '[\\w"]+'
  }, {
    'name': 'stopwords',
    'type': 'string',
    'default': ''
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['text', 'count']
  }]
};

function tokenize(text, tcase, match) {
  switch (tcase) {
    case 'upper':
      text = text.toUpperCase();
      break;

    case 'lower':
      text = text.toLowerCase();
      break;
  }

  return text.match(match);
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CountPattern, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const process = update => tuple => {
      var tokens = tokenize(get(tuple), _.case, match) || [],
          t;

      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop.test(t = tokens[i])) update(t);
      }
    };

    const init = this._parameterCheck(_, pulse),
          counts = this._counts,
          match = this._match,
          stop = this._stop,
          get = _.field,
          as = _.as || ['text', 'count'],
          add = process(t => counts[t] = 1 + (counts[t] || 0)),
          rem = process(t => counts[t] -= 1);

    if (init) {
      pulse.visit(pulse.SOURCE, add);
    } else {
      pulse.visit(pulse.ADD, add);
      pulse.visit(pulse.REM, rem);
    }

    return this._finish(pulse, as); // generate output tuples
  },

  _parameterCheck(_, pulse) {
    let init = false;

    if (_.modified('stopwords') || !this._stop) {
      this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');
      init = true;
    }

    if (_.modified('pattern') || !this._match) {
      this._match = new RegExp(_.pattern || '[\\w\']+', 'g');
      init = true;
    }

    if (_.modified('field') || pulse.modified(_.field.fields)) {
      init = true;
    }

    if (init) this._counts = {};
    return init;
  },

  _finish(pulse, as) {
    const counts = this._counts,
          tuples = this._tuples || (this._tuples = {}),
          text = as[0],
          count = as[1],
          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    let w, t, c;

    for (w in counts) {
      t = tuples[w];
      c = counts[w] || 0;

      if (!t && c) {
        tuples[w] = t = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({});
        t[text] = w;
        t[count] = c;
        out.add.push(t);
      } else if (c === 0) {
        if (t) out.rem.push(t);
        counts[w] = null;
        tuples[w] = null;
      } else if (t[count] !== c) {
        t[count] = c;
        out.mod.push(t);
      }
    }

    return out.modifies(as);
  }

});

/**
 * Perform a cross-product of a tuple stream with itself.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object):boolean} [params.filter] - An optional filter
 *   function for selectively including tuples in the cross product.
 * @param {Array<string>} [params.as] - The names of the output fields.
 */

function Cross(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Cross.Definition = {
  'type': 'Cross',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'filter',
    'type': 'expr'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['a', 'b']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Cross, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          as = _.as || ['a', 'b'],
          a = as[0],
          b = as[1],
          reset = !this.value || pulse.changed(pulse.ADD_REM) || _.modified('as') || _.modified('filter');

    let data = this.value;

    if (reset) {
      if (data) out.rem = data;
      data = pulse.materialize(pulse.SOURCE).source;
      out.add = this.value = cross(data, a, b, _.filter || vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy);
    } else {
      out.mod = data;
    }

    out.source = this.value;
    return out.modifies(as);
  }

});

function cross(input, a, b, filter) {
  var data = [],
      t = {},
      n = input.length,
      i = 0,
      j,
      left;

  for (; i < n; ++i) {
    t[a] = left = input[i];

    for (j = 0; j < n; ++j) {
      t[b] = input[j];

      if (filter(t)) {
        data.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        t = {};
        t[a] = left;
      }
    }
  }

  return data;
}

const Distributions = {
  kde: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomKDE,
  mixture: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomMixture,
  normal: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomNormal,
  lognormal: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomLogNormal,
  uniform: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomUniform
};
const DISTRIBUTIONS = 'distributions',
      FUNCTION = 'function',
      FIELD = 'field';
/**
 * Parse a parameter object for a probability distribution.
 * @param {object} def - The distribution parameter object.
 * @param {function():Array<object>} - A method for requesting
 *   source data. Used for distributions (such as KDE) that
 *   require sample data points. This method will only be
 *   invoked if the 'from' parameter for a target data source
 *   is not provided. Typically this method returns backing
 *   source data for a Pulse object.
 * @return {object} - The output distribution object.
 */

function parse(def, data) {
  const func = def[FUNCTION];

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(Distributions, func)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unknown distribution function: ' + func);
  }

  const d = Distributions[func]();

  for (const name in def) {
    // if data field, extract values
    if (name === FIELD) {
      d.data((def.from || data()).map(def[name]));
    } // if distribution mixture, recurse to parse each definition
    else if (name === DISTRIBUTIONS) {
        d[name](def[name].map(_ => parse(_, data)));
      } // otherwise, simply set the parameter
      else if (typeof d[name] === FUNCTION) {
          d[name](def[name]);
        }
  }

  return d;
}

/**
 * Grid sample points for a probability density. Given a distribution and
 * a sampling extent, will generate points suitable for plotting either
 * PDF (probability density function) or CDF (cumulative distribution
 * function) curves.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.distribution - The probability distribution. This
 *   is an object parameter dependent on the distribution type.
 * @param {string} [params.method='pdf'] - The distribution method to sample.
 *   One of 'pdf' or 'cdf'.
 * @param {Array<number>} [params.extent] - The [min, max] extent over which
 *   to sample the distribution. This argument is required in most cases, but
 *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method
 *   that returns numerical sample points from which the extent can be deduced.
 * @param {number} [params.minsteps=25] - The minimum number of curve samples
 *   for plotting the density.
 * @param {number} [params.maxsteps=200] - The maximum number of curve samples
 *   for plotting the density.
 * @param {number} [params.steps] - The exact number of curve samples for
 *   plotting the density. If specified, overrides both minsteps and maxsteps
 *   to set an exact number of uniform samples. Useful in conjunction with
 *   a fixed extent to ensure consistent sample points for stacked densities.
 */

function Density(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
const distributions = [{
  'key': {
    'function': 'normal'
  },
  'params': [{
    'name': 'mean',
    'type': 'number',
    'default': 0
  }, {
    'name': 'stdev',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'lognormal'
  },
  'params': [{
    'name': 'mean',
    'type': 'number',
    'default': 0
  }, {
    'name': 'stdev',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'uniform'
  },
  'params': [{
    'name': 'min',
    'type': 'number',
    'default': 0
  }, {
    'name': 'max',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'kde'
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'from',
    'type': 'data'
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0
  }]
}];
const mixture = {
  'key': {
    'function': 'mixture'
  },
  'params': [{
    'name': 'distributions',
    'type': 'param',
    'array': true,
    'params': distributions
  }, {
    'name': 'weights',
    'type': 'number',
    'array': true
  }]
};
Density.Definition = {
  'type': 'Density',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'steps',
    'type': 'number'
  }, {
    'name': 'minsteps',
    'type': 'number',
    'default': 25
  }, {
    'name': 'maxsteps',
    'type': 'number',
    'default': 200
  }, {
    'name': 'method',
    'type': 'string',
    'default': 'pdf',
    'values': ['pdf', 'cdf']
  }, {
    'name': 'distribution',
    'type': 'param',
    'params': distributions.concat(mixture)
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['value', 'density']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Density, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const dist = parse(_.distribution, source(pulse)),
            minsteps = _.steps || _.minsteps || 25,
            maxsteps = _.steps || _.maxsteps || 200;
      let method = _.method || 'pdf';

      if (method !== 'pdf' && method !== 'cdf') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid density method: ' + method);
      }

      if (!_.extent && !dist.data) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing density extent parameter.');
      }

      method = dist[method];
      const as = _.as || ['value', 'density'],
            domain = _.extent || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(dist.data()),
            values = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.sampleCurve)(method, domain, minsteps, maxsteps).map(v => {
        const tuple = {};
        tuple[as[0]] = v[0];
        tuple[as[1]] = v[1];
        return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(tuple);
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});

function source(pulse) {
  return () => pulse.materialize(pulse.SOURCE).source;
}

function fieldNames(fields, as) {
  if (!fields) return null;
  return fields.map((f, i) => as[i] || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(f));
}
function partition$1(data, groupby, field) {
  const groups = [],
        get = f => f(t);

  let map, i, n, t, k, g; // partition data points into groups

  if (groupby == null) {
    groups.push(data.map(field));
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }

      g.push(field(t));
    }
  }

  return groups;
}

const Output = 'bin';
/**
 * Dot density binning for dot plot construction.
 * Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.
 * https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to bin.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {number} [params.step] - The step size (bin width) within which dots should be
 *   stacked. Defaults to 1/30 of the extent of the data *field*.
 * @param {boolean} [params.smooth=false] - A boolean flag indicating if dot density
 *   stacks should be smoothed to reduce variance.
 */

function DotBin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
DotBin.Definition = {
  'type': 'DotBin',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'step',
    'type': 'number'
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'default': Output
  }]
};

const autostep = (data, field) => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(data, field)) / 30;

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(DotBin, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (this.value && !(_.modified() || pulse.changed())) {
      return pulse; // early exit
    }

    const source = pulse.materialize(pulse.SOURCE).source,
          groups = partition$1(pulse.source, _.groupby, vega_util__WEBPACK_IMPORTED_MODULE_0__.identity),
          smooth = _.smooth || false,
          field = _.field,
          step = _.step || autostep(source, field),
          sort = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)((a, b) => field(a) - field(b)),
          as = _.as || Output,
          n = groups.length; // compute dotplot bins per group

    let min = Infinity,
        max = -Infinity,
        i = 0,
        j;

    for (; i < n; ++i) {
      const g = groups[i].sort(sort);
      j = -1;

      for (const v of (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.dotbin)(g, step, smooth, field)) {
        if (v < min) min = v;
        if (v > max) max = v;
        g[++j][as] = v;
      }
    }

    this.value = {
      start: min,
      stop: max,
      step: step
    };
    return pulse.reflow(true).modifies(as);
  }

});

/**
 * Wraps an expression function with access to external parameters.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function} params.expr - The expression function. The
 *  function should accept both a datum and a parameter object.
 *  This operator's value will be a new function that wraps the
 *  expression function with access to this operator's parameters.
 */

function Expression(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$4, params);
  this.modified(true);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Expression, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$4(_) {
  const expr = _.expr;
  return this.value && !_.modified('expr') ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(datum => expr(datum, _), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(expr), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(expr));
}

/**
 * Computes extents (min/max) for a data field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The field over which to compute extends.
 */

function Extent(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [undefined, undefined], params);
}
Extent.Definition = {
  'type': 'Extent',
  'metadata': {},
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Extent, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const extent = this.value,
          field = _.field,
          mod = pulse.changed() || pulse.modified(field.fields) || _.modified('field');

    let min = extent[0],
        max = extent[1];

    if (mod || min == null) {
      min = +Infinity;
      max = -Infinity;
    }

    pulse.visit(mod ? pulse.SOURCE : pulse.ADD, t => {
      const v = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(field(t));

      if (v != null) {
        // NaNs will fail all comparisons!
        if (v < min) min = v;
        if (v > max) max = v;
      }
    });

    if (!Number.isFinite(min) || !Number.isFinite(max)) {
      let name = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field);
      if (name) name = ` for field "${name}"`;
      pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);
      min = max = undefined;
    }

    this.value = [min, max];
  }

});

/**
 * Provides a bridge between a parent transform and a target subflow that
 * consumes only a subset of the tuples that pass through the parent.
 * @constructor
 * @param {Pulse} pulse - A pulse to use as the value of this operator.
 * @param {Transform} parent - The parent transform (typically a Facet instance).
 */

function Subflow(pulse, parent) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, pulse);
  this.parent = parent;
  this.count = 0;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Subflow, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(target) {
    this.detachSubflow = target.detachSubflow;
    this.targets().add(target);
    return target.source = this;
  },

  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(t) {
    this.count += 1;
    this.value.add.push(t);
  },

  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(t) {
    this.count -= 1;
    this.value.rem.push(t);
  },

  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(t) {
    this.value.mod.push(t);
  },

  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(pulse) {
    this.value.init(pulse, pulse.NO_SOURCE);
  },

  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    // assert: this.value.stamp === pulse.stamp
    return this.value;
  }

});

/**
 * Facets a dataflow into a set of subflows based on a key.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Dataflow, string): Operator} params.subflow - A function
 *   that generates a subflow of operators and returns its root operator.
 * @param {function(object): *} params.key - The key field to facet by.
 */

function Facet(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
  this._keys = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(); // cache previously calculated key values
  // keep track of active subflows, use as targets array for listeners
  // this allows us to limit propagation to only updated subflows

  const a = this._targets = [];
  a.active = 0;

  a.forEach = f => {
    for (let i = 0, n = a.active; i < n; ++i) {
      f(a[i], i, a);
    }
  };
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Facet, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },

  // parent argument provided by PreFacet subclass
  subflow(key, flow, pulse, parent) {
    const flows = this.value;
    let sf = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(flows, key) && flows[key],
        df,
        p;

    if (!sf) {
      p = parent || (p = this._group[key]) && p.tuple;
      df = pulse.dataflow;
      sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key, p));
      flows[key] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse.stamp) {
      sf.init(pulse);
      this.activate(sf);
    }

    return sf;
  },

  clean() {
    const flows = this.value;
    let detached = 0;

    for (const key in flows) {
      if (flows[key].count === 0) {
        const detach = flows[key].detachSubflow;
        if (detach) detach();
        delete flows[key];
        ++detached;
      }
    } // remove inactive targets from the active targets array


    if (detached) {
      const active = this._targets.filter(sf => sf && sf.count > 0);

      this.initTargets(active);
    }
  },

  initTargets(act) {
    const a = this._targets,
          n = a.length,
          m = act ? act.length : 0;
    let i = 0;

    for (; i < m; ++i) {
      a[i] = act[i];
    }

    for (; i < n && a[i] != null; ++i) {
      a[i] = null; // ensure old flows can be garbage collected
    }

    a.active = m;
  },

  transform(_, pulse) {
    const df = pulse.dataflow,
          key = _.key,
          flow = _.subflow,
          cache = this._keys,
          rekey = _.modified('key'),
          subflow = key => this.subflow(key, flow, pulse);

    this._group = _.group || {};
    this.initTargets(); // reset list of active subflows

    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
            k = cache.get(id);

      if (k !== undefined) {
        cache.delete(id);
        subflow(k).rem(t);
      }
    });
    pulse.visit(pulse.ADD, t => {
      const k = key(t);
      cache.set((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), k);
      subflow(k).add(t);
    });

    if (rekey || pulse.modified(key.fields)) {
      pulse.visit(pulse.MOD, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
              k0 = cache.get(id),
              k1 = key(t);

        if (k0 === k1) {
          subflow(k1).mod(t);
        } else {
          cache.set(id, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    } else if (pulse.changed(pulse.MOD)) {
      pulse.visit(pulse.MOD, t => {
        subflow(cache.get((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t))).mod(t);
      });
    }

    if (rekey) {
      pulse.visit(pulse.REFLOW, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
              k0 = cache.get(id),
              k1 = key(t);

        if (k0 !== k1) {
          cache.set(id, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    }

    if (pulse.clean()) {
      df.runAfter(() => {
        this.clean();
        cache.clean();
      });
    } else if (cache.empty > df.cleanThreshold) {
      df.runAfter(cache.clean);
    }

    return pulse;
  }

});

/**
 * Generates one or more field accessor functions.
 * If the 'name' parameter is an array, an array of field accessors
 * will be created and the 'as' parameter will be ignored.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.name - The field name(s) to access.
 * @param {string} params.as - The accessor function name.
 */

function Field(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$3, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Field, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$3(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_.name) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.name).map(f => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f)) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(_.name, _.as);
}

/**
 * Filters data tuples according to a predicate function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.expr - The predicate expression function
 *   that determines a tuple's filter status. Truthy values pass the filter.
 */

function Filter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(), params);
}
Filter.Definition = {
  'type': 'Filter',
  'metadata': {
    'changes': true
  },
  'params': [{
    'name': 'expr',
    'type': 'expr',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Filter, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow,
          cache = this.value,
          // cache ids of filtered tuples
    output = pulse.fork(),
          add = output.add,
          rem = output.rem,
          mod = output.mod,
          test = _.expr;
    let isMod = true;
    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
      if (!cache.has(id)) rem.push(t);else cache.delete(id);
    });
    pulse.visit(pulse.ADD, t => {
      if (test(t, _)) add.push(t);else cache.set((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), 1);
    });

    function revisit(t) {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
            b = test(t, _),
            s = cache.get(id);

      if (b && s) {
        cache.delete(id);
        add.push(t);
      } else if (!b && !s) {
        cache.set(id, 1);
        rem.push(t);
      } else if (isMod && b && !s) {
        mod.push(t);
      }
    }

    pulse.visit(pulse.MOD, revisit);

    if (_.modified()) {
      isMod = false;
      pulse.visit(pulse.REFLOW, revisit);
    }

    if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);
    return output;
  }

});

/**
 * Flattens array-typed field values into new data objects.
 * If multiple fields are specified, they are treated as parallel arrays,
 * with output values included for each matching index (or null if missing).
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.fields - An array of field
 *   accessors for the tuple fields that should be flattened.
 * @param {string} [params.index] - Optional output field name for index
 *   value. If unspecified, no index field is included in the output.
 * @param {Array<string>} [params.as] - Output field names for flattened
 *   array fields. Any unspecified fields will use the field name provided
 *   by the fields accessors.
 */

function Flatten(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Flatten.Definition = {
  'type': 'Flatten',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'index',
    'type': 'string'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Flatten, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          fields = _.fields,
          as = fieldNames(fields, _.as || []),
          index = _.index || null,
          m = as.length; // remove any previous results

    out.rem = this.value; // generate flattened tuples

    pulse.visit(pulse.SOURCE, t => {
      const arrays = fields.map(f => f(t)),
            maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);
      let i = 0,
          j,
          d,
          v;

      for (; i < maxlen; ++i) {
        d = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);

        for (j = 0; j < m; ++j) {
          d[as[j]] = (v = arrays[j][i]) == null ? null : v;
        }

        if (index) {
          d[index] = i;
        }

        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index) out.modifies(index);
    return out.modifies(as);
  }

});

/**
 * Folds one more tuple fields into multiple tuples in which the field
 * name and values are available under new 'key' and 'value' fields.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.fields - An array of field accessors
 *   for the tuple fields that should be folded.
 * @param {Array<string>} [params.as] - Output field names for folded key
 *   and value fields, defaults to ['key', 'value'].
 */

function Fold(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Fold.Definition = {
  'type': 'Fold',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['key', 'value']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Fold, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          fields = _.fields,
          fnames = fields.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
          as = _.as || ['key', 'value'],
          k = as[0],
          v = as[1],
          n = fields.length;
    out.rem = this.value;
    pulse.visit(pulse.SOURCE, t => {
      for (let i = 0, d; i < n; ++i) {
        d = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);
        d[k] = fnames[i];
        d[v] = fields[i](t);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }

});

/**
 * Invokes a function for each data tuple and saves the results as a new field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.expr - The formula function to invoke for each tuple.
 * @param {string} params.as - The field name under which to save the result.
 * @param {boolean} [params.initonly=false] - If true, the formula is applied to
 *   added tuples only, and does not update in response to modifications.
 */

function Formula(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Formula.Definition = {
  'type': 'Formula',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'expr',
    'type': 'expr',
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'required': true
  }, {
    'name': 'initonly',
    'type': 'boolean'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Formula, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const func = _.expr,
          as = _.as,
          mod = _.modified(),
          flag = _.initonly ? pulse.ADD : mod ? pulse.SOURCE : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD : pulse.ADD;

    if (mod) {
      // parameters updated, need to reflow
      pulse = pulse.materialize().reflow(true);
    }

    if (!_.initonly) {
      pulse.modifies(as);
    }

    return pulse.visit(flag, t => t[as] = func(t, _));
  }

});

/**
 * Generates data tuples using a provided generator function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Parameters): object} params.generator - A tuple generator
 *   function. This function is given the operator parameters as input.
 *   Changes to any additional parameters will not trigger re-calculation
 *   of previously generated tuples. Only future tuples are affected.
 * @param {number} params.size - The number of tuples to produce.
 */

function Generate(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Generate, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.ALL),
          gen = _.generator;
    let data = this.value,
        num = _.size - data.length,
        add,
        rem,
        t;

    if (num > 0) {
      // need more tuples, generate and add
      for (add = []; --num >= 0;) {
        add.push(t = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(gen(_)));
        data.push(t);
      }

      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add) : add;
    } else {
      // need fewer tuples, remove
      rem = data.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem) : rem;
      data = data.slice(-num);
    }

    out.source = this.value = data;
    return out;
  }

});

const Methods = {
  value: 'value',
  median: d3_array__WEBPACK_IMPORTED_MODULE_4__.default,
  mean: d3_array__WEBPACK_IMPORTED_MODULE_5__.default,
  min: d3_array__WEBPACK_IMPORTED_MODULE_6__.default,
  max: d3_array__WEBPACK_IMPORTED_MODULE_7__.default
};
const Empty = [];
/**
 * Impute missing values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to impute.
 * @param {Array<function(object): *>} [params.groupby] - An array of
 *   accessors to determine series within which to perform imputation.
 * @param {function(object): *} params.key - An accessor for a key value.
 *   Each key value should be unique within a group. New tuples will be
 *   imputed for any key values that are not found within a group.
 * @param {Array<*>} [params.keyvals] - Optional array of required key
 *   values. New tuples will be imputed for any key values that are not
 *   found within a group. In addition, these values will be automatically
 *   augmented with the key values observed in the input data.
 * @param {string} [method='value'] - The imputation method to use. One of
 *   'value', 'mean', 'median', 'max', 'min'.
 * @param {*} [value=0] - The constant value to use for imputation
 *   when using method 'value'.
 */

function Impute(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Impute.Definition = {
  'type': 'Impute',
  'metadata': {
    'changes': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'key',
    'type': 'field',
    'required': true
  }, {
    'name': 'keyvals',
    'array': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'value',
    'values': ['value', 'mean', 'median', 'max', 'min']
  }, {
    'name': 'value',
    'default': 0
  }]
};

function getValue(_) {
  var m = _.method || Methods.value,
      v;

  if (Methods[m] == null) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized imputation method: ' + m);
  } else if (m === Methods.value) {
    v = _.value !== undefined ? _.value : 0;
    return () => v;
  } else {
    return Methods[m];
  }
}

function getField(_) {
  const f = _.field;
  return t => t ? f(t) : NaN;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Impute, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
        impute = getValue(_),
        field = getField(_),
        fName = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(_.field),
        kName = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(_.key),
        gNames = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
        groups = partition(pulse.source, _.groupby, _.key, _.keyvals),
        curr = [],
        prev = this.value,
        m = groups.domain.length,
        group,
        value,
        gVals,
        kVal,
        g,
        i,
        j,
        l,
        n,
        t;

    for (g = 0, l = groups.length; g < l; ++g) {
      group = groups[g];
      gVals = group.values;
      value = NaN; // add tuples for missing values

      for (j = 0; j < m; ++j) {
        if (group[j] != null) continue;
        kVal = groups.domain[j];
        t = {
          _impute: true
        };

        for (i = 0, n = gVals.length; i < n; ++i) t[gNames[i]] = gVals[i];

        t[kName] = kVal;
        t[fName] = Number.isNaN(value) ? value = impute(group, field) : value;
        curr.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
      }
    } // update pulse with imputed tuples


    if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);
    this.value = curr;
    return out;
  }

});

function partition(data, groupby, key, keyvals) {
  var get = f => f(t),
      groups = [],
      domain = keyvals ? keyvals.slice() : [],
      kMap = {},
      gMap = {},
      gVals,
      gKey,
      group,
      i,
      j,
      k,
      n,
      t;

  domain.forEach((k, i) => kMap[k] = i + 1);

  for (i = 0, n = data.length; i < n; ++i) {
    t = data[i];
    k = key(t);
    j = kMap[k] || (kMap[k] = domain.push(k));
    gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';

    if (!(group = gMap[gKey])) {
      group = gMap[gKey] = [];
      groups.push(group);
      group.values = gVals;
    }

    group[j - 1] = t;
  }

  groups.domain = domain;
  return groups;
}

/**
 * Extend input tuples with aggregate values.
 * Calcuates aggregate values and joins them with the input stream.
 * @constructor
 */

function JoinAggregate(params) {
  Aggregate.call(this, params);
}
JoinAggregate.Definition = {
  'type': 'JoinAggregate',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidAggregateOps
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(JoinAggregate, Aggregate, {
  transform(_, pulse) {
    const aggr = this,
          mod = _.modified();

    let cells; // process all input tuples to calculate aggregates

    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse.visit(pulse.SOURCE, t => aggr.add(t));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse.visit(pulse.REM, t => aggr.rem(t));
      pulse.visit(pulse.ADD, t => aggr.add(t));
    } // update aggregation cells


    aggr.changes(); // write aggregate values to input tuples

    pulse.visit(pulse.SOURCE, t => {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(t, cells[aggr.cellkey(t)].tuple);
    });
    return pulse.reflow(mod).modifies(this._outputs);
  },

  changes() {
    const adds = this._adds,
          mods = this._mods;
    let i, n;

    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null; // for garbage collection
    }

    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null; // for garbage collection
    }

    this._alen = this._mlen = 0; // reset list of active cells
  }

});

/**
 * Compute kernel density estimates (KDE) for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {function(object): *} params.field - An accessor for the data field
 *   to estimate.
 * @param {number} [params.bandwidth=0] - The KDE kernel bandwidth.
 *   If zero or unspecified, the bandwidth is automatically determined.
 * @param {boolean} [params.counts=false] - A boolean flag indicating if the
 *   output values should be probability estimates (false, default) or
 *   smoothed counts (true).
 * @param {string} [params.cumulative=false] - A boolean flag indicating if a
 *   density (false) or cumulative distribution (true) should be generated.
 * @param {Array<number>} [params.extent] - The domain extent over which to
 *   plot the density. If unspecified, the [min, max] data extent is used.
 * @param {string} [params.resolve='independent'] - Indicates how parameters for
 *   multiple densities should be resolved. If "independent" (the default), each
 *   density may have its own domain extent and dynamic number of curve sample
 *   steps. If "shared", the KDE transform will ensure that all densities are
 *   defined over a shared domain and curve steps, enabling stacking.
 * @param {number} [params.minsteps=25] - The minimum number of curve samples
 *   for plotting the density.
 * @param {number} [params.maxsteps=200] - The maximum number of curve samples
 *   for plotting the density.
 * @param {number} [params.steps] - The exact number of curve samples for
 *   plotting the density. If specified, overrides both minsteps and maxsteps
 *   to set an exact number of uniform samples. Useful in conjunction with
 *   a fixed extent to ensure consistent sample points for stacked densities.
 */

function KDE(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
KDE.Definition = {
  'type': 'KDE',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'cumulative',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'counts',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'steps',
    'type': 'number'
  }, {
    'name': 'minsteps',
    'type': 'number',
    'default': 25
  }, {
    'name': 'maxsteps',
    'type': 'number',
    'default': 200
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['value', 'density']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(KDE, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
            groups = partition$1(source, _.groupby, _.field),
            names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
            bandwidth = _.bandwidth,
            method = _.cumulative ? 'cdf' : 'pdf',
            as = _.as || ['value', 'density'],
            values = [];
      let domain = _.extent,
          minsteps = _.steps || _.minsteps || 25,
          maxsteps = _.steps || _.maxsteps || 200;

      if (method !== 'pdf' && method !== 'cdf') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid density method: ' + method);
      }

      if (_.resolve === 'shared') {
        if (!domain) domain = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(source, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }

      groups.forEach(g => {
        const density = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomKDE)(g, bandwidth)[method],
              scale = _.counts ? g.length : 1,
              local = domain || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(g);
        (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.sampleCurve)(density, local, minsteps, maxsteps).forEach(v => {
          const t = {};

          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }

          t[as[0]] = v[0];
          t[as[1]] = v[1] * scale;
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});

/**
 * Generates a key function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<string>} params.fields - The field name(s) for the key function.
 * @param {boolean} params.flat - A boolean flag indicating if the field names
 *  should be treated as flat property names, side-stepping nested field
 *  lookups normally indicated by dot or bracket notation.
 */

function Key(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$2, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Key, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$2(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.key)(_.fields, _.flat);
}

/**
 * Load and parse data from an external source. Marshalls parameter
 * values and then invokes the Dataflow request method.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.url - The URL to load from.
 * @param {object} params.format - The data format options.
 */

function Load(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
  this._pending = null;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Load, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow;

    if (this._pending) {
      // update state and return pulse
      return output(this, pulse, this._pending);
    }

    if (stop(_)) return pulse.StopPropagation;

    if (_.values) {
      // parse and ingest values, return output pulse
      return output(this, pulse, df.parse(_.values, _.format));
    } else if (_.async) {
      // return promise for non-blocking async loading
      const p = df.request(_.url, _.format).then(res => {
        this._pending = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(res.data);
        return df => df.touch(this);
      });
      return {
        async: p
      };
    } else {
      // return promise for synchronous loading
      return df.request(_.url, _.format).then(res => output(this, pulse, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(res.data)));
    }
  }

});

function stop(_) {
  return _.modified('async') && !(_.modified('values') || _.modified('url') || _.modified('format'));
}

function output(op, pulse, data) {
  data.forEach(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest);
  const out = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data;
  op._pending = null;
  if (out.rem.length) out.clean(true);
  return out;
}

/**
 * Extend tuples by joining them with values from a lookup table.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Map} params.index - The lookup table map.
 * @param {Array<function(object): *} params.fields - The fields to lookup.
 * @param {Array<string>} params.as - Output field names for each lookup value.
 * @param {*} [params.default] - A default value to use if lookup fails.
 */

function Lookup(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
}
Lookup.Definition = {
  'type': 'Lookup',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'index',
    'type': 'index',
    'params': [{
      'name': 'from',
      'type': 'data',
      'required': true
    }, {
      'name': 'key',
      'type': 'field',
      'required': true
    }]
  }, {
    'name': 'values',
    'type': 'field',
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }, {
    'name': 'default',
    'default': null
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Lookup, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const keys = _.fields,
          index = _.index,
          values = _.values,
          defaultValue = _.default == null ? null : _.default,
          reset = _.modified(),
          n = keys.length;

    let flag = reset ? pulse.SOURCE : pulse.ADD,
        out = pulse,
        as = _.as,
        set,
        m,
        mods;

    if (values) {
      m = values.length;

      if (n > 1 && !as) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Multi-field lookup requires explicit "as" parameter.');
      }

      if (as && as.length !== n * m) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('The "as" parameter has too few output field names.');
      }

      as = as || values.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName);

      set = function (t) {
        for (var i = 0, k = 0, j, v; i < n; ++i) {
          v = index.get(keys[i](t));
          if (v == null) for (j = 0; j < m; ++j, ++k) t[as[k]] = defaultValue;else for (j = 0; j < m; ++j, ++k) t[as[k]] = values[j](v);
        }
      };
    } else {
      if (!as) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing output field names.');
      }

      set = function (t) {
        for (var i = 0, v; i < n; ++i) {
          v = index.get(keys[i](t));
          t[as[i]] = v == null ? defaultValue : v;
        }
      };
    }

    if (reset) {
      out = pulse.reflow(true);
    } else {
      mods = keys.some(k => pulse.modified(k.fields));
      flag |= mods ? pulse.MOD : 0;
    }

    pulse.visit(flag, set);
    return out.modifies(as);
  }

});

/**
 * Computes global min/max extents over a collection of extents.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<Array<number>>} params.extents - The input extents.
 */

function MultiExtent(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$1, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiExtent, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }

  const ext = _.extents,
        n = ext.length;
  let min = +Infinity,
      max = -Infinity,
      i,
      e;

  for (i = 0; i < n; ++i) {
    e = ext[i];
    if (e[0] < min) min = e[0];
    if (e[1] > max) max = e[1];
  }

  return [min, max];
}

/**
 * Merge a collection of value arrays.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<Array<*>>} params.values - The input value arrrays.
 */

function MultiValues(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiValues, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data, _) => data.concat(_), []);
}

/**
 * Operator whose value is simply its parameter hash. This operator is
 * useful for enabling reactive updates to values of nested objects.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Params(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Params, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.modified(_.modified());
    this.value = _;
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples
  }

});

/**
 * Aggregate and pivot selected field values to become new fields.
 * This operator is useful to construction cross-tabulations.
 * @constructor
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *  to groupby. These fields act just like groupby fields of an Aggregate transform.
 * @param {function(object): *} params.field - The field to pivot on. The unique
 *  values of this field become new field names in the output stream.
 * @param {function(object): *} params.value - The field to populate pivoted fields.
 *  The aggregate values of this field become the values of the new pivoted fields.
 * @param {string} [params.op] - The aggregation operation for the value field,
 *  applied per cell in the output stream. The default is "sum".
 * @param {number} [params.limit] - An optional parameter indicating the maximum
 *  number of pivoted fields to generate. The pivoted field names are sorted in
 *  ascending order prior to enforcing the limit.
 */

function Pivot(params) {
  Aggregate.call(this, params);
}
Pivot.Definition = {
  'type': 'Pivot',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'value',
    'type': 'field',
    'required': true
  }, {
    'name': 'op',
    'type': 'enum',
    'values': ValidAggregateOps,
    'default': 'sum'
  }, {
    'name': 'limit',
    'type': 'number',
    'default': 0
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Pivot, Aggregate, {
  _transform: Aggregate.prototype.transform,

  transform(_, pulse) {
    return this._transform(aggregateParams(_, pulse), pulse);
  }

}); // Shoehorn a pivot transform into an aggregate transform!
// First collect all unique pivot field values.
// Then generate aggregate fields for each output pivot field.

function aggregateParams(_, pulse) {
  const key = _.field,
        value = _.value,
        op = (_.op === 'count' ? '__count__' : _.op) || 'sum',
        fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(key).concat((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(value)),
        keys = pivotKeys(key, _.limit || 0, pulse); // if data stream content changes, pivot fields may change
  // flag parameter modification to ensure re-initialization

  if (pulse.changed()) _.set('__pivot__', null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys.map(() => op),
    fields: keys.map(k => get(k, key, value, fields)),
    as: keys.map(k => k + ''),
    modified: _.modified.bind(_)
  };
} // Generate aggregate field accessor.
// Output NaN for non-existent values; aggregator will ignore!


function get(k, key, value, fields) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(d => key(d) === k ? value(d) : NaN, fields, k + '');
} // Collect (and optionally limit) all unique pivot values.


function pivotKeys(key, limit, pulse) {
  const map = {},
        list = [];
  pulse.visit(pulse.SOURCE, t => {
    const k = key(t);

    if (!map[k]) {
      map[k] = 1;
      list.push(k);
    }
  });
  list.sort(vega_util__WEBPACK_IMPORTED_MODULE_0__.ascending);
  return limit ? list.slice(0, limit) : list;
}

/**
 * Partitions pre-faceted data into tuple subflows.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Dataflow, string): Operator} params.subflow - A function
 *   that generates a subflow of operators and returns its root operator.
 * @param {function(object): Array<object>} params.field - The field
 *   accessor for an array of subflow tuple objects.
 */

function PreFacet(params) {
  Facet.call(this, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(PreFacet, Facet, {
  transform(_, pulse) {
    const flow = _.subflow,
          field = _.field,
          subflow = t => this.subflow((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), flow, pulse, t);

    if (_.modified('field') || field && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field))) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('PreFacet does not support field modification.');
    }

    this.initTargets(); // reset list of active subflows

    if (field) {
      pulse.visit(pulse.MOD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.mod(_));
      });
      pulse.visit(pulse.ADD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.add((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(_)));
      });
      pulse.visit(pulse.REM, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.rem(_));
      });
    } else {
      pulse.visit(pulse.MOD, t => subflow(t).mod(t));
      pulse.visit(pulse.ADD, t => subflow(t).add(t));
      pulse.visit(pulse.REM, t => subflow(t).rem(t));
    }

    if (pulse.clean()) {
      pulse.runAfter(() => this.clean());
    }

    return pulse;
  }

});

/**
 * Performs a relational projection, copying selected fields from source
 * tuples to a new set of derived tuples.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *} params.fields - The fields to project,
 *   as an array of field accessors. If unspecified, all fields will be
 *   copied with names unchanged.
 * @param {Array<string>} [params.as] - Output field names for each projected
 *   field. Any unspecified fields will use the field name provided by
 *   the field accessor.
 */

function Project(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Project.Definition = {
  'type': 'Project',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Project, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          fields = _.fields,
          as = fieldNames(_.fields, _.as || []),
          derive = fields ? (s, t) => project(s, t, fields, as) : vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.rederive;
    let lut;

    if (this.value) {
      lut = this.value;
    } else {
      pulse = pulse.addAll();
      lut = this.value = {};
    }

    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
      out.rem.push(lut[id]);
      lut[id] = null;
    });
    pulse.visit(pulse.ADD, t => {
      const dt = derive(t, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({}));
      lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = dt;
      out.add.push(dt);
    });
    pulse.visit(pulse.MOD, t => {
      out.mod.push(derive(t, lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]));
    });
    return out;
  }

});

function project(s, t, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t[as[i]] = fields[i](s);
  }

  return t;
}

/**
 * Proxy the value of another operator as a pure signal value.
 * Ensures no tuples are propagated.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {*} params.value - The value to proxy, becomes the value of this operator.
 */

function Proxy(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Proxy, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.value = _.value;
    return _.modified('value') ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
  }

});

/**
 * Generates sample quantile values from an input data stream.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - An accessor for the data field
 *   over which to calculate quantile values.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {Array<number>} [params.probs] - An array of probabilities in
 *   the range (0, 1) for which to compute quantile values. If not specified,
 *   the *step* parameter will be used.
 * @param {Array<number>} [params.step=0.01] - A probability step size for
 *   sampling quantile values. All values from one-half the step size up to
 *   1 (exclusive) will be sampled. This parameter is only used if the
 *   *quantiles* parameter is not provided.
 */

function Quantile(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Quantile.Definition = {
  'type': 'Quantile',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'probs',
    'type': 'number',
    'array': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 0.01
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['prob', 'value']
  }]
};
const EPSILON = 1e-14;
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Quantile, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
          as = _.as || ['prob', 'value'];

    if (this.value && !_.modified() && !pulse.changed()) {
      out.source = this.value;
      return out;
    }

    const source = pulse.materialize(pulse.SOURCE).source,
          groups = partition$1(source, _.groupby, _.field),
          names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
          values = [],
          step = _.step || 0.01,
          p = _.probs || (0,d3_array__WEBPACK_IMPORTED_MODULE_8__.default)(step / 2, 1 - EPSILON, step),
          n = p.length;
    groups.forEach(g => {
      const q = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.quantiles)(g, p);

      for (let i = 0; i < n; ++i) {
        const t = {};

        for (let i = 0; i < names.length; ++i) {
          t[names[i]] = g.dims[i];
        }

        t[as[0]] = p[i];
        t[as[1]] = q[i];
        values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
      }
    });
    if (this.value) out.rem = this.value;
    this.value = out.add = out.source = values;
    return out;
  }

});

/**
 * Relays a data stream between data processing pipelines.
 * If the derive parameter is set, this transform will create derived
 * copies of observed tuples. This provides derived data streams in which
 * modifications to the tuples do not pollute an upstream data source.
 * @param {object} params - The parameters for this operator.
 * @param {number} [params.derive=false] - Boolean flag indicating if
 *   the transform should make derived copies of incoming tuples.
 * @constructor
 */

function Relay(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Relay, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    let out, lut;

    if (this.value) {
      lut = this.value;
    } else {
      out = pulse = pulse.addAll();
      lut = this.value = {};
    }

    if (_.derive) {
      out = pulse.fork(pulse.NO_SOURCE);
      pulse.visit(pulse.REM, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
        out.rem.push(lut[id]);
        lut[id] = null;
      });
      pulse.visit(pulse.ADD, t => {
        const dt = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);
        lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = dt;
        out.add.push(dt);
      });
      pulse.visit(pulse.MOD, t => {
        const dt = lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)];

        for (const k in t) {
          dt[k] = t[k]; // down stream writes may overwrite re-derived tuples
          // conservatively mark all source fields as modified

          out.modifies(k);
        }

        out.mod.push(dt);
      });
    }

    return out;
  }

});

/**
 * Samples tuples passing through this operator.
 * Uses reservoir sampling to maintain a representative sample.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {number} [params.size=1000] - The maximum number of samples.
 */

function Sample(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
  this.count = 0;
}
Sample.Definition = {
  'type': 'Sample',
  'metadata': {},
  'params': [{
    'name': 'size',
    'type': 'number',
    'default': 1000
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sample, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          mod = _.modified('size'),
          num = _.size,
          map = this.value.reduce((m, t) => (m[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = 1, m), {});

    let res = this.value,
        cnt = this.count,
        cap = 0; // sample reservoir update function

    function update(t) {
      let p, idx;

      if (res.length < num) {
        res.push(t);
      } else {
        idx = ~~((cnt + 1) * (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.random)());

        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(p)]) out.rem.push(p); // eviction

          res[idx] = t;
        }
      }

      ++cnt;
    }

    if (pulse.rem.length) {
      // find all tuples that should be removed, add to output
      pulse.visit(pulse.REM, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);

        if (map[id]) {
          map[id] = -1;
          out.rem.push(t);
        }

        --cnt;
      }); // filter removed tuples out of the sample reservoir

      res = res.filter(t => map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] !== -1);
    }

    if ((pulse.rem.length || mod) && res.length < num && pulse.source) {
      // replenish sample if backing data source is available
      cap = cnt = res.length;
      pulse.visit(pulse.SOURCE, t => {
        // update, but skip previously sampled tuples
        if (!map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]) update(t);
      });
      cap = -1;
    }

    if (mod && res.length > num) {
      const n = res.length - num;

      for (let i = 0; i < n; ++i) {
        map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(res[i])] = -1;
        out.rem.push(res[i]);
      }

      res = res.slice(n);
    }

    if (pulse.mod.length) {
      // propagate modified tuples in the sample reservoir
      pulse.visit(pulse.MOD, t => {
        if (map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]) out.mod.push(t);
      });
    }

    if (pulse.add.length) {
      // update sample reservoir
      pulse.visit(pulse.ADD, update);
    }

    if (pulse.add.length || cap < 0) {
      // output newly added tuples
      out.add = res.filter(t => !map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]);
    }

    this.count = cnt;
    this.value = out.source = res;
    return out;
  }

});

/**
 * Generates data tuples for a specified sequence range of numbers.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {number} params.start - The first number in the sequence.
 * @param {number} params.stop - The last number (exclusive) in the sequence.
 * @param {number} [params.step=1] - The step size between numbers in the sequence.
 */

function Sequence(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Sequence.Definition = {
  'type': 'Sequence',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'start',
    'type': 'number',
    'required': true
  }, {
    'name': 'stop',
    'type': 'number',
    'required': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 1
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'data'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sequence, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (this.value && !_.modified()) return;
    const out = pulse.materialize().fork(pulse.MOD),
          as = _.as || 'data';
    out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;
    this.value = (0,d3_array__WEBPACK_IMPORTED_MODULE_8__.default)(_.start, _.stop, _.step || 1).map(v => {
      const t = {};
      t[as] = v;
      return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t);
    });
    out.add = pulse.add.concat(this.value);
    return out;
  }

});

/**
 * Propagates a new pulse without any tuples so long as the input
 * pulse contains some added, removed or modified tuples.
 * @param {object} params - The parameters for this operator.
 * @constructor
 */

function Sieve(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sieve, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.value = pulse.source;
    return pulse.changed() ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
  }

});

/**
 * Discretize dates to specific time units.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The data field containing date/time values.
 */

function TimeUnit(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
const OUTPUT = ['unit0', 'unit1'];
TimeUnit.Definition = {
  'type': 'TimeUnit',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'interval',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'units',
    'type': 'enum',
    'values': vega_time__WEBPACK_IMPORTED_MODULE_3__.TIME_UNITS,
    'array': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 1
  }, {
    'name': 'maxbins',
    'type': 'number',
    'default': 40
  }, {
    'name': 'extent',
    'type': 'date',
    'array': true
  }, {
    'name': 'timezone',
    'type': 'enum',
    'default': 'local',
    'values': ['local', 'utc']
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': OUTPUT
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(TimeUnit, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const field = _.field,
          band = _.interval !== false,
          utc = _.timezone === 'utc',
          floor = this._floor(_, pulse),
          offset = (utc ? vega_time__WEBPACK_IMPORTED_MODULE_3__.utcInterval : vega_time__WEBPACK_IMPORTED_MODULE_3__.timeInterval)(floor.unit).offset,
          as = _.as || OUTPUT,
          u0 = as[0],
          u1 = as[1],
          step = floor.step;

    let min = floor.start || Infinity,
        max = floor.stop || -Infinity,
        flag = pulse.ADD;

    if (_.modified() || pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field))) {
      pulse = pulse.reflow(true);
      flag = pulse.SOURCE;
      min = Infinity;
      max = -Infinity;
    }

    pulse.visit(flag, t => {
      const v = field(t);
      let a, b;

      if (v == null) {
        t[u0] = null;
        if (band) t[u1] = null;
      } else {
        t[u0] = a = b = floor(v);
        if (band) t[u1] = b = offset(a, step);
        if (a < min) min = a;
        if (b > max) max = b;
      }
    });
    floor.start = min;
    floor.stop = max;
    return pulse.modifies(band ? as : u0);
  },

  _floor(_, pulse) {
    const utc = _.timezone === 'utc'; // get parameters

    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : (0,vega_time__WEBPACK_IMPORTED_MODULE_3__.timeBin)({
      extent: _.extent || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(pulse.materialize(pulse.SOURCE).source, _.field),
      maxbins: _.maxbins
    }); // check / standardize time units

    const tunits = (0,vega_time__WEBPACK_IMPORTED_MODULE_3__.timeUnits)(units),
          prev = this.value || {},
          floor = (utc ? vega_time__WEBPACK_IMPORTED_MODULE_3__.utcFloor : vega_time__WEBPACK_IMPORTED_MODULE_3__.timeFloor)(tunits, step);
    floor.unit = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(tunits);
    floor.units = tunits;
    floor.step = step;
    floor.start = prev.start;
    floor.stop = prev.stop;
    return this.value = floor;
  }

});

/**
 * An index that maps from unique, string-coerced, field values to tuples.
 * Assumes that the field serves as a unique key with no duplicate values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The field accessor to index.
 */

function TupleIndex(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(), params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(TupleIndex, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow,
          field = _.field,
          index = this.value,
          set = t => index.set(field(t), t);

    let mod = true;

    if (_.modified('field') || pulse.modified(field.fields)) {
      index.clear();
      pulse.visit(pulse.SOURCE, set);
    } else if (pulse.changed()) {
      pulse.visit(pulse.REM, t => index.delete(field(t)));
      pulse.visit(pulse.ADD, set);
    } else {
      mod = false;
    }

    this.modified(mod);
    if (index.empty > df.cleanThreshold) df.runAfter(index.clean);
    return pulse.fork();
  }

});

/**
 * Extracts an array of values. Assumes the source data has already been
 * reduced as needed (e.g., by an upstream Aggregate transform).
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The domain field to extract.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for sorting the values. The comparator will be
 *   applied to backing tuples prior to value extraction.
 */

function Values(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Values, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const run = !this.value || _.modified('field') || _.modified('sort') || pulse.changed() || _.sort && pulse.modified(_.sort.fields);

    if (run) {
      this.value = (_.sort ? pulse.source.slice().sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(_.sort)) : pulse.source).map(_.field);
    }
  }

});

function WindowOp(op, field, param, as) {
  const fn = WindowOps[op](field, param);
  return {
    init: fn.init || vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
    update: function (w, t) {
      t[as] = fn.next(w);
    }
  };
}
const WindowOps = {
  row_number: function () {
    return {
      next: w => w.index + 1
    };
  },
  rank: function () {
    let rank;
    return {
      init: () => rank = 1,
      next: w => {
        const i = w.index,
              data = w.data;
        return i && w.compare(data[i - 1], data[i]) ? rank = i + 1 : rank;
      }
    };
  },
  dense_rank: function () {
    let drank;
    return {
      init: () => drank = 1,
      next: w => {
        const i = w.index,
              d = w.data;
        return i && w.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function () {
    const rank = WindowOps.rank(),
          next = rank.next;
    return {
      init: rank.init,
      next: w => (next(w) - 1) / (w.data.length - 1)
    };
  },
  cume_dist: function () {
    let cume;
    return {
      init: () => cume = 0,
      next: w => {
        const d = w.data,
              c = w.compare;
        let i = w.index;

        if (cume < i) {
          while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;

          cume = i;
        }

        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function (field, num) {
    num = +num;
    if (!(num > 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('ntile num must be greater than zero.');
    const cume = WindowOps.cume_dist(),
          next = cume.next;
    return {
      init: cume.init,
      next: w => Math.ceil(num * next(w))
    };
  },
  lag: function (field, offset) {
    offset = +offset || 1;
    return {
      next: w => {
        const i = w.index - offset;
        return i >= 0 ? field(w.data[i]) : null;
      }
    };
  },
  lead: function (field, offset) {
    offset = +offset || 1;
    return {
      next: w => {
        const i = w.index + offset,
              d = w.data;
        return i < d.length ? field(d[i]) : null;
      }
    };
  },
  first_value: function (field) {
    return {
      next: w => field(w.data[w.i0])
    };
  },
  last_value: function (field) {
    return {
      next: w => field(w.data[w.i1 - 1])
    };
  },
  nth_value: function (field, nth) {
    nth = +nth;
    if (!(nth > 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('nth_value nth must be greater than zero.');
    return {
      next: w => {
        const i = w.i0 + (nth - 1);
        return i < w.i1 ? field(w.data[i]) : null;
      }
    };
  },
  prev_value: function (field) {
    let prev;
    return {
      init: () => prev = null,
      next: w => {
        const v = field(w.data[w.index]);
        return v != null ? prev = v : prev;
      }
    };
  },
  next_value: function (field) {
    let v, i;
    return {
      init: () => (v = null, i = -1),
      next: w => {
        const d = w.data;
        return w.index <= i ? v : (i = find(field, d, w.index)) < 0 ? (i = d.length, v = null) : v = field(d[i]);
      }
    };
  }
};

function find(field, data, index) {
  for (let n = data.length; index < n; ++index) {
    const v = field(data[index]);
    if (v != null) return index;
  }

  return -1;
}

const ValidWindowOps = Object.keys(WindowOps);

function WindowState(_) {
  const ops = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.ops),
        fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.fields),
        params = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.params),
        as = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.as),
        outputs = this.outputs = [],
        windows = this.windows = [],
        inputs = {},
        map = {},
        counts = [],
        measures = [];
  let countOnly = true;

  function visitInputs(f) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(f)).forEach(_ => inputs[_] = 1);
  }

  visitInputs(_.sort);
  ops.forEach((op, i) => {
    const field = fields[i],
          mname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field),
          name = measureName(op, mname, as[i]);
    visitInputs(field);
    outputs.push(name); // Window operation

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(WindowOps, op)) {
      windows.push(WindowOp(op, fields[i], params[i], name));
    } // Aggregate operation
    else {
        if (field == null && op !== 'count') {
          (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Null aggregate field specified.');
        }

        if (op === 'count') {
          counts.push(name);
          return;
        }

        countOnly = false;
        let m = map[mname];

        if (!m) {
          m = map[mname] = [];
          m.field = field;
          measures.push(m);
        }

        m.push(createMeasure(op, name));
      }
  });

  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }

  this.inputs = Object.keys(inputs);
}
const prototype = WindowState.prototype;

prototype.init = function () {
  this.windows.forEach(_ => _.init());
  if (this.cell) this.cell.init();
};

prototype.update = function (w, t) {
  const cell = this.cell,
        wind = this.windows,
        data = w.data,
        m = wind && wind.length;
  let j;

  if (cell) {
    for (j = w.p0; j < w.i0; ++j) cell.rem(data[j]);

    for (j = w.p1; j < w.i1; ++j) cell.add(data[j]);

    cell.set(t);
  }

  for (j = 0; j < m; ++j) wind[j].update(w, t);
};

function cell(measures, counts, countOnly) {
  measures = measures.map(m => compileMeasures(m, m.field));
  const cell = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };

  if (!countOnly) {
    var n = measures.length,
        a = cell.agg = Array(n),
        i = 0;

    for (; i < n; ++i) a[i] = new measures[i](cell);
  }

  if (cell.store) {
    var store = cell.data = new TupleStore();
  }

  cell.add = function (t) {
    cell.num += 1;
    if (countOnly) return;
    if (store) store.add(t);

    for (let i = 0; i < n; ++i) {
      a[i].add(a[i].get(t), t);
    }
  };

  cell.rem = function (t) {
    cell.num -= 1;
    if (countOnly) return;
    if (store) store.rem(t);

    for (let i = 0; i < n; ++i) {
      a[i].rem(a[i].get(t), t);
    }
  };

  cell.set = function (t) {
    let i, n; // consolidate stored values

    if (store) store.values(); // update tuple properties

    for (i = 0, n = counts.length; i < n; ++i) t[counts[i]] = cell.num;

    if (!countOnly) for (i = 0, n = a.length; i < n; ++i) a[i].set(t);
  };

  cell.init = function () {
    cell.num = 0;
    if (store) store.reset();

    for (let i = 0; i < n; ++i) a[i].init();
  };

  return cell;
}

/**
 * Perform window calculations and write results to the input stream.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.
 * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.
 * @param {Array<function(object): *>} [params.fields] - An array of accessors
 *   for data fields to use as inputs to window operations.
 * @param {Array<*>} [params.params] - An array of parameter values for window operations.
 * @param {Array<string>} [params.as] - An array of output field names for window operations.
 * @param {Array<number>} [params.frame] - Window frame definition as two-element array.
 * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row
 *   number alone, ignoring peers with identical sort values. If false (default),
 *   the window boundaries will be adjusted to include peer values.
 */

function Window(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  'type': 'Window',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidWindowOps.concat(ValidAggregateOps)
  }, {
    'name': 'params',
    'type': 'number',
    'null': true,
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'frame',
    'type': 'number',
    'null': true,
    'array': true,
    'length': 2,
    'default': [null, 0]
  }, {
    'name': 'ignorePeers',
    'type': 'boolean',
    'default': false
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Window, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.stamp = pulse.stamp;

    const mod = _.modified(),
          cmp = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(_.sort),
          key = groupkey(_.groupby),
          group = t => this.group(key(t)); // initialize window state


    let state = this.state;

    if (!state || mod) {
      state = this.state = new WindowState(_);
    } // partition input tuples


    if (mod || pulse.modified(state.inputs)) {
      this.value = {};
      pulse.visit(pulse.SOURCE, t => group(t).add(t));
    } else {
      pulse.visit(pulse.REM, t => group(t).remove(t));
      pulse.visit(pulse.ADD, t => group(t).add(t));
    } // perform window calculations for each modified partition


    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp, _);
    }

    this._mlen = 0;
    this._mods = []; // TODO don't reflow everything?

    return pulse.reflow(mod).modifies(state.outputs);
  },

  group(key) {
    let group = this.value[key];

    if (!group) {
      group = this.value[key] = SortedList(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid);
      group.stamp = -1;
    }

    if (group.stamp < this.stamp) {
      group.stamp = this.stamp;
      this._mods[this._mlen++] = group;
    }

    return group;
  }

});

function processPartition(list, state, cmp, _) {
  const sort = _.sort,
        range = sort && !_.ignorePeers,
        frame = _.frame || [null, 0],
        data = list.data(cmp),
        // use cmp for stable sort
  n = data.length,
        b = range ? (0,d3_array__WEBPACK_IMPORTED_MODULE_9__.default)(sort) : null,
        w = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data,
    compare: sort || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(-1)
  };
  state.init();

  for (let i = 0; i < n; ++i) {
    setWindow(w, frame, i, n);
    if (range) adjustRange(w, b);
    state.update(w, data[i]);
  }
}

function setWindow(w, f, i, n) {
  w.p0 = w.i0;
  w.p1 = w.i1;
  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w.index = i;
} // if frame type is 'range', adjust window for peer values


function adjustRange(w, bisect) {
  const r0 = w.i0,
        r1 = w.i1 - 1,
        c = w.compare,
        d = w.data,
        n = d.length - 1;
  if (r0 > 0 && !c(d[r0], d[r0 - 1])) w.i0 = bisect.left(d, d[r0]);
  if (r1 < n && !c(d[r1], d[r1 + 1])) w.i1 = bisect.right(d, d[r1]);
}




/***/ }),

/***/ "../../node_modules/vega-view-transforms/build/vega-view-transforms.module.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/vega-view-transforms/build/vega-view-transforms.module.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bound": () => (/* binding */ Bound),
/* harmony export */   "identifier": () => (/* binding */ Identifier),
/* harmony export */   "mark": () => (/* binding */ Mark),
/* harmony export */   "overlap": () => (/* binding */ Overlap),
/* harmony export */   "render": () => (/* binding */ Render),
/* harmony export */   "viewlayout": () => (/* binding */ ViewLayout)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");




const Top = 'top';
const Left = 'left';
const Right = 'right';
const Bottom = 'bottom';
const TopLeft = 'top-left';
const TopRight = 'top-right';
const BottomLeft = 'bottom-left';
const BottomRight = 'bottom-right';
const Start = 'start';
const Middle = 'middle';
const End = 'end';
const X = 'x';
const Y = 'y';
const Group = 'group';
const AxisRole = 'axis';
const TitleRole = 'title';
const FrameRole = 'frame';
const ScopeRole = 'scope';
const LegendRole = 'legend';
const RowHeader = 'row-header';
const RowFooter = 'row-footer';
const RowTitle = 'row-title';
const ColHeader = 'column-header';
const ColFooter = 'column-footer';
const ColTitle = 'column-title';
const Padding = 'padding';
const Symbols = 'symbol';
const Fit = 'fit';
const FitX = 'fit-x';
const FitY = 'fit-y';
const Pad = 'pad';
const None = 'none';
const All = 'all';
const Each = 'each';
const Flush = 'flush';
const Column = 'column';
const Row = 'row';

/**
 * Calculate bounding boxes for scenegraph items.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.mark - The scenegraph mark instance to bound.
 */

function Bound(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Bound, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow,
          mark = _.mark,
          type = mark.marktype,
          entry = vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Marks[type],
          bound = entry.bound;
    let markBounds = mark.bounds,
        rebound;

    if (entry.nested) {
      // multi-item marks have a single bounds instance
      if (mark.items.length) view.dirty(mark.items[0]);
      markBounds = boundItem(mark, bound);
      mark.items.forEach(item => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type === Group || _.modified()) {
      // operator parameters modified -> re-bound all items
      // updates group bounds in response to modified group content
      pulse.visit(pulse.MOD, item => view.dirty(item));
      markBounds.clear();
      mark.items.forEach(item => markBounds.union(boundItem(item, bound))); // force reflow for axes/legends/titles to propagate any layout changes

      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          pulse.reflow();
      }
    } else {
      // incrementally update bounds, re-bound mark as needed
      rebound = pulse.changed(pulse.REM);
      pulse.visit(pulse.ADD, item => {
        markBounds.union(boundItem(item, bound));
      });
      pulse.visit(pulse.MOD, item => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem(item, bound));
      });

      if (rebound) {
        markBounds.clear();
        mark.items.forEach(item => markBounds.union(item.bounds));
      }
    } // ensure mark bounds do not exceed any clipping region


    (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundClip)(mark);
    return pulse.modifies('bounds');
  }

});

function boundItem(item, bound, opt) {
  return bound(item.bounds.clear(), item, opt);
}

const COUNTER_NAME = ':vega_identifier:';
/**
 * Adds a unique identifier to all added tuples.
 * This transform creates a new signal that serves as an id counter.
 * As a result, the id counter is shared across all instances of this
 * transform, generating unique ids across multiple data streams. In
 * addition, this signal value can be included in a snapshot of the
 * dataflow state, enabling correct resumption of id allocation.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.as - The field name for the generated identifier.
 */

function Identifier(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, 0, params);
}
Identifier.Definition = {
  'type': 'Identifier',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'as',
    'type': 'string',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Identifier, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const counter = getCounter(pulse.dataflow),
          as = _.as;
    let id = counter.value;
    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);
    counter.set(this.value = id);
    return pulse;
  }

});

function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}

/**
 * Bind scenegraph items to a scenegraph mark instance.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.markdef - The mark definition for creating the mark.
 *   This is an object of legal scenegraph mark properties which *must* include
 *   the 'marktype' property.
 */

function Mark(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Mark, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    let mark = this.value; // acquire mark on first invocation, bind context and group

    if (!mark) {
      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);
      mark.group.context = _.context;
      if (!_.context.group) _.context.group = mark.group;
      mark.source = this.source; // point to upstream collector

      mark.clip = _.clip;
      mark.interactive = _.interactive;
      this.value = mark;
    } // initialize entering items


    const Init = mark.marktype === Group ? vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.GroupItem : vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Item;
    pulse.visit(pulse.ADD, item => Init.call(item, mark)); // update clipping and/or interactive status

    if (_.modified('clip') || _.modified('interactive')) {
      mark.clip = _.clip;
      mark.interactive = !!_.interactive;
      mark.zdirty = true; // force scenegraph re-eval

      pulse.reflow();
    } // bind items array to scenegraph mark


    mark.items = pulse.source;
    return pulse;
  }

});

function lookup(_) {
  const g = _.groups,
        p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}

/**
 * Analyze items for overlap, changing opacity to hide items with
 * overlapping bounding boxes. This transform will preserve at least
 * two items (e.g., first and last) even if overlap persists.
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator
 *   function for sorting items.
 * @param {object} [params.method] - The overlap removal method to apply.
 *   One of 'parity' (default, hide every other item until there is no
 *   more overlap) or 'greedy' (sequentially scan and hide and items that
 *   overlap with the last visible item).
 * @param {object} [params.boundScale] - A scale whose range should be used
 *   to bound the items. Items exceeding the bounds of the scale range
 *   will be treated as overlapping. If null or undefined, no bounds check
 *   will be applied.
 * @param {object} [params.boundOrient] - The orientation of the scale
 *   (top, bottom, left, or right) used to bound items. This parameter is
 *   ignored if boundScale is null or undefined.
 * @param {object} [params.boundTolerance] - The tolerance in pixels for
 *   bound inclusion testing (default 1). This specifies by how many pixels
 *   an item's bounds may exceed the scale range bounds and not be culled.
 * @constructor
 */

function Overlap(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
const methods = {
  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items, sep) => {
    let a;
    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);
  }
}; // compute bounding box intersection
// including padding pixels of separation

const intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);

const hasOverlap = (items, pad) => {
  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {
    if (intersect(a, b = items[i].bounds, pad)) return true;
  }
};

const hasBounds = item => {
  const b = item.bounds;
  return b.width() > 1 && b.height() > 1;
};

const boundTest = (scale, orient, tolerance) => {
  var range = scale.range(),
      b = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds();

  if (orient === Top || orient === Bottom) {
    b.set(range[0], -Infinity, range[1], +Infinity);
  } else {
    b.set(-Infinity, range[0], +Infinity, range[1]);
  }

  b.expand(tolerance || 1);
  return item => b.encloses(item.bounds);
}; // reset all items to be fully opaque


const reset = source => {
  source.forEach(item => item.opacity = 1);
  return source;
}; // add all tuples to mod, fork pulse if parameters were modified
// fork prevents cross-stream tuple pollution (e.g., pulse from scale)


const reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');

(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Overlap, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const reduce = methods[_.method] || methods.parity,
          sep = _.separation || 0;
    let source = pulse.materialize(pulse.SOURCE).source,
        items,
        test;
    if (!source || !source.length) return;

    if (!_.method) {
      // early exit if method is falsy
      if (_.modified('method')) {
        reset(source);
        pulse = reflow(pulse, _);
      }

      return pulse;
    } // skip labels with no content


    source = source.filter(hasBounds); // early exit, nothing to do

    if (!source.length) return;

    if (_.sort) {
      source = source.slice().sort(_.sort);
    }

    items = reset(source);
    pulse = reflow(pulse, _);

    if (items.length >= 3 && hasOverlap(items, sep)) {
      do {
        items = reduce(items, sep);
      } while (items.length >= 3 && hasOverlap(items, sep));

      if (items.length < 3 && !(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(source).opacity) {
        if (items.length > 1) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(items).opacity = 0;
        (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(source).opacity = 1;
      }
    }

    if (_.boundScale && _.boundTolerance >= 0) {
      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source.forEach(item => {
        if (!test(item)) item.opacity = 0;
      });
    } // re-calculate mark bounds


    const bounds = items[0].mark.bounds.clear();
    source.forEach(item => {
      if (item.opacity) bounds.union(item.bounds);
    });
    return pulse;
  }

});

/**
 * Queue modified scenegraph items for rendering.
 * @constructor
 */

function Render(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Render, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow;
    pulse.visit(pulse.ALL, item => view.dirty(item)); // set z-index dirty flag as needed

    if (pulse.fields && pulse.fields['zindex']) {
      const item = pulse.source && pulse.source[0];
      if (item) item.mark.zdirty = true;
    }
  }

});

const tempBounds = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds();
function set(item, property, value) {
  return item[property] === value ? 0 : (item[property] = value, 1);
}

function isYAxis(mark) {
  var orient = mark.items[0].orient;
  return orient === Left || orient === Right;
}

function axisIndices(datum) {
  let index = +datum.grid;
  return [datum.ticks ? index++ : -1, // ticks index
  datum.labels ? index++ : -1, // labels index
  index + +datum.domain // title index
  ];
}

function axisLayout(view, axis, width, height) {
  var item = axis.items[0],
      datum = item.datum,
      delta = item.translate != null ? item.translate : 0.5,
      orient = item.orient,
      indices = axisIndices(datum),
      range = item.range,
      offset = item.offset,
      position = item.position,
      minExtent = item.minExtent,
      maxExtent = item.maxExtent,
      title = datum.title && item.items[indices[2]].items[0],
      titlePadding = item.titlePadding,
      bounds = item.bounds,
      dl = title && (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.multiLineOffset)(title),
      x = 0,
      y = 0,
      i,
      s;
  tempBounds.clear().union(bounds);
  bounds.clear();
  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);
  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds); // position axis group and title

  switch (orient) {
    case Top:
      x = position || 0;
      y = -offset;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));
      bounds.add(0, -s).add(range, 0);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);
      break;

    case Left:
      x = -offset;
      y = position || 0;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));
      bounds.add(-s, 0).add(0, range);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);
      break;

    case Right:
      x = width + offset;
      y = position || 0;
      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));
      bounds.add(0, 0).add(s, range);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);
      break;

    case Bottom:
      x = position || 0;
      y = height + offset;
      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));
      bounds.add(0, 0).add(range, s);
      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);
      break;

    default:
      x = item.x;
      y = item.y;
  } // update bounds


  (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundStroke)(bounds.translate(x, y), item);

  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {
    item.bounds = tempBounds;
    view.dirty(item);
    item.bounds = bounds;
    view.dirty(item);
  }

  return item.mark.bounds.clear().union(bounds);
}

function axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {
  const b = title.bounds;

  if (title.auto) {
    const v = sign * (offset + dl + pad);
    let dx = 0,
        dy = 0;
    view.dirty(title);
    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);
    title.mark.bounds.clear().union(b.translate(-dx, -dy));
    view.dirty(title);
  }

  bounds.union(b);
}

const min = (a, b) => Math.floor(Math.min(a, b));

const max = (a, b) => Math.ceil(Math.max(a, b));

function gridLayoutGroups(group) {
  var groups = group.items,
      n = groups.length,
      i = 0,
      mark,
      items;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  }; // layout axes, gather legends, collect bounds

  for (; i < n; ++i) {
    mark = groups[i];
    items = mark.items;

    if (mark.marktype === Group) {
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;

        case RowHeader:
          views.rowheaders.push(...items);
          break;

        case RowFooter:
          views.rowfooters.push(...items);
          break;

        case ColHeader:
          views.colheaders.push(...items);
          break;

        case ColFooter:
          views.colfooters.push(...items);
          break;

        case RowTitle:
          views.rowtitle = items[0];
          break;

        case ColTitle:
          views.coltitle = items[0];
          break;

        default:
          views.marks.push(...items);
      }
    }
  }

  return views;
}

function bboxFlush(item) {
  return new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds().set(0, 0, item.width || 0, item.height || 0);
}

function bboxFull(item) {
  const b = item.bounds.clone();
  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));
}

function get(opt, key, d) {
  const v = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(opt) ? opt[key] : opt;
  return v != null ? v : d !== undefined ? d : 0;
}

function offsetValue(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}

function gridLayout(view, groups, opt) {
  var dirty = !opt.nodirty,
      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,
      bounds = tempBounds.set(0, 0, 0, 0),
      alignCol = get(opt.align, Column),
      alignRow = get(opt.align, Row),
      padCol = get(opt.padding, Column),
      padRow = get(opt.padding, Row),
      ncols = opt.columns || groups.length,
      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),
      n = groups.length,
      xOffset = Array(n),
      xExtent = Array(ncols),
      xMax = 0,
      yOffset = Array(n),
      yExtent = Array(nrows),
      yMax = 0,
      dx = Array(n),
      dy = Array(n),
      boxes = Array(n),
      m,
      i,
      c,
      r,
      b,
      g,
      px,
      py,
      x,
      y,
      offset;

  for (i = 0; i < ncols; ++i) xExtent[i] = 0;

  for (i = 0; i < nrows; ++i) yExtent[i] = 0; // determine offsets for each group


  for (i = 0; i < n; ++i) {
    g = groups[i];
    b = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c = i % ncols;
    r = ~~(i / ncols);
    xMax = Math.max(xMax, px = Math.ceil(b.x2));
    yMax = Math.max(yMax, py = Math.ceil(b.y2));
    xExtent[c] = Math.max(xExtent[c], px);
    yExtent[r] = Math.max(yExtent[r], py);
    xOffset[i] = padCol + offsetValue(b.x1);
    yOffset[i] = padRow + offsetValue(b.y1);
    if (dirty) view.dirty(groups[i]);
  } // set initial alignment offsets


  for (i = 0; i < n; ++i) {
    if (i % ncols === 0) xOffset[i] = 0;
    if (i < ncols) yOffset[i] = 0;
  } // enforce column alignment constraints


  if (alignCol === Each) {
    for (c = 1; c < ncols; ++c) {
      for (offset = 0, i = c; i < n; i += ncols) {
        if (offset < xOffset[i]) offset = xOffset[i];
      }

      for (i = c; i < n; i += ncols) {
        xOffset[i] = offset + xExtent[c - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];
    }

    for (i = 0; i < n; ++i) {
      if (i % ncols) xOffset[i] = offset + xMax;
    }
  } else {
    for (alignCol = false, c = 1; c < ncols; ++c) {
      for (i = c; i < n; i += ncols) {
        xOffset[i] += xExtent[c - 1];
      }
    }
  } // enforce row alignment constraints


  if (alignRow === Each) {
    for (r = 1; r < nrows; ++r) {
      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {
        if (offset < yOffset[i]) offset = yOffset[i];
      }

      for (i = r * ncols; i < m; ++i) {
        yOffset[i] = offset + yExtent[r - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset = 0, i = ncols; i < n; ++i) {
      if (offset < yOffset[i]) offset = yOffset[i];
    }

    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset + yMax;
    }
  } else {
    for (alignRow = false, r = 1; r < nrows; ++r) {
      for (i = r * ncols, m = i + ncols; i < m; ++i) {
        yOffset[i] += yExtent[r - 1];
      }
    }
  } // perform horizontal grid layout


  for (x = 0, i = 0; i < n; ++i) {
    x = xOffset[i] + (i % ncols ? x : 0);
    dx[i] += x - groups[i].x;
  } // perform vertical grid layout


  for (c = 0; c < ncols; ++c) {
    for (y = 0, i = c; i < n; i += ncols) {
      y += yOffset[i];
      dy[i] += y - groups[i].y;
    }
  } // perform horizontal centering


  if (alignCol && get(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b = alignCol === All ? xMax : xExtent[i % ncols];
      x = b - boxes[i].x2 - groups[i].x - dx[i];
      if (x > 0) dx[i] += x / 2;
    }
  } // perform vertical centering


  if (alignRow && get(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y = b - boxes[i].y2 - groups[i].y - dy[i];
      if (y > 0) dy[i] += y / 2;
    }
  } // position grid relative to anchor


  for (i = 0; i < n; ++i) {
    bounds.union(boxes[i].translate(dx[i], dy[i]));
  }

  x = get(opt.anchor, X);
  y = get(opt.anchor, Y);

  switch (get(opt.anchor, Column)) {
    case End:
      x -= bounds.width();
      break;

    case Middle:
      x -= bounds.width() / 2;
  }

  switch (get(opt.anchor, Row)) {
    case End:
      y -= bounds.height();
      break;

    case Middle:
      y -= bounds.height() / 2;
  }

  x = Math.round(x);
  y = Math.round(y); // update mark positions, bounds, dirty

  bounds.clear();

  for (i = 0; i < n; ++i) {
    groups[i].mark.bounds.clear();
  }

  for (i = 0; i < n; ++i) {
    g = groups[i];
    g.x += dx[i] += x;
    g.y += dy[i] += y;
    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty) view.dirty(g);
  }

  return bounds;
}
function trellisLayout(view, group, opt) {
  var views = gridLayoutGroups(group),
      groups = views.marks,
      bbox = opt.bounds === Flush ? boundFlush : boundFull,
      off = opt.offset,
      ncols = opt.columns || groups.length,
      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),
      cells = nrows * ncols,
      x,
      y,
      x2,
      y2,
      anchor,
      band,
      offset; // -- initial grid layout

  const bounds = gridLayout(view, groups, opt);
  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid
  // -- layout grid headers and footers --
  // perform row header layout

  if (views.rowheaders) {
    band = get(opt.headerBand, Row, null);
    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);
  } // perform column header layout


  if (views.colheaders) {
    band = get(opt.headerBand, Column, null);
    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);
  } // perform row footer layout


  if (views.rowfooters) {
    band = get(opt.footerBand, Row, null);
    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);
  } // perform column footer layout


  if (views.colfooters) {
    band = get(opt.footerBand, Column, null);
    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);
  } // perform row title layout


  if (views.rowtitle) {
    anchor = get(opt.titleAnchor, Row);
    offset = get(off, 'rowTitle');
    offset = anchor === End ? x2 + offset : x - offset;
    band = get(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);
  } // perform column title layout


  if (views.coltitle) {
    anchor = get(opt.titleAnchor, Column);
    offset = get(off, 'columnTitle');
    offset = anchor === End ? y2 + offset : y - offset;
    band = get(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset, 1, bounds, band);
  }
}

function boundFlush(item, field) {
  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;
}

function boundFull(item, field) {
  return item.bounds[field];
}

function layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {
  var n = groups.length,
      init = 0,
      edge = 0,
      i,
      j,
      k,
      m,
      b,
      h,
      g,
      x,
      y; // if no groups, early exit and return 0

  if (!n) return init; // compute margin

  for (i = start; i < n; i += stride) {
    if (groups[i]) init = agg(init, bound(groups[i], bf));
  } // if no headers, return margin calculation


  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns

  if (headers.length > limit) {
    view.warn('Grid headers exceed limit: ' + limit);
    headers = headers.slice(0, limit);
  } // apply offset


  init += offset; // clear mark bounds for all headers

  for (j = 0, m = headers.length; j < m; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  } // layout each header


  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {
    h = headers[j];
    b = h.mark.bounds; // search for nearest group to align to
    // necessary if table has empty cells

    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back); // assign coordinates and update bounds


    if (isX) {
      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());
      y = init;
    } else {
      x = init;
      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());
    }

    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));
    h.x = x;
    h.y = y;
    view.dirty(h); // update current edge of layout bounds

    edge = agg(edge, b[bf]);
  }

  return edge;
}

function layoutTitle(view, g, offset, isX, bounds, band) {
  if (!g) return;
  view.dirty(g); // compute title coordinates

  var x = offset,
      y = offset;
  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds

  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x;
  g.y = y; // queue title for redraw

  view.dirty(g);
}

function lookup$1(config, orient) {
  const opt = config[orient] || {};
  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;
} // if legends specify offset directly, use the maximum specified value


function offsets(legends, value) {
  let max = -Infinity;
  legends.forEach(item => {
    if (item.offset != null) max = Math.max(max, item.offset);
  });
  return max > -Infinity ? max : value;
}

function legendParams(g, orient, config, xb, yb, w, h) {
  const _ = lookup$1(config, orient),
        offset = offsets(g, _('offset', 0)),
        anchor = _('anchor', Start),
        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;

  const p = {
    align: Each,
    bounds: _('bounds', Flush),
    columns: _('direction') === 'vertical' ? 1 : g.length,
    padding: _('margin', 8),
    center: _('center'),
    nodirty: true
  };

  switch (orient) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset,
        column: End,
        y: mult * (h || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;

    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset,
        y: mult * (h || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;

    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset,
        row: End,
        x: mult * (w || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;

    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset,
        x: mult * (w || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;

    case TopLeft:
      p.anchor = {
        x: offset,
        y: offset
      };
      break;

    case TopRight:
      p.anchor = {
        x: w - offset,
        y: offset,
        column: End
      };
      break;

    case BottomLeft:
      p.anchor = {
        x: offset,
        y: h - offset,
        row: End
      };
      break;

    case BottomRight:
      p.anchor = {
        x: w - offset,
        y: h - offset,
        column: End,
        row: End
      };
      break;
  }

  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0],
      datum = item.datum,
      orient = item.orient,
      bounds = item.bounds,
      x = item.x,
      y = item.y,
      w,
      h; // cache current bounds for later comparison

  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();
  bounds.clear(); // adjust legend to accommodate padding and title

  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin

  bounds = legendBounds(item, bounds);
  w = 2 * item.padding;
  h = 2 * item.padding;

  if (!bounds.empty()) {
    w = Math.ceil(bounds.width() + w);
    h = Math.ceil(bounds.height() + h);
  }

  if (datum.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }

  if (orient !== None) {
    item.x = x = 0;
    item.y = y = 0;
  }

  item.width = w;
  item.height = h;
  (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundStroke)(bounds.set(x, y, x + w, y + h), item);
  item.mark.bounds.clear().union(bounds);
  return item;
}

function legendBounds(item, b) {
  // aggregate item bounds
  item.items.forEach(_ => b.union(_.bounds)); // anchor to legend origin

  b.x1 = item.padding;
  b.y1 = item.padding;
  return b;
}

function legendGroupLayout(view, item, entry) {
  var pad = item.padding,
      ex = pad - entry.x,
      ey = pad - entry.y;

  if (!item.datum.title) {
    if (ex || ey) translate(view, entry, ex, ey);
  } else {
    var title = item.items[1].items[0],
        anchor = title.anchor,
        tpad = item.titlePadding || 0,
        tx = pad - title.x,
        ty = pad - title.y;

    switch (title.orient) {
      case Left:
        ex += Math.ceil(title.bounds.width()) + tpad;
        break;

      case Right:
      case Bottom:
        break;

      default:
        ey += title.bounds.height() + tpad;
    }

    if (ex || ey) translate(view, entry, ex, ey);

    switch (title.orient) {
      case Left:
        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);
        break;

      case Right:
        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);
        break;

      case Bottom:
        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);
        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;
        break;

      default:
        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);
    }

    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates

    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {
      translate(view, entry, -tx, 0);
      translate(view, title, -tx, 0);
    }
  }
}

function legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {
  const grad = item.datum.type !== 'symbol',
        vgrad = title.datum.vgrad,
        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,
        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,
        u = vgrad && lr ? s : 0,
        v = vgrad && lr ? 0 : s,
        o = y <= 0 ? 0 : (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.multiLineOffset)(title);
  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));
}

function translate(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}

function legendEntryLayout(entries) {
  // get max widths for each column
  const widths = entries.reduce((w, g) => {
    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);
    return w;
  }, {}); // set dimensions of legend entry groups

  entries.forEach(g => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}

function titleLayout(view, mark, width, height, viewBounds) {
  var group = mark.items[0],
      frame = group.frame,
      orient = group.orient,
      anchor = group.anchor,
      offset = group.offset,
      padding = group.padding,
      title = group.items[0].items[0],
      subtitle = group.items[1] && group.items[1].items[0],
      end = orient === Left || orient === Right ? height : width,
      start = 0,
      x = 0,
      y = 0,
      sx = 0,
      sy = 0,
      pos;

  if (frame !== Group) {
    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);
  } else if (orient === Left) {
    start = height, end = 0;
  }

  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;

  if (subtitle && subtitle.text) {
    // position subtitle
    switch (orient) {
      case Top:
      case Bottom:
        sy = title.bounds.height() + padding;
        break;

      case Left:
        sx = title.bounds.width() + padding;
        break;

      case Right:
        sx = -title.bounds.width() - padding;
        break;
    }

    tempBounds.clear().union(subtitle.bounds);
    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));

    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds);
      subtitle.mark.bounds.clear().union(tempBounds);
      view.dirty(subtitle);
    }

    tempBounds.clear().union(subtitle.bounds);
  } else {
    tempBounds.clear();
  }

  tempBounds.union(title.bounds); // position title group

  switch (orient) {
    case Top:
      x = pos;
      y = viewBounds.y1 - tempBounds.height() - offset;
      break;

    case Left:
      x = viewBounds.x1 - tempBounds.width() - offset;
      y = pos;
      break;

    case Right:
      x = viewBounds.x2 + tempBounds.width() + offset;
      y = pos;
      break;

    case Bottom:
      x = pos;
      y = viewBounds.y2 + offset;
      break;

    default:
      x = group.x;
      y = group.y;
  }

  if (set(group, 'x', x) | set(group, 'y', y)) {
    tempBounds.translate(x, y);
    view.dirty(group);
    group.bounds.clear().union(tempBounds);
    mark.bounds.clear().union(tempBounds);
    view.dirty(group);
  }

  return group.bounds;
}

/**
 * Layout view elements such as axes and legends.
 * Also performs size adjustments.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.mark - Scenegraph mark of groups to layout.
 */

function ViewLayout(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(ViewLayout, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow;

    _.mark.items.forEach(group => {
      if (_.layout) trellisLayout(view, group, _.layout);
      layoutGroup(view, group, _);
    });

    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;
  }

});

function shouldReflow(group) {
  // We typically should reflow if layout is invoked (#2568), as child items
  // may have resized and reflow ensures group bounds are re-calculated.
  // However, legend entries have a special exception to avoid instability.
  // For example, if a selected legend symbol gains a stroke on hover,
  // we don't want to re-position subsequent elements in the legend.
  return group && group.mark.role !== 'legend-entry';
}

function layoutGroup(view, group, _) {
  var items = group.items,
      width = Math.max(0, group.width || 0),
      height = Math.max(0, group.height || 0),
      viewBounds = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds().set(0, 0, width, height),
      xBounds = viewBounds.clone(),
      yBounds = viewBounds.clone(),
      legends = [],
      title,
      mark,
      orient,
      b,
      i,
      n; // layout axes, gather legends, collect bounds

  for (i = 0, n = items.length; i < n; ++i) {
    mark = items[i];

    switch (mark.role) {
      case AxisRole:
        b = isYAxis(mark) ? xBounds : yBounds;
        b.union(axisLayout(view, mark, width, height));
        break;

      case TitleRole:
        title = mark;
        break;

      case LegendRole:
        legends.push(legendLayout(view, mark));
        break;

      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark.bounds);
        yBounds.union(mark.bounds);
        break;

      default:
        viewBounds.union(mark.bounds);
    }
  } // layout legends, adjust viewBounds


  if (legends.length) {
    // group legends by orient
    const l = {};
    legends.forEach(item => {
      orient = item.orient || Right;
      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);
    }); // perform grid layout for each orient group

    for (const orient in l) {
      const g = l[orient];
      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));
    } // update view bounds


    legends.forEach(item => {
      const b = item.bounds;

      if (!b.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item); // dirty previous location

        item.bounds = b;
        view.dirty(item);
      }

      if (_.autosize && _.autosize.type === Fit) {
        // For autosize fit, incorporate the orthogonal dimension only.
        // Legends that overrun the chart area will then be clipped;
        // otherwise the chart area gets reduced to nothing!
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds.add(b.x1, 0).add(b.x2, 0);
            break;

          case Top:
          case Bottom:
            viewBounds.add(0, b.y1).add(0, b.y2);
        }
      } else {
        viewBounds.union(b);
      }
    });
  } // combine bounding boxes


  viewBounds.union(xBounds).union(yBounds); // layout title, adjust bounds

  if (title) {
    viewBounds.union(titleLayout(view, title, width, height, viewBounds));
  } // override aggregated view bounds if content is clipped


  if (group.clip) {
    viewBounds.set(0, 0, group.width || 0, group.height || 0);
  } // perform size adjustment


  viewSizeLayout(view, group, viewBounds, _);
}

function viewSizeLayout(view, group, viewBounds, _) {
  const auto = _.autosize || {},
        type = auto.type;
  if (view._autosize < 1 || !type) return;
  let viewWidth = view._width,
      viewHeight = view._height,
      width = Math.max(0, group.width || 0),
      left = Math.max(0, Math.ceil(-viewBounds.x1)),
      height = Math.max(0, group.height || 0),
      top = Math.max(0, Math.ceil(-viewBounds.y1));
  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),
        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));

  if (auto.contains === Padding) {
    const padding = view.padding();
    viewWidth -= padding.left + padding.right;
    viewHeight -= padding.top + padding.bottom;
  }

  if (type === None) {
    left = 0;
    top = 0;
    width = viewWidth;
    height = viewHeight;
  } else if (type === Fit) {
    width = Math.max(0, viewWidth - left - right);
    height = Math.max(0, viewHeight - top - bottom);
  } else if (type === FitX) {
    width = Math.max(0, viewWidth - left - right);
    viewHeight = height + top + bottom;
  } else if (type === FitY) {
    viewWidth = width + left + right;
    height = Math.max(0, viewHeight - top - bottom);
  } else if (type === Pad) {
    viewWidth = width + left + right;
    viewHeight = height + top + bottom;
  }

  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);
}




/***/ }),

/***/ "../../node_modules/vega-view/build/vega-view.module.js":
/*!**************************************************************!*\
  !*** ../../node_modules/vega-view/build/vega-view.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "View": () => (/* binding */ View)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-functions */ "../../node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-runtime */ "../../node_modules/vega-runtime/build/vega-runtime.module.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-timer */ "../../node_modules/d3-timer/src/interval.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-format */ "../../node_modules/vega-format/build/vega-format.module.js");









// initialize aria role and label attributes
function initializeAria(view) {
  const el = view.container();

  if (el) {
    el.setAttribute('role', 'graphics-document');
    el.setAttribute('aria-roleDescription', 'visualization');
    ariaLabel(el, view.description());
  }
} // update aria-label if we have a DOM container element

function ariaLabel(el, desc) {
  if (el) desc == null ? el.removeAttribute('aria-label') : el.setAttribute('aria-label', desc);
}

function background (view) {
  // respond to background signal
  view.add(null, _ => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}

const Default = 'default';
function cursor (view) {
  // get cursor signal, add to dataflow if needed
  const cursor = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  })); // evaluate cursor on each mousemove event

  view.on(view.events('view', 'mousemove'), cursor, (_, event) => {
    const value = cursor.value,
          user = value ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(value) ? value : value.user : Default,
          item = event.item && event.item.cursor || null;
    return value && user === value.user && item == value.item ? value : {
      user: user,
      item: item
    };
  }); // when cursor signal updates, set visible cursor

  view.add(null, function (_) {
    let user = _.cursor,
        item = this.value;

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(user)) {
      item = user.item;
      user = user.user;
    }

    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor
  });
}
function setCursor(view, cursor) {
  const el = view.globalCursor() ? typeof document !== 'undefined' && document.body : view.container();

  if (el) {
    return cursor == null ? el.style.removeProperty('cursor') : el.style.cursor = cursor;
  }
}

function dataref(view, name) {
  var data = view._runtime.data;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(data, name)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized data set: ' + name);
  }

  return data[name];
}
function data(name, values) {
  return arguments.length < 2 ? dataref(this, name).values.value : change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(values));
}
function change(name, changes) {
  if (!(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.isChangeSet)(changes)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Second argument to changes must be a changeset.');
  }

  const dataset = dataref(this, name);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name, _) {
  return change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().insert(_));
}
function remove(name, _) {
  return change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().remove(_));
}

function width(view) {
  var padding = view.padding();
  return Math.max(0, view._viewWidth + padding.left + padding.right);
}
function height(view) {
  var padding = view.padding();
  return Math.max(0, view._viewHeight + padding.top + padding.bottom);
}
function offset(view) {
  var padding = view.padding(),
      origin = view._origin;
  return [padding.left + origin[0], padding.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset(view),
      w = width(view),
      h = height(view);

  view._renderer.background(view.background());

  view._renderer.resize(w, h, origin);

  view._handler.origin(origin);

  view._resizeListeners.forEach(handler => {
    try {
      handler(w, h);
    } catch (error) {
      view.error(error);
    }
  });
}

/**
 * Extend an event with additional view-specific methods.
 * Adds a new property ('vega') to an event that provides a number
 * of methods for querying information about the current interaction.
 * The vega object provides the following methods:
 *   view - Returns the backing View instance.
 *   item - Returns the currently active scenegraph item (if any).
 *   group - Returns the currently active scenegraph group (if any).
 *     This method accepts a single string-typed argument indicating the name
 *     of the desired parent group. The scenegraph will be traversed from
 *     the item up towards the root to search for a matching group. If no
 *     argument is provided the enclosing group for the active item is
 *     returned, unless the item it itself a group, in which case it is
 *     returned directly.
 *   xy - Returns a two-element array containing the x and y coordinates for
 *     mouse or touch events. For touch events, this is based on the first
 *     elements in the changedTouches array. This method accepts a single
 *     argument: either an item instance or mark name that should serve as
 *     the reference coordinate system. If no argument is provided the
 *     top-level view coordinate system is assumed.
 *   x - Returns the current x-coordinate, accepts the same arguments as xy.
 *   y - Returns the current y-coordinate, accepts the same arguments as xy.
 * @param {Event} event - The input event to extend.
 * @param {Item} item - The currently active scenegraph item (if any).
 * @return {Event} - The extended input event.
 */

function eventExtend (view, event, item) {
  var r = view._renderer,
      el = r && r.canvas(),
      p,
      e,
      translate;

  if (el) {
    translate = offset(view);
    e = event.changedTouches ? event.changedTouches[0] : event;
    p = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.point)(e, el);
    p[0] -= translate[0];
    p[1] -= translate[1];
  }

  event.dataflow = view;
  event.item = item;
  event.vega = extension(view, item, p);
  return event;
}

function extension(view, item, point) {
  const itemGroup = item ? item.mark.marktype === 'group' ? item : item.mark.group : null;

  function group(name) {
    var g = itemGroup,
        i;
    if (name) for (i = item; i; i = i.mark.group) {
      if (i.mark.name === name) {
        g = i;
        break;
      }
    }
    return g && g.mark && g.mark.interactive ? g : {};
  }

  function xy(item) {
    if (!item) return point;
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(item)) item = group(item);
    const p = point.slice();

    while (item) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
      item = item.mark && item.mark.group;
    }

    return p;
  }

  return {
    view: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(view),
    item: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(item || {}),
    group: group,
    xy: xy,
    x: item => xy(item)[0],
    y: item => xy(item)[1]
  };
}

const VIEW = 'view',
      TIMER = 'timer',
      WINDOW = 'window',
      NO_TRAP = {
  trap: false
};
/**
 * Initialize event handling configuration.
 * @param {object} config - The configuration settings.
 * @return {object}
 */

function initializeEventConfig(config) {
  const events = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    defaults: {}
  }, config);

  const unpack = (obj, keys) => {
    keys.forEach(k => {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(obj[k])) obj[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(obj[k]);
    });
  };

  unpack(events.defaults, ['prevent', 'allow']);
  unpack(events, ['view', 'window', 'selector']);
  return events;
}
function trackEventListener(view, sources, type, handler) {
  view._eventListeners.push({
    type: type,
    sources: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(sources),
    handler: handler
  });
}

function prevent(view, type) {
  var def = view._eventConfig.defaults,
      prevent = def.prevent,
      allow = def.allow;
  return prevent === false || allow === true ? false : prevent === true || allow === false ? true : prevent ? prevent[type] : allow ? !allow[type] : view.preventDefault();
}

function permit(view, key, type) {
  const rule = view._eventConfig && view._eventConfig[key];

  if (rule === false || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(rule) && !rule[type]) {
    view.warn(`Blocked ${key} ${type} event listener.`);
    return false;
  }

  return true;
}
/**
 * Create a new event stream from an event source.
 * @param {object} source - The event source to monitor.
 * @param {string} type - The event type.
 * @param {function(object): boolean} [filter] - Event filter function.
 * @return {EventStream}
 */


function events(source, type, filter) {
  var view = this,
      s = new vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.EventStream(filter),
      send = function (e, item) {
    view.runAsync(null, () => {
      if (source === VIEW && prevent(view, type)) {
        e.preventDefault();
      }

      s.receive(eventExtend(view, e, item));
    });
  },
      sources;

  if (source === TIMER) {
    if (permit(view, 'timer', type)) {
      view.timer(send, type);
    }
  } else if (source === VIEW) {
    if (permit(view, 'view', type)) {
      // send traps errors, so use {trap: false} option
      view.addEventListener(type, send, NO_TRAP);
    }
  } else {
    if (source === WINDOW) {
      if (permit(view, 'window', type) && typeof window !== 'undefined') {
        sources = [window];
      }
    } else if (typeof document !== 'undefined') {
      if (permit(view, 'selector', type)) {
        sources = document.querySelectorAll(source);
      }
    }

    if (!sources) {
      view.warn('Can not resolve event source: ' + source);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type, send);
      }

      trackEventListener(view, sources, type, send);
    }
  }

  return s;
}

function itemFilter(event) {
  return event.item;
}

function markTarget(event) {
  // grab upstream collector feeding the mark operator
  return event.item.mark.source;
}

function invoke(name) {
  return function (_, event) {
    return event.vega.view().changeset().encode(event.item, name);
  };
}

function hover (hoverSet, leaveSet) {
  hoverSet = [hoverSet || 'hover'];
  leaveSet = [leaveSet || 'update', hoverSet[0]]; // invoke hover set upon mouseover

  this.on(this.events('view', 'mouseover', itemFilter), markTarget, invoke(hoverSet)); // invoke leave set upon mouseout

  this.on(this.events('view', 'mouseout', itemFilter), markTarget, invoke(leaveSet));
  return this;
}

/**
 * Finalize a View instance that is being removed.
 * Cancel any running timers.
 * Remove all external event listeners.
 * Remove any currently displayed tooltip.
 */
function finalize () {
  var tooltip = this._tooltip,
      timers = this._timers,
      listeners = this._eventListeners,
      n,
      m,
      e;
  n = timers.length;

  while (--n >= 0) {
    timers[n].stop();
  }

  n = listeners.length;

  while (--n >= 0) {
    e = listeners[n];
    m = e.sources.length;

    while (--m >= 0) {
      e.sources[m].removeEventListener(e.type, e.handler);
    }
  }

  if (tooltip) {
    tooltip.call(this, this._handler, null, null, null);
  }

  return this;
}

function element (tag, attr, text) {
  const el = document.createElement(tag);

  for (const key in attr) el.setAttribute(key, attr[key]);

  if (text != null) el.textContent = text;
  return el;
}

const BindClass = 'vega-bind',
      NameClass = 'vega-bind-name',
      RadioClass = 'vega-bind-radio';
/**
 * Bind a signal to an external HTML input element. The resulting two-way
 * binding will propagate input changes to signals, and propagate signal
 * changes to the input element state. If this view instance has no parent
 * element, we assume the view is headless and no bindings are created.
 * @param {Element|string} el - The parent DOM element to which the input
 *   element should be appended as a child. If string-valued, this argument
 *   will be treated as a CSS selector. If null or undefined, the parent
 *   element of this view will be used as the element.
 * @param {object} param - The binding parameters which specify the signal
 *   to bind to, the input element type, and type-specific configuration.
 * @return {View} - This view instance.
 */

function bind (view, el, binding) {
  if (!el) return;
  const param = binding.param;
  let bind = binding.state;

  if (!bind) {
    bind = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: value => {
        if (value != view.signal(param.signal)) {
          view.runAsync(null, () => {
            bind.source = true;
            view.signal(param.signal, value);
          });
        }
      }
    };

    if (param.debounce) {
      bind.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(param.debounce, bind.update);
    }
  }

  const create = param.input == null && param.element ? target : generate;
  create(bind, el, param, view);

  if (!bind.active) {
    view.on(view._signals[param.signal], null, () => {
      bind.source ? bind.source = false : bind.set(view.signal(param.signal));
    });
    bind.active = true;
  }

  return bind;
}
/**
 * Bind the signal to an external EventTarget.
 */

function target(bind, node, param, view) {
  const type = param.event || 'input';

  const handler = () => bind.update(node.value); // initialize signal value to external input value


  view.signal(param.signal, node.value); // listen for changes on the element

  node.addEventListener(type, handler); // register with view, so we can remove it upon finalization

  trackEventListener(view, node, type, handler); // propagate change to element

  bind.set = value => {
    node.value = value;
    node.dispatchEvent(event(type));
  };
}

function event(type) {
  return typeof Event !== 'undefined' ? new Event(type) : {
    type
  };
}
/**
 * Generate an HTML input form element and bind it to a signal.
 */


function generate(bind, el, param, view) {
  const value = view.signal(param.signal);
  const div = element('div', {
    'class': BindClass
  });
  const wrapper = param.input === 'radio' ? div : div.appendChild(element('label'));
  wrapper.appendChild(element('span', {
    'class': NameClass
  }, param.name || param.signal));
  el.appendChild(div);
  let input = form;

  switch (param.input) {
    case 'checkbox':
      input = checkbox;
      break;

    case 'select':
      input = select;
      break;

    case 'radio':
      input = radio;
      break;

    case 'range':
      input = range;
      break;
  }

  input(bind, wrapper, param, value);
}
/**
 * Generates an arbitrary input form element.
 * The input type is controlled via user-provided parameters.
 */


function form(bind, el, param, value) {
  const node = element('input');

  for (const key in param) {
    if (key !== 'signal' && key !== 'element') {
      node.setAttribute(key === 'input' ? 'type' : key, param[key]);
    }
  }

  node.setAttribute('name', param.signal);
  node.value = value;
  el.appendChild(node);
  node.addEventListener('input', () => bind.update(node.value));
  bind.elements = [node];

  bind.set = value => node.value = value;
}
/**
 * Generates a checkbox input element.
 */


function checkbox(bind, el, param, value) {
  const attr = {
    type: 'checkbox',
    name: param.signal
  };
  if (value) attr.checked = true;
  const node = element('input', attr);
  el.appendChild(node);
  node.addEventListener('change', () => bind.update(node.checked));
  bind.elements = [node];

  bind.set = value => node.checked = !!value || null;
}
/**
 * Generates a selection list input element.
 */


function select(bind, el, param, value) {
  const node = element('select', {
    name: param.signal
  }),
        labels = param.labels || [];
  param.options.forEach((option, i) => {
    const attr = {
      value: option
    };
    if (valuesEqual(option, value)) attr.selected = true;
    node.appendChild(element('option', attr, (labels[i] || option) + ''));
  });
  el.appendChild(node);
  node.addEventListener('change', () => {
    bind.update(param.options[node.selectedIndex]);
  });
  bind.elements = [node];

  bind.set = value => {
    for (let i = 0, n = param.options.length; i < n; ++i) {
      if (valuesEqual(param.options[i], value)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}
/**
 * Generates a radio button group.
 */


function radio(bind, el, param, value) {
  const group = element('span', {
    'class': RadioClass
  }),
        labels = param.labels || [];
  el.appendChild(group);
  bind.elements = param.options.map((option, i) => {
    const attr = {
      type: 'radio',
      name: param.signal,
      value: option
    };
    if (valuesEqual(option, value)) attr.checked = true;
    const input = element('input', attr);
    input.addEventListener('change', () => bind.update(option));
    const label = element('label', {}, (labels[i] || option) + '');
    label.prepend(input);
    group.appendChild(label);
    return input;
  });

  bind.set = value => {
    const nodes = bind.elements,
          n = nodes.length;

    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value)) nodes[i].checked = true;
    }
  };
}
/**
 * Generates a slider input element.
 */


function range(bind, el, param, value) {
  value = value !== undefined ? value : (+param.max + +param.min) / 2;
  const max = param.max != null ? param.max : Math.max(100, +value) || 100,
        min = param.min || Math.min(0, max, +value) || 0,
        step = param.step || (0,d3_array__WEBPACK_IMPORTED_MODULE_6__.tickStep)(min, max, 100);
  const node = element('input', {
    type: 'range',
    name: param.signal,
    min: min,
    max: max,
    step: step
  });
  node.value = value;
  const span = element('span', {}, +value);
  el.appendChild(node);
  el.appendChild(span);

  const update = () => {
    span.textContent = node.value;
    bind.update(+node.value);
  }; // subscribe to both input and change


  node.addEventListener('input', update);
  node.addEventListener('change', update);
  bind.elements = [node];

  bind.set = value => {
    node.value = value;
    span.textContent = value;
  };
}

function valuesEqual(a, b) {
  return a === b || a + '' === b + '';
}

function initializeRenderer (view, r, el, constructor, scaleFactor, opt) {
  r = r || new constructor(view.loader());
  return r.initialize(el, width(view), height(view), offset(view), scaleFactor, opt).background(view.background());
}

function trap (view, fn) {
  return !fn ? null : function () {
    try {
      fn.apply(this, arguments);
    } catch (error) {
      view.error(error);
    }
  };
}

function initializeHandler (view, prevHandler, el, constructor) {
  // instantiate scenegraph handler
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset(view), view); // transfer event handlers

  if (prevHandler) {
    prevHandler.handlers().forEach(h => {
      handler.on(h.type, h.handler);
    });
  }

  return handler;
}

function initialize (el, elBind) {
  const view = this,
        type = view._renderType,
        config = view._eventConfig.bind,
        module = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type); // containing dom element

  el = view._el = el ? lookup(view, el, true) : null; // initialize aria attributes

  initializeAria(view); // select appropriate renderer & handler

  if (!module) view.error('Unrecognized renderer type: ' + type);
  const Handler = module.handler || vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.CanvasHandler,
        Renderer = el ? module.renderer : module.headless; // initialize renderer and input handler

  view._renderer = !Renderer ? null : initializeRenderer(view, view._renderer, el, Renderer);
  view._handler = initializeHandler(view, view._handler, el, Handler);
  view._redraw = true; // initialize signal bindings

  if (el && config !== 'none') {
    elBind = elBind ? view._elBind = lookup(view, elBind, true) : el.appendChild(element('form', {
      'class': 'vega-bindings'
    }));

    view._bind.forEach(_ => {
      if (_.param.element && config !== 'container') {
        _.element = lookup(view, _.param.element, !!_.param.input);
      }
    });

    view._bind.forEach(_ => {
      bind(view, _.element || elBind, _);
    });
  }

  return view;
}

function lookup(view, el, clear) {
  if (typeof el === 'string') {
    if (typeof document !== 'undefined') {
      el = document.querySelector(el);

      if (!el) {
        view.error('Signal bind element not found: ' + el);
        return null;
      }
    } else {
      view.error('DOM document instance not found.');
      return null;
    }
  }

  if (el && clear) {
    try {
      el.innerHTML = '';
    } catch (e) {
      el = null;
      view.error(e);
    }
  }

  return el;
}

const number = _ => +_ || 0;

const paddingObject = _ => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});

function padding (_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) ? {
    top: number(_.top),
    bottom: number(_.bottom),
    left: number(_.left),
    right: number(_.right)
  } : paddingObject(number(_));
}

/**
 * Render the current scene in a headless fashion.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A Promise that resolves to a renderer.
 */

async function renderHeadless (view, type, scaleFactor, opt) {
  const module = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type),
        ctr = module && module.headless;
  if (!ctr) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized renderer type: ' + type);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}

/**
 * Produce an image URL for the visualization. Depending on the type
 * parameter, the generated URL contains data for either a PNG or SVG image.
 * The URL can be used (for example) to download images of the visualization.
 * This method is asynchronous, returning a Promise instance.
 * @param {string} type - The image type. One of 'svg', 'png' or 'canvas'.
 *   The 'canvas' and 'png' types are synonyms for a PNG image.
 * @return {Promise} - A promise that resolves to an image URL.
 */

async function renderToImageURL (type, scaleFactor) {
  if (type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas && type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG && type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.PNG) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized image type: ' + type);
  }

  const r = await renderHeadless(this, type, scaleFactor);
  return type === vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG ? toBlobURL(r.svg(), 'image/svg+xml') : r.canvas().toDataURL('image/png');
}

function toBlobURL(data, mime) {
  const blob = new Blob([data], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}

/**
 * Produce a Canvas instance containing a rendered visualization.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A promise that resolves to a Canvas instance.
 */

async function renderToCanvas (scaleFactor, opt) {
  const r = await renderHeadless(this, vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas, scaleFactor, opt);
  return r.canvas();
}

/**
 * Produce a rendered SVG string of the visualization.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A promise that resolves to an SVG string.
 */

async function renderToSVG (scaleFactor) {
  const r = await renderHeadless(this, vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG, scaleFactor);
  return r.svg();
}

function runtime (view, spec, expr) {
  return (0,vega_runtime__WEBPACK_IMPORTED_MODULE_4__.context)(view, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms, vega_functions__WEBPACK_IMPORTED_MODULE_3__.functionContext, expr).parse(spec);
}

function scale(name) {
  var scales = this._runtime.scales;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(scales, name)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale or projection: ' + name);
  }

  return scales[name].value;
}

var Width = 'width',
    Height = 'height',
    Padding = 'padding',
    Skip = {
  skip: true
};
function viewWidth(view, width) {
  var a = view.autosize(),
      p = view.padding();
  return width - (a && a.contains === Padding ? p.left + p.right : 0);
}
function viewHeight(view, height) {
  var a = view.autosize(),
      p = view.padding();
  return height - (a && a.contains === Padding ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s = view._signals,
      w = s[Width],
      h = s[Height],
      p = s[Padding];

  function resetSize() {
    view._autosize = view._resize = 1;
  } // respond to width signal


  view._resizeWidth = view.add(null, _ => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w
  }); // respond to height signal

  view._resizeHeight = view.add(null, _ => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h
  }); // respond to padding signal

  const resizePadding = view.add(null, resetSize, {
    pad: p
  }); // set rank to run immediately after source signal

  view._resizeWidth.rank = w.rank + 1;
  view._resizeHeight.rank = h.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth, viewHeight, width, height, origin, auto) {
  this.runAfter(view => {
    let rerun = 0; // reset autosize flag

    view._autosize = 0; // width value changed: update signal, skip resize op

    if (view.width() !== width) {
      rerun = 1;
      view.signal(Width, width, Skip); // set width, skip update calc

      view._resizeWidth.skip(true); // skip width resize handler

    } // height value changed: update signal, skip resize op


    if (view.height() !== height) {
      rerun = 1;
      view.signal(Height, height, Skip); // set height, skip update calc

      view._resizeHeight.skip(true); // skip height resize handler

    } // view width changed: update view property, set resize flag


    if (view._viewWidth !== viewWidth) {
      view._resize = 1;
      view._viewWidth = viewWidth;
    } // view height changed: update view property, set resize flag


    if (view._viewHeight !== viewHeight) {
      view._resize = 1;
      view._viewHeight = viewHeight;
    } // origin changed: update view property, set resize flag


    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    } // run dataflow on width/height signal change


    if (rerun) view.run('enter');
    if (auto) view.runAfter(v => v.resize());
  }, false, 1);
}

/**
 * Get the current view state, consisting of signal values and/or data sets.
 * @param {object} [options] - Options flags indicating which state to export.
 *   If unspecified, all signals and data sets will be exported.
 * @param {function(string, Operator):boolean} [options.signals] - Optional
 *   predicate function for testing if a signal should be included in the
 *   exported state. If unspecified, all signals will be included, except for
 *   those named 'parent' or those which refer to a Transform value.
 * @param {function(string, object):boolean} [options.data] - Optional
 *   predicate function for testing if a data set's input should be included
 *   in the exported state. If unspecified, all data sets that have been
 *   explicitly modified will be included.
 * @param {boolean} [options.recurse=true] - Flag indicating if the exported
 *   state should recursively include state from group mark sub-contexts.
 * @return {object} - An object containing the exported state values.
 */

function getState(options) {
  return this._runtime.getState(options || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}

function dataTest(name, data) {
  return data.modified && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data.input.value) && name.indexOf('_:vega:_');
}

function signalTest(name, op) {
  return !(name === 'parent' || op instanceof vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms.proxy);
}
/**
 * Sets the current view state and updates the view by invoking run.
 * @param {object} state - A state object containing signal and/or
 *   data set values, following the format used by the getState method.
 * @return {View} - This view instance.
 */


function setState(state) {
  this.runAsync(null, v => {
    v._trigger = false;

    v._runtime.setState(state);
  }, v => {
    v._trigger = true;
  });
  return this;
}

function timer (callback, delay) {
  function tick(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed: elapsed
    });
  }

  this._timers.push((0,d3_timer__WEBPACK_IMPORTED_MODULE_7__.default)(tick, delay));
}

function defaultTooltip (handler, event, item, value) {
  const el = handler.element();
  if (el) el.setAttribute('title', formatTooltip(value));
}

function formatTooltip(value) {
  return value == null ? '' : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? formatArray(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(value) ? formatObject(value) : value + '';
}

function formatObject(obj) {
  return Object.keys(obj).map(key => {
    const v = obj[key];
    return key + ': ' + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? formatArray(v) : formatValue(v));
  }).join('\n');
}

function formatArray(value) {
  return '[' + value.map(formatValue).join(', ') + ']';
}

function formatValue(value) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? '[\u2026]' : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(value) ? '{\u2026}' : value;
}

/**
 * Create a new View instance from a Vega dataflow runtime specification.
 * The generated View will not immediately be ready for display. Callers
 * should also invoke the initialize method (e.g., to set the parent
 * DOM element in browser-based deployment) and then invoke the run
 * method to evaluate the dataflow graph. Rendering will automatically
 * be performed upon dataflow runs.
 * @constructor
 * @param {object} spec - The Vega dataflow runtime specification.
 */

function View(spec, options) {
  const view = this;
  options = options || {};
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.call(view);
  if (options.loader) view.loader(options.loader);
  if (options.logger) view.logger(options.logger);
  if (options.logLevel != null) view.logLevel(options.logLevel);

  if (options.locale || spec.locale) {
    const loc = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, spec.locale, options.locale);
    view.locale((0,vega_format__WEBPACK_IMPORTED_MODULE_5__.locale)(loc.number, loc.time));
  }

  view._el = null;
  view._elBind = null;
  view._renderType = options.renderer || vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas;
  view._scenegraph = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.Scenegraph();
  const root = view._scenegraph.root; // initialize renderer, handler and event management

  view._renderer = null;
  view._tooltip = options.tooltip || defaultTooltip, view._redraw = true;
  view._handler = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.CanvasHandler().scene(root);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = []; // initialize event configuration

  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor); // initialize dataflow graph

  const ctx = runtime(view, spec, options.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map(_ => ({
    state: null,
    param: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _)
  })); // initialize scenegraph

  if (ctx.root) ctx.root.set(root);
  root.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root.items)); // initialize view size

  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view); // initialize background color

  background(view); // initialize cursor

  cursor(view); // initialize view description

  view.description(spec.description); // initialize hover proessing, if requested

  if (options.hover) view.hover(); // initialize DOM container(s) and renderer

  if (options.container) view.initialize(options.container, options.bind);
}

function lookupSignal(view, name) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(view._signals, name) ? view._signals[name] : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
}

function findOperatorHandler(op, handler) {
  const h = (op._targets || []).filter(op => op._update && op._update.handler === handler);
  return h.length ? h[0] : null;
}

function addOperatorListener(view, name, op, handler) {
  let h = findOperatorHandler(op, handler);

  if (!h) {
    h = trap(view, () => handler(name, op.value));
    h.handler = handler;
    view.on(op, null, h);
  }

  return view;
}

function removeOperatorListener(view, op, handler) {
  const h = findOperatorHandler(op, handler);
  if (h) op._targets.remove(h);
  return view;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(View, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(encode, prerun, postrun) {
    // evaluate dataflow and prerun
    await vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.prototype.evaluate.call(this, encode, prerun); // render as needed

    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }

          await this._renderer.renderAsync(this._scenegraph.root);
        }

        this._redraw = false;
      } catch (e) {
        this.error(e);
      }
    } // evaluate postrun


    if (postrun) (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.asyncCallback)(this, postrun);
    return this;
  },

  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },

  // -- GET / SET ----
  description(text) {
    if (arguments.length) {
      const desc = text != null ? text + '' : null;
      if (desc !== this._desc) ariaLabel(this._el, this._desc = desc);
      return this;
    }

    return this._desc;
  },

  container() {
    return this._el;
  },

  scenegraph() {
    return this._scenegraph;
  },

  origin() {
    return this._origin.slice();
  },

  signal(name, value, options) {
    const op = lookupSignal(this, name);
    return arguments.length === 1 ? op.value : this.update(op, value, options);
  },

  width(_) {
    return arguments.length ? this.signal('width', _) : this.signal('width');
  },

  height(_) {
    return arguments.length ? this.signal('height', _) : this.signal('height');
  },

  padding(_) {
    return arguments.length ? this.signal('padding', padding(_)) : padding(this.signal('padding'));
  },

  autosize(_) {
    return arguments.length ? this.signal('autosize', _) : this.signal('autosize');
  },

  background(_) {
    return arguments.length ? this.signal('background', _) : this.signal('background');
  },

  renderer(type) {
    if (!arguments.length) return this._renderType;
    if (!(0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized renderer type: ' + type);

    if (type !== this._renderType) {
      this._renderType = type;

      this._resetRenderer();
    }

    return this;
  },

  tooltip(handler) {
    if (!arguments.length) return this._tooltip;

    if (handler !== this._tooltip) {
      this._tooltip = handler;

      this._resetRenderer();
    }

    return this;
  },

  loader(loader) {
    if (!arguments.length) return this._loader;

    if (loader !== this._loader) {
      vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.prototype.loader.call(this, loader);

      this._resetRenderer();
    }

    return this;
  },

  resize() {
    // set flag to perform autosize
    this._autosize = 1; // touch autosize signal to ensure top-level ViewLayout runs

    return this.touch(lookupSignal(this, 'autosize'));
  },

  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },

  // -- SIZING ----
  _resizeView: resizeView,

  // -- EVENT HANDLING ----
  addEventListener(type, handler, options) {
    let callback = handler;

    if (!(options && options.trap === false)) {
      // wrap callback in error handler
      callback = trap(this, handler);
      callback.raw = handler;
    }

    this._handler.on(type, callback);

    return this;
  },

  removeEventListener(type, handler) {
    var handlers = this._handler.handlers(type),
        i = handlers.length,
        h,
        t; // search registered handlers, remove if match found


    while (--i >= 0) {
      t = handlers[i].type;
      h = handlers[i].handler;

      if (type === t && (handler === h || handler === h.raw)) {
        this._handler.off(t, h);

        break;
      }
    }

    return this;
  },

  addResizeListener(handler) {
    const l = this._resizeListeners;

    if (l.indexOf(handler) < 0) {
      // add handler if it isn't already registered
      // note: error trapping handled elsewhere, so
      // no need to wrap handlers here
      l.push(handler);
    }

    return this;
  },

  removeResizeListener(handler) {
    var l = this._resizeListeners,
        i = l.indexOf(handler);

    if (i >= 0) {
      l.splice(i, 1);
    }

    return this;
  },

  addSignalListener(name, handler) {
    return addOperatorListener(this, name, lookupSignal(this, name), handler);
  },

  removeSignalListener(name, handler) {
    return removeOperatorListener(this, lookupSignal(this, name), handler);
  },

  addDataListener(name, handler) {
    return addOperatorListener(this, name, dataref(this, name).values, handler);
  },

  removeDataListener(name, handler) {
    return removeOperatorListener(this, dataref(this, name).values, handler);
  },

  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev = setCursor(this, null); // clear previous cursor

        this._globalCursor = !!_;
        if (prev) setCursor(this, prev); // swap cursor
      }

      return this;
    } else {
      return this._globalCursor;
    }
  },

  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },

  timer,
  events,
  finalize,
  hover,
  // -- DATA ----
  data,
  change,
  insert,
  remove,
  // -- SCALES --
  scale,
  // -- INITIALIZATION ----
  initialize,
  // -- HEADLESS RENDERING ----
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  // -- SAVE / RESTORE STATE ----
  getState,
  setState
});




/***/ }),

/***/ "../../node_modules/vega-voronoi/build/vega-voronoi.module.js":
/*!********************************************************************!*\
  !*** ../../node_modules/vega-voronoi/build/vega-voronoi.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "voronoi": () => (/* binding */ Voronoi)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_delaunay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-delaunay */ "../../node_modules/d3-delaunay/src/delaunay.js");




function Voronoi(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Voronoi.Definition = {
  'type': 'Voronoi',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'extent',
    'type': 'array',
    'array': true,
    'length': 2,
    'default': [[-1e5, -1e5], [1e5, 1e5]],
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
const defaultExtent = [-1e5, -1e5, 1e5, 1e5];
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Voronoi, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const as = _.as || 'path',
          data = pulse.source; // nothing to do if no data

    if (!data || !data.length) return pulse; // configure and construct voronoi diagram

    let s = _.size;
    s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
    const voronoi = this.value = d3_delaunay__WEBPACK_IMPORTED_MODULE_2__.default.from(data, _.x, _.y).voronoi(s); // map polygons to paths

    for (let i = 0, n = data.length; i < n; ++i) {
      const polygon = voronoi.cellPolygon(i);
      data[i][as] = polygon ? toPathString(polygon) : null;
    }

    return pulse.reflow(_.modified()).modifies(as);
  }

}); // suppress duplicated end point vertices

function toPathString(p) {
  const x = p[0][0],
        y = p[0][1];
  let n = p.length - 1;

  for (; p[n][0] === x && p[n][1] === y; --n);

  return 'M' + p.slice(0, n + 1).join('L') + 'Z';
}




/***/ }),

/***/ "../../node_modules/vega-wordcloud/build/vega-wordcloud.module.js":
/*!************************************************************************!*\
  !*** ../../node_modules/vega-wordcloud/build/vega-wordcloud.module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wordcloud": () => (/* binding */ Wordcloud)
/* harmony export */ });
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-canvas */ "../../node_modules/vega-canvas/index.browser.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");






/*
Copyright (c) 2013, Jason Davies.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  * The name Jason Davies may not be used to endorse or promote products
    derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/
// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf

var cloudRadians = Math.PI / 180,
    cw = 1 << 11 >> 5,
    ch = 1 << 11;
function cloud () {
  var size = [256, 256],
      text,
      font,
      fontSize,
      fontStyle,
      fontWeight,
      rotate,
      padding,
      spiral = archimedeanSpiral,
      words = [],
      random = Math.random,
      cloud = {};

  cloud.layout = function () {
    var contextAndRatio = getContext((0,vega_canvas__WEBPACK_IMPORTED_MODULE_0__.canvas)()),
        board = zeroArray((size[0] >> 5) * size[1]),
        bounds = null,
        n = words.length,
        i = -1,
        tags = [],
        data = words.map(d => ({
      text: text(d),
      font: font(d),
      style: fontStyle(d),
      weight: fontWeight(d),
      rotate: rotate(d),
      size: ~~(fontSize(d) + 1e-14),
      padding: padding(d),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d
    })).sort((a, b) => b.size - a.size);

    while (++i < n) {
      var d = data[i];
      d.x = size[0] * (random() + .5) >> 1;
      d.y = size[1] * (random() + .5) >> 1;
      cloudSprite(contextAndRatio, d, data, i);

      if (d.hasText && place(board, d, bounds)) {
        tags.push(d);
        if (bounds) cloudBounds(bounds, d);else bounds = [{
          x: d.x + d.x0,
          y: d.y + d.y0
        }, {
          x: d.x + d.x1,
          y: d.y + d.y1
        }]; // Temporary hack

        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }

    return tags;
  };

  function getContext(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context = canvas.getContext('2d');
    context.fillStyle = context.strokeStyle = 'red';
    context.textAlign = 'center';
    return {
      context: context,
      ratio: ratio
    };
  }

  function place(board, tag, bounds) {
    var startX = tag.x,
        startY = tag.y,
        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
        s = spiral(size),
        dt = random() < .5 ? 1 : -1,
        t = -dt,
        dxdy,
        dx,
        dy;

    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue; // TODO only check for collisions within current bounds.

      if (!bounds || !cloudCollide(tag, board, size[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite,
              w = tag.width >> 5,
              sw = size[0] >> 5,
              lx = tag.x - (w << 4),
              sx = lx & 0x7f,
              msx = 32 - sx,
              h = tag.y1 - tag.y0,
              x = (tag.y + tag.y0) * sw + (lx >> 5),
              last;

          for (var j = 0; j < h; j++) {
            last = 0;

            for (var i = 0; i <= w; i++) {
              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
            }

            x += sw;
          }

          tag.sprite = null;
          return true;
        }
      }
    }

    return false;
  }

  cloud.words = function (_) {
    if (arguments.length) {
      words = _;
      return cloud;
    } else {
      return words;
    }
  };

  cloud.size = function (_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud;
    } else {
      return size;
    }
  };

  cloud.font = function (_) {
    if (arguments.length) {
      font = functor(_);
      return cloud;
    } else {
      return font;
    }
  };

  cloud.fontStyle = function (_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud;
    } else {
      return fontStyle;
    }
  };

  cloud.fontWeight = function (_) {
    if (arguments.length) {
      fontWeight = functor(_);
      return cloud;
    } else {
      return fontWeight;
    }
  };

  cloud.rotate = function (_) {
    if (arguments.length) {
      rotate = functor(_);
      return cloud;
    } else {
      return rotate;
    }
  };

  cloud.text = function (_) {
    if (arguments.length) {
      text = functor(_);
      return cloud;
    } else {
      return text;
    }
  };

  cloud.spiral = function (_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud;
    } else {
      return spiral;
    }
  };

  cloud.fontSize = function (_) {
    if (arguments.length) {
      fontSize = functor(_);
      return cloud;
    } else {
      return fontSize;
    }
  };

  cloud.padding = function (_) {
    if (arguments.length) {
      padding = functor(_);
      return cloud;
    } else {
      return padding;
    }
  };

  cloud.random = function (_) {
    if (arguments.length) {
      random = _;
      return cloud;
    } else {
      return random;
    }
  };

  return cloud;
} // Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.

function cloudSprite(contextAndRatio, d, data, di) {
  if (d.sprite) return;
  var c = contextAndRatio.context,
      ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0,
      y = 0,
      maxh = 0,
      n = data.length,
      w,
      w32,
      h,
      i,
      j;
  --di;

  while (++di < n) {
    d = data[di];
    c.save();
    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;
    w = c.measureText(d.text + 'm').width * ratio;
    h = d.size << 1;

    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians),
          cr = Math.cos(d.rotate * cloudRadians),
          wcr = w * cr,
          wsr = w * sr,
          hcr = h * cr,
          hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 0x1f >> 5 << 5;
    }

    if (h > maxh) maxh = h;

    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }

    if (y + h >= ch) break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate) c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);

    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }

    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }

  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
      sprite = [];

  while (--di >= 0) {
    d = data[di];
    if (!d.hasText) continue;
    w = d.width;
    w32 = w >> 5;
    h = d.y1 - d.y0; // Zero the buffer

    for (i = 0; i < h * w32; i++) sprite[i] = 0;

    x = d.xoff;
    if (x == null) return;
    y = d.yoff;
    var seen = 0,
        seenRow = -1;

    for (j = 0; j < h; j++) {
      for (i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5),
            m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }

      if (seen) seenRow = j;else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }

    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
} // Use mask-based collision detection.


function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite,
      w = tag.width >> 5,
      lx = tag.x - (w << 4),
      sx = lx & 0x7f,
      msx = 32 - sx,
      h = tag.y1 - tag.y0,
      x = (tag.y + tag.y0) * sw + (lx >> 5),
      last;

  for (var j = 0; j < h; j++) {
    last = 0;

    for (var i = 0; i <= w; i++) {
      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
    }

    x += sw;
  }

  return false;
}

function cloudBounds(bounds, d) {
  var b0 = bounds[0],
      b1 = bounds[1];
  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}

function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}

function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function (t) {
    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
  };
}

function rectangularSpiral(size) {
  var dy = 4,
      dx = dy * size[0] / size[1],
      x = 0,
      y = 0;
  return function (t) {
    var sign = t < 0 ? -1 : 1; // See triangular numbers: T_n = n * (n + 1) / 2.

    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;

      case 1:
        y += dy;
        break;

      case 2:
        x -= dx;
        break;

      default:
        y -= dy;
        break;
    }

    return [x, y];
  };
} // TODO reuse arrays?


function zeroArray(n) {
  var a = [],
      i = -1;

  while (++i < n) a[i] = 0;

  return a;
}

function functor(d) {
  return typeof d === 'function' ? d : function () {
    return d;
  };
}

var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};

const Output = ['x', 'y', 'font', 'fontSize', 'fontStyle', 'fontWeight', 'angle'];
const Params = ['text', 'font', 'rotate', 'fontSize', 'fontStyle', 'fontWeight'];
function Wordcloud(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, cloud(), params);
}
Wordcloud.Definition = {
  'type': 'Wordcloud',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'font',
    'type': 'string',
    'expr': true,
    'default': 'sans-serif'
  }, {
    'name': 'fontStyle',
    'type': 'string',
    'expr': true,
    'default': 'normal'
  }, {
    'name': 'fontWeight',
    'type': 'string',
    'expr': true,
    'default': 'normal'
  }, {
    'name': 'fontSize',
    'type': 'number',
    'expr': true,
    'default': 14
  }, {
    'name': 'fontSizeRange',
    'type': 'number',
    'array': 'nullable',
    'default': [10, 50]
  }, {
    'name': 'rotate',
    'type': 'number',
    'expr': true,
    'default': 0
  }, {
    'name': 'text',
    'type': 'field'
  }, {
    'name': 'spiral',
    'type': 'string',
    'values': ['archimedean', 'rectangular']
  }, {
    'name': 'padding',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 7,
    'default': Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Wordcloud, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (_.size && !(_.size[0] && _.size[1])) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Wordcloud size dimensions must be non-zero.');
    }

    function modp(param) {
      const p = _[param];
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(p) && pulse.modified(p.fields);
    }

    const mod = _.modified();

    if (!(mod || pulse.changed(pulse.ADD_REM) || Params.some(modp))) return;
    const data = pulse.materialize(pulse.SOURCE).source,
          layout = this.value,
          as = _.as || Output;
    let fontSize = _.fontSize || 14,
        range;
    (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(fontSize) ? range = _.fontSizeRange : fontSize = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.constant)(fontSize); // create font size scaling function as needed

    if (range) {
      const fsize = fontSize,
            sizeScale = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('sqrt')().domain((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.extent)(data, fsize)).range(range);

      fontSize = x => sizeScale(fsize(x));
    }

    data.forEach(t => {
      t[as[0]] = NaN;
      t[as[1]] = NaN;
      t[as[3]] = 0;
    }); // configure layout

    const words = layout.words(data).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || 'archimedean').rotate(_.rotate || 0).font(_.font || 'sans-serif').fontStyle(_.fontStyle || 'normal').fontWeight(_.fontWeight || 'normal').fontSize(fontSize).random(vega_statistics__WEBPACK_IMPORTED_MODULE_4__.random).layout();
    const size = layout.size(),
          dx = size[0] >> 1,
          dy = size[1] >> 1,
          n = words.length;

    for (let i = 0, w, t; i < n; ++i) {
      w = words[i];
      t = w.datum;
      t[as[0]] = w.x + dx;
      t[as[1]] = w.y + dy;
      t[as[2]] = w.font;
      t[as[3]] = w.size;
      t[as[4]] = w.style;
      t[as[5]] = w.weight;
      t[as[6]] = w.rotate;
    }

    return pulse.reflow(mod).modifies(as);
  }

});




/***/ }),

/***/ "../../node_modules/vega/build/vega.module.js":
/*!****************************************************!*\
  !*** ../../node_modules/vega/build/vega.module.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debug": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Debug),
/* harmony export */   "Error": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Error),
/* harmony export */   "Info": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Info),
/* harmony export */   "None": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.None),
/* harmony export */   "Warn": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Warn),
/* harmony export */   "accessor": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor),
/* harmony export */   "accessorFields": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields),
/* harmony export */   "accessorName": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
/* harmony export */   "array": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.array),
/* harmony export */   "ascending": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.ascending),
/* harmony export */   "clampRange": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.clampRange),
/* harmony export */   "compare": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.compare),
/* harmony export */   "constant": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.constant),
/* harmony export */   "debounce": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce),
/* harmony export */   "error": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.error),
/* harmony export */   "extend": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extend),
/* harmony export */   "extent": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extent),
/* harmony export */   "extentIndex": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extentIndex),
/* harmony export */   "falsy": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.falsy),
/* harmony export */   "fastmap": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap),
/* harmony export */   "field": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.field),
/* harmony export */   "flush": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.flush),
/* harmony export */   "hasOwnProperty": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty),
/* harmony export */   "id": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.id),
/* harmony export */   "identity": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.identity),
/* harmony export */   "inherits": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits),
/* harmony export */   "inrange": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange),
/* harmony export */   "isArray": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray),
/* harmony export */   "isBoolean": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isBoolean),
/* harmony export */   "isDate": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate),
/* harmony export */   "isFunction": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction),
/* harmony export */   "isIterable": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isIterable),
/* harmony export */   "isNumber": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber),
/* harmony export */   "isObject": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject),
/* harmony export */   "isRegExp": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp),
/* harmony export */   "isString": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isString),
/* harmony export */   "key": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.key),
/* harmony export */   "lerp": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.lerp),
/* harmony export */   "logger": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.logger),
/* harmony export */   "lruCache": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.lruCache),
/* harmony export */   "merge": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.merge),
/* harmony export */   "mergeConfig": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.mergeConfig),
/* harmony export */   "one": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.one),
/* harmony export */   "pad": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.pad),
/* harmony export */   "panLinear": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panLinear),
/* harmony export */   "panLog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panLog),
/* harmony export */   "panPow": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panPow),
/* harmony export */   "panSymlog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panSymlog),
/* harmony export */   "peek": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.peek),
/* harmony export */   "quarter": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.quarter),
/* harmony export */   "repeat": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.repeat),
/* harmony export */   "span": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.span),
/* harmony export */   "splitAccessPath": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.splitAccessPath),
/* harmony export */   "stringValue": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue),
/* harmony export */   "toBoolean": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean),
/* harmony export */   "toDate": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate),
/* harmony export */   "toNumber": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber),
/* harmony export */   "toSet": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet),
/* harmony export */   "toString": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toString),
/* harmony export */   "truncate": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.truncate),
/* harmony export */   "truthy": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy),
/* harmony export */   "utcquarter": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.utcquarter),
/* harmony export */   "visitArray": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray),
/* harmony export */   "writeConfig": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.writeConfig),
/* harmony export */   "zero": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zero),
/* harmony export */   "zoomLinear": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLinear),
/* harmony export */   "zoomLog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLog),
/* harmony export */   "zoomPow": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomPow),
/* harmony export */   "zoomSymlog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomSymlog),
/* harmony export */   "Dataflow": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow),
/* harmony export */   "EventStream": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.EventStream),
/* harmony export */   "MultiPulse": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.MultiPulse),
/* harmony export */   "Operator": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator),
/* harmony export */   "Parameters": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Parameters),
/* harmony export */   "Pulse": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Pulse),
/* harmony export */   "Transform": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   "changeset": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset),
/* harmony export */   "definition": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.definition),
/* harmony export */   "ingest": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest),
/* harmony export */   "isTuple": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.isTuple),
/* harmony export */   "transform": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transform),
/* harmony export */   "transforms": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms),
/* harmony export */   "tupleid": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid),
/* harmony export */   "bandwidthNRD": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bandwidthNRD),
/* harmony export */   "bin": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bin),
/* harmony export */   "bootstrapCI": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bootstrapCI),
/* harmony export */   "cumulativeLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeLogNormal),
/* harmony export */   "cumulativeNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeNormal),
/* harmony export */   "cumulativeUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeUniform),
/* harmony export */   "densityLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityLogNormal),
/* harmony export */   "densityNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityNormal),
/* harmony export */   "densityUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityUniform),
/* harmony export */   "dotbin": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.dotbin),
/* harmony export */   "quantileLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileLogNormal),
/* harmony export */   "quantileNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileNormal),
/* harmony export */   "quantileUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileUniform),
/* harmony export */   "quantiles": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantiles),
/* harmony export */   "quartiles": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quartiles),
/* harmony export */   "random": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.random),
/* harmony export */   "randomInteger": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomInteger),
/* harmony export */   "randomKDE": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomKDE),
/* harmony export */   "randomLCG": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomLCG),
/* harmony export */   "randomLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomLogNormal),
/* harmony export */   "randomMixture": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomMixture),
/* harmony export */   "randomNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomNormal),
/* harmony export */   "randomUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomUniform),
/* harmony export */   "regressionExp": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionExp),
/* harmony export */   "regressionLinear": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLinear),
/* harmony export */   "regressionLoess": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLoess),
/* harmony export */   "regressionLog": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLog),
/* harmony export */   "regressionPoly": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionPoly),
/* harmony export */   "regressionPow": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionPow),
/* harmony export */   "regressionQuad": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionQuad),
/* harmony export */   "sampleCurve": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleCurve),
/* harmony export */   "sampleLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleLogNormal),
/* harmony export */   "sampleNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleNormal),
/* harmony export */   "sampleUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleUniform),
/* harmony export */   "setRandom": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.setRandom),
/* harmony export */   "DATE": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DATE),
/* harmony export */   "DAY": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DAY),
/* harmony export */   "DAYOFYEAR": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DAYOFYEAR),
/* harmony export */   "HOURS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.HOURS),
/* harmony export */   "MILLISECONDS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MILLISECONDS),
/* harmony export */   "MINUTES": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MINUTES),
/* harmony export */   "MONTH": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MONTH),
/* harmony export */   "QUARTER": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.QUARTER),
/* harmony export */   "SECONDS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.SECONDS),
/* harmony export */   "TIME_UNITS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.TIME_UNITS),
/* harmony export */   "WEEK": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.WEEK),
/* harmony export */   "YEAR": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.YEAR),
/* harmony export */   "dayofyear": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.dayofyear),
/* harmony export */   "timeBin": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeBin),
/* harmony export */   "timeFloor": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeFloor),
/* harmony export */   "timeInterval": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeInterval),
/* harmony export */   "timeOffset": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeOffset),
/* harmony export */   "timeSequence": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeSequence),
/* harmony export */   "timeUnitSpecifier": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeUnitSpecifier),
/* harmony export */   "timeUnits": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeUnits),
/* harmony export */   "utcFloor": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcFloor),
/* harmony export */   "utcInterval": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcInterval),
/* harmony export */   "utcOffset": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcOffset),
/* harmony export */   "utcSequence": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcSequence),
/* harmony export */   "utcdayofyear": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcdayofyear),
/* harmony export */   "utcweek": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcweek),
/* harmony export */   "week": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.week),
/* harmony export */   "format": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.format),
/* harmony export */   "formats": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.formats),
/* harmony export */   "inferType": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.inferType),
/* harmony export */   "inferTypes": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.inferTypes),
/* harmony export */   "loader": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.loader),
/* harmony export */   "read": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.read),
/* harmony export */   "responseType": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.responseType),
/* harmony export */   "typeParsers": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.typeParsers),
/* harmony export */   "Bounds": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Bounds),
/* harmony export */   "CanvasHandler": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.CanvasHandler),
/* harmony export */   "CanvasRenderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.CanvasRenderer),
/* harmony export */   "Gradient": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Gradient),
/* harmony export */   "GroupItem": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.GroupItem),
/* harmony export */   "Handler": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Handler),
/* harmony export */   "Item": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Item),
/* harmony export */   "Marks": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Marks),
/* harmony export */   "RenderType": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.RenderType),
/* harmony export */   "Renderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Renderer),
/* harmony export */   "ResourceLoader": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.ResourceLoader),
/* harmony export */   "SVGHandler": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGHandler),
/* harmony export */   "SVGRenderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGRenderer),
/* harmony export */   "SVGStringRenderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGStringRenderer),
/* harmony export */   "Scenegraph": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Scenegraph),
/* harmony export */   "boundClip": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundClip),
/* harmony export */   "boundContext": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundContext),
/* harmony export */   "boundItem": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundItem),
/* harmony export */   "boundMark": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundMark),
/* harmony export */   "boundStroke": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundStroke),
/* harmony export */   "domChild": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domChild),
/* harmony export */   "domClear": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domClear),
/* harmony export */   "domCreate": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domCreate),
/* harmony export */   "domFind": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domFind),
/* harmony export */   "font": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.font),
/* harmony export */   "fontFamily": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.fontFamily),
/* harmony export */   "fontSize": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.fontSize),
/* harmony export */   "intersect": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersect),
/* harmony export */   "intersectBoxLine": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectBoxLine),
/* harmony export */   "intersectPath": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectPath),
/* harmony export */   "intersectPoint": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectPoint),
/* harmony export */   "intersectRule": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectRule),
/* harmony export */   "lineHeight": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.lineHeight),
/* harmony export */   "markup": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.markup),
/* harmony export */   "multiLineOffset": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.multiLineOffset),
/* harmony export */   "pathCurves": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathCurves),
/* harmony export */   "pathEqual": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathEqual),
/* harmony export */   "pathParse": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathParse),
/* harmony export */   "pathRectangle": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathRectangle),
/* harmony export */   "pathRender": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathRender),
/* harmony export */   "pathSymbols": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathSymbols),
/* harmony export */   "pathTrail": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathTrail),
/* harmony export */   "point": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.point),
/* harmony export */   "renderModule": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.renderModule),
/* harmony export */   "resetSVGClipId": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.resetSVGClipId),
/* harmony export */   "resetSVGDefIds": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.resetSVGDefIds),
/* harmony export */   "sceneEqual": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneEqual),
/* harmony export */   "sceneFromJSON": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneFromJSON),
/* harmony export */   "scenePickVisit": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.scenePickVisit),
/* harmony export */   "sceneToJSON": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneToJSON),
/* harmony export */   "sceneVisit": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneVisit),
/* harmony export */   "sceneZOrder": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneZOrder),
/* harmony export */   "serializeXML": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.serializeXML),
/* harmony export */   "textMetrics": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.textMetrics),
/* harmony export */   "interpolate": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolate),
/* harmony export */   "interpolateColors": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolateColors),
/* harmony export */   "interpolateRange": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolateRange),
/* harmony export */   "quantizeInterpolator": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.quantizeInterpolator),
/* harmony export */   "scale": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.scale),
/* harmony export */   "scheme": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.scheme),
/* harmony export */   "projection": () => (/* reexport safe */ vega_projection__WEBPACK_IMPORTED_MODULE_18__.projection),
/* harmony export */   "View": () => (/* reexport safe */ vega_view__WEBPACK_IMPORTED_MODULE_19__.View),
/* harmony export */   "defaultLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.defaultLocale),
/* harmony export */   "formatLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.numberFormatDefaultLocale),
/* harmony export */   "locale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.locale),
/* harmony export */   "resetDefaultLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.resetDefaultLocale),
/* harmony export */   "timeFormatLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.timeFormatDefaultLocale),
/* harmony export */   "expressionFunction": () => (/* reexport safe */ vega_functions__WEBPACK_IMPORTED_MODULE_21__.expressionFunction),
/* harmony export */   "parse": () => (/* reexport safe */ vega_parser__WEBPACK_IMPORTED_MODULE_22__.parse),
/* harmony export */   "runtimeContext": () => (/* reexport safe */ vega_runtime__WEBPACK_IMPORTED_MODULE_23__.context),
/* harmony export */   "codegenExpression": () => (/* reexport safe */ vega_expression__WEBPACK_IMPORTED_MODULE_24__.codegenExpression),
/* harmony export */   "parseExpression": () => (/* reexport safe */ vega_expression__WEBPACK_IMPORTED_MODULE_24__.parseExpression),
/* harmony export */   "parseSelector": () => (/* reexport safe */ vega_event_selector__WEBPACK_IMPORTED_MODULE_25__.parseSelector),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_transforms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-transforms */ "../../node_modules/vega-transforms/build/vega-transforms.module.js");
/* harmony import */ var vega_view_transforms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-view-transforms */ "../../node_modules/vega-view-transforms/build/vega-view-transforms.module.js");
/* harmony import */ var vega_encode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-encode */ "../../node_modules/vega-encode/build/vega-encode.module.js");
/* harmony import */ var vega_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-geo */ "../../node_modules/vega-geo/build/vega-geo.module.js");
/* harmony import */ var vega_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-force */ "../../node_modules/vega-force/build/vega-force.module.js");
/* harmony import */ var vega_hierarchy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-hierarchy */ "../../node_modules/vega-hierarchy/build/vega-hierarchy.module.js");
/* harmony import */ var vega_label__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vega-label */ "../../node_modules/vega-label/build/vega-label.module.js");
/* harmony import */ var vega_regression__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vega-regression */ "../../node_modules/vega-regression/build/vega-regression.module.js");
/* harmony import */ var vega_voronoi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vega-voronoi */ "../../node_modules/vega-voronoi/build/vega-voronoi.module.js");
/* harmony import */ var vega_wordcloud__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! vega-wordcloud */ "../../node_modules/vega-wordcloud/build/vega-wordcloud.module.js");
/* harmony import */ var vega_crossfilter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! vega-crossfilter */ "../../node_modules/vega-crossfilter/build/vega-crossfilter.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! vega-loader */ "../../node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_projection__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! vega-projection */ "../../node_modules/vega-projection/build/vega-projection.module.js");
/* harmony import */ var vega_view__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! vega-view */ "../../node_modules/vega-view/build/vega-view.module.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! vega-format */ "../../node_modules/vega-format/build/vega-format.module.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! vega-functions */ "../../node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_parser__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! vega-parser */ "../../node_modules/vega-parser/build/vega-parser.module.js");
/* harmony import */ var vega_runtime__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! vega-runtime */ "../../node_modules/vega-runtime/build/vega-runtime.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! vega-expression */ "../../node_modules/vega-expression/build/vega-expression.module.js");
/* harmony import */ var vega_event_selector__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! vega-event-selector */ "../../node_modules/vega-event-selector/build/vega-event-selector.module.js");





























var name = "vega";
var version$1 = "5.21.0";
var description = "The Vega visualization grammar.";
var keywords = [
	"vega",
	"visualization",
	"interaction",
	"dataflow",
	"library",
	"data",
	"d3"
];
var license = "BSD-3-Clause";
var author = "UW Interactive Data Lab (http://idl.cs.washington.edu)";
var main = "build/vega-node.js";
var module = "build/vega.module.js";
var unpkg = "build/vega.min.js";
var jsdelivr = "build/vega.min.js";
var types = "index.d.ts";
var repository = "vega/vega";
var scripts = {
	bundle: "rollup -c --config-bundle",
	prebuild: "rimraf build && rimraf build-es5",
	build: "rollup -c --config-core --config-bundle --config-ie",
	postbuild: "node schema-copy",
	pretest: "yarn build --config-test",
	test: "TZ=America/Los_Angeles tape 'test/**/*-test.js'",
	prepublishOnly: "yarn test && yarn build",
	postpublish: "./schema-deploy.sh"
};
var dependencies = {
	"vega-crossfilter": "~4.0.5",
	"vega-dataflow": "~5.7.4",
	"vega-encode": "~4.8.3",
	"vega-event-selector": "~3.0.0",
	"vega-expression": "~5.0.0",
	"vega-force": "~4.0.7",
	"vega-format": "~1.0.4",
	"vega-functions": "~5.12.1",
	"vega-geo": "~4.3.8",
	"vega-hierarchy": "~4.0.9",
	"vega-label": "~1.1.0",
	"vega-loader": "~4.4.1",
	"vega-parser": "~6.1.4",
	"vega-projection": "~1.4.5",
	"vega-regression": "~1.0.9",
	"vega-runtime": "~6.1.3",
	"vega-scale": "~7.1.1",
	"vega-scenegraph": "~4.9.4",
	"vega-statistics": "~1.7.10",
	"vega-time": "~2.0.4",
	"vega-transforms": "~4.9.4",
	"vega-typings": "~0.22.0",
	"vega-util": "~1.17.0",
	"vega-view": "~5.10.1",
	"vega-view-transforms": "~4.5.8",
	"vega-voronoi": "~4.1.5",
	"vega-wordcloud": "~4.1.3"
};
var devDependencies = {
	"vega-schema": "*"
};
var gitHead = "774165e29850b66ec8b79ba52a7955f1ab936ea6";
var pkg = {
	name: name,
	version: version$1,
	description: description,
	keywords: keywords,
	license: license,
	author: author,
	main: main,
	module: module,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	types: types,
	repository: repository,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	gitHead: gitHead
};

// -- Transforms -----
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms, vega_transforms__WEBPACK_IMPORTED_MODULE_2__, vega_view_transforms__WEBPACK_IMPORTED_MODULE_3__, vega_encode__WEBPACK_IMPORTED_MODULE_4__, vega_geo__WEBPACK_IMPORTED_MODULE_5__, vega_force__WEBPACK_IMPORTED_MODULE_6__, vega_label__WEBPACK_IMPORTED_MODULE_8__, vega_hierarchy__WEBPACK_IMPORTED_MODULE_7__, vega_regression__WEBPACK_IMPORTED_MODULE_9__, vega_voronoi__WEBPACK_IMPORTED_MODULE_10__, vega_wordcloud__WEBPACK_IMPORTED_MODULE_11__, vega_crossfilter__WEBPACK_IMPORTED_MODULE_12__); // -- Exports -----

const version = pkg.version;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9hc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2RldmlhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9mc3VtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21heC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZWFuLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21lZGlhbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3Blcm11dGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcXVhbnRpbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcXVpY2tzZWxlY3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc3VtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3RpY2tzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3ZhcmlhbmNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2NvbG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2N1YmVoZWxpeC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvbGFiLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1kZWxhdW5heS9zcmMvZGVsYXVuYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1kZWxhdW5heS9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWRlbGF1bmF5L3NyYy9wb2x5Z29uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZGVsYXVuYXkvc3JjL3Zvcm9ub2kuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL2Rzdi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZGVmYXVsdExvY2FsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZXhwb25lbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdERlY2ltYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdEdyb3VwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXROdW1lcmFscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0UHJlZml4QXV0by5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0Um91bmRlZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0U3BlY2lmaWVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRUcmltLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRUeXBlcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2xvY2FsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvcHJlY2lzaW9uRml4ZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvblByZWZpeC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvcHJlY2lzaW9uUm91bmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2FyZWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2JvdW5kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2FydGVzaWFuLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jZW50cm9pZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2lyY2xlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2FudGltZXJpZGlhbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvY2lyY2xlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2xpbmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvcmVjdGFuZ2xlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL3Jlam9pbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY29tcG9zZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2dyYXRpY3VsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL25vb3AuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvYXJlYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9ib3VuZHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvY2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvY29udGV4dC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9tZWFzdXJlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcG9pbnRFcXVhbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcG9seWdvbkNvbnRhaW5zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2FsYmVycy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hbGJlcnNVc2EuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vYXppbXV0aGFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2F6aW11dGhhbEVxdWFsQXJlYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hemltdXRoYWxFcXVpZGlzdGFudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9jb25pYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9jb25pY0NvbmZvcm1hbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9jb25pY0VxdWFsQXJlYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9jb25pY0VxdWlkaXN0YW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2N5bGluZHJpY2FsRXF1YWxBcmVhLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2VxdWFsRWFydGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vZXF1aXJlY3Rhbmd1bGFyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2ZpdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9nbm9tb25pYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9tZXJjYXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9uYXR1cmFsRWFydGgxLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL29ydGhvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9yZXNhbXBsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9zdGVyZW9ncmFwaGljLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL3RyYW5zdmVyc2VNZXJjYXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcm90YXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2FycmF5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2NvbG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2N1YmVoZWxpeC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9kYXRlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Rpc2NyZXRlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2hjbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9oc2wuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvaHVlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2xhYi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvb2JqZWN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3BpZWNld2lzZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9yZ2IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcm91bmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvc3RyaW5nLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9kZWNvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9wYXJzZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy92YWx1ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy96b29tLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtcGF0aC9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jb250aW51b3VzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2RpdmVyZ2luZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pbml0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2xpbmVhci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9sb2cuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbmljZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvb3JkaW5hbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9wb3cuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcXVhbnRpbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcXVhbnRpemUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvc2VxdWVudGlhbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zeW1sb2cuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGltZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy91dGNUaW1lLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvc3JjL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lLWZvcm1hdC9zcmMvbG9jYWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvZGF5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvZHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9ob3VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvaW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9taWxsaXNlY29uZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL21pbnV0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL21vbnRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvc2Vjb25kLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdGlja3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNEYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNIb3VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjTWludXRlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjTW9udGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNXZWVrLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjWWVhci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3dlZWsuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy95ZWFyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL2ludGVydmFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZGVsYXVuYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvYmJveC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvYmlzZWN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9mZWF0dXJlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL21lcmdlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9tZXNoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9uZWlnaGJvcnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL3F1YW50aXplLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9yZXZlcnNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9zdGl0Y2guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvdW50cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWNhbnZhcy9pbmRleC5icm93c2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1jYW52YXMvc3JjL2RvbUNhbnZhcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtY3Jvc3NmaWx0ZXIvYnVpbGQvdmVnYS1jcm9zc2ZpbHRlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L2J1aWxkL3ZlZ2EtZGF0YWZsb3cubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1lbmNvZGUvYnVpbGQvdmVnYS1lbmNvZGUubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1ldmVudC1zZWxlY3Rvci9idWlsZC92ZWdhLWV2ZW50LXNlbGVjdG9yLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9idWlsZC92ZWdhLWV4cHJlc3Npb24ubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JjZS9idWlsZC92ZWdhLWZvcmNlLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2Uvbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9kaXNwYXRjaC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2Uvbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jZW50ZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvY29sbGlkZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2Uvbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2Uvbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9qaWdnbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvbGNnLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JjZS9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL2xpbmsuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvbWFueUJvZHkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvc2ltdWxhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2Uvbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy94LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JjZS9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvYWRkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JjZS9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2NvdmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JjZS9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2RhdGEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZXh0ZW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JjZS9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2Uvbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9xdWFkdHJlZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2Uvbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcm9vdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2Uvbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9zaXplLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JjZS9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Zpc2l0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JjZS9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Zpc2l0QWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMveC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2Uvbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy95LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JtYXQvYnVpbGQvdmVnYS1mb3JtYXQubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mdW5jdGlvbnMvYnVpbGQvdmVnYS1mdW5jdGlvbnMubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1nZW8vYnVpbGQvdmVnYS1nZW8ubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvYnVpbGQvdmVnYS1oaWVyYXJjaHkubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvYWNjZXNzb3JzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9jbHVzdGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvYW5jZXN0b3JzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2NvdW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2Rlc2NlbmRhbnRzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2VhY2guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvZWFjaEFmdGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2VhY2hCZWZvcmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvZmluZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9sZWF2ZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvbGlua3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvcGF0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9zb3J0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L3N1bS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3BhY2svZW5jbG9zZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3BhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9wYWNrL3NpYmxpbmdzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvcGFydGl0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvc3RyYXRpZnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL2RpY2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9yZXNxdWFyaWZ5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1oaWVyYXJjaHkvbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9yb3VuZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3RyZWVtYXAvc2xpY2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL3NsaWNlRGljZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3RyZWVtYXAvc3F1YXJpZnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWxhYmVsL2J1aWxkL3ZlZ2EtbGFiZWwubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1sb2FkZXIvYnVpbGQvdmVnYS1sb2FkZXIuYnJvd3Nlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXBhcnNlci9idWlsZC92ZWdhLXBhcnNlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXByb2plY3Rpb24vYnVpbGQvdmVnYS1wcm9qZWN0aW9uLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtcHJvamVjdGlvbi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXByb2plY3Rpb24vbm9kZV9tb2R1bGVzL2QzLWdlby1wcm9qZWN0aW9uL3NyYy9tb2xsd2VpZGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXJlZ3Jlc3Npb24vYnVpbGQvdmVnYS1yZWdyZXNzaW9uLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtcnVudGltZS9idWlsZC92ZWdhLXJ1bnRpbWUubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2FsZS9idWlsZC92ZWdhLXNjYWxlLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9idWlsZC92ZWdhLXNjZW5lZ3JhcGgubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJjLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJlYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FycmF5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXNPcGVuLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYnVuZGxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2FyZGluYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbENsb3NlZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsT3Blbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb20uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tQ2xvc2VkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2F0bXVsbFJvbU9wZW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXJDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9tb25vdG9uZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL25hdHVyYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9zdGVwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbGluZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9ub29wLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcG9pbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY2lyY2xlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2Nyb3NzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2RpYW1vbmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3N0YXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvd3llLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1zZWxlY3Rpb25zL2J1aWxkL3ZlZ2Etc2VsZWN0aW9uLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc3RhdGlzdGljcy9idWlsZC92ZWdhLXN0YXRpc3RpY3MubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS10aW1lL2J1aWxkL3ZlZ2EtdGltZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXRyYW5zZm9ybXMvYnVpbGQvdmVnYS10cmFuc2Zvcm1zLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etdmlldy10cmFuc2Zvcm1zL2J1aWxkL3ZlZ2Etdmlldy10cmFuc2Zvcm1zLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etdmlldy9idWlsZC92ZWdhLXZpZXcubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS12b3Jvbm9pL2J1aWxkL3ZlZ2Etdm9yb25vaS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXdvcmRjbG91ZC9idWlsZC92ZWdhLXdvcmRjbG91ZC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhL2J1aWxkL3ZlZ2EubW9kdWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRnVDO0FBQ0Y7QUFDSjs7QUFFakMsd0JBQXdCLHFEQUFRLENBQUMsa0RBQVM7QUFDbkM7QUFDQTtBQUNBLHFCQUFxQixxREFBUSxDQUFDLCtDQUFNO0FBQzNDLGlFQUFlLFdBQVcsRUFBQzs7Ozs7Ozs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsbUJBQW1CLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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OztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVzs7QUFFWCxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1EQUFRLFFBQVEsb0RBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7OztBQUdwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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S0FBSztBQUNMO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0IsZ0RBQUs7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FB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R0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxpREFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBLGtDQUFrQzs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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USxrREFBa0Qsc0RBQVc7QUFDbEk7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0MsOEJBQThCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxTQUFTO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQWM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLE9BQU8seURBQWM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQU07O0FBRTNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpREFBTTs7QUFFbEQsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtEQUFLO0FBQ3RCLG1CQUFtQixrREFBTTtBQUN6QixtQkFBbUIsa0RBQU07QUFDekIsa0JBQWtCLGtEQUFNO0FBQ3hCO0FBQ0Esb0JBQW9CLGtEQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILE1BQU0scURBQVU7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQVE7O0FBRVI7QUFDQTtBQUNBLGlDQUFpQyxtREFBTTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esa0JBQWtCLGtEQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLHFEQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsbURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWSxJQUFJLEtBQUs7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsa0RBQU87QUFDaEI7O0FBRUE7QUFDQSxtREFBbUQsa0RBQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrREFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlEQUFNO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUseURBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUyxFQUFFOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFIOztBQUVySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixPQUFPO0FBQ2hDOztBQUVBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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RSx1Q0FBSyxFQUFFLHVDQUFLLEVBQUUsMkNBQUksRUFBRSw0Q0FBRyxFQUFFLDBDQUFPLEVBQUUsNENBQVMsRUFBRSw4Q0FBRSxFQUFFOztBQUUxRjs7QUFFbUIiLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdmVnYV9idWlsZF92ZWdhX21vZHVsZV9qcy4zYjJlNTg4Mzc1MWU2ZDVjOTlmNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBiaXNlY3RvciBmcm9tIFwiLi9iaXNlY3Rvci5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxuY29uc3QgYXNjZW5kaW5nQmlzZWN0ID0gYmlzZWN0b3IoYXNjZW5kaW5nKTtcbmV4cG9ydCBjb25zdCBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbmV4cG9ydCBjb25zdCBiaXNlY3RMZWZ0ID0gYXNjZW5kaW5nQmlzZWN0LmxlZnQ7XG5leHBvcnQgY29uc3QgYmlzZWN0Q2VudGVyID0gYmlzZWN0b3IobnVtYmVyKS5jZW50ZXI7XG5leHBvcnQgZGVmYXVsdCBiaXNlY3RSaWdodDtcbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGYpIHtcbiAgbGV0IGRlbHRhID0gZjtcbiAgbGV0IGNvbXBhcmUgPSBmO1xuXG4gIGlmIChmLmxlbmd0aCA9PT0gMSkge1xuICAgIGRlbHRhID0gKGQsIHgpID0+IGYoZCkgLSB4O1xuICAgIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGVmdChhLCB4LCBsbywgaGkpIHtcbiAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBjb25zdCBtaWQgPSAobG8gKyBoaSkgPj4+IDE7XG4gICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gcmlnaHQoYSwgeCwgbG8sIGhpKSB7XG4gICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkO1xuICAgICAgZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRlcihhLCB4LCBsbywgaGkpIHtcbiAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IGkgPSBsZWZ0KGEsIHgsIGxvLCBoaSAtIDEpO1xuICAgIHJldHVybiBpID4gbG8gJiYgZGVsdGEoYVtpIC0gMV0sIHgpID4gLWRlbHRhKGFbaV0sIHgpID8gaSAtIDEgOiBpO1xuICB9XG5cbiAgcmV0dXJuIHtsZWZ0LCBjZW50ZXIsIHJpZ2h0fTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gIHJldHVybiAoZCwgeCkgPT4gYXNjZW5kaW5nKGYoZCksIHgpO1xufVxuIiwiaW1wb3J0IHZhcmlhbmNlIGZyb20gXCIuL3ZhcmlhbmNlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldmlhdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgY29uc3QgdiA9IHZhcmlhbmNlKHZhbHVlcywgdmFsdWVvZik7XG4gIHJldHVybiB2ID8gTWF0aC5zcXJ0KHYpIDogdjtcbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9weXRob24vY3B5dGhvbi9ibG9iL2E3NGVlYTIzOGY1YmFiYTE1Nzk3ZTJlOGI1NzBkMTUzYmM4NjkwYTcvTW9kdWxlcy9tYXRobW9kdWxlLmMjTDE0MjNcbmV4cG9ydCBjbGFzcyBBZGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BhcnRpYWxzID0gbmV3IEZsb2F0NjRBcnJheSgzMik7XG4gICAgdGhpcy5fbiA9IDA7XG4gIH1cbiAgYWRkKHgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fcGFydGlhbHM7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fbiAmJiBqIDwgMzI7IGorKykge1xuICAgICAgY29uc3QgeSA9IHBbal0sXG4gICAgICAgIGhpID0geCArIHksXG4gICAgICAgIGxvID0gTWF0aC5hYnMoeCkgPCBNYXRoLmFicyh5KSA/IHggLSAoaGkgLSB5KSA6IHkgLSAoaGkgLSB4KTtcbiAgICAgIGlmIChsbykgcFtpKytdID0gbG87XG4gICAgICB4ID0gaGk7XG4gICAgfVxuICAgIHBbaV0gPSB4O1xuICAgIHRoaXMuX24gPSBpICsgMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YWx1ZU9mKCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wYXJ0aWFscztcbiAgICBsZXQgbiA9IHRoaXMuX24sIHgsIHksIGxvLCBoaSA9IDA7XG4gICAgaWYgKG4gPiAwKSB7XG4gICAgICBoaSA9IHBbLS1uXTtcbiAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICB4ID0gaGk7XG4gICAgICAgIHkgPSBwWy0tbl07XG4gICAgICAgIGhpID0geCArIHk7XG4gICAgICAgIGxvID0geSAtIChoaSAtIHgpO1xuICAgICAgICBpZiAobG8pIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG4gPiAwICYmICgobG8gPCAwICYmIHBbbiAtIDFdIDwgMCkgfHwgKGxvID4gMCAmJiBwW24gLSAxXSA+IDApKSkge1xuICAgICAgICB5ID0gbG8gKiAyO1xuICAgICAgICB4ID0gaGkgKyB5O1xuICAgICAgICBpZiAoeSA9PSB4IC0gaGkpIGhpID0geDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmc3VtKHZhbHVlcywgdmFsdWVvZikge1xuICBjb25zdCBhZGRlciA9IG5ldyBBZGRlcigpO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWUpIHtcbiAgICAgICAgYWRkZXIuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkge1xuICAgICAgICBhZGRlci5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gK2FkZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmN1bXN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgY29uc3QgYWRkZXIgPSBuZXcgQWRkZXIoKTtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIHJldHVybiBGbG9hdDY0QXJyYXkuZnJvbSh2YWx1ZXMsIHZhbHVlb2YgPT09IHVuZGVmaW5lZFxuICAgICAgPyB2ID0+IGFkZGVyLmFkZCgrdiB8fCAwKVxuICAgICAgOiB2ID0+IGFkZGVyLmFkZCgrdmFsdWVvZih2LCArK2luZGV4LCB2YWx1ZXMpIHx8IDApXG4gICk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtYXg7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZWFuKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3VtID0gMDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICArK2NvdW50LCBzdW0gKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICArK2NvdW50LCBzdW0gKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjb3VudCkgcmV0dXJuIHN1bSAvIGNvdW50O1xufVxuIiwiaW1wb3J0IHF1YW50aWxlIGZyb20gXCIuL3F1YW50aWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICByZXR1cm4gcXVhbnRpbGUodmFsdWVzLCAwLjUsIHZhbHVlb2YpO1xufVxuIiwiZnVuY3Rpb24qIGZsYXR0ZW4oYXJyYXlzKSB7XG4gIGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG4gICAgeWllbGQqIGFycmF5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlKGFycmF5cykge1xuICByZXR1cm4gQXJyYXkuZnJvbShmbGF0dGVuKGFycmF5cykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWluO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIG51bWJlcnModmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNvdXJjZSwga2V5cykge1xuICByZXR1cm4gQXJyYXkuZnJvbShrZXlzLCBrZXkgPT4gc291cmNlW2tleV0pO1xufVxuIiwiaW1wb3J0IG1heCBmcm9tIFwiLi9tYXguanNcIjtcbmltcG9ydCBtaW4gZnJvbSBcIi4vbWluLmpzXCI7XG5pbXBvcnQgcXVpY2tzZWxlY3QgZnJvbSBcIi4vcXVpY2tzZWxlY3QuanNcIjtcbmltcG9ydCBudW1iZXIsIHtudW1iZXJzfSBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpbGUodmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gIHZhbHVlcyA9IEZsb2F0NjRBcnJheS5mcm9tKG51bWJlcnModmFsdWVzLCB2YWx1ZW9mKSk7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBpZiAoKHAgPSArcCkgPD0gMCB8fCBuIDwgMikgcmV0dXJuIG1pbih2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gbWF4KHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gbWF4KHF1aWNrc2VsZWN0KHZhbHVlcywgaTApLnN1YmFycmF5KDAsIGkwICsgMSkpLFxuICAgICAgdmFsdWUxID0gbWluKHZhbHVlcy5zdWJhcnJheShpMCArIDEpKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGlsZVNvcnRlZCh2YWx1ZXMsIHAsIHZhbHVlb2YgPSBudW1iZXIpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIGlmICgocCA9ICtwKSA8PSAwIHx8IG4gPCAyKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzWzBdLCAwLCB2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzW24gLSAxXSwgbiAtIDEsIHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gK3ZhbHVlb2YodmFsdWVzW2kwXSwgaTAsIHZhbHVlcyksXG4gICAgICB2YWx1ZTEgPSArdmFsdWVvZih2YWx1ZXNbaTAgKyAxXSwgaTAgKyAxLCB2YWx1ZXMpO1xuICByZXR1cm4gdmFsdWUwICsgKHZhbHVlMSAtIHZhbHVlMCkgKiAoaSAtIGkwKTtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3F1aWNrc2VsZWN0XG4vLyBJU0MgbGljZW5zZSwgQ29weXJpZ2h0IDIwMTggVmxhZGltaXIgQWdhZm9ua2luLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyYXksIGssIGxlZnQgPSAwLCByaWdodCA9IGFycmF5Lmxlbmd0aCAtIDEsIGNvbXBhcmUgPSBhc2NlbmRpbmcpIHtcbiAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgIGNvbnN0IG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgY29uc3QgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgIGNvbnN0IHogPSBNYXRoLmxvZyhuKTtcbiAgICAgIGNvbnN0IHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgY29uc3Qgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICBxdWlja3NlbGVjdChhcnJheSwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHQgPSBhcnJheVtrXTtcbiAgICBsZXQgaSA9IGxlZnQ7XG4gICAgbGV0IGogPSByaWdodDtcblxuICAgIHN3YXAoYXJyYXksIGxlZnQsIGspO1xuICAgIGlmIChjb21wYXJlKGFycmF5W3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFycmF5LCBsZWZ0LCByaWdodCk7XG5cbiAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgIHN3YXAoYXJyYXksIGksIGopLCArK2ksIC0tajtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2ldLCB0KSA8IDApICsraTtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2pdLCB0KSA+IDApIC0tajtcbiAgICB9XG5cbiAgICBpZiAoY29tcGFyZShhcnJheVtsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyYXksIGxlZnQsIGopO1xuICAgIGVsc2UgKytqLCBzd2FwKGFycmF5LCBqLCByaWdodCk7XG5cbiAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyYXksIGksIGopIHtcbiAgY29uc3QgdCA9IGFycmF5W2ldO1xuICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICBhcnJheVtqXSA9IHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSkgfCAwLFxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBzdW0gPSAwO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWUpIHtcbiAgICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSB7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cbiIsInZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciByZXZlcnNlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbixcbiAgICAgIHRpY2tzLFxuICAgICAgc3RlcDtcblxuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wICYmIGNvdW50ID4gMCkgcmV0dXJuIFtzdGFydF07XG4gIGlmIChyZXZlcnNlID0gc3RvcCA8IHN0YXJ0KSBuID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IG47XG4gIGlmICgoc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSkgPT09IDAgfHwgIWlzRmluaXRlKHN0ZXApKSByZXR1cm4gW107XG5cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgbGV0IHIwID0gTWF0aC5yb3VuZChzdGFydCAvIHN0ZXApLCByMSA9IE1hdGgucm91bmQoc3RvcCAvIHN0ZXApO1xuICAgIGlmIChyMCAqIHN0ZXAgPCBzdGFydCkgKytyMDtcbiAgICBpZiAocjEgKiBzdGVwID4gc3RvcCkgLS1yMTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gcjEgLSByMCArIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChyMCArIGkpICogc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBzdGVwID0gLXN0ZXA7XG4gICAgbGV0IHIwID0gTWF0aC5yb3VuZChzdGFydCAqIHN0ZXApLCByMSA9IE1hdGgucm91bmQoc3RvcCAqIHN0ZXApO1xuICAgIGlmIChyMCAvIHN0ZXAgPCBzdGFydCkgKytyMDtcbiAgICBpZiAocjEgLyBzdGVwID4gc3RvcCkgLS1yMTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gcjEgLSByMCArIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChyMCArIGkpIC8gc3RlcDtcbiAgfVxuXG4gIGlmIChyZXZlcnNlKSB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGguTE4xMCksXG4gICAgICBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICByZXR1cm4gcG93ZXIgPj0gMFxuICAgICAgPyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBwb3dlcilcbiAgICAgIDogLU1hdGgucG93KDEwLCAtcG93ZXIpIC8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAwID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksXG4gICAgICBlcnJvciA9IHN0ZXAwIC8gc3RlcDE7XG4gIGlmIChlcnJvciA+PSBlMTApIHN0ZXAxICo9IDEwO1xuICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcDEgKj0gNTtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTIpIHN0ZXAxICo9IDI7XG4gIHJldHVybiBzdG9wIDwgc3RhcnQgPyAtc3RlcDEgOiBzdGVwMTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhcmlhbmNlKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgZGVsdGE7XG4gIGxldCBtZWFuID0gMDtcbiAgbGV0IHN1bSA9IDA7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK2NvdW50O1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKytjb3VudDtcbiAgICAgICAgc3VtICs9IGRlbHRhICogKHZhbHVlIC0gbWVhbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjb3VudCA+IDEpIHJldHVybiBzdW0gLyAoY291bnQgLSAxKTtcbn1cbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ29sb3IoKSB7fVxuXG5leHBvcnQgdmFyIGRhcmtlciA9IDAuNztcbmV4cG9ydCB2YXIgYnJpZ2h0ZXIgPSAxIC8gZGFya2VyO1xuXG52YXIgcmVJID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsXG4gICAgcmVOID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPylcXFxccypcIixcbiAgICByZVAgPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KSVcXFxccypcIixcbiAgICByZUhleCA9IC9eIyhbMC05YS1mXXszLDh9KSQvLFxuICAgIHJlUmdiSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtyZUksIHJlSSwgcmVJXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtyZVAsIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiYUludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlSSwgcmVJLCByZUksIHJlTl0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZVAsIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVIc2xQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xcXFxcKFwiICsgW3JlTiwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXG4gICAgcmVIc2xhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsYVxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpO1xuXG52YXIgbmFtZWQgPSB7XG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmYsXG4gIGFudGlxdWV3aGl0ZTogMHhmYWViZDcsXG4gIGFxdWE6IDB4MDBmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNCxcbiAgYXp1cmU6IDB4ZjBmZmZmLFxuICBiZWlnZTogMHhmNWY1ZGMsXG4gIGJpc3F1ZTogMHhmZmU0YzQsXG4gIGJsYWNrOiAweDAwMDAwMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxuICBibHVlOiAweDAwMDBmZixcbiAgYmx1ZXZpb2xldDogMHg4YTJiZTIsXG4gIGJyb3duOiAweGE1MmEyYSxcbiAgYnVybHl3b29kOiAweGRlYjg4NyxcbiAgY2FkZXRibHVlOiAweDVmOWVhMCxcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXG4gIGNob2NvbGF0ZTogMHhkMjY5MWUsXG4gIGNvcmFsOiAweGZmN2Y1MCxcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxuICBjb3Juc2lsazogMHhmZmY4ZGMsXG4gIGNyaW1zb246IDB4ZGMxNDNjLFxuICBjeWFuOiAweDAwZmZmZixcbiAgZGFya2JsdWU6IDB4MDAwMDhiLFxuICBkYXJrY3lhbjogMHgwMDhiOGIsXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxuICBkYXJrZ3JheTogMHhhOWE5YTksXG4gIGRhcmtncmVlbjogMHgwMDY0MDAsXG4gIGRhcmtncmV5OiAweGE5YTlhOSxcbiAgZGFya2toYWtpOiAweGJkYjc2YixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiLFxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXG4gIGRhcmtvcmFuZ2U6IDB4ZmY4YzAwLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjYyxcbiAgZGFya3JlZDogMHg4YjAwMDAsXG4gIGRhcmtzYWxtb246IDB4ZTk5NjdhLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmLFxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcbiAgZGFya3NsYXRlZ3JheTogMHgyZjRmNGYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmLFxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcbiAgZGFya3Zpb2xldDogMHg5NDAwZDMsXG4gIGRlZXBwaW5rOiAweGZmMTQ5MyxcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxuICBkaW1ncmF5OiAweDY5Njk2OSxcbiAgZGltZ3JleTogMHg2OTY5NjksXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxuICBmaXJlYnJpY2s6IDB4YjIyMjIyLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjAsXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcbiAgZnVjaHNpYTogMHhmZjAwZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGMsXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxuICBnb2xkOiAweGZmZDcwMCxcbiAgZ29sZGVucm9kOiAweGRhYTUyMCxcbiAgZ3JheTogMHg4MDgwODAsXG4gIGdyZWVuOiAweDAwODAwMCxcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmLFxuICBncmV5OiAweDgwODA4MCxcbiAgaG9uZXlkZXc6IDB4ZjBmZmYwLFxuICBob3RwaW5rOiAweGZmNjliNCxcbiAgaW5kaWFucmVkOiAweGNkNWM1YyxcbiAgaW5kaWdvOiAweDRiMDA4MixcbiAgaXZvcnk6IDB4ZmZmZmYwLFxuICBraGFraTogMHhmMGU2OGMsXG4gIGxhdmVuZGVyOiAweGU2ZTZmYSxcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjUsXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDAsXG4gIGxlbW9uY2hpZmZvbjogMHhmZmZhY2QsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTYsXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxuICBsaWdodGN5YW46IDB4ZTBmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDIsXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDMsXG4gIGxpZ2h0Z3JlZW46IDB4OTBlZTkwLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzLFxuICBsaWdodHBpbms6IDB4ZmZiNmMxLFxuICBsaWdodHNhbG1vbjogMHhmZmEwN2EsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhLFxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxuICBsaWdodHNsYXRlZ3JheTogMHg3Nzg4OTksXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OSxcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxuICBsaWdodHllbGxvdzogMHhmZmZmZTAsXG4gIGxpbWU6IDB4MDBmZjAwLFxuICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxuICBsaW5lbjogMHhmYWYwZTYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmLFxuICBtYXJvb246IDB4ODAwMDAwLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAweDY2Y2RhYSxcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2QsXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXG4gIG1lZGl1bXB1cnBsZTogMHg5MzcwZGIsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MSxcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDB4MDBmYTlhLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjLFxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxuICBtaWRuaWdodGJsdWU6IDB4MTkxOTcwLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhLFxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxuICBtb2NjYXNpbjogMHhmZmU0YjUsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZCxcbiAgbmF2eTogMHgwMDAwODAsXG4gIG9sZGxhY2U6IDB4ZmRmNWU2LFxuICBvbGl2ZTogMHg4MDgwMDAsXG4gIG9saXZlZHJhYjogMHg2YjhlMjMsXG4gIG9yYW5nZTogMHhmZmE1MDAsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDAsXG4gIG9yY2hpZDogMHhkYTcwZDYsXG4gIHBhbGVnb2xkZW5yb2Q6IDB4ZWVlOGFhLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4LFxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcbiAgcGFsZXZpb2xldHJlZDogMHhkYjcwOTMsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1LFxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxuICBwZXJ1OiAweGNkODUzZixcbiAgcGluazogMHhmZmMwY2IsXG4gIHBsdW06IDB4ZGRhMGRkLFxuICBwb3dkZXJibHVlOiAweGIwZTBlNixcbiAgcHVycGxlOiAweDgwMDA4MCxcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXG4gIHJlZDogMHhmZjAwMDAsXG4gIHJvc3licm93bjogMHhiYzhmOGYsXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTEsXG4gIHNhZGRsZWJyb3duOiAweDhiNDUxMyxcbiAgc2FsbW9uOiAweGZhODA3MixcbiAgc2FuZHlicm93bjogMHhmNGE0NjAsXG4gIHNlYWdyZWVuOiAweDJlOGI1NyxcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlLFxuICBzaWVubmE6IDB4YTA1MjJkLFxuICBzaWx2ZXI6IDB4YzBjMGMwLFxuICBza3libHVlOiAweDg3Y2VlYixcbiAgc2xhdGVibHVlOiAweDZhNWFjZCxcbiAgc2xhdGVncmF5OiAweDcwODA5MCxcbiAgc2xhdGVncmV5OiAweDcwODA5MCxcbiAgc25vdzogMHhmZmZhZmEsXG4gIHNwcmluZ2dyZWVuOiAweDAwZmY3ZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNCxcbiAgdGFuOiAweGQyYjQ4YyxcbiAgdGVhbDogMHgwMDgwODAsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4LFxuICB0b21hdG86IDB4ZmY2MzQ3LFxuICB0dXJxdW9pc2U6IDB4NDBlMGQwLFxuICB2aW9sZXQ6IDB4ZWU4MmVlLFxuICB3aGVhdDogMHhmNWRlYjMsXG4gIHdoaXRlOiAweGZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjUsXG4gIHllbGxvdzogMHhmZmZmMDAsXG4gIHllbGxvd2dyZWVuOiAweDlhY2QzMlxufTtcblxuZGVmaW5lKENvbG9yLCBjb2xvciwge1xuICBjb3B5OiBmdW5jdGlvbihjaGFubmVscykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLCBjaGFubmVscyk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICBoZXg6IGNvbG9yX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiBjb2xvcl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhzbDogY29sb3JfZm9ybWF0SHNsLFxuICBmb3JtYXRSZ2I6IGNvbG9yX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IGNvbG9yX2Zvcm1hdFJnYlxufSk7XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhzbCgpIHtcbiAgcmV0dXJuIGhzbENvbnZlcnQodGhpcykuZm9ybWF0SHNsKCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdFJnYigpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0UmdiKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbG9yKGZvcm1hdCkge1xuICB2YXIgbSwgbDtcbiAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKG0gPSByZUhleC5leGVjKGZvcm1hdCkpID8gKGwgPSBtWzFdLmxlbmd0aCwgbSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbCA9PT0gNiA/IHJnYm4obSkgLy8gI2ZmMDAwMFxuICAgICAgOiBsID09PSAzID8gbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpLCAxKSAvLyAjZjAwXG4gICAgICA6IGwgPT09IDggPyByZ2JhKG0gPj4gMjQgJiAweGZmLCBtID4+IDE2ICYgMHhmZiwgbSA+PiA4ICYgMHhmZiwgKG0gJiAweGZmKSAvIDB4ZmYpIC8vICNmZjAwMDAwMFxuICAgICAgOiBsID09PSA0ID8gcmdiYSgobSA+PiAxMiAmIDB4ZikgfCAobSA+PiA4ICYgMHhmMCksIChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpKSAvIDB4ZmYpIC8vICNmMDAwXG4gICAgICA6IG51bGwpIC8vIGludmFsaWQgaGV4XG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiQ29udmVydChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcbiAgbyA9IG8ucmdiKCk7XG4gIHJldHVybiBuZXcgUmdiKG8uciwgby5nLCBvLmIsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHJnYkNvbnZlcnQocikgOiBuZXcgUmdiKHIsIGcsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgtMC41IDw9IHRoaXMuciAmJiB0aGlzLnIgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5nICYmIHRoaXMuZyA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmIgJiYgdGhpcy5iIDwgMjU1LjUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGhleDogcmdiX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiByZ2JfZm9ybWF0SGV4LFxuICBmb3JtYXRSZ2I6IHJnYl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiByZ2JfZm9ybWF0UmdiXG59KSk7XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiBcIiNcIiArIGhleCh0aGlzLnIpICsgaGV4KHRoaXMuZykgKyBoZXgodGhpcy5iKTtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdFJnYigpIHtcbiAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gIHJldHVybiAoYSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwiKVxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5yKSB8fCAwKSkgKyBcIiwgXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuZykgfHwgMCkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmIpIHx8IDApKVxuICAgICAgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gIHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHZhbHVlKSB8fCAwKSk7XG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xuICBpZiAoYSA8PSAwKSBoID0gcyA9IGwgPSBOYU47XG4gIGVsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO1xuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhzbENvbnZlcnQoaCkgOiBuZXcgSHNsKGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShIc2wsIGhzbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IDAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBoc2wycmdiKGggPj0gMjQwID8gaCAtIDI0MCA6IGggKyAxMjAsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGggPCAxMjAgPyBoICsgMjQwIDogaCAtIDEyMCwgbTEsIG0yKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXG4gICAgICAgICYmICgwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgZm9ybWF0SHNsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IHRoaXMub3BhY2l0eTsgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcbiAgICByZXR1cm4gKGEgPT09IDEgPyBcImhzbChcIiA6IFwiaHNsYShcIilcbiAgICAgICAgKyAodGhpcy5oIHx8IDApICsgXCIsIFwiXG4gICAgICAgICsgKHRoaXMucyB8fCAwKSAqIDEwMCArIFwiJSwgXCJcbiAgICAgICAgKyAodGhpcy5sIHx8IDApICogMTAwICsgXCIlXCJcbiAgICAgICAgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbiAgfVxufSkpO1xuXG4vKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG5mdW5jdGlvbiBoc2wycmdiKGgsIG0xLCBtMikge1xuICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgOiBoIDwgMjQwID8gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MFxuICAgICAgOiBtMSkgKiAyNTU7XG59XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcbmltcG9ydCB7Q29sb3IsIHJnYkNvbnZlcnQsIFJnYiwgZGFya2VyLCBicmlnaHRlcn0gZnJvbSBcIi4vY29sb3IuanNcIjtcbmltcG9ydCB7ZGVncmVlcywgcmFkaWFuc30gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG52YXIgQSA9IC0wLjE0ODYxLFxuICAgIEIgPSArMS43ODI3NyxcbiAgICBDID0gLTAuMjkyMjcsXG4gICAgRCA9IC0wLjkwNjQ5LFxuICAgIEUgPSArMS45NzI5NCxcbiAgICBFRCA9IEUgKiBELFxuICAgIEVCID0gRSAqIEIsXG4gICAgQkNfREEgPSBCICogQyAtIEQgKiBBO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXhDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBDdWJlaGVsaXgpIHJldHVybiBuZXcgQ3ViZWhlbGl4KG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIGwgPSAoQkNfREEgKiBiICsgRUQgKiByIC0gRUIgKiBnKSAvIChCQ19EQSArIEVEIC0gRUIpLFxuICAgICAgYmwgPSBiIC0gbCxcbiAgICAgIGsgPSAoRSAqIChnIC0gbCkgLSBDICogYmwpIC8gRCxcbiAgICAgIHMgPSBNYXRoLnNxcnQoayAqIGsgKyBibCAqIGJsKSAvIChFICogbCAqICgxIC0gbCkpLCAvLyBOYU4gaWYgbD0wIG9yIGw9MVxuICAgICAgaCA9IHMgPyBNYXRoLmF0YW4yKGssIGJsKSAqIGRlZ3JlZXMgLSAxMjAgOiBOYU47XG4gIHJldHVybiBuZXcgQ3ViZWhlbGl4KGggPCAwID8gaCArIDM2MCA6IGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY3ViZWhlbGl4Q29udmVydChoKSA6IG5ldyBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShDdWJlaGVsaXgsIGN1YmVoZWxpeCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IGlzTmFOKHRoaXMuaCkgPyAwIDogKHRoaXMuaCArIDEyMCkgKiByYWRpYW5zLFxuICAgICAgICBsID0gK3RoaXMubCxcbiAgICAgICAgYSA9IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zICogbCAqICgxIC0gbCksXG4gICAgICAgIGNvc2ggPSBNYXRoLmNvcyhoKSxcbiAgICAgICAgc2luaCA9IE1hdGguc2luKGgpO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgMjU1ICogKGwgKyBhICogKEEgKiBjb3NoICsgQiAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChDICogY29zaCArIEQgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoRSAqIGNvc2gpKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmYWN0b3J5LCBwcm90b3R5cGUpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gZmFjdG9yeS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgZGVmaW5pdGlvbikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHByb3RvdHlwZVtrZXldID0gZGVmaW5pdGlvbltrZXldO1xuICByZXR1cm4gcHJvdG90eXBlO1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5pbXBvcnQge0NvbG9yLCByZ2JDb252ZXJ0LCBSZ2J9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5pbXBvcnQge2RlZ3JlZXMsIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcblxuLy8gaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9sYWItYW5kLXJnYlxuY29uc3QgSyA9IDE4LFxuICAgIFhuID0gMC45NjQyMixcbiAgICBZbiA9IDEsXG4gICAgWm4gPSAwLjgyNTIxLFxuICAgIHQwID0gNCAvIDI5LFxuICAgIHQxID0gNiAvIDI5LFxuICAgIHQyID0gMyAqIHQxICogdDEsXG4gICAgdDMgPSB0MSAqIHQxICogdDE7XG5cbmZ1bmN0aW9uIGxhYkNvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIExhYikgcmV0dXJuIG5ldyBMYWIoby5sLCBvLmEsIG8uYiwgby5vcGFjaXR5KTtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBoY2wybGFiKG8pO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gcmdiMmxyZ2Ioby5yKSxcbiAgICAgIGcgPSByZ2IybHJnYihvLmcpLFxuICAgICAgYiA9IHJnYjJscmdiKG8uYiksXG4gICAgICB5ID0geHl6MmxhYigoMC4yMjI1MDQ1ICogciArIDAuNzE2ODc4NiAqIGcgKyAwLjA2MDYxNjkgKiBiKSAvIFluKSwgeCwgejtcbiAgaWYgKHIgPT09IGcgJiYgZyA9PT0gYikgeCA9IHogPSB5OyBlbHNlIHtcbiAgICB4ID0geHl6MmxhYigoMC40MzYwNzQ3ICogciArIDAuMzg1MDY0OSAqIGcgKyAwLjE0MzA4MDQgKiBiKSAvIFhuKTtcbiAgICB6ID0geHl6MmxhYigoMC4wMTM5MzIyICogciArIDAuMDk3MTA0NSAqIGcgKyAwLjcxNDE3MzMgKiBiKSAvIFpuKTtcbiAgfVxuICByZXR1cm4gbmV3IExhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geiksIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5KGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIG5ldyBMYWIobCwgMCwgMCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLmEgPSArYTtcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoTGFiLCBsYWIsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGxyZ2IycmdiKCAzLjEzMzg1NjEgKiB4IC0gMS42MTY4NjY3ICogeSAtIDAuNDkwNjE0NiAqIHopLFxuICAgICAgbHJnYjJyZ2IoLTAuOTc4NzY4NCAqIHggKyAxLjkxNjE0MTUgKiB5ICsgMC4wMzM0NTQwICogeiksXG4gICAgICBscmdiMnJnYiggMC4wNzE5NDUzICogeCAtIDAuMjI4OTkxNCAqIHkgKyAxLjQwNTI0MjcgKiB6KSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuXG5mdW5jdGlvbiBscmdiMnJnYih4KSB7XG4gIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuXG5mdW5jdGlvbiByZ2IybHJnYih4KSB7XG4gIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuXG5mdW5jdGlvbiBoY2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBuZXcgSGNsKG8uaCwgby5jLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBMYWIpKSBvID0gbGFiQ29udmVydChvKTtcbiAgaWYgKG8uYSA9PT0gMCAmJiBvLmIgPT09IDApIHJldHVybiBuZXcgSGNsKE5hTiwgMCA8IG8ubCAmJiBvLmwgPCAxMDAgPyAwIDogTmFOLCBvLmwsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiBkZWdyZWVzO1xuICByZXR1cm4gbmV3IEhjbChoIDwgMCA/IGggKyAzNjAgOiBoLCBNYXRoLnNxcnQoby5hICogby5hICsgby5iICogby5iKSwgby5sLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGNoKGwsIGMsIGgsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGwpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQoaCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLmMgPSArYztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5mdW5jdGlvbiBoY2wybGFiKG8pIHtcbiAgaWYgKGlzTmFOKG8uaCkpIHJldHVybiBuZXcgTGFiKG8ubCwgMCwgMCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBvLmggKiByYWRpYW5zO1xuICByZXR1cm4gbmV3IExhYihvLmwsIE1hdGguY29zKGgpICogby5jLCBNYXRoLnNpbihoKSAqIG8uYywgby5vcGFjaXR5KTtcbn1cblxuZGVmaW5lKEhjbCwgaGNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaGNsMmxhYih0aGlzKS5yZ2IoKTtcbiAgfVxufSkpO1xuIiwiZXhwb3J0IGNvbnN0IHJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0IGNvbnN0IGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuIiwiaW1wb3J0IERlbGF1bmF0b3IgZnJvbSBcImRlbGF1bmF0b3JcIjtcbmltcG9ydCBQYXRoIGZyb20gXCIuL3BhdGguanNcIjtcbmltcG9ydCBQb2x5Z29uIGZyb20gXCIuL3BvbHlnb24uanNcIjtcbmltcG9ydCBWb3Jvbm9pIGZyb20gXCIuL3Zvcm9ub2kuanNcIjtcblxuY29uc3QgdGF1ID0gMiAqIE1hdGguUEksIHBvdyA9IE1hdGgucG93O1xuXG5mdW5jdGlvbiBwb2ludFgocCkge1xuICByZXR1cm4gcFswXTtcbn1cblxuZnVuY3Rpb24gcG9pbnRZKHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG5cbi8vIEEgdHJpYW5ndWxhdGlvbiBpcyBjb2xsaW5lYXIgaWYgYWxsIGl0cyB0cmlhbmdsZXMgaGF2ZSBhIG5vbi1udWxsIGFyZWFcbmZ1bmN0aW9uIGNvbGxpbmVhcihkKSB7XG4gIGNvbnN0IHt0cmlhbmdsZXMsIGNvb3Jkc30gPSBkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNvbnN0IGEgPSAyICogdHJpYW5nbGVzW2ldLFxuICAgICAgICAgIGIgPSAyICogdHJpYW5nbGVzW2kgKyAxXSxcbiAgICAgICAgICBjID0gMiAqIHRyaWFuZ2xlc1tpICsgMl0sXG4gICAgICAgICAgY3Jvc3MgPSAoY29vcmRzW2NdIC0gY29vcmRzW2FdKSAqIChjb29yZHNbYiArIDFdIC0gY29vcmRzW2EgKyAxXSlcbiAgICAgICAgICAgICAgICAtIChjb29yZHNbYl0gLSBjb29yZHNbYV0pICogKGNvb3Jkc1tjICsgMV0gLSBjb29yZHNbYSArIDFdKTtcbiAgICBpZiAoY3Jvc3MgPiAxZS0xMCkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBqaXR0ZXIoeCwgeSwgcikge1xuICByZXR1cm4gW3ggKyBNYXRoLnNpbih4ICsgeSkgKiByLCB5ICsgTWF0aC5jb3MoeCAtIHkpICogcl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlbGF1bmF5IHtcbiAgc3RhdGljIGZyb20ocG9pbnRzLCBmeCA9IHBvaW50WCwgZnkgPSBwb2ludFksIHRoYXQpIHtcbiAgICByZXR1cm4gbmV3IERlbGF1bmF5KFwibGVuZ3RoXCIgaW4gcG9pbnRzXG4gICAgICAgID8gZmxhdEFycmF5KHBvaW50cywgZngsIGZ5LCB0aGF0KVxuICAgICAgICA6IEZsb2F0NjRBcnJheS5mcm9tKGZsYXRJdGVyYWJsZShwb2ludHMsIGZ4LCBmeSwgdGhhdCkpKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihwb2ludHMpIHtcbiAgICB0aGlzLl9kZWxhdW5hdG9yID0gbmV3IERlbGF1bmF0b3IocG9pbnRzKTtcbiAgICB0aGlzLmluZWRnZXMgPSBuZXcgSW50MzJBcnJheShwb2ludHMubGVuZ3RoIC8gMik7XG4gICAgdGhpcy5faHVsbEluZGV4ID0gbmV3IEludDMyQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgIHRoaXMucG9pbnRzID0gdGhpcy5fZGVsYXVuYXRvci5jb29yZHM7XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9kZWxhdW5hdG9yLnVwZGF0ZSgpO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCBkID0gdGhpcy5fZGVsYXVuYXRvciwgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cbiAgICAvLyBjaGVjayBmb3IgY29sbGluZWFyXG4gICAgaWYgKGQuaHVsbCAmJiBkLmh1bGwubGVuZ3RoID4gMiAmJiBjb2xsaW5lYXIoZCkpIHtcbiAgICAgIHRoaXMuY29sbGluZWFyID0gSW50MzJBcnJheS5mcm9tKHtsZW5ndGg6IHBvaW50cy5sZW5ndGgvMn0sIChfLGkpID0+IGkpXG4gICAgICAgIC5zb3J0KChpLCBqKSA9PiBwb2ludHNbMiAqIGldIC0gcG9pbnRzWzIgKiBqXSB8fCBwb2ludHNbMiAqIGkgKyAxXSAtIHBvaW50c1syICogaiArIDFdKTsgLy8gZm9yIGV4YWN0IG5laWdoYm9yc1xuICAgICAgY29uc3QgZSA9IHRoaXMuY29sbGluZWFyWzBdLCBmID0gdGhpcy5jb2xsaW5lYXJbdGhpcy5jb2xsaW5lYXIubGVuZ3RoIC0gMV0sXG4gICAgICAgIGJvdW5kcyA9IFsgcG9pbnRzWzIgKiBlXSwgcG9pbnRzWzIgKiBlICsgMV0sIHBvaW50c1syICogZl0sIHBvaW50c1syICogZiArIDFdIF0sXG4gICAgICAgIHIgPSAxZS04ICogTWF0aC5oeXBvdChib3VuZHNbM10gLSBib3VuZHNbMV0sIGJvdW5kc1syXSAtIGJvdW5kc1swXSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGggLyAyOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHAgPSBqaXR0ZXIocG9pbnRzWzIgKiBpXSwgcG9pbnRzWzIgKiBpICsgMV0sIHIpO1xuICAgICAgICBwb2ludHNbMiAqIGldID0gcFswXTtcbiAgICAgICAgcG9pbnRzWzIgKiBpICsgMV0gPSBwWzFdO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGVsYXVuYXRvciA9IG5ldyBEZWxhdW5hdG9yKHBvaW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbGxpbmVhcjtcbiAgICB9XG5cbiAgICBjb25zdCBoYWxmZWRnZXMgPSB0aGlzLmhhbGZlZGdlcyA9IHRoaXMuX2RlbGF1bmF0b3IuaGFsZmVkZ2VzO1xuICAgIGNvbnN0IGh1bGwgPSB0aGlzLmh1bGwgPSB0aGlzLl9kZWxhdW5hdG9yLmh1bGw7XG4gICAgY29uc3QgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMgPSB0aGlzLl9kZWxhdW5hdG9yLnRyaWFuZ2xlcztcbiAgICBjb25zdCBpbmVkZ2VzID0gdGhpcy5pbmVkZ2VzLmZpbGwoLTEpO1xuICAgIGNvbnN0IGh1bGxJbmRleCA9IHRoaXMuX2h1bGxJbmRleC5maWxsKC0xKTtcblxuICAgIC8vIENvbXB1dGUgYW4gaW5kZXggZnJvbSBlYWNoIHBvaW50IHRvIGFuIChhcmJpdHJhcnkpIGluY29taW5nIGhhbGZlZGdlXG4gICAgLy8gVXNlZCB0byBnaXZlIHRoZSBmaXJzdCBuZWlnaGJvciBvZiBlYWNoIHBvaW50OyBmb3IgdGhpcyByZWFzb24sXG4gICAgLy8gb24gdGhlIGh1bGwgd2UgZ2l2ZSBwcmlvcml0eSB0byBleHRlcmlvciBoYWxmZWRnZXNcbiAgICBmb3IgKGxldCBlID0gMCwgbiA9IGhhbGZlZGdlcy5sZW5ndGg7IGUgPCBuOyArK2UpIHtcbiAgICAgIGNvbnN0IHAgPSB0cmlhbmdsZXNbZSAlIDMgPT09IDIgPyBlIC0gMiA6IGUgKyAxXTtcbiAgICAgIGlmIChoYWxmZWRnZXNbZV0gPT09IC0xIHx8IGluZWRnZXNbcF0gPT09IC0xKSBpbmVkZ2VzW3BdID0gZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBodWxsLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgaHVsbEluZGV4W2h1bGxbaV1dID0gaTtcbiAgICB9XG5cbiAgICAvLyBkZWdlbmVyYXRlIGNhc2U6IDEgb3IgMiAoZGlzdGluY3QpIHBvaW50c1xuICAgIGlmIChodWxsLmxlbmd0aCA8PSAyICYmIGh1bGwubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy50cmlhbmdsZXMgPSBuZXcgSW50MzJBcnJheSgzKS5maWxsKC0xKTtcbiAgICAgIHRoaXMuaGFsZmVkZ2VzID0gbmV3IEludDMyQXJyYXkoMykuZmlsbCgtMSk7XG4gICAgICB0aGlzLnRyaWFuZ2xlc1swXSA9IGh1bGxbMF07XG4gICAgICB0aGlzLnRyaWFuZ2xlc1sxXSA9IGh1bGxbMV07XG4gICAgICB0aGlzLnRyaWFuZ2xlc1syXSA9IGh1bGxbMV07XG4gICAgICBpbmVkZ2VzW2h1bGxbMF1dID0gMTtcbiAgICAgIGlmIChodWxsLmxlbmd0aCA9PT0gMikgaW5lZGdlc1todWxsWzFdXSA9IDA7XG4gICAgfVxuICB9XG4gIHZvcm9ub2koYm91bmRzKSB7XG4gICAgcmV0dXJuIG5ldyBWb3Jvbm9pKHRoaXMsIGJvdW5kcyk7XG4gIH1cbiAgKm5laWdoYm9ycyhpKSB7XG4gICAgY29uc3Qge2luZWRnZXMsIGh1bGwsIF9odWxsSW5kZXgsIGhhbGZlZGdlcywgdHJpYW5nbGVzLCBjb2xsaW5lYXJ9ID0gdGhpcztcblxuICAgIC8vIGRlZ2VuZXJhdGUgY2FzZSB3aXRoIHNldmVyYWwgY29sbGluZWFyIHBvaW50c1xuICAgIGlmIChjb2xsaW5lYXIpIHtcbiAgICAgIGNvbnN0IGwgPSBjb2xsaW5lYXIuaW5kZXhPZihpKTtcbiAgICAgIGlmIChsID4gMCkgeWllbGQgY29sbGluZWFyW2wgLSAxXTtcbiAgICAgIGlmIChsIDwgY29sbGluZWFyLmxlbmd0aCAtIDEpIHlpZWxkIGNvbGxpbmVhcltsICsgMV07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZTAgPSBpbmVkZ2VzW2ldO1xuICAgIGlmIChlMCA9PT0gLTEpIHJldHVybjsgLy8gY29pbmNpZGVudCBwb2ludFxuICAgIGxldCBlID0gZTAsIHAwID0gLTE7XG4gICAgZG8ge1xuICAgICAgeWllbGQgcDAgPSB0cmlhbmdsZXNbZV07XG4gICAgICBlID0gZSAlIDMgPT09IDIgPyBlIC0gMiA6IGUgKyAxO1xuICAgICAgaWYgKHRyaWFuZ2xlc1tlXSAhPT0gaSkgcmV0dXJuOyAvLyBiYWQgdHJpYW5ndWxhdGlvblxuICAgICAgZSA9IGhhbGZlZGdlc1tlXTtcbiAgICAgIGlmIChlID09PSAtMSkge1xuICAgICAgICBjb25zdCBwID0gaHVsbFsoX2h1bGxJbmRleFtpXSArIDEpICUgaHVsbC5sZW5ndGhdO1xuICAgICAgICBpZiAocCAhPT0gcDApIHlpZWxkIHA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChlICE9PSBlMCk7XG4gIH1cbiAgZmluZCh4LCB5LCBpID0gMCkge1xuICAgIGlmICgoeCA9ICt4LCB4ICE9PSB4KSB8fCAoeSA9ICt5LCB5ICE9PSB5KSkgcmV0dXJuIC0xO1xuICAgIGNvbnN0IGkwID0gaTtcbiAgICBsZXQgYztcbiAgICB3aGlsZSAoKGMgPSB0aGlzLl9zdGVwKGksIHgsIHkpKSA+PSAwICYmIGMgIT09IGkgJiYgYyAhPT0gaTApIGkgPSBjO1xuICAgIHJldHVybiBjO1xuICB9XG4gIF9zdGVwKGksIHgsIHkpIHtcbiAgICBjb25zdCB7aW5lZGdlcywgaHVsbCwgX2h1bGxJbmRleCwgaGFsZmVkZ2VzLCB0cmlhbmdsZXMsIHBvaW50c30gPSB0aGlzO1xuICAgIGlmIChpbmVkZ2VzW2ldID09PSAtMSB8fCAhcG9pbnRzLmxlbmd0aCkgcmV0dXJuIChpICsgMSkgJSAocG9pbnRzLmxlbmd0aCA+PiAxKTtcbiAgICBsZXQgYyA9IGk7XG4gICAgbGV0IGRjID0gcG93KHggLSBwb2ludHNbaSAqIDJdLCAyKSArIHBvdyh5IC0gcG9pbnRzW2kgKiAyICsgMV0sIDIpO1xuICAgIGNvbnN0IGUwID0gaW5lZGdlc1tpXTtcbiAgICBsZXQgZSA9IGUwO1xuICAgIGRvIHtcbiAgICAgIGxldCB0ID0gdHJpYW5nbGVzW2VdO1xuICAgICAgY29uc3QgZHQgPSBwb3coeCAtIHBvaW50c1t0ICogMl0sIDIpICsgcG93KHkgLSBwb2ludHNbdCAqIDIgKyAxXSwgMik7XG4gICAgICBpZiAoZHQgPCBkYykgZGMgPSBkdCwgYyA9IHQ7XG4gICAgICBlID0gZSAlIDMgPT09IDIgPyBlIC0gMiA6IGUgKyAxO1xuICAgICAgaWYgKHRyaWFuZ2xlc1tlXSAhPT0gaSkgYnJlYWs7IC8vIGJhZCB0cmlhbmd1bGF0aW9uXG4gICAgICBlID0gaGFsZmVkZ2VzW2VdO1xuICAgICAgaWYgKGUgPT09IC0xKSB7XG4gICAgICAgIGUgPSBodWxsWyhfaHVsbEluZGV4W2ldICsgMSkgJSBodWxsLmxlbmd0aF07XG4gICAgICAgIGlmIChlICE9PSB0KSB7XG4gICAgICAgICAgaWYgKHBvdyh4IC0gcG9pbnRzW2UgKiAyXSwgMikgKyBwb3coeSAtIHBvaW50c1tlICogMiArIDFdLCAyKSA8IGRjKSByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChlICE9PSBlMCk7XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgcmVuZGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBjb250ZXh0ID09IG51bGwgPyBjb250ZXh0ID0gbmV3IFBhdGggOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qge3BvaW50cywgaGFsZmVkZ2VzLCB0cmlhbmdsZXN9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGhhbGZlZGdlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGogPSBoYWxmZWRnZXNbaV07XG4gICAgICBpZiAoaiA8IGkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGkgPSB0cmlhbmdsZXNbaV0gKiAyO1xuICAgICAgY29uc3QgdGogPSB0cmlhbmdsZXNbal0gKiAyO1xuICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzW3RpXSwgcG9pbnRzW3RpICsgMV0pO1xuICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW3RqXSwgcG9pbnRzW3RqICsgMV0pO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlckh1bGwoY29udGV4dCk7XG4gICAgcmV0dXJuIGJ1ZmZlciAmJiBidWZmZXIudmFsdWUoKTtcbiAgfVxuICByZW5kZXJQb2ludHMoY29udGV4dCwgciA9IDIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBjb250ZXh0ID09IG51bGwgPyBjb250ZXh0ID0gbmV3IFBhdGggOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qge3BvaW50c30gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHBvaW50c1tpXSwgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4ICsgciwgeSk7XG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCByLCAwLCB0YXUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyICYmIGJ1ZmZlci52YWx1ZSgpO1xuICB9XG4gIHJlbmRlckh1bGwoY29udGV4dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQgPT0gbnVsbCA/IGNvbnRleHQgPSBuZXcgUGF0aCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7aHVsbCwgcG9pbnRzfSA9IHRoaXM7XG4gICAgY29uc3QgaCA9IGh1bGxbMF0gKiAyLCBuID0gaHVsbC5sZW5ndGg7XG4gICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzW2hdLCBwb2ludHNbaCArIDFdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgaCA9IDIgKiBodWxsW2ldO1xuICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2hdLCBwb2ludHNbaCArIDFdKTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm4gYnVmZmVyICYmIGJ1ZmZlci52YWx1ZSgpO1xuICB9XG4gIGh1bGxQb2x5Z29uKCkge1xuICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbjtcbiAgICB0aGlzLnJlbmRlckh1bGwocG9seWdvbik7XG4gICAgcmV0dXJuIHBvbHlnb24udmFsdWUoKTtcbiAgfVxuICByZW5kZXJUcmlhbmdsZShpLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYnVmZmVyID0gY29udGV4dCA9PSBudWxsID8gY29udGV4dCA9IG5ldyBQYXRoIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHtwb2ludHMsIHRyaWFuZ2xlc30gPSB0aGlzO1xuICAgIGNvbnN0IHQwID0gdHJpYW5nbGVzW2kgKj0gM10gKiAyO1xuICAgIGNvbnN0IHQxID0gdHJpYW5nbGVzW2kgKyAxXSAqIDI7XG4gICAgY29uc3QgdDIgPSB0cmlhbmdsZXNbaSArIDJdICogMjtcbiAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbdDBdLCBwb2ludHNbdDAgKyAxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocG9pbnRzW3QxXSwgcG9pbnRzW3QxICsgMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHBvaW50c1t0Ml0sIHBvaW50c1t0MiArIDFdKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHJldHVybiBidWZmZXIgJiYgYnVmZmVyLnZhbHVlKCk7XG4gIH1cbiAgKnRyaWFuZ2xlUG9seWdvbnMoKSB7XG4gICAgY29uc3Qge3RyaWFuZ2xlc30gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gdHJpYW5nbGVzLmxlbmd0aCAvIDM7IGkgPCBuOyArK2kpIHtcbiAgICAgIHlpZWxkIHRoaXMudHJpYW5nbGVQb2x5Z29uKGkpO1xuICAgIH1cbiAgfVxuICB0cmlhbmdsZVBvbHlnb24oaSkge1xuICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbjtcbiAgICB0aGlzLnJlbmRlclRyaWFuZ2xlKGksIHBvbHlnb24pO1xuICAgIHJldHVybiBwb2x5Z29uLnZhbHVlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdEFycmF5KHBvaW50cywgZngsIGZ5LCB0aGF0KSB7XG4gIGNvbnN0IG4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBhcnJheSA9IG5ldyBGbG9hdDY0QXJyYXkobiAqIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IHAgPSBwb2ludHNbaV07XG4gICAgYXJyYXlbaSAqIDJdID0gZnguY2FsbCh0aGF0LCBwLCBpLCBwb2ludHMpO1xuICAgIGFycmF5W2kgKiAyICsgMV0gPSBmeS5jYWxsKHRoYXQsIHAsIGksIHBvaW50cyk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiogZmxhdEl0ZXJhYmxlKHBvaW50cywgZngsIGZ5LCB0aGF0KSB7XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCBwIG9mIHBvaW50cykge1xuICAgIHlpZWxkIGZ4LmNhbGwodGhhdCwgcCwgaSwgcG9pbnRzKTtcbiAgICB5aWVsZCBmeS5jYWxsKHRoYXQsIHAsIGksIHBvaW50cyk7XG4gICAgKytpO1xuICB9XG59XG4iLCJjb25zdCBlcHNpbG9uID0gMWUtNjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICAgIHRoaXMuXyA9IFwiXCI7XG4gIH1cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSAreH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfVxuICBsaW5lVG8oeCwgeSkge1xuICAgIHRoaXMuXyArPSBgTCR7dGhpcy5feDEgPSAreH0sJHt0aGlzLl95MSA9ICt5fWA7XG4gIH1cbiAgYXJjKHgsIHksIHIpIHtcbiAgICB4ID0gK3gsIHkgPSAreSwgciA9ICtyO1xuICAgIGNvbnN0IHgwID0geCArIHI7XG4gICAgY29uc3QgeTAgPSB5O1xuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzXCIpO1xuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkgdGhpcy5fICs9IGBNJHt4MH0sJHt5MH1gO1xuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0geDApID4gZXBzaWxvbiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHkwKSA+IGVwc2lsb24pIHRoaXMuXyArPSBcIkxcIiArIHgwICsgXCIsXCIgKyB5MDtcbiAgICBpZiAoIXIpIHJldHVybjtcbiAgICB0aGlzLl8gKz0gYEEke3J9LCR7cn0sMCwxLDEsJHt4IC0gcn0sJHt5fUEke3J9LCR7cn0sMCwxLDEsJHt0aGlzLl94MSA9IHgwfSwke3RoaXMuX3kxID0geTB9YDtcbiAgfVxuICByZWN0KHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl8gKz0gYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSAreH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK3l9aCR7K3d9diR7K2h9aCR7LXd9WmA7XG4gIH1cbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuXyB8fCBudWxsO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fID0gW107XG4gIH1cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLl8ucHVzaChbeCwgeV0pO1xuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICB0aGlzLl8ucHVzaCh0aGlzLl9bMF0uc2xpY2UoKSk7XG4gIH1cbiAgbGluZVRvKHgsIHkpIHtcbiAgICB0aGlzLl8ucHVzaChbeCwgeV0pO1xuICB9XG4gIHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl8ubGVuZ3RoID8gdGhpcy5fIDogbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IFBhdGggZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IFBvbHlnb24gZnJvbSBcIi4vcG9seWdvbi5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWb3Jvbm9pIHtcbiAgY29uc3RydWN0b3IoZGVsYXVuYXksIFt4bWluLCB5bWluLCB4bWF4LCB5bWF4XSA9IFswLCAwLCA5NjAsIDUwMF0pIHtcbiAgICBpZiAoISgoeG1heCA9ICt4bWF4KSA+PSAoeG1pbiA9ICt4bWluKSkgfHwgISgoeW1heCA9ICt5bWF4KSA+PSAoeW1pbiA9ICt5bWluKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm91bmRzXCIpO1xuICAgIHRoaXMuZGVsYXVuYXkgPSBkZWxhdW5heTtcbiAgICB0aGlzLl9jaXJjdW1jZW50ZXJzID0gbmV3IEZsb2F0NjRBcnJheShkZWxhdW5heS5wb2ludHMubGVuZ3RoICogMik7XG4gICAgdGhpcy52ZWN0b3JzID0gbmV3IEZsb2F0NjRBcnJheShkZWxhdW5heS5wb2ludHMubGVuZ3RoICogMik7XG4gICAgdGhpcy54bWF4ID0geG1heCwgdGhpcy54bWluID0geG1pbjtcbiAgICB0aGlzLnltYXggPSB5bWF4LCB0aGlzLnltaW4gPSB5bWluO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5kZWxhdW5heS51cGRhdGUoKTtcbiAgICB0aGlzLl9pbml0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgY29uc3Qge2RlbGF1bmF5OiB7cG9pbnRzLCBodWxsLCB0cmlhbmdsZXN9LCB2ZWN0b3JzfSA9IHRoaXM7XG5cbiAgICAvLyBDb21wdXRlIGNpcmN1bWNlbnRlcnMuXG4gICAgY29uc3QgY2lyY3VtY2VudGVycyA9IHRoaXMuY2lyY3VtY2VudGVycyA9IHRoaXMuX2NpcmN1bWNlbnRlcnMuc3ViYXJyYXkoMCwgdHJpYW5nbGVzLmxlbmd0aCAvIDMgKiAyKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDAsIG4gPSB0cmlhbmdsZXMubGVuZ3RoLCB4LCB5OyBpIDwgbjsgaSArPSAzLCBqICs9IDIpIHtcbiAgICAgIGNvbnN0IHQxID0gdHJpYW5nbGVzW2ldICogMjtcbiAgICAgIGNvbnN0IHQyID0gdHJpYW5nbGVzW2kgKyAxXSAqIDI7XG4gICAgICBjb25zdCB0MyA9IHRyaWFuZ2xlc1tpICsgMl0gKiAyO1xuICAgICAgY29uc3QgeDEgPSBwb2ludHNbdDFdO1xuICAgICAgY29uc3QgeTEgPSBwb2ludHNbdDEgKyAxXTtcbiAgICAgIGNvbnN0IHgyID0gcG9pbnRzW3QyXTtcbiAgICAgIGNvbnN0IHkyID0gcG9pbnRzW3QyICsgMV07XG4gICAgICBjb25zdCB4MyA9IHBvaW50c1t0M107XG4gICAgICBjb25zdCB5MyA9IHBvaW50c1t0MyArIDFdO1xuXG4gICAgICBjb25zdCBkeCA9IHgyIC0geDE7XG4gICAgICBjb25zdCBkeSA9IHkyIC0geTE7XG4gICAgICBjb25zdCBleCA9IHgzIC0geDE7XG4gICAgICBjb25zdCBleSA9IHkzIC0geTE7XG4gICAgICBjb25zdCBibCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgY29uc3QgY2wgPSBleCAqIGV4ICsgZXkgKiBleTtcbiAgICAgIGNvbnN0IGFiID0gKGR4ICogZXkgLSBkeSAqIGV4KSAqIDI7XG5cbiAgICAgIGlmICghYWIpIHtcbiAgICAgICAgLy8gZGVnZW5lcmF0ZSBjYXNlIChjb2xsaW5lYXIgZGlhZ3JhbSlcbiAgICAgICAgeCA9ICh4MSArIHgzKSAvIDIgLSAxZTggKiBleTtcbiAgICAgICAgeSA9ICh5MSArIHkzKSAvIDIgKyAxZTggKiBleDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGFiKSA8IDFlLTgpIHtcbiAgICAgICAgLy8gYWxtb3N0IGVxdWFsIHBvaW50cyAoZGVnZW5lcmF0ZSB0cmlhbmdsZSlcbiAgICAgICAgeCA9ICh4MSArIHgzKSAvIDI7XG4gICAgICAgIHkgPSAoeTEgKyB5MykgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZCA9IDEgLyBhYjtcbiAgICAgICAgeCA9IHgxICsgKGV5ICogYmwgLSBkeSAqIGNsKSAqIGQ7XG4gICAgICAgIHkgPSB5MSArIChkeCAqIGNsIC0gZXggKiBibCkgKiBkO1xuICAgICAgfVxuICAgICAgY2lyY3VtY2VudGVyc1tqXSA9IHg7XG4gICAgICBjaXJjdW1jZW50ZXJzW2ogKyAxXSA9IHk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBleHRlcmlvciBjZWxsIHJheXMuXG4gICAgbGV0IGggPSBodWxsW2h1bGwubGVuZ3RoIC0gMV07XG4gICAgbGV0IHAwLCBwMSA9IGggKiA0O1xuICAgIGxldCB4MCwgeDEgPSBwb2ludHNbMiAqIGhdO1xuICAgIGxldCB5MCwgeTEgPSBwb2ludHNbMiAqIGggKyAxXTtcbiAgICB2ZWN0b3JzLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsLmxlbmd0aDsgKytpKSB7XG4gICAgICBoID0gaHVsbFtpXTtcbiAgICAgIHAwID0gcDEsIHgwID0geDEsIHkwID0geTE7XG4gICAgICBwMSA9IGggKiA0LCB4MSA9IHBvaW50c1syICogaF0sIHkxID0gcG9pbnRzWzIgKiBoICsgMV07XG4gICAgICB2ZWN0b3JzW3AwICsgMl0gPSB2ZWN0b3JzW3AxXSA9IHkwIC0geTE7XG4gICAgICB2ZWN0b3JzW3AwICsgM10gPSB2ZWN0b3JzW3AxICsgMV0gPSB4MSAtIHgwO1xuICAgIH1cbiAgfVxuICByZW5kZXIoY29udGV4dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQgPT0gbnVsbCA/IGNvbnRleHQgPSBuZXcgUGF0aCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7ZGVsYXVuYXk6IHtoYWxmZWRnZXMsIGluZWRnZXMsIGh1bGx9LCBjaXJjdW1jZW50ZXJzLCB2ZWN0b3JzfSA9IHRoaXM7XG4gICAgaWYgKGh1bGwubGVuZ3RoIDw9IDEpIHJldHVybiBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gaGFsZmVkZ2VzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgaiA9IGhhbGZlZGdlc1tpXTtcbiAgICAgIGlmIChqIDwgaSkgY29udGludWU7XG4gICAgICBjb25zdCB0aSA9IE1hdGguZmxvb3IoaSAvIDMpICogMjtcbiAgICAgIGNvbnN0IHRqID0gTWF0aC5mbG9vcihqIC8gMykgKiAyO1xuICAgICAgY29uc3QgeGkgPSBjaXJjdW1jZW50ZXJzW3RpXTtcbiAgICAgIGNvbnN0IHlpID0gY2lyY3VtY2VudGVyc1t0aSArIDFdO1xuICAgICAgY29uc3QgeGogPSBjaXJjdW1jZW50ZXJzW3RqXTtcbiAgICAgIGNvbnN0IHlqID0gY2lyY3VtY2VudGVyc1t0aiArIDFdO1xuICAgICAgdGhpcy5fcmVuZGVyU2VnbWVudCh4aSwgeWksIHhqLCB5aiwgY29udGV4dCk7XG4gICAgfVxuICAgIGxldCBoMCwgaDEgPSBodWxsW2h1bGwubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsLmxlbmd0aDsgKytpKSB7XG4gICAgICBoMCA9IGgxLCBoMSA9IGh1bGxbaV07XG4gICAgICBjb25zdCB0ID0gTWF0aC5mbG9vcihpbmVkZ2VzW2gxXSAvIDMpICogMjtcbiAgICAgIGNvbnN0IHggPSBjaXJjdW1jZW50ZXJzW3RdO1xuICAgICAgY29uc3QgeSA9IGNpcmN1bWNlbnRlcnNbdCArIDFdO1xuICAgICAgY29uc3QgdiA9IGgwICogNDtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLl9wcm9qZWN0KHgsIHksIHZlY3RvcnNbdiArIDJdLCB2ZWN0b3JzW3YgKyAzXSk7XG4gICAgICBpZiAocCkgdGhpcy5fcmVuZGVyU2VnbWVudCh4LCB5LCBwWzBdLCBwWzFdLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlciAmJiBidWZmZXIudmFsdWUoKTtcbiAgfVxuICByZW5kZXJCb3VuZHMoY29udGV4dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQgPT0gbnVsbCA/IGNvbnRleHQgPSBuZXcgUGF0aCA6IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0LnJlY3QodGhpcy54bWluLCB0aGlzLnltaW4sIHRoaXMueG1heCAtIHRoaXMueG1pbiwgdGhpcy55bWF4IC0gdGhpcy55bWluKTtcbiAgICByZXR1cm4gYnVmZmVyICYmIGJ1ZmZlci52YWx1ZSgpO1xuICB9XG4gIHJlbmRlckNlbGwoaSwgY29udGV4dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQgPT0gbnVsbCA/IGNvbnRleHQgPSBuZXcgUGF0aCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jbGlwKGkpO1xuICAgIGlmIChwb2ludHMgPT09IG51bGwgfHwgIXBvaW50cy5sZW5ndGgpIHJldHVybjtcbiAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgbGV0IG4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHdoaWxlIChwb2ludHNbMF0gPT09IHBvaW50c1tuLTJdICYmIHBvaW50c1sxXSA9PT0gcG9pbnRzW24tMV0gJiYgbiA+IDEpIG4gLT0gMjtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IG47IGkgKz0gMikge1xuICAgICAgaWYgKHBvaW50c1tpXSAhPT0gcG9pbnRzW2ktMl0gfHwgcG9pbnRzW2krMV0gIT09IHBvaW50c1tpLTFdKVxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHJldHVybiBidWZmZXIgJiYgYnVmZmVyLnZhbHVlKCk7XG4gIH1cbiAgKmNlbGxQb2x5Z29ucygpIHtcbiAgICBjb25zdCB7ZGVsYXVuYXk6IHtwb2ludHN9fSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoIC8gMjsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY2VsbFBvbHlnb24oaSk7XG4gICAgICBpZiAoY2VsbCkgY2VsbC5pbmRleCA9IGksIHlpZWxkIGNlbGw7XG4gICAgfVxuICB9XG4gIGNlbGxQb2x5Z29uKGkpIHtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb247XG4gICAgdGhpcy5yZW5kZXJDZWxsKGksIHBvbHlnb24pO1xuICAgIHJldHVybiBwb2x5Z29uLnZhbHVlKCk7XG4gIH1cbiAgX3JlbmRlclNlZ21lbnQoeDAsIHkwLCB4MSwgeTEsIGNvbnRleHQpIHtcbiAgICBsZXQgUztcbiAgICBjb25zdCBjMCA9IHRoaXMuX3JlZ2lvbmNvZGUoeDAsIHkwKTtcbiAgICBjb25zdCBjMSA9IHRoaXMuX3JlZ2lvbmNvZGUoeDEsIHkxKTtcbiAgICBpZiAoYzAgPT09IDAgJiYgYzEgPT09IDApIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgIH0gZWxzZSBpZiAoUyA9IHRoaXMuX2NsaXBTZWdtZW50KHgwLCB5MCwgeDEsIHkxLCBjMCwgYzEpKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhTWzBdLCBTWzFdKTtcbiAgICAgIGNvbnRleHQubGluZVRvKFNbMl0sIFNbM10pO1xuICAgIH1cbiAgfVxuICBjb250YWlucyhpLCB4LCB5KSB7XG4gICAgaWYgKCh4ID0gK3gsIHggIT09IHgpIHx8ICh5ID0gK3ksIHkgIT09IHkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXVuYXkuX3N0ZXAoaSwgeCwgeSkgPT09IGk7XG4gIH1cbiAgKm5laWdoYm9ycyhpKSB7XG4gICAgY29uc3QgY2kgPSB0aGlzLl9jbGlwKGkpO1xuICAgIGlmIChjaSkgZm9yIChjb25zdCBqIG9mIHRoaXMuZGVsYXVuYXkubmVpZ2hib3JzKGkpKSB7XG4gICAgICBjb25zdCBjaiA9IHRoaXMuX2NsaXAoaik7XG4gICAgICAvLyBmaW5kIHRoZSBjb21tb24gZWRnZVxuICAgICAgaWYgKGNqKSBsb29wOiBmb3IgKGxldCBhaSA9IDAsIGxpID0gY2kubGVuZ3RoOyBhaSA8IGxpOyBhaSArPSAyKSB7XG4gICAgICAgIGZvciAobGV0IGFqID0gMCwgbGogPSBjai5sZW5ndGg7IGFqIDwgbGo7IGFqICs9IDIpIHtcbiAgICAgICAgICBpZiAoY2lbYWldID09IGNqW2FqXVxuICAgICAgICAgICYmIGNpW2FpICsgMV0gPT0gY2pbYWogKyAxXVxuICAgICAgICAgICYmIGNpWyhhaSArIDIpICUgbGldID09IGNqWyhhaiArIGxqIC0gMikgJSBsal1cbiAgICAgICAgICAmJiBjaVsoYWkgKyAzKSAlIGxpXSA9PSBjalsoYWogKyBsaiAtIDEpICUgbGpdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB5aWVsZCBqO1xuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NlbGwoaSkge1xuICAgIGNvbnN0IHtjaXJjdW1jZW50ZXJzLCBkZWxhdW5heToge2luZWRnZXMsIGhhbGZlZGdlcywgdHJpYW5nbGVzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGUwID0gaW5lZGdlc1tpXTtcbiAgICBpZiAoZTAgPT09IC0xKSByZXR1cm4gbnVsbDsgLy8gY29pbmNpZGVudCBwb2ludFxuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGxldCBlID0gZTA7XG4gICAgZG8ge1xuICAgICAgY29uc3QgdCA9IE1hdGguZmxvb3IoZSAvIDMpO1xuICAgICAgcG9pbnRzLnB1c2goY2lyY3VtY2VudGVyc1t0ICogMl0sIGNpcmN1bWNlbnRlcnNbdCAqIDIgKyAxXSk7XG4gICAgICBlID0gZSAlIDMgPT09IDIgPyBlIC0gMiA6IGUgKyAxO1xuICAgICAgaWYgKHRyaWFuZ2xlc1tlXSAhPT0gaSkgYnJlYWs7IC8vIGJhZCB0cmlhbmd1bGF0aW9uXG4gICAgICBlID0gaGFsZmVkZ2VzW2VdO1xuICAgIH0gd2hpbGUgKGUgIT09IGUwICYmIGUgIT09IC0xKTtcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gIF9jbGlwKGkpIHtcbiAgICAvLyBkZWdlbmVyYXRlIGNhc2UgKDEgdmFsaWQgcG9pbnQ6IHJldHVybiB0aGUgYm94KVxuICAgIGlmIChpID09PSAwICYmIHRoaXMuZGVsYXVuYXkuaHVsbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBbdGhpcy54bWF4LCB0aGlzLnltaW4sIHRoaXMueG1heCwgdGhpcy55bWF4LCB0aGlzLnhtaW4sIHRoaXMueW1heCwgdGhpcy54bWluLCB0aGlzLnltaW5dO1xuICAgIH1cbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jZWxsKGkpO1xuICAgIGlmIChwb2ludHMgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHt2ZWN0b3JzOiBWfSA9IHRoaXM7XG4gICAgY29uc3QgdiA9IGkgKiA0O1xuICAgIHJldHVybiBWW3ZdIHx8IFZbdiArIDFdXG4gICAgICAgID8gdGhpcy5fY2xpcEluZmluaXRlKGksIHBvaW50cywgVlt2XSwgVlt2ICsgMV0sIFZbdiArIDJdLCBWW3YgKyAzXSlcbiAgICAgICAgOiB0aGlzLl9jbGlwRmluaXRlKGksIHBvaW50cyk7XG4gIH1cbiAgX2NsaXBGaW5pdGUoaSwgcG9pbnRzKSB7XG4gICAgY29uc3QgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IFAgPSBudWxsO1xuICAgIGxldCB4MCwgeTAsIHgxID0gcG9pbnRzW24gLSAyXSwgeTEgPSBwb2ludHNbbiAtIDFdO1xuICAgIGxldCBjMCwgYzEgPSB0aGlzLl9yZWdpb25jb2RlKHgxLCB5MSk7XG4gICAgbGV0IGUwLCBlMTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47IGogKz0gMikge1xuICAgICAgeDAgPSB4MSwgeTAgPSB5MSwgeDEgPSBwb2ludHNbal0sIHkxID0gcG9pbnRzW2ogKyAxXTtcbiAgICAgIGMwID0gYzEsIGMxID0gdGhpcy5fcmVnaW9uY29kZSh4MSwgeTEpO1xuICAgICAgaWYgKGMwID09PSAwICYmIGMxID09PSAwKSB7XG4gICAgICAgIGUwID0gZTEsIGUxID0gMDtcbiAgICAgICAgaWYgKFApIFAucHVzaCh4MSwgeTEpO1xuICAgICAgICBlbHNlIFAgPSBbeDEsIHkxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBTLCBzeDAsIHN5MCwgc3gxLCBzeTE7XG4gICAgICAgIGlmIChjMCA9PT0gMCkge1xuICAgICAgICAgIGlmICgoUyA9IHRoaXMuX2NsaXBTZWdtZW50KHgwLCB5MCwgeDEsIHkxLCBjMCwgYzEpKSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgW3N4MCwgc3kwLCBzeDEsIHN5MV0gPSBTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoUyA9IHRoaXMuX2NsaXBTZWdtZW50KHgxLCB5MSwgeDAsIHkwLCBjMSwgYzApKSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgW3N4MSwgc3kxLCBzeDAsIHN5MF0gPSBTO1xuICAgICAgICAgIGUwID0gZTEsIGUxID0gdGhpcy5fZWRnZWNvZGUoc3gwLCBzeTApO1xuICAgICAgICAgIGlmIChlMCAmJiBlMSkgdGhpcy5fZWRnZShpLCBlMCwgZTEsIFAsIFAubGVuZ3RoKTtcbiAgICAgICAgICBpZiAoUCkgUC5wdXNoKHN4MCwgc3kwKTtcbiAgICAgICAgICBlbHNlIFAgPSBbc3gwLCBzeTBdO1xuICAgICAgICB9XG4gICAgICAgIGUwID0gZTEsIGUxID0gdGhpcy5fZWRnZWNvZGUoc3gxLCBzeTEpO1xuICAgICAgICBpZiAoZTAgJiYgZTEpIHRoaXMuX2VkZ2UoaSwgZTAsIGUxLCBQLCBQLmxlbmd0aCk7XG4gICAgICAgIGlmIChQKSBQLnB1c2goc3gxLCBzeTEpO1xuICAgICAgICBlbHNlIFAgPSBbc3gxLCBzeTFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoUCkge1xuICAgICAgZTAgPSBlMSwgZTEgPSB0aGlzLl9lZGdlY29kZShQWzBdLCBQWzFdKTtcbiAgICAgIGlmIChlMCAmJiBlMSkgdGhpcy5fZWRnZShpLCBlMCwgZTEsIFAsIFAubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29udGFpbnMoaSwgKHRoaXMueG1pbiArIHRoaXMueG1heCkgLyAyLCAodGhpcy55bWluICsgdGhpcy55bWF4KSAvIDIpKSB7XG4gICAgICByZXR1cm4gW3RoaXMueG1heCwgdGhpcy55bWluLCB0aGlzLnhtYXgsIHRoaXMueW1heCwgdGhpcy54bWluLCB0aGlzLnltYXgsIHRoaXMueG1pbiwgdGhpcy55bWluXTtcbiAgICB9XG4gICAgcmV0dXJuIFA7XG4gIH1cbiAgX2NsaXBTZWdtZW50KHgwLCB5MCwgeDEsIHkxLCBjMCwgYzEpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGMwID09PSAwICYmIGMxID09PSAwKSByZXR1cm4gW3gwLCB5MCwgeDEsIHkxXTtcbiAgICAgIGlmIChjMCAmIGMxKSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCB4LCB5LCBjID0gYzAgfHwgYzE7XG4gICAgICBpZiAoYyAmIDBiMTAwMCkgeCA9IHgwICsgKHgxIC0geDApICogKHRoaXMueW1heCAtIHkwKSAvICh5MSAtIHkwKSwgeSA9IHRoaXMueW1heDtcbiAgICAgIGVsc2UgaWYgKGMgJiAwYjAxMDApIHggPSB4MCArICh4MSAtIHgwKSAqICh0aGlzLnltaW4gLSB5MCkgLyAoeTEgLSB5MCksIHkgPSB0aGlzLnltaW47XG4gICAgICBlbHNlIGlmIChjICYgMGIwMDEwKSB5ID0geTAgKyAoeTEgLSB5MCkgKiAodGhpcy54bWF4IC0geDApIC8gKHgxIC0geDApLCB4ID0gdGhpcy54bWF4O1xuICAgICAgZWxzZSB5ID0geTAgKyAoeTEgLSB5MCkgKiAodGhpcy54bWluIC0geDApIC8gKHgxIC0geDApLCB4ID0gdGhpcy54bWluO1xuICAgICAgaWYgKGMwKSB4MCA9IHgsIHkwID0geSwgYzAgPSB0aGlzLl9yZWdpb25jb2RlKHgwLCB5MCk7XG4gICAgICBlbHNlIHgxID0geCwgeTEgPSB5LCBjMSA9IHRoaXMuX3JlZ2lvbmNvZGUoeDEsIHkxKTtcbiAgICB9XG4gIH1cbiAgX2NsaXBJbmZpbml0ZShpLCBwb2ludHMsIHZ4MCwgdnkwLCB2eG4sIHZ5bikge1xuICAgIGxldCBQID0gQXJyYXkuZnJvbShwb2ludHMpLCBwO1xuICAgIGlmIChwID0gdGhpcy5fcHJvamVjdChQWzBdLCBQWzFdLCB2eDAsIHZ5MCkpIFAudW5zaGlmdChwWzBdLCBwWzFdKTtcbiAgICBpZiAocCA9IHRoaXMuX3Byb2plY3QoUFtQLmxlbmd0aCAtIDJdLCBQW1AubGVuZ3RoIC0gMV0sIHZ4biwgdnluKSkgUC5wdXNoKHBbMF0sIHBbMV0pO1xuICAgIGlmIChQID0gdGhpcy5fY2xpcEZpbml0ZShpLCBQKSkge1xuICAgICAgZm9yIChsZXQgaiA9IDAsIG4gPSBQLmxlbmd0aCwgYzAsIGMxID0gdGhpcy5fZWRnZWNvZGUoUFtuIC0gMl0sIFBbbiAtIDFdKTsgaiA8IG47IGogKz0gMikge1xuICAgICAgICBjMCA9IGMxLCBjMSA9IHRoaXMuX2VkZ2Vjb2RlKFBbal0sIFBbaiArIDFdKTtcbiAgICAgICAgaWYgKGMwICYmIGMxKSBqID0gdGhpcy5fZWRnZShpLCBjMCwgYzEsIFAsIGopLCBuID0gUC5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbnRhaW5zKGksICh0aGlzLnhtaW4gKyB0aGlzLnhtYXgpIC8gMiwgKHRoaXMueW1pbiArIHRoaXMueW1heCkgLyAyKSkge1xuICAgICAgUCA9IFt0aGlzLnhtaW4sIHRoaXMueW1pbiwgdGhpcy54bWF4LCB0aGlzLnltaW4sIHRoaXMueG1heCwgdGhpcy55bWF4LCB0aGlzLnhtaW4sIHRoaXMueW1heF07XG4gICAgfVxuICAgIHJldHVybiBQO1xuICB9XG4gIF9lZGdlKGksIGUwLCBlMSwgUCwgaikge1xuICAgIHdoaWxlIChlMCAhPT0gZTEpIHtcbiAgICAgIGxldCB4LCB5O1xuICAgICAgc3dpdGNoIChlMCkge1xuICAgICAgICBjYXNlIDBiMDEwMTogZTAgPSAwYjAxMDA7IGNvbnRpbnVlOyAvLyB0b3AtbGVmdFxuICAgICAgICBjYXNlIDBiMDEwMDogZTAgPSAwYjAxMTAsIHggPSB0aGlzLnhtYXgsIHkgPSB0aGlzLnltaW47IGJyZWFrOyAvLyB0b3BcbiAgICAgICAgY2FzZSAwYjAxMTA6IGUwID0gMGIwMDEwOyBjb250aW51ZTsgLy8gdG9wLXJpZ2h0XG4gICAgICAgIGNhc2UgMGIwMDEwOiBlMCA9IDBiMTAxMCwgeCA9IHRoaXMueG1heCwgeSA9IHRoaXMueW1heDsgYnJlYWs7IC8vIHJpZ2h0XG4gICAgICAgIGNhc2UgMGIxMDEwOiBlMCA9IDBiMTAwMDsgY29udGludWU7IC8vIGJvdHRvbS1yaWdodFxuICAgICAgICBjYXNlIDBiMTAwMDogZTAgPSAwYjEwMDEsIHggPSB0aGlzLnhtaW4sIHkgPSB0aGlzLnltYXg7IGJyZWFrOyAvLyBib3R0b21cbiAgICAgICAgY2FzZSAwYjEwMDE6IGUwID0gMGIwMDAxOyBjb250aW51ZTsgLy8gYm90dG9tLWxlZnRcbiAgICAgICAgY2FzZSAwYjAwMDE6IGUwID0gMGIwMTAxLCB4ID0gdGhpcy54bWluLCB5ID0gdGhpcy55bWluOyBicmVhazsgLy8gbGVmdFxuICAgICAgfVxuICAgICAgaWYgKChQW2pdICE9PSB4IHx8IFBbaiArIDFdICE9PSB5KSAmJiB0aGlzLmNvbnRhaW5zKGksIHgsIHkpKSB7XG4gICAgICAgIFAuc3BsaWNlKGosIDAsIHgsIHkpLCBqICs9IDI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChQLmxlbmd0aCA+IDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUC5sZW5ndGg7IGkrPSAyKSB7XG4gICAgICAgIGNvbnN0IGogPSAoaSArIDIpICUgUC5sZW5ndGgsIGsgPSAoaSArIDQpICUgUC5sZW5ndGg7XG4gICAgICAgIGlmIChQW2ldID09PSBQW2pdICYmIFBbal0gPT09IFBba11cbiAgICAgICAgfHwgUFtpICsgMV0gPT09IFBbaiArIDFdICYmIFBbaiArIDFdID09PSBQW2sgKyAxXSlcbiAgICAgICAgICBQLnNwbGljZShqLCAyKSwgaSAtPSAyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gajtcbiAgfVxuICBfcHJvamVjdCh4MCwgeTAsIHZ4LCB2eSkge1xuICAgIGxldCB0ID0gSW5maW5pdHksIGMsIHgsIHk7XG4gICAgaWYgKHZ5IDwgMCkgeyAvLyB0b3BcbiAgICAgIGlmICh5MCA8PSB0aGlzLnltaW4pIHJldHVybiBudWxsO1xuICAgICAgaWYgKChjID0gKHRoaXMueW1pbiAtIHkwKSAvIHZ5KSA8IHQpIHkgPSB0aGlzLnltaW4sIHggPSB4MCArICh0ID0gYykgKiB2eDtcbiAgICB9IGVsc2UgaWYgKHZ5ID4gMCkgeyAvLyBib3R0b21cbiAgICAgIGlmICh5MCA+PSB0aGlzLnltYXgpIHJldHVybiBudWxsO1xuICAgICAgaWYgKChjID0gKHRoaXMueW1heCAtIHkwKSAvIHZ5KSA8IHQpIHkgPSB0aGlzLnltYXgsIHggPSB4MCArICh0ID0gYykgKiB2eDtcbiAgICB9XG4gICAgaWYgKHZ4ID4gMCkgeyAvLyByaWdodFxuICAgICAgaWYgKHgwID49IHRoaXMueG1heCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoKGMgPSAodGhpcy54bWF4IC0geDApIC8gdngpIDwgdCkgeCA9IHRoaXMueG1heCwgeSA9IHkwICsgKHQgPSBjKSAqIHZ5O1xuICAgIH0gZWxzZSBpZiAodnggPCAwKSB7IC8vIGxlZnRcbiAgICAgIGlmICh4MCA8PSB0aGlzLnhtaW4pIHJldHVybiBudWxsO1xuICAgICAgaWYgKChjID0gKHRoaXMueG1pbiAtIHgwKSAvIHZ4KSA8IHQpIHggPSB0aGlzLnhtaW4sIHkgPSB5MCArICh0ID0gYykgKiB2eTtcbiAgICB9XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuICBfZWRnZWNvZGUoeCwgeSkge1xuICAgIHJldHVybiAoeCA9PT0gdGhpcy54bWluID8gMGIwMDAxXG4gICAgICAgIDogeCA9PT0gdGhpcy54bWF4ID8gMGIwMDEwIDogMGIwMDAwKVxuICAgICAgICB8ICh5ID09PSB0aGlzLnltaW4gPyAwYjAxMDBcbiAgICAgICAgOiB5ID09PSB0aGlzLnltYXggPyAwYjEwMDAgOiAwYjAwMDApO1xuICB9XG4gIF9yZWdpb25jb2RlKHgsIHkpIHtcbiAgICByZXR1cm4gKHggPCB0aGlzLnhtaW4gPyAwYjAwMDFcbiAgICAgICAgOiB4ID4gdGhpcy54bWF4ID8gMGIwMDEwIDogMGIwMDAwKVxuICAgICAgICB8ICh5IDwgdGhpcy55bWluID8gMGIwMTAwXG4gICAgICAgIDogeSA+IHRoaXMueW1heCA/IDBiMTAwMCA6IDBiMDAwMCk7XG4gIH1cbn1cbiIsInZhciBFT0wgPSB7fSxcbiAgICBFT0YgPSB7fSxcbiAgICBRVU9URSA9IDM0LFxuICAgIE5FV0xJTkUgPSAxMCxcbiAgICBSRVRVUk4gPSAxMztcblxuZnVuY3Rpb24gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpIHtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImRcIiwgXCJyZXR1cm4ge1wiICsgY29sdW1ucy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXSB8fCBcXFwiXFxcIlwiO1xuICB9KS5qb2luKFwiLFwiKSArIFwifVwiKTtcbn1cblxuZnVuY3Rpb24gY3VzdG9tQ29udmVydGVyKGNvbHVtbnMsIGYpIHtcbiAgdmFyIG9iamVjdCA9IG9iamVjdENvbnZlcnRlcihjb2x1bW5zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgIHJldHVybiBmKG9iamVjdChyb3cpLCBpLCBjb2x1bW5zKTtcbiAgfTtcbn1cblxuLy8gQ29tcHV0ZSB1bmlxdWUgY29sdW1ucyBpbiBvcmRlciBvZiBkaXNjb3ZlcnkuXG5mdW5jdGlvbiBpbmZlckNvbHVtbnMocm93cykge1xuICB2YXIgY29sdW1uU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGNvbHVtbnMgPSBbXTtcblxuICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgZm9yICh2YXIgY29sdW1uIGluIHJvdykge1xuICAgICAgaWYgKCEoY29sdW1uIGluIGNvbHVtblNldCkpIHtcbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtblNldFtjb2x1bW5dID0gY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb2x1bW5zO1xufVxuXG5mdW5jdGlvbiBwYWQodmFsdWUsIHdpZHRoKSB7XG4gIHZhciBzID0gdmFsdWUgKyBcIlwiLCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbigwKSArIHMgOiBzO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRZZWFyKHllYXIpIHtcbiAgcmV0dXJuIHllYXIgPCAwID8gXCItXCIgKyBwYWQoLXllYXIsIDYpXG4gICAgOiB5ZWFyID4gOTk5OSA/IFwiK1wiICsgcGFkKHllYXIsIDYpXG4gICAgOiBwYWQoeWVhciwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCksXG4gICAgICBtaW51dGVzID0gZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICBzZWNvbmRzID0gZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgICBtaWxsaXNlY29uZHMgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBcIkludmFsaWQgRGF0ZVwiXG4gICAgICA6IGZvcm1hdFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCA0KSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsIDIpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENEYXRlKCksIDIpXG4gICAgICArIChtaWxsaXNlY29uZHMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiOlwiICsgcGFkKHNlY29uZHMsIDIpICsgXCIuXCIgKyBwYWQobWlsbGlzZWNvbmRzLCAzKSArIFwiWlwiXG4gICAgICA6IHNlY29uZHMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiOlwiICsgcGFkKHNlY29uZHMsIDIpICsgXCJaXCJcbiAgICAgIDogbWludXRlcyB8fCBob3VycyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCJaXCJcbiAgICAgIDogXCJcIik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlbGltaXRlcikge1xuICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKFwiW1xcXCJcIiArIGRlbGltaXRlciArIFwiXFxuXFxyXVwiKSxcbiAgICAgIERFTElNSVRFUiA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHRleHQsIGYpIHtcbiAgICB2YXIgY29udmVydCwgY29sdW1ucywgcm93cyA9IHBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgIGlmIChjb252ZXJ0KSByZXR1cm4gY29udmVydChyb3csIGkgLSAxKTtcbiAgICAgIGNvbHVtbnMgPSByb3csIGNvbnZlcnQgPSBmID8gY3VzdG9tQ29udmVydGVyKHJvdywgZikgOiBvYmplY3RDb252ZXJ0ZXIocm93KTtcbiAgICB9KTtcbiAgICByb3dzLmNvbHVtbnMgPSBjb2x1bW5zIHx8IFtdO1xuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSb3dzKHRleHQsIGYpIHtcbiAgICB2YXIgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICBOID0gdGV4dC5sZW5ndGgsXG4gICAgICAgIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICBuID0gMCwgLy8gY3VycmVudCBsaW5lIG51bWJlclxuICAgICAgICB0LCAvLyBjdXJyZW50IHRva2VuXG4gICAgICAgIGVvZiA9IE4gPD0gMCwgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0Y/XG4gICAgICAgIGVvbCA9IGZhbHNlOyAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPTD9cblxuICAgIC8vIFN0cmlwIHRoZSB0cmFpbGluZyBuZXdsaW5lLlxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBORVdMSU5FKSAtLU47XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IFJFVFVSTikgLS1OO1xuXG4gICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICBpZiAoZW9mKSByZXR1cm4gRU9GO1xuICAgICAgaWYgKGVvbCkgcmV0dXJuIGVvbCA9IGZhbHNlLCBFT0w7XG5cbiAgICAgIC8vIFVuZXNjYXBlIHF1b3Rlcy5cbiAgICAgIHZhciBpLCBqID0gSSwgYztcbiAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IFFVT1RFKSB7XG4gICAgICAgIHdoaWxlIChJKysgPCBOICYmIHRleHQuY2hhckNvZGVBdChJKSAhPT0gUVVPVEUgfHwgdGV4dC5jaGFyQ29kZUF0KCsrSSkgPT09IFFVT1RFKTtcbiAgICAgICAgaWYgKChpID0gSSkgPj0gTikgZW9mID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkgLSAxKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGRlbGltaXRlciBvciBuZXdsaW5lLlxuICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChpID0gSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gREVMSU1JVEVSKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBsYXN0IHRva2VuIGJlZm9yZSBFT0YuXG4gICAgICByZXR1cm4gZW9mID0gdHJ1ZSwgdGV4dC5zbGljZShqLCBOKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICB2YXIgcm93ID0gW107XG4gICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikgcm93LnB1c2godCksIHQgPSB0b2tlbigpO1xuICAgICAgaWYgKGYgJiYgKHJvdyA9IGYocm93LCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgIH1cblxuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2NvbHVtbl0pO1xuICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBbY29sdW1ucy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3dzKHJvd3MpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xuICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIlxuICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGZvcm1hdERhdGUodmFsdWUpXG4gICAgICAgIDogcmVGb3JtYXQudGVzdCh2YWx1ZSArPSBcIlwiKSA/IFwiXFxcIlwiICsgdmFsdWUucmVwbGFjZSgvXCIvZywgXCJcXFwiXFxcIlwiKSArIFwiXFxcIlwiXG4gICAgICAgIDogdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBwYXJzZVJvd3M6IHBhcnNlUm93cyxcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXRCb2R5OiBmb3JtYXRCb2R5LFxuICAgIGZvcm1hdFJvd3M6IGZvcm1hdFJvd3MsXG4gICAgZm9ybWF0Um93OiBmb3JtYXRSb3csXG4gICAgZm9ybWF0VmFsdWU6IGZvcm1hdFZhbHVlXG4gIH07XG59XG4iLCJpbXBvcnQgZm9ybWF0TG9jYWxlIGZyb20gXCIuL2xvY2FsZS5qc1wiO1xuXG52YXIgbG9jYWxlO1xuZXhwb3J0IHZhciBmb3JtYXQ7XG5leHBvcnQgdmFyIGZvcm1hdFByZWZpeDtcblxuZGVmYXVsdExvY2FsZSh7XG4gIHRob3VzYW5kczogXCIsXCIsXG4gIGdyb3VwaW5nOiBbM10sXG4gIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZm9ybWF0UHJlZml4ID0gbG9jYWxlLmZvcm1hdFByZWZpeDtcbiAgcmV0dXJuIGxvY2FsZTtcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsUGFydHMoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggPSBNYXRoLnJvdW5kKHgpKSA+PSAxZTIxXG4gICAgICA/IHgudG9Mb2NhbGVTdHJpbmcoXCJlblwiKS5yZXBsYWNlKC8sL2csIFwiXCIpXG4gICAgICA6IHgudG9TdHJpbmcoMTApO1xufVxuXG4vLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4vLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbi8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsUGFydHMoMS4yMykgcmV0dXJucyBbXCIxMjNcIiwgMF0uXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApIHtcbiAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XG4gIHZhciBpLCBjb2VmZmljaWVudCA9IHguc2xpY2UoMCwgaSk7XG5cbiAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xuICAvLyAoZS5nLiwgMS4yZSszKSBvciB0aGUgZm9ybSBcXGRlWy0rXVxcZCsgKGUuZy4sIDFlKzMpLlxuICByZXR1cm4gW1xuICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXG4gICAgK3guc2xpY2UoaSArIDEpXG4gIF07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihncm91cGluZywgdGhvdXNhbmRzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgdCA9IFtdLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obnVtZXJhbHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBudW1lcmFsc1sraV07XG4gICAgfSk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Zvcm1hdERlY2ltYWxQYXJ0c30gZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuXG5leHBvcnQgdmFyIHByZWZpeEV4cG9uZW50O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsUGFydHMoeCwgTWF0aC5tYXgoMCwgcCArIGkgLSAxKSlbMF07IC8vIGxlc3MgdGhhbiAxeSFcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG59XG4iLCIvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW35dW3R5cGVdXG52YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyh+KT8oW2EteiVdKT8kL2k7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuICB2YXIgbWF0Y2g7XG4gIHJldHVybiBuZXcgRm9ybWF0U3BlY2lmaWVyKHtcbiAgICBmaWxsOiBtYXRjaFsxXSxcbiAgICBhbGlnbjogbWF0Y2hbMl0sXG4gICAgc2lnbjogbWF0Y2hbM10sXG4gICAgc3ltYm9sOiBtYXRjaFs0XSxcbiAgICB6ZXJvOiBtYXRjaFs1XSxcbiAgICB3aWR0aDogbWF0Y2hbNl0sXG4gICAgY29tbWE6IG1hdGNoWzddLFxuICAgIHByZWNpc2lvbjogbWF0Y2hbOF0gJiYgbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgdHJpbTogbWF0Y2hbOV0sXG4gICAgdHlwZTogbWF0Y2hbMTBdXG4gIH0pO1xufVxuXG5mb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlID0gRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZTsgLy8gaW5zdGFuY2VvZlxuXG5leHBvcnQgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICB0aGlzLmZpbGwgPSBzcGVjaWZpZXIuZmlsbCA9PT0gdW5kZWZpbmVkID8gXCIgXCIgOiBzcGVjaWZpZXIuZmlsbCArIFwiXCI7XG4gIHRoaXMuYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24gPT09IHVuZGVmaW5lZCA/IFwiPlwiIDogc3BlY2lmaWVyLmFsaWduICsgXCJcIjtcbiAgdGhpcy5zaWduID0gc3BlY2lmaWVyLnNpZ24gPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogc3BlY2lmaWVyLnNpZ24gKyBcIlwiO1xuICB0aGlzLnN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIuc3ltYm9sICsgXCJcIjtcbiAgdGhpcy56ZXJvID0gISFzcGVjaWZpZXIuemVybztcbiAgdGhpcy53aWR0aCA9IHNwZWNpZmllci53aWR0aCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci53aWR0aDtcbiAgdGhpcy5jb21tYSA9ICEhc3BlY2lmaWVyLmNvbW1hO1xuICB0aGlzLnByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIucHJlY2lzaW9uO1xuICB0aGlzLnRyaW0gPSAhIXNwZWNpZmllci50cmltO1xuICB0aGlzLnR5cGUgPSBzcGVjaWZpZXIudHlwZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci50eXBlICsgXCJcIjtcbn1cblxuRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWxsXG4gICAgICArIHRoaXMuYWxpZ25cbiAgICAgICsgdGhpcy5zaWduXG4gICAgICArIHRoaXMuc3ltYm9sXG4gICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgKyAodGhpcy50cmltID8gXCJ+XCIgOiBcIlwiKVxuICAgICAgKyB0aGlzLnR5cGU7XG59O1xuIiwiLy8gVHJpbXMgaW5zaWduaWZpY2FudCB6ZXJvcywgZS5nLiwgcmVwbGFjZXMgMS4yMDAwayB3aXRoIDEuMmsuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzKSB7XG4gIG91dDogZm9yICh2YXIgbiA9IHMubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKHNbaV0pIHtcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogaWYgKCErc1tpXSkgYnJlYWsgb3V0OyBpZiAoaTAgPiAwKSBpMCA9IDA7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTAgPiAwID8gcy5zbGljZSgwLCBpMCkgKyBzLnNsaWNlKGkxICsgMSkgOiBzO1xufVxuIiwiaW1wb3J0IGZvcm1hdERlY2ltYWwgZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuaW1wb3J0IGZvcm1hdFByZWZpeEF1dG8gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGZvcm1hdFJvdW5kZWQgZnJvbSBcIi4vZm9ybWF0Um91bmRlZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFwiJVwiOiAoeCwgcCkgPT4gKHggKiAxMDApLnRvRml4ZWQocCksXG4gIFwiYlwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKSxcbiAgXCJjXCI6ICh4KSA9PiB4ICsgXCJcIixcbiAgXCJkXCI6IGZvcm1hdERlY2ltYWwsXG4gIFwiZVwiOiAoeCwgcCkgPT4geC50b0V4cG9uZW50aWFsKHApLFxuICBcImZcIjogKHgsIHApID0+IHgudG9GaXhlZChwKSxcbiAgXCJnXCI6ICh4LCBwKSA9PiB4LnRvUHJlY2lzaW9uKHApLFxuICBcIm9cIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCksXG4gIFwicFwiOiAoeCwgcCkgPT4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKSxcbiAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gIFwic1wiOiBmb3JtYXRQcmVmaXhBdXRvLFxuICBcIlhcIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksXG4gIFwieFwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNilcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5pbXBvcnQgZm9ybWF0R3JvdXAgZnJvbSBcIi4vZm9ybWF0R3JvdXAuanNcIjtcbmltcG9ydCBmb3JtYXROdW1lcmFscyBmcm9tIFwiLi9mb3JtYXROdW1lcmFscy5qc1wiO1xuaW1wb3J0IGZvcm1hdFNwZWNpZmllciBmcm9tIFwiLi9mb3JtYXRTcGVjaWZpZXIuanNcIjtcbmltcG9ydCBmb3JtYXRUcmltIGZyb20gXCIuL2Zvcm1hdFRyaW0uanNcIjtcbmltcG9ydCBmb3JtYXRUeXBlcyBmcm9tIFwiLi9mb3JtYXRUeXBlcy5qc1wiO1xuaW1wb3J0IHtwcmVmaXhFeHBvbmVudH0gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5LmpzXCI7XG5cbnZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLFxuICAgIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obG9jYWxlKSB7XG4gIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyA9PT0gdW5kZWZpbmVkIHx8IGxvY2FsZS50aG91c2FuZHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0R3JvdXAobWFwLmNhbGwobG9jYWxlLmdyb3VwaW5nLCBOdW1iZXIpLCBsb2NhbGUudGhvdXNhbmRzICsgXCJcIiksXG4gICAgICBjdXJyZW5jeVByZWZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVswXSArIFwiXCIsXG4gICAgICBjdXJyZW5jeVN1ZmZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVsxXSArIFwiXCIsXG4gICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwgPT09IHVuZGVmaW5lZCA/IFwiLlwiIDogbG9jYWxlLmRlY2ltYWwgKyBcIlwiLFxuICAgICAgbnVtZXJhbHMgPSBsb2NhbGUubnVtZXJhbHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0TnVtZXJhbHMobWFwLmNhbGwobG9jYWxlLm51bWVyYWxzLCBTdHJpbmcpKSxcbiAgICAgIHBlcmNlbnQgPSBsb2NhbGUucGVyY2VudCA9PT0gdW5kZWZpbmVkID8gXCIlXCIgOiBsb2NhbGUucGVyY2VudCArIFwiXCIsXG4gICAgICBtaW51cyA9IGxvY2FsZS5taW51cyA9PT0gdW5kZWZpbmVkID8gXCLiiJJcIiA6IGxvY2FsZS5taW51cyArIFwiXCIsXG4gICAgICBuYW4gPSBsb2NhbGUubmFuID09PSB1bmRlZmluZWQgPyBcIk5hTlwiIDogbG9jYWxlLm5hbiArIFwiXCI7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllcikge1xuICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuXG4gICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgIHNpZ24gPSBzcGVjaWZpZXIuc2lnbixcbiAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICB3aWR0aCA9IHNwZWNpZmllci53aWR0aCxcbiAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgIHRyaW0gPSBzcGVjaWZpZXIudHJpbSxcbiAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gVGhlIFwiXCIgdHlwZSwgYW5kIGFueSBpbnZhbGlkIHR5cGUsIGlzIGFuIGFsaWFzIGZvciBcIi4xMn5nXCIuXG4gICAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCAmJiAocHJlY2lzaW9uID0gMTIpLCB0cmltID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5UHJlZml4IDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lTdWZmaXggOiAvWyVwXS8udGVzdCh0eXBlKSA/IHBlcmNlbnQgOiBcIlwiO1xuXG4gICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgIG1heWJlU3VmZml4ID0gL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNlxuICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeCxcbiAgICAgICAgICBpLCBuLCBjO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpZ24uIC0wIGlzIG5vdCBsZXNzIHRoYW4gMCwgYnV0IDEgLyAtMCBpcyFcbiAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSB2YWx1ZSA8IDAgfHwgMSAvIHZhbHVlIDwgMDtcblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgIHZhbHVlID0gaXNOYU4odmFsdWUpID8gbmFuIDogZm9ybWF0VHlwZShNYXRoLmFicyh2YWx1ZSksIHByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gVHJpbSBpbnNpZ25pZmljYW50IHplcm9zLlxuICAgICAgICBpZiAodHJpbSkgdmFsdWUgPSBmb3JtYXRUcmltKHZhbHVlKTtcblxuICAgICAgICAvLyBJZiBhIG5lZ2F0aXZlIHZhbHVlIHJvdW5kcyB0byB6ZXJvIGFmdGVyIGZvcm1hdHRpbmcsIGFuZCBubyBleHBsaWNpdCBwb3NpdGl2ZSBzaWduIGlzIHJlcXVlc3RlZCwgaGlkZSB0aGUgc2lnbi5cbiAgICAgICAgaWYgKHZhbHVlTmVnYXRpdmUgJiYgK3ZhbHVlID09PSAwICYmIHNpZ24gIT09IFwiK1wiKSB2YWx1ZU5lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogbWludXMpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgdmFsdWVTdWZmaXggPSAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgdmFsdWVTdWZmaXggKyAodmFsdWVOZWdhdGl2ZSAmJiBzaWduID09PSBcIihcIiA/IFwiKVwiIDogXCJcIik7XG5cbiAgICAgICAgLy8gQnJlYWsgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBpbnRlZ2VyIOKAnHZhbHVl4oCdIHBhcnQgdGhhdCBjYW4gYmVcbiAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgIGlmIChtYXliZVN1ZmZpeCkge1xuICAgICAgICAgIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gKGMgPT09IDQ2ID8gZGVjaW1hbCArIHZhbHVlLnNsaWNlKGkgKyAxKSA6IHZhbHVlLnNsaWNlKGkpKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIG5vdCBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBiZWZvcmUgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwYWRkaW5nLlxuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlUHJlZml4Lmxlbmd0aCArIHZhbHVlLmxlbmd0aCArIHZhbHVlU3VmZml4Lmxlbmd0aCxcbiAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGFmdGVyIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgemVybykgdmFsdWUgPSBncm91cChwYWRkaW5nICsgdmFsdWUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSB2YWx1ZVN1ZmZpeC5sZW5ndGggOiBJbmZpbml0eSksIHBhZGRpbmcgPSBcIlwiO1xuXG4gICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSBcIjxcIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nOyBicmVhaztcbiAgICAgICAgY2FzZSBcIj1cIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgICAgY2FzZSBcIl5cIjogdmFsdWUgPSBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdmFsdWUgPSBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bWVyYWxzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3JtYXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcGVjaWZpZXIgKyBcIlwiO1xuICAgIH07XG5cbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpIHtcbiAgICB2YXIgZiA9IG5ld0Zvcm1hdCgoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciksIHNwZWNpZmllci50eXBlID0gXCJmXCIsIHNwZWNpZmllcikpLFxuICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxuICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1s4ICsgZSAvIDNdO1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IG5ld0Zvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICB9O1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0ZXApIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0ZXAsIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RlcCwgbWF4KSB7XG4gIHN0ZXAgPSBNYXRoLmFicyhzdGVwKSwgbWF4ID0gTWF0aC5hYnMobWF4KSAtIHN0ZXA7XG4gIHJldHVybiBNYXRoLm1heCgwLCBleHBvbmVudChtYXgpIC0gZXhwb25lbnQoc3RlcCkpICsgMTtcbn1cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHthdGFuMiwgY29zLCBxdWFydGVyUGksIHJhZGlhbnMsIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi9ub29wLmpzXCI7XG5pbXBvcnQgc3RyZWFtIGZyb20gXCIuL3N0cmVhbS5qc1wiO1xuXG5leHBvcnQgdmFyIGFyZWFSaW5nU3VtID0gbmV3IEFkZGVyKCk7XG5cbi8vIGhlbGxvP1xuXG52YXIgYXJlYVN1bSA9IG5ldyBBZGRlcigpLFxuICAgIGxhbWJkYTAwLFxuICAgIHBoaTAwLFxuICAgIGxhbWJkYTAsXG4gICAgY29zUGhpMCxcbiAgICBzaW5QaGkwO1xuXG5leHBvcnQgdmFyIGFyZWFTdHJlYW0gPSB7XG4gIHBvaW50OiBub29wLFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVJpbmdTdW0gPSBuZXcgQWRkZXIoKTtcbiAgICBhcmVhU3RyZWFtLmxpbmVTdGFydCA9IGFyZWFSaW5nU3RhcnQ7XG4gICAgYXJlYVN0cmVhbS5saW5lRW5kID0gYXJlYVJpbmdFbmQ7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmVhUmluZyA9ICthcmVhUmluZ1N1bTtcbiAgICBhcmVhU3VtLmFkZChhcmVhUmluZyA8IDAgPyB0YXUgKyBhcmVhUmluZyA6IGFyZWFSaW5nKTtcbiAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMubGluZUVuZCA9IHRoaXMucG9pbnQgPSBub29wO1xuICB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdW0uYWRkKHRhdSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFyZWFSaW5nU3RhcnQoKSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gYXJlYVJpbmdFbmQoKSB7XG4gIGFyZWFQb2ludChsYW1iZGEwMCwgcGhpMDApO1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50O1xuICBsYW1iZGEwMCA9IGxhbWJkYSwgcGhpMDAgPSBwaGk7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgbGFtYmRhMCA9IGxhbWJkYSwgY29zUGhpMCA9IGNvcyhwaGkgPSBwaGkgLyAyICsgcXVhcnRlclBpKSwgc2luUGhpMCA9IHNpbihwaGkpO1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICBwaGkgPSBwaGkgLyAyICsgcXVhcnRlclBpOyAvLyBoYWxmIHRoZSBhbmd1bGFyIGRpc3RhbmNlIGZyb20gc291dGggcG9sZVxuXG4gIC8vIFNwaGVyaWNhbCBleGNlc3MgRSBmb3IgYSBzcGhlcmljYWwgdHJpYW5nbGUgd2l0aCB2ZXJ0aWNlczogc291dGggcG9sZSxcbiAgLy8gcHJldmlvdXMgcG9pbnQsIGN1cnJlbnQgcG9pbnQuICBVc2VzIGEgZm9ybXVsYSBkZXJpdmVkIGZyb20gQ2Fnbm9saeKAmXNcbiAgLy8gdGhlb3JlbS4gIFNlZSBUb2RodW50ZXIsIFNwaGVyaWNhbCBUcmlnLiAoMTg3MSksIFNlYy4gMTAzLCBFcS4gKDIpLlxuICB2YXIgZExhbWJkYSA9IGxhbWJkYSAtIGxhbWJkYTAsXG4gICAgICBzZExhbWJkYSA9IGRMYW1iZGEgPj0gMCA/IDEgOiAtMSxcbiAgICAgIGFkTGFtYmRhID0gc2RMYW1iZGEgKiBkTGFtYmRhLFxuICAgICAgY29zUGhpID0gY29zKHBoaSksXG4gICAgICBzaW5QaGkgPSBzaW4ocGhpKSxcbiAgICAgIGsgPSBzaW5QaGkwICogc2luUGhpLFxuICAgICAgdSA9IGNvc1BoaTAgKiBjb3NQaGkgKyBrICogY29zKGFkTGFtYmRhKSxcbiAgICAgIHYgPSBrICogc2RMYW1iZGEgKiBzaW4oYWRMYW1iZGEpO1xuICBhcmVhUmluZ1N1bS5hZGQoYXRhbjIodiwgdSkpO1xuXG4gIC8vIEFkdmFuY2UgdGhlIHByZXZpb3VzIHBvaW50cy5cbiAgbGFtYmRhMCA9IGxhbWJkYSwgY29zUGhpMCA9IGNvc1BoaSwgc2luUGhpMCA9IHNpblBoaTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGFyZWFTdW0gPSBuZXcgQWRkZXIoKTtcbiAgc3RyZWFtKG9iamVjdCwgYXJlYVN0cmVhbSk7XG4gIHJldHVybiBhcmVhU3VtICogMjtcbn1cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHthcmVhU3RyZWFtLCBhcmVhUmluZ1N1bX0gZnJvbSBcIi4vYXJlYS5qc1wiO1xuaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbkNyb3NzLCBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlLCBzcGhlcmljYWx9IGZyb20gXCIuL2NhcnRlc2lhbi5qc1wiO1xuaW1wb3J0IHthYnMsIGRlZ3JlZXMsIGVwc2lsb24sIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcbmltcG9ydCBzdHJlYW0gZnJvbSBcIi4vc3RyZWFtLmpzXCI7XG5cbnZhciBsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxLCAvLyBib3VuZHNcbiAgICBsYW1iZGEyLCAvLyBwcmV2aW91cyBsYW1iZGEtY29vcmRpbmF0ZVxuICAgIGxhbWJkYTAwLCBwaGkwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICBwMCwgLy8gcHJldmlvdXMgM0QgcG9pbnRcbiAgICBkZWx0YVN1bSxcbiAgICByYW5nZXMsXG4gICAgcmFuZ2U7XG5cbnZhciBib3VuZHNTdHJlYW0gPSB7XG4gIHBvaW50OiBib3VuZHNQb2ludCxcbiAgbGluZVN0YXJ0OiBib3VuZHNMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IGJvdW5kc0xpbmVFbmQsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUmluZ1BvaW50O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lU3RhcnQgPSBib3VuZHNSaW5nU3RhcnQ7XG4gICAgYm91bmRzU3RyZWFtLmxpbmVFbmQgPSBib3VuZHNSaW5nRW5kO1xuICAgIGRlbHRhU3VtID0gbmV3IEFkZGVyKCk7XG4gICAgYXJlYVN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUG9pbnQ7XG4gICAgYm91bmRzU3RyZWFtLmxpbmVTdGFydCA9IGJvdW5kc0xpbmVTdGFydDtcbiAgICBib3VuZHNTdHJlYW0ubGluZUVuZCA9IGJvdW5kc0xpbmVFbmQ7XG4gICAgaWYgKGFyZWFSaW5nU3VtIDwgMCkgbGFtYmRhMCA9IC0obGFtYmRhMSA9IDE4MCksIHBoaTAgPSAtKHBoaTEgPSA5MCk7XG4gICAgZWxzZSBpZiAoZGVsdGFTdW0gPiBlcHNpbG9uKSBwaGkxID0gOTA7XG4gICAgZWxzZSBpZiAoZGVsdGFTdW0gPCAtZXBzaWxvbikgcGhpMCA9IC05MDtcbiAgICByYW5nZVswXSA9IGxhbWJkYTAsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgfSxcbiAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICBsYW1iZGEwID0gLShsYW1iZGExID0gMTgwKSwgcGhpMCA9IC0ocGhpMSA9IDkwKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYm91bmRzUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgcmFuZ2VzLnB1c2gocmFuZ2UgPSBbbGFtYmRhMCA9IGxhbWJkYSwgbGFtYmRhMSA9IGxhbWJkYV0pO1xuICBpZiAocGhpIDwgcGhpMCkgcGhpMCA9IHBoaTtcbiAgaWYgKHBoaSA+IHBoaTEpIHBoaTEgPSBwaGk7XG59XG5cbmZ1bmN0aW9uIGxpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICB2YXIgcCA9IGNhcnRlc2lhbihbbGFtYmRhICogcmFkaWFucywgcGhpICogcmFkaWFuc10pO1xuICBpZiAocDApIHtcbiAgICB2YXIgbm9ybWFsID0gY2FydGVzaWFuQ3Jvc3MocDAsIHApLFxuICAgICAgICBlcXVhdG9yaWFsID0gW25vcm1hbFsxXSwgLW5vcm1hbFswXSwgMF0sXG4gICAgICAgIGluZmxlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhlcXVhdG9yaWFsLCBub3JtYWwpO1xuICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW5mbGVjdGlvbik7XG4gICAgaW5mbGVjdGlvbiA9IHNwaGVyaWNhbChpbmZsZWN0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBsYW1iZGEgLSBsYW1iZGEyLFxuICAgICAgICBzaWduID0gZGVsdGEgPiAwID8gMSA6IC0xLFxuICAgICAgICBsYW1iZGFpID0gaW5mbGVjdGlvblswXSAqIGRlZ3JlZXMgKiBzaWduLFxuICAgICAgICBwaGlpLFxuICAgICAgICBhbnRpbWVyaWRpYW4gPSBhYnMoZGVsdGEpID4gMTgwO1xuICAgIGlmIChhbnRpbWVyaWRpYW4gXiAoc2lnbiAqIGxhbWJkYTIgPCBsYW1iZGFpICYmIGxhbWJkYWkgPCBzaWduICogbGFtYmRhKSkge1xuICAgICAgcGhpaSA9IGluZmxlY3Rpb25bMV0gKiBkZWdyZWVzO1xuICAgICAgaWYgKHBoaWkgPiBwaGkxKSBwaGkxID0gcGhpaTtcbiAgICB9IGVsc2UgaWYgKGxhbWJkYWkgPSAobGFtYmRhaSArIDM2MCkgJSAzNjAgLSAxODAsIGFudGltZXJpZGlhbiBeIChzaWduICogbGFtYmRhMiA8IGxhbWJkYWkgJiYgbGFtYmRhaSA8IHNpZ24gKiBsYW1iZGEpKSB7XG4gICAgICBwaGlpID0gLWluZmxlY3Rpb25bMV0gKiBkZWdyZWVzO1xuICAgICAgaWYgKHBoaWkgPCBwaGkwKSBwaGkwID0gcGhpaTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBoaSA8IHBoaTApIHBoaTAgPSBwaGk7XG4gICAgICBpZiAocGhpID4gcGhpMSkgcGhpMSA9IHBoaTtcbiAgICB9XG4gICAgaWYgKGFudGltZXJpZGlhbikge1xuICAgICAgaWYgKGxhbWJkYSA8IGxhbWJkYTIpIHtcbiAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYTAsIGxhbWJkYSkgPiBhbmdsZShsYW1iZGEwLCBsYW1iZGExKSkgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhbmdsZShsYW1iZGEsIGxhbWJkYTEpID4gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkpIGxhbWJkYTAgPSBsYW1iZGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsYW1iZGExID49IGxhbWJkYTApIHtcbiAgICAgICAgaWYgKGxhbWJkYSA8IGxhbWJkYTApIGxhbWJkYTAgPSBsYW1iZGE7XG4gICAgICAgIGlmIChsYW1iZGEgPiBsYW1iZGExKSBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxhbWJkYSA+IGxhbWJkYTIpIHtcbiAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhMCwgbGFtYmRhKSA+IGFuZ2xlKGxhbWJkYTAsIGxhbWJkYTEpKSBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEsIGxhbWJkYTEpID4gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkpIGxhbWJkYTAgPSBsYW1iZGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmFuZ2VzLnB1c2gocmFuZ2UgPSBbbGFtYmRhMCA9IGxhbWJkYSwgbGFtYmRhMSA9IGxhbWJkYV0pO1xuICB9XG4gIGlmIChwaGkgPCBwaGkwKSBwaGkwID0gcGhpO1xuICBpZiAocGhpID4gcGhpMSkgcGhpMSA9IHBoaTtcbiAgcDAgPSBwLCBsYW1iZGEyID0gbGFtYmRhO1xufVxuXG5mdW5jdGlvbiBib3VuZHNMaW5lU3RhcnQoKSB7XG4gIGJvdW5kc1N0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbn1cblxuZnVuY3Rpb24gYm91bmRzTGluZUVuZCgpIHtcbiAgcmFuZ2VbMF0gPSBsYW1iZGEwLCByYW5nZVsxXSA9IGxhbWJkYTE7XG4gIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1BvaW50O1xuICBwMCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc1JpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICBpZiAocDApIHtcbiAgICB2YXIgZGVsdGEgPSBsYW1iZGEgLSBsYW1iZGEyO1xuICAgIGRlbHRhU3VtLmFkZChhYnMoZGVsdGEpID4gMTgwID8gZGVsdGEgKyAoZGVsdGEgPiAwID8gMzYwIDogLTM2MCkgOiBkZWx0YSk7XG4gIH0gZWxzZSB7XG4gICAgbGFtYmRhMDAgPSBsYW1iZGEsIHBoaTAwID0gcGhpO1xuICB9XG4gIGFyZWFTdHJlYW0ucG9pbnQobGFtYmRhLCBwaGkpO1xuICBsaW5lUG9pbnQobGFtYmRhLCBwaGkpO1xufVxuXG5mdW5jdGlvbiBib3VuZHNSaW5nU3RhcnQoKSB7XG4gIGFyZWFTdHJlYW0ubGluZVN0YXJ0KCk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc1JpbmdFbmQoKSB7XG4gIGJvdW5kc1JpbmdQb2ludChsYW1iZGEwMCwgcGhpMDApO1xuICBhcmVhU3RyZWFtLmxpbmVFbmQoKTtcbiAgaWYgKGFicyhkZWx0YVN1bSkgPiBlcHNpbG9uKSBsYW1iZGEwID0gLShsYW1iZGExID0gMTgwKTtcbiAgcmFuZ2VbMF0gPSBsYW1iZGEwLCByYW5nZVsxXSA9IGxhbWJkYTE7XG4gIHAwID0gbnVsbDtcbn1cblxuLy8gRmluZHMgdGhlIGxlZnQtcmlnaHQgZGlzdGFuY2UgYmV0d2VlbiB0d28gbG9uZ2l0dWRlcy5cbi8vIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIChsYW1iZGExIC0gbGFtYmRhMCArIDM2MMKwKSAlIDM2MMKwLCBleGNlcHQgdGhhdCB3ZSB3YW50XG4vLyB0aGUgZGlzdGFuY2UgYmV0d2VlbiDCsTE4MMKwIHRvIGJlIDM2MMKwLlxuZnVuY3Rpb24gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkge1xuICByZXR1cm4gKGxhbWJkYTEgLT0gbGFtYmRhMCkgPCAwID8gbGFtYmRhMSArIDM2MCA6IGxhbWJkYTE7XG59XG5cbmZ1bmN0aW9uIHJhbmdlQ29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VDb250YWlucyhyYW5nZSwgeCkge1xuICByZXR1cm4gcmFuZ2VbMF0gPD0gcmFuZ2VbMV0gPyByYW5nZVswXSA8PSB4ICYmIHggPD0gcmFuZ2VbMV0gOiB4IDwgcmFuZ2VbMF0gfHwgcmFuZ2VbMV0gPCB4O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihmZWF0dXJlKSB7XG4gIHZhciBpLCBuLCBhLCBiLCBtZXJnZWQsIGRlbHRhTWF4LCBkZWx0YTtcblxuICBwaGkxID0gbGFtYmRhMSA9IC0obGFtYmRhMCA9IHBoaTAgPSBJbmZpbml0eSk7XG4gIHJhbmdlcyA9IFtdO1xuICBzdHJlYW0oZmVhdHVyZSwgYm91bmRzU3RyZWFtKTtcblxuICAvLyBGaXJzdCwgc29ydCByYW5nZXMgYnkgdGhlaXIgbWluaW11bSBsb25naXR1ZGVzLlxuICBpZiAobiA9IHJhbmdlcy5sZW5ndGgpIHtcbiAgICByYW5nZXMuc29ydChyYW5nZUNvbXBhcmUpO1xuXG4gICAgLy8gVGhlbiwgbWVyZ2UgYW55IHJhbmdlcyB0aGF0IG92ZXJsYXAuXG4gICAgZm9yIChpID0gMSwgYSA9IHJhbmdlc1swXSwgbWVyZ2VkID0gW2FdOyBpIDwgbjsgKytpKSB7XG4gICAgICBiID0gcmFuZ2VzW2ldO1xuICAgICAgaWYgKHJhbmdlQ29udGFpbnMoYSwgYlswXSkgfHwgcmFuZ2VDb250YWlucyhhLCBiWzFdKSkge1xuICAgICAgICBpZiAoYW5nbGUoYVswXSwgYlsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSkgYVsxXSA9IGJbMV07XG4gICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzBdID0gYlswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZC5wdXNoKGEgPSBiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCBmaW5kIHRoZSBsYXJnZXN0IGdhcCBiZXR3ZWVuIHRoZSBtZXJnZWQgcmFuZ2VzLlxuICAgIC8vIFRoZSBmaW5hbCBib3VuZGluZyBib3ggd2lsbCBiZSB0aGUgaW52ZXJzZSBvZiB0aGlzIGdhcC5cbiAgICBmb3IgKGRlbHRhTWF4ID0gLUluZmluaXR5LCBuID0gbWVyZ2VkLmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbWVyZ2VkW25dOyBpIDw9IG47IGEgPSBiLCArK2kpIHtcbiAgICAgIGIgPSBtZXJnZWRbaV07XG4gICAgICBpZiAoKGRlbHRhID0gYW5nbGUoYVsxXSwgYlswXSkpID4gZGVsdGFNYXgpIGRlbHRhTWF4ID0gZGVsdGEsIGxhbWJkYTAgPSBiWzBdLCBsYW1iZGExID0gYVsxXTtcbiAgICB9XG4gIH1cblxuICByYW5nZXMgPSByYW5nZSA9IG51bGw7XG5cbiAgcmV0dXJuIGxhbWJkYTAgPT09IEluZmluaXR5IHx8IHBoaTAgPT09IEluZmluaXR5XG4gICAgICA/IFtbTmFOLCBOYU5dLCBbTmFOLCBOYU5dXVxuICAgICAgOiBbW2xhbWJkYTAsIHBoaTBdLCBbbGFtYmRhMSwgcGhpMV1dO1xufVxuIiwiaW1wb3J0IHthc2luLCBhdGFuMiwgY29zLCBzaW4sIHNxcnR9IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNwaGVyaWNhbChjYXJ0ZXNpYW4pIHtcbiAgcmV0dXJuIFthdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGFzaW4oY2FydGVzaWFuWzJdKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW4oc3BoZXJpY2FsKSB7XG4gIHZhciBsYW1iZGEgPSBzcGhlcmljYWxbMF0sIHBoaSA9IHNwaGVyaWNhbFsxXSwgY29zUGhpID0gY29zKHBoaSk7XG4gIHJldHVybiBbY29zUGhpICogY29zKGxhbWJkYSksIGNvc1BoaSAqIHNpbihsYW1iZGEpLCBzaW4ocGhpKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5Eb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuQ3Jvc3MoYSwgYikge1xuICByZXR1cm4gW2FbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1dO1xufVxuXG4vLyBUT0RPIHJldHVybiBhXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuQWRkSW5QbGFjZShhLCBiKSB7XG4gIGFbMF0gKz0gYlswXSwgYVsxXSArPSBiWzFdLCBhWzJdICs9IGJbMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5TY2FsZSh2ZWN0b3IsIGspIHtcbiAgcmV0dXJuIFt2ZWN0b3JbMF0gKiBrLCB2ZWN0b3JbMV0gKiBrLCB2ZWN0b3JbMl0gKiBrXTtcbn1cblxuLy8gVE9ETyByZXR1cm4gZFxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoZCkge1xuICB2YXIgbCA9IHNxcnQoZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXSArIGRbMl0gKiBkWzJdKTtcbiAgZFswXSAvPSBsLCBkWzFdIC89IGwsIGRbMl0gLz0gbDtcbn1cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHthc2luLCBhdGFuMiwgY29zLCBkZWdyZWVzLCBlcHNpbG9uLCBlcHNpbG9uMiwgaHlwb3QsIHJhZGlhbnMsIHNpbiwgc3FydH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4vbm9vcC5qc1wiO1xuaW1wb3J0IHN0cmVhbSBmcm9tIFwiLi9zdHJlYW0uanNcIjtcblxudmFyIFcwLCBXMSxcbiAgICBYMCwgWTAsIFowLFxuICAgIFgxLCBZMSwgWjEsXG4gICAgWDIsIFkyLCBaMixcbiAgICBsYW1iZGEwMCwgcGhpMDAsIC8vIGZpcnN0IHBvaW50XG4gICAgeDAsIHkwLCB6MDsgLy8gcHJldmlvdXMgcG9pbnRcblxudmFyIGNlbnRyb2lkU3RyZWFtID0ge1xuICBzcGhlcmU6IG5vb3AsXG4gIHBvaW50OiBjZW50cm9pZFBvaW50LFxuICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0LFxuICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZDtcbiAgfVxufTtcblxuLy8gQXJpdGhtZXRpYyBtZWFuIG9mIENhcnRlc2lhbiB2ZWN0b3JzLlxuZnVuY3Rpb24gY2VudHJvaWRQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbihjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludENhcnRlc2lhbih4LCB5LCB6KSB7XG4gICsrVzA7XG4gIFgwICs9ICh4IC0gWDApIC8gVzA7XG4gIFkwICs9ICh5IC0gWTApIC8gVzA7XG4gIFowICs9ICh6IC0gWjApIC8gVzA7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gIHgwID0gY29zUGhpICogY29zKGxhbWJkYSk7XG4gIHkwID0gY29zUGhpICogc2luKGxhbWJkYSk7XG4gIHowID0gc2luKHBoaSk7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnQ7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgeCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpLFxuICAgICAgeSA9IGNvc1BoaSAqIHNpbihsYW1iZGEpLFxuICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgdyA9IGF0YW4yKHNxcnQoKHcgPSB5MCAqIHogLSB6MCAqIHkpICogdyArICh3ID0gejAgKiB4IC0geDAgKiB6KSAqIHcgKyAodyA9IHgwICogeSAtIHkwICogeCkgKiB3KSwgeDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6KTtcbiAgVzEgKz0gdztcbiAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kKCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbi8vIFNlZSBKLiBFLiBCcm9jaywgVGhlIEluZXJ0aWEgVGVuc29yIGZvciBhIFNwaGVyaWNhbCBUcmlhbmdsZSxcbi8vIEouIEFwcGxpZWQgTWVjaGFuaWNzIDQyLCAyMzkgKDE5NzUpLlxuZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kKCkge1xuICBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEwMCwgcGhpMDApO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1BvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhMDAgPSBsYW1iZGEsIHBoaTAwID0gcGhpO1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnQ7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgejAgPSBzaW4ocGhpKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICB4ID0gY29zUGhpICogY29zKGxhbWJkYSksXG4gICAgICB5ID0gY29zUGhpICogc2luKGxhbWJkYSksXG4gICAgICB6ID0gc2luKHBoaSksXG4gICAgICBjeCA9IHkwICogeiAtIHowICogeSxcbiAgICAgIGN5ID0gejAgKiB4IC0geDAgKiB6LFxuICAgICAgY3ogPSB4MCAqIHkgLSB5MCAqIHgsXG4gICAgICBtID0gaHlwb3QoY3gsIGN5LCBjeiksXG4gICAgICB3ID0gYXNpbihtKSwgLy8gbGluZSB3ZWlnaHQgPSBhbmdsZVxuICAgICAgdiA9IG0gJiYgLXcgLyBtOyAvLyBhcmVhIHdlaWdodCBtdWx0aXBsaWVyXG4gIFgyLmFkZCh2ICogY3gpO1xuICBZMi5hZGQodiAqIGN5KTtcbiAgWjIuYWRkKHYgKiBjeik7XG4gIFcxICs9IHc7XG4gIFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gIFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gIFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdCkge1xuICBXMCA9IFcxID1cbiAgWDAgPSBZMCA9IFowID1cbiAgWDEgPSBZMSA9IFoxID0gMDtcbiAgWDIgPSBuZXcgQWRkZXIoKTtcbiAgWTIgPSBuZXcgQWRkZXIoKTtcbiAgWjIgPSBuZXcgQWRkZXIoKTtcbiAgc3RyZWFtKG9iamVjdCwgY2VudHJvaWRTdHJlYW0pO1xuXG4gIHZhciB4ID0gK1gyLFxuICAgICAgeSA9ICtZMixcbiAgICAgIHogPSArWjIsXG4gICAgICBtID0gaHlwb3QoeCwgeSwgeik7XG5cbiAgLy8gSWYgdGhlIGFyZWEtd2VpZ2h0ZWQgY2NlbnRyb2lkIGlzIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIGxlbmd0aC13ZWlnaHRlZCBjY2VudHJvaWQuXG4gIGlmIChtIDwgZXBzaWxvbjIpIHtcbiAgICB4ID0gWDEsIHkgPSBZMSwgeiA9IFoxO1xuICAgIC8vIElmIHRoZSBmZWF0dXJlIGhhcyB6ZXJvIGxlbmd0aCwgZmFsbCBiYWNrIHRvIGFyaXRobWV0aWMgbWVhbiBvZiBwb2ludCB2ZWN0b3JzLlxuICAgIGlmIChXMSA8IGVwc2lsb24pIHggPSBYMCwgeSA9IFkwLCB6ID0gWjA7XG4gICAgbSA9IGh5cG90KHgsIHksIHopO1xuICAgIC8vIElmIHRoZSBmZWF0dXJlIHN0aWxsIGhhcyBhbiB1bmRlZmluZWQgY2NlbnRyb2lkLCB0aGVuIHJldHVybi5cbiAgICBpZiAobSA8IGVwc2lsb24yKSByZXR1cm4gW05hTiwgTmFOXTtcbiAgfVxuXG4gIHJldHVybiBbYXRhbjIoeSwgeCkgKiBkZWdyZWVzLCBhc2luKHogLyBtKSAqIGRlZ3JlZXNdO1xufVxuIiwiaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UsIHNwaGVyaWNhbH0gZnJvbSBcIi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCB7YWNvcywgY29zLCBkZWdyZWVzLCBlcHNpbG9uLCByYWRpYW5zLCBzaW4sIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtyb3RhdGVSYWRpYW5zfSBmcm9tIFwiLi9yb3RhdGlvbi5qc1wiO1xuXG4vLyBHZW5lcmF0ZXMgYSBjaXJjbGUgY2VudGVyZWQgYXQgWzDCsCwgMMKwXSwgd2l0aCBhIGdpdmVuIHJhZGl1cyBhbmQgcHJlY2lzaW9uLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgdDAsIHQxKSB7XG4gIGlmICghZGVsdGEpIHJldHVybjtcbiAgdmFyIGNvc1JhZGl1cyA9IGNvcyhyYWRpdXMpLFxuICAgICAgc2luUmFkaXVzID0gc2luKHJhZGl1cyksXG4gICAgICBzdGVwID0gZGlyZWN0aW9uICogZGVsdGE7XG4gIGlmICh0MCA9PSBudWxsKSB7XG4gICAgdDAgPSByYWRpdXMgKyBkaXJlY3Rpb24gKiB0YXU7XG4gICAgdDEgPSByYWRpdXMgLSBzdGVwIC8gMjtcbiAgfSBlbHNlIHtcbiAgICB0MCA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQwKTtcbiAgICB0MSA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQxKTtcbiAgICBpZiAoZGlyZWN0aW9uID4gMCA/IHQwIDwgdDEgOiB0MCA+IHQxKSB0MCArPSBkaXJlY3Rpb24gKiB0YXU7XG4gIH1cbiAgZm9yICh2YXIgcG9pbnQsIHQgPSB0MDsgZGlyZWN0aW9uID4gMCA/IHQgPiB0MSA6IHQgPCB0MTsgdCAtPSBzdGVwKSB7XG4gICAgcG9pbnQgPSBzcGhlcmljYWwoW2Nvc1JhZGl1cywgLXNpblJhZGl1cyAqIGNvcyh0KSwgLXNpblJhZGl1cyAqIHNpbih0KV0pO1xuICAgIHN0cmVhbS5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICB9XG59XG5cbi8vIFJldHVybnMgdGhlIHNpZ25lZCBhbmdsZSBvZiBhIGNhcnRlc2lhbiBwb2ludCByZWxhdGl2ZSB0byBbY29zUmFkaXVzLCAwLCAwXS5cbmZ1bmN0aW9uIGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHBvaW50KSB7XG4gIHBvaW50ID0gY2FydGVzaWFuKHBvaW50KSwgcG9pbnRbMF0gLT0gY29zUmFkaXVzO1xuICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKHBvaW50KTtcbiAgdmFyIHJhZGl1cyA9IGFjb3MoLXBvaW50WzFdKTtcbiAgcmV0dXJuICgoLXBvaW50WzJdIDwgMCA/IC1yYWRpdXMgOiByYWRpdXMpICsgdGF1IC0gZXBzaWxvbikgJSB0YXU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2VudGVyID0gY29uc3RhbnQoWzAsIDBdKSxcbiAgICAgIHJhZGl1cyA9IGNvbnN0YW50KDkwKSxcbiAgICAgIHByZWNpc2lvbiA9IGNvbnN0YW50KDYpLFxuICAgICAgcmluZyxcbiAgICAgIHJvdGF0ZSxcbiAgICAgIHN0cmVhbSA9IHtwb2ludDogcG9pbnR9O1xuXG4gIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICByaW5nLnB1c2goeCA9IHJvdGF0ZSh4LCB5KSk7XG4gICAgeFswXSAqPSBkZWdyZWVzLCB4WzFdICo9IGRlZ3JlZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjaXJjbGUoKSB7XG4gICAgdmFyIGMgPSBjZW50ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgciA9IHJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucyxcbiAgICAgICAgcCA9IHByZWNpc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucztcbiAgICByaW5nID0gW107XG4gICAgcm90YXRlID0gcm90YXRlUmFkaWFucygtY1swXSAqIHJhZGlhbnMsIC1jWzFdICogcmFkaWFucywgMCkuaW52ZXJ0O1xuICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHIsIHAsIDEpO1xuICAgIGMgPSB7dHlwZTogXCJQb2x5Z29uXCIsIGNvb3JkaW5hdGVzOiBbcmluZ119O1xuICAgIHJpbmcgPSByb3RhdGUgPSBudWxsO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgY2lyY2xlLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjZW50ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFsrX1swXSwgK19bMV1dKSwgY2lyY2xlKSA6IGNlbnRlcjtcbiAgfTtcblxuICBjaXJjbGUucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBjaXJjbGUpIDogcmFkaXVzO1xuICB9O1xuXG4gIGNpcmNsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2lzaW9uID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiBwcmVjaXNpb247XG4gIH07XG5cbiAgcmV0dXJuIGNpcmNsZTtcbn1cbiIsImltcG9ydCBjbGlwIGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge2FicywgYXRhbiwgY29zLCBlcHNpbG9uLCBoYWxmUGksIHBpLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsaXAoXG4gIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgY2xpcEFudGltZXJpZGlhbkxpbmUsXG4gIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZSxcbiAgWy1waSwgLWhhbGZQaV1cbik7XG5cbi8vIFRha2VzIGEgbGluZSBhbmQgY3V0cyBpbnRvIHZpc2libGUgc2VnbWVudHMuIFJldHVybiB2YWx1ZXM6IDAgLSB0aGVyZSB3ZXJlXG4vLyBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vIGludGVyc2VjdGlvbnM7IDIgLSB0aGVyZSB3ZXJlXG4vLyBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIHNob3VsZCBiZSByZWpvaW5lZC5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5MaW5lKHN0cmVhbSkge1xuICB2YXIgbGFtYmRhMCA9IE5hTixcbiAgICAgIHBoaTAgPSBOYU4sXG4gICAgICBzaWduMCA9IE5hTixcbiAgICAgIGNsZWFuOyAvLyBubyBpbnRlcnNlY3Rpb25zXG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgY2xlYW4gPSAxO1xuICAgIH0sXG4gICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYTEsIHBoaTEpIHtcbiAgICAgIHZhciBzaWduMSA9IGxhbWJkYTEgPiAwID8gcGkgOiAtcGksXG4gICAgICAgICAgZGVsdGEgPSBhYnMobGFtYmRhMSAtIGxhbWJkYTApO1xuICAgICAgaWYgKGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24pIHsgLy8gbGluZSBjcm9zc2VzIGEgcG9sZVxuICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCwgcGhpMCA9IChwaGkwICsgcGhpMSkgLyAyID4gMCA/IGhhbGZQaSA6IC1oYWxmUGkpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGExLCBwaGkwKTtcbiAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChzaWduMCAhPT0gc2lnbjEgJiYgZGVsdGEgPj0gcGkpIHsgLy8gbGluZSBjcm9zc2VzIGFudGltZXJpZGlhblxuICAgICAgICBpZiAoYWJzKGxhbWJkYTAgLSBzaWduMCkgPCBlcHNpbG9uKSBsYW1iZGEwIC09IHNpZ24wICogZXBzaWxvbjsgLy8gaGFuZGxlIGRlZ2VuZXJhY2llc1xuICAgICAgICBpZiAoYWJzKGxhbWJkYTEgLSBzaWduMSkgPCBlcHNpbG9uKSBsYW1iZGExIC09IHNpZ24xICogZXBzaWxvbjtcbiAgICAgICAgcGhpMCA9IGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAgPSBsYW1iZGExLCBwaGkwID0gcGhpMSk7XG4gICAgICBzaWduMCA9IHNpZ24xO1xuICAgIH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgbGFtYmRhMCA9IHBoaTAgPSBOYU47XG4gICAgfSxcbiAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMiAtIGNsZWFuOyAvLyBpZiBpbnRlcnNlY3Rpb25zLCByZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSkge1xuICB2YXIgY29zUGhpMCxcbiAgICAgIGNvc1BoaTEsXG4gICAgICBzaW5MYW1iZGEwTGFtYmRhMSA9IHNpbihsYW1iZGEwIC0gbGFtYmRhMSk7XG4gIHJldHVybiBhYnMoc2luTGFtYmRhMExhbWJkYTEpID4gZXBzaWxvblxuICAgICAgPyBhdGFuKChzaW4ocGhpMCkgKiAoY29zUGhpMSA9IGNvcyhwaGkxKSkgKiBzaW4obGFtYmRhMSlcbiAgICAgICAgICAtIHNpbihwaGkxKSAqIChjb3NQaGkwID0gY29zKHBoaTApKSAqIHNpbihsYW1iZGEwKSlcbiAgICAgICAgICAvIChjb3NQaGkwICogY29zUGhpMSAqIHNpbkxhbWJkYTBMYW1iZGExKSlcbiAgICAgIDogKHBoaTAgKyBwaGkxKSAvIDI7XG59XG5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgdmFyIHBoaTtcbiAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGhhbGZQaTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChwaSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIDApO1xuICAgIHN0cmVhbS5wb2ludChwaSwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIDApO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gIH0gZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGxhbWJkYSA9IGZyb21bMF0gPCB0b1swXSA/IHBpIDogLXBpO1xuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGxhbWJkYSAvIDI7XG4gICAgc3RyZWFtLnBvaW50KC1sYW1iZGEsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgfVxufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lcyA9IFtdLFxuICAgICAgbGluZTtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSwgbSkge1xuICAgICAgbGluZS5wdXNoKFt4LCB5LCBtXSk7XG4gICAgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgIH0sXG4gICAgbGluZUVuZDogbm9vcCxcbiAgICByZWpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICB9LFxuICAgIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbGluZXM7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgbGluZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCB7Y2FydGVzaWFuLCBjYXJ0ZXNpYW5BZGRJblBsYWNlLCBjYXJ0ZXNpYW5Dcm9zcywgY2FydGVzaWFuRG90LCBjYXJ0ZXNpYW5TY2FsZSwgc3BoZXJpY2FsfSBmcm9tIFwiLi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2NpcmNsZVN0cmVhbX0gZnJvbSBcIi4uL2NpcmNsZS5qc1wiO1xuaW1wb3J0IHthYnMsIGNvcywgZXBzaWxvbiwgcGksIHJhZGlhbnMsIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgcG9pbnRFcXVhbCBmcm9tIFwiLi4vcG9pbnRFcXVhbC5qc1wiO1xuaW1wb3J0IGNsaXAgZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFkaXVzKSB7XG4gIHZhciBjciA9IGNvcyhyYWRpdXMpLFxuICAgICAgZGVsdGEgPSA2ICogcmFkaWFucyxcbiAgICAgIHNtYWxsUmFkaXVzID0gY3IgPiAwLFxuICAgICAgbm90SGVtaXNwaGVyZSA9IGFicyhjcikgPiBlcHNpbG9uOyAvLyBUT0RPIG9wdGltaXNlIGZvciB0aGlzIGNvbW1vbiBjYXNlXG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCBmcm9tLCB0byk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIGNvcyhsYW1iZGEpICogY29zKHBoaSkgPiBjcjtcbiAgfVxuXG4gIC8vIFRha2VzIGEgbGluZSBhbmQgY3V0cyBpbnRvIHZpc2libGUgc2VnbWVudHMuIFJldHVybiB2YWx1ZXMgdXNlZCBmb3IgcG9seWdvblxuICAvLyBjbGlwcGluZzogMCAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBub1xuICAvLyBpbnRlcnNlY3Rpb25zIDIgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMsIGFuZCB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgLy8gc2hvdWxkIGJlIHJlam9pbmVkLlxuICBmdW5jdGlvbiBjbGlwTGluZShzdHJlYW0pIHtcbiAgICB2YXIgcG9pbnQwLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICBjMCwgLy8gY29kZSBmb3IgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgdjAsIC8vIHZpc2liaWxpdHkgb2YgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgdjAwLCAvLyB2aXNpYmlsaXR5IG9mIGZpcnN0IHBvaW50XG4gICAgICAgIGNsZWFuOyAvLyBubyBpbnRlcnNlY3Rpb25zXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHYwMCA9IHYwID0gZmFsc2U7XG4gICAgICAgIGNsZWFuID0gMTtcbiAgICAgIH0sXG4gICAgICBwb2ludDogZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHBvaW50MSA9IFtsYW1iZGEsIHBoaV0sXG4gICAgICAgICAgICBwb2ludDIsXG4gICAgICAgICAgICB2ID0gdmlzaWJsZShsYW1iZGEsIHBoaSksXG4gICAgICAgICAgICBjID0gc21hbGxSYWRpdXNcbiAgICAgICAgICAgICAgPyB2ID8gMCA6IGNvZGUobGFtYmRhLCBwaGkpXG4gICAgICAgICAgICAgIDogdiA/IGNvZGUobGFtYmRhICsgKGxhbWJkYSA8IDAgPyBwaSA6IC1waSksIHBoaSkgOiAwO1xuICAgICAgICBpZiAoIXBvaW50MCAmJiAodjAwID0gdjAgPSB2KSkgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgIGlmICghcG9pbnQyIHx8IHBvaW50RXF1YWwocG9pbnQwLCBwb2ludDIpIHx8IHBvaW50RXF1YWwocG9pbnQxLCBwb2ludDIpKVxuICAgICAgICAgICAgcG9pbnQxWzJdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIC8vIG91dHNpZGUgZ29pbmcgaW5cbiAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnNpZGUgZ29pbmcgb3V0XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdLCAyKTtcbiAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50MCA9IHBvaW50MjtcbiAgICAgICAgfSBlbHNlIGlmIChub3RIZW1pc3BoZXJlICYmIHBvaW50MCAmJiBzbWFsbFJhZGl1cyBeIHYpIHtcbiAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAvLyBJZiB0aGUgY29kZXMgZm9yIHR3byBwb2ludHMgYXJlIGRpZmZlcmVudCwgb3IgYXJlIGJvdGggemVybyxcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgdGhpcyBzZWdtZW50IGludGVyc2VjdHMgd2l0aCB0aGUgc21hbGwgY2lyY2xlLlxuICAgICAgICAgIGlmICghKGMgJiBjMCkgJiYgKHQgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDAsIHRydWUpKSkge1xuICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgaWYgKHNtYWxsUmFkaXVzKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0sIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodiAmJiAoIXBvaW50MCB8fCAhcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MSkpKSB7XG4gICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBwb2ludDAgPSBwb2ludDEsIHYwID0gdiwgYzAgPSBjO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodjApIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHBvaW50MCA9IG51bGw7XG4gICAgICB9LFxuICAgICAgLy8gUmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIGlmIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBhbmQgbGFzdCBwb2ludHMgd2VyZSB2aXNpYmxlLlxuICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2xlYW4gfCAoKHYwMCAmJiB2MCkgPDwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVyc2VjdHMgdGhlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIGEgYW5kIGIgd2l0aCB0aGUgY2xpcCBjaXJjbGUuXG4gIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiLCB0d28pIHtcbiAgICB2YXIgcGEgPSBjYXJ0ZXNpYW4oYSksXG4gICAgICAgIHBiID0gY2FydGVzaWFuKGIpO1xuXG4gICAgLy8gV2UgaGF2ZSB0d28gcGxhbmVzLCBuMS5wID0gZDEgYW5kIG4yLnAgPSBkMi5cbiAgICAvLyBGaW5kIGludGVyc2VjdGlvbiBsaW5lIHAodCkgPSBjMSBuMSArIGMyIG4yICsgdCAobjEg4qivIG4yKS5cbiAgICB2YXIgbjEgPSBbMSwgMCwgMF0sIC8vIG5vcm1hbFxuICAgICAgICBuMiA9IGNhcnRlc2lhbkNyb3NzKHBhLCBwYiksXG4gICAgICAgIG4ybjIgPSBjYXJ0ZXNpYW5Eb3QobjIsIG4yKSxcbiAgICAgICAgbjFuMiA9IG4yWzBdLCAvLyBjYXJ0ZXNpYW5Eb3QobjEsIG4yKSxcbiAgICAgICAgZGV0ZXJtaW5hbnQgPSBuMm4yIC0gbjFuMiAqIG4xbjI7XG5cbiAgICAvLyBUd28gcG9sYXIgcG9pbnRzLlxuICAgIGlmICghZGV0ZXJtaW5hbnQpIHJldHVybiAhdHdvICYmIGE7XG5cbiAgICB2YXIgYzEgPSAgY3IgKiBuMm4yIC8gZGV0ZXJtaW5hbnQsXG4gICAgICAgIGMyID0gLWNyICogbjFuMiAvIGRldGVybWluYW50LFxuICAgICAgICBuMXhuMiA9IGNhcnRlc2lhbkNyb3NzKG4xLCBuMiksXG4gICAgICAgIEEgPSBjYXJ0ZXNpYW5TY2FsZShuMSwgYzEpLFxuICAgICAgICBCID0gY2FydGVzaWFuU2NhbGUobjIsIGMyKTtcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKEEsIEIpO1xuXG4gICAgLy8gU29sdmUgfHAodCl8XjIgPSAxLlxuICAgIHZhciB1ID0gbjF4bjIsXG4gICAgICAgIHcgPSBjYXJ0ZXNpYW5Eb3QoQSwgdSksXG4gICAgICAgIHV1ID0gY2FydGVzaWFuRG90KHUsIHUpLFxuICAgICAgICB0MiA9IHcgKiB3IC0gdXUgKiAoY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XG5cbiAgICBpZiAodDIgPCAwKSByZXR1cm47XG5cbiAgICB2YXIgdCA9IHNxcnQodDIpLFxuICAgICAgICBxID0gY2FydGVzaWFuU2NhbGUodSwgKC13IC0gdCkgLyB1dSk7XG4gICAgY2FydGVzaWFuQWRkSW5QbGFjZShxLCBBKTtcbiAgICBxID0gc3BoZXJpY2FsKHEpO1xuXG4gICAgaWYgKCF0d28pIHJldHVybiBxO1xuXG4gICAgLy8gVHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gICAgdmFyIGxhbWJkYTAgPSBhWzBdLFxuICAgICAgICBsYW1iZGExID0gYlswXSxcbiAgICAgICAgcGhpMCA9IGFbMV0sXG4gICAgICAgIHBoaTEgPSBiWzFdLFxuICAgICAgICB6O1xuXG4gICAgaWYgKGxhbWJkYTEgPCBsYW1iZGEwKSB6ID0gbGFtYmRhMCwgbGFtYmRhMCA9IGxhbWJkYTEsIGxhbWJkYTEgPSB6O1xuXG4gICAgdmFyIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsXG4gICAgICAgIHBvbGFyID0gYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbixcbiAgICAgICAgbWVyaWRpYW4gPSBwb2xhciB8fCBkZWx0YSA8IGVwc2lsb247XG5cbiAgICBpZiAoIXBvbGFyICYmIHBoaTEgPCBwaGkwKSB6ID0gcGhpMCwgcGhpMCA9IHBoaTEsIHBoaTEgPSB6O1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgZmlyc3QgcG9pbnQgaXMgYmV0d2VlbiBhIGFuZCBiLlxuICAgIGlmIChtZXJpZGlhblxuICAgICAgICA/IHBvbGFyXG4gICAgICAgICAgPyBwaGkwICsgcGhpMSA+IDAgXiBxWzFdIDwgKGFicyhxWzBdIC0gbGFtYmRhMCkgPCBlcHNpbG9uID8gcGhpMCA6IHBoaTEpXG4gICAgICAgICAgOiBwaGkwIDw9IHFbMV0gJiYgcVsxXSA8PSBwaGkxXG4gICAgICAgIDogZGVsdGEgPiBwaSBeIChsYW1iZGEwIDw9IHFbMF0gJiYgcVswXSA8PSBsYW1iZGExKSkge1xuICAgICAgdmFyIHExID0gY2FydGVzaWFuU2NhbGUodSwgKC13ICsgdCkgLyB1dSk7XG4gICAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHExLCBBKTtcbiAgICAgIHJldHVybiBbcSwgc3BoZXJpY2FsKHExKV07XG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGVzIGEgNC1iaXQgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gb2YgYSBwb2ludCByZWxhdGl2ZSB0b1xuICAvLyB0aGUgc21hbGwgY2lyY2xlJ3MgYm91bmRpbmcgYm94LlxuICBmdW5jdGlvbiBjb2RlKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IHBpIC0gcmFkaXVzLFxuICAgICAgICBjb2RlID0gMDtcbiAgICBpZiAobGFtYmRhIDwgLXIpIGNvZGUgfD0gMTsgLy8gbGVmdFxuICAgIGVsc2UgaWYgKGxhbWJkYSA+IHIpIGNvZGUgfD0gMjsgLy8gcmlnaHRcbiAgICBpZiAocGhpIDwgLXIpIGNvZGUgfD0gNDsgLy8gYmVsb3dcbiAgICBlbHNlIGlmIChwaGkgPiByKSBjb2RlIHw9IDg7IC8vIGFib3ZlXG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cblxuICByZXR1cm4gY2xpcCh2aXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHNtYWxsUmFkaXVzID8gWzAsIC1yYWRpdXNdIDogWy1waSwgcmFkaXVzIC0gcGldKTtcbn1cbiIsImltcG9ydCBjbGlwQnVmZmVyIGZyb20gXCIuL2J1ZmZlci5qc1wiO1xuaW1wb3J0IGNsaXBSZWpvaW4gZnJvbSBcIi4vcmVqb2luLmpzXCI7XG5pbXBvcnQge2Vwc2lsb24sIGhhbGZQaX0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBwb2x5Z29uQ29udGFpbnMgZnJvbSBcIi4uL3BvbHlnb25Db250YWlucy5qc1wiO1xuaW1wb3J0IHttZXJnZX0gZnJvbSBcImQzLWFycmF5XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBvaW50VmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzdGFydCkge1xuICByZXR1cm4gZnVuY3Rpb24oc2luaykge1xuICAgIHZhciBsaW5lID0gY2xpcExpbmUoc2luayksXG4gICAgICAgIHJpbmdCdWZmZXIgPSBjbGlwQnVmZmVyKCksXG4gICAgICAgIHJpbmdTaW5rID0gY2xpcExpbmUocmluZ0J1ZmZlciksXG4gICAgICAgIHBvbHlnb25TdGFydGVkID0gZmFsc2UsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHNlZ21lbnRzLFxuICAgICAgICByaW5nO1xuXG4gICAgdmFyIGNsaXAgPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRSaW5nO1xuICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBjbGlwLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzZWdtZW50cyA9IG1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkNvbnRhaW5zKHBvbHlnb24sIHN0YXJ0KTtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHNpbmspO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25FbmQoKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpO1xuICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIHNpbmsucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgaWYgKHBvaW50VmlzaWJsZShsYW1iZGEsIHBoaSkpIHNpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50TGluZShsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZS5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcC5wb2ludCA9IHBvaW50TGluZTtcbiAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50UmluZyhsYW1iZGEsIHBoaSkge1xuICAgICAgcmluZy5wdXNoKFtsYW1iZGEsIHBoaV0pO1xuICAgICAgcmluZ1NpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIHJpbmdTaW5rLmxpbmVTdGFydCgpO1xuICAgICAgcmluZyA9IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICBwb2ludFJpbmcocmluZ1swXVswXSwgcmluZ1swXVsxXSk7XG4gICAgICByaW5nU2luay5saW5lRW5kKCk7XG5cbiAgICAgIHZhciBjbGVhbiA9IHJpbmdTaW5rLmNsZWFuKCksXG4gICAgICAgICAgcmluZ1NlZ21lbnRzID0gcmluZ0J1ZmZlci5yZXN1bHQoKSxcbiAgICAgICAgICBpLCBuID0gcmluZ1NlZ21lbnRzLmxlbmd0aCwgbSxcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIHBvaW50O1xuXG4gICAgICByaW5nLnBvcCgpO1xuICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgcmluZyA9IG51bGw7XG5cbiAgICAgIGlmICghbikgcmV0dXJuO1xuXG4gICAgICAvLyBObyBpbnRlcnNlY3Rpb25zLlxuICAgICAgaWYgKGNsZWFuICYgMSkge1xuICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICBpZiAoKG0gPSBzZWdtZW50Lmxlbmd0aCAtIDEpID4gMCkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHNpbmsucG9pbnQoKHBvaW50ID0gc2VnbWVudFtpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlam9pbiBjb25uZWN0ZWQgc2VnbWVudHMuXG4gICAgICAvLyBUT0RPIHJldXNlIHJpbmdCdWZmZXIucmVqb2luKCk/XG4gICAgICBpZiAobiA+IDEgJiYgY2xlYW4gJiAyKSByaW5nU2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMucG9wKCkuY29uY2F0KHJpbmdTZWdtZW50cy5zaGlmdCgpKSk7XG5cbiAgICAgIHNlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLmZpbHRlcih2YWxpZFNlZ21lbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcbn1cblxuLy8gSW50ZXJzZWN0aW9ucyBhcmUgc29ydGVkIGFsb25nIHRoZSBjbGlwIGVkZ2UuIEZvciBib3RoIGFudGltZXJpZGlhbiBjdXR0aW5nXG4vLyBhbmQgY2lyY2xlIGNsaXBwaW5nLCB0aGUgc2FtZSBjb21wYXJpc29uIGlzIHVzZWQuXG5mdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBhWzFdKVxuICAgICAgIC0gKChiID0gYi54KVswXSA8IDAgPyBiWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGJbMV0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYiwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIHQwID0gMCxcbiAgICAgIHQxID0gMSxcbiAgICAgIGR4ID0gYnggLSBheCxcbiAgICAgIGR5ID0gYnkgLSBheSxcbiAgICAgIHI7XG5cbiAgciA9IHgwIC0gYXg7XG4gIGlmICghZHggJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB4MSAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICByID0geTAgLSBheTtcbiAgaWYgKCFkeSAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHkxIC0gYXk7XG4gIGlmICghZHkgJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIGlmICh0MCA+IDApIGFbMF0gPSBheCArIHQwICogZHgsIGFbMV0gPSBheSArIHQwICogZHk7XG4gIGlmICh0MSA8IDEpIGJbMF0gPSBheCArIHQxICogZHgsIGJbMV0gPSBheSArIHQxICogZHk7XG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHthYnMsIGVwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgY2xpcEJ1ZmZlciBmcm9tIFwiLi9idWZmZXIuanNcIjtcbmltcG9ydCBjbGlwTGluZSBmcm9tIFwiLi9saW5lLmpzXCI7XG5pbXBvcnQgY2xpcFJlam9pbiBmcm9tIFwiLi9yZWpvaW4uanNcIjtcbmltcG9ydCB7bWVyZ2V9IGZyb20gXCJkMy1hcnJheVwiO1xuXG52YXIgY2xpcE1heCA9IDFlOSwgY2xpcE1pbiA9IC1jbGlwTWF4O1xuXG4vLyBUT0RPIFVzZSBkMy1wb2x5Z29u4oCZcyBwb2x5Z29uQ29udGFpbnMgaGVyZSBmb3IgdGhlIHJpbmcgY2hlY2s/XG4vLyBUT0RPIEVsaW1pbmF0ZSBkdXBsaWNhdGUgYnVmZmVyaW5nIGluIGNsaXBCdWZmZXIgYW5kIHBvbHlnb24ucHVzaD9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xpcFJlY3RhbmdsZSh4MCwgeTAsIHgxLCB5MSkge1xuXG4gIGZ1bmN0aW9uIHZpc2libGUoeCwgeSkge1xuICAgIHJldHVybiB4MCA8PSB4ICYmIHggPD0geDEgJiYgeTAgPD0geSAmJiB5IDw9IHkxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgdmFyIGEgPSAwLCBhMSA9IDA7XG4gICAgaWYgKGZyb20gPT0gbnVsbFxuICAgICAgICB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKVxuICAgICAgICB8fCBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIDwgMCBeIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIGRvIHN0cmVhbS5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcm5lcihwLCBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gYWJzKHBbMF0gLSB4MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDAgOiAzXG4gICAgICAgIDogYWJzKHBbMF0gLSB4MSkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxXG4gICAgICAgIDogYWJzKHBbMV0gLSB5MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwXG4gICAgICAgIDogZGlyZWN0aW9uID4gMCA/IDMgOiAyOyAvLyBhYnMocFsxXSAtIHkxKSA8IGVwc2lsb25cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlUG9pbnQoYS54LCBiLngpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVBvaW50KGEsIGIpIHtcbiAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksXG4gICAgICAgIGNiID0gY29ybmVyKGIsIDEpO1xuICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiXG4gICAgICAgIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXVxuICAgICAgICA6IGNhID09PSAxID8gYVswXSAtIGJbMF1cbiAgICAgICAgOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdXG4gICAgICAgIDogYlswXSAtIGFbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSxcbiAgICAgICAgYnVmZmVyU3RyZWFtID0gY2xpcEJ1ZmZlcigpLFxuICAgICAgICBzZWdtZW50cyxcbiAgICAgICAgcG9seWdvbixcbiAgICAgICAgcmluZyxcbiAgICAgICAgeF9fLCB5X18sIHZfXywgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgeF8sIHlfLCB2XywgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgZmlyc3QsXG4gICAgICAgIGNsZWFuO1xuXG4gICAgdmFyIGNsaXBTdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IHBvbHlnb25TdGFydCxcbiAgICAgIHBvbHlnb25FbmQ6IHBvbHlnb25FbmRcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgaWYgKHZpc2libGUoeCwgeSkpIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uSW5zaWRlKCkge1xuICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBqID0gMSwgbSA9IHJpbmcubGVuZ3RoLCBwb2ludCA9IHJpbmdbMF0sIGEwLCBhMSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTsgaiA8IG07ICsraikge1xuICAgICAgICAgIGEwID0gYjAsIGExID0gYjEsIHBvaW50ID0gcmluZ1tqXSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTtcbiAgICAgICAgICBpZiAoYTEgPD0geTEpIHsgaWYgKGIxID4geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpID4gKGIxIC0gYTEpICogKHgwIC0gYTApKSArK3dpbmRpbmc7IH1cbiAgICAgICAgICBlbHNlIHsgaWYgKGIxIDw9IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA8IChiMSAtIGExKSAqICh4MCAtIGEwKSkgLS13aW5kaW5nOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpbmRpbmc7XG4gICAgfVxuXG4gICAgLy8gQnVmZmVyIGdlb21ldHJ5IHdpdGhpbiBhIHBvbHlnb24gYW5kIHRoZW4gY2xpcCBpdCBlbiBtYXNzZS5cbiAgICBmdW5jdGlvbiBwb2x5Z29uU3RhcnQoKSB7XG4gICAgICBhY3RpdmVTdHJlYW0gPSBidWZmZXJTdHJlYW0sIHNlZ21lbnRzID0gW10sIHBvbHlnb24gPSBbXSwgY2xlYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb25FbmQoKSB7XG4gICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uSW5zaWRlKCksXG4gICAgICAgICAgY2xlYW5JbnNpZGUgPSBjbGVhbiAmJiBzdGFydEluc2lkZSxcbiAgICAgICAgICB2aXNpYmxlID0gKHNlZ21lbnRzID0gbWVyZ2Uoc2VnbWVudHMpKS5sZW5ndGg7XG4gICAgICBpZiAoY2xlYW5JbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIGlmIChjbGVhbkluc2lkZSkge1xuICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzdHJlYW0pO1xuICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSwgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcbiAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIHZfID0gZmFsc2U7XG4gICAgICB4XyA9IHlfID0gTmFOO1xuICAgIH1cblxuICAgIC8vIFRPRE8gcmF0aGVyIHRoYW4gc3BlY2lhbC1jYXNlIHBvbHlnb25zLCBzaW1wbHkgaGFuZGxlIHRoZW0gc2VwYXJhdGVseS5cbiAgICAvLyBJZGVhbGx5LCBjb2luY2lkZW50IGludGVyc2VjdGlvbiBwb2ludHMgc2hvdWxkIGJlIGppdHRlcmVkIHRvIGF2b2lkXG4gICAgLy8gY2xpcHBpbmcgaXNzdWVzLlxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgbGluZVBvaW50KHhfXywgeV9fKTtcbiAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyU3RyZWFtLnJlam9pbigpO1xuICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlclN0cmVhbS5yZXN1bHQoKSk7XG4gICAgICB9XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICBpZiAodl8pIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KHgsIHkpIHtcbiAgICAgIHZhciB2ID0gdmlzaWJsZSh4LCB5KTtcbiAgICAgIGlmIChwb2x5Z29uKSByaW5nLnB1c2goW3gsIHldKTtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICB4X18gPSB4LCB5X18gPSB5LCB2X18gPSB2O1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICYmIHZfKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gW3hfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeF8pKSwgeV8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5XykpXSxcbiAgICAgICAgICAgICAgYiA9IFt4ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeCkpLCB5ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeSkpXTtcbiAgICAgICAgICBpZiAoY2xpcExpbmUoYSwgYiwgeDAsIHkwLCB4MSwgeTEpKSB7XG4gICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGJbMF0sIGJbMV0pO1xuICAgICAgICAgICAgaWYgKCF2KSBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwU3RyZWFtO1xuICB9O1xufVxuIiwiaW1wb3J0IHBvaW50RXF1YWwgZnJvbSBcIi4uL3BvaW50RXF1YWwuanNcIjtcbmltcG9ydCB7ZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHBvaW50LCBwb2ludHMsIG90aGVyLCBlbnRyeSkge1xuICB0aGlzLnggPSBwb2ludDtcbiAgdGhpcy56ID0gcG9pbnRzO1xuICB0aGlzLm8gPSBvdGhlcjsgLy8gYW5vdGhlciBpbnRlcnNlY3Rpb25cbiAgdGhpcy5lID0gZW50cnk7IC8vIGlzIGFuIGVudHJ5P1xuICB0aGlzLnYgPSBmYWxzZTsgLy8gdmlzaXRlZFxuICB0aGlzLm4gPSB0aGlzLnAgPSBudWxsOyAvLyBuZXh0ICYgcHJldmlvdXNcbn1cblxuLy8gQSBnZW5lcmFsaXplZCBwb2x5Z29uIGNsaXBwaW5nIGFsZ29yaXRobTogZ2l2ZW4gYSBwb2x5Z29uIHRoYXQgaGFzIGJlZW4gY3V0XG4vLyBpbnRvIGl0cyB2aXNpYmxlIGxpbmUgc2VnbWVudHMsIGFuZCByZWpvaW5zIHRoZSBzZWdtZW50cyBieSBpbnRlcnBvbGF0aW5nXG4vLyBhbG9uZyB0aGUgY2xpcCBlZGdlLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKSB7XG4gIHZhciBzdWJqZWN0ID0gW10sXG4gICAgICBjbGlwID0gW10sXG4gICAgICBpLFxuICAgICAgbjtcblxuICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICBpZiAoKG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEpIDw9IDApIHJldHVybjtcbiAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl0sIHg7XG5cbiAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICBpZiAoIXAwWzJdICYmICFwMVsyXSkge1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHN0cmVhbS5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgZGVnZW5lcmF0ZSBjYXNlcyBieSBtb3ZpbmcgdGhlIHBvaW50XG4gICAgICBwMVswXSArPSAyICogZXBzaWxvbjtcbiAgICB9XG5cbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIHNlZ21lbnQsIG51bGwsIHRydWUpKTtcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMCwgbnVsbCwgeCwgZmFsc2UpKTtcbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIG51bGwsIHgsIHRydWUpKTtcbiAgfSk7XG5cbiAgaWYgKCFzdWJqZWN0Lmxlbmd0aCkgcmV0dXJuO1xuXG4gIGNsaXAuc29ydChjb21wYXJlSW50ZXJzZWN0aW9uKTtcbiAgbGluayhzdWJqZWN0KTtcbiAgbGluayhjbGlwKTtcblxuICBmb3IgKGkgPSAwLCBuID0gY2xpcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjbGlwW2ldLmUgPSBzdGFydEluc2lkZSA9ICFzdGFydEluc2lkZTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IHN1YmplY3RbMF0sXG4gICAgICBwb2ludHMsXG4gICAgICBwb2ludDtcblxuICB3aGlsZSAoMSkge1xuICAgIC8vIEZpbmQgZmlyc3QgdW52aXNpdGVkIGludGVyc2VjdGlvbi5cbiAgICB2YXIgY3VycmVudCA9IHN0YXJ0LFxuICAgICAgICBpc1N1YmplY3QgPSB0cnVlO1xuICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XG4gICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50LnYgPSBjdXJyZW50Lm8udiA9IHRydWU7XG4gICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47ICsraSkgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQubi54LCAxLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgcG9pbnRzID0gY3VycmVudC5wLno7XG4gICAgICAgICAgZm9yIChpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5wLngsIC0xLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnA7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgaXNTdWJqZWN0ID0gIWlzU3ViamVjdDtcbiAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICBzdHJlYW0ubGluZUVuZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpbmsoYXJyYXkpIHtcbiAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgdmFyIG4sXG4gICAgICBpID0gMCxcbiAgICAgIGEgPSBhcnJheVswXSxcbiAgICAgIGI7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgIGIucCA9IGE7XG4gICAgYSA9IGI7XG4gIH1cbiAgYS5uID0gYiA9IGFycmF5WzBdO1xuICBiLnAgPSBhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuXG4gIGZ1bmN0aW9uIGNvbXBvc2UoeCwgeSkge1xuICAgIHJldHVybiB4ID0gYSh4LCB5KSwgYih4WzBdLCB4WzFdKTtcbiAgfVxuXG4gIGlmIChhLmludmVydCAmJiBiLmludmVydCkgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBiLmludmVydCh4LCB5KSwgeCAmJiBhLmludmVydCh4WzBdLCB4WzFdKTtcbiAgfTtcblxuICByZXR1cm4gY29tcG9zZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IHtyYW5nZX0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2FicywgY2VpbCwgZXBzaWxvbn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBncmF0aWN1bGVYKHkwLCB5MSwgZHkpIHtcbiAgdmFyIHkgPSByYW5nZSh5MCwgeTEgLSBlcHNpbG9uLCBkeSkuY29uY2F0KHkxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHkubWFwKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIFt4LCB5XTsgfSk7IH07XG59XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZVkoeDAsIHgxLCBkeCkge1xuICB2YXIgeCA9IHJhbmdlKHgwLCB4MSAtIGVwc2lsb24sIGR4KS5jb25jYXQoeDEpO1xuICByZXR1cm4gZnVuY3Rpb24oeSkgeyByZXR1cm4geC5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICB2YXIgeDEsIHgwLCBYMSwgWDAsXG4gICAgICB5MSwgeTAsIFkxLCBZMCxcbiAgICAgIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLFxuICAgICAgeCwgeSwgWCwgWSxcbiAgICAgIHByZWNpc2lvbiA9IDIuNTtcblxuICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogbGluZXMoKX07XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICByZXR1cm4gcmFuZ2UoY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKVxuICAgICAgICAuY29uY2F0KHJhbmdlKGNlaWwoWTAgLyBEWSkgKiBEWSwgWTEsIERZKS5tYXAoWSkpXG4gICAgICAgIC5jb25jYXQocmFuZ2UoY2VpbCh4MCAvIGR4KSAqIGR4LCB4MSwgZHgpLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBhYnMoeCAlIERYKSA+IGVwc2lsb247IH0pLm1hcCh4KSlcbiAgICAgICAgLmNvbmNhdChyYW5nZShjZWlsKHkwIC8gZHkpICogZHksIHkxLCBkeSkuZmlsdGVyKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIGFicyh5ICUgRFkpID4gZXBzaWxvbjsgfSkubWFwKHkpKTtcbiAgfVxuXG4gIGdyYXRpY3VsZS5saW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsaW5lcygpLm1hcChmdW5jdGlvbihjb29yZGluYXRlcykgeyByZXR1cm4ge3R5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXN9OyB9KTtcbiAgfTtcblxuICBncmF0aWN1bGUub3V0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgIFgoWDApLmNvbmNhdChcbiAgICAgICAgWShZMSkuc2xpY2UoMSksXG4gICAgICAgIFgoWDEpLnJldmVyc2UoKS5zbGljZSgxKSxcbiAgICAgICAgWShZMCkucmV2ZXJzZSgpLnNsaWNlKDEpKVxuICAgICAgXVxuICAgIH07XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWlub3IoKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLmV4dGVudE1ham9yKF8pLmV4dGVudE1pbm9yKF8pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnRNYWpvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW1gwLCBZMF0sIFtYMSwgWTFdXTtcbiAgICBYMCA9ICtfWzBdWzBdLCBYMSA9ICtfWzFdWzBdO1xuICAgIFkwID0gK19bMF1bMV0sIFkxID0gK19bMV1bMV07XG4gICAgaWYgKFgwID4gWDEpIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xuICAgIGlmIChZMCA+IFkxKSBfID0gWTAsIFkwID0gWTEsIFkxID0gXztcbiAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnRNaW5vciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB4MCA9ICtfWzBdWzBdLCB4MSA9ICtfWzFdWzBdO1xuICAgIHkwID0gK19bMF1bMV0sIHkxID0gK19bMV1bMV07XG4gICAgaWYgKHgwID4geDEpIF8gPSB4MCwgeDAgPSB4MSwgeDEgPSBfO1xuICAgIGlmICh5MCA+IHkxKSBfID0geTAsIHkwID0geTEsIHkxID0gXztcbiAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWlub3IoKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNYWpvcihfKS5zdGVwTWlub3IoXyk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXBNYWpvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbRFgsIERZXTtcbiAgICBEWCA9ICtfWzBdLCBEWSA9ICtfWzFdO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXBNaW5vciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcbiAgICBkeCA9ICtfWzBdLCBkeSA9ICtfWzFdO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgcHJlY2lzaW9uID0gK187XG4gICAgeCA9IGdyYXRpY3VsZVgoeTAsIHkxLCA5MCk7XG4gICAgeSA9IGdyYXRpY3VsZVkoeDAsIHgxLCBwcmVjaXNpb24pO1xuICAgIFggPSBncmF0aWN1bGVYKFkwLCBZMSwgOTApO1xuICAgIFkgPSBncmF0aWN1bGVZKFgwLCBYMSwgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIHJldHVybiBncmF0aWN1bGVcbiAgICAgIC5leHRlbnRNYWpvcihbWy0xODAsIC05MCArIGVwc2lsb25dLCBbMTgwLCA5MCAtIGVwc2lsb25dXSlcbiAgICAgIC5leHRlbnRNaW5vcihbWy0xODAsIC04MCAtIGVwc2lsb25dLCBbMTgwLCA4MCArIGVwc2lsb25dXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF0aWN1bGUxMCgpIHtcbiAgcmV0dXJuIGdyYXRpY3VsZSgpKCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB4ID0+IHg7XG4iLCJleHBvcnQgdmFyIGVwc2lsb24gPSAxZS02O1xuZXhwb3J0IHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuZXhwb3J0IHZhciBwaSA9IE1hdGguUEk7XG5leHBvcnQgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuZXhwb3J0IHZhciB0YXUgPSBwaSAqIDI7XG5cbmV4cG9ydCB2YXIgZGVncmVlcyA9IDE4MCAvIHBpO1xuZXhwb3J0IHZhciByYWRpYW5zID0gcGkgLyAxODA7XG5cbmV4cG9ydCB2YXIgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgdmFyIGF0YW4gPSBNYXRoLmF0YW47XG5leHBvcnQgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbmV4cG9ydCB2YXIgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgdmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5leHBvcnQgdmFyIGV4cCA9IE1hdGguZXhwO1xuZXhwb3J0IHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5leHBvcnQgdmFyIGh5cG90ID0gTWF0aC5oeXBvdDtcbmV4cG9ydCB2YXIgbG9nID0gTWF0aC5sb2c7XG5leHBvcnQgdmFyIHBvdyA9IE1hdGgucG93O1xuZXhwb3J0IHZhciBzaW4gPSBNYXRoLnNpbjtcbmV4cG9ydCB2YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbmV4cG9ydCB2YXIgc3FydCA9IE1hdGguc3FydDtcbmV4cG9ydCB2YXIgdGFuID0gTWF0aC50YW47XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID4gMSA/IGhhbGZQaSA6IHggPCAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXZlcnNpbih4KSB7XG4gIHJldHVybiAoeCA9IHNpbih4IC8gMikpICogeDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Fic30gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbnZhciBhcmVhU3VtID0gbmV3IEFkZGVyKCksXG4gICAgYXJlYVJpbmdTdW0gPSBuZXcgQWRkZXIoKSxcbiAgICB4MDAsXG4gICAgeTAwLFxuICAgIHgwLFxuICAgIHkwO1xuXG52YXIgYXJlYVN0cmVhbSA9IHtcbiAgcG9pbnQ6IG5vb3AsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtLmxpbmVTdGFydCA9IGFyZWFSaW5nU3RhcnQ7XG4gICAgYXJlYVN0cmVhbS5saW5lRW5kID0gYXJlYVJpbmdFbmQ7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVN0cmVhbS5saW5lRW5kID0gYXJlYVN0cmVhbS5wb2ludCA9IG5vb3A7XG4gICAgYXJlYVN1bS5hZGQoYWJzKGFyZWFSaW5nU3VtKSk7XG4gICAgYXJlYVJpbmdTdW0gPSBuZXcgQWRkZXIoKTtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYSA9IGFyZWFTdW0gLyAyO1xuICAgIGFyZWFTdW0gPSBuZXcgQWRkZXIoKTtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXJlYVJpbmdTdGFydCgpIHtcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnRGaXJzdCh4LCB5KSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnQ7XG4gIHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5O1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnQoeCwgeSkge1xuICBhcmVhUmluZ1N1bS5hZGQoeTAgKiB4IC0geDAgKiB5KTtcbiAgeDAgPSB4LCB5MCA9IHk7XG59XG5cbmZ1bmN0aW9uIGFyZWFSaW5nRW5kKCkge1xuICBhcmVhUG9pbnQoeDAwLCB5MDApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcmVhU3RyZWFtO1xuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxudmFyIHgwID0gSW5maW5pdHksXG4gICAgeTAgPSB4MCxcbiAgICB4MSA9IC14MCxcbiAgICB5MSA9IHgxO1xuXG52YXIgYm91bmRzU3RyZWFtID0ge1xuICBwb2ludDogYm91bmRzUG9pbnQsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBub29wLFxuICBwb2x5Z29uRW5kOiBub29wLFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib3VuZHMgPSBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB4MSA9IHkxID0gLSh5MCA9IHgwID0gSW5maW5pdHkpO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJvdW5kc1BvaW50KHgsIHkpIHtcbiAgaWYgKHggPCB4MCkgeDAgPSB4O1xuICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gIGlmICh5IDwgeTApIHkwID0geTtcbiAgaWYgKHkgPiB5MSkgeTEgPSB5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBib3VuZHNTdHJlYW07XG4iLCJpbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbi8vIFRPRE8gRW5mb3JjZSBwb3NpdGl2ZSBhcmVhIGZvciBleHRlcmlvciwgbmVnYXRpdmUgYXJlYSBmb3IgaW50ZXJpb3I/XG5cbnZhciBYMCA9IDAsXG4gICAgWTAgPSAwLFxuICAgIFowID0gMCxcbiAgICBYMSA9IDAsXG4gICAgWTEgPSAwLFxuICAgIFoxID0gMCxcbiAgICBYMiA9IDAsXG4gICAgWTIgPSAwLFxuICAgIFoyID0gMCxcbiAgICB4MDAsXG4gICAgeTAwLFxuICAgIHgwLFxuICAgIHkwO1xuXG52YXIgY2VudHJvaWRTdHJlYW0gPSB7XG4gIHBvaW50OiBjZW50cm9pZFBvaW50LFxuICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0LFxuICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkTGluZVN0YXJ0O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZExpbmVFbmQ7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNlbnRyb2lkID0gWjIgPyBbWDIgLyBaMiwgWTIgLyBaMl1cbiAgICAgICAgOiBaMSA/IFtYMSAvIFoxLCBZMSAvIFoxXVxuICAgICAgICA6IFowID8gW1gwIC8gWjAsIFkwIC8gWjBdXG4gICAgICAgIDogW05hTiwgTmFOXTtcbiAgICBYMCA9IFkwID0gWjAgPVxuICAgIFgxID0gWTEgPSBaMSA9XG4gICAgWDIgPSBZMiA9IFoyID0gMDtcbiAgICByZXR1cm4gY2VudHJvaWQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnQoeCwgeSkge1xuICBYMCArPSB4O1xuICBZMCArPSB5O1xuICArK1owO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RMaW5lO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RMaW5lKHgsIHkpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50TGluZTtcbiAgY2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRMaW5lKHgsIHkpIHtcbiAgdmFyIGR4ID0geCAtIHgwLCBkeSA9IHkgLSB5MCwgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBYMSArPSB6ICogKHgwICsgeCkgLyAyO1xuICBZMSArPSB6ICogKHkwICsgeSkgLyAyO1xuICBaMSArPSB6O1xuICBjZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kKCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnRGaXJzdFJpbmc7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ0VuZCgpIHtcbiAgY2VudHJvaWRQb2ludFJpbmcoeDAwLCB5MDApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RSaW5nKHgsIHkpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50UmluZztcbiAgY2VudHJvaWRQb2ludCh4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRSaW5nKHgsIHkpIHtcbiAgdmFyIGR4ID0geCAtIHgwLFxuICAgICAgZHkgPSB5IC0geTAsXG4gICAgICB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgWjEgKz0gejtcblxuICB6ID0geTAgKiB4IC0geDAgKiB5O1xuICBYMiArPSB6ICogKHgwICsgeCk7XG4gIFkyICs9IHogKiAoeTAgKyB5KTtcbiAgWjIgKz0geiAqIDM7XG4gIGNlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjZW50cm9pZFN0cmVhbTtcbiIsImltcG9ydCB7dGF1fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGF0aENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUGF0aENvbnRleHQucHJvdG90eXBlID0ge1xuICBfcmFkaXVzOiA0LjUsXG4gIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhZGl1cyA9IF8sIHRoaXM7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSA9PT0gMCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4ICsgdGhpcy5fcmFkaXVzLCB5KTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5hcmMoeCwgeSwgdGhpcy5fcmFkaXVzLCAwLCB0YXUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlc3VsdDogbm9vcFxufTtcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCBzdHJlYW0gZnJvbSBcIi4uL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHBhdGhBcmVhIGZyb20gXCIuL2FyZWEuanNcIjtcbmltcG9ydCBwYXRoQm91bmRzIGZyb20gXCIuL2JvdW5kcy5qc1wiO1xuaW1wb3J0IHBhdGhDZW50cm9pZCBmcm9tIFwiLi9jZW50cm9pZC5qc1wiO1xuaW1wb3J0IFBhdGhDb250ZXh0IGZyb20gXCIuL2NvbnRleHQuanNcIjtcbmltcG9ydCBwYXRoTWVhc3VyZSBmcm9tIFwiLi9tZWFzdXJlLmpzXCI7XG5pbXBvcnQgUGF0aFN0cmluZyBmcm9tIFwiLi9zdHJpbmcuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocHJvamVjdGlvbiwgY29udGV4dCkge1xuICB2YXIgcG9pbnRSYWRpdXMgPSA0LjUsXG4gICAgICBwcm9qZWN0aW9uU3RyZWFtLFxuICAgICAgY29udGV4dFN0cmVhbTtcblxuICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGNvbnRleHRTdHJlYW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRTdHJlYW0ucmVzdWx0KCk7XG4gIH1cblxuICBwYXRoLmFyZWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKHBhdGhBcmVhKSk7XG4gICAgcmV0dXJuIHBhdGhBcmVhLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGgubWVhc3VyZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0ocGF0aE1lYXN1cmUpKTtcbiAgICByZXR1cm4gcGF0aE1lYXN1cmUucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5ib3VuZHMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKHBhdGhCb3VuZHMpKTtcbiAgICByZXR1cm4gcGF0aEJvdW5kcy5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLmNlbnRyb2lkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoQ2VudHJvaWQpKTtcbiAgICByZXR1cm4gcGF0aENlbnRyb2lkLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0aW9uU3RyZWFtID0gXyA9PSBudWxsID8gKHByb2plY3Rpb24gPSBudWxsLCBpZGVudGl0eSkgOiAocHJvamVjdGlvbiA9IF8pLnN0cmVhbSwgcGF0aCkgOiBwcm9qZWN0aW9uO1xuICB9O1xuXG4gIHBhdGguY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgIGNvbnRleHRTdHJlYW0gPSBfID09IG51bGwgPyAoY29udGV4dCA9IG51bGwsIG5ldyBQYXRoU3RyaW5nKSA6IG5ldyBQYXRoQ29udGV4dChjb250ZXh0ID0gXyk7XG4gICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBwYXRoLnBvaW50UmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBvaW50UmFkaXVzO1xuICAgIHBvaW50UmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiAoY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrXyksICtfKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICByZXR1cm4gcGF0aC5wcm9qZWN0aW9uKHByb2plY3Rpb24pLmNvbnRleHQoY29udGV4dCk7XG59XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbnZhciBsZW5ndGhTdW0gPSBuZXcgQWRkZXIoKSxcbiAgICBsZW5ndGhSaW5nLFxuICAgIHgwMCxcbiAgICB5MDAsXG4gICAgeDAsXG4gICAgeTA7XG5cbnZhciBsZW5ndGhTdHJlYW0gPSB7XG4gIHBvaW50OiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50Rmlyc3Q7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChsZW5ndGhSaW5nKSBsZW5ndGhQb2ludCh4MDAsIHkwMCk7XG4gICAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbm9vcDtcbiAgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhSaW5nID0gdHJ1ZTtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoUmluZyA9IG51bGw7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9ICtsZW5ndGhTdW07XG4gICAgbGVuZ3RoU3VtID0gbmV3IEFkZGVyKCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxufTtcblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdCh4LCB5KSB7XG4gIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50O1xuICB4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnQoeCwgeSkge1xuICB4MCAtPSB4LCB5MCAtPSB5O1xuICBsZW5ndGhTdW0uYWRkKHNxcnQoeDAgKiB4MCArIHkwICogeTApKTtcbiAgeDAgPSB4LCB5MCA9IHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxlbmd0aFN0cmVhbTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhdGhTdHJpbmcoKSB7XG4gIHRoaXMuX3N0cmluZyA9IFtdO1xufVxuXG5QYXRoU3RyaW5nLnByb3RvdHlwZSA9IHtcbiAgX3JhZGl1czogNC41LFxuICBfY2lyY2xlOiBjaXJjbGUoNC41KSxcbiAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoKF8gPSArXykgIT09IHRoaXMuX3JhZGl1cykgdGhpcy5fcmFkaXVzID0gXywgdGhpcy5fY2lyY2xlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lID09PSAwKSB0aGlzLl9zdHJpbmcucHVzaChcIlpcIik7XG4gICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSk7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJMXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0aGlzLl9jaXJjbGUgPT0gbnVsbCkgdGhpcy5fY2lyY2xlID0gY2lyY2xlKHRoaXMuX3JhZGl1cyk7XG4gICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSwgdGhpcy5fY2lyY2xlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9zdHJpbmcubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICB0aGlzLl9zdHJpbmcgPSBbXTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2lyY2xlKHJhZGl1cykge1xuICByZXR1cm4gXCJtMCxcIiArIHJhZGl1c1xuICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIC0yICogcmFkaXVzXG4gICAgICArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgMiAqIHJhZGl1c1xuICAgICAgKyBcInpcIjtcbn1cbiIsImltcG9ydCB7YWJzLCBlcHNpbG9ufSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCBlcHNpbG9uICYmIGFicyhhWzFdIC0gYlsxXSkgPCBlcHNpbG9uO1xufVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2NhcnRlc2lhbiwgY2FydGVzaWFuQ3Jvc3MsIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2V9IGZyb20gXCIuL2NhcnRlc2lhbi5qc1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGF0YW4yLCBjb3MsIGVwc2lsb24sIGVwc2lsb24yLCBoYWxmUGksIHBpLCBxdWFydGVyUGksIHNpZ24sIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGxvbmdpdHVkZShwb2ludCkge1xuICBpZiAoYWJzKHBvaW50WzBdKSA8PSBwaSlcbiAgICByZXR1cm4gcG9pbnRbMF07XG4gIGVsc2VcbiAgICByZXR1cm4gc2lnbihwb2ludFswXSkgKiAoKGFicyhwb2ludFswXSkgKyBwaSkgJSB0YXUgLSBwaSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBvbHlnb24sIHBvaW50KSB7XG4gIHZhciBsYW1iZGEgPSBsb25naXR1ZGUocG9pbnQpLFxuICAgICAgcGhpID0gcG9pbnRbMV0sXG4gICAgICBzaW5QaGkgPSBzaW4ocGhpKSxcbiAgICAgIG5vcm1hbCA9IFtzaW4obGFtYmRhKSwgLWNvcyhsYW1iZGEpLCAwXSxcbiAgICAgIGFuZ2xlID0gMCxcbiAgICAgIHdpbmRpbmcgPSAwO1xuXG4gIHZhciBzdW0gPSBuZXcgQWRkZXIoKTtcblxuICBpZiAoc2luUGhpID09PSAxKSBwaGkgPSBoYWxmUGkgKyBlcHNpbG9uO1xuICBlbHNlIGlmIChzaW5QaGkgPT09IC0xKSBwaGkgPSAtaGFsZlBpIC0gZXBzaWxvbjtcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEobSA9IChyaW5nID0gcG9seWdvbltpXSkubGVuZ3RoKSkgY29udGludWU7XG4gICAgdmFyIHJpbmcsXG4gICAgICAgIG0sXG4gICAgICAgIHBvaW50MCA9IHJpbmdbbSAtIDFdLFxuICAgICAgICBsYW1iZGEwID0gbG9uZ2l0dWRlKHBvaW50MCksXG4gICAgICAgIHBoaTAgPSBwb2ludDBbMV0gLyAyICsgcXVhcnRlclBpLFxuICAgICAgICBzaW5QaGkwID0gc2luKHBoaTApLFxuICAgICAgICBjb3NQaGkwID0gY29zKHBoaTApO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2osIGxhbWJkYTAgPSBsYW1iZGExLCBzaW5QaGkwID0gc2luUGhpMSwgY29zUGhpMCA9IGNvc1BoaTEsIHBvaW50MCA9IHBvaW50MSkge1xuICAgICAgdmFyIHBvaW50MSA9IHJpbmdbal0sXG4gICAgICAgICAgbGFtYmRhMSA9IGxvbmdpdHVkZShwb2ludDEpLFxuICAgICAgICAgIHBoaTEgPSBwb2ludDFbMV0gLyAyICsgcXVhcnRlclBpLFxuICAgICAgICAgIHNpblBoaTEgPSBzaW4ocGhpMSksXG4gICAgICAgICAgY29zUGhpMSA9IGNvcyhwaGkxKSxcbiAgICAgICAgICBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxuICAgICAgICAgIHNpZ24gPSBkZWx0YSA+PSAwID8gMSA6IC0xLFxuICAgICAgICAgIGFic0RlbHRhID0gc2lnbiAqIGRlbHRhLFxuICAgICAgICAgIGFudGltZXJpZGlhbiA9IGFic0RlbHRhID4gcGksXG4gICAgICAgICAgayA9IHNpblBoaTAgKiBzaW5QaGkxO1xuXG4gICAgICBzdW0uYWRkKGF0YW4yKGsgKiBzaWduICogc2luKGFic0RlbHRhKSwgY29zUGhpMCAqIGNvc1BoaTEgKyBrICogY29zKGFic0RlbHRhKSkpO1xuICAgICAgYW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZGVsdGEgKyBzaWduICogdGF1IDogZGVsdGE7XG5cbiAgICAgIC8vIEFyZSB0aGUgbG9uZ2l0dWRlcyBlaXRoZXIgc2lkZSBvZiB0aGUgcG9pbnTigJlzIG1lcmlkaWFuIChsYW1iZGEpLFxuICAgICAgLy8gYW5kIGFyZSB0aGUgbGF0aXR1ZGVzIHNtYWxsZXIgdGhhbiB0aGUgcGFyYWxsZWwgKHBoaSk/XG4gICAgICBpZiAoYW50aW1lcmlkaWFuIF4gbGFtYmRhMCA+PSBsYW1iZGEgXiBsYW1iZGExID49IGxhbWJkYSkge1xuICAgICAgICB2YXIgYXJjID0gY2FydGVzaWFuQ3Jvc3MoY2FydGVzaWFuKHBvaW50MCksIGNhcnRlc2lhbihwb2ludDEpKTtcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShhcmMpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gY2FydGVzaWFuQ3Jvc3Mobm9ybWFsLCBhcmMpO1xuICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGludGVyc2VjdGlvbik7XG4gICAgICAgIHZhciBwaGlBcmMgPSAoYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IC0xIDogMSkgKiBhc2luKGludGVyc2VjdGlvblsyXSk7XG4gICAgICAgIGlmIChwaGkgPiBwaGlBcmMgfHwgcGhpID09PSBwaGlBcmMgJiYgKGFyY1swXSB8fCBhcmNbMV0pKSB7XG4gICAgICAgICAgd2luZGluZyArPSBhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QsIGRldGVybWluZSB3aGV0aGVyIHRoZSBTb3V0aCBwb2xlIGlzIGluc2lkZSBvciBvdXRzaWRlOlxuICAvL1xuICAvLyBJdCBpcyBpbnNpZGUgaWY6XG4gIC8vICogdGhlIHBvbHlnb24gd2luZHMgYXJvdW5kIGl0IGluIGEgY2xvY2t3aXNlIGRpcmVjdGlvbi5cbiAgLy8gKiB0aGUgcG9seWdvbiBkb2VzIG5vdCAoY3VtdWxhdGl2ZWx5KSB3aW5kIGFyb3VuZCBpdCwgYnV0IGhhcyBhIG5lZ2F0aXZlXG4gIC8vICAgKGNvdW50ZXItY2xvY2t3aXNlKSBhcmVhLlxuICAvL1xuICAvLyBTZWNvbmQsIGNvdW50IHRoZSAoc2lnbmVkKSBudW1iZXIgb2YgdGltZXMgYSBzZWdtZW50IGNyb3NzZXMgYSBsYW1iZGFcbiAgLy8gZnJvbSB0aGUgcG9pbnQgdG8gdGhlIFNvdXRoIHBvbGUuICBJZiBpdCBpcyB6ZXJvLCB0aGVuIHRoZSBwb2ludCBpcyB0aGVcbiAgLy8gc2FtZSBzaWRlIGFzIHRoZSBTb3V0aCBwb2xlLlxuXG4gIHJldHVybiAoYW5nbGUgPCAtZXBzaWxvbiB8fCBhbmdsZSA8IGVwc2lsb24gJiYgc3VtIDwgLWVwc2lsb24yKSBeICh3aW5kaW5nICYgMSk7XG59XG4iLCJpbXBvcnQgY29uaWNFcXVhbEFyZWEgZnJvbSBcIi4vY29uaWNFcXVhbEFyZWEuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjb25pY0VxdWFsQXJlYSgpXG4gICAgICAucGFyYWxsZWxzKFsyOS41LCA0NS41XSlcbiAgICAgIC5zY2FsZSgxMDcwKVxuICAgICAgLnRyYW5zbGF0ZShbNDgwLCAyNTBdKVxuICAgICAgLnJvdGF0ZShbOTYsIDBdKVxuICAgICAgLmNlbnRlcihbLTAuNiwgMzguN10pO1xufVxuIiwiaW1wb3J0IHtlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IGFsYmVycyBmcm9tIFwiLi9hbGJlcnMuanNcIjtcbmltcG9ydCBjb25pY0VxdWFsQXJlYSBmcm9tIFwiLi9jb25pY0VxdWFsQXJlYS5qc1wiO1xuaW1wb3J0IHtmaXRFeHRlbnQsIGZpdFNpemUsIGZpdFdpZHRoLCBmaXRIZWlnaHR9IGZyb20gXCIuL2ZpdC5qc1wiO1xuXG4vLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbi8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuZnVuY3Rpb24gbXVsdGlwbGV4KHN0cmVhbXMpIHtcbiAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTsgfSxcbiAgICBzcGhlcmU6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5zcGhlcmUoKTsgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTsgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ubGluZUVuZCgpOyB9LFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpOyB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7IH1cbiAgfTtcbn1cblxuLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgdGhlIFVuaXRlZCBTdGF0ZXMsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3Jcbi8vIDk2MMOXNTAwLiBUaGUgcHJvamVjdGlvbiBhbHNvIHdvcmtzIHF1aXRlIHdlbGwgYXQgOTYww5c2MDAgaWYgeW91IGNoYW5nZSB0aGVcbi8vIHNjYWxlIHRvIDEyODUgYW5kIGFkanVzdCB0aGUgdHJhbnNsYXRlIGFjY29yZGluZ2x5LiBUaGUgc2V0IG9mIHN0YW5kYXJkXG4vLyBwYXJhbGxlbHMgZm9yIGVhY2ggcmVnaW9uIGNvbWVzIGZyb20gVVNHUywgd2hpY2ggaXMgcHVibGlzaGVkIGhlcmU6XG4vLyBodHRwOi8vZWdzYy51c2dzLmdvdi9pc2IvcHVicy9NYXBQcm9qZWN0aW9ucy9wcm9qZWN0aW9ucy5odG1sI2FsYmVyc1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtLFxuICAgICAgbG93ZXI0OCA9IGFsYmVycygpLCBsb3dlcjQ4UG9pbnQsXG4gICAgICBhbGFza2EgPSBjb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbMTU0LCAwXSkuY2VudGVyKFstMiwgNTguNV0pLnBhcmFsbGVscyhbNTUsIDY1XSksIGFsYXNrYVBvaW50LCAvLyBFUFNHOjMzMzhcbiAgICAgIGhhd2FpaSA9IGNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTcsIDBdKS5jZW50ZXIoWy0zLCAxOS45XSkucGFyYWxsZWxzKFs4LCAxOF0pLCBoYXdhaWlQb2ludCwgLy8gRVNSSToxMDIwMDdcbiAgICAgIHBvaW50LCBwb2ludFN0cmVhbSA9IHtwb2ludDogZnVuY3Rpb24oeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfX07XG5cbiAgZnVuY3Rpb24gYWxiZXJzVXNhKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgIChsb3dlcjQ4UG9pbnQucG9pbnQoeCwgeSksIHBvaW50KVxuICAgICAgICB8fCAoYWxhc2thUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KVxuICAgICAgICB8fCAoaGF3YWlpUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KTtcbiAgfVxuXG4gIGFsYmVyc1VzYS5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLFxuICAgICAgICB0ID0gbG93ZXI0OC50cmFuc2xhdGUoKSxcbiAgICAgICAgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gayxcbiAgICAgICAgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICByZXR1cm4gKHkgPj0gMC4xMjAgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuNDI1ICYmIHggPCAtMC4yMTQgPyBhbGFza2FcbiAgICAgICAgOiB5ID49IDAuMTY2ICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjIxNCAmJiB4IDwgLTAuMTE1ID8gaGF3YWlpXG4gICAgICAgIDogbG93ZXI0OCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgfTtcblxuICBhbGJlcnNVc2Euc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4KFtsb3dlcjQ4LnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGFsYXNrYS5zdHJlYW0oc3RyZWFtKSwgaGF3YWlpLnN0cmVhbShzdHJlYW0pXSk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnByZWNpc2lvbigpO1xuICAgIGxvd2VyNDgucHJlY2lzaW9uKF8pLCBhbGFza2EucHJlY2lzaW9uKF8pLCBoYXdhaWkucHJlY2lzaW9uKF8pO1xuICAgIHJldHVybiByZXNldCgpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnNjYWxlKCk7XG4gICAgbG93ZXI0OC5zY2FsZShfKSwgYWxhc2thLnNjYWxlKF8gKiAwLjM1KSwgaGF3YWlpLnNjYWxlKF8pO1xuICAgIHJldHVybiBhbGJlcnNVc2EudHJhbnNsYXRlKGxvd2VyNDgudHJhbnNsYXRlKCkpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC50cmFuc2xhdGUoKTtcbiAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG5cbiAgICBsb3dlcjQ4UG9pbnQgPSBsb3dlcjQ4XG4gICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40NTUgKiBrLCB5IC0gMC4yMzggKiBrXSwgW3ggKyAwLjQ1NSAqIGssIHkgKyAwLjIzOCAqIGtdXSlcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG5cbiAgICBhbGFza2FQb2ludCA9IGFsYXNrYVxuICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4zMDcgKiBrLCB5ICsgMC4yMDEgKiBrXSlcbiAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40MjUgKiBrICsgZXBzaWxvbiwgeSArIDAuMTIwICogayArIGVwc2lsb25dLCBbeCAtIDAuMjE0ICogayAtIGVwc2lsb24sIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuXG4gICAgaGF3YWlpUG9pbnQgPSBoYXdhaWlcbiAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMjA1ICogaywgeSArIDAuMjEyICoga10pXG4gICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMjE0ICogayArIGVwc2lsb24sIHkgKyAwLjE2NiAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjExNSAqIGsgLSBlcHNpbG9uLCB5ICsgMC4yMzQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcblxuICAgIHJldHVybiByZXNldCgpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5maXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRFeHRlbnQoYWxiZXJzVXNhLCBleHRlbnQsIG9iamVjdCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLmZpdFNpemUgPSBmdW5jdGlvbihzaXplLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0U2l6ZShhbGJlcnNVc2EsIHNpemUsIG9iamVjdCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLmZpdFdpZHRoID0gZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRXaWR0aChhbGJlcnNVc2EsIHdpZHRoLCBvYmplY3QpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5maXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRIZWlnaHQoYWxiZXJzVXNhLCBoZWlnaHQsIG9iamVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgcmV0dXJuIGFsYmVyc1VzYTtcbiAgfVxuXG4gIHJldHVybiBhbGJlcnNVc2Euc2NhbGUoMTA3MCk7XG59XG4iLCJpbXBvcnQge2FzaW4sIGF0YW4yLCBjb3MsIHNpbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGF6aW11dGhhbFJhdyhzY2FsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBjeCA9IGNvcyh4KSxcbiAgICAgICAgY3kgPSBjb3MoeSksXG4gICAgICAgIGsgPSBzY2FsZShjeCAqIGN5KTtcbiAgICAgICAgaWYgKGsgPT09IEluZmluaXR5KSByZXR1cm4gWzIsIDBdO1xuICAgIHJldHVybiBbXG4gICAgICBrICogY3kgKiBzaW4oeCksXG4gICAgICBrICogc2luKHkpXG4gICAgXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXppbXV0aGFsSW52ZXJ0KGFuZ2xlKSB7XG4gIHJldHVybiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHogPSBzcXJ0KHggKiB4ICsgeSAqIHkpLFxuICAgICAgICBjID0gYW5nbGUoeiksXG4gICAgICAgIHNjID0gc2luKGMpLFxuICAgICAgICBjYyA9IGNvcyhjKTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeCAqIHNjLCB6ICogY2MpLFxuICAgICAgYXNpbih6ICYmIHkgKiBzYyAvIHopXG4gICAgXTtcbiAgfVxufVxuIiwiaW1wb3J0IHthc2luLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHthemltdXRoYWxSYXcsIGF6aW11dGhhbEludmVydH0gZnJvbSBcIi4vYXppbXV0aGFsLmpzXCI7XG5pbXBvcnQgcHJvamVjdGlvbiBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgdmFyIGF6aW11dGhhbEVxdWFsQXJlYVJhdyA9IGF6aW11dGhhbFJhdyhmdW5jdGlvbihjeGN5KSB7XG4gIHJldHVybiBzcXJ0KDIgLyAoMSArIGN4Y3kpKTtcbn0pO1xuXG5hemltdXRoYWxFcXVhbEFyZWFSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGZ1bmN0aW9uKHopIHtcbiAgcmV0dXJuIDIgKiBhc2luKHogLyAyKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oYXppbXV0aGFsRXF1YWxBcmVhUmF3KVxuICAgICAgLnNjYWxlKDEyNC43NSlcbiAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG59XG4iLCJpbXBvcnQge2Fjb3MsIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7YXppbXV0aGFsUmF3LCBhemltdXRoYWxJbnZlcnR9IGZyb20gXCIuL2F6aW11dGhhbC5qc1wiO1xuaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IHZhciBhemltdXRoYWxFcXVpZGlzdGFudFJhdyA9IGF6aW11dGhhbFJhdyhmdW5jdGlvbihjKSB7XG4gIHJldHVybiAoYyA9IGFjb3MoYykpICYmIGMgLyBzaW4oYyk7XG59KTtcblxuYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGZ1bmN0aW9uKHopIHtcbiAgcmV0dXJuIHo7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKGF6aW11dGhhbEVxdWlkaXN0YW50UmF3KVxuICAgICAgLnNjYWxlKDc5LjQxODgpXG4gICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xufVxuIiwiaW1wb3J0IHtkZWdyZWVzLCBwaSwgcmFkaWFuc30gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7cHJvamVjdGlvbk11dGF0b3J9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25pY1Byb2plY3Rpb24ocHJvamVjdEF0KSB7XG4gIHZhciBwaGkwID0gMCxcbiAgICAgIHBoaTEgPSBwaSAvIDMsXG4gICAgICBtID0gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSxcbiAgICAgIHAgPSBtKHBoaTAsIHBoaTEpO1xuXG4gIHAucGFyYWxsZWxzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gbShwaGkwID0gX1swXSAqIHJhZGlhbnMsIHBoaTEgPSBfWzFdICogcmFkaWFucykgOiBbcGhpMCAqIGRlZ3JlZXMsIHBoaTEgKiBkZWdyZWVzXTtcbiAgfTtcblxuICByZXR1cm4gcDtcbn1cbiIsImltcG9ydCB7YWJzLCBhdGFuLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBoYWxmUGksIGxvZywgcGksIHBvdywgc2lnbiwgc2luLCBzcXJ0LCB0YW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge2NvbmljUHJvamVjdGlvbn0gZnJvbSBcIi4vY29uaWMuanNcIjtcbmltcG9ydCB7bWVyY2F0b3JSYXd9IGZyb20gXCIuL21lcmNhdG9yLmpzXCI7XG5cbmZ1bmN0aW9uIHRhbnkoeSkge1xuICByZXR1cm4gdGFuKChoYWxmUGkgKyB5KSAvIDIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uaWNDb25mb3JtYWxSYXcoeTAsIHkxKSB7XG4gIHZhciBjeTAgPSBjb3MoeTApLFxuICAgICAgbiA9IHkwID09PSB5MSA/IHNpbih5MCkgOiBsb2coY3kwIC8gY29zKHkxKSkgLyBsb2codGFueSh5MSkgLyB0YW55KHkwKSksXG4gICAgICBmID0gY3kwICogcG93KHRhbnkoeTApLCBuKSAvIG47XG5cbiAgaWYgKCFuKSByZXR1cm4gbWVyY2F0b3JSYXc7XG5cbiAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgaWYgKGYgPiAwKSB7IGlmICh5IDwgLWhhbGZQaSArIGVwc2lsb24pIHkgPSAtaGFsZlBpICsgZXBzaWxvbjsgfVxuICAgIGVsc2UgeyBpZiAoeSA+IGhhbGZQaSAtIGVwc2lsb24pIHkgPSBoYWxmUGkgLSBlcHNpbG9uOyB9XG4gICAgdmFyIHIgPSBmIC8gcG93KHRhbnkoeSksIG4pO1xuICAgIHJldHVybiBbciAqIHNpbihuICogeCksIGYgLSByICogY29zKG4gKiB4KV07XG4gIH1cblxuICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgZnkgPSBmIC0geSwgciA9IHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZnkgKiBmeSksXG4gICAgICBsID0gYXRhbjIoeCwgYWJzKGZ5KSkgKiBzaWduKGZ5KTtcbiAgICBpZiAoZnkgKiBuIDwgMClcbiAgICAgIGwgLT0gcGkgKiBzaWduKHgpICogc2lnbihmeSk7XG4gICAgcmV0dXJuIFtsIC8gbiwgMiAqIGF0YW4ocG93KGYgLyByLCAxIC8gbikpIC0gaGFsZlBpXTtcbiAgfTtcblxuICByZXR1cm4gcHJvamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNDb25mb3JtYWxSYXcpXG4gICAgICAuc2NhbGUoMTA5LjUpXG4gICAgICAucGFyYWxsZWxzKFszMCwgMzBdKTtcbn1cbiIsImltcG9ydCB7YWJzLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBwaSwgc2lnbiwgc2luLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtjb25pY1Byb2plY3Rpb259IGZyb20gXCIuL2NvbmljLmpzXCI7XG5pbXBvcnQge2N5bGluZHJpY2FsRXF1YWxBcmVhUmF3fSBmcm9tIFwiLi9jeWxpbmRyaWNhbEVxdWFsQXJlYS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uaWNFcXVhbEFyZWFSYXcoeTAsIHkxKSB7XG4gIHZhciBzeTAgPSBzaW4oeTApLCBuID0gKHN5MCArIHNpbih5MSkpIC8gMjtcblxuICAvLyBBcmUgdGhlIHBhcmFsbGVscyBzeW1tZXRyaWNhbCBhcm91bmQgdGhlIEVxdWF0b3I/XG4gIGlmIChhYnMobikgPCBlcHNpbG9uKSByZXR1cm4gY3lsaW5kcmljYWxFcXVhbEFyZWFSYXcoeTApO1xuXG4gIHZhciBjID0gMSArIHN5MCAqICgyICogbiAtIHN5MCksIHIwID0gc3FydChjKSAvIG47XG5cbiAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgdmFyIHIgPSBzcXJ0KGMgLSAyICogbiAqIHNpbih5KSkgLyBuO1xuICAgIHJldHVybiBbciAqIHNpbih4ICo9IG4pLCByMCAtIHIgKiBjb3MoeCldO1xuICB9XG5cbiAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHIweSA9IHIwIC0geSxcbiAgICAgICAgbCA9IGF0YW4yKHgsIGFicyhyMHkpKSAqIHNpZ24ocjB5KTtcbiAgICBpZiAocjB5ICogbiA8IDApXG4gICAgICBsIC09IHBpICogc2lnbih4KSAqIHNpZ24ocjB5KTtcbiAgICByZXR1cm4gW2wgLyBuLCBhc2luKChjIC0gKHggKiB4ICsgcjB5ICogcjB5KSAqIG4gKiBuKSAvICgyICogbikpXTtcbiAgfTtcblxuICByZXR1cm4gcHJvamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNFcXVhbEFyZWFSYXcpXG4gICAgICAuc2NhbGUoMTU1LjQyNClcbiAgICAgIC5jZW50ZXIoWzAsIDMzLjY0NDJdKTtcbn1cbiIsImltcG9ydCB7YWJzLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBwaSwgc2lnbiwgc2luLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtjb25pY1Byb2plY3Rpb259IGZyb20gXCIuL2NvbmljLmpzXCI7XG5pbXBvcnQge2VxdWlyZWN0YW5ndWxhclJhd30gZnJvbSBcIi4vZXF1aXJlY3Rhbmd1bGFyLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25pY0VxdWlkaXN0YW50UmF3KHkwLCB5MSkge1xuICB2YXIgY3kwID0gY29zKHkwKSxcbiAgICAgIG4gPSB5MCA9PT0geTEgPyBzaW4oeTApIDogKGN5MCAtIGNvcyh5MSkpIC8gKHkxIC0geTApLFxuICAgICAgZyA9IGN5MCAvIG4gKyB5MDtcblxuICBpZiAoYWJzKG4pIDwgZXBzaWxvbikgcmV0dXJuIGVxdWlyZWN0YW5ndWxhclJhdztcblxuICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICB2YXIgZ3kgPSBnIC0geSwgbnggPSBuICogeDtcbiAgICByZXR1cm4gW2d5ICogc2luKG54KSwgZyAtIGd5ICogY29zKG54KV07XG4gIH1cblxuICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgZ3kgPSBnIC0geSxcbiAgICAgICAgbCA9IGF0YW4yKHgsIGFicyhneSkpICogc2lnbihneSk7XG4gICAgaWYgKGd5ICogbiA8IDApXG4gICAgICBsIC09IHBpICogc2lnbih4KSAqIHNpZ24oZ3kpO1xuICAgIHJldHVybiBbbCAvIG4sIGcgLSBzaWduKG4pICogc3FydCh4ICogeCArIGd5ICogZ3kpXTtcbiAgfTtcblxuICByZXR1cm4gcHJvamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNFcXVpZGlzdGFudFJhdylcbiAgICAgIC5zY2FsZSgxMzEuMTU0KVxuICAgICAgLmNlbnRlcihbMCwgMTMuOTM4OV0pO1xufVxuIiwiaW1wb3J0IHthc2luLCBjb3MsIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHBoaTApIHtcbiAgdmFyIGNvc1BoaTAgPSBjb3MocGhpMCk7XG5cbiAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBbbGFtYmRhICogY29zUGhpMCwgc2luKHBoaSkgLyBjb3NQaGkwXTtcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbeCAvIGNvc1BoaTAsIGFzaW4oeSAqIGNvc1BoaTApXTtcbiAgfTtcblxuICByZXR1cm4gZm9yd2FyZDtcbn1cbiIsImltcG9ydCBwcm9qZWN0aW9uIGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgY29zLCBlcHNpbG9uMiwgc2luLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG52YXIgQTEgPSAxLjM0MDI2NCxcbiAgICBBMiA9IC0wLjA4MTEwNixcbiAgICBBMyA9IDAuMDAwODkzLFxuICAgIEE0ID0gMC4wMDM3OTYsXG4gICAgTSA9IHNxcnQoMykgLyAyLFxuICAgIGl0ZXJhdGlvbnMgPSAxMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsRWFydGhSYXcobGFtYmRhLCBwaGkpIHtcbiAgdmFyIGwgPSBhc2luKE0gKiBzaW4ocGhpKSksIGwyID0gbCAqIGwsIGw2ID0gbDIgKiBsMiAqIGwyO1xuICByZXR1cm4gW1xuICAgIGxhbWJkYSAqIGNvcyhsKSAvIChNICogKEExICsgMyAqIEEyICogbDIgKyBsNiAqICg3ICogQTMgKyA5ICogQTQgKiBsMikpKSxcbiAgICBsICogKEExICsgQTIgKiBsMiArIGw2ICogKEEzICsgQTQgKiBsMikpXG4gIF07XG59XG5cbmVxdWFsRWFydGhSYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgbCA9IHksIGwyID0gbCAqIGwsIGw2ID0gbDIgKiBsMiAqIGwyO1xuICBmb3IgKHZhciBpID0gMCwgZGVsdGEsIGZ5LCBmcHk7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICBmeSA9IGwgKiAoQTEgKyBBMiAqIGwyICsgbDYgKiAoQTMgKyBBNCAqIGwyKSkgLSB5O1xuICAgIGZweSA9IEExICsgMyAqIEEyICogbDIgKyBsNiAqICg3ICogQTMgKyA5ICogQTQgKiBsMik7XG4gICAgbCAtPSBkZWx0YSA9IGZ5IC8gZnB5LCBsMiA9IGwgKiBsLCBsNiA9IGwyICogbDIgKiBsMjtcbiAgICBpZiAoYWJzKGRlbHRhKSA8IGVwc2lsb24yKSBicmVhaztcbiAgfVxuICByZXR1cm4gW1xuICAgIE0gKiB4ICogKEExICsgMyAqIEEyICogbDIgKyBsNiAqICg3ICogQTMgKyA5ICogQTQgKiBsMikpIC8gY29zKGwpLFxuICAgIGFzaW4oc2luKGwpIC8gTSlcbiAgXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihlcXVhbEVhcnRoUmF3KVxuICAgICAgLnNjYWxlKDE3Ny4xNTgpO1xufVxuIiwiaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWlyZWN0YW5ndWxhclJhdyhsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2xhbWJkYSwgcGhpXTtcbn1cblxuZXF1aXJlY3Rhbmd1bGFyUmF3LmludmVydCA9IGVxdWlyZWN0YW5ndWxhclJhdztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKGVxdWlyZWN0YW5ndWxhclJhdylcbiAgICAgIC5zY2FsZSgxNTIuNjMpO1xufVxuIiwiaW1wb3J0IHtkZWZhdWx0IGFzIGdlb1N0cmVhbX0gZnJvbSBcIi4uL3N0cmVhbS5qc1wiO1xuaW1wb3J0IGJvdW5kc1N0cmVhbSBmcm9tIFwiLi4vcGF0aC9ib3VuZHMuanNcIjtcblxuZnVuY3Rpb24gZml0KHByb2plY3Rpb24sIGZpdEJvdW5kcywgb2JqZWN0KSB7XG4gIHZhciBjbGlwID0gcHJvamVjdGlvbi5jbGlwRXh0ZW50ICYmIHByb2plY3Rpb24uY2xpcEV4dGVudCgpO1xuICBwcm9qZWN0aW9uLnNjYWxlKDE1MCkudHJhbnNsYXRlKFswLCAwXSk7XG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChudWxsKTtcbiAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvbi5zdHJlYW0oYm91bmRzU3RyZWFtKSk7XG4gIGZpdEJvdW5kcyhib3VuZHNTdHJlYW0ucmVzdWx0KCkpO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoY2xpcCk7XG4gIHJldHVybiBwcm9qZWN0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciB3ID0gZXh0ZW50WzFdWzBdIC0gZXh0ZW50WzBdWzBdLFxuICAgICAgICBoID0gZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdLFxuICAgICAgICBrID0gTWF0aC5taW4odyAvIChiWzFdWzBdIC0gYlswXVswXSksIGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pKSxcbiAgICAgICAgeCA9ICtleHRlbnRbMF1bMF0gKyAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsXG4gICAgICAgIHkgPSArZXh0ZW50WzBdWzFdICsgKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCkge1xuICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIFtbMCwgMF0sIHNpemVdLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9ICt3aWR0aCxcbiAgICAgICAgayA9IHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLFxuICAgICAgICB4ID0gKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gLWsgKiBiWzBdWzFdO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIGggPSAraGVpZ2h0LFxuICAgICAgICBrID0gaCAvIChiWzFdWzFdIC0gYlswXVsxXSksXG4gICAgICAgIHggPSAtayAqIGJbMF1bMF0sXG4gICAgICAgIHkgPSAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cbiIsImltcG9ydCB7YXRhbiwgY29zLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge2F6aW11dGhhbEludmVydH0gZnJvbSBcIi4vYXppbXV0aGFsLmpzXCI7XG5pbXBvcnQgcHJvamVjdGlvbiBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ25vbW9uaWNSYXcoeCwgeSkge1xuICB2YXIgY3kgPSBjb3MoeSksIGsgPSBjb3MoeCkgKiBjeTtcbiAgcmV0dXJuIFtjeSAqIHNpbih4KSAvIGssIHNpbih5KSAvIGtdO1xufVxuXG5nbm9tb25pY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXRhbik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihnbm9tb25pY1JhdylcbiAgICAgIC5zY2FsZSgxNDQuMDQ5KVxuICAgICAgLmNsaXBBbmdsZSg2MCk7XG59XG4iLCJpbXBvcnQgY2xpcFJlY3RhbmdsZSBmcm9tIFwiLi4vY2xpcC9yZWN0YW5nbGUuanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCB7dHJhbnNmb3JtZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCB7Zml0RXh0ZW50LCBmaXRTaXplLCBmaXRXaWR0aCwgZml0SGVpZ2h0fSBmcm9tIFwiLi9maXQuanNcIjtcbmltcG9ydCB7Y29zLCBkZWdyZWVzLCByYWRpYW5zLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgayA9IDEsIHR4ID0gMCwgdHkgPSAwLCBzeCA9IDEsIHN5ID0gMSwgLy8gc2NhbGUsIHRyYW5zbGF0ZSBhbmQgcmVmbGVjdFxuICAgICAgYWxwaGEgPSAwLCBjYSwgc2EsIC8vIGFuZ2xlXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTEsIC8vIGNsaXAgZXh0ZW50XG4gICAgICBreCA9IDEsIGt5ID0gMSxcbiAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybWVyKHtcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICB2YXIgcCA9IHByb2plY3Rpb24oW3gsIHldKVxuICAgICAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHBbMF0sIHBbMV0pO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHBvc3RjbGlwID0gaWRlbnRpdHksXG4gICAgICBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGt4ID0gayAqIHN4O1xuICAgIGt5ID0gayAqIHN5O1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvamVjdGlvbiAocCkge1xuICAgIHZhciB4ID0gcFswXSAqIGt4LCB5ID0gcFsxXSAqIGt5O1xuICAgIGlmIChhbHBoYSkge1xuICAgICAgdmFyIHQgPSB5ICogY2EgLSB4ICogc2E7XG4gICAgICB4ID0geCAqIGNhICsgeSAqIHNhO1xuICAgICAgeSA9IHQ7XG4gICAgfSAgICBcbiAgICByZXR1cm4gW3ggKyB0eCwgeSArIHR5XTtcbiAgfVxuICBwcm9qZWN0aW9uLmludmVydCA9IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgeCA9IHBbMF0gLSB0eCwgeSA9IHBbMV0gLSB0eTtcbiAgICBpZiAoYWxwaGEpIHtcbiAgICAgIHZhciB0ID0geSAqIGNhICsgeCAqIHNhO1xuICAgICAgeCA9IHggKiBjYSAtIHkgKiBzYTtcbiAgICAgIHkgPSB0O1xuICAgIH1cbiAgICByZXR1cm4gW3ggLyBreCwgeSAvIGt5XTtcbiAgfTtcbiAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm0ocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKTtcbiAgfTtcbiAgcHJvamVjdGlvbi5wb3N0Y2xpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcbiAgfTtcbiAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkpIDogY2xpcFJlY3RhbmdsZSh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVzZXQoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICB9O1xuICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVzZXQoKSkgOiBrO1xuICB9O1xuICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eCA9ICtfWzBdLCB0eSA9ICtfWzFdLCByZXNldCgpKSA6IFt0eCwgdHldO1xuICB9XG4gIHByb2plY3Rpb24uYW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSBfICUgMzYwICogcmFkaWFucywgc2EgPSBzaW4oYWxwaGEpLCBjYSA9IGNvcyhhbHBoYSksIHJlc2V0KCkpIDogYWxwaGEgKiBkZWdyZWVzO1xuICB9O1xuICBwcm9qZWN0aW9uLnJlZmxlY3RYID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN4ID0gXyA/IC0xIDogMSwgcmVzZXQoKSkgOiBzeCA8IDA7XG4gIH07XG4gIHByb2plY3Rpb24ucmVmbGVjdFkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3kgPSBfID8gLTEgOiAxLCByZXNldCgpKSA6IHN5IDwgMDtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdFNpemUgPSBmdW5jdGlvbihzaXplLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdFdpZHRoID0gZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KTtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0aW9uO1xufVxuIiwiaW1wb3J0IGNsaXBBbnRpbWVyaWRpYW4gZnJvbSBcIi4uL2NsaXAvYW50aW1lcmlkaWFuLmpzXCI7XG5pbXBvcnQgY2xpcENpcmNsZSBmcm9tIFwiLi4vY2xpcC9jaXJjbGUuanNcIjtcbmltcG9ydCBjbGlwUmVjdGFuZ2xlIGZyb20gXCIuLi9jbGlwL3JlY3RhbmdsZS5qc1wiO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSBcIi4uL2NvbXBvc2UuanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCB7Y29zLCBkZWdyZWVzLCByYWRpYW5zLCBzaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge3JvdGF0ZVJhZGlhbnN9IGZyb20gXCIuLi9yb3RhdGlvbi5qc1wiO1xuaW1wb3J0IHt0cmFuc2Zvcm1lcn0gZnJvbSBcIi4uL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IHtmaXRFeHRlbnQsIGZpdFNpemUsIGZpdFdpZHRoLCBmaXRIZWlnaHR9IGZyb20gXCIuL2ZpdC5qc1wiO1xuaW1wb3J0IHJlc2FtcGxlIGZyb20gXCIuL3Jlc2FtcGxlLmpzXCI7XG5cbnZhciB0cmFuc2Zvcm1SYWRpYW5zID0gdHJhbnNmb3JtZXIoe1xuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKiByYWRpYW5zLCB5ICogcmFkaWFucyk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Sb3RhdGUocm90YXRlKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciByID0gcm90YXRlKHgsIHkpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBvaW50KHJbMF0sIHJbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlKGssIGR4LCBkeSwgc3gsIHN5KSB7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybSh4LCB5KSB7XG4gICAgeCAqPSBzeDsgeSAqPSBzeTtcbiAgICByZXR1cm4gW2R4ICsgayAqIHgsIGR5IC0gayAqIHldO1xuICB9XG4gIHRyYW5zZm9ybS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsoeCAtIGR4KSAvIGsgKiBzeCwgKGR5IC0geSkgLyBrICogc3ldO1xuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCBkeCwgZHksIHN4LCBzeSwgYWxwaGEpIHtcbiAgaWYgKCFhbHBoYSkgcmV0dXJuIHNjYWxlVHJhbnNsYXRlKGssIGR4LCBkeSwgc3gsIHN5KTtcbiAgdmFyIGNvc0FscGhhID0gY29zKGFscGhhKSxcbiAgICAgIHNpbkFscGhhID0gc2luKGFscGhhKSxcbiAgICAgIGEgPSBjb3NBbHBoYSAqIGssXG4gICAgICBiID0gc2luQWxwaGEgKiBrLFxuICAgICAgYWkgPSBjb3NBbHBoYSAvIGssXG4gICAgICBiaSA9IHNpbkFscGhhIC8gayxcbiAgICAgIGNpID0gKHNpbkFscGhhICogZHkgLSBjb3NBbHBoYSAqIGR4KSAvIGssXG4gICAgICBmaSA9IChzaW5BbHBoYSAqIGR4ICsgY29zQWxwaGEgKiBkeSkgLyBrO1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgIHggKj0gc3g7IHkgKj0gc3k7XG4gICAgcmV0dXJuIFthICogeCAtIGIgKiB5ICsgZHgsIGR5IC0gYiAqIHggLSBhICogeV07XG4gIH1cbiAgdHJhbnNmb3JtLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gW3N4ICogKGFpICogeCAtIGJpICogeSArIGNpKSwgc3kgKiAoZmkgLSBiaSAqIHggLSBhaSAqIHkpXTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvamVjdGlvbihwcm9qZWN0KSB7XG4gIHJldHVybiBwcm9qZWN0aW9uTXV0YXRvcihmdW5jdGlvbigpIHsgcmV0dXJuIHByb2plY3Q7IH0pKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpIHtcbiAgdmFyIHByb2plY3QsXG4gICAgICBrID0gMTUwLCAvLyBzY2FsZVxuICAgICAgeCA9IDQ4MCwgeSA9IDI1MCwgLy8gdHJhbnNsYXRlXG4gICAgICBsYW1iZGEgPSAwLCBwaGkgPSAwLCAvLyBjZW50ZXJcbiAgICAgIGRlbHRhTGFtYmRhID0gMCwgZGVsdGFQaGkgPSAwLCBkZWx0YUdhbW1hID0gMCwgcm90YXRlLCAvLyBwcmUtcm90YXRlXG4gICAgICBhbHBoYSA9IDAsIC8vIHBvc3Qtcm90YXRlIGFuZ2xlXG4gICAgICBzeCA9IDEsIC8vIHJlZmxlY3RYXG4gICAgICBzeSA9IDEsIC8vIHJlZmxlY3RYXG4gICAgICB0aGV0YSA9IG51bGwsIHByZWNsaXAgPSBjbGlwQW50aW1lcmlkaWFuLCAvLyBwcmUtY2xpcCBhbmdsZVxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCBwb3N0Y2xpcCA9IGlkZW50aXR5LCAvLyBwb3N0LWNsaXAgZXh0ZW50XG4gICAgICBkZWx0YTIgPSAwLjUsIC8vIHByZWNpc2lvblxuICAgICAgcHJvamVjdFJlc2FtcGxlLFxuICAgICAgcHJvamVjdFRyYW5zZm9ybSxcbiAgICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0sXG4gICAgICBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gcHJvamVjdFJvdGF0ZVRyYW5zZm9ybShwb2ludFswXSAqIHJhZGlhbnMsIHBvaW50WzFdICogcmFkaWFucyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZlcnQocG9pbnQpIHtcbiAgICBwb2ludCA9IHByb2plY3RSb3RhdGVUcmFuc2Zvcm0uaW52ZXJ0KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgcmV0dXJuIHBvaW50ICYmIFtwb2ludFswXSAqIGRlZ3JlZXMsIHBvaW50WzFdICogZGVncmVlc107XG4gIH1cblxuICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybVJhZGlhbnModHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkocHJlY2xpcChwcm9qZWN0UmVzYW1wbGUocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKSkpKTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnByZWNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9IF8sIHRoZXRhID0gdW5kZWZpbmVkLCByZXNldCgpKSA6IHByZWNsaXA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wb3N0Y2xpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gK18gPyBjbGlwQ2lyY2xlKHRoZXRhID0gXyAqIHJhZGlhbnMpIDogKHRoZXRhID0gbnVsbCwgY2xpcEFudGltZXJpZGlhbiksIHJlc2V0KCkpIDogdGhldGEgKiBkZWdyZWVzO1xuICB9O1xuXG4gIHByb2plY3Rpb24uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8gPT0gbnVsbCA/ICh4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIGlkZW50aXR5KSA6IGNsaXBSZWN0YW5nbGUoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVjZW50ZXIoKSkgOiBrO1xuICB9O1xuXG4gIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArX1swXSwgeSA9ICtfWzFdLCByZWNlbnRlcigpKSA6IFt4LCB5XTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgcGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIHJlY2VudGVyKCkpIDogW2xhbWJkYSAqIGRlZ3JlZXMsIHBoaSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlbHRhTGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhUGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhR2FtbWEgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogcmFkaWFucyA6IDAsIHJlY2VudGVyKCkpIDogW2RlbHRhTGFtYmRhICogZGVncmVlcywgZGVsdGFQaGkgKiBkZWdyZWVzLCBkZWx0YUdhbW1hICogZGVncmVlc107XG4gIH07XG5cbiAgcHJvamVjdGlvbi5hbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9IF8gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IGFscGhhICogZGVncmVlcztcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJlZmxlY3RYID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN4ID0gXyA/IC0xIDogMSwgcmVjZW50ZXIoKSkgOiBzeCA8IDA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5yZWZsZWN0WSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeSA9IF8gPyAtMSA6IDEsIHJlY2VudGVyKCkpIDogc3kgPCAwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMiA9IF8gKiBfKSwgcmVzZXQoKSkgOiBzcXJ0KGRlbHRhMik7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlY2VudGVyKCkge1xuICAgIHZhciBjZW50ZXIgPSBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCAwLCAwLCBzeCwgc3ksIGFscGhhKS5hcHBseShudWxsLCBwcm9qZWN0KGxhbWJkYSwgcGhpKSksXG4gICAgICAgIHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIHggLSBjZW50ZXJbMF0sIHkgLSBjZW50ZXJbMV0sIHN4LCBzeSwgYWxwaGEpO1xuICAgIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKTtcbiAgICBwcm9qZWN0VHJhbnNmb3JtID0gY29tcG9zZShwcm9qZWN0LCB0cmFuc2Zvcm0pO1xuICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0gPSBjb21wb3NlKHJvdGF0ZSwgcHJvamVjdFRyYW5zZm9ybSk7XG4gICAgcHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyKTtcbiAgICByZXR1cm4gcmVzZXQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHByb2plY3QgPSBwcm9qZWN0QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBwcm9qZWN0aW9uLmludmVydCA9IHByb2plY3QuaW52ZXJ0ICYmIGludmVydDtcbiAgICByZXR1cm4gcmVjZW50ZXIoKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7YXRhbiwgZXhwLCBoYWxmUGksIGxvZywgcGksIHRhbiwgdGF1fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHJvdGF0aW9uIGZyb20gXCIuLi9yb3RhdGlvbi5qc1wiO1xuaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmNhdG9yUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbbGFtYmRhLCBsb2codGFuKChoYWxmUGkgKyBwaGkpIC8gMikpXTtcbn1cblxubWVyY2F0b3JSYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gW3gsIDIgKiBhdGFuKGV4cCh5KSkgLSBoYWxmUGldO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBtZXJjYXRvclByb2plY3Rpb24obWVyY2F0b3JSYXcpXG4gICAgICAuc2NhbGUoOTYxIC8gdGF1KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmNhdG9yUHJvamVjdGlvbihwcm9qZWN0KSB7XG4gIHZhciBtID0gcHJvamVjdGlvbihwcm9qZWN0KSxcbiAgICAgIGNlbnRlciA9IG0uY2VudGVyLFxuICAgICAgc2NhbGUgPSBtLnNjYWxlLFxuICAgICAgdHJhbnNsYXRlID0gbS50cmFuc2xhdGUsXG4gICAgICBjbGlwRXh0ZW50ID0gbS5jbGlwRXh0ZW50LFxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxOyAvLyBjbGlwIGV4dGVudFxuXG4gIG0uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGUoXyksIHJlY2xpcCgpKSA6IHNjYWxlKCk7XG4gIH07XG5cbiAgbS50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNsYXRlKF8pLCByZWNsaXAoKSkgOiB0cmFuc2xhdGUoKTtcbiAgfTtcblxuICBtLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjZW50ZXIoXyksIHJlY2xpcCgpKSA6IGNlbnRlcigpO1xuICB9O1xuXG4gIG0uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoXyA9PSBudWxsID8geDAgPSB5MCA9IHgxID0geTEgPSBudWxsIDogKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pKSwgcmVjbGlwKCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWNsaXAoKSB7XG4gICAgdmFyIGsgPSBwaSAqIHNjYWxlKCksXG4gICAgICAgIHQgPSBtKHJvdGF0aW9uKG0ucm90YXRlKCkpLmludmVydChbMCwgMF0pKTtcbiAgICByZXR1cm4gY2xpcEV4dGVudCh4MCA9PSBudWxsXG4gICAgICAgID8gW1t0WzBdIC0gaywgdFsxXSAtIGtdLCBbdFswXSArIGssIHRbMV0gKyBrXV0gOiBwcm9qZWN0ID09PSBtZXJjYXRvclJhd1xuICAgICAgICA/IFtbTWF0aC5tYXgodFswXSAtIGssIHgwKSwgeTBdLCBbTWF0aC5taW4odFswXSArIGssIHgxKSwgeTFdXVxuICAgICAgICA6IFtbeDAsIE1hdGgubWF4KHRbMV0gLSBrLCB5MCldLCBbeDEsIE1hdGgubWluKHRbMV0gKyBrLCB5MSldXSk7XG4gIH1cblxuICByZXR1cm4gcmVjbGlwKCk7XG59XG4iLCJpbXBvcnQgcHJvamVjdGlvbiBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHthYnMsIGVwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXR1cmFsRWFydGgxUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHZhciBwaGkyID0gcGhpICogcGhpLCBwaGk0ID0gcGhpMiAqIHBoaTI7XG4gIHJldHVybiBbXG4gICAgbGFtYmRhICogKDAuODcwNyAtIDAuMTMxOTc5ICogcGhpMiArIHBoaTQgKiAoLTAuMDEzNzkxICsgcGhpNCAqICgwLjAwMzk3MSAqIHBoaTIgLSAwLjAwMTUyOSAqIHBoaTQpKSksXG4gICAgcGhpICogKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSArIHBoaTQgKiAoLTAuMDQ0NDc1ICsgMC4wMjg4NzQgKiBwaGkyIC0gMC4wMDU5MTYgKiBwaGk0KSkpXG4gIF07XG59XG5cbm5hdHVyYWxFYXJ0aDFSYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgcGhpID0geSwgaSA9IDI1LCBkZWx0YTtcbiAgZG8ge1xuICAgIHZhciBwaGkyID0gcGhpICogcGhpLCBwaGk0ID0gcGhpMiAqIHBoaTI7XG4gICAgcGhpIC09IGRlbHRhID0gKHBoaSAqICgxLjAwNzIyNiArIHBoaTIgKiAoMC4wMTUwODUgKyBwaGk0ICogKC0wLjA0NDQ3NSArIDAuMDI4ODc0ICogcGhpMiAtIDAuMDA1OTE2ICogcGhpNCkpKSAtIHkpIC9cbiAgICAgICAgKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSAqIDMgKyBwaGk0ICogKC0wLjA0NDQ3NSAqIDcgKyAwLjAyODg3NCAqIDkgKiBwaGkyIC0gMC4wMDU5MTYgKiAxMSAqIHBoaTQpKSk7XG4gIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICByZXR1cm4gW1xuICAgIHggLyAoMC44NzA3ICsgKHBoaTIgPSBwaGkgKiBwaGkpICogKC0wLjEzMTk3OSArIHBoaTIgKiAoLTAuMDEzNzkxICsgcGhpMiAqIHBoaTIgKiBwaGkyICogKDAuMDAzOTcxIC0gMC4wMDE1MjkgKiBwaGkyKSkpKSxcbiAgICBwaGlcbiAgXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihuYXR1cmFsRWFydGgxUmF3KVxuICAgICAgLnNjYWxlKDE3NS4yOTUpO1xufVxuIiwiaW1wb3J0IHthc2luLCBjb3MsIGVwc2lsb24sIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7YXppbXV0aGFsSW52ZXJ0fSBmcm9tIFwiLi9hemltdXRoYWwuanNcIjtcbmltcG9ydCBwcm9qZWN0aW9uIGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBvcnRob2dyYXBoaWNSYXcoeCwgeSkge1xuICByZXR1cm4gW2Nvcyh5KSAqIHNpbih4KSwgc2luKHkpXTtcbn1cblxub3J0aG9ncmFwaGljUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChhc2luKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKG9ydGhvZ3JhcGhpY1JhdylcbiAgICAgIC5zY2FsZSgyNDkuNSlcbiAgICAgIC5jbGlwQW5nbGUoOTAgKyBlcHNpbG9uKTtcbn1cbiIsImltcG9ydCB7Y2FydGVzaWFufSBmcm9tIFwiLi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgcmFkaWFucywgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7dHJhbnNmb3JtZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm0uanNcIjtcblxudmFyIG1heERlcHRoID0gMTYsIC8vIG1heGltdW0gZGVwdGggb2Ygc3ViZGl2aXNpb25cbiAgICBjb3NNaW5EaXN0YW5jZSA9IGNvcygzMCAqIHJhZGlhbnMpOyAvLyBjb3MobWluaW11bSBhbmd1bGFyIGRpc3RhbmNlKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwcm9qZWN0LCBkZWx0YTIpIHtcbiAgcmV0dXJuICtkZWx0YTIgPyByZXNhbXBsZShwcm9qZWN0LCBkZWx0YTIpIDogcmVzYW1wbGVOb25lKHByb2plY3QpO1xufVxuXG5mdW5jdGlvbiByZXNhbXBsZU5vbmUocHJvamVjdCkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2FtcGxlKHByb2plY3QsIGRlbHRhMikge1xuXG4gIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKSB7XG4gICAgdmFyIGR4ID0geDEgLSB4MCxcbiAgICAgICAgZHkgPSB5MSAtIHkwLFxuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGlmIChkMiA+IDQgKiBkZWx0YTIgJiYgZGVwdGgtLSkge1xuICAgICAgdmFyIGEgPSBhMCArIGExLFxuICAgICAgICAgIGIgPSBiMCArIGIxLFxuICAgICAgICAgIGMgPSBjMCArIGMxLFxuICAgICAgICAgIG0gPSBzcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYyksXG4gICAgICAgICAgcGhpMiA9IGFzaW4oYyAvPSBtKSxcbiAgICAgICAgICBsYW1iZGEyID0gYWJzKGFicyhjKSAtIDEpIDwgZXBzaWxvbiB8fCBhYnMobGFtYmRhMCAtIGxhbWJkYTEpIDwgZXBzaWxvbiA/IChsYW1iZGEwICsgbGFtYmRhMSkgLyAyIDogYXRhbjIoYiwgYSksXG4gICAgICAgICAgcCA9IHByb2plY3QobGFtYmRhMiwgcGhpMiksXG4gICAgICAgICAgeDIgPSBwWzBdLFxuICAgICAgICAgIHkyID0gcFsxXSxcbiAgICAgICAgICBkeDIgPSB4MiAtIHgwLFxuICAgICAgICAgIGR5MiA9IHkyIC0geTAsXG4gICAgICAgICAgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgaWYgKGR6ICogZHogLyBkMiA+IGRlbHRhMiAvLyBwZXJwZW5kaWN1bGFyIHByb2plY3RlZCBkaXN0YW5jZVxuICAgICAgICAgIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIDAuNSkgPiAwLjMgLy8gbWlkcG9pbnQgY2xvc2UgdG8gYW4gZW5kXG4gICAgICAgICAgfHwgYTAgKiBhMSArIGIwICogYjEgKyBjMCAqIGMxIDwgY29zTWluRGlzdGFuY2UpIHsgLy8gYW5ndWxhciBkaXN0YW5jZVxuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgbGFtYmRhMiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeDIsIHkyKTtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCBsYW1iZGEyLCBhLCBiLCBjLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGxhbWJkYTAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgbGFtYmRhMCwgeDAsIHkwLCBhMCwgYjAsIGMwOyAvLyBwcmV2aW91cyBwb2ludFxuXG4gICAgdmFyIHJlc2FtcGxlU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25TdGFydCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSByaW5nU3RhcnQ7IH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25FbmQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gbGluZVN0YXJ0OyB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIHgwID0gTmFOO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICB2YXIgYyA9IGNhcnRlc2lhbihbbGFtYmRhLCBwaGldKSwgcCA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgbGFtYmRhMCA9IGxhbWJkYSwgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZVBvaW50KGxhbWJkYTAwID0gbGFtYmRhLCBwaGkpLCB4MDAgPSB4MCwgeTAwID0geTAsIGEwMCA9IGEwLCBiMDAgPSBiMCwgYzAwID0gYzA7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgbGFtYmRhMDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICBsaW5lRW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2FtcGxlU3RyZWFtO1xuICB9O1xufVxuIiwiaW1wb3J0IHthdGFuLCBjb3MsIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7YXppbXV0aGFsSW52ZXJ0fSBmcm9tIFwiLi9hemltdXRoYWwuanNcIjtcbmltcG9ydCBwcm9qZWN0aW9uIGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVyZW9ncmFwaGljUmF3KHgsIHkpIHtcbiAgdmFyIGN5ID0gY29zKHkpLCBrID0gMSArIGNvcyh4KSAqIGN5O1xuICByZXR1cm4gW2N5ICogc2luKHgpIC8gaywgc2luKHkpIC8ga107XG59XG5cbnN0ZXJlb2dyYXBoaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGZ1bmN0aW9uKHopIHtcbiAgcmV0dXJuIDIgKiBhdGFuKHopO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihzdGVyZW9ncmFwaGljUmF3KVxuICAgICAgLnNjYWxlKDI1MClcbiAgICAgIC5jbGlwQW5nbGUoMTQyKTtcbn1cbiIsImltcG9ydCB7YXRhbiwgZXhwLCBoYWxmUGksIGxvZywgdGFufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHttZXJjYXRvclByb2plY3Rpb259IGZyb20gXCIuL21lcmNhdG9yLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3ZlcnNlTWVyY2F0b3JSYXcobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFtsb2codGFuKChoYWxmUGkgKyBwaGkpIC8gMikpLCAtbGFtYmRhXTtcbn1cblxudHJhbnN2ZXJzZU1lcmNhdG9yUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIFsteSwgMiAqIGF0YW4oZXhwKHgpKSAtIGhhbGZQaV07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG0gPSBtZXJjYXRvclByb2plY3Rpb24odHJhbnN2ZXJzZU1lcmNhdG9yUmF3KSxcbiAgICAgIGNlbnRlciA9IG0uY2VudGVyLFxuICAgICAgcm90YXRlID0gbS5yb3RhdGU7XG5cbiAgbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjZW50ZXIoWy1fWzFdLCBfWzBdXSkgOiAoXyA9IGNlbnRlcigpLCBbX1sxXSwgLV9bMF1dKTtcbiAgfTtcblxuICBtLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJvdGF0ZShbX1swXSwgX1sxXSwgXy5sZW5ndGggPiAyID8gX1syXSArIDkwIDogOTBdKSA6IChfID0gcm90YXRlKCksIFtfWzBdLCBfWzFdLCBfWzJdIC0gOTBdKTtcbiAgfTtcblxuICByZXR1cm4gcm90YXRlKFswLCAwLCA5MF0pXG4gICAgICAuc2NhbGUoMTU5LjE1NSk7XG59XG4iLCJpbXBvcnQgY29tcG9zZSBmcm9tIFwiLi9jb21wb3NlLmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZGVncmVlcywgcGksIHJhZGlhbnMsIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHJvdGF0aW9uSWRlbnRpdHkobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFthYnMobGFtYmRhKSA+IHBpID8gbGFtYmRhICsgTWF0aC5yb3VuZCgtbGFtYmRhIC8gdGF1KSAqIHRhdSA6IGxhbWJkYSwgcGhpXTtcbn1cblxucm90YXRpb25JZGVudGl0eS5pbnZlcnQgPSByb3RhdGlvbklkZW50aXR5O1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlUmFkaWFucyhkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcbiAgcmV0dXJuIChkZWx0YUxhbWJkYSAlPSB0YXUpID8gKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyBjb21wb3NlKHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSwgcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkpXG4gICAgOiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkpXG4gICAgOiAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpXG4gICAgOiByb3RhdGlvbklkZW50aXR5KTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gIHJldHVybiBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBsYW1iZGEgKz0gZGVsdGFMYW1iZGEsIFtsYW1iZGEgPiBwaSA/IGxhbWJkYSAtIHRhdSA6IGxhbWJkYSA8IC1waSA/IGxhbWJkYSArIHRhdSA6IGxhbWJkYSwgcGhpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgdmFyIHJvdGF0aW9uID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKTtcbiAgcm90YXRpb24uaW52ZXJ0ID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKC1kZWx0YUxhbWJkYSk7XG4gIHJldHVybiByb3RhdGlvbjtcbn1cblxuZnVuY3Rpb24gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICB2YXIgY29zRGVsdGFQaGkgPSBjb3MoZGVsdGFQaGkpLFxuICAgICAgc2luRGVsdGFQaGkgPSBzaW4oZGVsdGFQaGkpLFxuICAgICAgY29zRGVsdGFHYW1tYSA9IGNvcyhkZWx0YUdhbW1hKSxcbiAgICAgIHNpbkRlbHRhR2FtbWEgPSBzaW4oZGVsdGFHYW1tYSk7XG5cbiAgZnVuY3Rpb24gcm90YXRpb24obGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICAgIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB6ID0gc2luKHBoaSksXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFQaGkgKyB4ICogc2luRGVsdGFQaGk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hIC0gayAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSAtIHogKiBzaW5EZWx0YVBoaSksXG4gICAgICBhc2luKGsgKiBjb3NEZWx0YUdhbW1hICsgeSAqIHNpbkRlbHRhR2FtbWEpXG4gICAgXTtcbiAgfVxuXG4gIHJvdGF0aW9uLmludmVydCA9IGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgICB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgICBrID0geiAqIGNvc0RlbHRhR2FtbWEgLSB5ICogc2luRGVsdGFHYW1tYTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgKyB6ICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpICsgayAqIHNpbkRlbHRhUGhpKSxcbiAgICAgIGFzaW4oayAqIGNvc0RlbHRhUGhpIC0geCAqIHNpbkRlbHRhUGhpKVxuICAgIF07XG4gIH07XG5cbiAgcmV0dXJuIHJvdGF0aW9uO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyb3RhdGUpIHtcbiAgcm90YXRlID0gcm90YXRlUmFkaWFucyhyb3RhdGVbMF0gKiByYWRpYW5zLCByb3RhdGVbMV0gKiByYWRpYW5zLCByb3RhdGUubGVuZ3RoID4gMiA/IHJvdGF0ZVsyXSAqIHJhZGlhbnMgOiAwKTtcblxuICBmdW5jdGlvbiBmb3J3YXJkKGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXMgPSByb3RhdGUoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlcztcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcyA9IHJvdGF0ZS5pbnZlcnQoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlcztcbiAgfTtcblxuICByZXR1cm4gZm9yd2FyZDtcbn1cbiIsImZ1bmN0aW9uIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJ5LCBzdHJlYW0pIHtcbiAgaWYgKGdlb21ldHJ5ICYmIHN0cmVhbUdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKSkge1xuICAgIHN0cmVhbUdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgc3RyZWFtKTtcbiAgfVxufVxuXG52YXIgc3RyZWFtT2JqZWN0VHlwZSA9IHtcbiAgRmVhdHVyZTogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QuZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH0sXG4gIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBmZWF0dXJlcyA9IG9iamVjdC5mZWF0dXJlcywgaSA9IC0xLCBuID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShmZWF0dXJlc1tpXS5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgfVxufTtcblxudmFyIHN0cmVhbUdlb21ldHJ5VHlwZSA9IHtcbiAgU3BoZXJlOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbS5zcGhlcmUoKTtcbiAgfSxcbiAgUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0LmNvb3JkaW5hdGVzO1xuICAgIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgfSxcbiAgTXVsdGlQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgb2JqZWN0ID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgfSxcbiAgTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1MaW5lKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtLCAwKTtcbiAgfSxcbiAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDApO1xuICB9LFxuICBQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbVBvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0pO1xuICB9LFxuICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSk7XG4gIH0sXG4gIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgc3RyZWFtKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyZWFtTGluZShjb29yZGluYXRlcywgc3RyZWFtLCBjbG9zZWQpIHtcbiAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIGNsb3NlZCwgY29vcmRpbmF0ZTtcbiAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICB3aGlsZSAoKytpIDwgbikgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQoY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVsyXSk7XG4gIHN0cmVhbS5saW5lRW5kKCk7XG59XG5cbmZ1bmN0aW9uIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXMsIHN0cmVhbSkge1xuICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDEpO1xuICBzdHJlYW0ucG9seWdvbkVuZCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICBpZiAob2JqZWN0ICYmIHN0cmVhbU9iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpKSB7XG4gICAgc3RyZWFtT2JqZWN0VHlwZVtvYmplY3QudHlwZV0ob2JqZWN0LCBzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdCwgc3RyZWFtKTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWV0aG9kcykge1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogdHJhbnNmb3JtZXIobWV0aG9kcylcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybWVyKG1ldGhvZHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBzID0gbmV3IFRyYW5zZm9ybVN0cmVhbTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykgc1trZXldID0gbWV0aG9kc1trZXldO1xuICAgIHMuc3RyZWFtID0gc3RyZWFtO1xuICAgIHJldHVybiBzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW0oKSB7fVxuXG5UcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNmb3JtU3RyZWFtLFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLnN0cmVhbS5wb2ludCh4LCB5KTsgfSxcbiAgc3BoZXJlOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0uc3BoZXJlKCk7IH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLmxpbmVTdGFydCgpOyB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ubGluZUVuZCgpOyB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uU3RhcnQoKTsgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25FbmQoKTsgfVxufTtcbiIsImltcG9ydCB2YWx1ZSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuaW1wb3J0IG51bWJlckFycmF5LCB7aXNOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gKGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheSA6IGdlbmVyaWNBcnJheSkoYSwgYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmljQXJyYXkoYSwgYikge1xuICB2YXIgbmIgPSBiID8gYi5sZW5ndGggOiAwLFxuICAgICAgbmEgPSBhID8gTWF0aC5taW4obmIsIGEubGVuZ3RoKSA6IDAsXG4gICAgICB4ID0gbmV3IEFycmF5KG5hKSxcbiAgICAgIGMgPSBuZXcgQXJyYXkobmIpLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgeFtpXSA9IHZhbHVlKGFbaV0sIGJbaV0pO1xuICBmb3IgKDsgaSA8IG5iOyArK2kpIGNbaV0gPSBiW2ldO1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGJhc2lzKHQxLCB2MCwgdjEsIHYyLCB2Mykge1xuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XG4gIHJldHVybiAoKDEgLSAzICogdDEgKyAzICogdDIgLSB0MykgKiB2MFxuICAgICAgKyAoNCAtIDYgKiB0MiArIDMgKiB0MykgKiB2MVxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxuICAgICAgKyB0MyAqIHYzKSAvIDY7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdCA8PSAwID8gKHQgPSAwKSA6IHQgPj0gMSA/ICh0ID0gMSwgbiAtIDEpIDogTWF0aC5mbG9vcih0ICogbiksXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxuICAgICAgICB2MiA9IHZhbHVlc1tpICsgMV0sXG4gICAgICAgIHYwID0gaSA+IDAgPyB2YWx1ZXNbaSAtIDFdIDogMiAqIHYxIC0gdjIsXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7YmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKCgodCAlPSAxKSA8IDAgPyArK3QgOiB0KSAqIG4pLFxuICAgICAgICB2MCA9IHZhbHVlc1soaSArIG4gLSAxKSAlIG5dLFxuICAgICAgICB2MSA9IHZhbHVlc1tpICUgbl0sXG4gICAgICAgIHYyID0gdmFsdWVzWyhpICsgMSkgJSBuXSxcbiAgICAgICAgdjMgPSB2YWx1ZXNbKGkgKyAyKSAlIG5dO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBodWUoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtbWEoeSkge1xuICByZXR1cm4gKHkgPSAreSkgPT09IDEgPyBub2dhbW1hIDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vZ2FtbWEoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiaW1wb3J0IHtjdWJlaGVsaXggYXMgY29sb3JDdWJlaGVsaXh9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yLCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXgoaHVlKSB7XG4gIHJldHVybiAoZnVuY3Rpb24gY3ViZWhlbGl4R2FtbWEoeSkge1xuICAgIHkgPSAreTtcblxuICAgIGZ1bmN0aW9uIGN1YmVoZWxpeChzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckN1YmVoZWxpeChzdGFydCkpLmgsIChlbmQgPSBjb2xvckN1YmVoZWxpeChlbmQpKS5oKSxcbiAgICAgICAgICBzID0gY29sb3Ioc3RhcnQucywgZW5kLnMpLFxuICAgICAgICAgIGwgPSBjb2xvcihzdGFydC5sLCBlbmQubCksXG4gICAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgICAgc3RhcnQubCA9IGwoTWF0aC5wb3codCwgeSkpO1xuICAgICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3ViZWhlbGl4LmdhbW1hID0gY3ViZWhlbGl4R2FtbWE7XG5cbiAgICByZXR1cm4gY3ViZWhlbGl4O1xuICB9KSgxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3ViZWhlbGl4KGh1ZSk7XG5leHBvcnQgdmFyIGN1YmVoZWxpeExvbmcgPSBjdWJlaGVsaXgoY29sb3IpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgZCA9IG5ldyBEYXRlO1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZC5zZXRUaW1lKGEgKiAoMSAtIHQpICsgYiAqIHQpLCBkO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgfTtcbn1cbiIsImltcG9ydCB7aGNsIGFzIGNvbG9ySGNsfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciwge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZnVuY3Rpb24gaGNsKGh1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlKChzdGFydCA9IGNvbG9ySGNsKHN0YXJ0KSkuaCwgKGVuZCA9IGNvbG9ySGNsKGVuZCkpLmgpLFxuICAgICAgICBjID0gY29sb3Ioc3RhcnQuYywgZW5kLmMpLFxuICAgICAgICBsID0gY29sb3Ioc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gY29sb3Ioc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LmMgPSBjKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBoY2woaHVlKTtcbmV4cG9ydCB2YXIgaGNsTG9uZyA9IGhjbChjb2xvcik7XG4iLCJpbXBvcnQge2hzbCBhcyBjb2xvckhzbH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IsIHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGhzbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckhzbChzdGFydCkpLmgsIChlbmQgPSBjb2xvckhzbChlbmQpKS5oKSxcbiAgICAgICAgcyA9IGNvbG9yKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgbCA9IGNvbG9yKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaHNsKGh1ZSk7XG5leHBvcnQgdmFyIGhzbExvbmcgPSBoc2woY29sb3IpO1xuIiwiaW1wb3J0IHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSBodWUoK2EsICtiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgeCA9IGkodCk7XG4gICAgcmV0dXJuIHggLSAzNjAgKiBNYXRoLmZsb29yKHggLyAzNjApO1xuICB9O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlfSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQXJyYXl9IGZyb20gXCIuL2FycmF5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVCYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUJhc2lzQ2xvc2VkfSBmcm9tIFwiLi9iYXNpc0Nsb3NlZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlRGF0ZX0gZnJvbSBcIi4vZGF0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlRGlzY3JldGV9IGZyb20gXCIuL2Rpc2NyZXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIdWV9IGZyb20gXCIuL2h1ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlTnVtYmVyfSBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU51bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlT2JqZWN0fSBmcm9tIFwiLi9vYmplY3QuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVJvdW5kfSBmcm9tIFwiLi9yb3VuZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlU3RyaW5nfSBmcm9tIFwiLi9zdHJpbmcuanNcIjtcbmV4cG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MsIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnfSBmcm9tIFwiLi90cmFuc2Zvcm0vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVpvb219IGZyb20gXCIuL3pvb20uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVJnYiwgcmdiQmFzaXMgYXMgaW50ZXJwb2xhdGVSZ2JCYXNpcywgcmdiQmFzaXNDbG9zZWQgYXMgaW50ZXJwb2xhdGVSZ2JCYXNpc0Nsb3NlZH0gZnJvbSBcIi4vcmdiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIc2wsIGhzbExvbmcgYXMgaW50ZXJwb2xhdGVIc2xMb25nfSBmcm9tIFwiLi9oc2wuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUxhYn0gZnJvbSBcIi4vbGFiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIY2wsIGhjbExvbmcgYXMgaW50ZXJwb2xhdGVIY2xMb25nfSBmcm9tIFwiLi9oY2wuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUN1YmVoZWxpeCwgY3ViZWhlbGl4TG9uZyBhcyBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmd9IGZyb20gXCIuL2N1YmVoZWxpeC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBpZWNld2lzZX0gZnJvbSBcIi4vcGllY2V3aXNlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpemV9IGZyb20gXCIuL3F1YW50aXplLmpzXCI7XG4iLCJpbXBvcnQge2xhYiBhcyBjb2xvckxhYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGwgPSBjb2xvcigoc3RhcnQgPSBjb2xvckxhYihzdGFydCkpLmwsIChlbmQgPSBjb2xvckxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBjb2xvcihzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKCFiKSBiID0gW107XG4gIHZhciBuID0gYSA/IE1hdGgubWluKGIubGVuZ3RoLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgYyA9IGIuc2xpY2UoKSxcbiAgICAgIGk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY1tpXSA9IGFbaV0gKiAoMSAtIHQpICsgYltpXSAqIHQ7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlckFycmF5KHgpIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiAhKHggaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgaSA9IHt9LFxuICAgICAgYyA9IHt9LFxuICAgICAgaztcblxuICBpZiAoYSA9PT0gbnVsbCB8fCB0eXBlb2YgYSAhPT0gXCJvYmplY3RcIikgYSA9IHt9O1xuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgYiA9IHt9O1xuXG4gIGZvciAoayBpbiBiKSB7XG4gICAgaWYgKGsgaW4gYSkge1xuICAgICAgaVtrXSA9IHZhbHVlKGFba10sIGJba10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjW2tdID0gYltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyB2YWx1ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGllY2V3aXNlKGludGVycG9sYXRlLCB2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB2YWx1ZXMgPSBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbiAgdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aCAtIDEsIHYgPSB2YWx1ZXNbMF0sIEkgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gIHdoaWxlIChpIDwgbikgSVtpXSA9IGludGVycG9sYXRlKHYsIHYgPSB2YWx1ZXNbKytpXSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICo9IG4pKSk7XG4gICAgcmV0dXJuIElbaV0odCAtIGkpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJwb2xhdG9yLCBuKSB7XG4gIHZhciBzYW1wbGVzID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgc2FtcGxlc1tpXSA9IGludGVycG9sYXRvcihpIC8gKG4gLSAxKSk7XG4gIHJldHVybiBzYW1wbGVzO1xufVxuIiwiaW1wb3J0IHtyZ2IgYXMgY29sb3JSZ2J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGJhc2lzIGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5pbXBvcnQgYmFzaXNDbG9zZWQgZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmltcG9ydCBub2dhbW1hLCB7Z2FtbWF9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvcigoc3RhcnQgPSBjb2xvclJnYihzdGFydCkpLnIsIChlbmQgPSBjb2xvclJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYi5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2I7XG59KSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciA9IGNvbG9yUmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvci5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvci5yID0gcih0KTtcbiAgICAgIGNvbG9yLmcgPSBnKHQpO1xuICAgICAgY29sb3IuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMpO1xuZXhwb3J0IHZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKiAoMSAtIHQpICsgYiAqIHQpO1xuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cbiIsInZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge3BhcnNlQ3NzLCBwYXJzZVN2Z30gZnJvbSBcIi4vcGFyc2UuanNcIjtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcbiIsImltcG9ydCBkZWNvbXBvc2UsIHtpZGVudGl0eX0gZnJvbSBcIi4vZGVjb21wb3NlLmpzXCI7XG5cbnZhciBzdmdOb2RlO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGNvbnN0IG0gPSBuZXcgKHR5cGVvZiBET01NYXRyaXggPT09IFwiZnVuY3Rpb25cIiA/IERPTU1hdHJpeCA6IFdlYktpdENTU01hdHJpeCkodmFsdWUgKyBcIlwiKTtcbiAgcmV0dXJuIG0uaXNJZGVudGl0eSA/IGlkZW50aXR5IDogZGVjb21wb3NlKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHJnYiBmcm9tIFwiLi9yZ2IuanNcIjtcbmltcG9ydCB7Z2VuZXJpY0FycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGRhdGUgZnJvbSBcIi4vZGF0ZS5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmltcG9ydCBvYmplY3QgZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5pbXBvcnQgc3RyaW5nIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gY29sb3IoYikpID8gKGIgPSBjLCByZ2IpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyByZ2JcbiAgICAgIDogYiBpbnN0YW5jZW9mIERhdGUgPyBkYXRlXG4gICAgICA6IGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gZ2VuZXJpY0FycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59XG4iLCJ2YXIgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHpvb21SaG8ocmhvLCByaG8yLCByaG80KSB7XG5cbiAgLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuICAvLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG4gIGZ1bmN0aW9uIHpvb20ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxuICAgICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICAgIGksXG4gICAgICAgIFM7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHUwIOKJhSB1MS5cbiAgICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgICAgdXkwICsgdCAqIGR5LFxuICAgICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhbCBjYXNlLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwICogcmhvIC8gTWF0aC5TUVJUMjtcblxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgem9vbS5yaG8gPSBmdW5jdGlvbihfKSB7XG4gICAgdmFyIF8xID0gTWF0aC5tYXgoMWUtMywgK18pLCBfMiA9IF8xICogXzEsIF80ID0gXzIgKiBfMjtcbiAgICByZXR1cm4gem9vbVJobyhfMSwgXzIsIF80KTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn0pKE1hdGguU1FSVDIsIDIsIDQpO1xuIiwiY29uc3QgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl8gPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gbmV3IFBhdGg7XG59XG5cblBhdGgucHJvdG90eXBlID0gcGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIlFcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiQ1wiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAoK3gyKSArIFwiLFwiICsgKCt5MikgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBhcmNUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICB4MSA9ICt4MSwgeTEgPSAreTEsIHgyID0gK3gyLCB5MiA9ICt5MiwgciA9ICtyO1xuICAgIHZhciB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MSx5MSkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgIH1cbiAgfSxcbiAgYXJjOiBmdW5jdGlvbih4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3IsIGNjdyA9ICEhY2N3O1xuICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgfVxuICB9LFxuICByZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXRoO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uc3RhbnRzKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZSBhcyBpbnRlcnBvbGF0ZVZhbHVlLCBpbnRlcnBvbGF0ZU51bWJlciwgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbnZhciB1bml0ID0gWzAsIDFdO1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKGEsIGIpIHtcbiAgcmV0dXJuIChiIC09IChhID0gK2EpKVxuICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiAoeCAtIGEpIC8gYjsgfVxuICAgICAgOiBjb25zdGFudChpc05hTihiKSA/IE5hTiA6IDAuNSk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wZXIoYSwgYikge1xuICB2YXIgdDtcbiAgaWYgKGEgPiBiKSB0ID0gYSwgYSA9IGIsIGIgPSB0O1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgeCkpOyB9O1xufVxuXG4vLyBub3JtYWxpemUoYSwgYikoeCkgdGFrZXMgYSBkb21haW4gdmFsdWUgeCBpbiBbYSxiXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXIgdCBpbiBbMCwxXS5cbi8vIGludGVycG9sYXRlKGEsIGIpKHQpIHRha2VzIGEgcGFyYW1ldGVyIHQgaW4gWzAsMV0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmFuZ2UgdmFsdWUgeCBpbiBbYSxiXS5cbmZ1bmN0aW9uIGJpbWFwKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlKSB7XG4gIHZhciBkMCA9IGRvbWFpblswXSwgZDEgPSBkb21haW5bMV0sIHIwID0gcmFuZ2VbMF0sIHIxID0gcmFuZ2VbMV07XG4gIGlmIChkMSA8IGQwKSBkMCA9IG5vcm1hbGl6ZShkMSwgZDApLCByMCA9IGludGVycG9sYXRlKHIxLCByMCk7XG4gIGVsc2UgZDAgPSBub3JtYWxpemUoZDAsIGQxKSwgcjAgPSBpbnRlcnBvbGF0ZShyMCwgcjEpO1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gcjAoZDAoeCkpOyB9O1xufVxuXG5mdW5jdGlvbiBwb2x5bWFwKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlKSB7XG4gIHZhciBqID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSAtIDEsXG4gICAgICBkID0gbmV3IEFycmF5KGopLFxuICAgICAgciA9IG5ldyBBcnJheShqKSxcbiAgICAgIGkgPSAtMTtcblxuICAvLyBSZXZlcnNlIGRlc2NlbmRpbmcgZG9tYWlucy5cbiAgaWYgKGRvbWFpbltqXSA8IGRvbWFpblswXSkge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpLnJldmVyc2UoKTtcbiAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgd2hpbGUgKCsraSA8IGopIHtcbiAgICBkW2ldID0gbm9ybWFsaXplKGRvbWFpbltpXSwgZG9tYWluW2kgKyAxXSk7XG4gICAgcltpXSA9IGludGVycG9sYXRlKHJhbmdlW2ldLCByYW5nZVtpICsgMV0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaSA9IGJpc2VjdChkb21haW4sIHgsIDEsIGopIC0gMTtcbiAgICByZXR1cm4gcltpXShkW2ldKHgpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAuaW50ZXJwb2xhdGUoc291cmNlLmludGVycG9sYXRlKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgZG9tYWluID0gdW5pdCxcbiAgICAgIHJhbmdlID0gdW5pdCxcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHVudHJhbnNmb3JtLFxuICAgICAgdW5rbm93bixcbiAgICAgIGNsYW1wID0gaWRlbnRpdHksXG4gICAgICBwaWVjZXdpc2UsXG4gICAgICBvdXRwdXQsXG4gICAgICBpbnB1dDtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKTtcbiAgICBpZiAoY2xhbXAgIT09IGlkZW50aXR5KSBjbGFtcCA9IGNsYW1wZXIoZG9tYWluWzBdLCBkb21haW5bbiAtIDFdKTtcbiAgICBwaWVjZXdpc2UgPSBuID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgfHwgaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiAob3V0cHV0IHx8IChvdXRwdXQgPSBwaWVjZXdpc2UoZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCByYW5nZSwgaW50ZXJwb2xhdGUpKSkodHJhbnNmb3JtKGNsYW1wKHgpKSk7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIGNsYW1wKHVudHJhbnNmb3JtKChpbnB1dCB8fCAoaW5wdXQgPSBwaWVjZXdpc2UocmFuZ2UsIGRvbWFpbi5tYXAodHJhbnNmb3JtKSwgaW50ZXJwb2xhdGVOdW1iZXIpKSkoeSkpKTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gQXJyYXkuZnJvbShfLCBudW1iZXIpLCByZXNjYWxlKCkpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IEFycmF5LmZyb20oXyksIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gXyA/IHRydWUgOiBpZGVudGl0eSwgcmVzY2FsZSgpKSA6IGNsYW1wICE9PSBpZGVudGl0eTtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHJlc2NhbGUoKSkgOiBpbnRlcnBvbGF0ZTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0LCB1KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdW50cmFuc2Zvcm0gPSB1O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRpbnVvdXMoKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcigpKGlkZW50aXR5LCBpZGVudGl0eSk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlLCBpbnRlcnBvbGF0ZVJvdW5kLCBwaWVjZXdpc2V9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5pbXBvcnQge2xvZ2dpc2h9IGZyb20gXCIuL2xvZy5qc1wiO1xuaW1wb3J0IHtjb3B5fSBmcm9tIFwiLi9zZXF1ZW50aWFsLmpzXCI7XG5pbXBvcnQge3N5bWxvZ2lzaH0gZnJvbSBcIi4vc3ltbG9nLmpzXCI7XG5pbXBvcnQge3Bvd2lzaH0gZnJvbSBcIi4vcG93LmpzXCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAwLjUsXG4gICAgICB4MiA9IDEsXG4gICAgICBzID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICB0MixcbiAgICAgIGsxMCxcbiAgICAgIGsyMSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6ICh4ID0gMC41ICsgKCh4ID0gK3RyYW5zZm9ybSh4KSkgLSB0MSkgKiAocyAqIHggPCBzICogdDEgPyBrMTAgOiBrMjEpLCBpbnRlcnBvbGF0b3IoY2xhbXAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB4KSkgOiB4KSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3gwLCB4MSwgeDJdID0gXywgdDAgPSB0cmFuc2Zvcm0oeDAgPSAreDApLCB0MSA9IHRyYW5zZm9ybSh4MSA9ICt4MSksIHQyID0gdHJhbnNmb3JtKHgyID0gK3gyKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDAuNSAvICh0MSAtIHQwKSwgazIxID0gdDEgPT09IHQyID8gMCA6IDAuNSAvICh0MiAtIHQxKSwgcyA9IHQxIDwgdDAgPyAtMSA6IDEsIHNjYWxlKSA6IFt4MCwgeDEsIHgyXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBmdW5jdGlvbiByYW5nZShpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihfKSB7XG4gICAgICB2YXIgcjAsIHIxLCByMjtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFtyMCwgcjEsIHIyXSA9IF8sIGludGVycG9sYXRvciA9IHBpZWNld2lzZShpbnRlcnBvbGF0ZSwgW3IwLCByMSwgcjJdKSwgc2NhbGUpIDogW2ludGVycG9sYXRvcigwKSwgaW50ZXJwb2xhdG9yKDAuNSksIGludGVycG9sYXRvcigxKV07XG4gICAgfTtcbiAgfVxuXG4gIHNjYWxlLnJhbmdlID0gcmFuZ2UoaW50ZXJwb2xhdGUpO1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSByYW5nZShpbnRlcnBvbGF0ZVJvdW5kKTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgdDIgPSB0KHgyKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDAuNSAvICh0MSAtIHQwKSwgazIxID0gdDEgPT09IHQyID8gMCA6IDAuNSAvICh0MiAtIHQxKSwgcyA9IHQxIDwgdDAgPyAtMSA6IDE7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXZlcmdpbmcoKSB7XG4gIHZhciBzY2FsZSA9IGxpbmVhcmlzaCh0cmFuc2Zvcm1lcigpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBkaXZlcmdpbmcoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdMb2coKSB7XG4gIHZhciBzY2FsZSA9IGxvZ2dpc2godHJhbnNmb3JtZXIoKSkuZG9tYWluKFswLjEsIDEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBkaXZlcmdpbmdMb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nU3ltbG9nKCkge1xuICB2YXIgc2NhbGUgPSBzeW1sb2dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBkaXZlcmdpbmdTeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdQb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ1BvdygpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1NxcnQoKSB7XG4gIHJldHVybiBkaXZlcmdpbmdQb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaWRlbnRpdHkoZG9tYWluKSB7XG4gIHZhciB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsIHx8IGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogeDtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IHNjYWxlO1xuXG4gIHNjYWxlLmRvbWFpbiA9IHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IEFycmF5LmZyb20oXywgbnVtYmVyKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5KGRvbWFpbikudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICBkb21haW4gPSBhcmd1bWVudHMubGVuZ3RoID8gQXJyYXkuZnJvbShkb21haW4sIG51bWJlcikgOiBbMCwgMV07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaW5pdFJhbmdlKGRvbWFpbiwgcmFuZ2UpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMucmFuZ2UoZG9tYWluKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5yYW5nZShyYW5nZSkuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdEludGVycG9sYXRvcihkb21haW4sIGludGVycG9sYXRvcikge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMToge1xuICAgICAgaWYgKHR5cGVvZiBkb21haW4gPT09IFwiZnVuY3Rpb25cIikgdGhpcy5pbnRlcnBvbGF0b3IoZG9tYWluKTtcbiAgICAgIGVsc2UgdGhpcy5yYW5nZShkb21haW4pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRoaXMuZG9tYWluKGRvbWFpbik7XG4gICAgICBpZiAodHlwZW9mIGludGVycG9sYXRvciA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLmludGVycG9sYXRvcihpbnRlcnBvbGF0b3IpO1xuICAgICAgZWxzZSB0aGlzLnJhbmdlKGludGVycG9sYXRvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJpbXBvcnQge3RpY2tzLCB0aWNrSW5jcmVtZW50fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCBjb250aW51b3VzLCB7Y29weX0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcbmltcG9ydCB0aWNrRm9ybWF0IGZyb20gXCIuL3RpY2tGb3JtYXQuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcmlzaChzY2FsZSkge1xuICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KTtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tGb3JtYXQoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcblxuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgdmFyIGkwID0gMDtcbiAgICB2YXIgaTEgPSBkLmxlbmd0aCAtIDE7XG4gICAgdmFyIHN0YXJ0ID0gZFtpMF07XG4gICAgdmFyIHN0b3AgPSBkW2kxXTtcbiAgICB2YXIgcHJlc3RlcDtcbiAgICB2YXIgc3RlcDtcbiAgICB2YXIgbWF4SXRlciA9IDEwO1xuXG4gICAgaWYgKHN0b3AgPCBzdGFydCkge1xuICAgICAgc3RlcCA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBzdGVwO1xuICAgICAgc3RlcCA9IGkwLCBpMCA9IGkxLCBpMSA9IHN0ZXA7XG4gICAgfVxuICAgIFxuICAgIHdoaWxlIChtYXhJdGVyLS0gPiAwKSB7XG4gICAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgICAgaWYgKHN0ZXAgPT09IHByZXN0ZXApIHtcbiAgICAgICAgZFtpMF0gPSBzdGFydFxuICAgICAgICBkW2kxXSA9IHN0b3BcbiAgICAgICAgcmV0dXJuIGRvbWFpbihkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwcmVzdGVwID0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5lYXIoKSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxpbmVhcigpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG4iLCJpbXBvcnQge3RpY2tzfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0fSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlLmpzXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2coeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cCh4KSB7XG4gIHJldHVybiBNYXRoLmV4cCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nbih4KSB7XG4gIHJldHVybiAtTWF0aC5sb2coLXgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHBuKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmV4cCgteCk7XG59XG5cbmZ1bmN0aW9uIHBvdzEwKHgpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIHBvd3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgOiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmV4cFxuICAgICAgOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnBvdyhiYXNlLCB4KTsgfTtcbn1cblxuZnVuY3Rpb24gbG9ncChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICB8fCBiYXNlID09PSAyICYmIE1hdGgubG9nMlxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcbn1cblxuZnVuY3Rpb24gcmVmbGVjdChmKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIC1mKC14KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ2dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBiYXNlID0gMTAsXG4gICAgICBsb2dzLFxuICAgICAgcG93cztcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIGxvZ3MgPSBsb2dwKGJhc2UpLCBwb3dzID0gcG93cChiYXNlKTtcbiAgICBpZiAoZG9tYWluKClbMF0gPCAwKSB7XG4gICAgICBsb2dzID0gcmVmbGVjdChsb2dzKSwgcG93cyA9IHJlZmxlY3QocG93cyk7XG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nbiwgdHJhbnNmb3JtRXhwbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmJhc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYmFzZSA9ICtfLCByZXNjYWxlKCkpIDogYmFzZTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHUgPSBkWzBdLFxuICAgICAgICB2ID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByO1xuXG4gICAgaWYgKHIgPSB2IDwgdSkgaSA9IHUsIHUgPSB2LCB2ID0gaTtcblxuICAgIHZhciBpID0gbG9ncyh1KSxcbiAgICAgICAgaiA9IGxvZ3ModiksXG4gICAgICAgIHAsXG4gICAgICAgIGssXG4gICAgICAgIHQsXG4gICAgICAgIG4gPSBjb3VudCA9PSBudWxsID8gMTAgOiArY291bnQsXG4gICAgICAgIHogPSBbXTtcblxuICAgIGlmICghKGJhc2UgJSAxKSAmJiBqIC0gaSA8IG4pIHtcbiAgICAgIGkgPSBNYXRoLmZsb29yKGkpLCBqID0gTWF0aC5jZWlsKGopO1xuICAgICAgaWYgKHUgPiAwKSBmb3IgKDsgaSA8PSBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gMSwgcCA9IHBvd3MoaSk7IGsgPCBiYXNlOyArK2spIHtcbiAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGZvciAoOyBpIDw9IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSBiYXNlIC0gMSwgcCA9IHBvd3MoaSk7IGsgPj0gMTsgLS1rKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh6Lmxlbmd0aCAqIDIgPCBuKSB6ID0gdGlja3ModSwgdiwgbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSB0aWNrcyhpLCBqLCBNYXRoLm1pbihqIC0gaSwgbikpLm1hcChwb3dzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gciA/IHoucmV2ZXJzZSgpIDogejtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIGlmIChzcGVjaWZpZXIgPT0gbnVsbCkgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyBcIi4wZVwiIDogXCIsXCI7XG4gICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZm9ybWF0KHNwZWNpZmllcik7XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIHNwZWNpZmllcjtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcbiAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xuICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgaSA9IGQgLyBwb3dzKE1hdGgucm91bmQobG9ncyhkKSkpO1xuICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgICAgcmV0dXJuIGkgPD0gayA/IHNwZWNpZmllcihkKSA6IFwiXCI7XG4gICAgfTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbihuaWNlKGRvbWFpbigpLCB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmZsb29yKGxvZ3MoeCkpKTsgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5jZWlsKGxvZ3MoeCkpKTsgfVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuaWNlKGRvbWFpbiwgaW50ZXJ2YWwpIHtcbiAgZG9tYWluID0gZG9tYWluLnNsaWNlKCk7XG5cbiAgdmFyIGkwID0gMCxcbiAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXG4gICAgICB4MCA9IGRvbWFpbltpMF0sXG4gICAgICB4MSA9IGRvbWFpbltpMV0sXG4gICAgICB0O1xuXG4gIGlmICh4MSA8IHgwKSB7XG4gICAgdCA9IGkwLCBpMCA9IGkxLCBpMSA9IHQ7XG4gICAgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gIH1cblxuICBkb21haW5baTBdID0gaW50ZXJ2YWwuZmxvb3IoeDApO1xuICBkb21haW5baTFdID0gaW50ZXJ2YWwuY2VpbCh4MSk7XG4gIHJldHVybiBkb21haW47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBudW1iZXIoeCkge1xuICByZXR1cm4gK3g7XG59XG4iLCJpbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgY29uc3QgaW1wbGljaXQgPSBTeW1ib2woXCJpbXBsaWNpdFwiKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkaW5hbCgpIHtcbiAgdmFyIGluZGV4ID0gbmV3IE1hcCgpLFxuICAgICAgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdLFxuICAgICAgdW5rbm93biA9IGltcGxpY2l0O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKGQpIHtcbiAgICB2YXIga2V5ID0gZCArIFwiXCIsIGkgPSBpbmRleC5nZXQoa2V5KTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIGlmICh1bmtub3duICE9PSBpbXBsaWNpdCkgcmV0dXJuIHVua25vd247XG4gICAgICBpbmRleC5zZXQoa2V5LCBpID0gZG9tYWluLnB1c2goZCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VbKGkgLSAxKSAlIHJhbmdlLmxlbmd0aF07XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW10sIGluZGV4ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgXykge1xuICAgICAgY29uc3Qga2V5ID0gdmFsdWUgKyBcIlwiO1xuICAgICAgaWYgKGluZGV4LmhhcyhrZXkpKSBjb250aW51ZTtcbiAgICAgIGluZGV4LnNldChrZXksIGRvbWFpbi5wdXNoKHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG9yZGluYWwoZG9tYWluLCByYW5nZSkudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuIiwiaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IHtjb3B5LCBpZGVudGl0eSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvdyhleHBvbmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXJ0KHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLU1hdGguc3FydCgteCkgOiBNYXRoLnNxcnQoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxdWFyZSh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC14ICogeCA6IHggKiB4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93aXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGV4cG9uZW50ID0gMTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHJldHVybiBleHBvbmVudCA9PT0gMSA/IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpXG4gICAgICAgIDogZXhwb25lbnQgPT09IDAuNSA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TcXJ0LCB0cmFuc2Zvcm1TcXVhcmUpXG4gICAgICAgIDogdHJhbnNmb3JtKHRyYW5zZm9ybVBvdyhleHBvbmVudCksIHRyYW5zZm9ybVBvdygxIC8gZXhwb25lbnQpKTtcbiAgfVxuXG4gIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIHJlc2NhbGUoKSkgOiBleHBvbmVudDtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxcnQoKSB7XG4gIHJldHVybiBwb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdCwgcXVhbnRpbGVTb3J0ZWQgYXMgdGhyZXNob2xkfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdLFxuICAgICAgdGhyZXNob2xkcyA9IFtdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XG4gICAgdGhyZXNob2xkcyA9IG5ldyBBcnJheShuIC0gMSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gdGhyZXNob2xkKGRvbWFpbiwgaSAvIG4pO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsIHx8IGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogcmFuZ2VbYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAobGV0IGQgb2YgXykgaWYgKGQgIT0gbnVsbCAmJiAhaXNOYU4oZCA9ICtkKSkgZG9tYWluLnB1c2goZCk7XG4gICAgZG9tYWluLnNvcnQoYXNjZW5kaW5nKTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkcy5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpbGUoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpemUoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHggPD0geCA/IHJhbmdlW2Jpc2VjdChkb21haW4sIHgsIDAsIG4pXSA6IHVua25vd247XG4gIH1cblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gLTE7XG4gICAgZG9tYWluID0gbmV3IEFycmF5KG4pO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkb21haW5baV0gPSAoKGkgKyAxKSAqIHgxIC0gKGkgLSBuKSAqIHgwKSAvIChuICsgMSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFt4MCwgeDFdID0gXywgeDAgPSAreDAsIHgxID0gK3gxLCByZXNjYWxlKCkpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IChyYW5nZSA9IEFycmF5LmZyb20oXykpLmxlbmd0aCAtIDEsIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXVxuICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgIDogaSA+PSBuID8gW2RvbWFpbltuIC0gMV0sIHgxXVxuICAgICAgICA6IFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnRocmVzaG9sZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGl6ZSgpXG4gICAgICAgIC5kb21haW4oW3gwLCB4MV0pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShsaW5lYXJpc2goc2NhbGUpLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXQuanNcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXIuanNcIjtcbmltcG9ydCB7bG9nZ2lzaH0gZnJvbSBcIi4vbG9nLmpzXCI7XG5pbXBvcnQge3N5bWxvZ2lzaH0gZnJvbSBcIi4vc3ltbG9nLmpzXCI7XG5pbXBvcnQge3Bvd2lzaH0gZnJvbSBcIi4vcG93LmpzXCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgdDAsXG4gICAgICB0MSxcbiAgICAgIGsxMCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5LFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgfHwgaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiBpbnRlcnBvbGF0b3IoazEwID09PSAwID8gMC41IDogKHggPSAodHJhbnNmb3JtKHgpIC0gdDApICogazEwLCBjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbeDAsIHgxXSA9IF8sIHQwID0gdHJhbnNmb3JtKHgwID0gK3gwKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSAreDEpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMSAvICh0MSAtIHQwKSwgc2NhbGUpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHNjYWxlKSA6IGNsYW1wO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmFuZ2UoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oXykge1xuICAgICAgdmFyIHIwLCByMTtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFtyMCwgcjFdID0gXywgaW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdGUocjAsIHIxKSwgc2NhbGUpIDogW2ludGVycG9sYXRvcigwKSwgaW50ZXJwb2xhdG9yKDEpXTtcbiAgICB9O1xuICB9XG5cbiAgc2NhbGUucmFuZ2UgPSByYW5nZShpbnRlcnBvbGF0ZSk7XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IHJhbmdlKGludGVycG9sYXRlUm91bmQpO1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB0MCA9IHQoeDApLCB0MSA9IHQoeDEpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMSAvICh0MSAtIHQwKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLmludGVycG9sYXRvcihzb3VyY2UuaW50ZXJwb2xhdG9yKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VxdWVudGlhbCgpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWwoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsTG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxMb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc2VxdWVudGlhbFN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxQb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsU3FydCgpIHtcbiAgcmV0dXJuIHNlcXVlbnRpYWxQb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IHtjb3B5LCB0cmFuc2Zvcm1lcn0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3ltbG9nKGMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5sb2cxcChNYXRoLmFicyh4IC8gYykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TeW1leHAoYykge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmV4cG0xKE1hdGguYWJzKHgpKSAqIGM7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzeW1sb2dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBjID0gMSwgc2NhbGUgPSB0cmFuc2Zvcm0odHJhbnNmb3JtU3ltbG9nKGMpLCB0cmFuc2Zvcm1TeW1leHAoYykpO1xuXG4gIHNjYWxlLmNvbnN0YW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdHJhbnNmb3JtKHRyYW5zZm9ybVN5bWxvZyhjID0gK18pLCB0cmFuc2Zvcm1TeW1leHAoYykpIDogYztcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ltbG9nKCkge1xuICB2YXIgc2NhbGUgPSBzeW1sb2dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRocmVzaG9sZCgpIHtcbiAgdmFyIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duLFxuICAgICAgbiA9IDE7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgeCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBBcnJheS5mcm9tKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHt0aWNrU3RlcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Zvcm1hdCwgZm9ybWF0UHJlZml4LCBmb3JtYXRTcGVjaWZpZXIsIHByZWNpc2lvbkZpeGVkLCBwcmVjaXNpb25QcmVmaXgsIHByZWNpc2lvblJvdW5kfSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpY2tGb3JtYXQoc3RhcnQsIHN0b3AsIGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgdmFyIHN0ZXAgPSB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpLFxuICAgICAgcHJlY2lzaW9uO1xuICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyBcIixmXCIgOiBzcGVjaWZpZXIpO1xuICBzd2l0Y2ggKHNwZWNpZmllci50eXBlKSB7XG4gICAgY2FzZSBcInNcIjoge1xuICAgICAgdmFyIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgIHJldHVybiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNhc2UgXCJcIjpcbiAgICBjYXNlIFwiZVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwiclwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25Sb3VuZChzdGVwLCBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcImVcIik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZcIjpcbiAgICBjYXNlIFwiJVwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25GaXhlZChzdGVwKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiJVwiKSAqIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChzcGVjaWZpZXIpO1xufVxuIiwiaW1wb3J0IHt0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lV2VlaywgdGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVTZWNvbmQsIHRpbWVUaWNrcywgdGltZVRpY2tJbnRlcnZhbH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7dGltZUZvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQgY29udGludW91cywge2NvcHl9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlLmpzXCI7XG5cbmZ1bmN0aW9uIGRhdGUodCkge1xuICByZXR1cm4gbmV3IERhdGUodCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlcih0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGVuZGFyKHRpY2tzLCB0aWNrSW50ZXJ2YWwsIHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmb3JtYXQpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cygpLFxuICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHZhciBmb3JtYXRNaWxsaXNlY29uZCA9IGZvcm1hdChcIi4lTFwiKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdChcIjolU1wiKSxcbiAgICAgIGZvcm1hdE1pbnV0ZSA9IGZvcm1hdChcIiVJOiVNXCIpLFxuICAgICAgZm9ybWF0SG91ciA9IGZvcm1hdChcIiVJICVwXCIpLFxuICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0KFwiJWEgJWRcIiksXG4gICAgICBmb3JtYXRXZWVrID0gZm9ybWF0KFwiJWIgJWRcIiksXG4gICAgICBmb3JtYXRNb250aCA9IGZvcm1hdChcIiVCXCIpLFxuICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdChcIiVZXCIpO1xuXG4gIGZ1bmN0aW9uIHRpY2tGb3JtYXQoZGF0ZSkge1xuICAgIHJldHVybiAoc2Vjb25kKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbGxpc2Vjb25kXG4gICAgICAgIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGhvdXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWludXRlXG4gICAgICAgIDogZGF5KGRhdGUpIDwgZGF0ZSA/IGZvcm1hdEhvdXJcbiAgICAgICAgOiBtb250aChkYXRlKSA8IGRhdGUgPyAod2VlayhkYXRlKSA8IGRhdGUgPyBmb3JtYXREYXkgOiBmb3JtYXRXZWVrKVxuICAgICAgICA6IHllYXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoaW52ZXJ0KHkpKTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkb21haW4oQXJyYXkuZnJvbShfLCBudW1iZXIpKSA6IGRvbWFpbigpLm1hcChkYXRlKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBpbnRlcnZhbCA9PSBudWxsID8gMTAgOiBpbnRlcnZhbCk7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyID09IG51bGwgPyB0aWNrRm9ybWF0IDogZm9ybWF0KHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICBpZiAoIWludGVydmFsIHx8IHR5cGVvZiBpbnRlcnZhbC5yYW5nZSAhPT0gXCJmdW5jdGlvblwiKSBpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGludGVydmFsID09IG51bGwgPyAxMCA6IGludGVydmFsKTtcbiAgICByZXR1cm4gaW50ZXJ2YWwgPyBkb21haW4obmljZShkLCBpbnRlcnZhbCkpIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih0aWNrcywgdGlja0ludGVydmFsLCB5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZm9ybWF0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aW1lKCkge1xuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KGNhbGVuZGFyKHRpbWVUaWNrcywgdGltZVRpY2tJbnRlcnZhbCwgdGltZVllYXIsIHRpbWVNb250aCwgdGltZVdlZWssIHRpbWVEYXksIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lRm9ybWF0KS5kb21haW4oW25ldyBEYXRlKDIwMDAsIDAsIDEpLCBuZXcgRGF0ZSgyMDAwLCAwLCAyKV0pLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHt1dGNZZWFyLCB1dGNNb250aCwgdXRjV2VlaywgdXRjRGF5LCB1dGNIb3VyLCB1dGNNaW51dGUsIHV0Y1NlY29uZCwgdXRjVGlja3MsIHV0Y1RpY2tJbnRlcnZhbH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7dXRjRm9ybWF0fSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcbmltcG9ydCB7Y2FsZW5kYXJ9IGZyb20gXCIuL3RpbWUuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHV0Y1RpbWUoKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIodXRjVGlja3MsIHV0Y1RpY2tJbnRlcnZhbCwgdXRjWWVhciwgdXRjTW9udGgsIHV0Y1dlZWssIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y0Zvcm1hdCkuZG9tYWluKFtEYXRlLlVUQygyMDAwLCAwLCAxKSwgRGF0ZS5VVEMoMjAwMCwgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCBmb3JtYXRMb2NhbGUgZnJvbSBcIi4vbG9jYWxlLmpzXCI7XG5cbnZhciBsb2NhbGU7XG5leHBvcnQgdmFyIHRpbWVGb3JtYXQ7XG5leHBvcnQgdmFyIHRpbWVQYXJzZTtcbmV4cG9ydCB2YXIgdXRjRm9ybWF0O1xuZXhwb3J0IHZhciB1dGNQYXJzZTtcblxuZGVmYXVsdExvY2FsZSh7XG4gIGRhdGVUaW1lOiBcIiV4LCAlWFwiLFxuICBkYXRlOiBcIiUtbS8lLWQvJVlcIixcbiAgdGltZTogXCIlLUk6JU06JVMgJXBcIixcbiAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgdGltZUZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIHRpbWVQYXJzZSA9IGxvY2FsZS5wYXJzZTtcbiAgdXRjRm9ybWF0ID0gbG9jYWxlLnV0Y0Zvcm1hdDtcbiAgdXRjUGFyc2UgPSBsb2NhbGUudXRjUGFyc2U7XG4gIHJldHVybiBsb2NhbGU7XG59XG4iLCJpbXBvcnQge1xuICB0aW1lRGF5LFxuICB0aW1lU3VuZGF5LFxuICB0aW1lTW9uZGF5LFxuICB0aW1lVGh1cnNkYXksXG4gIHRpbWVZZWFyLFxuICB1dGNEYXksXG4gIHV0Y1N1bmRheSxcbiAgdXRjTW9uZGF5LFxuICB1dGNUaHVyc2RheSxcbiAgdXRjWWVhclxufSBmcm9tIFwiZDMtdGltZVwiO1xuXG5mdW5jdGlvbiBsb2NhbERhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkLnkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZShkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xufVxuXG5mdW5jdGlvbiB1dGNEYXRlKGQpIHtcbiAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xufVxuXG5mdW5jdGlvbiBuZXdEYXRlKHksIG0sIGQpIHtcbiAgcmV0dXJuIHt5OiB5LCBtOiBtLCBkOiBkLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0TG9jYWxlKGxvY2FsZSkge1xuICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLFxuICAgICAgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSxcbiAgICAgIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsXG4gICAgICBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLFxuICAgICAgbG9jYWxlX3dlZWtkYXlzID0gbG9jYWxlLmRheXMsXG4gICAgICBsb2NhbGVfc2hvcnRXZWVrZGF5cyA9IGxvY2FsZS5zaG9ydERheXMsXG4gICAgICBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocyxcbiAgICAgIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcblxuICB2YXIgcGVyaW9kUmUgPSBmb3JtYXRSZShsb2NhbGVfcGVyaW9kcyksXG4gICAgICBwZXJpb2RMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3BlcmlvZHMpLFxuICAgICAgd2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHNob3J0V2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgIG1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfbW9udGhzKSxcbiAgICAgIG1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLFxuICAgICAgc2hvcnRNb250aFJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSxcbiAgICAgIHNob3J0TW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcblxuICB2YXIgZm9ybWF0cyA9IHtcbiAgICBcImFcIjogZm9ybWF0U2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxuICAgIFwiYlwiOiBmb3JtYXRTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBmb3JtYXRNb250aCxcbiAgICBcImNcIjogbnVsbCxcbiAgICBcImRcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcImVcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcImZcIjogZm9ybWF0TWljcm9zZWNvbmRzLFxuICAgIFwiZ1wiOiBmb3JtYXRZZWFySVNPLFxuICAgIFwiR1wiOiBmb3JtYXRGdWxsWWVhcklTTyxcbiAgICBcIkhcIjogZm9ybWF0SG91cjI0LFxuICAgIFwiSVwiOiBmb3JtYXRIb3VyMTIsXG4gICAgXCJqXCI6IGZvcm1hdERheU9mWWVhcixcbiAgICBcIkxcIjogZm9ybWF0TWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBmb3JtYXRNb250aE51bWJlcixcbiAgICBcIk1cIjogZm9ybWF0TWludXRlcyxcbiAgICBcInBcIjogZm9ybWF0UGVyaW9kLFxuICAgIFwicVwiOiBmb3JtYXRRdWFydGVyLFxuICAgIFwiUVwiOiBmb3JtYXRVbml4VGltZXN0YW1wLFxuICAgIFwic1wiOiBmb3JtYXRVbml4VGltZXN0YW1wU2Vjb25kcyxcbiAgICBcIlNcIjogZm9ybWF0U2Vjb25kcyxcbiAgICBcInVcIjogZm9ybWF0V2Vla2RheU51bWJlck1vbmRheSxcbiAgICBcIlVcIjogZm9ybWF0V2Vla051bWJlclN1bmRheSxcbiAgICBcIlZcIjogZm9ybWF0V2Vla051bWJlcklTTyxcbiAgICBcIndcIjogZm9ybWF0V2Vla2RheU51bWJlclN1bmRheSxcbiAgICBcIldcIjogZm9ybWF0V2Vla051bWJlck1vbmRheSxcbiAgICBcInhcIjogbnVsbCxcbiAgICBcIlhcIjogbnVsbCxcbiAgICBcInlcIjogZm9ybWF0WWVhcixcbiAgICBcIllcIjogZm9ybWF0RnVsbFllYXIsXG4gICAgXCJaXCI6IGZvcm1hdFpvbmUsXG4gICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gIH07XG5cbiAgdmFyIHV0Y0Zvcm1hdHMgPSB7XG4gICAgXCJhXCI6IGZvcm1hdFVUQ1Nob3J0V2Vla2RheSxcbiAgICBcIkFcIjogZm9ybWF0VVRDV2Vla2RheSxcbiAgICBcImJcIjogZm9ybWF0VVRDU2hvcnRNb250aCxcbiAgICBcIkJcIjogZm9ybWF0VVRDTW9udGgsXG4gICAgXCJjXCI6IG51bGwsXG4gICAgXCJkXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgXCJlXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgXCJmXCI6IGZvcm1hdFVUQ01pY3Jvc2Vjb25kcyxcbiAgICBcImdcIjogZm9ybWF0VVRDWWVhcklTTyxcbiAgICBcIkdcIjogZm9ybWF0VVRDRnVsbFllYXJJU08sXG4gICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0VVRDSG91cjEyLFxuICAgIFwialwiOiBmb3JtYXRVVENEYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0VVRDTW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdFVUQ01pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICBcInFcIjogZm9ybWF0VVRDUXVhcnRlcixcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciBwYXJzZXMgPSB7XG4gICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJmXCI6IHBhcnNlTWljcm9zZWNvbmRzLFxuICAgIFwiZ1wiOiBwYXJzZVllYXIsXG4gICAgXCJHXCI6IHBhcnNlRnVsbFllYXIsXG4gICAgXCJIXCI6IHBhcnNlSG91cjI0LFxuICAgIFwiSVwiOiBwYXJzZUhvdXIyNCxcbiAgICBcImpcIjogcGFyc2VEYXlPZlllYXIsXG4gICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBwYXJzZU1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBwYXJzZU1pbnV0ZXMsXG4gICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxuICAgIFwicVwiOiBwYXJzZVF1YXJ0ZXIsXG4gICAgXCJRXCI6IHBhcnNlVW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogcGFyc2VVbml4VGltZXN0YW1wU2Vjb25kcyxcbiAgICBcIlNcIjogcGFyc2VTZWNvbmRzLFxuICAgIFwidVwiOiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IHBhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICBcIlZcIjogcGFyc2VXZWVrTnVtYmVySVNPLFxuICAgIFwid1wiOiBwYXJzZVdlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IHBhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICBcInhcIjogcGFyc2VMb2NhbGVEYXRlLFxuICAgIFwiWFwiOiBwYXJzZUxvY2FsZVRpbWUsXG4gICAgXCJ5XCI6IHBhcnNlWWVhcixcbiAgICBcIllcIjogcGFyc2VGdWxsWWVhcixcbiAgICBcIlpcIjogcGFyc2Vab25lLFxuICAgIFwiJVwiOiBwYXJzZUxpdGVyYWxQZXJjZW50XG4gIH07XG5cbiAgLy8gVGhlc2UgcmVjdXJzaXZlIGRpcmVjdGl2ZSBkZWZpbml0aW9ucyBtdXN0IGJlIGRlZmVycmVkLlxuICBmb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIGZvcm1hdHMpO1xuICBmb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIGZvcm1hdHMpO1xuICBmb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCBmb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCB1dGNGb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCB1dGNGb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgdXRjRm9ybWF0cyk7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllciwgZm9ybWF0cykge1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgc3RyaW5nID0gW10sXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgcGFkLFxuICAgICAgICAgIGZvcm1hdDtcblxuICAgICAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSBkYXRlID0gbmV3IERhdGUoK2RhdGUpO1xuXG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICBpZiAoKHBhZCA9IHBhZHNbYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKV0pICE9IG51bGwpIGMgPSBzcGVjaWZpZXIuY2hhckF0KCsraSk7XG4gICAgICAgICAgZWxzZSBwYWQgPSBjID09PSBcImVcIiA/IFwiIFwiIDogXCIwXCI7XG4gICAgICAgICAgaWYgKGZvcm1hdCA9IGZvcm1hdHNbY10pIGMgPSBmb3JtYXQoZGF0ZSwgcGFkKTtcbiAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgIHJldHVybiBzdHJpbmcuam9pbihcIlwiKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3UGFyc2Uoc3BlY2lmaWVyLCBaKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIGQgPSBuZXdEYXRlKDE5MDAsIHVuZGVmaW5lZCwgMSksXG4gICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nICs9IFwiXCIsIDApLFxuICAgICAgICAgIHdlZWssIGRheTtcbiAgICAgIGlmIChpICE9IHN0cmluZy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBJZiBhIFVOSVggdGltZXN0YW1wIGlzIHNwZWNpZmllZCwgcmV0dXJuIGl0LlxuICAgICAgaWYgKFwiUVwiIGluIGQpIHJldHVybiBuZXcgRGF0ZShkLlEpO1xuICAgICAgaWYgKFwic1wiIGluIGQpIHJldHVybiBuZXcgRGF0ZShkLnMgKiAxMDAwICsgKFwiTFwiIGluIGQgPyBkLkwgOiAwKSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdXRjUGFyc2UsIG5ldmVyIHVzZSB0aGUgbG9jYWwgdGltZXpvbmUuXG4gICAgICBpZiAoWiAmJiAhKFwiWlwiIGluIGQpKSBkLlogPSAwO1xuXG4gICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG5cbiAgICAgIC8vIElmIHRoZSBtb250aCB3YXMgbm90IHNwZWNpZmllZCwgaW5oZXJpdCBmcm9tIHRoZSBxdWFydGVyLlxuICAgICAgaWYgKGQubSA9PT0gdW5kZWZpbmVkKSBkLm0gPSBcInFcIiBpbiBkID8gZC5xIDogMDtcblxuICAgICAgLy8gQ29udmVydCBkYXktb2Ytd2VlayBhbmQgd2Vlay1vZi15ZWFyIHRvIGRheS1vZi15ZWFyLlxuICAgICAgaWYgKFwiVlwiIGluIGQpIHtcbiAgICAgICAgaWYgKGQuViA8IDEgfHwgZC5WID4gNTMpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gMTtcbiAgICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgICB3ZWVrID0gdXRjRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLCBkYXkgPSB3ZWVrLmdldFVUQ0RheSgpO1xuICAgICAgICAgIHdlZWsgPSBkYXkgPiA0IHx8IGRheSA9PT0gMCA/IHV0Y01vbmRheS5jZWlsKHdlZWspIDogdXRjTW9uZGF5KHdlZWspO1xuICAgICAgICAgIHdlZWsgPSB1dGNEYXkub2Zmc2V0KHdlZWssIChkLlYgLSAxKSAqIDcpO1xuICAgICAgICAgIGQueSA9IHdlZWsuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICBkLm0gPSB3ZWVrLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgZC5kID0gd2Vlay5nZXRVVENEYXRlKCkgKyAoZC53ICsgNikgJSA3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdlZWsgPSBsb2NhbERhdGUobmV3RGF0ZShkLnksIDAsIDEpKSwgZGF5ID0gd2Vlay5nZXREYXkoKTtcbiAgICAgICAgICB3ZWVrID0gZGF5ID4gNCB8fCBkYXkgPT09IDAgPyB0aW1lTW9uZGF5LmNlaWwod2VlaykgOiB0aW1lTW9uZGF5KHdlZWspO1xuICAgICAgICAgIHdlZWsgPSB0aW1lRGF5Lm9mZnNldCh3ZWVrLCAoZC5WIC0gMSkgKiA3KTtcbiAgICAgICAgICBkLnkgPSB3ZWVrLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgZC5tID0gd2Vlay5nZXRNb250aCgpO1xuICAgICAgICAgIGQuZCA9IHdlZWsuZ2V0RGF0ZSgpICsgKGQudyArIDYpICUgNztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpIHtcbiAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IFwidVwiIGluIGQgPyBkLnUgJSA3IDogXCJXXCIgaW4gZCA/IDEgOiAwO1xuICAgICAgICBkYXkgPSBcIlpcIiBpbiBkID8gdXRjRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLmdldFVUQ0RheSgpIDogbG9jYWxEYXRlKG5ld0RhdGUoZC55LCAwLCAxKSkuZ2V0RGF5KCk7XG4gICAgICAgIGQubSA9IDA7XG4gICAgICAgIGQuZCA9IFwiV1wiIGluIGQgPyAoZC53ICsgNikgJSA3ICsgZC5XICogNyAtIChkYXkgKyA1KSAlIDcgOiBkLncgKyBkLlUgKiA3IC0gKGRheSArIDYpICUgNztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkLCBhbGwgZmllbGRzIGFyZSBpbnRlcnByZXRlZCBhcyBVVEMgYW5kIHRoZW5cbiAgICAgIC8vIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0aW1lIHpvbmUuXG4gICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICBkLkggKz0gZC5aIC8gMTAwIHwgMDtcbiAgICAgICAgZC5NICs9IGQuWiAlIDEwMDtcbiAgICAgICAgcmV0dXJuIHV0Y0RhdGUoZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgYWxsIGZpZWxkcyBhcmUgaW4gbG9jYWwgdGltZS5cbiAgICAgIHJldHVybiBsb2NhbERhdGUoZCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nLCBqKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgbSA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgIGMsXG4gICAgICAgIHBhcnNlO1xuXG4gICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICBjID0gc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIGlmIChjID09PSAzNykge1xuICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJBdChpKyspO1xuICAgICAgICBwYXJzZSA9IHBhcnNlc1tjIGluIHBhZHMgPyBzcGVjaWZpZXIuY2hhckF0KGkrKykgOiBjXTtcbiAgICAgICAgaWYgKCFwYXJzZSB8fCAoKGogPSBwYXJzZShkLCBzdHJpbmcsIGopKSA8IDApKSByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGo7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBlcmlvZChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHBlcmlvZFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLnAgPSBwZXJpb2RMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gd2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNob3J0TW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBzaG9ydE1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQubSA9IHNob3J0TW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGVUaW1lLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX3RpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXREYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRRdWFydGVyKGQpIHtcbiAgICByZXR1cm4gMSArIH5+KGQuZ2V0TW9udGgoKSAvIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENQZXJpb2QoZCkge1xuICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0VVRDSG91cnMoKSA+PSAxMildO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDUXVhcnRlcihkKSB7XG4gICAgcmV0dXJuIDEgKyB+fihkLmdldFVUQ01vbnRoKCkgLyAzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCBmb3JtYXRzKTtcbiAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIHAgPSBuZXdQYXJzZShzcGVjaWZpZXIgKz0gXCJcIiwgZmFsc2UpO1xuICAgICAgcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICB1dGNGb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIHV0Y0Zvcm1hdHMpO1xuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgICB1dGNQYXJzZTogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgcCA9IG5ld1BhcnNlKHNwZWNpZmllciArPSBcIlwiLCB0cnVlKTtcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifSxcbiAgICBudW1iZXJSZSA9IC9eXFxzKlxcZCsvLCAvLyBub3RlOiBpZ25vcmVzIG5leHQgZGlyZWN0aXZlXG4gICAgcGVyY2VudFJlID0gL14lLyxcbiAgICByZXF1b3RlUmUgPSAvW1xcXFxeJCorP3xbXFxdKCkue31dL2c7XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsXG4gICAgICBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xufVxuXG5mdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShyZXF1b3RlUmUsIFwiXFxcXCQmXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChyZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICByZXR1cm4gbmV3IE1hcChuYW1lcy5tYXAoKG5hbWUsIGkpID0+IFtuYW1lLnRvTG93ZXJDYXNlKCksIGldKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyAoZC51ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlcklTTyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlYgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gL14oWil8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/Ly5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLlogPSBuWzFdID8gMCA6IC0oblsyXSArIChuWzNdIHx8IFwiMDBcIikpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVhcnRlcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLnEgPSBuWzBdICogMyAtIDMsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZlllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gMCwgZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICByZXR1cm4gbiA/IChkLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pY3Jvc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLkwgPSBNYXRoLmZsb29yKG5bMF0gLyAxMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpdGVyYWxQZXJjZW50KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IHBlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVuaXhUaW1lc3RhbXAoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICByZXR1cm4gbiA/IChkLlEgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5zID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXREYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyB0aW1lRGF5LmNvdW50KHRpbWVZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pY3Jvc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkgKyBcIjAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyTW9uZGF5KGQpIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIHJldHVybiBkYXkgPT09IDAgPyA3IDogZGF5O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZCh0aW1lU3VuZGF5LmNvdW50KHRpbWVZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBkSVNPKGQpIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIHJldHVybiAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IHRpbWVUaHVyc2RheShkKSA6IHRpbWVUaHVyc2RheS5jZWlsKGQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVySVNPKGQsIHApIHtcbiAgZCA9IGRJU08oZCk7XG4gIHJldHVybiBwYWQodGltZVRodXJzZGF5LmNvdW50KHRpbWVZZWFyKGQpLCBkKSArICh0aW1lWWVhcihkKS5nZXREYXkoKSA9PT0gNCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcbiAgcmV0dXJuIGQuZ2V0RGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKHRpbWVNb25kYXkuY291bnQodGltZVllYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXJJU08oZCwgcCkge1xuICBkID0gZElTTyhkKTtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRGdWxsWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRGdWxsWWVhcklTTyhkLCBwKSB7XG4gIHZhciBkYXkgPSBkLmdldERheSgpO1xuICBkID0gKGRheSA+PSA0IHx8IGRheSA9PT0gMCkgPyB0aW1lVGh1cnNkYXkoZCkgOiB0aW1lVGh1cnNkYXkuY2VpbChkKTtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICB2YXIgeiA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgcmV0dXJuICh6ID4gMCA/IFwiLVwiIDogKHogKj0gLTEsIFwiK1wiKSlcbiAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgKyBwYWQoeiAlIDYwLCBcIjBcIiwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRGF0ZSgpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZCgxICsgdXRjRGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWljcm9zZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ1NlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xuICB2YXIgZG93ID0gZC5nZXRVVENEYXkoKTtcbiAgcmV0dXJuIGRvdyA9PT0gMCA/IDcgOiBkb3c7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKHV0Y1N1bmRheS5jb3VudCh1dGNZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBVVENkSVNPKGQpIHtcbiAgdmFyIGRheSA9IGQuZ2V0VVRDRGF5KCk7XG4gIHJldHVybiAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IHV0Y1RodXJzZGF5KGQpIDogdXRjVGh1cnNkYXkuY2VpbChkKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlcklTTyhkLCBwKSB7XG4gIGQgPSBVVENkSVNPKGQpO1xuICByZXR1cm4gcGFkKHV0Y1RodXJzZGF5LmNvdW50KHV0Y1llYXIoZCksIGQpICsgKHV0Y1llYXIoZCkuZ2V0VVRDRGF5KCkgPT09IDQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlclN1bmRheShkKSB7XG4gIHJldHVybiBkLmdldFVUQ0RheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZCh1dGNNb25kYXkuY291bnQodXRjWWVhcihkKSAtIDEsIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWWVhcklTTyhkLCBwKSB7XG4gIGQgPSBVVENkSVNPKGQpO1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFySVNPKGQsIHApIHtcbiAgdmFyIGRheSA9IGQuZ2V0VVRDRGF5KCk7XG4gIGQgPSAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IHV0Y1RodXJzZGF5KGQpIDogdXRjVGh1cnNkYXkuY2VpbChkKTtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1pvbmUoKSB7XG4gIHJldHVybiBcIiswMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExpdGVyYWxQZXJjZW50KCkge1xuICByZXR1cm4gXCIlXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuaXhUaW1lc3RhbXAoZCkge1xuICByZXR1cm4gK2Q7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzKGQpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoK2QgLyAxMDAwKTtcbn1cbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbkRheSwgZHVyYXRpb25NaW51dGV9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciBkYXkgPSBpbnRlcnZhbChcbiAgZGF0ZSA9PiBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApLFxuICAoZGF0ZSwgc3RlcCkgPT4gZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCksXG4gIChzdGFydCwgZW5kKSA9PiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uRGF5LFxuICBkYXRlID0+IGRhdGUuZ2V0RGF0ZSgpIC0gMVxuKTtcblxuZXhwb3J0IGRlZmF1bHQgZGF5O1xuZXhwb3J0IHZhciBkYXlzID0gZGF5LnJhbmdlO1xuIiwiZXhwb3J0IGNvbnN0IGR1cmF0aW9uU2Vjb25kID0gMTAwMDtcbmV4cG9ydCBjb25zdCBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjA7XG5leHBvcnQgY29uc3QgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MDtcbmV4cG9ydCBjb25zdCBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0O1xuZXhwb3J0IGNvbnN0IGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNztcbmV4cG9ydCBjb25zdCBkdXJhdGlvbk1vbnRoID0gZHVyYXRpb25EYXkgKiAzMDtcbmV4cG9ydCBjb25zdCBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbkhvdXIsIGR1cmF0aW9uTWludXRlLCBkdXJhdGlvblNlY29uZH0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIGhvdXIgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShkYXRlIC0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAtIGRhdGUuZ2V0U2Vjb25kcygpICogZHVyYXRpb25TZWNvbmQgLSBkYXRlLmdldE1pbnV0ZXMoKSAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRIb3VycygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGhvdXI7XG5leHBvcnQgdmFyIGhvdXJzID0gaG91ci5yYW5nZTtcbiIsInZhciB0MCA9IG5ldyBEYXRlLFxuICAgIHQxID0gbmV3IERhdGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQsIGZpZWxkKSB7XG5cbiAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyBuZXcgRGF0ZSA6IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gIH1cblxuICBpbnRlcnZhbC5mbG9vciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLmNlaWwgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZmxvb3JpKGRhdGUpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkMCA9IGludGVydmFsKGRhdGUpLFxuICAgICAgICBkMSA9IGludGVydmFsLmNlaWwoZGF0ZSk7XG4gICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gIH07XG5cbiAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgdmFyIHJhbmdlID0gW10sIHByZXZpb3VzO1xuICAgIHN0YXJ0ID0gaW50ZXJ2YWwuY2VpbChzdGFydCk7XG4gICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgIGlmICghKHN0YXJ0IDwgc3RvcCkgfHwgIShzdGVwID4gMCkpIHJldHVybiByYW5nZTsgLy8gYWxzbyBoYW5kbGVzIEludmFsaWQgRGF0ZVxuICAgIGRvIHJhbmdlLnB1c2gocHJldmlvdXMgPSBuZXcgRGF0ZSgrc3RhcnQpKSwgb2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCk7XG4gICAgd2hpbGUgKHByZXZpb3VzIDwgc3RhcnQgJiYgc3RhcnQgPCBzdG9wKTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB7XG4gICAgICAgIGlmIChzdGVwIDwgMCkgd2hpbGUgKCsrc3RlcCA8PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgLTEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGVsc2Ugd2hpbGUgKC0tc3RlcCA+PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgKzEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGNvdW50KSB7XG4gICAgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIGludGVydmFsLmV2ZXJ5ID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICByZXR1cm4gIWlzRmluaXRlKHN0ZXApIHx8ICEoc3RlcCA+IDApID8gbnVsbFxuICAgICAgICAgIDogIShzdGVwID4gMSkgPyBpbnRlcnZhbFxuICAgICAgICAgIDogaW50ZXJ2YWwuZmlsdGVyKGZpZWxkXG4gICAgICAgICAgICAgID8gZnVuY3Rpb24oZCkgeyByZXR1cm4gZmllbGQoZCkgJSBzdGVwID09PSAwOyB9XG4gICAgICAgICAgICAgIDogZnVuY3Rpb24oZCkgeyByZXR1cm4gaW50ZXJ2YWwuY291bnQoMCwgZCkgJSBzdGVwID09PSAwOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGludGVydmFsO1xufVxuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5cbnZhciBtaWxsaXNlY29uZCA9IGludGVydmFsKGZ1bmN0aW9uKCkge1xuICAvLyBub29wXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxubWlsbGlzZWNvbmQuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIGsgPSBNYXRoLmZsb29yKGspO1xuICBpZiAoIWlzRmluaXRlKGspIHx8ICEoayA+IDApKSByZXR1cm4gbnVsbDtcbiAgaWYgKCEoayA+IDEpKSByZXR1cm4gbWlsbGlzZWNvbmQ7XG4gIHJldHVybiBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoZGF0ZSAvIGspICogayk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogayk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGs7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWlsbGlzZWNvbmQ7XG5leHBvcnQgdmFyIG1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uTWludXRlLCBkdXJhdGlvblNlY29uZH0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIG1pbnV0ZSA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKGRhdGUgLSBkYXRlLmdldE1pbGxpc2Vjb25kcygpIC0gZGF0ZS5nZXRTZWNvbmRzKCkgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtaW51dGU7XG5leHBvcnQgdmFyIG1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcblxudmFyIG1vbnRoID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldERhdGUoMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0TW9udGgoKSAtIHN0YXJ0LmdldE1vbnRoKCkgKyAoZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpKSAqIDEyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1vbnRoO1xuZXhwb3J0IHZhciBtb250aHMgPSBtb250aC5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvblNlY29uZH0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIHNlY29uZCA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKGRhdGUgLSBkYXRlLmdldE1pbGxpc2Vjb25kcygpKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uU2Vjb25kKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvblNlY29uZDtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNlY29uZDtcbmV4cG9ydCB2YXIgc2Vjb25kcyA9IHNlY29uZC5yYW5nZTtcbiIsImltcG9ydCB7YmlzZWN0b3IsIHRpY2tTdGVwfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7ZHVyYXRpb25EYXksIGR1cmF0aW9uSG91ciwgZHVyYXRpb25NaW51dGUsIGR1cmF0aW9uTW9udGgsIGR1cmF0aW9uU2Vjb25kLCBkdXJhdGlvbldlZWssIGR1cmF0aW9uWWVhcn0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBtaWxsaXNlY29uZCBmcm9tIFwiLi9taWxsaXNlY29uZC5qc1wiO1xuaW1wb3J0IHNlY29uZCBmcm9tIFwiLi9zZWNvbmQuanNcIjtcbmltcG9ydCBtaW51dGUgZnJvbSBcIi4vbWludXRlLmpzXCI7XG5pbXBvcnQgaG91ciBmcm9tIFwiLi9ob3VyLmpzXCI7XG5pbXBvcnQgZGF5IGZyb20gXCIuL2RheS5qc1wiO1xuaW1wb3J0IHtzdW5kYXkgYXMgd2Vla30gZnJvbSBcIi4vd2Vlay5qc1wiO1xuaW1wb3J0IG1vbnRoIGZyb20gXCIuL21vbnRoLmpzXCI7XG5pbXBvcnQgeWVhciBmcm9tIFwiLi95ZWFyLmpzXCI7XG5pbXBvcnQgdXRjTWludXRlIGZyb20gXCIuL3V0Y01pbnV0ZS5qc1wiO1xuaW1wb3J0IHV0Y0hvdXIgZnJvbSBcIi4vdXRjSG91ci5qc1wiO1xuaW1wb3J0IHV0Y0RheSBmcm9tIFwiLi91dGNEYXkuanNcIjtcbmltcG9ydCB7dXRjU3VuZGF5IGFzIHV0Y1dlZWt9IGZyb20gXCIuL3V0Y1dlZWsuanNcIjtcbmltcG9ydCB1dGNNb250aCBmcm9tIFwiLi91dGNNb250aC5qc1wiO1xuaW1wb3J0IHV0Y1llYXIgZnJvbSBcIi4vdXRjWWVhci5qc1wiO1xuXG5mdW5jdGlvbiB0aWNrZXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlKSB7XG5cbiAgY29uc3QgdGlja0ludGVydmFscyA9IFtcbiAgICBbc2Vjb25kLCAgMSwgICAgICBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgIDUsICA1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDE1LCAxNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW21pbnV0ZSwgIDEsICAgICAgZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsICA1LCAgNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLFxuICAgIFsgIGhvdXIsICAxLCAgICAgIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgIDYsICA2ICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsIDEyLCAxMiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICAgZGF5LCAgMSwgICAgICBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgIGRheSwgIDIsICAyICogZHVyYXRpb25EYXkgICBdLFxuICAgIFsgIHdlZWssICAxLCAgICAgIGR1cmF0aW9uV2VlayAgXSxcbiAgICBbIG1vbnRoLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyBtb250aCwgIDMsICAzICogZHVyYXRpb25Nb250aCBdLFxuICAgIFsgIHllYXIsICAxLCAgICAgIGR1cmF0aW9uWWVhciAgXVxuICBdO1xuXG4gIGZ1bmN0aW9uIHRpY2tzKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICAgIGNvbnN0IHJldmVyc2UgPSBzdG9wIDwgc3RhcnQ7XG4gICAgaWYgKHJldmVyc2UpIFtzdGFydCwgc3RvcF0gPSBbc3RvcCwgc3RhcnRdO1xuICAgIGNvbnN0IGludGVydmFsID0gY291bnQgJiYgdHlwZW9mIGNvdW50LnJhbmdlID09PSBcImZ1bmN0aW9uXCIgPyBjb3VudCA6IHRpY2tJbnRlcnZhbChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgIGNvbnN0IHRpY2tzID0gaW50ZXJ2YWwgPyBpbnRlcnZhbC5yYW5nZShzdGFydCwgK3N0b3AgKyAxKSA6IFtdOyAvLyBpbmNsdXNpdmUgc3RvcFxuICAgIHJldHVybiByZXZlcnNlID8gdGlja3MucmV2ZXJzZSgpIDogdGlja3M7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrSW50ZXJ2YWwoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIGNvdW50O1xuICAgIGNvbnN0IGkgPSBiaXNlY3RvcigoWywsIHN0ZXBdKSA9PiBzdGVwKS5yaWdodCh0aWNrSW50ZXJ2YWxzLCB0YXJnZXQpO1xuICAgIGlmIChpID09PSB0aWNrSW50ZXJ2YWxzLmxlbmd0aCkgcmV0dXJuIHllYXIuZXZlcnkodGlja1N0ZXAoc3RhcnQgLyBkdXJhdGlvblllYXIsIHN0b3AgLyBkdXJhdGlvblllYXIsIGNvdW50KSk7XG4gICAgaWYgKGkgPT09IDApIHJldHVybiBtaWxsaXNlY29uZC5ldmVyeShNYXRoLm1heCh0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpLCAxKSk7XG4gICAgY29uc3QgW3QsIHN0ZXBdID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgIHJldHVybiB0LmV2ZXJ5KHN0ZXApO1xuICB9XG5cbiAgcmV0dXJuIFt0aWNrcywgdGlja0ludGVydmFsXTtcbn1cblxuY29uc3QgW3V0Y1RpY2tzLCB1dGNUaWNrSW50ZXJ2YWxdID0gdGlja2VyKHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSk7XG5jb25zdCBbdGltZVRpY2tzLCB0aW1lVGlja0ludGVydmFsXSA9IHRpY2tlcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUpO1xuXG5leHBvcnQge3V0Y1RpY2tzLCB1dGNUaWNrSW50ZXJ2YWwsIHRpbWVUaWNrcywgdGltZVRpY2tJbnRlcnZhbH07XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25EYXl9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciB1dGNEYXkgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uRGF5O1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENEYXRlKCkgLSAxO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0Y0RheTtcbmV4cG9ydCB2YXIgdXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbkhvdXJ9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciB1dGNIb3VyID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1dGNIb3VyO1xuZXhwb3J0IHZhciB1dGNIb3VycyA9IHV0Y0hvdXIucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25NaW51dGV9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciB1dGNNaW51dGUgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbk1pbnV0ZTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTWludXRlcygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0Y01pbnV0ZTtcbmV4cG9ydCB2YXIgdXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuXG52YXIgdXRjTW9udGggPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZSgxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENNb250aChkYXRlLmdldFVUQ01vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENNb250aCgpIC0gc3RhcnQuZ2V0VVRDTW9udGgoKSArIChlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01vbnRoKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdXRjTW9udGg7XG5leHBvcnQgdmFyIHV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uV2Vla30gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxuZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gIHJldHVybiBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbldlZWs7XG4gIH0pO1xufVxuXG5leHBvcnQgdmFyIHV0Y1N1bmRheSA9IHV0Y1dlZWtkYXkoMCk7XG5leHBvcnQgdmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG5leHBvcnQgdmFyIHV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xuZXhwb3J0IHZhciB1dGNXZWRuZXNkYXkgPSB1dGNXZWVrZGF5KDMpO1xuZXhwb3J0IHZhciB1dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG5leHBvcnQgdmFyIHV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG5leHBvcnQgdmFyIHV0Y1NhdHVyZGF5ID0gdXRjV2Vla2RheSg2KTtcblxuZXhwb3J0IHZhciB1dGNTdW5kYXlzID0gdXRjU3VuZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNNb25kYXlzID0gdXRjTW9uZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNGcmlkYXlzID0gdXRjRnJpZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuXG52YXIgdXRjWWVhciA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG51dGNZZWFyLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAvIGspICogayk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwICogayk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXRjWWVhcjtcbmV4cG9ydCB2YXIgdXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uTWludXRlLCBkdXJhdGlvbldlZWt9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbmZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICByZXR1cm4gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbmV4cG9ydCB2YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbmV4cG9ydCB2YXIgdHVlc2RheSA9IHdlZWtkYXkoMik7XG5leHBvcnQgdmFyIHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG5leHBvcnQgdmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbmV4cG9ydCB2YXIgZnJpZGF5ID0gd2Vla2RheSg1KTtcbmV4cG9ydCB2YXIgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG5leHBvcnQgdmFyIHN1bmRheXMgPSBzdW5kYXkucmFuZ2U7XG5leHBvcnQgdmFyIG1vbmRheXMgPSBtb25kYXkucmFuZ2U7XG5leHBvcnQgdmFyIHR1ZXNkYXlzID0gdHVlc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgd2VkbmVzZGF5cyA9IHdlZG5lc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgdGh1cnNkYXlzID0gdGh1cnNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIGZyaWRheXMgPSBmcmlkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHNhdHVyZGF5cyA9IHNhdHVyZGF5LnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5cbnZhciB5ZWFyID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnllYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB5ZWFyO1xuZXhwb3J0IHZhciB5ZWFycyA9IHllYXIucmFuZ2U7XG4iLCJpbXBvcnQge1RpbWVyLCBub3d9IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lciwgdG90YWwgPSBkZWxheTtcbiAgaWYgKGRlbGF5ID09IG51bGwpIHJldHVybiB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSwgdDtcbiAgdC5fcmVzdGFydCA9IHQucmVzdGFydDtcbiAgdC5yZXN0YXJ0ID0gZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgZGVsYXkgPSArZGVsYXksIHRpbWUgPSB0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lO1xuICAgIHQuX3Jlc3RhcnQoZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgICBlbGFwc2VkICs9IHRvdGFsO1xuICAgICAgdC5fcmVzdGFydCh0aWNrLCB0b3RhbCArPSBkZWxheSwgdGltZSk7XG4gICAgICBjYWxsYmFjayhlbGFwc2VkKTtcbiAgICB9LCBkZWxheSwgdGltZSk7XG4gIH1cbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuIiwidmFyIGZyYW1lID0gMCwgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XG4gICAgdGltZW91dCA9IDAsIC8vIGlzIGEgdGltZW91dCBwZW5kaW5nP1xuICAgIGludGVydmFsID0gMCwgLy8gYXJlIGFueSB0aW1lcnMgYWN0aXZlP1xuICAgIHBva2VEZWxheSA9IDEwMDAsIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XG4gICAgdGFza0hlYWQsXG4gICAgdGFza1RhaWwsXG4gICAgY2xvY2tMYXN0ID0gMCxcbiAgICBjbG9ja05vdyA9IDAsXG4gICAgY2xvY2tTa2V3ID0gMCxcbiAgICBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsXG4gICAgc2V0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAxNyk7IH07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBjbG9ja05vdyB8fCAoc2V0RnJhbWUoY2xlYXJOb3cpLCBjbG9ja05vdyA9IGNsb2NrLm5vdygpICsgY2xvY2tTa2V3KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJOb3coKSB7XG4gIGNsb2NrTm93ID0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lcihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyRmx1c2goKSB7XG4gIG5vdygpOyAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSwgaWYgbm90IGFscmVhZHkgc2V0LlxuICArK2ZyYW1lOyAvLyBQcmV0ZW5kIHdl4oCZdmUgc2V0IGFuIGFsYXJtLCBpZiB3ZSBoYXZlbuKAmXQgYWxyZWFkeS5cbiAgdmFyIHQgPSB0YXNrSGVhZCwgZTtcbiAgd2hpbGUgKHQpIHtcbiAgICBpZiAoKGUgPSBjbG9ja05vdyAtIHQuX3RpbWUpID49IDApIHQuX2NhbGwuY2FsbChudWxsLCBlKTtcbiAgICB0ID0gdC5fbmV4dDtcbiAgfVxuICAtLWZyYW1lO1xufVxuXG5mdW5jdGlvbiB3YWtlKCkge1xuICBjbG9ja05vdyA9IChjbG9ja0xhc3QgPSBjbG9jay5ub3coKSkgKyBjbG9ja1NrZXc7XG4gIGZyYW1lID0gdGltZW91dCA9IDA7XG4gIHRyeSB7XG4gICAgdGltZXJGbHVzaCgpO1xuICB9IGZpbmFsbHkge1xuICAgIGZyYW1lID0gMDtcbiAgICBuYXAoKTtcbiAgICBjbG9ja05vdyA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9rZSgpIHtcbiAgdmFyIG5vdyA9IGNsb2NrLm5vdygpLCBkZWxheSA9IG5vdyAtIGNsb2NrTGFzdDtcbiAgaWYgKGRlbGF5ID4gcG9rZURlbGF5KSBjbG9ja1NrZXcgLT0gZGVsYXksIGNsb2NrTGFzdCA9IG5vdztcbn1cblxuZnVuY3Rpb24gbmFwKCkge1xuICB2YXIgdDAsIHQxID0gdGFza0hlYWQsIHQyLCB0aW1lID0gSW5maW5pdHk7XG4gIHdoaWxlICh0MSkge1xuICAgIGlmICh0MS5fY2FsbCkge1xuICAgICAgaWYgKHRpbWUgPiB0MS5fdGltZSkgdGltZSA9IHQxLl90aW1lO1xuICAgICAgdDAgPSB0MSwgdDEgPSB0MS5fbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgPSB0MS5fbmV4dCwgdDEuX25leHQgPSBudWxsO1xuICAgICAgdDEgPSB0MCA/IHQwLl9uZXh0ID0gdDIgOiB0YXNrSGVhZCA9IHQyO1xuICAgIH1cbiAgfVxuICB0YXNrVGFpbCA9IHQwO1xuICBzbGVlcCh0aW1lKTtcbn1cblxuZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICBpZiAoZnJhbWUpIHJldHVybjsgLy8gU29vbmVzdCBhbGFybSBhbHJlYWR5IHNldCwgb3Igd2lsbCBiZS5cbiAgaWYgKHRpbWVvdXQpIHRpbWVvdXQgPSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIHZhciBkZWxheSA9IHRpbWUgLSBjbG9ja05vdzsgLy8gU3RyaWN0bHkgbGVzcyB0aGFuIGlmIHdlIHJlY29tcHV0ZWQgY2xvY2tOb3cuXG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgdGltZSAtIGNsb2NrLm5vdygpIC0gY2xvY2tTa2V3KTtcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnRlcnZhbCkgY2xvY2tMYXN0ID0gY2xvY2subm93KCksIGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9rZSwgcG9rZURlbGF5KTtcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xuICB9XG59XG4iLCJcbmNvbnN0IEVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpO1xuY29uc3QgRURHRV9TVEFDSyA9IG5ldyBVaW50MzJBcnJheSg1MTIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWxhdW5hdG9yIHtcblxuICAgIHN0YXRpYyBmcm9tKHBvaW50cywgZ2V0WCA9IGRlZmF1bHRHZXRYLCBnZXRZID0gZGVmYXVsdEdldFkpIHtcbiAgICAgICAgY29uc3QgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IG5ldyBGbG9hdDY0QXJyYXkobiAqIDIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgY29vcmRzWzIgKiBpXSA9IGdldFgocCk7XG4gICAgICAgICAgICBjb29yZHNbMiAqIGkgKyAxXSA9IGdldFkocCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERlbGF1bmF0b3IoY29vcmRzKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb29yZHMpIHtcbiAgICAgICAgY29uc3QgbiA9IGNvb3Jkcy5sZW5ndGggPj4gMTtcbiAgICAgICAgaWYgKG4gPiAwICYmIHR5cGVvZiBjb29yZHNbMF0gIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGNvb3JkcyB0byBjb250YWluIG51bWJlcnMuJyk7XG5cbiAgICAgICAgdGhpcy5jb29yZHMgPSBjb29yZHM7XG5cbiAgICAgICAgLy8gYXJyYXlzIHRoYXQgd2lsbCBzdG9yZSB0aGUgdHJpYW5ndWxhdGlvbiBncmFwaFxuICAgICAgICBjb25zdCBtYXhUcmlhbmdsZXMgPSBNYXRoLm1heCgyICogbiAtIDUsIDApO1xuICAgICAgICB0aGlzLl90cmlhbmdsZXMgPSBuZXcgVWludDMyQXJyYXkobWF4VHJpYW5nbGVzICogMyk7XG4gICAgICAgIHRoaXMuX2hhbGZlZGdlcyA9IG5ldyBJbnQzMkFycmF5KG1heFRyaWFuZ2xlcyAqIDMpO1xuXG4gICAgICAgIC8vIHRlbXBvcmFyeSBhcnJheXMgZm9yIHRyYWNraW5nIHRoZSBlZGdlcyBvZiB0aGUgYWR2YW5jaW5nIGNvbnZleCBodWxsXG4gICAgICAgIHRoaXMuX2hhc2hTaXplID0gTWF0aC5jZWlsKE1hdGguc3FydChuKSk7XG4gICAgICAgIHRoaXMuX2h1bGxQcmV2ID0gbmV3IFVpbnQzMkFycmF5KG4pOyAvLyBlZGdlIHRvIHByZXYgZWRnZVxuICAgICAgICB0aGlzLl9odWxsTmV4dCA9IG5ldyBVaW50MzJBcnJheShuKTsgLy8gZWRnZSB0byBuZXh0IGVkZ2VcbiAgICAgICAgdGhpcy5faHVsbFRyaSA9IG5ldyBVaW50MzJBcnJheShuKTsgLy8gZWRnZSB0byBhZGphY2VudCB0cmlhbmdsZVxuICAgICAgICB0aGlzLl9odWxsSGFzaCA9IG5ldyBJbnQzMkFycmF5KHRoaXMuX2hhc2hTaXplKS5maWxsKC0xKTsgLy8gYW5ndWxhciBlZGdlIGhhc2hcblxuICAgICAgICAvLyB0ZW1wb3JhcnkgYXJyYXlzIGZvciBzb3J0aW5nIHBvaW50c1xuICAgICAgICB0aGlzLl9pZHMgPSBuZXcgVWludDMyQXJyYXkobik7XG4gICAgICAgIHRoaXMuX2Rpc3RzID0gbmV3IEZsb2F0NjRBcnJheShuKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3Qge2Nvb3JkcywgX2h1bGxQcmV2OiBodWxsUHJldiwgX2h1bGxOZXh0OiBodWxsTmV4dCwgX2h1bGxUcmk6IGh1bGxUcmksIF9odWxsSGFzaDogaHVsbEhhc2h9ID0gIHRoaXM7XG4gICAgICAgIGNvbnN0IG4gPSBjb29yZHMubGVuZ3RoID4+IDE7XG5cbiAgICAgICAgLy8gcG9wdWxhdGUgYW4gYXJyYXkgb2YgcG9pbnQgaW5kaWNlczsgY2FsY3VsYXRlIGlucHV0IGRhdGEgYmJveFxuICAgICAgICBsZXQgbWluWCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgbWluWSA9IEluZmluaXR5O1xuICAgICAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgbGV0IG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBjb29yZHNbMiAqIGldO1xuICAgICAgICAgICAgY29uc3QgeSA9IGNvb3Jkc1syICogaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgICAgIHRoaXMuX2lkc1tpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3ggPSAobWluWCArIG1heFgpIC8gMjtcbiAgICAgICAgY29uc3QgY3kgPSAobWluWSArIG1heFkpIC8gMjtcblxuICAgICAgICBsZXQgbWluRGlzdCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgaTAsIGkxLCBpMjtcblxuICAgICAgICAvLyBwaWNrIGEgc2VlZCBwb2ludCBjbG9zZSB0byB0aGUgY2VudGVyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gZGlzdChjeCwgY3ksIGNvb3Jkc1syICogaV0sIGNvb3Jkc1syICogaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChkIDwgbWluRGlzdCkge1xuICAgICAgICAgICAgICAgIGkwID0gaTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpMHggPSBjb29yZHNbMiAqIGkwXTtcbiAgICAgICAgY29uc3QgaTB5ID0gY29vcmRzWzIgKiBpMCArIDFdO1xuXG4gICAgICAgIG1pbkRpc3QgPSBJbmZpbml0eTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBzZWVkXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaTApIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZCA9IGRpc3QoaTB4LCBpMHksIGNvb3Jkc1syICogaV0sIGNvb3Jkc1syICogaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChkIDwgbWluRGlzdCAmJiBkID4gMCkge1xuICAgICAgICAgICAgICAgIGkxID0gaTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaTF4ID0gY29vcmRzWzIgKiBpMV07XG4gICAgICAgIGxldCBpMXkgPSBjb29yZHNbMiAqIGkxICsgMV07XG5cbiAgICAgICAgbGV0IG1pblJhZGl1cyA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHRoaXJkIHBvaW50IHdoaWNoIGZvcm1zIHRoZSBzbWFsbGVzdCBjaXJjdW1jaXJjbGUgd2l0aCB0aGUgZmlyc3QgdHdvXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaTAgfHwgaSA9PT0gaTEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgciA9IGNpcmN1bXJhZGl1cyhpMHgsIGkweSwgaTF4LCBpMXksIGNvb3Jkc1syICogaV0sIGNvb3Jkc1syICogaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyIDwgbWluUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgaTIgPSBpO1xuICAgICAgICAgICAgICAgIG1pblJhZGl1cyA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkyeCA9IGNvb3Jkc1syICogaTJdO1xuICAgICAgICBsZXQgaTJ5ID0gY29vcmRzWzIgKiBpMiArIDFdO1xuXG4gICAgICAgIGlmIChtaW5SYWRpdXMgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvLyBvcmRlciBjb2xsaW5lYXIgcG9pbnRzIGJ5IGR4IChvciBkeSBpZiBhbGwgeCBhcmUgaWRlbnRpY2FsKVxuICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgbGlzdCBhcyBhIGh1bGxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdHNbaV0gPSAoY29vcmRzWzIgKiBpXSAtIGNvb3Jkc1swXSkgfHwgKGNvb3Jkc1syICogaSArIDFdIC0gY29vcmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1aWNrc29ydCh0aGlzLl9pZHMsIHRoaXMuX2Rpc3RzLCAwLCBuIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBodWxsID0gbmV3IFVpbnQzMkFycmF5KG4pO1xuICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGQwID0gLUluZmluaXR5OyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLl9pZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3RzW2lkXSA+IGQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGh1bGxbaisrXSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICBkMCA9IHRoaXMuX2Rpc3RzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmh1bGwgPSBodWxsLnN1YmFycmF5KDAsIGopO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZXMgPSBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgICAgICAgICB0aGlzLmhhbGZlZGdlcyA9IG5ldyBVaW50MzJBcnJheSgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN3YXAgdGhlIG9yZGVyIG9mIHRoZSBzZWVkIHBvaW50cyBmb3IgY291bnRlci1jbG9ja3dpc2Ugb3JpZW50YXRpb25cbiAgICAgICAgaWYgKG9yaWVudChpMHgsIGkweSwgaTF4LCBpMXksIGkyeCwgaTJ5KSkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGkxO1xuICAgICAgICAgICAgY29uc3QgeCA9IGkxeDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBpMXk7XG4gICAgICAgICAgICBpMSA9IGkyO1xuICAgICAgICAgICAgaTF4ID0gaTJ4O1xuICAgICAgICAgICAgaTF5ID0gaTJ5O1xuICAgICAgICAgICAgaTIgPSBpO1xuICAgICAgICAgICAgaTJ4ID0geDtcbiAgICAgICAgICAgIGkyeSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjZW50ZXIgPSBjaXJjdW1jZW50ZXIoaTB4LCBpMHksIGkxeCwgaTF5LCBpMngsIGkyeSk7XG4gICAgICAgIHRoaXMuX2N4ID0gY2VudGVyLng7XG4gICAgICAgIHRoaXMuX2N5ID0gY2VudGVyLnk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RzW2ldID0gZGlzdChjb29yZHNbMiAqIGldLCBjb29yZHNbMiAqIGkgKyAxXSwgY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNvcnQgdGhlIHBvaW50cyBieSBkaXN0YW5jZSBmcm9tIHRoZSBzZWVkIHRyaWFuZ2xlIGNpcmN1bWNlbnRlclxuICAgICAgICBxdWlja3NvcnQodGhpcy5faWRzLCB0aGlzLl9kaXN0cywgMCwgbiAtIDEpO1xuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgc2VlZCB0cmlhbmdsZSBhcyB0aGUgc3RhcnRpbmcgaHVsbFxuICAgICAgICB0aGlzLl9odWxsU3RhcnQgPSBpMDtcbiAgICAgICAgbGV0IGh1bGxTaXplID0gMztcblxuICAgICAgICBodWxsTmV4dFtpMF0gPSBodWxsUHJldltpMl0gPSBpMTtcbiAgICAgICAgaHVsbE5leHRbaTFdID0gaHVsbFByZXZbaTBdID0gaTI7XG4gICAgICAgIGh1bGxOZXh0W2kyXSA9IGh1bGxQcmV2W2kxXSA9IGkwO1xuXG4gICAgICAgIGh1bGxUcmlbaTBdID0gMDtcbiAgICAgICAgaHVsbFRyaVtpMV0gPSAxO1xuICAgICAgICBodWxsVHJpW2kyXSA9IDI7XG5cbiAgICAgICAgaHVsbEhhc2guZmlsbCgtMSk7XG4gICAgICAgIGh1bGxIYXNoW3RoaXMuX2hhc2hLZXkoaTB4LCBpMHkpXSA9IGkwO1xuICAgICAgICBodWxsSGFzaFt0aGlzLl9oYXNoS2V5KGkxeCwgaTF5KV0gPSBpMTtcbiAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleShpMngsIGkyeSldID0gaTI7XG5cbiAgICAgICAgdGhpcy50cmlhbmdsZXNMZW4gPSAwO1xuICAgICAgICB0aGlzLl9hZGRUcmlhbmdsZShpMCwgaTEsIGkyLCAtMSwgLTEsIC0xKTtcblxuICAgICAgICBmb3IgKGxldCBrID0gMCwgeHAsIHlwOyBrIDwgdGhpcy5faWRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcy5faWRzW2tdO1xuICAgICAgICAgICAgY29uc3QgeCA9IGNvb3Jkc1syICogaV07XG4gICAgICAgICAgICBjb25zdCB5ID0gY29vcmRzWzIgKiBpICsgMV07XG5cbiAgICAgICAgICAgIC8vIHNraXAgbmVhci1kdXBsaWNhdGUgcG9pbnRzXG4gICAgICAgICAgICBpZiAoayA+IDAgJiYgTWF0aC5hYnMoeCAtIHhwKSA8PSBFUFNJTE9OICYmIE1hdGguYWJzKHkgLSB5cCkgPD0gRVBTSUxPTikgY29udGludWU7XG4gICAgICAgICAgICB4cCA9IHg7XG4gICAgICAgICAgICB5cCA9IHk7XG5cbiAgICAgICAgICAgIC8vIHNraXAgc2VlZCB0cmlhbmdsZSBwb2ludHNcbiAgICAgICAgICAgIGlmIChpID09PSBpMCB8fCBpID09PSBpMSB8fCBpID09PSBpMikgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgYSB2aXNpYmxlIGVkZ2Ugb24gdGhlIGNvbnZleCBodWxsIHVzaW5nIGVkZ2UgaGFzaFxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBrZXkgPSB0aGlzLl9oYXNoS2V5KHgsIHkpOyBqIDwgdGhpcy5faGFzaFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaHVsbEhhc2hbKGtleSArIGopICUgdGhpcy5faGFzaFNpemVdO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCAhPT0gLTEgJiYgc3RhcnQgIT09IGh1bGxOZXh0W3N0YXJ0XSkgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXJ0ID0gaHVsbFByZXZbc3RhcnRdO1xuICAgICAgICAgICAgbGV0IGUgPSBzdGFydCwgcTtcbiAgICAgICAgICAgIHdoaWxlIChxID0gaHVsbE5leHRbZV0sICFvcmllbnQoeCwgeSwgY29vcmRzWzIgKiBlXSwgY29vcmRzWzIgKiBlICsgMV0sIGNvb3Jkc1syICogcV0sIGNvb3Jkc1syICogcSArIDFdKSkge1xuICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgIGlmIChlID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBlID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlID09PSAtMSkgY29udGludWU7IC8vIGxpa2VseSBhIG5lYXItZHVwbGljYXRlIHBvaW50OyBza2lwIGl0XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgZmlyc3QgdHJpYW5nbGUgZnJvbSB0aGUgcG9pbnRcbiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5fYWRkVHJpYW5nbGUoZSwgaSwgaHVsbE5leHRbZV0sIC0xLCAtMSwgaHVsbFRyaVtlXSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGZsaXAgdHJpYW5nbGVzIGZyb20gdGhlIHBvaW50IHVudGlsIHRoZXkgc2F0aXNmeSB0aGUgRGVsYXVuYXkgY29uZGl0aW9uXG4gICAgICAgICAgICBodWxsVHJpW2ldID0gdGhpcy5fbGVnYWxpemUodCArIDIpO1xuICAgICAgICAgICAgaHVsbFRyaVtlXSA9IHQ7IC8vIGtlZXAgdHJhY2sgb2YgYm91bmRhcnkgdHJpYW5nbGVzIG9uIHRoZSBodWxsXG4gICAgICAgICAgICBodWxsU2l6ZSsrO1xuXG4gICAgICAgICAgICAvLyB3YWxrIGZvcndhcmQgdGhyb3VnaCB0aGUgaHVsbCwgYWRkaW5nIG1vcmUgdHJpYW5nbGVzIGFuZCBmbGlwcGluZyByZWN1cnNpdmVseVxuICAgICAgICAgICAgbGV0IG4gPSBodWxsTmV4dFtlXTtcbiAgICAgICAgICAgIHdoaWxlIChxID0gaHVsbE5leHRbbl0sIG9yaWVudCh4LCB5LCBjb29yZHNbMiAqIG5dLCBjb29yZHNbMiAqIG4gKyAxXSwgY29vcmRzWzIgKiBxXSwgY29vcmRzWzIgKiBxICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgdCA9IHRoaXMuX2FkZFRyaWFuZ2xlKG4sIGksIHEsIGh1bGxUcmlbaV0sIC0xLCBodWxsVHJpW25dKTtcbiAgICAgICAgICAgICAgICBodWxsVHJpW2ldID0gdGhpcy5fbGVnYWxpemUodCArIDIpO1xuICAgICAgICAgICAgICAgIGh1bGxOZXh0W25dID0gbjsgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgaHVsbFNpemUtLTtcbiAgICAgICAgICAgICAgICBuID0gcTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2FsayBiYWNrd2FyZCBmcm9tIHRoZSBvdGhlciBzaWRlLCBhZGRpbmcgbW9yZSB0cmlhbmdsZXMgYW5kIGZsaXBwaW5nXG4gICAgICAgICAgICBpZiAoZSA9PT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocSA9IGh1bGxQcmV2W2VdLCBvcmllbnQoeCwgeSwgY29vcmRzWzIgKiBxXSwgY29vcmRzWzIgKiBxICsgMV0sIGNvb3Jkc1syICogZV0sIGNvb3Jkc1syICogZSArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5fYWRkVHJpYW5nbGUocSwgaSwgZSwgLTEsIGh1bGxUcmlbZV0sIGh1bGxUcmlbcV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZWdhbGl6ZSh0ICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGh1bGxUcmlbcV0gPSB0O1xuICAgICAgICAgICAgICAgICAgICBodWxsTmV4dFtlXSA9IGU7IC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICBodWxsU2l6ZS0tO1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaHVsbCBpbmRpY2VzXG4gICAgICAgICAgICB0aGlzLl9odWxsU3RhcnQgPSBodWxsUHJldltpXSA9IGU7XG4gICAgICAgICAgICBodWxsTmV4dFtlXSA9IGh1bGxQcmV2W25dID0gaTtcbiAgICAgICAgICAgIGh1bGxOZXh0W2ldID0gbjtcblxuICAgICAgICAgICAgLy8gc2F2ZSB0aGUgdHdvIG5ldyBlZGdlcyBpbiB0aGUgaGFzaCB0YWJsZVxuICAgICAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleSh4LCB5KV0gPSBpO1xuICAgICAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleShjb29yZHNbMiAqIGVdLCBjb29yZHNbMiAqIGUgKyAxXSldID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaHVsbCA9IG5ldyBVaW50MzJBcnJheShodWxsU2l6ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gdGhpcy5faHVsbFN0YXJ0OyBpIDwgaHVsbFNpemU7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5odWxsW2ldID0gZTtcbiAgICAgICAgICAgIGUgPSBodWxsTmV4dFtlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaW0gdHlwZWQgdHJpYW5nbGUgbWVzaCBhcnJheXNcbiAgICAgICAgdGhpcy50cmlhbmdsZXMgPSB0aGlzLl90cmlhbmdsZXMuc3ViYXJyYXkoMCwgdGhpcy50cmlhbmdsZXNMZW4pO1xuICAgICAgICB0aGlzLmhhbGZlZGdlcyA9IHRoaXMuX2hhbGZlZGdlcy5zdWJhcnJheSgwLCB0aGlzLnRyaWFuZ2xlc0xlbik7XG4gICAgfVxuXG4gICAgX2hhc2hLZXkoeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihwc2V1ZG9BbmdsZSh4IC0gdGhpcy5fY3gsIHkgLSB0aGlzLl9jeSkgKiB0aGlzLl9oYXNoU2l6ZSkgJSB0aGlzLl9oYXNoU2l6ZTtcbiAgICB9XG5cbiAgICBfbGVnYWxpemUoYSkge1xuICAgICAgICBjb25zdCB7X3RyaWFuZ2xlczogdHJpYW5nbGVzLCBfaGFsZmVkZ2VzOiBoYWxmZWRnZXMsIGNvb3Jkc30gPSB0aGlzO1xuXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGFyID0gMDtcblxuICAgICAgICAvLyByZWN1cnNpb24gZWxpbWluYXRlZCB3aXRoIGEgZml4ZWQtc2l6ZSBzdGFja1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgYiA9IGhhbGZlZGdlc1thXTtcblxuICAgICAgICAgICAgLyogaWYgdGhlIHBhaXIgb2YgdHJpYW5nbGVzIGRvZXNuJ3Qgc2F0aXNmeSB0aGUgRGVsYXVuYXkgY29uZGl0aW9uXG4gICAgICAgICAgICAgKiAocDEgaXMgaW5zaWRlIHRoZSBjaXJjdW1jaXJjbGUgb2YgW3AwLCBwbCwgcHJdKSwgZmxpcCB0aGVtLFxuICAgICAgICAgICAgICogdGhlbiBkbyB0aGUgc2FtZSBjaGVjay9mbGlwIHJlY3Vyc2l2ZWx5IGZvciB0aGUgbmV3IHBhaXIgb2YgdHJpYW5nbGVzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAgICAgIHBsICAgICAgICAgICAgICAgICAgICBwbFxuICAgICAgICAgICAgICogICAgICAgICAgL3x8XFwgICAgICAgICAgICAgICAgICAvICBcXFxuICAgICAgICAgICAgICogICAgICAgYWwvIHx8IFxcYmwgICAgICAgICAgICBhbC8gICAgXFxhXG4gICAgICAgICAgICAgKiAgICAgICAgLyAgfHwgIFxcICAgICAgICAgICAgICAvICAgICAgXFxcbiAgICAgICAgICAgICAqICAgICAgIC8gIGF8fGIgIFxcICAgIGZsaXAgICAgL19fX2FyX19fXFxcbiAgICAgICAgICAgICAqICAgICBwMFxcICAgfHwgICAvcDEgICA9PiAgIHAwXFwtLS1ibC0tLS9wMVxuICAgICAgICAgICAgICogICAgICAgIFxcICB8fCAgLyAgICAgICAgICAgICAgXFwgICAgICAvXG4gICAgICAgICAgICAgKiAgICAgICBhclxcIHx8IC9iciAgICAgICAgICAgICBiXFwgICAgL2JyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcXHx8LyAgICAgICAgICAgICAgICAgIFxcICAvXG4gICAgICAgICAgICAgKiAgICAgICAgICAgcHIgICAgICAgICAgICAgICAgICAgIHByXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGEwID0gYSAtIGEgJSAzO1xuICAgICAgICAgICAgYXIgPSBhMCArIChhICsgMikgJSAzO1xuXG4gICAgICAgICAgICBpZiAoYiA9PT0gLTEpIHsgLy8gY29udmV4IGh1bGwgZWRnZVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcbiAgICAgICAgICAgICAgICBhID0gRURHRV9TVEFDS1stLWldO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBiMCA9IGIgLSBiICUgMztcbiAgICAgICAgICAgIGNvbnN0IGFsID0gYTAgKyAoYSArIDEpICUgMztcbiAgICAgICAgICAgIGNvbnN0IGJsID0gYjAgKyAoYiArIDIpICUgMztcblxuICAgICAgICAgICAgY29uc3QgcDAgPSB0cmlhbmdsZXNbYXJdO1xuICAgICAgICAgICAgY29uc3QgcHIgPSB0cmlhbmdsZXNbYV07XG4gICAgICAgICAgICBjb25zdCBwbCA9IHRyaWFuZ2xlc1thbF07XG4gICAgICAgICAgICBjb25zdCBwMSA9IHRyaWFuZ2xlc1tibF07XG5cbiAgICAgICAgICAgIGNvbnN0IGlsbGVnYWwgPSBpbkNpcmNsZShcbiAgICAgICAgICAgICAgICBjb29yZHNbMiAqIHAwXSwgY29vcmRzWzIgKiBwMCArIDFdLFxuICAgICAgICAgICAgICAgIGNvb3Jkc1syICogcHJdLCBjb29yZHNbMiAqIHByICsgMV0sXG4gICAgICAgICAgICAgICAgY29vcmRzWzIgKiBwbF0sIGNvb3Jkc1syICogcGwgKyAxXSxcbiAgICAgICAgICAgICAgICBjb29yZHNbMiAqIHAxXSwgY29vcmRzWzIgKiBwMSArIDFdKTtcblxuICAgICAgICAgICAgaWYgKGlsbGVnYWwpIHtcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXNbYV0gPSBwMTtcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXNbYl0gPSBwMDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGhibCA9IGhhbGZlZGdlc1tibF07XG5cbiAgICAgICAgICAgICAgICAvLyBlZGdlIHN3YXBwZWQgb24gdGhlIG90aGVyIHNpZGUgb2YgdGhlIGh1bGwgKHJhcmUpOyBmaXggdGhlIGhhbGZlZGdlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGlmIChoYmwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlID0gdGhpcy5faHVsbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faHVsbFRyaVtlXSA9PT0gYmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9odWxsVHJpW2VdID0gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLl9odWxsUHJldltlXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZSAhPT0gdGhpcy5faHVsbFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluayhhLCBoYmwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmsoYiwgaGFsZmVkZ2VzW2FyXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluayhhciwgYmwpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYnIgPSBiMCArIChiICsgMSkgJSAzO1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgd29ycnkgYWJvdXQgaGl0dGluZyB0aGUgY2FwOiBpdCBjYW4gb25seSBoYXBwZW4gb24gZXh0cmVtZWx5IGRlZ2VuZXJhdGUgaW5wdXRcbiAgICAgICAgICAgICAgICBpZiAoaSA8IEVER0VfU1RBQ0subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIEVER0VfU1RBQ0tbaSsrXSA9IGJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xuICAgICAgICAgICAgICAgIGEgPSBFREdFX1NUQUNLWy0taV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXI7XG4gICAgfVxuXG4gICAgX2xpbmsoYSwgYikge1xuICAgICAgICB0aGlzLl9oYWxmZWRnZXNbYV0gPSBiO1xuICAgICAgICBpZiAoYiAhPT0gLTEpIHRoaXMuX2hhbGZlZGdlc1tiXSA9IGE7XG4gICAgfVxuXG4gICAgLy8gYWRkIGEgbmV3IHRyaWFuZ2xlIGdpdmVuIHZlcnRleCBpbmRpY2VzIGFuZCBhZGphY2VudCBoYWxmLWVkZ2UgaWRzXG4gICAgX2FkZFRyaWFuZ2xlKGkwLCBpMSwgaTIsIGEsIGIsIGMpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMudHJpYW5nbGVzTGVuO1xuXG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlc1t0XSA9IGkwO1xuICAgICAgICB0aGlzLl90cmlhbmdsZXNbdCArIDFdID0gaTE7XG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlc1t0ICsgMl0gPSBpMjtcblxuICAgICAgICB0aGlzLl9saW5rKHQsIGEpO1xuICAgICAgICB0aGlzLl9saW5rKHQgKyAxLCBiKTtcbiAgICAgICAgdGhpcy5fbGluayh0ICsgMiwgYyk7XG5cbiAgICAgICAgdGhpcy50cmlhbmdsZXNMZW4gKz0gMztcblxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG59XG5cbi8vIG1vbm90b25pY2FsbHkgaW5jcmVhc2VzIHdpdGggcmVhbCBhbmdsZSwgYnV0IGRvZXNuJ3QgbmVlZCBleHBlbnNpdmUgdHJpZ29ub21ldHJ5XG5mdW5jdGlvbiBwc2V1ZG9BbmdsZShkeCwgZHkpIHtcbiAgICBjb25zdCBwID0gZHggLyAoTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKTtcbiAgICByZXR1cm4gKGR5ID4gMCA/IDMgLSBwIDogMSArIHApIC8gNDsgLy8gWzAuLjFdXG59XG5cbmZ1bmN0aW9uIGRpc3QoYXgsIGF5LCBieCwgYnkpIHtcbiAgICBjb25zdCBkeCA9IGF4IC0gYng7XG4gICAgY29uc3QgZHkgPSBheSAtIGJ5O1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLy8gcmV0dXJuIDJkIG9yaWVudGF0aW9uIHNpZ24gaWYgd2UncmUgY29uZmlkZW50IGluIGl0IHRocm91Z2ggSi4gU2hld2NodWsncyBlcnJvciBib3VuZCBjaGVja1xuZnVuY3Rpb24gb3JpZW50SWZTdXJlKHB4LCBweSwgcngsIHJ5LCBxeCwgcXkpIHtcbiAgICBjb25zdCBsID0gKHJ5IC0gcHkpICogKHF4IC0gcHgpO1xuICAgIGNvbnN0IHIgPSAocnggLSBweCkgKiAocXkgLSBweSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKGwgLSByKSA+PSAzLjMzMDY2OTA3Mzg3NTQ3MTZlLTE2ICogTWF0aC5hYnMobCArIHIpID8gbCAtIHIgOiAwO1xufVxuXG4vLyBhIG1vcmUgcm9idXN0IG9yaWVudGF0aW9uIHRlc3QgdGhhdCdzIHN0YWJsZSBpbiBhIGdpdmVuIHRyaWFuZ2xlICh0byBmaXggcm9idXN0bmVzcyBpc3N1ZXMpXG5mdW5jdGlvbiBvcmllbnQocngsIHJ5LCBxeCwgcXksIHB4LCBweSkge1xuICAgIGNvbnN0IHNpZ24gPSBvcmllbnRJZlN1cmUocHgsIHB5LCByeCwgcnksIHF4LCBxeSkgfHxcbiAgICBvcmllbnRJZlN1cmUocngsIHJ5LCBxeCwgcXksIHB4LCBweSkgfHxcbiAgICBvcmllbnRJZlN1cmUocXgsIHF5LCBweCwgcHksIHJ4LCByeSk7XG4gICAgcmV0dXJuIHNpZ24gPCAwO1xufVxuXG5mdW5jdGlvbiBpbkNpcmNsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICBjb25zdCBkeCA9IGF4IC0gcHg7XG4gICAgY29uc3QgZHkgPSBheSAtIHB5O1xuICAgIGNvbnN0IGV4ID0gYnggLSBweDtcbiAgICBjb25zdCBleSA9IGJ5IC0gcHk7XG4gICAgY29uc3QgZnggPSBjeCAtIHB4O1xuICAgIGNvbnN0IGZ5ID0gY3kgLSBweTtcblxuICAgIGNvbnN0IGFwID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgY29uc3QgYnAgPSBleCAqIGV4ICsgZXkgKiBleTtcbiAgICBjb25zdCBjcCA9IGZ4ICogZnggKyBmeSAqIGZ5O1xuXG4gICAgcmV0dXJuIGR4ICogKGV5ICogY3AgLSBicCAqIGZ5KSAtXG4gICAgICAgICAgIGR5ICogKGV4ICogY3AgLSBicCAqIGZ4KSArXG4gICAgICAgICAgIGFwICogKGV4ICogZnkgLSBleSAqIGZ4KSA8IDA7XG59XG5cbmZ1bmN0aW9uIGNpcmN1bXJhZGl1cyhheCwgYXksIGJ4LCBieSwgY3gsIGN5KSB7XG4gICAgY29uc3QgZHggPSBieCAtIGF4O1xuICAgIGNvbnN0IGR5ID0gYnkgLSBheTtcbiAgICBjb25zdCBleCA9IGN4IC0gYXg7XG4gICAgY29uc3QgZXkgPSBjeSAtIGF5O1xuXG4gICAgY29uc3QgYmwgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBjb25zdCBjbCA9IGV4ICogZXggKyBleSAqIGV5O1xuICAgIGNvbnN0IGQgPSAwLjUgLyAoZHggKiBleSAtIGR5ICogZXgpO1xuXG4gICAgY29uc3QgeCA9IChleSAqIGJsIC0gZHkgKiBjbCkgKiBkO1xuICAgIGNvbnN0IHkgPSAoZHggKiBjbCAtIGV4ICogYmwpICogZDtcblxuICAgIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuXG5mdW5jdGlvbiBjaXJjdW1jZW50ZXIoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkge1xuICAgIGNvbnN0IGR4ID0gYnggLSBheDtcbiAgICBjb25zdCBkeSA9IGJ5IC0gYXk7XG4gICAgY29uc3QgZXggPSBjeCAtIGF4O1xuICAgIGNvbnN0IGV5ID0gY3kgLSBheTtcblxuICAgIGNvbnN0IGJsID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgY29uc3QgY2wgPSBleCAqIGV4ICsgZXkgKiBleTtcbiAgICBjb25zdCBkID0gMC41IC8gKGR4ICogZXkgLSBkeSAqIGV4KTtcblxuICAgIGNvbnN0IHggPSBheCArIChleSAqIGJsIC0gZHkgKiBjbCkgKiBkO1xuICAgIGNvbnN0IHkgPSBheSArIChkeCAqIGNsIC0gZXggKiBibCkgKiBkO1xuXG4gICAgcmV0dXJuIHt4LCB5fTtcbn1cblxuZnVuY3Rpb24gcXVpY2tzb3J0KGlkcywgZGlzdHMsIGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSAyMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gbGVmdCArIDE7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBEaXN0ID0gZGlzdHNbdGVtcF07XG4gICAgICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGogPj0gbGVmdCAmJiBkaXN0c1tpZHNbal1dID4gdGVtcERpc3QpIGlkc1tqICsgMV0gPSBpZHNbai0tXTtcbiAgICAgICAgICAgIGlkc1tqICsgMV0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVkaWFuID0gKGxlZnQgKyByaWdodCkgPj4gMTtcbiAgICAgICAgbGV0IGkgPSBsZWZ0ICsgMTtcbiAgICAgICAgbGV0IGogPSByaWdodDtcbiAgICAgICAgc3dhcChpZHMsIG1lZGlhbiwgaSk7XG4gICAgICAgIGlmIChkaXN0c1tpZHNbbGVmdF1dID4gZGlzdHNbaWRzW3JpZ2h0XV0pIHN3YXAoaWRzLCBsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChkaXN0c1tpZHNbaV1dID4gZGlzdHNbaWRzW3JpZ2h0XV0pIHN3YXAoaWRzLCBpLCByaWdodCk7XG4gICAgICAgIGlmIChkaXN0c1tpZHNbbGVmdF1dID4gZGlzdHNbaWRzW2ldXSkgc3dhcChpZHMsIGxlZnQsIGkpO1xuXG4gICAgICAgIGNvbnN0IHRlbXAgPSBpZHNbaV07XG4gICAgICAgIGNvbnN0IHRlbXBEaXN0ID0gZGlzdHNbdGVtcF07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBkbyBpKys7IHdoaWxlIChkaXN0c1tpZHNbaV1dIDwgdGVtcERpc3QpO1xuICAgICAgICAgICAgZG8gai0tOyB3aGlsZSAoZGlzdHNbaWRzW2pdXSA+IHRlbXBEaXN0KTtcbiAgICAgICAgICAgIGlmIChqIDwgaSkgYnJlYWs7XG4gICAgICAgICAgICBzd2FwKGlkcywgaSwgaik7XG4gICAgICAgIH1cbiAgICAgICAgaWRzW2xlZnQgKyAxXSA9IGlkc1tqXTtcbiAgICAgICAgaWRzW2pdID0gdGVtcDtcblxuICAgICAgICBpZiAocmlnaHQgLSBpICsgMSA+PSBqIC0gbGVmdCkge1xuICAgICAgICAgICAgcXVpY2tzb3J0KGlkcywgZGlzdHMsIGksIHJpZ2h0KTtcbiAgICAgICAgICAgIHF1aWNrc29ydChpZHMsIGRpc3RzLCBsZWZ0LCBqIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWlja3NvcnQoaWRzLCBkaXN0cywgbGVmdCwgaiAtIDEpO1xuICAgICAgICAgICAgcXVpY2tzb3J0KGlkcywgZGlzdHMsIGksIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICBjb25zdCB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEdldFgocCkge1xuICAgIHJldHVybiBwWzBdO1xufVxuZnVuY3Rpb24gZGVmYXVsdEdldFkocCkge1xuICAgIHJldHVybiBwWzFdO1xufVxuIiwiaW1wb3J0IHRyYW5zZm9ybSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgdmFyIHQgPSB0cmFuc2Zvcm0odG9wb2xvZ3kudHJhbnNmb3JtKSwga2V5LFxuICAgICAgeDAgPSBJbmZpbml0eSwgeTAgPSB4MCwgeDEgPSAteDAsIHkxID0gLXgwO1xuXG4gIGZ1bmN0aW9uIGJib3hQb2ludChwKSB7XG4gICAgcCA9IHQocCk7XG4gICAgaWYgKHBbMF0gPCB4MCkgeDAgPSBwWzBdO1xuICAgIGlmIChwWzBdID4geDEpIHgxID0gcFswXTtcbiAgICBpZiAocFsxXSA8IHkwKSB5MCA9IHBbMV07XG4gICAgaWYgKHBbMV0gPiB5MSkgeTEgPSBwWzFdO1xuICB9XG5cbiAgZnVuY3Rpb24gYmJveEdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChiYm94R2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBiYm94UG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogby5jb29yZGluYXRlcy5mb3JFYWNoKGJib3hQb2ludCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRvcG9sb2d5LmFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJjLmxlbmd0aCwgcDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcCA9IHQoYXJjW2ldLCBpKTtcbiAgICAgIGlmIChwWzBdIDwgeDApIHgwID0gcFswXTtcbiAgICAgIGlmIChwWzBdID4geDEpIHgxID0gcFswXTtcbiAgICAgIGlmIChwWzFdIDwgeTApIHkwID0gcFsxXTtcbiAgICAgIGlmIChwWzFdID4geTEpIHkxID0gcFsxXTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvciAoa2V5IGluIHRvcG9sb2d5Lm9iamVjdHMpIHtcbiAgICBiYm94R2VvbWV0cnkodG9wb2xvZ3kub2JqZWN0c1trZXldKTtcbiAgfVxuXG4gIHJldHVybiBbeDAsIHkwLCB4MSwgeTFdO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgeCkge1xuICB2YXIgbG8gPSAwLCBoaSA9IGEubGVuZ3RoO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmIChhW21pZF0gPCB4KSBsbyA9IG1pZCArIDE7XG4gICAgZWxzZSBoaSA9IG1pZDtcbiAgfVxuICByZXR1cm4gbG87XG59XG4iLCJpbXBvcnQgcmV2ZXJzZSBmcm9tIFwiLi9yZXZlcnNlLmpzXCI7XG5pbXBvcnQgdHJhbnNmb3JtIGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgbykge1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIG8gPSB0b3BvbG9neS5vYmplY3RzW29dO1xuICByZXR1cm4gby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiXG4gICAgICA/IHt0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsIGZlYXR1cmVzOiBvLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGZlYXR1cmUodG9wb2xvZ3ksIG8pOyB9KX1cbiAgICAgIDogZmVhdHVyZSh0b3BvbG9neSwgbyk7XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmUodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIGlkID0gby5pZCxcbiAgICAgIGJib3ggPSBvLmJib3gsXG4gICAgICBwcm9wZXJ0aWVzID0gby5wcm9wZXJ0aWVzID09IG51bGwgPyB7fSA6IG8ucHJvcGVydGllcyxcbiAgICAgIGdlb21ldHJ5ID0gb2JqZWN0KHRvcG9sb2d5LCBvKTtcbiAgcmV0dXJuIGlkID09IG51bGwgJiYgYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IGJib3ggPT0gbnVsbCA/IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBiYm94OiBiYm94LCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KHRvcG9sb2d5LCBvKSB7XG4gIHZhciB0cmFuc2Zvcm1Qb2ludCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgYXJjcyA9IHRvcG9sb2d5LmFyY3M7XG5cbiAgZnVuY3Rpb24gYXJjKGksIHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoKSBwb2ludHMucG9wKCk7XG4gICAgZm9yICh2YXIgYSA9IGFyY3NbaSA8IDAgPyB+aSA6IGldLCBrID0gMCwgbiA9IGEubGVuZ3RoOyBrIDwgbjsgKytrKSB7XG4gICAgICBwb2ludHMucHVzaCh0cmFuc2Zvcm1Qb2ludChhW2tdLCBrKSk7XG4gICAgfVxuICAgIGlmIChpIDwgMCkgcmV2ZXJzZShwb2ludHMsIG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnQocCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qb2ludChwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHBvaW50cy5wdXNoKHBvaW50c1swXSk7IC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBwZXIgdGhlIHNwZWNpZmljYXRpb24uXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJpbmcoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBsaW5lKGFyY3MpO1xuICAgIHdoaWxlIChwb2ludHMubGVuZ3RoIDwgNCkgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBtYXkgaGFwcGVuIGlmIGFuIGFyYyBoYXMgb25seSB0d28gcG9pbnRzLlxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MpIHtcbiAgICByZXR1cm4gYXJjcy5tYXAocmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgdmFyIHR5cGUgPSBvLnR5cGUsIGNvb3JkaW5hdGVzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiByZXR1cm4ge3R5cGU6IHR5cGUsIGdlb21ldHJpZXM6IG8uZ2VvbWV0cmllcy5tYXAoZ2VvbWV0cnkpfTtcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBjb29yZGluYXRlcyA9IHBvaW50KG8uY29vcmRpbmF0ZXMpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IGNvb3JkaW5hdGVzID0gby5jb29yZGluYXRlcy5tYXAocG9pbnQpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGNvb3JkaW5hdGVzID0gbGluZShvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKGxpbmUpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGNvb3JkaW5hdGVzID0gcG9seWdvbihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKHBvbHlnb24pOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGU6IHR5cGUsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307XG4gIH1cblxuICByZXR1cm4gZ2VvbWV0cnkobyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGJib3h9IGZyb20gXCIuL2Jib3guanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmZWF0dXJlfSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWVzaCwgbWVzaEFyY3N9IGZyb20gXCIuL21lc2guanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXJnZSwgbWVyZ2VBcmNzfSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5laWdoYm9yc30gZnJvbSBcIi4vbmVpZ2hib3JzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpemV9IGZyb20gXCIuL3F1YW50aXplLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNmb3JtfSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB1bnRyYW5zZm9ybX0gZnJvbSBcIi4vdW50cmFuc2Zvcm0uanNcIjtcbiIsImltcG9ydCB7b2JqZWN0fSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5pbXBvcnQgc3RpdGNoIGZyb20gXCIuL3N0aXRjaC5qc1wiO1xuXG5mdW5jdGlvbiBwbGFuYXJSaW5nQXJlYShyaW5nKSB7XG4gIHZhciBpID0gLTEsIG4gPSByaW5nLmxlbmd0aCwgYSwgYiA9IHJpbmdbbiAtIDFdLCBhcmVhID0gMDtcbiAgd2hpbGUgKCsraSA8IG4pIGEgPSBiLCBiID0gcmluZ1tpXSwgYXJlYSArPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICByZXR1cm4gTWF0aC5hYnMoYXJlYSk7IC8vIE5vdGU6IGRvdWJsZWQgYXJlYSFcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgcmV0dXJuIG9iamVjdCh0b3BvbG9neSwgbWVyZ2VBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcmNzKHRvcG9sb2d5LCBvYmplY3RzKSB7XG4gIHZhciBwb2x5Z29uc0J5QXJjID0ge30sXG4gICAgICBwb2x5Z29ucyA9IFtdLFxuICAgICAgZ3JvdXBzID0gW107XG5cbiAgb2JqZWN0cy5mb3JFYWNoKGdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgc3dpdGNoIChvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3Qoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6IG8uYXJjcy5mb3JFYWNoKGV4dHJhY3QpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0KHBvbHlnb24pIHtcbiAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAocG9seWdvbnNCeUFyY1thcmMgPSBhcmMgPCAwID8gfmFyYyA6IGFyY10gfHwgKHBvbHlnb25zQnlBcmNbYXJjXSA9IFtdKSkucHVzaChwb2x5Z29uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhKHJpbmcpIHtcbiAgICByZXR1cm4gcGxhbmFyUmluZ0FyZWEob2JqZWN0KHRvcG9sb2d5LCB7dHlwZTogXCJQb2x5Z29uXCIsIGFyY3M6IFtyaW5nXX0pLmNvb3JkaW5hdGVzWzBdKTtcbiAgfVxuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGlmICghcG9seWdvbi5fKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBbXSxcbiAgICAgICAgICBuZWlnaGJvcnMgPSBbcG9seWdvbl07XG4gICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgd2hpbGUgKHBvbHlnb24gPSBuZWlnaGJvcnMucG9wKCkpIHtcbiAgICAgICAgZ3JvdXAucHVzaChwb2x5Z29uKTtcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICBwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICBkZWxldGUgcG9seWdvbi5fO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgYXJjczogZ3JvdXBzLm1hcChmdW5jdGlvbihwb2x5Z29ucykge1xuICAgICAgdmFyIGFyY3MgPSBbXSwgbjtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgZXh0ZXJpb3IgKHVuaXF1ZSkgYXJjcy5cbiAgICAgIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIGFyY3MucHVzaChhcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdGl0Y2ggdGhlIGFyY3MgaW50byBvbmUgb3IgbW9yZSByaW5ncy5cbiAgICAgIGFyY3MgPSBzdGl0Y2godG9wb2xvZ3ksIGFyY3MpO1xuXG4gICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIHJpbmcgaXMgcmV0dXJuZWQsXG4gICAgICAvLyBhdCBtb3N0IG9uZSBvZiB0aGVzZSByaW5ncyBjYW4gYmUgdGhlIGV4dGVyaW9yO1xuICAgICAgLy8gY2hvb3NlIHRoZSBvbmUgd2l0aCB0aGUgZ3JlYXRlc3QgYWJzb2x1dGUgYXJlYS5cbiAgICAgIGlmICgobiA9IGFyY3MubGVuZ3RoKSA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGsgPSBhcmVhKGFyY3NbMF0pLCBraSwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmICgoa2kgPSBhcmVhKGFyY3NbaV0pKSA+IGspIHtcbiAgICAgICAgICAgIHQgPSBhcmNzWzBdLCBhcmNzWzBdID0gYXJjc1tpXSwgYXJjc1tpXSA9IHQsIGsgPSBraTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGFyY3MpIHtcbiAgICAgIHJldHVybiBhcmNzLmxlbmd0aCA+IDA7XG4gICAgfSlcbiAgfTtcbn1cbiIsImltcG9ydCB7b2JqZWN0fSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5pbXBvcnQgc3RpdGNoIGZyb20gXCIuL3N0aXRjaC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXNoQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lc2hBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcikge1xuICB2YXIgYXJjcywgaSwgbjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBhcmNzID0gZXh0cmFjdEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKTtcbiAgZWxzZSBmb3IgKGkgPSAwLCBhcmNzID0gbmV3IEFycmF5KG4gPSB0b3BvbG9neS5hcmNzLmxlbmd0aCk7IGkgPCBuOyArK2kpIGFyY3NbaV0gPSBpO1xuICByZXR1cm4ge3R5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGFyY3M6IHN0aXRjaCh0b3BvbG9neSwgYXJjcyl9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpIHtcbiAgdmFyIGFyY3MgPSBbXSxcbiAgICAgIGdlb21zQnlBcmMgPSBbXSxcbiAgICAgIGdlb207XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDAoaSkge1xuICAgIHZhciBqID0gaSA8IDAgPyB+aSA6IGk7XG4gICAgKGdlb21zQnlBcmNbal0gfHwgKGdlb21zQnlBcmNbal0gPSBbXSkpLnB1c2goe2k6IGksIGc6IGdlb219KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QxKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDIoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MyhhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKGdlb20gPSBvLCBvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGV4dHJhY3QxKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjYXNlIFwiUG9seWdvblwiOiBleHRyYWN0MihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogZXh0cmFjdDMoby5hcmNzKTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZ2VvbWV0cnkob2JqZWN0KTtcblxuICBnZW9tc0J5QXJjLmZvckVhY2goZmlsdGVyID09IG51bGxcbiAgICAgID8gZnVuY3Rpb24oZ2VvbXMpIHsgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9XG4gICAgICA6IGZ1bmN0aW9uKGdlb21zKSB7IGlmIChmaWx0ZXIoZ2VvbXNbMF0uZywgZ2VvbXNbZ2VvbXMubGVuZ3RoIC0gMV0uZykpIGFyY3MucHVzaChnZW9tc1swXS5pKTsgfSk7XG5cbiAgcmV0dXJuIGFyY3M7XG59XG4iLCJpbXBvcnQgYmlzZWN0IGZyb20gXCIuL2Jpc2VjdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmplY3RzKSB7XG4gIHZhciBpbmRleGVzQnlBcmMgPSB7fSwgLy8gYXJjIGluZGV4IC0+IGFycmF5IG9mIG9iamVjdCBpbmRleGVzXG4gICAgICBuZWlnaGJvcnMgPSBvYmplY3RzLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICBmdW5jdGlvbiBsaW5lKGFyY3MsIGkpIHtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKGEgPCAwKSBhID0gfmE7XG4gICAgICB2YXIgbyA9IGluZGV4ZXNCeUFyY1thXTtcbiAgICAgIGlmIChvKSBvLnB1c2goaSk7XG4gICAgICBlbHNlIGluZGV4ZXNCeUFyY1thXSA9IFtpXTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgbGluZShhcmMsIGkpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8sIGkpIHtcbiAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChmdW5jdGlvbihvKSB7IGdlb21ldHJ5KG8sIGkpOyB9KTtcbiAgICBlbHNlIGlmIChvLnR5cGUgaW4gZ2VvbWV0cnlUeXBlKSBnZW9tZXRyeVR5cGVbby50eXBlXShvLmFyY3MsIGkpO1xuICB9XG5cbiAgdmFyIGdlb21ldHJ5VHlwZSA9IHtcbiAgICBMaW5lU3RyaW5nOiBsaW5lLFxuICAgIE11bHRpTGluZVN0cmluZzogcG9seWdvbixcbiAgICBQb2x5Z29uOiBwb2x5Z29uLFxuICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24oYXJjcywgaSkgeyBhcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7IHBvbHlnb24oYXJjLCBpKTsgfSk7IH1cbiAgfTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZvciAodmFyIGkgaW4gaW5kZXhlc0J5QXJjKSB7XG4gICAgZm9yICh2YXIgaW5kZXhlcyA9IGluZGV4ZXNCeUFyY1tpXSwgbSA9IGluZGV4ZXMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbTsgKytrKSB7XG4gICAgICAgIHZhciBpaiA9IGluZGV4ZXNbal0sIGlrID0gaW5kZXhlc1trXSwgbjtcbiAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lqXSlbaSA9IGJpc2VjdChuLCBpayldICE9PSBpaykgbi5zcGxpY2UoaSwgMCwgaWspO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWtdKVtpID0gYmlzZWN0KG4sIGlqKV0gIT09IGlqKSBuLnNwbGljZShpLCAwLCBpaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn1cbiIsImltcG9ydCBiYm94IGZyb20gXCIuL2Jib3guanNcIjtcbmltcG9ydCB1bnRyYW5zZm9ybSBmcm9tIFwiLi91bnRyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgdHJhbnNmb3JtKSB7XG4gIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgcXVhbnRpemVkXCIpO1xuXG4gIGlmICghdHJhbnNmb3JtIHx8ICF0cmFuc2Zvcm0uc2NhbGUpIHtcbiAgICBpZiAoISgobiA9IE1hdGguZmxvb3IodHJhbnNmb3JtKSkgPj0gMikpIHRocm93IG5ldyBFcnJvcihcIm4gbXVzdCBiZSDiiaUyXCIpO1xuICAgIGJveCA9IHRvcG9sb2d5LmJib3ggfHwgYmJveCh0b3BvbG9neSk7XG4gICAgdmFyIHgwID0gYm94WzBdLCB5MCA9IGJveFsxXSwgeDEgPSBib3hbMl0sIHkxID0gYm94WzNdLCBuO1xuICAgIHRyYW5zZm9ybSA9IHtzY2FsZTogW3gxIC0geDAgPyAoeDEgLSB4MCkgLyAobiAtIDEpIDogMSwgeTEgLSB5MCA/ICh5MSAtIHkwKSAvIChuIC0gMSkgOiAxXSwgdHJhbnNsYXRlOiBbeDAsIHkwXX07XG4gIH0gZWxzZSB7XG4gICAgYm94ID0gdG9wb2xvZ3kuYmJveDtcbiAgfVxuXG4gIHZhciB0ID0gdW50cmFuc2Zvcm0odHJhbnNmb3JtKSwgYm94LCBrZXksIGlucHV0cyA9IHRvcG9sb2d5Lm9iamVjdHMsIG91dHB1dHMgPSB7fTtcblxuICBmdW5jdGlvbiBxdWFudGl6ZVBvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHQocG9pbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhbnRpemVHZW9tZXRyeShpbnB1dCkge1xuICAgIHZhciBvdXRwdXQ7XG4gICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG91dHB1dCA9IHt0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLCBnZW9tZXRyaWVzOiBpbnB1dC5nZW9tZXRyaWVzLm1hcChxdWFudGl6ZUdlb21ldHJ5KX07IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IG91dHB1dCA9IHt0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBxdWFudGl6ZVBvaW50KGlucHV0LmNvb3JkaW5hdGVzKX07IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogb3V0cHV0ID0ge3R5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogaW5wdXQuY29vcmRpbmF0ZXMubWFwKHF1YW50aXplUG9pbnQpfTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChpbnB1dC5pZCAhPSBudWxsKSBvdXRwdXQuaWQgPSBpbnB1dC5pZDtcbiAgICBpZiAoaW5wdXQuYmJveCAhPSBudWxsKSBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgaWYgKGlucHV0LnByb3BlcnRpZXMgIT0gbnVsbCkgb3V0cHV0LnByb3BlcnRpZXMgPSBpbnB1dC5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUFyYyhpbnB1dCkge1xuICAgIHZhciBpID0gMCwgaiA9IDEsIG4gPSBpbnB1dC5sZW5ndGgsIHAsIG91dHB1dCA9IG5ldyBBcnJheShuKTsgLy8gcGVzc2ltaXN0aWNcbiAgICBvdXRwdXRbMF0gPSB0KGlucHV0WzBdLCAwKTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKChwID0gdChpbnB1dFtpXSwgaSkpWzBdIHx8IHBbMV0pIG91dHB1dFtqKytdID0gcDsgLy8gbm9uLWNvaW5jaWRlbnQgcG9pbnRzXG4gICAgaWYgKGogPT09IDEpIG91dHB1dFtqKytdID0gWzAsIDBdOyAvLyBhbiBhcmMgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICBvdXRwdXQubGVuZ3RoID0gajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgZm9yIChrZXkgaW4gaW5wdXRzKSBvdXRwdXRzW2tleV0gPSBxdWFudGl6ZUdlb21ldHJ5KGlucHV0c1trZXldKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVG9wb2xvZ3lcIixcbiAgICBiYm94OiBib3gsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgb2JqZWN0czogb3V0cHV0cyxcbiAgICBhcmNzOiB0b3BvbG9neS5hcmNzLm1hcChxdWFudGl6ZUFyYylcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBuKSB7XG4gIHZhciB0LCBqID0gYXJyYXkubGVuZ3RoLCBpID0gaiAtIG47XG4gIHdoaWxlIChpIDwgLS1qKSB0ID0gYXJyYXlbaV0sIGFycmF5W2krK10gPSBhcnJheVtqXSwgYXJyYXlbal0gPSB0O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3ksIGFyY3MpIHtcbiAgdmFyIHN0aXRjaGVkQXJjcyA9IHt9LFxuICAgICAgZnJhZ21lbnRCeVN0YXJ0ID0ge30sXG4gICAgICBmcmFnbWVudEJ5RW5kID0ge30sXG4gICAgICBmcmFnbWVudHMgPSBbXSxcbiAgICAgIGVtcHR5SW5kZXggPSAtMTtcblxuICAvLyBTdGl0Y2ggZW1wdHkgYXJjcyBmaXJzdCwgc2luY2UgdGhleSBtYXkgYmUgc3Vic3VtZWQgYnkgb3RoZXIgYXJjcy5cbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGksIGopIHtcbiAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHQ7XG4gICAgaWYgKGFyYy5sZW5ndGggPCAzICYmICFhcmNbMV1bMF0gJiYgIWFyY1sxXVsxXSkge1xuICAgICAgdCA9IGFyY3NbKytlbXB0eUluZGV4XSwgYXJjc1tlbXB0eUluZGV4XSA9IGksIGFyY3Nbal0gPSB0O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgZSA9IGVuZHMoaSksXG4gICAgICAgIHN0YXJ0ID0gZVswXSxcbiAgICAgICAgZW5kID0gZVsxXSxcbiAgICAgICAgZiwgZztcblxuICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgIGYucHVzaChpKTtcbiAgICAgIGYuZW5kID0gZW5kO1xuICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2cuc3RhcnRdO1xuICAgICAgICB2YXIgZmcgPSBnID09PSBmID8gZiA6IGYuY29uY2F0KGcpO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZmcuc3RhcnQgPSBmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZmcuZW5kID0gZy5lbmRdID0gZmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF0pIHtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICBmLnVuc2hpZnQoaSk7XG4gICAgICBmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2cuZW5kXTtcbiAgICAgICAgdmFyIGdmID0gZyA9PT0gZiA/IGYgOiBnLmNvbmNhdChmKTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2dmLnN0YXJ0ID0gZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2dmLmVuZCA9IGYuZW5kXSA9IGdmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSBmO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmID0gW2ldO1xuICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kXSA9IGY7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBlbmRzKGkpIHtcbiAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHAwID0gYXJjWzBdLCBwMTtcbiAgICBpZiAodG9wb2xvZ3kudHJhbnNmb3JtKSBwMSA9IFswLCAwXSwgYXJjLmZvckVhY2goZnVuY3Rpb24oZHApIHsgcDFbMF0gKz0gZHBbMF0sIHAxWzFdICs9IGRwWzFdOyB9KTtcbiAgICBlbHNlIHAxID0gYXJjW2FyYy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gaSA8IDAgPyBbcDEsIHAwXSA6IFtwMCwgcDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KSB7XG4gICAgZm9yICh2YXIgayBpbiBmcmFnbWVudEJ5RW5kKSB7XG4gICAgICB2YXIgZiA9IGZyYWdtZW50QnlFbmRba107XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgZGVsZXRlIGYuc3RhcnQ7XG4gICAgICBkZWxldGUgZi5lbmQ7XG4gICAgICBmLmZvckVhY2goZnVuY3Rpb24oaSkgeyBzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldID0gMTsgfSk7XG4gICAgICBmcmFnbWVudHMucHVzaChmKTtcbiAgICB9XG4gIH1cblxuICBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpO1xuICBmbHVzaChmcmFnbWVudEJ5U3RhcnQsIGZyYWdtZW50QnlFbmQpO1xuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkgeyBpZiAoIXN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0pIGZyYWdtZW50cy5wdXNoKFtpXSk7IH0pO1xuXG4gIHJldHVybiBmcmFnbWVudHM7XG59XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICB2YXIgeDAsXG4gICAgICB5MCxcbiAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaSkge1xuICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgdmFyIGogPSAyLCBuID0gaW5wdXQubGVuZ3RoLCBvdXRwdXQgPSBuZXcgQXJyYXkobik7XG4gICAgb3V0cHV0WzBdID0gKHgwICs9IGlucHV0WzBdKSAqIGt4ICsgZHg7XG4gICAgb3V0cHV0WzFdID0gKHkwICs9IGlucHV0WzFdKSAqIGt5ICsgZHk7XG4gICAgd2hpbGUgKGogPCBuKSBvdXRwdXRbal0gPSBpbnB1dFtqXSwgKytqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICB2YXIgeDAsXG4gICAgICB5MCxcbiAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaSkge1xuICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgdmFyIGogPSAyLFxuICAgICAgICBuID0gaW5wdXQubGVuZ3RoLFxuICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHgxID0gTWF0aC5yb3VuZCgoaW5wdXRbMF0gLSBkeCkgLyBreCksXG4gICAgICAgIHkxID0gTWF0aC5yb3VuZCgoaW5wdXRbMV0gLSBkeSkgLyBreSk7XG4gICAgb3V0cHV0WzBdID0geDEgLSB4MCwgeDAgPSB4MTtcbiAgICBvdXRwdXRbMV0gPSB5MSAtIHkwLCB5MCA9IHkxO1xuICAgIHdoaWxlIChqIDwgbikgb3V0cHV0W2pdID0gaW5wdXRbal0sICsrajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuIiwiZXhwb3J0IHtcbiAgZG9tQ2FudmFzIGFzIGRvbUNhbnZhcyxcbiAgZG9tQ2FudmFzIGFzIGNhbnZhcyxcbiAgZG9tSW1hZ2UgYXMgaW1hZ2Vcbn0gZnJvbSAnLi9zcmMvZG9tQ2FudmFzJztcbiIsImV4cG9ydCBmdW5jdGlvbiBkb21DYW52YXModywgaCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB7XG4gICAgY29uc3QgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGlmIChjICYmIGMuZ2V0Q29udGV4dCkge1xuICAgICAgYy53aWR0aCA9IHc7XG4gICAgICBjLmhlaWdodCA9IGg7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBjb25zdCBkb21JbWFnZSA9ICgpID0+XG4gIHR5cGVvZiBJbWFnZSAhPT0gJ3VuZGVmaW5lZCcgPyBJbWFnZSA6IG51bGw7XG4iLCJpbXBvcnQgeyBwZXJtdXRlLCBiaXNlY3RMZWZ0LCBiaXNlY3RSaWdodCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5jb25zdCBhcnJheTggPSBuID0+IG5ldyBVaW50OEFycmF5KG4pO1xuY29uc3QgYXJyYXkxNiA9IG4gPT4gbmV3IFVpbnQxNkFycmF5KG4pO1xuY29uc3QgYXJyYXkzMiA9IG4gPT4gbmV3IFVpbnQzMkFycmF5KG4pO1xuXG4vKipcbiAqIE1haW50YWlucyBDcm9zc0ZpbHRlciBzdGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiBCaXRtYXBzKCkge1xuICBsZXQgd2lkdGggPSA4LFxuICAgICAgZGF0YSA9IFtdLFxuICAgICAgc2VlbiA9IGFycmF5MzIoMCksXG4gICAgICBjdXJyID0gYXJyYXkoMCwgd2lkdGgpLFxuICAgICAgcHJldiA9IGFycmF5KDAsIHdpZHRoKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiAoKSA9PiBkYXRhLFxuICAgIHNlZW46ICgpID0+IHNlZW4gPSBsZW5ndGhlbihzZWVuLCBkYXRhLmxlbmd0aCksXG5cbiAgICBhZGQoYXJyYXkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gZGF0YS5sZW5ndGgsIG4gPSBhcnJheS5sZW5ndGgsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdCA9IGFycmF5W2ldO1xuICAgICAgICB0Ll9pbmRleCA9IGorKztcbiAgICAgICAgZGF0YS5wdXNoKHQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmUobnVtLCBtYXApIHtcbiAgICAgIC8vIG1hcDogaW5kZXggLT4gYm9vbGVhbiAodHJ1ZSA9PiByZW1vdmUpXG4gICAgICBjb25zdCBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBjb3B5ID0gQXJyYXkobiAtIG51bSksXG4gICAgICAgICAgICByZWluZGV4ID0gZGF0YTsgLy8gcmV1c2Ugb2xkIGRhdGEgYXJyYXkgZm9yIGluZGV4IG1hcFxuXG4gICAgICBsZXQgdCwgaSwgajsgLy8gc2VlayBmb3J3YXJkIHRvIGZpcnN0IHJlbW92YWxcblxuICAgICAgZm9yIChpID0gMDsgIW1hcFtpXSAmJiBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvcHlbaV0gPSBkYXRhW2ldO1xuICAgICAgICByZWluZGV4W2ldID0gaTtcbiAgICAgIH0gLy8gY29uZGVuc2UgYXJyYXlzXG5cblxuICAgICAgZm9yIChqID0gaTsgaSA8IG47ICsraSkge1xuICAgICAgICB0ID0gZGF0YVtpXTtcblxuICAgICAgICBpZiAoIW1hcFtpXSkge1xuICAgICAgICAgIHJlaW5kZXhbaV0gPSBqO1xuICAgICAgICAgIGN1cnJbal0gPSBjdXJyW2ldO1xuICAgICAgICAgIHByZXZbal0gPSBwcmV2W2ldO1xuICAgICAgICAgIGNvcHlbal0gPSB0O1xuICAgICAgICAgIHQuX2luZGV4ID0gaisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlaW5kZXhbaV0gPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJbaV0gPSAwOyAvLyBjbGVhciB1bnVzZWQgYml0c1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gY29weTtcbiAgICAgIHJldHVybiByZWluZGV4O1xuICAgIH0sXG5cbiAgICBzaXplOiAoKSA9PiBkYXRhLmxlbmd0aCxcbiAgICBjdXJyOiAoKSA9PiBjdXJyLFxuICAgIHByZXY6ICgpID0+IHByZXYsXG4gICAgcmVzZXQ6IGsgPT4gcHJldltrXSA9IGN1cnJba10sXG4gICAgYWxsOiAoKSA9PiB3aWR0aCA8IDB4MTAxID8gMHhmZiA6IHdpZHRoIDwgMHgxMDAwMSA/IDB4ZmZmZiA6IDB4ZmZmZmZmZmYsXG5cbiAgICBzZXQoaywgb25lKSB7XG4gICAgICBjdXJyW2tdIHw9IG9uZTtcbiAgICB9LFxuXG4gICAgY2xlYXIoaywgb25lKSB7XG4gICAgICBjdXJyW2tdICY9IH5vbmU7XG4gICAgfSxcblxuICAgIHJlc2l6ZShuLCBtKSB7XG4gICAgICBjb25zdCBrID0gY3Vyci5sZW5ndGg7XG5cbiAgICAgIGlmIChuID4gayB8fCBtID4gd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heChtLCB3aWR0aCk7XG4gICAgICAgIGN1cnIgPSBhcnJheShuLCB3aWR0aCwgY3Vycik7XG4gICAgICAgIHByZXYgPSBhcnJheShuLCB3aWR0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG59XG5cbmZ1bmN0aW9uIGxlbmd0aGVuKGFycmF5LCBsZW5ndGgsIGNvcHkpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA+PSBsZW5ndGgpIHJldHVybiBhcnJheTtcbiAgY29weSA9IGNvcHkgfHwgbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG4gIGNvcHkuc2V0KGFycmF5KTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIGFycmF5KG4sIG0sIGFycmF5KSB7XG4gIGNvbnN0IGNvcHkgPSAobSA8IDB4MTAxID8gYXJyYXk4IDogbSA8IDB4MTAwMDEgPyBhcnJheTE2IDogYXJyYXkzMikobik7XG4gIGlmIChhcnJheSkgY29weS5zZXQoYXJyYXkpO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gRGltZW5zaW9uIChpbmRleCwgaSwgcXVlcnkpIHtcbiAgY29uc3QgYml0ID0gMSA8PCBpO1xuICByZXR1cm4ge1xuICAgIG9uZTogYml0LFxuICAgIHplcm86IH5iaXQsXG4gICAgcmFuZ2U6IHF1ZXJ5LnNsaWNlKCksXG4gICAgYmlzZWN0OiBpbmRleC5iaXNlY3QsXG4gICAgaW5kZXg6IGluZGV4LmluZGV4LFxuICAgIHNpemU6IGluZGV4LnNpemUsXG5cbiAgICBvbkFkZChhZGRlZCwgY3Vycikge1xuICAgICAgY29uc3QgZGltID0gdGhpcyxcbiAgICAgICAgICAgIHJhbmdlID0gZGltLmJpc2VjdChkaW0ucmFuZ2UsIGFkZGVkLnZhbHVlKSxcbiAgICAgICAgICAgIGlkeCA9IGFkZGVkLmluZGV4LFxuICAgICAgICAgICAgbG8gPSByYW5nZVswXSxcbiAgICAgICAgICAgIGhpID0gcmFuZ2VbMV0sXG4gICAgICAgICAgICBuMSA9IGlkeC5sZW5ndGg7XG4gICAgICBsZXQgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxvOyArK2kpIGN1cnJbaWR4W2ldXSB8PSBiaXQ7XG5cbiAgICAgIGZvciAoaSA9IGhpOyBpIDwgbjE7ICsraSkgY3VycltpZHhbaV1dIHw9IGJpdDtcblxuICAgICAgcmV0dXJuIGRpbTtcbiAgICB9XG5cbiAgfTtcbn1cblxuLyoqXG4gKiBNYWludGFpbnMgYSBsaXN0IG9mIHZhbHVlcywgc29ydGVkIGJ5IGtleS5cbiAqL1xuXG5mdW5jdGlvbiBTb3J0ZWRJbmRleCgpIHtcbiAgbGV0IGluZGV4ID0gYXJyYXkzMigwKSxcbiAgICAgIHZhbHVlID0gW10sXG4gICAgICBzaXplID0gMDtcblxuICBmdW5jdGlvbiBpbnNlcnQoa2V5LCBkYXRhLCBiYXNlKSB7XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IG4wID0gc2l6ZSxcbiAgICAgICAgICBuMSA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGFkZGkgPSBhcnJheTMyKG4xKTtcbiAgICBsZXQgYWRkdiA9IEFycmF5KG4xKSxcbiAgICAgICAgb2xkdixcbiAgICAgICAgb2xkaSxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuMTsgKytpKSB7XG4gICAgICBhZGR2W2ldID0ga2V5KGRhdGFbaV0pO1xuICAgICAgYWRkaVtpXSA9IGk7XG4gICAgfVxuXG4gICAgYWRkdiA9IHNvcnQoYWRkdiwgYWRkaSk7XG5cbiAgICBpZiAobjApIHtcbiAgICAgIG9sZHYgPSB2YWx1ZTtcbiAgICAgIG9sZGkgPSBpbmRleDtcbiAgICAgIHZhbHVlID0gQXJyYXkobjAgKyBuMSk7XG4gICAgICBpbmRleCA9IGFycmF5MzIobjAgKyBuMSk7XG4gICAgICBtZXJnZShiYXNlLCBvbGR2LCBvbGRpLCBuMCwgYWRkdiwgYWRkaSwgbjEsIHZhbHVlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChiYXNlID4gMCkgZm9yIChpID0gMDsgaSA8IG4xOyArK2kpIHtcbiAgICAgICAgYWRkaVtpXSArPSBiYXNlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBhZGR2O1xuICAgICAgaW5kZXggPSBhZGRpO1xuICAgIH1cblxuICAgIHNpemUgPSBuMCArIG4xO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleDogYWRkaSxcbiAgICAgIHZhbHVlOiBhZGR2XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZShudW0sIG1hcCkge1xuICAgIC8vIG1hcDogaW5kZXggLT4gcmVtb3ZlXG4gICAgY29uc3QgbiA9IHNpemU7XG4gICAgbGV0IGlkeCwgaSwgajsgLy8gc2VlayBmb3J3YXJkIHRvIGZpcnN0IHJlbW92YWxcblxuICAgIGZvciAoaSA9IDA7ICFtYXBbaW5kZXhbaV1dICYmIGkgPCBuOyArK2kpOyAvLyBjb25kZW5zZSBpbmRleCBhbmQgdmFsdWUgYXJyYXlzXG5cblxuICAgIGZvciAoaiA9IGk7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICghbWFwW2lkeCA9IGluZGV4W2ldXSkge1xuICAgICAgICBpbmRleFtqXSA9IGlkeDtcbiAgICAgICAgdmFsdWVbal0gPSB2YWx1ZVtpXTtcbiAgICAgICAgKytqO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNpemUgPSBuIC0gbnVtO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVpbmRleChtYXApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHNpemU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGluZGV4W2ldID0gbWFwW2luZGV4W2ldXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiaXNlY3QocmFuZ2UsIGFycmF5KSB7XG4gICAgbGV0IG47XG5cbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5ID0gdmFsdWU7XG4gICAgICBuID0gc2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2Jpc2VjdExlZnQoYXJyYXksIHJhbmdlWzBdLCAwLCBuKSwgYmlzZWN0UmlnaHQoYXJyYXksIHJhbmdlWzFdLCAwLCBuKV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGluc2VydDogaW5zZXJ0LFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIGJpc2VjdDogYmlzZWN0LFxuICAgIHJlaW5kZXg6IHJlaW5kZXgsXG4gICAgaW5kZXg6ICgpID0+IGluZGV4LFxuICAgIHNpemU6ICgpID0+IHNpemVcbiAgfTtcbn1cblxuZnVuY3Rpb24gc29ydCh2YWx1ZXMsIGluZGV4KSB7XG4gIHZhbHVlcy5zb3J0LmNhbGwoaW5kZXgsIChhLCBiKSA9PiB7XG4gICAgY29uc3QgeCA9IHZhbHVlc1thXSxcbiAgICAgICAgICB5ID0gdmFsdWVzW2JdO1xuICAgIHJldHVybiB4IDwgeSA/IC0xIDogeCA+IHkgPyAxIDogMDtcbiAgfSk7XG4gIHJldHVybiBwZXJtdXRlKHZhbHVlcywgaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBtZXJnZShiYXNlLCB2YWx1ZTAsIGluZGV4MCwgbjAsIHZhbHVlMSwgaW5kZXgxLCBuMSwgdmFsdWUsIGluZGV4KSB7XG4gIGxldCBpMCA9IDAsXG4gICAgICBpMSA9IDAsXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkwIDwgbjAgJiYgaTEgPCBuMTsgKytpKSB7XG4gICAgaWYgKHZhbHVlMFtpMF0gPCB2YWx1ZTFbaTFdKSB7XG4gICAgICB2YWx1ZVtpXSA9IHZhbHVlMFtpMF07XG4gICAgICBpbmRleFtpXSA9IGluZGV4MFtpMCsrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVbaV0gPSB2YWx1ZTFbaTFdO1xuICAgICAgaW5kZXhbaV0gPSBpbmRleDFbaTErK10gKyBiYXNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBpMCA8IG4wOyArK2kwLCArK2kpIHtcbiAgICB2YWx1ZVtpXSA9IHZhbHVlMFtpMF07XG4gICAgaW5kZXhbaV0gPSBpbmRleDBbaTBdO1xuICB9XG5cbiAgZm9yICg7IGkxIDwgbjE7ICsraTEsICsraSkge1xuICAgIHZhbHVlW2ldID0gdmFsdWUxW2kxXTtcbiAgICBpbmRleFtpXSA9IGluZGV4MVtpMV0gKyBiYXNlO1xuICB9XG59XG5cbi8qKlxuICogQW4gaW5kZXhlZCBtdWx0aS1kaW1lbnNpb25hbCBmaWx0ZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IHBhcmFtcy5maWVsZHMgLSBBbiBhcnJheSBvZiBkaW1lbnNpb24gYWNjZXNzb3JzIHRvIGZpbHRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcy5xdWVyeSAtIEFuIGFycmF5IG9mIHBlci1kaW1lbnNpb24gcmFuZ2UgcXVlcmllcy5cbiAqL1xuXG5mdW5jdGlvbiBDcm9zc0ZpbHRlcihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgQml0bWFwcygpLCBwYXJhbXMpO1xuICB0aGlzLl9pbmRpY2VzID0gbnVsbDtcbiAgdGhpcy5fZGltcyA9IG51bGw7XG59XG5Dcm9zc0ZpbHRlci5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdDcm9zc0ZpbHRlcicsXG4gICdtZXRhZGF0YSc6IHt9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3F1ZXJ5JyxcbiAgICAndHlwZSc6ICdhcnJheScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAncmVxdWlyZWQnOiB0cnVlLFxuICAgICdjb250ZW50Jzoge1xuICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICdhcnJheSc6IHRydWUsXG4gICAgICAnbGVuZ3RoJzogMlxuICAgIH1cbiAgfV1cbn07XG5pbmhlcml0cyhDcm9zc0ZpbHRlciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICghdGhpcy5fZGltcykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdChfLCBwdWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbml0ID0gXy5tb2RpZmllZCgnZmllbGRzJykgfHwgXy5maWVsZHMuc29tZShmID0+IHB1bHNlLm1vZGlmaWVkKGYuZmllbGRzKSk7XG5cbiAgICAgIHJldHVybiBpbml0ID8gdGhpcy5yZWluaXQoXywgcHVsc2UpIDogdGhpcy5ldmFsKF8sIHB1bHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdChfLCBwdWxzZSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgICAgIHF1ZXJ5ID0gXy5xdWVyeSxcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyA9IHt9LFxuICAgICAgICAgIGRpbXMgPSB0aGlzLl9kaW1zID0gW10sXG4gICAgICAgICAgbSA9IHF1ZXJ5Lmxlbmd0aDtcbiAgICBsZXQgaSA9IDAsXG4gICAgICAgIGtleSxcbiAgICAgICAgaW5kZXg7IC8vIGluc3RhbnRpYXRlIGluZGljZXMgYW5kIGRpbWVuc2lvbnNcblxuICAgIGZvciAoOyBpIDwgbTsgKytpKSB7XG4gICAgICBrZXkgPSBmaWVsZHNbaV0uZm5hbWU7XG4gICAgICBpbmRleCA9IGluZGljZXNba2V5XSB8fCAoaW5kaWNlc1trZXldID0gU29ydGVkSW5kZXgoKSk7XG4gICAgICBkaW1zLnB1c2goRGltZW5zaW9uKGluZGV4LCBpLCBxdWVyeVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV2YWwoXywgcHVsc2UpO1xuICB9LFxuXG4gIHJlaW5pdChfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dHB1dCA9IHB1bHNlLm1hdGVyaWFsaXplKCkuZm9yaygpLFxuICAgICAgICAgIGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgICAgIHF1ZXJ5ID0gXy5xdWVyeSxcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgICAgICBiaXRzID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBjdXJyID0gYml0cy5jdXJyKCksXG4gICAgICAgICAgcHJldiA9IGJpdHMucHJldigpLFxuICAgICAgICAgIGFsbCA9IGJpdHMuYWxsKCksXG4gICAgICAgICAgb3V0ID0gb3V0cHV0LnJlbSA9IG91dHB1dC5hZGQsXG4gICAgICAgICAgbW9kID0gb3V0cHV0Lm1vZCxcbiAgICAgICAgICBtID0gcXVlcnkubGVuZ3RoLFxuICAgICAgICAgIGFkZHMgPSB7fTtcbiAgICBsZXQgYWRkLCBpbmRleCwga2V5LCBtb2RzLCByZW1NYXAsIG1vZE1hcCwgaSwgbiwgZjsgLy8gc2V0IHByZXYgdG8gY3VycmVudCBzdGF0ZVxuXG4gICAgcHJldi5zZXQoY3Vycik7IC8vIGlmIHB1bHNlIGhhcyByZW1vdmUgdHVwbGVzLCBwcm9jZXNzIHRoZW0gZmlyc3RcblxuICAgIGlmIChwdWxzZS5yZW0ubGVuZ3RoKSB7XG4gICAgICByZW1NYXAgPSB0aGlzLnJlbW92ZShfLCBwdWxzZSwgb3V0cHV0KTtcbiAgICB9IC8vIGlmIHB1bHNlIGhhcyBhZGRlZCB0dXBsZXMsIGFkZCB0aGVtIHRvIHN0YXRlXG5cblxuICAgIGlmIChwdWxzZS5hZGQubGVuZ3RoKSB7XG4gICAgICBiaXRzLmFkZChwdWxzZS5hZGQpO1xuICAgIH0gLy8gaWYgcHVsc2UgaGFzIG1vZGlmaWVkIHR1cGxlcywgY3JlYXRlIGFuIGluZGV4IG1hcFxuXG5cbiAgICBpZiAocHVsc2UubW9kLmxlbmd0aCkge1xuICAgICAgbW9kTWFwID0ge307XG5cbiAgICAgIGZvciAobW9kcyA9IHB1bHNlLm1vZCwgaSA9IDAsIG4gPSBtb2RzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBtb2RNYXBbbW9kc1tpXS5faW5kZXhdID0gMTtcbiAgICAgIH1cbiAgICB9IC8vIHJlLWluaXRpYWxpemUgaW5kaWNlcyBhcyBuZWVkZWQsIHVwZGF0ZSBjdXJyIGJpdG1hcFxuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICBmID0gZmllbGRzW2ldO1xuXG4gICAgICBpZiAoIWRpbXNbaV0gfHwgXy5tb2RpZmllZCgnZmllbGRzJywgaSkgfHwgcHVsc2UubW9kaWZpZWQoZi5maWVsZHMpKSB7XG4gICAgICAgIGtleSA9IGYuZm5hbWU7XG5cbiAgICAgICAgaWYgKCEoYWRkID0gYWRkc1trZXldKSkge1xuICAgICAgICAgIGluZGljZXNba2V5XSA9IGluZGV4ID0gU29ydGVkSW5kZXgoKTtcbiAgICAgICAgICBhZGRzW2tleV0gPSBhZGQgPSBpbmRleC5pbnNlcnQoZiwgcHVsc2Uuc291cmNlLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbXNbaV0gPSBEaW1lbnNpb24oaW5kZXgsIGksIHF1ZXJ5W2ldKS5vbkFkZChhZGQsIGN1cnIpO1xuICAgICAgfVxuICAgIH0gLy8gdmlzaXQgZWFjaCB0dXBsZVxuICAgIC8vIGlmIGZpbHRlciBzdGF0ZSBjaGFuZ2VkLCBwdXNoIGluZGV4IHRvIGFkZC9yZW1cbiAgICAvLyBlbHNlIGlmIGluIG1vZCBhbmQgcGFzc2VzIGEgZmlsdGVyLCBwdXNoIGluZGV4IHRvIG1vZFxuXG5cbiAgICBmb3IgKGkgPSAwLCBuID0gYml0cy5kYXRhKCkubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAocmVtTWFwW2ldKSB7XG4gICAgICAgIC8vIHNraXAgaWYgcmVtb3ZlZCB0dXBsZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAocHJldltpXSAhPT0gY3VycltpXSkge1xuICAgICAgICAvLyBhZGQgaWYgc3RhdGUgY2hhbmdlZFxuICAgICAgICBvdXQucHVzaChpKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kTWFwW2ldICYmIGN1cnJbaV0gIT09IGFsbCkge1xuICAgICAgICAvLyBvdGhlcndpc2UsIHBhc3MgbW9kcyB0aHJvdWdoXG4gICAgICAgIG1vZC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJpdHMubWFzayA9ICgxIDw8IG0pIC0gMTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIGV2YWwoXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBwdWxzZS5tYXRlcmlhbGl6ZSgpLmZvcmsoKSxcbiAgICAgICAgICBtID0gdGhpcy5fZGltcy5sZW5ndGg7XG4gICAgbGV0IG1hc2sgPSAwO1xuXG4gICAgaWYgKHB1bHNlLnJlbS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtb3ZlKF8sIHB1bHNlLCBvdXRwdXQpO1xuICAgICAgbWFzayB8PSAoMSA8PCBtKSAtIDE7XG4gICAgfVxuXG4gICAgaWYgKF8ubW9kaWZpZWQoJ3F1ZXJ5JykgJiYgIV8ubW9kaWZpZWQoJ2ZpZWxkcycpKSB7XG4gICAgICBtYXNrIHw9IHRoaXMudXBkYXRlKF8sIHB1bHNlLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIGlmIChwdWxzZS5hZGQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluc2VydChfLCBwdWxzZSwgb3V0cHV0KTtcbiAgICAgIG1hc2sgfD0gKDEgPDwgbSkgLSAxO1xuICAgIH1cblxuICAgIGlmIChwdWxzZS5tb2QubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1vZGlmeShwdWxzZSwgb3V0cHV0KTtcbiAgICAgIG1hc2sgfD0gKDEgPDwgbSkgLSAxO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUubWFzayA9IG1hc2s7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcblxuICBpbnNlcnQoXywgcHVsc2UsIG91dHB1dCkge1xuICAgIGNvbnN0IHR1cGxlcyA9IHB1bHNlLmFkZCxcbiAgICAgICAgICBiaXRzID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyxcbiAgICAgICAgICBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgICAgICBhZGRzID0ge30sXG4gICAgICAgICAgb3V0ID0gb3V0cHV0LmFkZCxcbiAgICAgICAgICBuID0gYml0cy5zaXplKCkgKyB0dXBsZXMubGVuZ3RoLFxuICAgICAgICAgIG0gPSBkaW1zLmxlbmd0aDtcbiAgICBsZXQgayA9IGJpdHMuc2l6ZSgpLFxuICAgICAgICBqLFxuICAgICAgICBrZXksXG4gICAgICAgIGFkZDsgLy8gcmVzaXplIGJpdG1hcHMgYW5kIGFkZCB0dXBsZXMgYXMgbmVlZGVkXG5cbiAgICBiaXRzLnJlc2l6ZShuLCBtKTtcbiAgICBiaXRzLmFkZCh0dXBsZXMpO1xuICAgIGNvbnN0IGN1cnIgPSBiaXRzLmN1cnIoKSxcbiAgICAgICAgICBwcmV2ID0gYml0cy5wcmV2KCksXG4gICAgICAgICAgYWxsID0gYml0cy5hbGwoKTsgLy8gYWRkIHRvIGRpbWVuc2lvbmFsIGluZGljZXNcblxuICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGtleSA9IGZpZWxkc1tqXS5mbmFtZTtcbiAgICAgIGFkZCA9IGFkZHNba2V5XSB8fCAoYWRkc1trZXldID0gaW5kaWNlc1trZXldLmluc2VydChmaWVsZHNbal0sIHR1cGxlcywgaykpO1xuICAgICAgZGltc1tqXS5vbkFkZChhZGQsIGN1cnIpO1xuICAgIH0gLy8gc2V0IHByZXZpb3VzIGZpbHRlcnMsIG91dHB1dCBpZiBwYXNzZXMgYXQgbGVhc3Qgb25lIGZpbHRlclxuXG5cbiAgICBmb3IgKDsgayA8IG47ICsraykge1xuICAgICAgcHJldltrXSA9IGFsbDtcbiAgICAgIGlmIChjdXJyW2tdICE9PSBhbGwpIG91dC5wdXNoKGspO1xuICAgIH1cbiAgfSxcblxuICBtb2RpZnkocHVsc2UsIG91dHB1dCkge1xuICAgIGNvbnN0IG91dCA9IG91dHB1dC5tb2QsXG4gICAgICAgICAgYml0cyA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgY3VyciA9IGJpdHMuY3VycigpLFxuICAgICAgICAgIGFsbCA9IGJpdHMuYWxsKCksXG4gICAgICAgICAgdHVwbGVzID0gcHVsc2UubW9kO1xuICAgIGxldCBpLCBuLCBrO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IHR1cGxlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGsgPSB0dXBsZXNbaV0uX2luZGV4O1xuICAgICAgaWYgKGN1cnJba10gIT09IGFsbCkgb3V0LnB1c2goayk7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZShfLCBwdWxzZSwgb3V0cHV0KSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuX2luZGljZXMsXG4gICAgICAgICAgYml0cyA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgY3VyciA9IGJpdHMuY3VycigpLFxuICAgICAgICAgIHByZXYgPSBiaXRzLnByZXYoKSxcbiAgICAgICAgICBhbGwgPSBiaXRzLmFsbCgpLFxuICAgICAgICAgIG1hcCA9IHt9LFxuICAgICAgICAgIG91dCA9IG91dHB1dC5yZW0sXG4gICAgICAgICAgdHVwbGVzID0gcHVsc2UucmVtO1xuICAgIGxldCBpLCBuLCBrLCBmOyAvLyBwcm9jZXNzIHR1cGxlcywgb3V0cHV0IGlmIHBhc3NlcyBhdCBsZWFzdCBvbmUgZmlsdGVyXG5cbiAgICBmb3IgKGkgPSAwLCBuID0gdHVwbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgayA9IHR1cGxlc1tpXS5faW5kZXg7XG4gICAgICBtYXBba10gPSAxOyAvLyBidWlsZCBpbmRleCBtYXBcblxuICAgICAgcHJldltrXSA9IGYgPSBjdXJyW2tdO1xuICAgICAgY3VycltrXSA9IGFsbDtcbiAgICAgIGlmIChmICE9PSBhbGwpIG91dC5wdXNoKGspO1xuICAgIH0gLy8gcmVtb3ZlIGZyb20gZGltZW5zaW9uYWwgaW5kaWNlc1xuXG5cbiAgICBmb3IgKGsgaW4gaW5kaWNlcykge1xuICAgICAgaW5kaWNlc1trXS5yZW1vdmUobiwgbWFwKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlaW5kZXgocHVsc2UsIG4sIG1hcCk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfSxcblxuICAvLyByZWluZGV4IGZpbHRlcnMgYW5kIGluZGljZXMgYWZ0ZXIgcHJvcGFnYXRpb24gY29tcGxldGVzXG4gIHJlaW5kZXgocHVsc2UsIG51bSwgbWFwKSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuX2luZGljZXMsXG4gICAgICAgICAgYml0cyA9IHRoaXMudmFsdWU7XG4gICAgcHVsc2UucnVuQWZ0ZXIoKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXhNYXAgPSBiaXRzLnJlbW92ZShudW0sIG1hcCk7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZGljZXMpIGluZGljZXNba2V5XS5yZWluZGV4KGluZGV4TWFwKTtcbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGUoXywgcHVsc2UsIG91dHB1dCkge1xuICAgIGNvbnN0IGRpbXMgPSB0aGlzLl9kaW1zLFxuICAgICAgICAgIHF1ZXJ5ID0gXy5xdWVyeSxcbiAgICAgICAgICBzdGFtcCA9IHB1bHNlLnN0YW1wLFxuICAgICAgICAgIG0gPSBkaW1zLmxlbmd0aDtcbiAgICBsZXQgbWFzayA9IDAsXG4gICAgICAgIGksXG4gICAgICAgIHE7IC8vIHN1cnZleSBob3cgbWFueSBxdWVyaWVzIGhhdmUgY2hhbmdlZFxuXG4gICAgb3V0cHV0LmZpbHRlcnMgPSAwO1xuXG4gICAgZm9yIChxID0gMDsgcSA8IG07ICsrcSkge1xuICAgICAgaWYgKF8ubW9kaWZpZWQoJ3F1ZXJ5JywgcSkpIHtcbiAgICAgICAgaSA9IHE7XG4gICAgICAgICsrbWFzaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gMSkge1xuICAgICAgLy8gb25seSBvbmUgcXVlcnkgY2hhbmdlZCwgdXNlIG1vcmUgZWZmaWNpZW50IHVwZGF0ZVxuICAgICAgbWFzayA9IGRpbXNbaV0ub25lO1xuICAgICAgdGhpcy5pbmNyZW1lbnRPbmUoZGltc1tpXSwgcXVlcnlbaV0sIG91dHB1dC5hZGQsIG91dHB1dC5yZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtdWx0aXBsZSBxdWVyaWVzIGNoYW5nZWQsIHBlcmZvcm0gZnVsbCByZWNvcmQga2VlcGluZ1xuICAgICAgZm9yIChxID0gMCwgbWFzayA9IDA7IHEgPCBtOyArK3EpIHtcbiAgICAgICAgaWYgKCFfLm1vZGlmaWVkKCdxdWVyeScsIHEpKSBjb250aW51ZTtcbiAgICAgICAgbWFzayB8PSBkaW1zW3FdLm9uZTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRBbGwoZGltc1txXSwgcXVlcnlbcV0sIHN0YW1wLCBvdXRwdXQuYWRkKTtcbiAgICAgICAgb3V0cHV0LnJlbSA9IG91dHB1dC5hZGQ7IC8vIGR1cGxpY2F0ZSBhZGQvcmVtIGZvciBkb3duc3RyZWFtIHJlc29sdmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFzaztcbiAgfSxcblxuICBpbmNyZW1lbnRBbGwoZGltLCBxdWVyeSwgc3RhbXAsIG91dCkge1xuICAgIGNvbnN0IGJpdHMgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIHNlZW4gPSBiaXRzLnNlZW4oKSxcbiAgICAgICAgICBjdXJyID0gYml0cy5jdXJyKCksXG4gICAgICAgICAgcHJldiA9IGJpdHMucHJldigpLFxuICAgICAgICAgIGluZGV4ID0gZGltLmluZGV4KCksXG4gICAgICAgICAgb2xkID0gZGltLmJpc2VjdChkaW0ucmFuZ2UpLFxuICAgICAgICAgIHJhbmdlID0gZGltLmJpc2VjdChxdWVyeSksXG4gICAgICAgICAgbG8xID0gcmFuZ2VbMF0sXG4gICAgICAgICAgaGkxID0gcmFuZ2VbMV0sXG4gICAgICAgICAgbG8wID0gb2xkWzBdLFxuICAgICAgICAgIGhpMCA9IG9sZFsxXSxcbiAgICAgICAgICBvbmUgPSBkaW0ub25lO1xuICAgIGxldCBpLCBqLCBrOyAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBsbyBpbmRleC5cblxuICAgIGlmIChsbzEgPCBsbzApIHtcbiAgICAgIGZvciAoaSA9IGxvMSwgaiA9IE1hdGgubWluKGxvMCwgaGkxKTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG5cbiAgICAgICAgaWYgKHNlZW5ba10gIT09IHN0YW1wKSB7XG4gICAgICAgICAgcHJldltrXSA9IGN1cnJba107XG4gICAgICAgICAgc2VlbltrXSA9IHN0YW1wO1xuICAgICAgICAgIG91dC5wdXNoKGspO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycltrXSBePSBvbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsbzEgPiBsbzApIHtcbiAgICAgIGZvciAoaSA9IGxvMCwgaiA9IE1hdGgubWluKGxvMSwgaGkwKTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG5cbiAgICAgICAgaWYgKHNlZW5ba10gIT09IHN0YW1wKSB7XG4gICAgICAgICAgcHJldltrXSA9IGN1cnJba107XG4gICAgICAgICAgc2VlbltrXSA9IHN0YW1wO1xuICAgICAgICAgIG91dC5wdXNoKGspO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycltrXSBePSBvbmU7XG4gICAgICB9XG4gICAgfSAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBoaSBpbmRleC5cblxuXG4gICAgaWYgKGhpMSA+IGhpMCkge1xuICAgICAgZm9yIChpID0gTWF0aC5tYXgobG8xLCBoaTApLCBqID0gaGkxOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcblxuICAgICAgICBpZiAoc2VlbltrXSAhPT0gc3RhbXApIHtcbiAgICAgICAgICBwcmV2W2tdID0gY3VycltrXTtcbiAgICAgICAgICBzZWVuW2tdID0gc3RhbXA7XG4gICAgICAgICAgb3V0LnB1c2goayk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhpMSA8IGhpMCkge1xuICAgICAgZm9yIChpID0gTWF0aC5tYXgobG8wLCBoaTEpLCBqID0gaGkwOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcblxuICAgICAgICBpZiAoc2VlbltrXSAhPT0gc3RhbXApIHtcbiAgICAgICAgICBwcmV2W2tdID0gY3VycltrXTtcbiAgICAgICAgICBzZWVuW2tdID0gc3RhbXA7XG4gICAgICAgICAgb3V0LnB1c2goayk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaW0ucmFuZ2UgPSBxdWVyeS5zbGljZSgpO1xuICB9LFxuXG4gIGluY3JlbWVudE9uZShkaW0sIHF1ZXJ5LCBhZGQsIHJlbSkge1xuICAgIGNvbnN0IGJpdHMgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIGN1cnIgPSBiaXRzLmN1cnIoKSxcbiAgICAgICAgICBpbmRleCA9IGRpbS5pbmRleCgpLFxuICAgICAgICAgIG9sZCA9IGRpbS5iaXNlY3QoZGltLnJhbmdlKSxcbiAgICAgICAgICByYW5nZSA9IGRpbS5iaXNlY3QocXVlcnkpLFxuICAgICAgICAgIGxvMSA9IHJhbmdlWzBdLFxuICAgICAgICAgIGhpMSA9IHJhbmdlWzFdLFxuICAgICAgICAgIGxvMCA9IG9sZFswXSxcbiAgICAgICAgICBoaTAgPSBvbGRbMV0sXG4gICAgICAgICAgb25lID0gZGltLm9uZTtcbiAgICBsZXQgaSwgaiwgazsgLy8gRmFzdCBpbmNyZW1lbnRhbCB1cGRhdGUgYmFzZWQgb24gcHJldmlvdXMgbG8gaW5kZXguXG5cbiAgICBpZiAobG8xIDwgbG8wKSB7XG4gICAgICBmb3IgKGkgPSBsbzEsIGogPSBNYXRoLm1pbihsbzAsIGhpMSk7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgayA9IGluZGV4W2ldO1xuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgICAgYWRkLnB1c2goayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsbzEgPiBsbzApIHtcbiAgICAgIGZvciAoaSA9IGxvMCwgaiA9IE1hdGgubWluKGxvMSwgaGkwKTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgICByZW0ucHVzaChrKTtcbiAgICAgIH1cbiAgICB9IC8vIEZhc3QgaW5jcmVtZW50YWwgdXBkYXRlIGJhc2VkIG9uIHByZXZpb3VzIGhpIGluZGV4LlxuXG5cbiAgICBpZiAoaGkxID4gaGkwKSB7XG4gICAgICBmb3IgKGkgPSBNYXRoLm1heChsbzEsIGhpMCksIGogPSBoaTE7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgayA9IGluZGV4W2ldO1xuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgICAgYWRkLnB1c2goayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoaTEgPCBoaTApIHtcbiAgICAgIGZvciAoaSA9IE1hdGgubWF4KGxvMCwgaGkxKSwgaiA9IGhpMDsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgICByZW0ucHVzaChrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaW0ucmFuZ2UgPSBxdWVyeS5zbGljZSgpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFNlbGVjdGl2ZWx5IGZpbHRlcnMgdHVwbGVzIGJ5IHJlc29sdmluZyBhZ2FpbnN0IGEgZmlsdGVyIGJpdG1hcC5cbiAqIFVzZWZ1bCBmb3IgcHJvY2Vzc2luZyB0aGUgb3V0cHV0IG9mIGEgY3Jvc3MtZmlsdGVyIHRyYW5zZm9ybS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5pZ25vcmUgLSBBIGJpdCBtYXNrIGluZGljYXRpbmcgd2hpY2ggZmlsdGVycyB0byBpZ25vcmUuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmZpbHRlciAtIFRoZSBwZXItdHVwbGUgZmlsdGVyIGJpdG1hcHMuIFR5cGljYWxseSB0aGlzXG4gKiAgIHBhcmFtZXRlciB2YWx1ZSBpcyBhIHJlZmVyZW5jZSB0byBhIHtAbGluayBDcm9zc0ZpbHRlcn0gdHJhbnNmb3JtLlxuICovXG5cbmZ1bmN0aW9uIFJlc29sdmVGaWx0ZXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5SZXNvbHZlRmlsdGVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1Jlc29sdmVGaWx0ZXInLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnaWdub3JlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdyZXF1aXJlZCc6IHRydWUsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0EgYml0IG1hc2sgaW5kaWNhdGluZyB3aGljaCBmaWx0ZXJzIHRvIGlnbm9yZS4nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWx0ZXInLFxuICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZSxcbiAgICAnZGVzY3JpcHRpb24nOiAnUGVyLXR1cGxlIGZpbHRlciBiaXRtYXBzIGZyb20gYSBDcm9zc0ZpbHRlciB0cmFuc2Zvcm0uJ1xuICB9XVxufTtcbmluaGVyaXRzKFJlc29sdmVGaWx0ZXIsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBpZ25vcmUgPSB+KF8uaWdub3JlIHx8IDApLFxuICAgICAgICAgIC8vIGJpdCBtYXNrIHdoZXJlIHplcm9zIC0+IGRpbXMgdG8gaWdub3JlXG4gICAgYml0bWFwID0gXy5maWx0ZXIsXG4gICAgICAgICAgbWFzayA9IGJpdG1hcC5tYXNrOyAvLyBleGl0IGVhcmx5IGlmIG5vIHJlbGV2YW50IGZpbHRlciBjaGFuZ2VzXG5cbiAgICBpZiAoKG1hc2sgJiBpZ25vcmUpID09PSAwKSByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuXG4gICAgY29uc3Qgb3V0cHV0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLFxuICAgICAgICAgIGRhdGEgPSBiaXRtYXAuZGF0YSgpLFxuICAgICAgICAgIGN1cnIgPSBiaXRtYXAuY3VycigpLFxuICAgICAgICAgIHByZXYgPSBiaXRtYXAucHJldigpLFxuICAgICAgICAgIHBhc3MgPSBrID0+ICEoY3VycltrXSAmIGlnbm9yZSkgPyBkYXRhW2tdIDogbnVsbDsgLy8gcHJvcGFnYXRlIGFsbCBtb2QgdHVwbGVzIHRoYXQgcGFzcyB0aGUgZmlsdGVyXG5cblxuICAgIG91dHB1dC5maWx0ZXIob3V0cHV0Lk1PRCwgcGFzcyk7IC8vIGRldGVybWluZSBhZGQgJiByZW0gdHVwbGVzIHZpYSBmaWx0ZXIgZnVuY3Rpb25zXG4gICAgLy8gZm9yIGVmZmljaWVuY3ksIHdlIGRvICpub3QqIHBvcHVsYXRlIG5ldyBhcnJheXMsXG4gICAgLy8gaW5zdGVhZCB3ZSBhZGQgZmlsdGVyIGZ1bmN0aW9ucyBhcHBsaWVkIGRvd25zdHJlYW1cblxuICAgIGlmICghKG1hc2sgJiBtYXNrIC0gMSkpIHtcbiAgICAgIC8vIG9ubHkgb25lIGZpbHRlciBjaGFuZ2VkXG4gICAgICBvdXRwdXQuZmlsdGVyKG91dHB1dC5BREQsIHBhc3MpO1xuICAgICAgb3V0cHV0LmZpbHRlcihvdXRwdXQuUkVNLCBrID0+IChjdXJyW2tdICYgaWdub3JlKSA9PT0gbWFzayA/IGRhdGFba10gOiBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbXVsdGlwbGUgZmlsdGVycyBjaGFuZ2VkXG4gICAgICBvdXRwdXQuZmlsdGVyKG91dHB1dC5BREQsIGsgPT4ge1xuICAgICAgICBjb25zdCBjID0gY3VycltrXSAmIGlnbm9yZSxcbiAgICAgICAgICAgICAgZiA9ICFjICYmIGMgXiBwcmV2W2tdICYgaWdub3JlO1xuICAgICAgICByZXR1cm4gZiA/IGRhdGFba10gOiBudWxsO1xuICAgICAgfSk7XG4gICAgICBvdXRwdXQuZmlsdGVyKG91dHB1dC5SRU0sIGsgPT4ge1xuICAgICAgICBjb25zdCBjID0gY3VycltrXSAmIGlnbm9yZSxcbiAgICAgICAgICAgICAgZiA9IGMgJiYgIShjIF4gKGMgXiBwcmV2W2tdICYgaWdub3JlKSk7XG4gICAgICAgIHJldHVybiBmID8gZGF0YVtrXSA6IG51bGw7XG4gICAgICB9KTtcbiAgICB9IC8vIGFkZCBmaWx0ZXIgdG8gc291cmNlIGRhdGEgaW4gY2FzZSBvZiByZWZsb3cuLi5cblxuXG4gICAgcmV0dXJuIG91dHB1dC5maWx0ZXIob3V0cHV0LlNPVVJDRSwgdCA9PiBwYXNzKHQuX2luZGV4KSk7XG4gIH1cblxufSk7XG5cbmV4cG9ydCB7IENyb3NzRmlsdGVyIGFzIGNyb3NzZmlsdGVyLCBSZXNvbHZlRmlsdGVyIGFzIHJlc29sdmVmaWx0ZXIgfTtcbiIsImltcG9ydCB7IGlkZW50aXR5LCBhcnJheSwgaXNGdW5jdGlvbiwgY29uc3RhbnQsIGlzQXJyYXksIGlkLCBlcnJvciwgdHJ1dGh5LCBkZWJvdW5jZSwgZXh0ZW5kLCB2aXNpdEFycmF5LCBpbmhlcml0cywgbG9nZ2VyLCBFcnJvciwgaGFzT3duUHJvcGVydHkgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgcmVhZCwgcmVzcG9uc2VUeXBlLCBsb2FkZXIgfSBmcm9tICd2ZWdhLWxvYWRlcic7XG5pbXBvcnQgeyBkZWZhdWx0TG9jYWxlIH0gZnJvbSAndmVnYS1mb3JtYXQnO1xuXG5mdW5jdGlvbiBVbmlxdWVMaXN0KGlkRnVuYykge1xuICBjb25zdCAkID0gaWRGdW5jIHx8IGlkZW50aXR5LFxuICAgICAgICBsaXN0ID0gW10sXG4gICAgICAgIGlkcyA9IHt9O1xuXG4gIGxpc3QuYWRkID0gXyA9PiB7XG4gICAgY29uc3QgaWQgPSAkKF8pO1xuXG4gICAgaWYgKCFpZHNbaWRdKSB7XG4gICAgICBpZHNbaWRdID0gMTtcbiAgICAgIGxpc3QucHVzaChfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfTtcblxuICBsaXN0LnJlbW92ZSA9IF8gPT4ge1xuICAgIGNvbnN0IGlkID0gJChfKTtcblxuICAgIGlmIChpZHNbaWRdKSB7XG4gICAgICBpZHNbaWRdID0gMDtcbiAgICAgIGNvbnN0IGlkeCA9IGxpc3QuaW5kZXhPZihfKTtcbiAgICAgIGlmIChpZHggPj0gMCkgbGlzdC5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYW5kIGF3YWl0IGEgcG90ZW50aWFsbHkgYXN5bmMgY2FsbGJhY2sgZnVuY3Rpb24uIElmXG4gKiBhbiBlcnJvciBvY2N1cnMsIHRyYXAgaXQgYW5kIHJvdXRlIHRvIERhdGFmbG93LmVycm9yLlxuICogQHBhcmFtIHtEYXRhZmxvd30gZGYgLSBUaGUgZGF0YWZsb3cgaW5zdGFuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgYW5kIHRoZW4gYXdhaXQuIFRoZSBkYXRhZmxvdyB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgc2luZ2xlXG4gKiAgIGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNDYWxsYmFjayAoZGYsIGNhbGxiYWNrKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgY2FsbGJhY2soZGYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZi5lcnJvcihlcnIpO1xuICB9XG59XG5cbmNvbnN0IFRVUExFX0lEX0tFWSA9IFN5bWJvbCgndmVnYV9pZCcpO1xubGV0IFRVUExFX0lEID0gMTtcbi8qKlxuICogQ2hlY2tzIGlmIGFuIGlucHV0IHZhbHVlIGlzIGEgcmVnaXN0ZXJlZCB0dXBsZS5cbiAqIEBwYXJhbSB7Kn0gdCAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGlucHV0IGlzIGEgdHVwbGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc1R1cGxlKHQpIHtcbiAgcmV0dXJuICEhKHQgJiYgdHVwbGVpZCh0KSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGlkIG9mIGEgdHVwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gdCAtIFRoZSBpbnB1dCB0dXBsZS5cbiAqIEByZXR1cm4geyp9IHRoZSB0dXBsZSBpZC5cbiAqL1xuXG5mdW5jdGlvbiB0dXBsZWlkKHQpIHtcbiAgcmV0dXJuIHRbVFVQTEVfSURfS0VZXTtcbn1cbi8qKlxuICogU2V0cyB0aGUgaWQgb2YgYSB0dXBsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0IC0gVGhlIGlucHV0IHR1cGxlLlxuICogQHBhcmFtIHsqfSBpZCAtIFRoZSBpZCB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJuIHtvYmplY3R9IHRoZSBpbnB1dCB0dXBsZS5cbiAqL1xuXG5mdW5jdGlvbiBzZXRpZCh0LCBpZCkge1xuICB0W1RVUExFX0lEX0tFWV0gPSBpZDtcbiAgcmV0dXJuIHQ7XG59XG4vKipcbiAqIEluZ2VzdCBhbiBvYmplY3Qgb3IgdmFsdWUgYXMgYSBkYXRhIHR1cGxlLlxuICogSWYgdGhlIGlucHV0IHZhbHVlIGlzIGFuIG9iamVjdCwgYW4gaWQgZmllbGQgd2lsbCBiZSBhZGRlZCB0byBpdC4gRm9yXG4gKiBlZmZpY2llbmN5LCB0aGUgaW5wdXQgb2JqZWN0IGlzIG1vZGlmaWVkIGRpcmVjdGx5LiBBIGNvcHkgaXMgbm90IG1hZGUuXG4gKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgYSBsaXRlcmFsLCBpdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSBuZXcgb2JqZWN0XG4gKiBpbnN0YW5jZSwgd2l0aCB0aGUgdmFsdWUgYWNjZXNzaWJsZSBhcyB0aGUgJ2RhdGEnIHByb3BlcnR5LlxuICogQHBhcmFtIGRhdHVtIC0gVGhlIHZhbHVlIHRvIGluZ2VzdC5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIGluZ2VzdGVkIGRhdGEgdHVwbGUuXG4gKi9cblxuXG5mdW5jdGlvbiBpbmdlc3QkMShkYXR1bSkge1xuICBjb25zdCB0ID0gZGF0dW0gPT09IE9iamVjdChkYXR1bSkgPyBkYXR1bSA6IHtcbiAgICBkYXRhOiBkYXR1bVxuICB9O1xuICByZXR1cm4gdHVwbGVpZCh0KSA/IHQgOiBzZXRpZCh0LCBUVVBMRV9JRCsrKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBzb3VyY2UgdHVwbGUsIHJldHVybiBhIGRlcml2ZWQgY29weS5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0IC0gVGhlIHNvdXJjZSB0dXBsZS5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIGRlcml2ZWQgdHVwbGUuXG4gKi9cblxuZnVuY3Rpb24gZGVyaXZlKHQpIHtcbiAgcmV0dXJuIHJlZGVyaXZlKHQsIGluZ2VzdCQxKHt9KSk7XG59XG4vKipcbiAqIFJlZGVyaXZlIGEgZGVyaXZlZCB0dXBsZSBieSBjb3B5aW5nIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdHVwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gdCAtIFRoZSBzb3VyY2UgdHVwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gZCAtIFRoZSBkZXJpdmVkIHR1cGxlLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgZGVyaXZlZCB0dXBsZS5cbiAqL1xuXG5mdW5jdGlvbiByZWRlcml2ZSh0LCBkKSB7XG4gIGZvciAoY29uc3QgayBpbiB0KSBkW2tdID0gdFtrXTtcblxuICByZXR1cm4gZDtcbn1cbi8qKlxuICogUmVwbGFjZSBhbiBleGlzdGluZyB0dXBsZSB3aXRoIGEgbmV3IHR1cGxlLlxuICogQHBhcmFtIHtvYmplY3R9IHQgLSBUaGUgZXhpc3RpbmcgZGF0YSB0dXBsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkIC0gVGhlIG5ldyB0dXBsZSB0aGF0IHJlcGxhY2VzIHRoZSBvbGQuXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBuZXcgdHVwbGUuXG4gKi9cblxuZnVuY3Rpb24gcmVwbGFjZSh0LCBkKSB7XG4gIHJldHVybiBzZXRpZChkLCB0dXBsZWlkKHQpKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYW4gYXVnbWVudGVkIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBzdGFibGVcbiAqIHNvcnRpbmcgYnkgdHVwbGUgaWQgd2hlbiB0aGUgZ2l2ZW4gY29tcGFyYXRvciBwcm9kdWNlcyB0aWVzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY21wIC0gVGhlIGNvbXBhcmF0b3IgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmXSAtIE9wdGlvbmFsIHR1cGxlIGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEFuIGF1Z21lbnRlZCBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIHN0YWJsZUNvbXBhcmUoY21wLCBmKSB7XG4gIHJldHVybiAhY21wID8gbnVsbCA6IGYgPyAoYSwgYikgPT4gY21wKGEsIGIpIHx8IHR1cGxlaWQoZihhKSkgLSB0dXBsZWlkKGYoYikpIDogKGEsIGIpID0+IGNtcChhLCBiKSB8fCB0dXBsZWlkKGEpIC0gdHVwbGVpZChiKTtcbn1cblxuZnVuY3Rpb24gaXNDaGFuZ2VTZXQodikge1xuICByZXR1cm4gdiAmJiB2LmNvbnN0cnVjdG9yID09PSBjaGFuZ2VzZXQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VzZXQoKSB7XG4gIGNvbnN0IGFkZCA9IFtdLFxuICAgICAgICAvLyBpbnNlcnQgdHVwbGVzXG4gIHJlbSA9IFtdLFxuICAgICAgICAvLyByZW1vdmUgdHVwbGVzXG4gIG1vZCA9IFtdLFxuICAgICAgICAvLyBtb2RpZnkgdHVwbGVzXG4gIHJlbXAgPSBbXSxcbiAgICAgICAgLy8gcmVtb3ZlIGJ5IHByZWRpY2F0ZVxuICBtb2RwID0gW107IC8vIG1vZGlmeSBieSBwcmVkaWNhdGVcblxuICBsZXQgY2xlYW4gPSBudWxsLFxuICAgICAgcmVmbG93ID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgY29uc3RydWN0b3I6IGNoYW5nZXNldCxcblxuICAgIGluc2VydCh0KSB7XG4gICAgICBjb25zdCBkID0gYXJyYXkodCksXG4gICAgICAgICAgICBuID0gZC5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBhZGQucHVzaChkW2ldKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZSh0KSB7XG4gICAgICBjb25zdCBhID0gaXNGdW5jdGlvbih0KSA/IHJlbXAgOiByZW0sXG4gICAgICAgICAgICBkID0gYXJyYXkodCksXG4gICAgICAgICAgICBuID0gZC5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBhLnB1c2goZFtpXSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtb2RpZnkodCwgZmllbGQsIHZhbHVlKSB7XG4gICAgICBjb25zdCBtID0ge1xuICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgIHZhbHVlOiBjb25zdGFudCh2YWx1ZSlcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHQpKSB7XG4gICAgICAgIG0uZmlsdGVyID0gdDtcbiAgICAgICAgbW9kcC5wdXNoKG0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbS50dXBsZSA9IHQ7XG4gICAgICAgIG1vZC5wdXNoKG0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZW5jb2RlKHQsIHNldCkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24odCkpIG1vZHAucHVzaCh7XG4gICAgICAgIGZpbHRlcjogdCxcbiAgICAgICAgZmllbGQ6IHNldFxuICAgICAgfSk7ZWxzZSBtb2QucHVzaCh7XG4gICAgICAgIHR1cGxlOiB0LFxuICAgICAgICBmaWVsZDogc2V0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhbih2YWx1ZSkge1xuICAgICAgY2xlYW4gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZWZsb3coKSB7XG4gICAgICByZWZsb3cgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHB1bHNlKHB1bHNlLCB0dXBsZXMpIHtcbiAgICAgIGNvbnN0IGN1ciA9IHt9LFxuICAgICAgICAgICAgb3V0ID0ge307XG4gICAgICBsZXQgaSwgbiwgbSwgZiwgdCwgaWQ7IC8vIGJ1aWxkIGxvb2t1cCB0YWJsZSBvZiBjdXJyZW50IHR1cGxlc1xuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gdHVwbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBjdXJbdHVwbGVpZCh0dXBsZXNbaV0pXSA9IDE7XG4gICAgICB9IC8vIHByb2Nlc3MgaW5kaXZpZHVhbCB0dXBsZXMgdG8gcmVtb3ZlXG5cblxuICAgICAgZm9yIChpID0gMCwgbiA9IHJlbS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdCA9IHJlbVtpXTtcbiAgICAgICAgY3VyW3R1cGxlaWQodCldID0gLTE7XG4gICAgICB9IC8vIHByb2Nlc3MgcHJlZGljYXRlLWJhc2VkIHJlbW92YWxzXG5cblxuICAgICAgZm9yIChpID0gMCwgbiA9IHJlbXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGYgPSByZW1wW2ldO1xuICAgICAgICB0dXBsZXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBpZiAoZih0KSkgY3VyW3R1cGxlaWQodCldID0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBwcm9jZXNzIGFsbCBhZGQgdHVwbGVzXG5cblxuICAgICAgZm9yIChpID0gMCwgbiA9IGFkZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdCA9IGFkZFtpXTtcbiAgICAgICAgaWQgPSB0dXBsZWlkKHQpO1xuXG4gICAgICAgIGlmIChjdXJbaWRdKSB7XG4gICAgICAgICAgLy8gdHVwbGUgYWxyZWFkeSByZXNpZGVzIGluIGRhdGFzZXRcbiAgICAgICAgICAvLyBpZiBmbGFnZ2VkIGZvciBib3RoIGFkZCBhbmQgcmVtb3ZlLCBjYW5jZWxcbiAgICAgICAgICBjdXJbaWRdID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0dXBsZSBkb2VzIG5vdCByZXNpZGUgaW4gZGF0YXNldCwgYWRkXG4gICAgICAgICAgcHVsc2UuYWRkLnB1c2goaW5nZXN0JDEoYWRkW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcG9wdWxhdGUgcHVsc2UgcmVtIGxpc3RcblxuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gdHVwbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB0ID0gdHVwbGVzW2ldO1xuICAgICAgICBpZiAoY3VyW3R1cGxlaWQodCldIDwgMCkgcHVsc2UucmVtLnB1c2godCk7XG4gICAgICB9IC8vIG1vZGlmeSBoZWxwZXIgbWV0aG9kXG5cblxuICAgICAgZnVuY3Rpb24gbW9kaWZ5KHQsIGYsIHYpIHtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICB0W2ZdID0gdih0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdWxzZS5lbmNvZGUgPSBmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWZsb3cpIG91dFt0dXBsZWlkKHQpXSA9IHQ7XG4gICAgICB9IC8vIHByb2Nlc3MgaW5kaXZpZHVhbCB0dXBsZXMgdG8gbW9kaWZ5XG5cblxuICAgICAgZm9yIChpID0gMCwgbiA9IG1vZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbSA9IG1vZFtpXTtcbiAgICAgICAgdCA9IG0udHVwbGU7XG4gICAgICAgIGYgPSBtLmZpZWxkO1xuICAgICAgICBpZCA9IGN1clt0dXBsZWlkKHQpXTtcblxuICAgICAgICBpZiAoaWQgPiAwKSB7XG4gICAgICAgICAgbW9kaWZ5KHQsIGYsIG0udmFsdWUpO1xuICAgICAgICAgIHB1bHNlLm1vZGlmaWVzKGYpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHByb2Nlc3MgcHJlZGljYXRlLWJhc2VkIG1vZGlmaWNhdGlvbnNcblxuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gbW9kcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbSA9IG1vZHBbaV07XG4gICAgICAgIGYgPSBtLmZpbHRlcjtcbiAgICAgICAgdHVwbGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgaWYgKGYodCkgJiYgY3VyW3R1cGxlaWQodCldID4gMCkge1xuICAgICAgICAgICAgbW9kaWZ5KHQsIG0uZmllbGQsIG0udmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHB1bHNlLm1vZGlmaWVzKG0uZmllbGQpO1xuICAgICAgfSAvLyB1cG9uIHJlZmxvdyByZXF1ZXN0LCBwb3B1bGF0ZSBtb2Qgd2l0aCBhbGwgbm9uLXJlbW92ZWQgdHVwbGVzXG4gICAgICAvLyBvdGhlcndpc2UsIHBvcHVsYXRlIG1vZCB3aXRoIG1vZGlmaWVkIHR1cGxlcyBvbmx5XG5cblxuICAgICAgaWYgKHJlZmxvdykge1xuICAgICAgICBwdWxzZS5tb2QgPSByZW0ubGVuZ3RoIHx8IHJlbXAubGVuZ3RoID8gdHVwbGVzLmZpbHRlcih0ID0+IGN1clt0dXBsZWlkKHQpXSA+IDApIDogdHVwbGVzLnNsaWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGlkIGluIG91dCkgcHVsc2UubW9kLnB1c2gob3V0W2lkXSk7XG4gICAgICB9IC8vIHNldCBwdWxzZSBnYXJiYWdlIGNvbGxlY3Rpb24gcmVxdWVzdFxuXG5cbiAgICAgIGlmIChjbGVhbiB8fCBjbGVhbiA9PSBudWxsICYmIChyZW0ubGVuZ3RoIHx8IHJlbXAubGVuZ3RoKSkge1xuICAgICAgICBwdWxzZS5jbGVhbih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB1bHNlO1xuICAgIH1cblxuICB9O1xufVxuXG5jb25zdCBDQUNIRSA9ICdfOm1vZDpfJztcbi8qKlxuICogSGFzaCB0aGF0IHRyYWNrcyBtb2RpZmljYXRpb25zIHRvIGFzc2lnbmVkIHZhbHVlcy5cbiAqIENhbGxlcnMgKm11c3QqIHVzZSB0aGUgc2V0IG1ldGhvZCB0byB1cGRhdGUgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIFBhcmFtZXRlcnMoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBDQUNIRSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB7fVxuICB9KTtcbn1cblBhcmFtZXRlcnMucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogU2V0IGEgcGFyYW1ldGVyIHZhbHVlLiBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGNoYW5nZXMsIHRoZSBwYXJhbWV0ZXJcbiAgICogd2lsbCBiZSByZWNvcmRlZCBhcyBtb2RpZmllZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIGFuIGFycmF5LXZhbHVlIHBhcmFtZXRlci4gSWdub3JlZCBpZlxuICAgKiAgIHRoZSBhcmd1bWVudCBpcyB1bmRlZmluZWQsIG51bGwgb3IgbGVzcyB0aGFuIHplcm8uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgcGFyYW1ldGVyIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gSWYgdHJ1ZSwgcmVjb3JkcyB0aGUgcGFyYW1ldGVyIGFzIG1vZGlmaWVkXG4gICAqICAgZXZlbiBpZiB0aGUgdmFsdWUgaXMgdW5jaGFuZ2VkLlxuICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJzfSAtIFRoaXMgcGFyYW1ldGVyIG9iamVjdC5cbiAgICovXG4gIHNldChuYW1lLCBpbmRleCwgdmFsdWUsIGZvcmNlKSB7XG4gICAgY29uc3QgbyA9IHRoaXMsXG4gICAgICAgICAgdiA9IG9bbmFtZV0sXG4gICAgICAgICAgbW9kID0gb1tDQUNIRV07XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICBpZiAodltpbmRleF0gIT09IHZhbHVlIHx8IGZvcmNlKSB7XG4gICAgICAgIHZbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIG1vZFtpbmRleCArICc6JyArIG5hbWVdID0gLTE7XG4gICAgICAgIG1vZFtuYW1lXSA9IC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodiAhPT0gdmFsdWUgfHwgZm9yY2UpIHtcbiAgICAgIG9bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIG1vZFtuYW1lXSA9IGlzQXJyYXkodmFsdWUpID8gMSArIHZhbHVlLmxlbmd0aCA6IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBvO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiBvbmUgb3IgbW9yZSBwYXJhbWV0ZXJzIGhhcyBiZWVuIG1vZGlmaWVkLiBJZiBpbnZva2VkIHdpdGggbm9cbiAgICogYXJndW1lbnRzLCByZXR1cm5zIHRydWUgaWYgYW55IHBhcmFtZXRlciB2YWx1ZSBoYXMgY2hhbmdlZC4gSWYgdGhlIGZpcnN0XG4gICAqIGFyZ3VtZW50IGlzIGFycmF5LCByZXR1cm5zIHRydWVzIGlmIGFueSBwYXJhbWV0ZXIgbmFtZSBpbiB0aGUgYXJyYXkgaGFzXG4gICAqIGNoYW5nZWQuIE90aGVyd2lzZSwgdGVzdHMgaWYgdGhlIGdpdmVuIG5hbWUgYW5kIG9wdGlvbmFsIGFycmF5IGluZGV4IGhhc1xuICAgKiBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBwYXJhbWV0ZXIgbmFtZSB0byB0ZXN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PXVuZGVmaW5lZF0gLSBUaGUgcGFyYW1ldGVyIGFycmF5IGluZGV4IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIGEgcXVlcmllZCBwYXJhbWV0ZXIgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgbW9kaWZpZWQobmFtZSwgaW5kZXgpIHtcbiAgICBjb25zdCBtb2QgPSB0aGlzW0NBQ0hFXTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBrIGluIG1vZCkge1xuICAgICAgICBpZiAobW9kW2tdKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShuYW1lKSkge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuYW1lLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGlmIChtb2RbbmFtZVtrXV0pIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4ICE9IG51bGwgJiYgaW5kZXggPj0gMCA/IGluZGV4ICsgMSA8IG1vZFtuYW1lXSB8fCAhIW1vZFtpbmRleCArICc6JyArIG5hbWVdIDogISFtb2RbbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgbW9kaWZpY2F0aW9uIHJlY29yZHMuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gICAqIGFsbCBwYXJhbWV0ZXJzIGFyZSBjb25zaWRlcmVkIHVubW9kaWZpZWQuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzW0NBQ0hFXSA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn07XG5cbmxldCBPUF9JRCA9IDA7XG5jb25zdCBQVUxTRSA9ICdwdWxzZScsXG4gICAgICBOT19QQVJBTVMgPSBuZXcgUGFyYW1ldGVycygpOyAvLyBCb29sZWFuIEZsYWdzXG5cbmNvbnN0IFNLSVAkMSA9IDEsXG4gICAgICBNT0RJRklFRCA9IDI7XG4vKipcbiAqIEFuIE9wZXJhdG9yIGlzIGEgcHJvY2Vzc2luZyBub2RlIGluIGEgZGF0YWZsb3cgZ3JhcGguXG4gKiBFYWNoIG9wZXJhdG9yIHN0b3JlcyBhIHZhbHVlIGFuZCBhbiBvcHRpb25hbCB2YWx1ZSB1cGRhdGUgZnVuY3Rpb24uXG4gKiBPcGVyYXRvcnMgY2FuIGFjY2VwdCBhIGhhc2ggb2YgbmFtZWQgcGFyYW1ldGVycy4gUGFyYW1ldGVyIHZhbHVlcyBjYW5cbiAqIGVpdGhlciBiZSBkaXJlY3QgKEphdmFTY3JpcHQgbGl0ZXJhbHMsIGFycmF5cywgb2JqZWN0cykgb3IgaW5kaXJlY3RcbiAqIChvdGhlciBvcGVyYXRvcnMgd2hvc2UgdmFsdWVzIHdpbGwgYmUgcHVsbGVkIGR5bmFtaWNhbGx5KS4gT3BlcmF0b3JzXG4gKiBpbmNsdWRlZCBhcyBwYXJhbWV0ZXJzIHdpbGwgaGF2ZSB0aGlzIG9wZXJhdG9yIGFkZGVkIGFzIGEgZGVwZW5kZW5jeS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSBbaW5pdF0gLSBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0LCBQdWxzZSl9IFt1cGRhdGVdIC0gQW4gdXBkYXRlIGZ1bmN0aW9uLiBVcG9uXG4gKiAgIGV2YWx1YXRpb24gb2YgdGhpcyBvcGVyYXRvciwgdGhlIHVwZGF0ZSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYW5kIHRoZVxuICogICByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBuZXcgdmFsdWUgb2YgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtib29sZWFufSBbcmVhY3Q9dHJ1ZV0gLSBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBvcGVyYXRvciBzaG91bGRcbiAqICAgbGlzdGVuIGZvciBjaGFuZ2VzIHRvIHVwc3RyZWFtIG9wZXJhdG9ycyBpbmNsdWRlZCBhcyBwYXJhbWV0ZXJzLlxuICogQHNlZSBwYXJhbWV0ZXJzXG4gKi9cblxuZnVuY3Rpb24gT3BlcmF0b3IoaW5pdCwgdXBkYXRlLCBwYXJhbXMsIHJlYWN0KSB7XG4gIHRoaXMuaWQgPSArK09QX0lEO1xuICB0aGlzLnZhbHVlID0gaW5pdDtcbiAgdGhpcy5zdGFtcCA9IC0xO1xuICB0aGlzLnJhbmsgPSAtMTtcbiAgdGhpcy5xcmFuayA9IC0xO1xuICB0aGlzLmZsYWdzID0gMDtcblxuICBpZiAodXBkYXRlKSB7XG4gICAgdGhpcy5fdXBkYXRlID0gdXBkYXRlO1xuICB9XG5cbiAgaWYgKHBhcmFtcykgdGhpcy5wYXJhbWV0ZXJzKHBhcmFtcywgcmVhY3QpO1xufVxuXG5mdW5jdGlvbiBmbGFnKGJpdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgY29uc3QgZiA9IHRoaXMuZmxhZ3M7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiAhIShmICYgYml0KTtcbiAgICB0aGlzLmZsYWdzID0gc3RhdGUgPyBmIHwgYml0IDogZiAmIH5iaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbk9wZXJhdG9yLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRhcmdldCBvcGVyYXRvcnMgZGVwZW5kZW50IG9uIHRoaXMgb3BlcmF0b3IuXG4gICAqIElmIHRoaXMgbGlzdCBkb2VzIG5vdCBleGlzdCwgaXQgaXMgY3JlYXRlZCBhbmQgdGhlbiByZXR1cm5lZC5cbiAgICogQHJldHVybiB7VW5pcXVlTGlzdH1cbiAgICovXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldHMgfHwgKHRoaXMuX3RhcmdldHMgPSBVbmlxdWVMaXN0KGlkKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoaXMgb3BlcmF0b3IuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgMSBpZiB0aGUgb3BlcmF0b3IgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICogICBhY2NvcmRpbmcgdG8gc3RyaWN0IGVxdWFsaXR5LCByZXR1cm5zIDAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgc2V0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBvcGVyYXRvciBldmFsdWF0aW9uIHNob3VsZCBiZSBza2lwcGVkIG9uIHRoZSBuZXh0IHB1bHNlLlxuICAgKiBUaGlzIG9wZXJhdG9yIHdpbGwgc3RpbGwgcHJvcGFnYXRlIGluY29taW5nIHB1bHNlcywgYnV0IGl0cyB1cGRhdGUgZnVuY3Rpb25cbiAgICogd2lsbCBub3QgYmUgaW52b2tlZC4gVGhlIHNraXAgZmxhZyBpcyByZXNldCBhZnRlciBldmVyeSBwdWxzZSwgc28gY2FsbGluZ1xuICAgKiB0aGlzIG1ldGhvZCB3aWxsIGFmZmVjdCBwcm9jZXNzaW5nIG9mIHRoZSBuZXh0IHB1bHNlIG9ubHkuXG4gICAqL1xuICBza2lwOiBmbGFnKFNLSVAkMSksXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IHRoaXMgb3BlcmF0b3IncyB2YWx1ZSBoYXMgYmVlbiBtb2RpZmllZCBvbiBpdHMgbW9zdCByZWNlbnRcbiAgICogcHVsc2UuIE5vcm1hbGx5IG1vZGlmaWNhdGlvbiBpcyBjaGVja2VkIHZpYSBzdHJpY3QgZXF1YWxpdHk7IGhvd2V2ZXIsIGluXG4gICAqIHNvbWUgY2FzZXMgaXQgaXMgbW9yZSBlZmZpY2llbnQgdG8gdXBkYXRlIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBhbiBvYmplY3QuXG4gICAqIEluIHRob3NlIGNhc2VzLCB0aGUgbW9kaWZpZWQgZmxhZyBjYW4gYmUgdXNlZCB0byB0cmlnZ2VyIHByb3BhZ2F0aW9uLiBPbmNlXG4gICAqIHNldCwgdGhlIG1vZGlmaWNhdGlvbiBmbGFnIHBlcnNpc3RzIGFjcm9zcyBwdWxzZXMgdW50aWwgdW5zZXQuIFRoZSBmbGFnIGNhblxuICAgKiBiZSB1c2VkIHdpdGggdGhlIGxhc3QgdGltZXN0YW1wIHRvIHRlc3QgaWYgYSBtb2RpZmljYXRpb24gaXMgcmVjZW50LlxuICAgKi9cbiAgbW9kaWZpZWQ6IGZsYWcoTU9ESUZJRUQpLFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBhcmUgYW5hbHl6ZWQgZm9yXG4gICAqIG9wZXJhdG9yIGluc3RhbmNlcy4gSWYgZm91bmQsIHRoaXMgb3BlcmF0b3Igd2lsbCBiZSBhZGRlZCBhcyBhIGRlcGVuZGVuY3lcbiAgICogb2YgdGhlIHBhcmFtZXRlcml6aW5nIG9wZXJhdG9yLiBPcGVyYXRvciB2YWx1ZXMgYXJlIGR5bmFtaWNhbGx5IG1hcnNoYWxsZWRcbiAgICogZnJvbSBlYWNoIG9wZXJhdG9yIHBhcmFtZXRlciBwcmlvciB0byBldmFsdWF0aW9uLiBJZiBhIHBhcmFtZXRlciB2YWx1ZSBpc1xuICAgKiBhbiBhcnJheSwgdGhlIGFycmF5IHdpbGwgYWxzbyBiZSBzZWFyY2hlZCBmb3IgT3BlcmF0b3IgaW5zdGFuY2VzLiBIb3dldmVyLFxuICAgKiB0aGUgc2VhcmNoIGRvZXMgbm90IHJlY3Vyc2UgaW50byBzdWItYXJyYXlzIG9yIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gQSBoYXNoIG9mIG9wZXJhdG9yIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlYWN0PXRydWVdIC0gQSBmbGFnIGluZGljYXRpbmcgaWYgdGhpcyBvcGVyYXRvciBzaG91bGRcbiAgICogICBhdXRvbWF0aWNhbGx5IHVwZGF0ZSAocmVhY3QpIHdoZW4gcGFyYW1ldGVyIHZhbHVlcyBjaGFuZ2UuIEluIG90aGVyIHdvcmRzLFxuICAgKiAgIHRoaXMgZmxhZyBkZXRlcm1pbmVzIGlmIHRoZSBvcGVyYXRvciByZWdpc3RlcnMgaXRzZWxmIGFzIGEgbGlzdGVuZXIgb25cbiAgICogICBhbnkgdXBzdHJlYW0gb3BlcmF0b3JzIGluY2x1ZGVkIGluIHRoZSBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0b25seT1mYWxzZV0gLSBBIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIG9wZXJhdG9yXG4gICAqICAgc2hvdWxkIGNhbGN1bGF0ZSBhbiB1cGRhdGUgb25seSB1cG9uIGl0cyBpbml0aWF0YWwgZXZhbHVhdGlvbiwgdGhlblxuICAgKiAgIGRlcmVnaXN0ZXIgZGVwZW5kZW5jaWVzIGFuZCBzdXBwcmVzcyBhbGwgZnV0dXJlIHVwZGF0ZSBpbnZvY2F0aW9ucy5cbiAgICogQHJldHVybiB7T3BlcmF0b3JbXX0gLSBBbiBhcnJheSBvZiB1cHN0cmVhbSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBwYXJhbWV0ZXJzKHBhcmFtcywgcmVhY3QsIGluaXRvbmx5KSB7XG4gICAgcmVhY3QgPSByZWFjdCAhPT0gZmFsc2U7XG4gICAgY29uc3QgYXJndmFsID0gdGhpcy5fYXJndmFsID0gdGhpcy5fYXJndmFsIHx8IG5ldyBQYXJhbWV0ZXJzKCksXG4gICAgICAgICAgYXJnb3BzID0gdGhpcy5fYXJnb3BzID0gdGhpcy5fYXJnb3BzIHx8IFtdLFxuICAgICAgICAgIGRlcHMgPSBbXTtcbiAgICBsZXQgbmFtZSwgdmFsdWUsIG4sIGk7XG5cbiAgICBjb25zdCBhZGQgPSAobmFtZSwgaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPcGVyYXRvcikge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMpIHtcbiAgICAgICAgICBpZiAocmVhY3QpIHZhbHVlLnRhcmdldHMoKS5hZGQodGhpcyk7XG4gICAgICAgICAgZGVwcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ29wcy5wdXNoKHtcbiAgICAgICAgICBvcDogdmFsdWUsXG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmd2YWwuc2V0KG5hbWUsIGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAobmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHZhbHVlID0gcGFyYW1zW25hbWVdO1xuXG4gICAgICBpZiAobmFtZSA9PT0gUFVMU0UpIHtcbiAgICAgICAgYXJyYXkodmFsdWUpLmZvckVhY2gob3AgPT4ge1xuICAgICAgICAgIGlmICghKG9wIGluc3RhbmNlb2YgT3BlcmF0b3IpKSB7XG4gICAgICAgICAgICBlcnJvcignUHVsc2UgcGFyYW1ldGVycyBtdXN0IGJlIG9wZXJhdG9yIGluc3RhbmNlcy4nKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wICE9PSB0aGlzKSB7XG4gICAgICAgICAgICBvcC50YXJnZXRzKCkuYWRkKHRoaXMpO1xuICAgICAgICAgICAgZGVwcy5wdXNoKG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhcmd2YWwuc2V0KG5hbWUsIC0xLCBBcnJheShuID0gdmFsdWUubGVuZ3RoKSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgYWRkKG5hbWUsIGksIHZhbHVlW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZChuYW1lLCAtMSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWFyc2hhbGwoKS5jbGVhcigpOyAvLyBpbml0aWFsaXplIHZhbHVlc1xuXG4gICAgaWYgKGluaXRvbmx5KSBhcmdvcHMuaW5pdG9ubHkgPSB0cnVlO1xuICAgIHJldHVybiBkZXBzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgZm9yIG1hcnNoYWxsaW5nIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqIFZpc2l0cyBlYWNoIG9wZXJhdG9yIGRlcGVuZGVuY3kgdG8gcHVsbCB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJzfSBBIFBhcmFtZXRlcnMgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIHVwZGF0ZSBmdW5jdGlvbi5cbiAgICovXG4gIG1hcnNoYWxsKHN0YW1wKSB7XG4gICAgY29uc3QgYXJndmFsID0gdGhpcy5fYXJndmFsIHx8IE5PX1BBUkFNUyxcbiAgICAgICAgICBhcmdvcHMgPSB0aGlzLl9hcmdvcHM7XG4gICAgbGV0IGl0ZW0sIGksIG9wLCBtb2Q7XG5cbiAgICBpZiAoYXJnb3BzKSB7XG4gICAgICBjb25zdCBuID0gYXJnb3BzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBpdGVtID0gYXJnb3BzW2ldO1xuICAgICAgICBvcCA9IGl0ZW0ub3A7XG4gICAgICAgIG1vZCA9IG9wLm1vZGlmaWVkKCkgJiYgb3Auc3RhbXAgPT09IHN0YW1wO1xuICAgICAgICBhcmd2YWwuc2V0KGl0ZW0ubmFtZSwgaXRlbS5pbmRleCwgb3AudmFsdWUsIG1vZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdvcHMuaW5pdG9ubHkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGl0ZW0gPSBhcmdvcHNbaV07XG4gICAgICAgICAgaXRlbS5vcC50YXJnZXRzKCkucmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXJnb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXBkYXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJndmFsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRhY2ggdGhpcyBvcGVyYXRvciBmcm9tIHRoZSBkYXRhZmxvdy5cbiAgICogVW5yZWdpc3RlcnMgbGlzdGVuZXJzIG9uIHVwc3RyZWFtIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICBjb25zdCBhcmdvcHMgPSB0aGlzLl9hcmdvcHM7XG4gICAgbGV0IGksIG4sIGl0ZW0sIG9wO1xuXG4gICAgaWYgKGFyZ29wcykge1xuICAgICAgZm9yIChpID0gMCwgbiA9IGFyZ29wcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaXRlbSA9IGFyZ29wc1tpXTtcbiAgICAgICAgb3AgPSBpdGVtLm9wO1xuXG4gICAgICAgIGlmIChvcC5fdGFyZ2V0cykge1xuICAgICAgICAgIG9wLl90YXJnZXRzLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gdGhlIHNvdXJjZSBhbmQgcHVsc2Ugb2JqZWN0LFxuICAgIC8vIGlmIHByZXNlbnQsIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIG9mIG9sZCBkYXRhLlxuXG5cbiAgICB0aGlzLnB1bHNlID0gbnVsbDtcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGVnYXRlIG1ldGhvZCB0byBwZXJmb3JtIG9wZXJhdG9yIHByb2Nlc3NpbmcuXG4gICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gY3VzdG9tIHByb2Nlc3NpbmcuXG4gICAqIEJ5IGRlZmF1bHQsIGl0IG1hcnNoYWxscyBwYXJhbWV0ZXJzIGFuZCBjYWxscyB0aGUgdXBkYXRlIGZ1bmN0aW9uXG4gICAqIGlmIHRoYXQgZnVuY3Rpb24gaXMgZGVmaW5lZC4gSWYgdGhlIHVwZGF0ZSBmdW5jdGlvbiBkb2VzIG5vdFxuICAgKiBjaGFuZ2UgdGhlIG9wZXJhdG9yIHZhbHVlIHRoZW4gU3RvcFByb3BhZ2F0aW9uIGlzIHJldHVybmVkLlxuICAgKiBJZiBubyB1cGRhdGUgZnVuY3Rpb24gaXMgZGVmaW5lZCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgKiBAcGFyYW0ge1B1bHNlfSBwdWxzZSAtIHRoZSBjdXJyZW50IGRhdGFmbG93IHB1bHNlLlxuICAgKiBAcmV0dXJuIFRoZSBvdXRwdXQgcHVsc2Ugb3IgU3RvcFByb3BhZ2F0aW9uLiBBIGZhbHN5IHJldHVybiB2YWx1ZVxuICAgKiAgIChpbmNsdWRpbmcgdW5kZWZpbmVkKSB3aWxsIGxldCB0aGUgaW5wdXQgcHVsc2UgcGFzcyB0aHJvdWdoLlxuICAgKi9cbiAgZXZhbHVhdGUocHVsc2UpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLm1hcnNoYWxsKHB1bHNlLnN0YW1wKSxcbiAgICAgICAgICAgIHYgPSB1cGRhdGUuY2FsbCh0aGlzLCBwYXJhbXMsIHB1bHNlKTtcbiAgICAgIHBhcmFtcy5jbGVhcigpO1xuXG4gICAgICBpZiAodiAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdjtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMubW9kaWZpZWQoKSkge1xuICAgICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUnVuIHRoaXMgb3BlcmF0b3IgZm9yIHRoZSBjdXJyZW50IHB1bHNlLiBJZiB0aGlzIG9wZXJhdG9yIGhhcyBhbHJlYWR5XG4gICAqIGJlZW4gcnVuIGF0IChvciBhZnRlcikgdGhlIHB1bHNlIHRpbWVzdGFtcCwgcmV0dXJucyBTdG9wUHJvcGFnYXRpb24uXG4gICAqIEludGVybmFsbHksIHRoaXMgbWV0aG9kIGNhbGxzIHtAbGluayBldmFsdWF0ZX0gdG8gcGVyZm9ybSBwcm9jZXNzaW5nLlxuICAgKiBJZiB7QGxpbmsgZXZhbHVhdGV9IHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgdGhlIGlucHV0IHB1bHNlIGlzIHJldHVybmVkLlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgTk9UIGJlIG92ZXJyaWRkZW4sIGluc3RlYWQgb3ZlcnJyaWRlIHtAbGluayBldmFsdWF0ZX0uXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gdGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4gdGhlIG91dHB1dCBwdWxzZSBmb3IgdGhpcyBvcGVyYXRvciAob3IgU3RvcFByb3BhZ2F0aW9uKVxuICAgKi9cbiAgcnVuKHB1bHNlKSB7XG4gICAgaWYgKHB1bHNlLnN0YW1wIDwgdGhpcy5zdGFtcCkgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICBsZXQgcnY7XG5cbiAgICBpZiAodGhpcy5za2lwKCkpIHtcbiAgICAgIHRoaXMuc2tpcChmYWxzZSk7XG4gICAgICBydiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2ID0gdGhpcy5ldmFsdWF0ZShwdWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHVsc2UgPSBydiB8fCBwdWxzZTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEFkZCBhbiBvcGVyYXRvciB0byB0aGUgZGF0YWZsb3cgZ3JhcGguIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhXG4gKiB2YXJpZXR5IG9mIGlucHV0IGFyZ3VtZW50IHR5cGVzLiBUaGUgYmFzaWMgc2lnbmF0dXJlIHN1cHBvcnRzIGFuXG4gKiBpbml0aWFsIHZhbHVlLCB1cGRhdGUgZnVuY3Rpb24gYW5kIHBhcmFtZXRlcnMuIElmIHRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAqIGlzIGFuIE9wZXJhdG9yIGluc3RhbmNlLCBpdCB3aWxsIGJlIGFkZGVkIGRpcmVjdGx5LiBJZiBpdCBpcyBhXG4gKiBjb25zdHJ1Y3RvciBmb3IgYW4gT3BlcmF0b3Igc3ViY2xhc3MsIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgaW5zdGFudGlhdGVkLlxuICogT3RoZXJ3aXNlLCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gaW5zdGFuY2UsIGl0IHdpbGwgYmUgdXNlZFxuICogYXMgdGhlIHVwZGF0ZSBmdW5jdGlvbiBhbmQgYSBudWxsIGluaXRpYWwgdmFsdWUgaXMgYXNzdW1lZC5cbiAqIEBwYXJhbSB7Kn0gaW5pdCAtIE9uZSBvZjogdGhlIG9wZXJhdG9yIHRvIGFkZCwgdGhlIGluaXRpYWwgdmFsdWUgb2ZcbiAqICAgdGhlIG9wZXJhdG9yLCBhbiBvcGVyYXRvciBjbGFzcyB0byBpbnN0YW50aWF0ZSwgb3IgYW4gdXBkYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3VwZGF0ZV0gLSBUaGUgb3BlcmF0b3IgdXBkYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIC0gVGhlIG9wZXJhdG9yIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWFjdD10cnVlXSAtIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIG9wZXJhdG9yIHNob3VsZFxuICogICBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdXBzdHJlYW0gb3BlcmF0b3JzIGluY2x1ZGVkIGFzIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJuIHtPcGVyYXRvcn0gLSBUaGUgYWRkZWQgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gYWRkIChpbml0LCB1cGRhdGUsIHBhcmFtcywgcmVhY3QpIHtcbiAgbGV0IHNoaWZ0ID0gMSxcbiAgICAgIG9wO1xuXG4gIGlmIChpbml0IGluc3RhbmNlb2YgT3BlcmF0b3IpIHtcbiAgICBvcCA9IGluaXQ7XG4gIH0gZWxzZSBpZiAoaW5pdCAmJiBpbml0LnByb3RvdHlwZSBpbnN0YW5jZW9mIE9wZXJhdG9yKSB7XG4gICAgb3AgPSBuZXcgaW5pdCgpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oaW5pdCkpIHtcbiAgICBvcCA9IG5ldyBPcGVyYXRvcihudWxsLCBpbml0KTtcbiAgfSBlbHNlIHtcbiAgICBzaGlmdCA9IDA7XG4gICAgb3AgPSBuZXcgT3BlcmF0b3IoaW5pdCwgdXBkYXRlKTtcbiAgfVxuXG4gIHRoaXMucmFuayhvcCk7XG5cbiAgaWYgKHNoaWZ0KSB7XG4gICAgcmVhY3QgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0gdXBkYXRlO1xuICB9XG5cbiAgaWYgKHBhcmFtcykgdGhpcy5jb25uZWN0KG9wLCBvcC5wYXJhbWV0ZXJzKHBhcmFtcywgcmVhY3QpKTtcbiAgdGhpcy50b3VjaChvcCk7XG4gIHJldHVybiBvcDtcbn1cblxuLyoqXG4gKiBDb25uZWN0IGEgdGFyZ2V0IG9wZXJhdG9yIGFzIGEgZGVwZW5kZW50IG9mIHNvdXJjZSBvcGVyYXRvcnMuXG4gKiBJZiBuZWNlc3NhcnksIHRoaXMgbWV0aG9kIHdpbGwgcmVyYW5rIHRoZSB0YXJnZXQgb3BlcmF0b3IgYW5kIGl0c1xuICogZGVwZW5kZW50cyB0byBlbnN1cmUgcHJvcGFnYXRpb24gcHJvY2VlZHMgaW4gYSB0b3BvbG9naWNhbGx5IHNvcnRlZCBvcmRlci5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IHRhcmdldCAtIFRoZSB0YXJnZXQgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PE9wZXJhdG9yPn0gLSBUaGUgc291cmNlIG9wZXJhdG9ycyB0aGF0IHNob3VsZCBwcm9wYWdhdGVcbiAqICAgdG8gdGhlIHRhcmdldCBvcGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gY29ubmVjdCAodGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGNvbnN0IHRhcmdldFJhbmsgPSB0YXJnZXQucmFuayxcbiAgICAgICAgbiA9IHNvdXJjZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHRhcmdldFJhbmsgPCBzb3VyY2VzW2ldLnJhbmspIHtcbiAgICAgIHRoaXMucmVyYW5rKHRhcmdldCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmxldCBTVFJFQU1fSUQgPSAwO1xuLyoqXG4gKiBNb2RlbHMgYW4gZXZlbnQgc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCwgbnVtYmVyKTogYm9vbGVhbn0gW2ZpbHRlcl0gLSBGaWx0ZXIgcHJlZGljYXRlLlxuICogICBFdmVudHMgcGFzcyB0aHJvdWdoIHdoZW4gdHJ1dGh5LCBldmVudHMgYXJlIHN1cHByZXNzZWQgd2hlbiBmYWxzeS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KTogKn0gW2FwcGx5XSAtIEFwcGxpZWQgdG8gaW5wdXQgZXZlbnRzIHRvIHByb2R1Y2VcbiAqICAgbmV3IGV2ZW50IHZhbHVlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KX0gW3JlY2VpdmVdIC0gRXZlbnQgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIHVwb24gcmVjZWlwdCBvZiBhIG5ldyBldmVudC4gVXNlIHRvIG92ZXJyaWRlIHN0YW5kYXJkIGV2ZW50IHByb2Nlc3NpbmcuXG4gKi9cblxuZnVuY3Rpb24gRXZlbnRTdHJlYW0oZmlsdGVyLCBhcHBseSwgcmVjZWl2ZSkge1xuICB0aGlzLmlkID0gKytTVFJFQU1fSUQ7XG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICBpZiAocmVjZWl2ZSkgdGhpcy5yZWNlaXZlID0gcmVjZWl2ZTtcbiAgaWYgKGZpbHRlcikgdGhpcy5fZmlsdGVyID0gZmlsdGVyO1xuICBpZiAoYXBwbHkpIHRoaXMuX2FwcGx5ID0gYXBwbHk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZXZlbnQgc3RyZWFtIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkXG4gKiAob3B0aW9uYWwpIGZpbHRlciwgYXBwbHkgYW5kIHJlY2VpdmUgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsIG51bWJlcik6IGJvb2xlYW59IFtmaWx0ZXJdIC0gRmlsdGVyIHByZWRpY2F0ZS5cbiAqICAgRXZlbnRzIHBhc3MgdGhyb3VnaCB3aGVuIHRydXRoeSwgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHdoZW4gZmFsc3kuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6ICp9IFthcHBseV0gLSBBcHBsaWVkIHRvIGlucHV0IGV2ZW50cyB0byBwcm9kdWNlXG4gKiAgIG5ldyBldmVudCB2YWx1ZXMuXG4gKiBAc2VlIEV2ZW50U3RyZWFtXG4gKi9cblxuZnVuY3Rpb24gc3RyZWFtKGZpbHRlciwgYXBwbHksIHJlY2VpdmUpIHtcbiAgcmV0dXJuIG5ldyBFdmVudFN0cmVhbShmaWx0ZXIsIGFwcGx5LCByZWNlaXZlKTtcbn1cbkV2ZW50U3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgX2ZpbHRlcjogdHJ1dGh5LFxuICBfYXBwbHk6IGlkZW50aXR5LFxuXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldHMgfHwgKHRoaXMuX3RhcmdldHMgPSBVbmlxdWVMaXN0KGlkKSk7XG4gIH0sXG5cbiAgY29uc3VtZShfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gISF0aGlzLl9jb25zdW1lO1xuICAgIHRoaXMuX2NvbnN1bWUgPSAhIV87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVjZWl2ZShldnQpIHtcbiAgICBpZiAodGhpcy5fZmlsdGVyKGV2dCkpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMudmFsdWUgPSB0aGlzLl9hcHBseShldnQpLFxuICAgICAgICAgICAgdHJnID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAgICAgIG4gPSB0cmcgPyB0cmcubGVuZ3RoIDogMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRyZ1tpXS5yZWNlaXZlKHZhbCk7XG5cbiAgICAgIGlmICh0aGlzLl9jb25zdW1lKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGZpbHRlcihmaWx0ZXIpIHtcbiAgICBjb25zdCBzID0gc3RyZWFtKGZpbHRlcik7XG4gICAgdGhpcy50YXJnZXRzKCkuYWRkKHMpO1xuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIGFwcGx5KGFwcGx5KSB7XG4gICAgY29uc3QgcyA9IHN0cmVhbShudWxsLCBhcHBseSk7XG4gICAgdGhpcy50YXJnZXRzKCkuYWRkKHMpO1xuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIG1lcmdlKCkge1xuICAgIGNvbnN0IHMgPSBzdHJlYW0oKTtcbiAgICB0aGlzLnRhcmdldHMoKS5hZGQocyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGFyZ3VtZW50c1tpXS50YXJnZXRzKCkuYWRkKHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIHRocm90dGxlKHBhdXNlKSB7XG4gICAgbGV0IHQgPSAtMTtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgaWYgKG5vdyAtIHQgPiBwYXVzZSkge1xuICAgICAgICB0ID0gbm93O1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGRlYm91bmNlKGRlbGF5KSB7XG4gICAgY29uc3QgcyA9IHN0cmVhbSgpO1xuICAgIHRoaXMudGFyZ2V0cygpLmFkZChzdHJlYW0obnVsbCwgbnVsbCwgZGVib3VuY2UoZGVsYXksIGUgPT4ge1xuICAgICAgY29uc3QgZGYgPSBlLmRhdGFmbG93O1xuICAgICAgcy5yZWNlaXZlKGUpO1xuICAgICAgaWYgKGRmICYmIGRmLnJ1bikgZGYucnVuKCk7XG4gICAgfSkpKTtcbiAgICByZXR1cm4gcztcbiAgfSxcblxuICBiZXR3ZWVuKGEsIGIpIHtcbiAgICBsZXQgYWN0aXZlID0gZmFsc2U7XG4gICAgYS50YXJnZXRzKCkuYWRkKHN0cmVhbShudWxsLCBudWxsLCAoKSA9PiBhY3RpdmUgPSB0cnVlKSk7XG4gICAgYi50YXJnZXRzKCkuYWRkKHN0cmVhbShudWxsLCBudWxsLCAoKSA9PiBhY3RpdmUgPSBmYWxzZSkpO1xuICAgIHJldHVybiB0aGlzLmZpbHRlcigoKSA9PiBhY3RpdmUpO1xuICB9LFxuXG4gIGRldGFjaCgpIHtcbiAgICAvLyBlbnN1cmVzIGNvbXBhdGliaWxpdHkgd2l0aCBvcGVyYXRvcnMgKCMyNzUzKVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIG90aGVyIHN0cmVhbXMgYW5kIGZpbHRlciBmdW5jdGlvbnMgdGhhdCBtYXlcbiAgICAvLyBiZSBib3VuZCB0byBzdWJjb250ZXh0cyB0aGF0IG5lZWQgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgdGhpcy5fZmlsdGVyID0gdHJ1dGh5O1xuICAgIHRoaXMuX3RhcmdldHMgPSBudWxsO1xuICB9XG5cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV2ZW50IHN0cmVhbSBmcm9tIGFuIGV2ZW50IHNvdXJjZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBUaGUgZXZlbnQgc291cmNlIHRvIG1vbml0b3IuIFRoZSBpbnB1dCBtdXN0XG4gKiAgc3VwcG9ydCB0aGUgYWRkRXZlbnRMaXN0ZW5lciBtZXRob2QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBib29sZWFufSBbZmlsdGVyXSAtIEV2ZW50IGZpbHRlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gW2FwcGx5XSAtIEV2ZW50IGFwcGxpY2F0aW9uIGZ1bmN0aW9uLlxuICogICBJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYW5kIHRoZSByZXN1bHQgd2lsbCBiZVxuICogICB1c2VkIGFzIHRoZSBkb3duc3RyZWFtIGV2ZW50IHZhbHVlLlxuICogQHJldHVybiB7RXZlbnRTdHJlYW19XG4gKi9cblxuZnVuY3Rpb24gZXZlbnRzIChzb3VyY2UsIHR5cGUsIGZpbHRlciwgYXBwbHkpIHtcbiAgY29uc3QgZGYgPSB0aGlzLFxuICAgICAgICBzID0gc3RyZWFtKGZpbHRlciwgYXBwbHkpLFxuICAgICAgICBzZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLmRhdGFmbG93ID0gZGY7XG5cbiAgICB0cnkge1xuICAgICAgcy5yZWNlaXZlKGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZi5lcnJvcihlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRmLnJ1bigpO1xuICAgIH1cbiAgfTtcblxuICBsZXQgc291cmNlcztcblxuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNvdXJjZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNvdXJjZSk7XG4gIH0gZWxzZSB7XG4gICAgc291cmNlcyA9IGFycmF5KHNvdXJjZSk7XG4gIH1cblxuICBjb25zdCBuID0gc291cmNlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzb3VyY2VzW2ldLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc2VuZCk7XG4gIH1cblxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gcGFyc2UoZGF0YSwgZm9ybWF0KSB7XG4gIGNvbnN0IGxvY2FsZSA9IHRoaXMubG9jYWxlKCk7XG4gIHJldHVybiByZWFkKGRhdGEsIGZvcm1hdCwgbG9jYWxlLnRpbWVQYXJzZSwgbG9jYWxlLnV0Y1BhcnNlKTtcbn1cbi8qKlxuICogSW5nZXN0cyBuZXcgZGF0YSBpbnRvIHRoZSBkYXRhZmxvdy4gRmlyc3QgcGFyc2VzIHRoZSBkYXRhIHVzaW5nIHRoZVxuICogdmVnYS1sb2FkZXIgcmVhZCBtZXRob2QsIHRoZW4gcHVsc2VzIGEgY2hhbmdlc2V0IHRvIHRoZSB0YXJnZXQgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSB0YXJnZXQgLSBUaGUgT3BlcmF0b3IgdG8gdGFyZ2V0IHdpdGggaW5nZXN0ZWQgZGF0YSxcbiAqICAgdHlwaWNhbGx5IGEgQ29sbGVjdCB0cmFuc2Zvcm0gaW5zdGFuY2UuXG4gKiBAcGFyYW0geyp9IGRhdGEgLSBUaGUgaW5wdXQgZGF0YSwgcHJpb3IgdG8gcGFyc2luZy4gRm9yIEpTT04gdGhpcyBtYXlcbiAqICAgYmUgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LiBGb3IgQ1NWLCBUU1YsIGV0YyBzaG91bGQgYmUgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gZm9ybWF0IC0gVGhlIGRhdGEgZm9ybWF0IGRlc2NyaXB0aW9uIGZvciBwYXJzaW5nXG4gKiAgIGxvYWRlZCBkYXRhLiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gdGhlIHZlZ2EtbG9hZGVyIHJlYWQgbWV0aG9kLlxuICogQHJldHVybnMge0RhdGFmbG93fVxuICovXG5cbmZ1bmN0aW9uIGluZ2VzdCh0YXJnZXQsIGRhdGEsIGZvcm1hdCkge1xuICBkYXRhID0gdGhpcy5wYXJzZShkYXRhLCBmb3JtYXQpO1xuICByZXR1cm4gdGhpcy5wdWxzZSh0YXJnZXQsIHRoaXMuY2hhbmdlc2V0KCkuaW5zZXJ0KGRhdGEpKTtcbn1cbi8qKlxuICogUmVxdWVzdCBkYXRhIGZyb20gYW4gZXh0ZXJuYWwgc291cmNlLCBwYXJzZSBpdCwgYW5kIHJldHVybiBhIFByb21pc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBmcm9tIHdoaWNoIHRvIGxvYWQgdGhlIGRhdGEuIFRoaXMgc3RyaW5nXG4gKiAgIGlzIHBhc3NlZCB0byB0aGUgdmVnYS1sb2FkZXIgbG9hZCBtZXRob2QuXG4gKiBAcGFyYW0ge29iamVjdH0gW2Zvcm1hdF0gLSBUaGUgZGF0YSBmb3JtYXQgZGVzY3JpcHRpb24gZm9yIHBhcnNpbmdcbiAqICAgbG9hZGVkIGRhdGEuIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byB0aGUgdmVnYS1sb2FkZXIgcmVhZCBtZXRob2QuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB1cG9uIGNvbXBsZXRpb24gb2YgdGhlIHJlcXVlc3QuXG4gKiAgIFRoZSByZXNvbHZlZCBvYmplY3QgY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogICAtIGRhdGE6IGFuIGFycmF5IG9mIHBhcnNlZCBkYXRhIChvciBudWxsIHVwb24gZXJyb3IpXG4gKiAgIC0gc3RhdHVzOiBhIGNvZGUgZm9yIHN1Y2Nlc3MgKDApLCBsb2FkIGZhaWwgKC0xKSwgb3IgcGFyc2UgZmFpbCAoLTIpXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIGZvcm1hdCkge1xuICBjb25zdCBkZiA9IHRoaXM7XG4gIGxldCBzdGF0dXMgPSAwLFxuICAgICAgZGF0YTtcblxuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCBkZi5sb2FkZXIoKS5sb2FkKHVybCwge1xuICAgICAgY29udGV4dDogJ2RhdGFmbG93JyxcbiAgICAgIHJlc3BvbnNlOiByZXNwb25zZVR5cGUoZm9ybWF0ICYmIGZvcm1hdC50eXBlKVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBkZi5wYXJzZShkYXRhLCBmb3JtYXQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc3RhdHVzID0gLTI7XG4gICAgICBkZi53YXJuKCdEYXRhIGluZ2VzdGlvbiBmYWlsZWQnLCB1cmwsIGVycik7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzdGF0dXMgPSAtMTtcbiAgICBkZi53YXJuKCdMb2FkaW5nIGZhaWxlZCcsIHVybCwgZXJyKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBzdGF0dXNcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWxvYWQodGFyZ2V0LCB1cmwsIGZvcm1hdCkge1xuICBjb25zdCBkZiA9IHRoaXMsXG4gICAgICAgIHBlbmRpbmcgPSBkZi5fcGVuZGluZyB8fCBsb2FkUGVuZGluZyhkZik7XG4gIHBlbmRpbmcucmVxdWVzdHMgKz0gMTtcbiAgY29uc3QgcmVzID0gYXdhaXQgZGYucmVxdWVzdCh1cmwsIGZvcm1hdCk7XG4gIGRmLnB1bHNlKHRhcmdldCwgZGYuY2hhbmdlc2V0KCkucmVtb3ZlKHRydXRoeSkuaW5zZXJ0KHJlcy5kYXRhIHx8IFtdKSk7XG4gIHBlbmRpbmcuZG9uZSgpO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBsb2FkUGVuZGluZyhkZikge1xuICBsZXQgYWNjZXB0O1xuICBjb25zdCBwZW5kaW5nID0gbmV3IFByb21pc2UoYSA9PiBhY2NlcHQgPSBhKTtcbiAgcGVuZGluZy5yZXF1ZXN0cyA9IDA7XG5cbiAgcGVuZGluZy5kb25lID0gKCkgPT4ge1xuICAgIGlmICgtLXBlbmRpbmcucmVxdWVzdHMgPT09IDApIHtcbiAgICAgIGRmLl9wZW5kaW5nID0gbnVsbDtcbiAgICAgIGFjY2VwdChkZik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkZi5fcGVuZGluZyA9IHBlbmRpbmc7XG59XG5cbmNvbnN0IFNLSVAgPSB7XG4gIHNraXA6IHRydWVcbn07XG4vKipcbiAqIFBlcmZvcm0gb3BlcmF0b3IgdXBkYXRlcyBpbiByZXNwb25zZSB0byBldmVudHMuIEFwcGxpZXMgYW5cbiAqIHVwZGF0ZSBmdW5jdGlvbiB0byBjb21wdXRlIGEgbmV3IG9wZXJhdG9yIHZhbHVlLiBJZiB0aGUgdXBkYXRlIGZ1bmN0aW9uXG4gKiByZXR1cm5zIGEge0BsaW5rIENoYW5nZVNldH0sIHRoZSBvcGVyYXRvciB3aWxsIGJlIHB1bHNlZCB3aXRoIHRob3NlIHR1cGxlXG4gKiBjaGFuZ2VzLiBPdGhlcndpc2UsIHRoZSBvcGVyYXRvciB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQgdG8gdGhlIHJldHVybiB2YWx1ZS5cbiAqIEBwYXJhbSB7RXZlbnRTdHJlYW18T3BlcmF0b3J9IHNvdXJjZSAtIFRoZSBldmVudCBzb3VyY2UgdG8gcmVhY3QgdG8uXG4gKiAgIFRoaXMgYXJndW1lbnQgY2FuIGJlIGVpdGhlciBhbiBFdmVudFN0cmVhbSBvciBhbiBPcGVyYXRvci5cbiAqIEBwYXJhbSB7T3BlcmF0b3J8ZnVuY3Rpb24ob2JqZWN0KTpPcGVyYXRvcn0gdGFyZ2V0IC0gVGhlIG9wZXJhdG9yIHRvIHVwZGF0ZS5cbiAqICAgVGhpcyBhcmd1bWVudCBjYW4gZWl0aGVyIGJlIGFuIE9wZXJhdG9yIGluc3RhbmNlIG9yIChpZiB0aGUgc291cmNlXG4gKiAgIGFyZ3VtZW50IGlzIGFuIEV2ZW50U3RyZWFtKSwgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYW4gZXZlbnQgb2JqZWN0IGFzXG4gKiAgIGlucHV0IGFuZCByZXR1cm5zIGFuIE9wZXJhdG9yIHRvIHRhcmdldC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUGFyYW1ldGVycyxFdmVudCk6ICp9IFt1cGRhdGVdIC0gT3B0aW9uYWwgdXBkYXRlIGZ1bmN0aW9uXG4gKiAgIHRvIGNvbXB1dGUgdGhlIG5ldyBvcGVyYXRvciB2YWx1ZSwgb3IgYSBsaXRlcmFsIHZhbHVlIHRvIHNldC4gVXBkYXRlXG4gKiAgIGZ1bmN0aW9ucyBleHBlY3QgdG8gcmVjZWl2ZSBhIHBhcmFtZXRlciBvYmplY3QgYW5kIGV2ZW50IGFzIGFyZ3VtZW50cy5cbiAqICAgVGhpcyBmdW5jdGlvbiBjYW4gZWl0aGVyIHJldHVybiBhIG5ldyBvcGVyYXRvciB2YWx1ZSBvciAoaWYgdGhlIHNvdXJjZVxuICogICBhcmd1bWVudCBpcyBhbiBFdmVudFN0cmVhbSkgYSB7QGxpbmsgQ2hhbmdlU2V0fSBpbnN0YW5jZSB0byBwdWxzZVxuICogICB0aGUgdGFyZ2V0IG9wZXJhdG9yIHdpdGggdHVwbGUgY2hhbmdlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSB1cGRhdGUgZnVuY3Rpb24gcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgaGFzaC4gSWYgbm90IG92ZXJyaWRkZW4sXG4gKiAgIHVwZGF0ZWQgb3BlcmF0b3JzIHdpbGwgYmUgc2tpcHBlZCBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgYmUgc2tpcHBlZDogaXQgd2lsbCBub3QgYmUgZXZhbHVhdGVkLCBidXQgaXRzIGRlcGVuZGVudHMgd2lsbCBiZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yY2VdIC0gSWYgdHJ1ZSwgdGhlIG9wZXJhdG9yIHdpbGxcbiAqICAgYmUgcmUtZXZhbHVhdGVkIGV2ZW4gaWYgaXRzIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cbiAqIEByZXR1cm4ge0RhdGFmbG93fVxuICovXG5cbmZ1bmN0aW9uIG9uIChzb3VyY2UsIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgZm4gPSBzb3VyY2UgaW5zdGFuY2VvZiBPcGVyYXRvciA/IG9uT3BlcmF0b3IgOiBvblN0cmVhbTtcbiAgZm4odGhpcywgc291cmNlLCB0YXJnZXQsIHVwZGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG9uU3RyZWFtKGRmLCBzdHJlYW0sIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0ID0gZXh0ZW5kKHt9LCBvcHRpb25zLCBTS0lQKTtcbiAgbGV0IGZ1bmMsIG9wO1xuICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkgdGFyZ2V0ID0gY29uc3RhbnQodGFyZ2V0KTtcblxuICBpZiAodXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBmdW5jID0gZSA9PiBkZi50b3VjaCh0YXJnZXQoZSkpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odXBkYXRlKSkge1xuICAgIG9wID0gbmV3IE9wZXJhdG9yKG51bGwsIHVwZGF0ZSwgcGFyYW1zLCBmYWxzZSk7XG5cbiAgICBmdW5jID0gZSA9PiB7XG4gICAgICBvcC5ldmFsdWF0ZShlKTtcbiAgICAgIGNvbnN0IHQgPSB0YXJnZXQoZSksXG4gICAgICAgICAgICB2ID0gb3AudmFsdWU7XG4gICAgICBpc0NoYW5nZVNldCh2KSA/IGRmLnB1bHNlKHQsIHYsIG9wdGlvbnMpIDogZGYudXBkYXRlKHQsIHYsIG9wdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmdW5jID0gZSA9PiBkZi51cGRhdGUodGFyZ2V0KGUpLCB1cGRhdGUsIG9wdCk7XG4gIH1cblxuICBzdHJlYW0uYXBwbHkoZnVuYyk7XG59XG5cbmZ1bmN0aW9uIG9uT3BlcmF0b3IoZGYsIHNvdXJjZSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICBpZiAodXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2UudGFyZ2V0cygpLmFkZCh0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgICAgb3AgPSBuZXcgT3BlcmF0b3IobnVsbCwgdXBkYXRlcih0YXJnZXQsIHVwZGF0ZSksIHBhcmFtcywgZmFsc2UpO1xuICAgIG9wLm1vZGlmaWVkKG9wdC5mb3JjZSk7XG4gICAgb3AucmFuayA9IHNvdXJjZS5yYW5rOyAvLyBpbW1lZGlhdGVseSBmb2xsb3cgc291cmNlXG5cbiAgICBzb3VyY2UudGFyZ2V0cygpLmFkZChvcCk7IC8vIGFkZCBkZXBlbmRlbmN5XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBvcC5za2lwKHRydWUpOyAvLyBza2lwIGZpcnN0IGludm9jYXRpb25cblxuICAgICAgb3AudmFsdWUgPSB0YXJnZXQudmFsdWU7IC8vIGluaXRpYWxpemUgdmFsdWVcblxuICAgICAgb3AudGFyZ2V0cygpLmFkZCh0YXJnZXQpOyAvLyBjaGFpbiBkZXBlbmRlbmNpZXNcblxuICAgICAgZGYuY29ubmVjdCh0YXJnZXQsIFtvcF0pOyAvLyByZXJhbmsgYXMgbmVlZGVkLCAjMTY3MlxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVyKHRhcmdldCwgdXBkYXRlKSB7XG4gIHVwZGF0ZSA9IGlzRnVuY3Rpb24odXBkYXRlKSA/IHVwZGF0ZSA6IGNvbnN0YW50KHVwZGF0ZSk7XG4gIHJldHVybiB0YXJnZXQgPyBmdW5jdGlvbiAoXywgcHVsc2UpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHVwZGF0ZShfLCBwdWxzZSk7XG5cbiAgICBpZiAoIXRhcmdldC5za2lwKCkpIHtcbiAgICAgIHRhcmdldC5za2lwKHZhbHVlICE9PSB0aGlzLnZhbHVlKS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSA6IHVwZGF0ZTtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIGEgcmFuayB0byBhbiBvcGVyYXRvci4gUmFua3MgYXJlIGFzc2lnbmVkIGluIGluY3JlYXNpbmcgb3JkZXJcbiAqIGJ5IGluY3JlbWVudGluZyBhbiBpbnRlcm5hbCByYW5rIGNvdW50ZXIuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSBvcCAtIFRoZSBvcGVyYXRvciB0byBhc3NpZ24gYSByYW5rLlxuICovXG5cbmZ1bmN0aW9uIHJhbmsob3ApIHtcbiAgb3AucmFuayA9ICsrdGhpcy5fcmFuaztcbn1cbi8qKlxuICogUmUtcmFua3MgYW4gb3BlcmF0b3IgYW5kIGFsbCBkb3duc3RyZWFtIHRhcmdldCBkZXBlbmRlbmNpZXMuIFRoaXNcbiAqIGlzIG5lY2Vzc2FyeSB3aGVuIHVwc3RyZWFtIGRlcGVuZGVuY2llcyBvZiBoaWdoZXIgcmFuayBhcmUgYWRkZWQgdG9cbiAqIGEgdGFyZ2V0IG9wZXJhdG9yLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gcmUtcmFuay5cbiAqL1xuXG5mdW5jdGlvbiByZXJhbmsob3ApIHtcbiAgY29uc3QgcXVldWUgPSBbb3BdO1xuICBsZXQgY3VyLCBsaXN0LCBpO1xuXG4gIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICB0aGlzLnJhbmsoY3VyID0gcXVldWUucG9wKCkpO1xuXG4gICAgaWYgKGxpc3QgPSBjdXIuX3RhcmdldHMpIHtcbiAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgcXVldWUucHVzaChjdXIgPSBsaXN0W2ldKTtcbiAgICAgICAgaWYgKGN1ciA9PT0gb3ApIGVycm9yKCdDeWNsZSBkZXRlY3RlZCBpbiBkYXRhZmxvdyBncmFwaC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZW50aW5lbCB2YWx1ZSBpbmRpY2F0aW5nIHB1bHNlIHByb3BhZ2F0aW9uIHNob3VsZCBzdG9wLlxuICovXG5cbmNvbnN0IFN0b3BQcm9wYWdhdGlvbiA9IHt9OyAvLyBQdWxzZSB2aXNpdCB0eXBlIGZsYWdzXG5cbmNvbnN0IEFERCA9IDEgPDwgMCxcbiAgICAgIFJFTSA9IDEgPDwgMSxcbiAgICAgIE1PRCA9IDEgPDwgMixcbiAgICAgIEFERF9SRU0gPSBBREQgfCBSRU0sXG4gICAgICBBRERfTU9EID0gQUREIHwgTU9ELFxuICAgICAgQUxMID0gQUREIHwgUkVNIHwgTU9ELFxuICAgICAgUkVGTE9XID0gMSA8PCAzLFxuICAgICAgU09VUkNFID0gMSA8PCA0LFxuICAgICAgTk9fU09VUkNFID0gMSA8PCA1LFxuICAgICAgTk9fRklFTERTID0gMSA8PCA2O1xuLyoqXG4gKiBBIFB1bHNlIGVuYWJsZXMgaW50ZXItb3BlcmF0b3IgY29tbXVuaWNhdGlvbiBkdXJpbmcgYSBydW4gb2YgdGhlXG4gKiBkYXRhZmxvdyBncmFwaC4gSW4gYWRkaXRpb24gdG8gdGhlIGN1cnJlbnQgdGltZXN0YW1wLCBhIHB1bHNlIG1heSBhbHNvXG4gKiBjb250YWluIGEgY2hhbmdlLXNldCBvZiBhZGRlZCwgcmVtb3ZlZCBvciBtb2RpZmllZCBkYXRhIHR1cGxlcywgYXMgd2VsbCBhc1xuICogYSBwb2ludGVyIHRvIGEgZnVsbCBiYWNraW5nIGRhdGEgc291cmNlLiBUdXBsZSBjaGFuZ2Ugc2V0cyBtYXkgbm90XG4gKiBiZSBmdWxseSBtYXRlcmlhbGl6ZWQ7IGZvciBleGFtcGxlLCB0byBwcmV2ZW50IG5lZWRsZXNzIGFycmF5IGNyZWF0aW9uXG4gKiBhIGNoYW5nZSBzZXQgbWF5IGluY2x1ZGUgbGFyZ2VyIGFycmF5cyBhbmQgY29ycmVzcG9uZGluZyBmaWx0ZXIgZnVuY3Rpb25zLlxuICogVGhlIHB1bHNlIHByb3ZpZGVzIGEge0BsaW5rIHZpc2l0fSBtZXRob2QgdG8gZW5hYmxlIHByb3BlciBhbmQgZWZmaWNpZW50XG4gKiBpdGVyYXRpb24gb3ZlciByZXF1ZXN0ZWQgZGF0YSB0dXBsZXMuXG4gKlxuICogSW4gYWRkaXRpb24sIGVhY2ggcHVsc2UgY2FuIHRyYWNrIG1vZGlmaWNhdGlvbiBmbGFncyBmb3IgZGF0YSB0dXBsZSBmaWVsZHMuXG4gKiBSZXNwb25zaWJsZSB0cmFuc2Zvcm0gb3BlcmF0b3JzIHNob3VsZCBjYWxsIHRoZSB7QGxpbmsgbW9kaWZpZXN9IG1ldGhvZCB0b1xuICogaW5kaWNhdGUgY2hhbmdlcyB0byBkYXRhIGZpZWxkcy4gVGhlIHtAbGluayBtb2RpZmllZH0gbWV0aG9kIGVuYWJsZXNcbiAqIHF1ZXJ5aW5nIG9mIHRoaXMgbW9kaWZpY2F0aW9uIHN0YXRlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtEYXRhZmxvd30gZGF0YWZsb3cgLSBUaGUgYmFja2luZyBkYXRhZmxvdyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFtcCAtIFRoZSBjdXJyZW50IHByb3BhZ2F0aW9uIHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RlXSAtIEFuIG9wdGlvbmFsIGVuY29kaW5nIHNldCBuYW1lLCB3aGljaCBpcyB0aGVuXG4gKiAgIGFjY2Vzc2libGUgYXMgUHVsc2UuZW5jb2RlLiBPcGVyYXRvcnMgY2FuIHJlc3BvbmQgdG8gKG9yIGlnbm9yZSkgdGhpc1xuICogICBzZXR0aW5nIGFzIGFwcHJvcHJpYXRlLiBUaGlzIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoXG4gKiAgIHRoZSBFbmNvZGUgdHJhbnNmb3JtIGluIHRoZSB2ZWdhLWVuY29kZSBtb2R1bGUuXG4gKi9cblxuZnVuY3Rpb24gUHVsc2UoZGF0YWZsb3csIHN0YW1wLCBlbmNvZGUpIHtcbiAgdGhpcy5kYXRhZmxvdyA9IGRhdGFmbG93O1xuICB0aGlzLnN0YW1wID0gc3RhbXAgPT0gbnVsbCA/IC0xIDogc3RhbXA7XG4gIHRoaXMuYWRkID0gW107XG4gIHRoaXMucmVtID0gW107XG4gIHRoaXMubW9kID0gW107XG4gIHRoaXMuZmllbGRzID0gbnVsbDtcbiAgdGhpcy5lbmNvZGUgPSBlbmNvZGUgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoZGF0YSwgZmlsdGVyKSB7XG4gIGNvbnN0IG91dCA9IFtdO1xuICB2aXNpdEFycmF5KGRhdGEsIGZpbHRlciwgXyA9PiBvdXQucHVzaChfKSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGZpbHRlcihwdWxzZSwgZmxhZ3MpIHtcbiAgY29uc3QgbWFwID0ge307XG4gIHB1bHNlLnZpc2l0KGZsYWdzLCB0ID0+IHtcbiAgICBtYXBbdHVwbGVpZCh0KV0gPSAxO1xuICB9KTtcbiAgcmV0dXJuIHQgPT4gbWFwW3R1cGxlaWQodCldID8gbnVsbCA6IHQ7XG59XG5cbmZ1bmN0aW9uIGFkZEZpbHRlcihhLCBiKSB7XG4gIHJldHVybiBhID8gKHQsIGkpID0+IGEodCwgaSkgJiYgYih0LCBpKSA6IGI7XG59XG5cblB1bHNlLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFNlbnRpbmVsIHZhbHVlIGluZGljYXRpbmcgcHVsc2UgcHJvcGFnYXRpb24gc2hvdWxkIHN0b3AuXG4gICAqL1xuICBTdG9wUHJvcGFnYXRpb24sXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIEFERCAoYWRkZWQpIHR1cGxlcy5cbiAgICovXG4gIEFERCxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgUkVNIChyZW1vdmVkKSB0dXBsZXMuXG4gICAqL1xuICBSRU0sXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIE1PRCAobW9kaWZpZWQpIHR1cGxlcy5cbiAgICovXG4gIE1PRCxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgQUREIChhZGRlZCkgYW5kIFJFTSAocmVtb3ZlZCkgdHVwbGVzLlxuICAgKi9cbiAgQUREX1JFTSxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgQUREIChhZGRlZCkgYW5kIE1PRCAobW9kaWZpZWQpIHR1cGxlcy5cbiAgICovXG4gIEFERF9NT0QsXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIEFERCwgUkVNIGFuZCBNT0QgdHVwbGVzLlxuICAgKi9cbiAgQUxMLFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBhbGwgdHVwbGVzIGluIGEgZGF0YSBzb3VyY2VcbiAgICogZXhjZXB0IGZvciB0aGUgQURELCBSRU0gYW5kIE1PRCB0dXBsZXMuXG4gICAqL1xuICBSRUZMT1csXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGEgJ3Bhc3MtdGhyb3VnaCcgdG8gYVxuICAgKiBiYWNraW5nIGRhdGEgc291cmNlLCBpZ25vcmluZyBBREQsIFJFTSBhbmQgTU9EIHR1cGxlcy5cbiAgICovXG4gIFNPVVJDRSxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgdGhhdCBzb3VyY2UgZGF0YSBzaG91bGQgYmVcbiAgICogc3VwcHJlc3NlZCB3aGVuIGNyZWF0aW5nIGEgZm9ya2VkIHB1bHNlLlxuICAgKi9cbiAgTk9fU09VUkNFLFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyB0aGF0IGZpZWxkIG1vZGlmaWNhdGlvbnMgc2hvdWxkIGJlXG4gICAqIHN1cHByZXNzZWQgd2hlbiBjcmVhdGluZyBhIGZvcmtlZCBwdWxzZS5cbiAgICovXG4gIE5PX0ZJRUxEUyxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwdWxzZSBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIHRoaXMgcHVsc2UuXG4gICAqIFRoZSBkYXRhZmxvdywgdGltZSBzdGFtcCBhbmQgZmllbGQgbW9kaWZpY2F0aW9uIHZhbHVlcyBhcmUgY29waWVkIG92ZXIuXG4gICAqIEJ5IGRlZmF1bHQsIG5ldyBlbXB0eSBBREQsIFJFTSBhbmQgTU9EIGFycmF5cyBhcmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gSW50ZWdlciBvZiBib29sZWFuIGZsYWdzIGluZGljYXRpbmcgd2hpY2ggKGlmIGFueSlcbiAgICogICB0dXBsZSBhcnJheXMgc2hvdWxkIGJlIGNvcGllZCB0byB0aGUgbmV3IHB1bHNlLiBUaGUgc3VwcG9ydGVkIGZsYWcgdmFsdWVzXG4gICAqICAgYXJlIEFERCwgUkVNIGFuZCBNT0QuIEFycmF5IHJlZmVyZW5jZXMgYXJlIGNvcGllZCBkaXJlY3RseTogbmV3IGFycmF5XG4gICAqICAgaW5zdGFuY2VzIGFyZSBub3QgY3JlYXRlZC5cbiAgICogQHJldHVybiB7UHVsc2V9IC0gVGhlIGZvcmtlZCBwdWxzZSBpbnN0YW5jZS5cbiAgICogQHNlZSBpbml0XG4gICAqL1xuICBmb3JrKGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBQdWxzZSh0aGlzLmRhdGFmbG93KS5pbml0KHRoaXMsIGZsYWdzKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBwdWxzZSB3aXRoIG5ldyBtYXRlcmlhbGl6ZWQgYXJyYXlcbiAgICogaW5zdGFuY2VzIGZvciB0aGUgQURELCBSRU0sIE1PRCwgYW5kIFNPVVJDRSBhcnJheXMuXG4gICAqIFRoZSBkYXRhZmxvdywgdGltZSBzdGFtcCBhbmQgZmllbGQgbW9kaWZpY2F0aW9uIHZhbHVlcyBhcmUgY29waWVkIG92ZXIuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFRoZSBjbG9uZWQgcHVsc2UgaW5zdGFuY2UuXG4gICAqIEBzZWUgaW5pdFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuZm9yayhBTEwpO1xuICAgIHAuYWRkID0gcC5hZGQuc2xpY2UoKTtcbiAgICBwLnJlbSA9IHAucmVtLnNsaWNlKCk7XG4gICAgcC5tb2QgPSBwLm1vZC5zbGljZSgpO1xuICAgIGlmIChwLnNvdXJjZSkgcC5zb3VyY2UgPSBwLnNvdXJjZS5zbGljZSgpO1xuICAgIHJldHVybiBwLm1hdGVyaWFsaXplKEFMTCB8IFNPVVJDRSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwdWxzZSB0aGF0IGFkZHMgYWxsIHR1cGxlcyBmcm9tIGEgYmFja2luZyBzb3VyY2UuIFRoaXMgaXNcbiAgICogdXNlZnVsIGZvciBjYXNlcyB3aGVyZSBvcGVyYXRvcnMgYXJlIGFkZGVkIHRvIGEgZGF0YWZsb3cgYWZ0ZXIgYW5cbiAgICogdXBzdHJlYW0gZGF0YSBwaXBlbGluZSBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCwgZW5zdXJpbmcgdGhhdFxuICAgKiBuZXcgb3BlcmF0b3JzIGNhbiBvYnNlcnZlIGFsbCB0dXBsZXMgd2l0aGluIGEgc3RyZWFtLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBBIHB1bHNlIGluc3RhbmNlIHdpdGggYWxsIHNvdXJjZSB0dXBsZXMgaW5jbHVkZWRcbiAgICogICBpbiB0aGUgYWRkIGFycmF5LiBJZiB0aGUgY3VycmVudCBwdWxzZSBhbHJlYWR5IGhhcyBhbGwgc291cmNlXG4gICAqICAgdHVwbGVzIGluIGl0cyBhZGQgYXJyYXksIGl0IGlzIHJldHVybmVkIGRpcmVjdGx5LiBJZiB0aGUgY3VycmVudFxuICAgKiAgIHB1bHNlIGRvZXMgbm90IGhhdmUgYSBiYWNraW5nIHNvdXJjZSwgaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHkuXG4gICAqL1xuICBhZGRBbGwoKSB7XG4gICAgbGV0IHAgPSB0aGlzO1xuICAgIGNvbnN0IHJldXNlID0gIXAuc291cmNlIHx8IHAuYWRkID09PSBwLnJlbSAvLyBzcGVjaWFsIGNhc2UgZm9yIGluZGV4ZWQgc2V0IChlLmcuLCBjcm9zc2ZpbHRlcilcbiAgICB8fCAhcC5yZW0ubGVuZ3RoICYmIHAuc291cmNlLmxlbmd0aCA9PT0gcC5hZGQubGVuZ3RoO1xuXG4gICAgaWYgKHJldXNlKSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IG5ldyBQdWxzZSh0aGlzLmRhdGFmbG93KS5pbml0KHRoaXMpO1xuICAgICAgcC5hZGQgPSBwLnNvdXJjZTtcbiAgICAgIHAucmVtID0gW107IC8vIG5ldyBvcGVyYXRvcnMgY2FuIGlnbm9yZSByZW0gIzI3NjlcblxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoaXMgcHVsc2UgYmFzZWQgb24gdGhlIHZhbHVlcyBvZiBhbm90aGVyIHB1bHNlLiBUaGlzIG1ldGhvZFxuICAgKiBpcyB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIGZvcmt9IHRvIGluaXRpYWxpemUgYSBuZXcgZm9ya2VkIHR1cGxlLlxuICAgKiBUaGUgZGF0YWZsb3csIHRpbWUgc3RhbXAgYW5kIGZpZWxkIG1vZGlmaWNhdGlvbiB2YWx1ZXMgYXJlIGNvcGllZCBvdmVyLlxuICAgKiBCeSBkZWZhdWx0LCBuZXcgZW1wdHkgQURELCBSRU0gYW5kIE1PRCBhcnJheXMgYXJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7UHVsc2V9IHNyYyAtIFRoZSBzb3VyY2UgcHVsc2UgdG8gY29weSBmcm9tLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgLSBJbnRlZ2VyIG9mIGJvb2xlYW4gZmxhZ3MgaW5kaWNhdGluZyB3aGljaCAoaWYgYW55KVxuICAgKiAgIHR1cGxlIGFycmF5cyBzaG91bGQgYmUgY29waWVkIHRvIHRoZSBuZXcgcHVsc2UuIFRoZSBzdXBwb3J0ZWQgZmxhZyB2YWx1ZXNcbiAgICogICBhcmUgQURELCBSRU0gYW5kIE1PRC4gQXJyYXkgcmVmZXJlbmNlcyBhcmUgY29waWVkIGRpcmVjdGx5OiBuZXcgYXJyYXlcbiAgICogICBpbnN0YW5jZXMgYXJlIG5vdCBjcmVhdGVkLiBCeSBkZWZhdWx0LCBzb3VyY2UgZGF0YSBhcnJheXMgYXJlIGNvcGllZFxuICAgKiAgIHRvIHRoZSBuZXcgcHVsc2UuIFVzZSB0aGUgTk9fU09VUkNFIGZsYWcgdG8gZW5mb3JjZSBhIG51bGwgc291cmNlLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgUHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICBpbml0KHNyYywgZmxhZ3MpIHtcbiAgICBjb25zdCBwID0gdGhpcztcbiAgICBwLnN0YW1wID0gc3JjLnN0YW1wO1xuICAgIHAuZW5jb2RlID0gc3JjLmVuY29kZTtcblxuICAgIGlmIChzcmMuZmllbGRzICYmICEoZmxhZ3MgJiBOT19GSUVMRFMpKSB7XG4gICAgICBwLmZpZWxkcyA9IHNyYy5maWVsZHM7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgQUREKSB7XG4gICAgICBwLmFkZEYgPSBzcmMuYWRkRjtcbiAgICAgIHAuYWRkID0gc3JjLmFkZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5hZGRGID0gbnVsbDtcbiAgICAgIHAuYWRkID0gW107XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgUkVNKSB7XG4gICAgICBwLnJlbUYgPSBzcmMucmVtRjtcbiAgICAgIHAucmVtID0gc3JjLnJlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5yZW1GID0gbnVsbDtcbiAgICAgIHAucmVtID0gW107XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgTU9EKSB7XG4gICAgICBwLm1vZEYgPSBzcmMubW9kRjtcbiAgICAgIHAubW9kID0gc3JjLm1vZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5tb2RGID0gbnVsbDtcbiAgICAgIHAubW9kID0gW107XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgTk9fU09VUkNFKSB7XG4gICAgICBwLnNyY0YgPSBudWxsO1xuICAgICAgcC5zb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnNyY0YgPSBzcmMuc3JjRjtcbiAgICAgIHAuc291cmNlID0gc3JjLnNvdXJjZTtcbiAgICAgIGlmIChzcmMuY2xlYW5zKSBwLmNsZWFucyA9IHNyYy5jbGVhbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciBwdWxzZSBwcm9wYWdhdGlvbiBjb21wbGV0ZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gcnVuLlxuICAgKi9cbiAgcnVuQWZ0ZXIoZnVuYykge1xuICAgIHRoaXMuZGF0YWZsb3cucnVuQWZ0ZXIoZnVuYyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0dXBsZXMgaGF2ZSBiZWVuIGFkZGVkLCByZW1vdmVkIG9yIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2ZsYWdzXSAtIFRoZSB0dXBsZSB0eXBlcyAoQURELCBSRU0gb3IgTU9EKSB0byBxdWVyeS5cbiAgICogICBEZWZhdWx0cyB0byBBTEwsIHJldHVybmluZyB0cnVlIGlmIGFueSB0dXBsZSB0eXBlIGhhcyBjaGFuZ2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiBvbmUgb3IgbW9yZSBxdWVyaWVkIHR1cGxlIHR5cGVzIGhhdmVcbiAgICogICBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjaGFuZ2VkKGZsYWdzKSB7XG4gICAgY29uc3QgZiA9IGZsYWdzIHx8IEFMTDtcbiAgICByZXR1cm4gZiAmIEFERCAmJiB0aGlzLmFkZC5sZW5ndGggfHwgZiAmIFJFTSAmJiB0aGlzLnJlbS5sZW5ndGggfHwgZiAmIE1PRCAmJiB0aGlzLm1vZC5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhIFwicmVmbG93XCIgb2YgdHVwbGUgdmFsdWVzLCBzdWNoIHRoYXQgYWxsIHR1cGxlcyBpbiB0aGUgYmFja2luZ1xuICAgKiBzb3VyY2UgYXJlIGFkZGVkIHRvIHRoZSBNT0Qgc2V0LCB1bmxlc3MgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBBREQgc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JrPWZhbHNlXSAtIElmIHRydWUsIHJldHVybnMgYSBmb3JrZWQgY29weSBvZiB0aGlzXG4gICAqICAgcHVsc2UsIGFuZCBpbnZva2VzIHJlZmxvdyBvbiB0aGF0IGRlcml2ZWQgcHVsc2UuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFRoZSByZWZsb3dlZCBwdWxzZSBpbnN0YW5jZS5cbiAgICovXG4gIHJlZmxvdyhmb3JrKSB7XG4gICAgaWYgKGZvcmspIHJldHVybiB0aGlzLmZvcmsoQUxMKS5yZWZsb3coKTtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmFkZC5sZW5ndGgsXG4gICAgICAgICAgc3JjID0gdGhpcy5zb3VyY2UgJiYgdGhpcy5zb3VyY2UubGVuZ3RoO1xuXG4gICAgaWYgKHNyYyAmJiBzcmMgIT09IGxlbikge1xuICAgICAgdGhpcy5tb2QgPSB0aGlzLnNvdXJjZTtcbiAgICAgIGlmIChsZW4pIHRoaXMuZmlsdGVyKE1PRCwgZmlsdGVyKHRoaXMsIEFERCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQvc2V0IG1ldGFkYXRhIHRvIHB1bHNlIHJlcXVlc3RpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAqIHRvIHJlY2xhaW0gY3VycmVudGx5IHVudXNlZCByZXNvdXJjZXMuXG4gICAqL1xuICBjbGVhbih2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNsZWFucyA9ICEhdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2xlYW5zO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTWFya3Mgb25lIG9yIG1vcmUgZGF0YSBmaWVsZCBuYW1lcyBhcyBtb2RpZmllZCB0byBhc3Npc3QgZGVwZW5kZW5jeVxuICAgKiB0cmFja2luZyBhbmQgaW5jcmVtZW50YWwgcHJvY2Vzc2luZyBieSB0cmFuc2Zvcm0gb3BlcmF0b3JzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBfIC0gVGhlIGZpZWxkKHMpIHRvIG1hcmsgYXMgbW9kaWZpZWQuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICBtb2RpZmllcyhfKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuZmllbGRzIHx8ICh0aGlzLmZpZWxkcyA9IHt9KTtcblxuICAgIGlmIChpc0FycmF5KF8pKSB7XG4gICAgICBfLmZvckVhY2goZiA9PiBoYXNoW2ZdID0gdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2hbX10gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgb25lIG9yIG1vcmUgZGF0YSBmaWVsZHMgaGF2ZSBiZWVuIG1vZGlmaWVkIGR1cmluZyB0aGlzIHB1bHNlXG4gICAqIHByb3BhZ2F0aW9uIHRpbWVzdGFtcC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gXyAtIFRoZSBmaWVsZChzKSB0byBjaGVjayBmb3IgbW9kaWZpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbm9tb2QgLSBJZiB0cnVlLCB3aWxsIGNoZWNrIHRoZSBtb2RpZmllZCBmbGFnIGV2ZW4gaWZcbiAgICogICBubyBtb2QgdHVwbGVzIGV4aXN0LiBJZiBmYWxzZSAoZGVmYXVsdCksIG1vZCB0dXBsZXMgbXVzdCBiZSBwcmVzZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlIHByb3ZpZGVkIGZpZWxkcyBoYXMgYmVlblxuICAgKiAgIG1hcmtlZCBhcyBtb2RpZmllZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgbW9kaWZpZWQoXywgbm9tb2QpIHtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICByZXR1cm4gISgobm9tb2QgfHwgdGhpcy5tb2QubGVuZ3RoKSAmJiBmaWVsZHMpID8gZmFsc2UgOiAhYXJndW1lbnRzLmxlbmd0aCA/ICEhZmllbGRzIDogaXNBcnJheShfKSA/IF8uc29tZShmID0+IGZpZWxkc1tmXSkgOiBmaWVsZHNbX107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBmaWx0ZXIgZnVuY3Rpb24gdG8gb25lIG1vcmUgdHVwbGUgc2V0cy4gRmlsdGVycyBhcmUgYXBwbGllZCB0b1xuICAgKiBiYWNraW5nIHR1cGxlIGFycmF5cywgdG8gZGV0ZXJtaW5lIHRoZSBhY3R1YWwgc2V0IG9mIHR1cGxlcyBjb25zaWRlcmVkXG4gICAqIGFkZGVkLCByZW1vdmVkIG9yIG1vZGlmaWVkLiBUaGV5IGNhbiBiZSB1c2VkIHRvIGRlbGF5IG1hdGVyaWFsaXphdGlvbiBvZlxuICAgKiBhIHR1cGxlIHNldCBpbiBvcmRlciB0byBhdm9pZCBleHBlbnNpdmUgYXJyYXkgY29waWVzLiBJbiBhZGRpdGlvbiwgdGhlXG4gICAqIGZpbHRlciBmdW5jdGlvbnMgY2FuIHNlcnZlIGFzIHZhbHVlIHRyYW5zZm9ybWVyczogdW5saWtlIHN0YW5kYXJkIHByZWRpY2F0ZVxuICAgKiBmdW5jdGlvbiAod2hpY2ggcmV0dXJuIGJvb2xlYW4gdmFsdWVzKSwgUHVsc2UgZmlsdGVycyBzaG91bGQgcmV0dXJuIHRoZVxuICAgKiBhY3R1YWwgdHVwbGUgdmFsdWUgdG8gcHJvY2Vzcy4gSWYgYSB0dXBsZSBzZXQgaXMgYWxyZWFkeSBmaWx0ZXJlZCwgdGhlXG4gICAqIG5ldyBmaWx0ZXIgZnVuY3Rpb24gd2lsbCBiZSBhcHBlbmRlZCBpbnRvIGEgY29uanVudGl2ZSAoJ2FuZCcpIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgLSBGbGFncyBpbmRpY2F0aW5nIHRoZSB0dXBsZSBzZXQocykgdG8gZmlsdGVyLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopOm9iamVjdH0gZmlsdGVyIC0gRmlsdGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gICAqICAgdG8gdGhlIHR1cGxlIHNldCBhcnJheSwgYW5kIHNob3VsZCByZXR1cm4gYSBkYXRhIHR1cGxlIGlmIHRoZSB2YWx1ZVxuICAgKiAgIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdHVwbGUgc2V0LCBhbmQgZmFsc3kgKG9yIG51bGwpIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7UHVsc2V9IC0gUmV0dXJucyB0aGlzIHB1bHNlIGluc3RhbmNlLlxuICAgKi9cbiAgZmlsdGVyKGZsYWdzLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBwID0gdGhpcztcbiAgICBpZiAoZmxhZ3MgJiBBREQpIHAuYWRkRiA9IGFkZEZpbHRlcihwLmFkZEYsIGZpbHRlcik7XG4gICAgaWYgKGZsYWdzICYgUkVNKSBwLnJlbUYgPSBhZGRGaWx0ZXIocC5yZW1GLCBmaWx0ZXIpO1xuICAgIGlmIChmbGFncyAmIE1PRCkgcC5tb2RGID0gYWRkRmlsdGVyKHAubW9kRiwgZmlsdGVyKTtcbiAgICBpZiAoZmxhZ3MgJiBTT1VSQ0UpIHAuc3JjRiA9IGFkZEZpbHRlcihwLnNyY0YsIGZpbHRlcik7XG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hdGVyaWFsaXplIG9uZSBvciBtb3JlIHR1cGxlIHNldHMgaW4gdGhpcyBwdWxzZS4gSWYgdGhlIHR1cGxlIHNldChzKSBoYXZlXG4gICAqIGEgcmVnaXN0ZXJlZCBmaWx0ZXIgZnVuY3Rpb24sIGl0IHdpbGwgYmUgYXBwbGllZCBhbmQgdGhlIHR1cGxlIHNldChzKSB3aWxsXG4gICAqIGJlIHJlcGxhY2VkIHdpdGggbWF0ZXJpYWxpemVkIHR1cGxlIGFycmF5cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gRmxhZ3MgaW5kaWNhdGluZyB0aGUgdHVwbGUgc2V0KHMpIHRvIG1hdGVyaWFsaXplLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICBtYXRlcmlhbGl6ZShmbGFncykge1xuICAgIGZsYWdzID0gZmxhZ3MgfHwgQUxMO1xuICAgIGNvbnN0IHAgPSB0aGlzO1xuXG4gICAgaWYgKGZsYWdzICYgQUREICYmIHAuYWRkRikge1xuICAgICAgcC5hZGQgPSBtYXRlcmlhbGl6ZShwLmFkZCwgcC5hZGRGKTtcbiAgICAgIHAuYWRkRiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgUkVNICYmIHAucmVtRikge1xuICAgICAgcC5yZW0gPSBtYXRlcmlhbGl6ZShwLnJlbSwgcC5yZW1GKTtcbiAgICAgIHAucmVtRiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgTU9EICYmIHAubW9kRikge1xuICAgICAgcC5tb2QgPSBtYXRlcmlhbGl6ZShwLm1vZCwgcC5tb2RGKTtcbiAgICAgIHAubW9kRiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgU09VUkNFICYmIHAuc3JjRikge1xuICAgICAgcC5zb3VyY2UgPSBwLnNvdXJjZS5maWx0ZXIocC5zcmNGKTtcbiAgICAgIHAuc3JjRiA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZpc2l0IG9uZSBvciBtb3JlIHR1cGxlIHNldHMgaW4gdGhpcyBwdWxzZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gRmxhZ3MgaW5kaWNhdGluZyB0aGUgdHVwbGUgc2V0KHMpIHRvIHZpc2l0LlxuICAgKiAgIExlZ2FsIHZhbHVlcyBhcmUgQURELCBSRU0sIE1PRCBhbmQgU09VUkNFIChpZiBhIGJhY2tpbmcgZGF0YSBzb3VyY2VcbiAgICogICBoYXMgYmVlbiBzZXQpLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6Kn0gLSBWaXNpdG9yIGZ1bmN0aW9uIGludm9rZWQgcGVyLXR1cGxlLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICB2aXNpdChmbGFncywgdmlzaXRvcikge1xuICAgIGNvbnN0IHAgPSB0aGlzLFxuICAgICAgICAgIHYgPSB2aXNpdG9yO1xuXG4gICAgaWYgKGZsYWdzICYgU09VUkNFKSB7XG4gICAgICB2aXNpdEFycmF5KHAuc291cmNlLCBwLnNyY0YsIHYpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgQUREKSB2aXNpdEFycmF5KHAuYWRkLCBwLmFkZEYsIHYpO1xuICAgIGlmIChmbGFncyAmIFJFTSkgdmlzaXRBcnJheShwLnJlbSwgcC5yZW1GLCB2KTtcbiAgICBpZiAoZmxhZ3MgJiBNT0QpIHZpc2l0QXJyYXkocC5tb2QsIHAubW9kRiwgdik7XG4gICAgY29uc3Qgc3JjID0gcC5zb3VyY2U7XG5cbiAgICBpZiAoZmxhZ3MgJiBSRUZMT1cgJiYgc3JjKSB7XG4gICAgICBjb25zdCBzdW0gPSBwLmFkZC5sZW5ndGggKyBwLm1vZC5sZW5ndGg7XG5cbiAgICAgIGlmIChzdW0gPT09IHNyYy5sZW5ndGgpIDsgZWxzZSBpZiAoc3VtKSB7XG4gICAgICAgIHZpc2l0QXJyYXkoc3JjLCBmaWx0ZXIocCwgQUREX01PRCksIHYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm8gYWRkL3JlbS9tb2QgdHVwbGVzLCB2aXNpdCBzb3VyY2VcbiAgICAgICAgdmlzaXRBcnJheShzcmMsIHAuc3JjRiwgdik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH1cblxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2V0IG9mIG11bHRpcGxlIHB1bHNlcy4gVXNlZCBhcyBpbnB1dCBmb3Igb3BlcmF0b3JzXG4gKiB0aGF0IGFjY2VwdCBtdWx0aXBsZSBwdWxzZXMgYXQgYSB0aW1lLiBDb250YWluZWQgcHVsc2VzIGFyZVxuICogYWNjZXNzaWJsZSB2aWEgdGhlIHB1YmxpYyBcInB1bHNlc1wiIGFycmF5IHByb3BlcnR5LiBUaGlzIHB1bHNlIGRvZVxuICogbm90IGNhcnJ5IGFkZGVkLCByZW1vdmVkIG9yIG1vZGlmaWVkIHR1cGxlcyBkaXJlY3RseS4gSG93ZXZlcixcbiAqIHRoZSB2aXNpdCBtZXRob2QgY2FuIGJlIHVzZWQgdG8gdHJhdmVyc2UgYWxsIHN1Y2ggdHVwbGVzIGNvbnRhaW5lZFxuICogaW4gc3ViLXB1bHNlcyB3aXRoIGEgdGltZXN0YW1wIG1hdGNoaW5nIHRoaXMgcGFyZW50IG11bHRpLXB1bHNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0RhdGFmbG93fSBkYXRhZmxvdyAtIFRoZSBiYWNraW5nIGRhdGFmbG93IGluc3RhbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YW1wIC0gVGhlIHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7QXJyYXk8UHVsc2U+fSBwdWxzZXMgLSBUaGUgc3ViLXB1bHNlcyBmb3IgdGhpcyBtdWx0aS1wdWxzZS5cbiAqL1xuXG5mdW5jdGlvbiBNdWx0aVB1bHNlKGRhdGFmbG93LCBzdGFtcCwgcHVsc2VzLCBlbmNvZGUpIHtcbiAgY29uc3QgcCA9IHRoaXMsXG4gICAgICAgIG4gPSBwdWxzZXMubGVuZ3RoO1xuICBsZXQgYyA9IDA7XG4gIHRoaXMuZGF0YWZsb3cgPSBkYXRhZmxvdztcbiAgdGhpcy5zdGFtcCA9IHN0YW1wO1xuICB0aGlzLmZpZWxkcyA9IG51bGw7XG4gIHRoaXMuZW5jb2RlID0gZW5jb2RlIHx8IG51bGw7XG4gIHRoaXMucHVsc2VzID0gcHVsc2VzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgcHVsc2UgPSBwdWxzZXNbaV07XG4gICAgaWYgKHB1bHNlLnN0YW1wICE9PSBzdGFtcCkgY29udGludWU7XG5cbiAgICBpZiAocHVsc2UuZmllbGRzKSB7XG4gICAgICBjb25zdCBoYXNoID0gcC5maWVsZHMgfHwgKHAuZmllbGRzID0ge30pO1xuXG4gICAgICBmb3IgKGNvbnN0IGYgaW4gcHVsc2UuZmllbGRzKSB7XG4gICAgICAgIGhhc2hbZl0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHAuQUREKSkgYyB8PSBwLkFERDtcbiAgICBpZiAocHVsc2UuY2hhbmdlZChwLlJFTSkpIGMgfD0gcC5SRU07XG4gICAgaWYgKHB1bHNlLmNoYW5nZWQocC5NT0QpKSBjIHw9IHAuTU9EO1xuICB9XG5cbiAgdGhpcy5jaGFuZ2VzID0gYztcbn1cbmluaGVyaXRzKE11bHRpUHVsc2UsIFB1bHNlLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHB1bHNlIGJhc2VkIG9uIHRoZSB2YWx1ZXMgb2YgdGhpcyBwdWxzZS5cbiAgICogVGhlIGRhdGFmbG93LCB0aW1lIHN0YW1wIGFuZCBmaWVsZCBtb2RpZmljYXRpb24gdmFsdWVzIGFyZSBjb3BpZWQgb3Zlci5cbiAgICogQHJldHVybiB7UHVsc2V9XG4gICAqL1xuICBmb3JrKGZsYWdzKSB7XG4gICAgY29uc3QgcCA9IG5ldyBQdWxzZSh0aGlzLmRhdGFmbG93KS5pbml0KHRoaXMsIGZsYWdzICYgdGhpcy5OT19GSUVMRFMpO1xuXG4gICAgaWYgKGZsYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChmbGFncyAmIHAuQUREKSB0aGlzLnZpc2l0KHAuQURELCB0ID0+IHAuYWRkLnB1c2godCkpO1xuICAgICAgaWYgKGZsYWdzICYgcC5SRU0pIHRoaXMudmlzaXQocC5SRU0sIHQgPT4gcC5yZW0ucHVzaCh0KSk7XG4gICAgICBpZiAoZmxhZ3MgJiBwLk1PRCkgdGhpcy52aXNpdChwLk1PRCwgdCA9PiBwLm1vZC5wdXNoKHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICBjaGFuZ2VkKGZsYWdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlcyAmIGZsYWdzO1xuICB9LFxuXG4gIG1vZGlmaWVkKF8pIHtcbiAgICBjb25zdCBwID0gdGhpcyxcbiAgICAgICAgICBmaWVsZHMgPSBwLmZpZWxkcztcbiAgICByZXR1cm4gIShmaWVsZHMgJiYgcC5jaGFuZ2VzICYgcC5NT0QpID8gMCA6IGlzQXJyYXkoXykgPyBfLnNvbWUoZiA9PiBmaWVsZHNbZl0pIDogZmllbGRzW19dO1xuICB9LFxuXG4gIGZpbHRlcigpIHtcbiAgICBlcnJvcignTXVsdGlQdWxzZSBkb2VzIG5vdCBzdXBwb3J0IGZpbHRlcmluZy4nKTtcbiAgfSxcblxuICBtYXRlcmlhbGl6ZSgpIHtcbiAgICBlcnJvcignTXVsdGlQdWxzZSBkb2VzIG5vdCBzdXBwb3J0IG1hdGVyaWFsaXphdGlvbi4nKTtcbiAgfSxcblxuICB2aXNpdChmbGFncywgdmlzaXRvcikge1xuICAgIGNvbnN0IHAgPSB0aGlzLFxuICAgICAgICAgIHB1bHNlcyA9IHAucHVsc2VzLFxuICAgICAgICAgIG4gPSBwdWxzZXMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcblxuICAgIGlmIChmbGFncyAmIHAuU09VUkNFKSB7XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBwdWxzZXNbaV0udmlzaXQoZmxhZ3MsIHZpc2l0b3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAocHVsc2VzW2ldLnN0YW1wID09PSBwLnN0YW1wKSB7XG4gICAgICAgICAgcHVsc2VzW2ldLnZpc2l0KGZsYWdzLCB2aXNpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9XG5cbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF0b21pYy11cGRhdGVzICovXG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgZGF0YWZsb3cgYW5kIHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBwdWxzZVxuICogcHJvcGFnYXRpb24gY29tcGxldGVzLiBUaGlzIG1ldGhvZCB3aWxsIGluY3JlbWVudCB0aGUgY3VycmVudCB0aW1lc3RhbXBcbiAqIGFuZCBwcm9jZXNzIGFsbCB1cGRhdGVkLCBwdWxzZWQgYW5kIHRvdWNoZWQgb3BlcmF0b3JzLiBXaGVuIGludm9rZWQgZm9yXG4gKiB0aGUgZmlyc3QgdGltZSwgYWxsIHJlZ2lzdGVyZWQgb3BlcmF0b3JzIHdpbGwgYmUgcHJvY2Vzc2VkLiBUaGlzIG1ldGhvZFxuICogc2hvdWxkIG5vdCBiZSBpbnZva2VkIGJ5IHRoaXJkLXBhcnR5IGNsaWVudHMsIHVzZSB7QGxpbmsgcnVuQXN5bmN9IG9yXG4gKiB7QGxpbmsgcnVufSBpbnN0ZWFkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGVdIC0gVGhlIG5hbWUgb2YgYW4gZW5jb2Rpbmcgc2V0IHRvIGludm9rZSBkdXJpbmdcbiAqICAgcHJvcGFnYXRpb24uIFRoaXMgdmFsdWUgaXMgYWRkZWQgdG8gZ2VuZXJhdGVkIFB1bHNlIGluc3RhbmNlcztcbiAqICAgb3BlcmF0b3JzIGNhbiB0aGVuIHJlc3BvbmQgdG8gKG9yIGlnbm9yZSkgdGhpcyBzZXR0aW5nIGFzIGFwcHJvcHJpYXRlLlxuICogICBUaGlzIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBFbmNvZGUgdHJhbnNmb3JtIGluXG4gKiAgIHRoZSB2ZWdhLWVuY29kZSBwYWNrYWdlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3ByZXJ1bl0gLSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgaW1tZWRpYXRlbHkgYmVmb3JlIGRhdGFmbG93IGV2YWx1YXRpb24gY29tbWVuY2VzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Bvc3RydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGFmdGVyIGRhdGFmbG93IGV2YWx1YXRpb24gY29tcGxldGVzLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiAgIGFmdGVyIHRob3NlIHJlZ2lzdGVyZWQgdmlhIHtAbGluayBydW5BZnRlcn0uXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoaXMgZGF0YWZsb3cgYWZ0ZXJcbiAqICAgZXZhbHVhdGlvbiBjb21wbGV0ZXMuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGUoZW5jb2RlLCBwcmVydW4sIHBvc3RydW4pIHtcbiAgY29uc3QgZGYgPSB0aGlzLFxuICAgICAgICBhc3luYyA9IFtdOyAvLyBpZiB0aGUgcHVsc2UgdmFsdWUgaXMgc2V0LCB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsXG5cbiAgaWYgKGRmLl9wdWxzZSkgcmV0dXJuIHJlZW50cmFudChkZik7IC8vIHdhaXQgZm9yIHBlbmRpbmcgZGF0YXNldHMgdG8gbG9hZFxuXG4gIGlmIChkZi5fcGVuZGluZykgYXdhaXQgZGYuX3BlbmRpbmc7IC8vIGludm9rZSBwcmVydW4gZnVuY3Rpb24sIGlmIHByb3ZpZGVkXG5cbiAgaWYgKHByZXJ1bikgYXdhaXQgYXN5bmNDYWxsYmFjayhkZiwgcHJlcnVuKTsgLy8gZXhpdCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gdXBkYXRlc1xuXG4gIGlmICghZGYuX3RvdWNoZWQubGVuZ3RoKSB7XG4gICAgZGYuZGVidWcoJ0RhdGFmbG93IGludm9rZWQsIGJ1dCBub3RoaW5nIHRvIGRvLicpO1xuICAgIHJldHVybiBkZjtcbiAgfSAvLyBpbmNyZW1lbnQgdGltZXN0YW1wIGNsb2NrXG5cblxuICBjb25zdCBzdGFtcCA9ICsrZGYuX2Nsb2NrOyAvLyBzZXQgdGhlIGN1cnJlbnQgcHVsc2VcblxuICBkZi5fcHVsc2UgPSBuZXcgUHVsc2UoZGYsIHN0YW1wLCBlbmNvZGUpOyAvLyBpbml0aWFsaXplIHByaW9yaXR5IHF1ZXVlLCByZXNldCB0b3VjaGVkIG9wZXJhdG9yc1xuXG4gIGRmLl90b3VjaGVkLmZvckVhY2gob3AgPT4gZGYuX2VucXVldWUob3AsIHRydWUpKTtcblxuICBkZi5fdG91Y2hlZCA9IFVuaXF1ZUxpc3QoaWQpO1xuICBsZXQgY291bnQgPSAwLFxuICAgICAgb3AsXG4gICAgICBuZXh0LFxuICAgICAgZXJyb3I7XG5cbiAgdHJ5IHtcbiAgICB3aGlsZSAoZGYuX2hlYXAuc2l6ZSgpID4gMCkge1xuICAgICAgLy8gZGVxdWV1ZSBvcGVyYXRvciB3aXRoIGhpZ2hlc3QgcHJpb3JpdHlcbiAgICAgIG9wID0gZGYuX2hlYXAucG9wKCk7IC8vIHJlLXF1ZXVlIGlmIHJhbmsgY2hhbmdlZFxuXG4gICAgICBpZiAob3AucmFuayAhPT0gb3AucXJhbmspIHtcbiAgICAgICAgZGYuX2VucXVldWUob3AsIHRydWUpO1xuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBvdGhlcndpc2UsIGV2YWx1YXRlIHRoZSBvcGVyYXRvclxuXG5cbiAgICAgIG5leHQgPSBvcC5ydW4oZGYuX2dldFB1bHNlKG9wLCBlbmNvZGUpKTtcblxuICAgICAgaWYgKG5leHQudGhlbikge1xuICAgICAgICAvLyBhd2FpdCBpZiBvcGVyYXRvciByZXR1cm5zIGEgcHJvbWlzZSBkaXJlY3RseVxuICAgICAgICBuZXh0ID0gYXdhaXQgbmV4dDtcbiAgICAgIH0gZWxzZSBpZiAobmV4dC5hc3luYykge1xuICAgICAgICAvLyBxdWV1ZSBwYXJhbGxlbCBhc3luY2hyb25vdXMgZXhlY3V0aW9uXG4gICAgICAgIGFzeW5jLnB1c2gobmV4dC5hc3luYyk7XG4gICAgICAgIG5leHQgPSBTdG9wUHJvcGFnYXRpb247XG4gICAgICB9IC8vIHByb3BhZ2F0ZSBldmFsdWF0aW9uLCBlbnF1ZXVlIGRlcGVuZGVudCBvcGVyYXRvcnNcblxuXG4gICAgICBpZiAobmV4dCAhPT0gU3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGlmIChvcC5fdGFyZ2V0cykgb3AuX3RhcmdldHMuZm9yRWFjaChvcCA9PiBkZi5fZW5xdWV1ZShvcCkpO1xuICAgICAgfSAvLyBpbmNyZW1lbnQgdmlzaXQgY291bnRlclxuXG5cbiAgICAgICsrY291bnQ7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZi5faGVhcC5jbGVhcigpO1xuXG4gICAgZXJyb3IgPSBlcnI7XG4gIH0gLy8gcmVzZXQgcHVsc2UgbWFwXG5cblxuICBkZi5faW5wdXQgPSB7fTtcbiAgZGYuX3B1bHNlID0gbnVsbDtcbiAgZGYuZGVidWcoYFB1bHNlICR7c3RhbXB9OiAke2NvdW50fSBvcGVyYXRvcnNgKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBkZi5fcG9zdHJ1biA9IFtdO1xuICAgIGRmLmVycm9yKGVycm9yKTtcbiAgfSAvLyBpbnZva2UgY2FsbGJhY2tzIHF1ZXVlZCB2aWEgcnVuQWZ0ZXJcblxuXG4gIGlmIChkZi5fcG9zdHJ1bi5sZW5ndGgpIHtcbiAgICBjb25zdCBwciA9IGRmLl9wb3N0cnVuLnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcblxuICAgIGRmLl9wb3N0cnVuID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByLmxlbmd0aDsgKytpKSB7XG4gICAgICBhd2FpdCBhc3luY0NhbGxiYWNrKGRmLCBwcltpXS5jYWxsYmFjayk7XG4gICAgfVxuICB9IC8vIGludm9rZSBwb3N0cnVuIGZ1bmN0aW9uLCBpZiBwcm92aWRlZFxuXG5cbiAgaWYgKHBvc3RydW4pIGF3YWl0IGFzeW5jQ2FsbGJhY2soZGYsIHBvc3RydW4pOyAvLyBoYW5kbGUgbm9uLWJsb2NraW5nIGFzeW5jaHJvbm91cyBjYWxsYmFja3NcblxuICBpZiAoYXN5bmMubGVuZ3RoKSB7XG4gICAgUHJvbWlzZS5hbGwoYXN5bmMpLnRoZW4oY2IgPT4gZGYucnVuQXN5bmMobnVsbCwgKCkgPT4ge1xuICAgICAgY2IuZm9yRWFjaChmID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmKGRmKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZGYuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIGRmO1xufVxuLyoqXG4gKiBRdWV1ZXMgZGF0YWZsb3cgZXZhbHVhdGlvbiB0byBydW4gb25jZSBhbnkgb3RoZXIgcXVldWVkIGV2YWx1YXRpb25zIGhhdmVcbiAqIGNvbXBsZXRlZCBhbmQgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBxdWV1ZWQgcHVsc2VcbiAqIHByb3BhZ2F0aW9uIGNvbXBsZXRlcy4gSWYgcHJvdmlkZWQsIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkXG4gKiBpbW1lZGlhdGVseSBiZWZvcmUgZXZhbHVhdGlvbiBjb21tZW5jZXMuIFRoaXMgbWV0aG9kIHdpbGwgZW5zdXJlIGFcbiAqIHNlcGFyYXRlIGV2YWx1YXRpb24gaXMgaW52b2tlZCBmb3IgZWFjaCB0aW1lIGl0IGlzIGNhbGxlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RlXSAtIFRoZSBuYW1lIG9mIGFuIGVuY29kaW5nIHNldCB0byBpbnZva2UgZHVyaW5nXG4gKiAgIHByb3BhZ2F0aW9uLiBUaGlzIHZhbHVlIGlzIGFkZGVkIHRvIGdlbmVyYXRlZCBQdWxzZSBpbnN0YW5jZXM7XG4gKiAgIG9wZXJhdG9ycyBjYW4gdGhlbiByZXNwb25kIHRvIChvciBpZ25vcmUpIHRoaXMgc2V0dGluZyBhcyBhcHByb3ByaWF0ZS5cbiAqICAgVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgRW5jb2RlIHRyYW5zZm9ybSBpblxuICogICB0aGUgdmVnYS1lbmNvZGUgcGFja2FnZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcmVydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGltbWVkaWF0ZWx5IGJlZm9yZSBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbW1lbmNlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwb3N0cnVuXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICBhZnRlciBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbXBsZXRlcy4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogICBhZnRlciB0aG9zZSByZWdpc3RlcmVkIHZpYSB7QGxpbmsgcnVuQWZ0ZXJ9LlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGlzIGRhdGFmbG93IGFmdGVyXG4gKiAgIGV2YWx1YXRpb24gY29tcGxldGVzLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkFzeW5jKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSB7XG4gIC8vIGF3YWl0IHByZXZpb3VzbHkgcXVldWVkIGZ1bmN0aW9uc1xuICB3aGlsZSAodGhpcy5fcnVubmluZykgYXdhaXQgdGhpcy5fcnVubmluZzsgLy8gcnVuIGRhdGFmbG93LCBtYW5hZ2UgcnVubmluZyBwcm9taXNlXG5cblxuICBjb25zdCBjbGVhciA9ICgpID0+IHRoaXMuX3J1bm5pbmcgPSBudWxsO1xuXG4gICh0aGlzLl9ydW5uaW5nID0gdGhpcy5ldmFsdWF0ZShlbmNvZGUsIHByZXJ1biwgcG9zdHJ1bikpLnRoZW4oY2xlYXIsIGNsZWFyKTtcbiAgcmV0dXJuIHRoaXMuX3J1bm5pbmc7XG59XG4vKipcbiAqIFJlcXVlc3RzIGRhdGFmbG93IGV2YWx1YXRpb24gYW5kIHRoZSBpbW1lZGlhdGVseSByZXR1cm5zIHRoaXMgZGF0YWZsb3dcbiAqIGluc3RhbmNlLiBJZiB0aGVyZSBhcmUgcGVuZGluZyBkYXRhIGxvYWRpbmcgb3Igb3RoZXIgYXN5bmNocm9ub3VzXG4gKiBvcGVyYXRpb25zLCB0aGUgZGF0YWZsb3cgd2lsbCBldmFsdWF0ZSBhc3luY2hyb25vdXNseSBhZnRlciB0aGlzIG1ldGhvZFxuICogaGFzIGJlZW4gaW52b2tlZC4gVG8gdHJhY2sgd2hlbiBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbXBsZXRlcywgdXNlIHRoZVxuICoge0BsaW5rIHJ1bkFzeW5jfSBtZXRob2QgaW5zdGVhZC4gVGhpcyBtZXRob2Qgd2lsbCByYWlzZSBhbiBlcnJvciBpZlxuICogaW52b2tlZCB3aGlsZSB0aGUgZGF0YWZsb3cgaXMgYWxyZWFkeSBpbiB0aGUgbWlkc3Qgb2YgZXZhbHVhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RlXSAtIFRoZSBuYW1lIG9mIGFuIGVuY29kaW5nIHNldCB0byBpbnZva2UgZHVyaW5nXG4gKiAgIHByb3BhZ2F0aW9uLiBUaGlzIHZhbHVlIGlzIGFkZGVkIHRvIGdlbmVyYXRlZCBQdWxzZSBpbnN0YW5jZXM7XG4gKiAgIG9wZXJhdG9ycyBjYW4gdGhlbiByZXNwb25kIHRvIChvciBpZ25vcmUpIHRoaXMgc2V0dGluZyBhcyBhcHByb3ByaWF0ZS5cbiAqICAgVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgRW5jb2RlIHRyYW5zZm9ybSBpblxuICogICB0aGUgdmVnYS1lbmNvZGUgbW9kdWxlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3ByZXJ1bl0gLSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgaW1tZWRpYXRlbHkgYmVmb3JlIGRhdGFmbG93IGV2YWx1YXRpb24gY29tbWVuY2VzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Bvc3RydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGFmdGVyIGRhdGFmbG93IGV2YWx1YXRpb24gY29tcGxldGVzLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiAgIGFmdGVyIHRob3NlIHJlZ2lzdGVyZWQgdmlhIHtAbGluayBydW5BZnRlcn0uXG4gKiBAcmV0dXJuIHtEYXRhZmxvd30gLSBUaGlzIGRhdGFmbG93IGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIHJ1bihlbmNvZGUsIHByZXJ1biwgcG9zdHJ1bikge1xuICByZXR1cm4gdGhpcy5fcHVsc2UgPyByZWVudHJhbnQodGhpcykgOiAodGhpcy5ldmFsdWF0ZShlbmNvZGUsIHByZXJ1biwgcG9zdHJ1biksIHRoaXMpO1xufVxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBjdXJyZW50IHB1bHNlXG4gKiBwcm9wYWdhdGlvbiBjb21wbGV0ZXMuIElmIG5vIHByb3BhZ2F0aW9uIGlzIGN1cnJlbnRseSBvY2N1cnJpbmcsXG4gKiB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZCBpbW1lZGlhdGVseS4gQ2FsbGJhY2tzIHNjaGVkdWxlZCB2aWEgcnVuQWZ0ZXJcbiAqIGFyZSBpbnZva2VkIGltbWVkaWF0ZWx5IHVwb24gY29tcGxldGlvbiBvZiB0aGUgY3VycmVudCBjeWNsZSwgYmVmb3JlXG4gKiBhbnkgcmVxdWVzdCBxdWV1ZWQgdmlhIHJ1bkFzeW5jLiBUaGlzIG1ldGhvZCBpcyBwcmltYXJpbHkgaW50ZW5kZWQgZm9yXG4gKiBpbnRlcm5hbCB1c2UuIFRoaXJkLXBhcnR5IGNhbGxlcnMgdXNpbmcgcnVuQWZ0ZXIgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICogdGhhdCBpbnZva2VzIHtAbGluayBydW59IG9yIHtAbGluayBydW5Bc3luY30gc2hvdWxkIG5vdCB1c2UgdGhpcyBtZXRob2QsXG4gKiBidXQgaW5zdGVhZCB1c2Uge0BsaW5rIHJ1bkFzeW5jfSB3aXRoIHByZXJ1biBvciBwb3N0cnVuIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRGF0YWZsb3cpfSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4uXG4gKiAgIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGlzIERhdGFmbG93IGluc3RhbmNlIGFzIGl0c1xuICogICBzb2xlIGFyZ3VtZW50LlxuICogQHBhcmFtIHtib29sZWFufSBlbnF1ZXVlIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZVxuICogICBjYWxsYmFjayBzaG91bGQgYmUgcXVldWVkIHVwIHRvIHJ1biBhZnRlciB0aGUgbmV4dCBwcm9wYWdhdGlvblxuICogICBjeWNsZSwgc3VwcHJlc3NpbmcgaW1tZWRpYXRlIGludm9jYXRpb24gd2hlbiBwcm9wYWdhdGlvbiBpcyBub3RcbiAqICAgY3VycmVudGx5IG9jY3VycmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHldIC0gQSBwcmlvcml0eSB2YWx1ZSB1c2VkIHRvIHNvcnQgcmVnaXN0ZXJlZFxuICogICBjYWxsYmFja3MgdG8gZGV0ZXJtaW5lIGV4ZWN1dGlvbiBvcmRlci4gVGhpcyBhcmd1bWVudCBpcyBpbnRlbmRlZFxuICogICBmb3IgaW50ZXJuYWwgVmVnYSB1c2Ugb25seS5cbiAqL1xuXG5mdW5jdGlvbiBydW5BZnRlcihjYWxsYmFjaywgZW5xdWV1ZSwgcHJpb3JpdHkpIHtcbiAgaWYgKHRoaXMuX3B1bHNlIHx8IGVucXVldWUpIHtcbiAgICAvLyBwdWxzZSBwcm9wYWdhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZywgcXVldWUgdG8gcnVuIGFmdGVyXG4gICAgdGhpcy5fcG9zdHJ1bi5wdXNoKHtcbiAgICAgIHByaW9yaXR5OiBwcmlvcml0eSB8fCAwLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcHVsc2UgcHJvcGFnYXRpb24gYWxyZWFkeSBjb21wbGV0ZSwgaW52b2tlIGltbWVkaWF0ZWx5XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBSYWlzZSBhbiBlcnJvciBmb3IgcmUtZW50cmFudCBkYXRhZmxvdyBldmFsdWF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIHJlZW50cmFudChkZikge1xuICBkZi5lcnJvcignRGF0YWZsb3cgYWxyZWFkeSBydW5uaW5nLiBVc2UgcnVuQXN5bmMoKSB0byBjaGFpbiBpbnZvY2F0aW9ucy4nKTtcbiAgcmV0dXJuIGRmO1xufVxuLyoqXG4gKiBFbnF1ZXVlIGFuIG9wZXJhdG9yIGludG8gdGhlIHByaW9yaXR5IHF1ZXVlIGZvciBldmFsdWF0aW9uLiBUaGUgb3BlcmF0b3JcbiAqIHdpbGwgYmUgZW5xdWV1ZWQgaWYgaXQgaGFzIG5vIHJlZ2lzdGVyZWQgcHVsc2UgZm9yIHRoZSBjdXJyZW50IGN5Y2xlLCBvciBpZlxuICogdGhlIGZvcmNlIGFyZ3VtZW50IGlzIHRydWUuIFVwb24gZW5xdWV1ZSwgdGhpcyBtZXRob2QgYWxzbyBzZXRzIHRoZVxuICogb3BlcmF0b3IncyBxcmFuayB0byB0aGUgY3VycmVudCByYW5rIHZhbHVlLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gZW5xdWV1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSAtIEEgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBvcGVyYXRvciBzaG91bGQgYmVcbiAqICAgZm9yY2VhYmx5IGFkZGVkIHRvIHRoZSBxdWV1ZSwgZXZlbiBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHByZXZpb3VzbHlcbiAqICAgZW5xdWV1ZWQgZHVyaW5nIHRoZSBjdXJyZW50IHB1bHNlIHByb3BhZ2F0aW9uLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRoZVxuICogICBkYXRhZmxvdyBncmFwaCBpcyBkeW5hbWljYWxseSBtb2RpZmllZCBhbmQgdGhlIG9wZXJhdG9yIHJhbmsgY2hhbmdlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVucXVldWUob3AsIGZvcmNlKSB7XG4gIGNvbnN0IHEgPSBvcC5zdGFtcCA8IHRoaXMuX2Nsb2NrO1xuICBpZiAocSkgb3Auc3RhbXAgPSB0aGlzLl9jbG9jaztcblxuICBpZiAocSB8fCBmb3JjZSkge1xuICAgIG9wLnFyYW5rID0gb3AucmFuaztcblxuICAgIHRoaXMuX2hlYXAucHVzaChvcCk7XG4gIH1cbn1cbi8qKlxuICogUHJvdmlkZSBhIGNvcnJlY3QgcHVsc2UgZm9yIGV2YWx1YXRpbmcgYW4gb3BlcmF0b3IuIElmIHRoZSBvcGVyYXRvciBoYXMgYW5cbiAqIGV4cGxpY2l0IHNvdXJjZSBvcGVyYXRvciwgd2Ugd2lsbCB0cnkgdG8gcHVsbCB0aGUgcHVsc2UocykgZnJvbSBpdC5cbiAqIElmIHRoZXJlIGlzIGFuIGFycmF5IG9mIHNvdXJjZSBvcGVyYXRvcnMsIHdlIGJ1aWxkIGEgbXVsdGktcHVsc2UuXG4gKiBPdGhlcndpc2UsIHdlIHJldHVybiBhIGN1cnJlbnQgcHVsc2Ugd2l0aCBjb3JyZWN0IHNvdXJjZSBkYXRhLlxuICogSWYgdGhlIHB1bHNlIGlzIHRoZSBwdWxzZSBtYXAgaGFzIGFuIGV4cGxpY2l0IHRhcmdldCBzZXQsIHdlIHVzZSB0aGF0LlxuICogRWxzZSBpZiB0aGUgcHVsc2Ugb24gdGhlIHVwc3RyZWFtIHNvdXJjZSBvcGVyYXRvciBpcyBjdXJyZW50LCB3ZSB1c2UgdGhhdC5cbiAqIEVsc2Ugd2UgdXNlIHRoZSBwdWxzZSBmcm9tIHRoZSBwdWxzZSBtYXAsIGJ1dCBjb3B5IHRoZSBzb3VyY2UgdHVwbGUgYXJyYXkuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSBvcCAtIFRoZSBvcGVyYXRvciBmb3Igd2hpY2ggdG8gZ2V0IGFuIGlucHV0IHB1bHNlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGVdIC0gQW4gKG9wdGlvbmFsKSBlbmNvZGluZyBzZXQgbmFtZSB3aXRoIHdoaWNoIHRvXG4gKiAgIGFubm90YXRlIHRoZSByZXR1cm5lZCBwdWxzZS4gU2VlIHtAbGluayBydW59IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGdldFB1bHNlKG9wLCBlbmNvZGUpIHtcbiAgY29uc3QgcyA9IG9wLnNvdXJjZSxcbiAgICAgICAgc3RhbXAgPSB0aGlzLl9jbG9jaztcbiAgcmV0dXJuIHMgJiYgaXNBcnJheShzKSA/IG5ldyBNdWx0aVB1bHNlKHRoaXMsIHN0YW1wLCBzLm1hcChfID0+IF8ucHVsc2UpLCBlbmNvZGUpIDogdGhpcy5faW5wdXRbb3AuaWRdIHx8IHNpbmdsZVB1bHNlKHRoaXMuX3B1bHNlLCBzICYmIHMucHVsc2UpO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVQdWxzZShwLCBzKSB7XG4gIGlmIChzICYmIHMuc3RhbXAgPT09IHAuc3RhbXApIHtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIHAgPSBwLmZvcmsoKTtcblxuICBpZiAocyAmJiBzICE9PSBTdG9wUHJvcGFnYXRpb24pIHtcbiAgICBwLnNvdXJjZSA9IHMuc291cmNlO1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmNvbnN0IE5PX09QVCA9IHtcbiAgc2tpcDogZmFsc2UsXG4gIGZvcmNlOiBmYWxzZVxufTtcbi8qKlxuICogVG91Y2hlcyBhbiBvcGVyYXRvciwgc2NoZWR1bGluZyBpdCB0byBiZSBldmFsdWF0ZWQuIElmIGludm9rZWQgb3V0c2lkZSBvZlxuICogYSBwdWxzZSBwcm9wYWdhdGlvbiwgdGhlIG9wZXJhdG9yIHdpbGwgYmUgZXZhbHVhdGVkIHRoZSBuZXh0IHRpbWUgdGhpc1xuICogZGF0YWZsb3cgaXMgcnVuLiBJZiBpbnZva2VkIGluIHRoZSBtaWRzdCBvZiBwdWxzZSBwcm9wYWdhdGlvbiwgdGhlIG9wZXJhdG9yXG4gKiB3aWxsIGJlIHF1ZXVlZCBmb3IgZXZhbHVhdGlvbiBpZiBhbmQgb25seSBpZiB0aGUgb3BlcmF0b3IgaGFzIG5vdCB5ZXQgYmVlblxuICogZXZhbHVhdGVkIG9uIHRoZSBjdXJyZW50IHByb3BhZ2F0aW9uIHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIHRvdWNoLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBoYXNoLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgIGJlIHNraXBwZWQ6IGl0IHdpbGwgbm90IGJlIGV2YWx1YXRlZCwgYnV0IGl0cyBkZXBlbmRlbnRzIHdpbGwgYmUuXG4gKiBAcmV0dXJuIHtEYXRhZmxvd31cbiAqL1xuXG5mdW5jdGlvbiB0b3VjaChvcCwgb3B0aW9ucykge1xuICBjb25zdCBvcHQgPSBvcHRpb25zIHx8IE5PX09QVDtcblxuICBpZiAodGhpcy5fcHVsc2UpIHtcbiAgICAvLyBpZiBpbiBtaWRzdCBvZiBwcm9wYWdhdGlvbiwgYWRkIHRvIHByaW9yaXR5IHF1ZXVlXG4gICAgdGhpcy5fZW5xdWV1ZShvcCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCBxdWV1ZSBmb3IgbmV4dCBwcm9wYWdhdGlvblxuICAgIHRoaXMuX3RvdWNoZWQuYWRkKG9wKTtcbiAgfVxuXG4gIGlmIChvcHQuc2tpcCkgb3Auc2tpcCh0cnVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBvcGVyYXRvci5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBoYXNoLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZV0gLSBJZiB0cnVlLCB0aGUgb3BlcmF0b3Igd2lsbFxuICogICBiZSByZS1ldmFsdWF0ZWQgZXZlbiBpZiBpdHMgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgIGJlIHNraXBwZWQ6IGl0IHdpbGwgbm90IGJlIGV2YWx1YXRlZCwgYnV0IGl0cyBkZXBlbmRlbnRzIHdpbGwgYmUuXG4gKiBAcmV0dXJuIHtEYXRhZmxvd31cbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGUob3AsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnMgfHwgTk9fT1BUO1xuXG4gIGlmIChvcC5zZXQodmFsdWUpIHx8IG9wdC5mb3JjZSkge1xuICAgIHRoaXMudG91Y2gob3AsIG9wdCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogUHVsc2VzIGFuIG9wZXJhdG9yIHdpdGggYSBjaGFuZ2VzZXQgb2YgdHVwbGVzLiBJZiBpbnZva2VkIG91dHNpZGUgb2ZcbiAqIGEgcHVsc2UgcHJvcGFnYXRpb24sIHRoZSBwdWxzZSB3aWxsIGJlIGFwcGxpZWQgdGhlIG5leHQgdGltZSB0aGlzXG4gKiBkYXRhZmxvdyBpcyBydW4uIElmIGludm9rZWQgaW4gdGhlIG1pZHN0IG9mIHB1bHNlIHByb3BhZ2F0aW9uLCB0aGUgcHVsc2VcbiAqIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNldCBvZiBhY3RpdmUgcHVsc2VzIGFuZCB3aWxsIGJlIGFwcGxpZWQgaWYgYW5kXG4gKiBvbmx5IGlmIHRoZSB0YXJnZXQgb3BlcmF0b3IgaGFzIG5vdCB5ZXQgYmVlbiBldmFsdWF0ZWQgb24gdGhlIGN1cnJlbnRcbiAqIHByb3BhZ2F0aW9uIHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIHB1bHNlLlxuICogQHBhcmFtIHtDaGFuZ2VTZXR9IHZhbHVlIC0gVGhlIHR1cGxlIGNoYW5nZXNldCB0byBhcHBseS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgaGFzaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcF0gLSBJZiB0cnVlLCB0aGUgb3BlcmF0b3Igd2lsbFxuICogICBiZSBza2lwcGVkOiBpdCB3aWxsIG5vdCBiZSBldmFsdWF0ZWQsIGJ1dCBpdHMgZGVwZW5kZW50cyB3aWxsIGJlLlxuICogQHJldHVybiB7RGF0YWZsb3d9XG4gKi9cblxuZnVuY3Rpb24gcHVsc2Uob3AsIGNoYW5nZXNldCwgb3B0aW9ucykge1xuICB0aGlzLnRvdWNoKG9wLCBvcHRpb25zIHx8IE5PX09QVCk7XG4gIGNvbnN0IHAgPSBuZXcgUHVsc2UodGhpcywgdGhpcy5fY2xvY2sgKyAodGhpcy5fcHVsc2UgPyAwIDogMSkpLFxuICAgICAgICB0ID0gb3AucHVsc2UgJiYgb3AucHVsc2Uuc291cmNlIHx8IFtdO1xuICBwLnRhcmdldCA9IG9wO1xuICB0aGlzLl9pbnB1dFtvcC5pZF0gPSBjaGFuZ2VzZXQucHVsc2UocCwgdCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBIZWFwKGNtcCkge1xuICBsZXQgbm9kZXMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcjogKCkgPT4gbm9kZXMgPSBbXSxcbiAgICBzaXplOiAoKSA9PiBub2Rlcy5sZW5ndGgsXG4gICAgcGVlazogKCkgPT4gbm9kZXNbMF0sXG4gICAgcHVzaDogeCA9PiB7XG4gICAgICBub2Rlcy5wdXNoKHgpO1xuICAgICAgcmV0dXJuIHNpZnRkb3duKG5vZGVzLCAwLCBub2Rlcy5sZW5ndGggLSAxLCBjbXApO1xuICAgIH0sXG4gICAgcG9wOiAoKSA9PiB7XG4gICAgICBjb25zdCBsYXN0ID0gbm9kZXMucG9wKCk7XG4gICAgICBsZXQgaXRlbTtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gbm9kZXNbMF07XG4gICAgICAgIG5vZGVzWzBdID0gbGFzdDtcbiAgICAgICAgc2lmdHVwKG5vZGVzLCAwLCBjbXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbSA9IGxhc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc2lmdGRvd24oYXJyYXksIHN0YXJ0LCBpZHgsIGNtcCkge1xuICBsZXQgcGFyZW50LCBwaWR4O1xuICBjb25zdCBpdGVtID0gYXJyYXlbaWR4XTtcblxuICB3aGlsZSAoaWR4ID4gc3RhcnQpIHtcbiAgICBwaWR4ID0gaWR4IC0gMSA+PiAxO1xuICAgIHBhcmVudCA9IGFycmF5W3BpZHhdO1xuXG4gICAgaWYgKGNtcChpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgYXJyYXlbaWR4XSA9IHBhcmVudDtcbiAgICAgIGlkeCA9IHBpZHg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBhcnJheVtpZHhdID0gaXRlbTtcbn1cblxuZnVuY3Rpb24gc2lmdHVwKGFycmF5LCBpZHgsIGNtcCkge1xuICBjb25zdCBzdGFydCA9IGlkeCxcbiAgICAgICAgZW5kID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpdGVtID0gYXJyYXlbaWR4XTtcbiAgbGV0IGNpZHggPSAoaWR4IDw8IDEpICsgMSxcbiAgICAgIHJpZHg7XG5cbiAgd2hpbGUgKGNpZHggPCBlbmQpIHtcbiAgICByaWR4ID0gY2lkeCArIDE7XG5cbiAgICBpZiAocmlkeCA8IGVuZCAmJiBjbXAoYXJyYXlbY2lkeF0sIGFycmF5W3JpZHhdKSA+PSAwKSB7XG4gICAgICBjaWR4ID0gcmlkeDtcbiAgICB9XG5cbiAgICBhcnJheVtpZHhdID0gYXJyYXlbY2lkeF07XG4gICAgaWR4ID0gY2lkeDtcbiAgICBjaWR4ID0gKGlkeCA8PCAxKSArIDE7XG4gIH1cblxuICBhcnJheVtpZHhdID0gaXRlbTtcbiAgcmV0dXJuIHNpZnRkb3duKGFycmF5LCBzdGFydCwgaWR4LCBjbXApO1xufVxuXG4vKipcbiAqIEEgZGF0YWZsb3cgZ3JhcGggZm9yIHJlYWN0aXZlIHByb2Nlc3Npbmcgb2YgZGF0YSBzdHJlYW1zLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gRGF0YWZsb3coKSB7XG4gIHRoaXMubG9nZ2VyKGxvZ2dlcigpKTtcbiAgdGhpcy5sb2dMZXZlbChFcnJvcik7XG4gIHRoaXMuX2Nsb2NrID0gMDtcbiAgdGhpcy5fcmFuayA9IDA7XG4gIHRoaXMuX2xvY2FsZSA9IGRlZmF1bHRMb2NhbGUoKTtcblxuICB0cnkge1xuICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcigpO1xuICB9IGNhdGNoIChlKSB7Ly8gZG8gbm90aGluZyBpZiBsb2FkZXIgbW9kdWxlIGlzIHVuYXZhaWxhYmxlXG4gIH1cblxuICB0aGlzLl90b3VjaGVkID0gVW5pcXVlTGlzdChpZCk7XG4gIHRoaXMuX2lucHV0ID0ge307XG4gIHRoaXMuX3B1bHNlID0gbnVsbDtcbiAgdGhpcy5faGVhcCA9IEhlYXAoKGEsIGIpID0+IGEucXJhbmsgLSBiLnFyYW5rKTtcbiAgdGhpcy5fcG9zdHJ1biA9IFtdO1xufVxuXG5mdW5jdGlvbiBsb2dNZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvZ1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbkRhdGFmbG93LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRpbWVzdGFtcCBvZiB0aGlzIGRhdGFmbG93LiBUaGlzIHZhbHVlIHJlZmxlY3RzIHRoZVxuICAgKiB0aW1lc3RhbXAgb2YgdGhlIHByZXZpb3VzIGRhdGFmbG93IHJ1bi4gVGhlIGRhdGFmbG93IGlzIGluaXRpYWxpemVkXG4gICAqIHdpdGggYSBzdGFtcCB2YWx1ZSBvZiAwLiBUaGUgaW5pdGlhbCBydW4gb2YgdGhlIGRhdGFmbG93IHdpbGwgaGF2ZVxuICAgKiBhIHRpbWVzdGFwIG9mIDEsIGFuZCBzbyBvbi4gVGhpcyB2YWx1ZSB3aWxsIG1hdGNoIHRoZVxuICAgKiB7QGxpbmsgUHVsc2Uuc3RhbXB9IHByb3BlcnR5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGN1cnJlbnQgdGltZXN0YW1wIHZhbHVlLlxuICAgKi9cbiAgc3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb2NrO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGxvYWRlciBpbnN0YW5jZSB0byB1c2UgZm9yIGRhdGEgZmlsZSBsb2FkaW5nLiBBXG4gICAqIGxvYWRlciBvYmplY3QgbXVzdCBwcm92aWRlIGEgXCJsb2FkXCIgbWV0aG9kIGZvciBsb2FkaW5nIGZpbGVzIGFuZCBhXG4gICAqIFwic2FuaXRpemVcIiBtZXRob2QgZm9yIGNoZWNraW5nIFVSTC9maWxlbmFtZSB2YWxpZGl0eS4gQm90aCBtZXRob2RzXG4gICAqIHNob3VsZCBhY2NlcHQgYSBVUkkgYW5kIG9wdGlvbnMgaGFzaCBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm4gYSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxvYWRlZCBmaWxlIGNvbnRlbnRzIChsb2FkKSBvciBhIGhhc2ggY29udGFpbmluZ1xuICAgKiBzYW5pdGl6ZWQgVVJJIGRhdGEgd2l0aCB0aGUgc2FuaXRpemVkIHVybCBhc3NpZ25lZCB0byB0aGUgXCJocmVmXCIgcHJvcGVydHlcbiAgICogKHNhbml0aXplKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IF8gLSBUaGUgbG9hZGVyIGluc3RhbmNlIHRvIHVzZS5cbiAgICogQHJldHVybiB7b2JqZWN0fERhdGFmbG93fSAtIElmIG5vIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHJldHVybnNcbiAgICogICB0aGUgY3VycmVudCBsb2FkZXIgaW5zdGFuY2UuIE90aGVyd2lzZSByZXR1cm5zIHRoaXMgRGF0YWZsb3cgaW5zdGFuY2UuXG4gICAqL1xuICBsb2FkZXIoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9sb2FkZXIgPSBfO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGxvY2FsZSBpbnN0YW5jZSB0byB1c2UgZm9yIGZvcm1hdHRpbmcgYW5kIHBhcnNpbmdcbiAgICogc3RyaW5nIHZhbHVlcy4gVGhlIGxvY2FsZSBvYmplY3Qgc2hvdWxkIGJlIHByb3ZpZGVkIGJ5IHRoZVxuICAgKiB2ZWdhLWZvcm1hdCBsaWJyYXJ5LCBhbmQgaW5jbHVkZSBtZXRob2RzIHN1Y2ggYXMgZm9ybWF0LCB0aW1lRm9ybWF0LFxuICAgKiB1dGNGb3JtYXQsIHRpbWVQYXJzZSwgYW5kIHV0Y1BhcnNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gXyAtIFRoZSBsb2NhbGUgaW5zdGFuY2UgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R8RGF0YWZsb3d9IC0gSWYgbm8gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgcmV0dXJuc1xuICAgKiAgIHRoZSBjdXJyZW50IGxvY2FsZSBpbnN0YW5jZS4gT3RoZXJ3aXNlIHJldHVybnMgdGhpcyBEYXRhZmxvdyBpbnN0YW5jZS5cbiAgICovXG4gIGxvY2FsZShfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2xvY2FsZSA9IF87XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvZ2dlciBpbnN0YW5jZSB1c2VkIHRvIGxvZyBtZXNzYWdlcy4gSWYgbm8gYXJndW1lbnRzIGFyZVxuICAgKiBwcm92aWRlZCwgcmV0dXJucyB0aGUgY3VycmVudCBsb2dnZXIgaW5zdGFuY2UuIE90aGVyd2lzZSwgc2V0cyB0aGUgbG9nZ2VyXG4gICAqIGFuZCByZXR1cm4gdGhpcyBEYXRhZmxvdyBpbnN0YW5jZS4gUHJvdmlkZWQgbG9nZ2VycyBtdXN0IHN1cHBvcnQgdGhlIGZ1bGxcbiAgICogQVBJIG9mIGxvZ2dlciBvYmplY3RzIGdlbmVyYXRlZCBieSB0aGUgdmVnYS11dGlsIGxvZ2dlciBtZXRob2QuIE5vdGUgdGhhdFxuICAgKiBieSBkZWZhdWx0IHRoZSBsb2cgbGV2ZWwgb2YgdGhlIG5ldyBsb2dnZXIgd2lsbCBiZSB1c2VkOyB1c2UgdGhlIGxvZ0xldmVsXG4gICAqIG1ldGhvZCB0byBhZGp1c3QgdGhlIGxvZyBsZXZlbCBhcyBuZWVkZWQuXG4gICAqL1xuICBsb2dnZXIobG9nZ2VyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2xvZyA9IGxvZ2dlcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9ncyBhbiBlcnJvciBtZXNzYWdlLiBCeSBkZWZhdWx0LCBsb2dnZWQgbWVzc2FnZXMgYXJlIHdyaXR0ZW4gdG8gY29uc29sZVxuICAgKiBvdXRwdXQuIFRoZSBtZXNzYWdlIHdpbGwgb25seSBiZSBsb2dnZWQgaWYgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGlzIGhpZ2hcbiAgICogZW5vdWdoIHRvIHBlcm1pdCBlcnJvciBtZXNzYWdlcy5cbiAgICovXG4gIGVycm9yOiBsb2dNZXRob2QoJ2Vycm9yJyksXG5cbiAgLyoqXG4gICAqIExvZ3MgYSB3YXJuaW5nIG1lc3NhZ2UuIEJ5IGRlZmF1bHQsIGxvZ2dlZCBtZXNzYWdlcyBhcmUgd3JpdHRlbiB0byBjb25zb2xlXG4gICAqIG91dHB1dC4gVGhlIG1lc3NhZ2Ugd2lsbCBvbmx5IGJlIGxvZ2dlZCBpZiB0aGUgY3VycmVudCBsb2cgbGV2ZWwgaXMgaGlnaFxuICAgKiBlbm91Z2ggdG8gcGVybWl0IHdhcm5pbmcgbWVzc2FnZXMuXG4gICAqL1xuICB3YXJuOiBsb2dNZXRob2QoJ3dhcm4nKSxcblxuICAvKipcbiAgICogTG9ncyBhIGluZm9ybWF0aW9uIG1lc3NhZ2UuIEJ5IGRlZmF1bHQsIGxvZ2dlZCBtZXNzYWdlcyBhcmUgd3JpdHRlbiB0b1xuICAgKiBjb25zb2xlIG91dHB1dC4gVGhlIG1lc3NhZ2Ugd2lsbCBvbmx5IGJlIGxvZ2dlZCBpZiB0aGUgY3VycmVudCBsb2cgbGV2ZWwgaXNcbiAgICogaGlnaCBlbm91Z2ggdG8gcGVybWl0IGluZm9ybWF0aW9uIG1lc3NhZ2VzLlxuICAgKi9cbiAgaW5mbzogbG9nTWV0aG9kKCdpbmZvJyksXG5cbiAgLyoqXG4gICAqIExvZ3MgYSBkZWJ1ZyBtZXNzYWdlLiBCeSBkZWZhdWx0LCBsb2dnZWQgbWVzc2FnZXMgYXJlIHdyaXR0ZW4gdG8gY29uc29sZVxuICAgKiBvdXRwdXQuIFRoZSBtZXNzYWdlIHdpbGwgb25seSBiZSBsb2dnZWQgaWYgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGlzIGhpZ2hcbiAgICogZW5vdWdoIHRvIHBlcm1pdCBkZWJ1ZyBtZXNzYWdlcy5cbiAgICovXG4gIGRlYnVnOiBsb2dNZXRob2QoJ2RlYnVnJyksXG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgbG9nIGxldmVsLiBJZiBhbiBhcmd1bWVudCBpcyBwcm92aWRlZCwgaXRcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBuZXcgbG9nIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xldmVsXSAtIFNob3VsZCBiZSBvbmUgb2YgTm9uZSwgV2FybiwgSW5mb1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGN1cnJlbnQgbG9nIGxldmVsLlxuICAgKi9cbiAgbG9nTGV2ZWw6IGxvZ01ldGhvZCgnbGV2ZWwnKSxcblxuICAvKipcbiAgICogRW1wdHkgZW50cnkgdGhyZXNob2xkIGZvciBnYXJiYWdlIGNsZWFuaW5nLiBNYXAgZGF0YSBzdHJ1Y3R1cmVzIHdpbGxcbiAgICogcGVyZm9ybSBjbGVhbmluZyBvbmNlIHRoZSBudW1iZXIgb2YgZW1wdHkgZW50cmllcyBleGNlZWRzIHRoaXMgdmFsdWUuXG4gICAqL1xuICBjbGVhblRocmVzaG9sZDogMWU0LFxuICAvLyBPUEVSQVRPUiBSRUdJU1RSQVRJT05cbiAgYWRkLFxuICBjb25uZWN0LFxuICByYW5rLFxuICByZXJhbmssXG4gIC8vIE9QRVJBVE9SIFVQREFURVNcbiAgcHVsc2UsXG4gIHRvdWNoLFxuICB1cGRhdGUsXG4gIGNoYW5nZXNldCxcbiAgLy8gREFUQSBMT0FESU5HXG4gIGluZ2VzdCxcbiAgcGFyc2UsXG4gIHByZWxvYWQsXG4gIHJlcXVlc3QsXG4gIC8vIEVWRU5UIEhBTkRMSU5HXG4gIGV2ZW50cyxcbiAgb24sXG4gIC8vIFBVTFNFIFBST1BBR0FUSU9OXG4gIGV2YWx1YXRlLFxuICBydW4sXG4gIHJ1bkFzeW5jLFxuICBydW5BZnRlcixcbiAgX2VucXVldWU6IGVucXVldWUsXG4gIF9nZXRQdWxzZTogZ2V0UHVsc2Vcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIG9wZXJhdG9ycyB0aGF0IHByb2Nlc3MgZGF0YSB0dXBsZXMuXG4gKiBTdWJjbGFzc2VzIG11c3QgcHJvdmlkZSBhIHtAbGluayB0cmFuc2Zvcm19IG1ldGhvZCBmb3Igb3BlcmF0b3IgcHJvY2Vzc2luZy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSBbaW5pdF0gLSBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gW3NvdXJjZV0gLSBUaGUgb3BlcmF0b3IgZnJvbSB3aGljaCB0byByZWNlaXZlIHB1bHNlcy5cbiAqL1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oaW5pdCwgcGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgaW5pdCwgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFRyYW5zZm9ybSwgT3BlcmF0b3IsIHtcbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB7QGxpbmsgT3BlcmF0b3IuZXZhbHVhdGV9IGZvciB0cmFuc2Zvcm0gb3BlcmF0b3JzLlxuICAgKiBJbnRlcm5hbGx5LCB0aGlzIG1ldGhvZCBjYWxscyB7QGxpbmsgZXZhbHVhdGV9IHRvIHBlcmZvcm0gcHJvY2Vzc2luZy5cbiAgICogSWYge0BsaW5rIGV2YWx1YXRlfSByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZSBpbnB1dCBwdWxzZSBpcyByZXR1cm5lZC5cbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIE5PVCBiZSBvdmVycmlkZGVuLCBpbnN0ZWFkIG92ZXJycmlkZSB7QGxpbmsgZXZhbHVhdGV9LlxuICAgKiBAcGFyYW0ge1B1bHNlfSBwdWxzZSAtIHRoZSBjdXJyZW50IGRhdGFmbG93IHB1bHNlLlxuICAgKiBAcmV0dXJuIHRoZSBvdXRwdXQgcHVsc2UgZm9yIHRoaXMgb3BlcmF0b3IgKG9yIFN0b3BQcm9wYWdhdGlvbilcbiAgICovXG4gIHJ1bihwdWxzZSkge1xuICAgIGlmIChwdWxzZS5zdGFtcCA8IHRoaXMuc3RhbXApIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgbGV0IHJ2O1xuXG4gICAgaWYgKHRoaXMuc2tpcCgpKSB7XG4gICAgICB0aGlzLnNraXAoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBydiA9IHRoaXMuZXZhbHVhdGUocHVsc2UpO1xuICAgIH1cblxuICAgIHJ2ID0gcnYgfHwgcHVsc2U7XG5cbiAgICBpZiAocnYudGhlbikge1xuICAgICAgcnYgPSBydi50aGVuKF8gPT4gdGhpcy5wdWxzZSA9IF8pO1xuICAgIH0gZWxzZSBpZiAocnYgIT09IHB1bHNlLlN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgdGhpcy5wdWxzZSA9IHJ2O1xuICAgIH1cblxuICAgIHJldHVybiBydjtcbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHtAbGluayBPcGVyYXRvci5ldmFsdWF0ZX0gZm9yIHRyYW5zZm9ybSBvcGVyYXRvcnMuXG4gICAqIE1hcnNoYWxscyBwYXJhbWV0ZXIgdmFsdWVzIGFuZCB0aGVuIGludm9rZXMge0BsaW5rIHRyYW5zZm9ybX0uXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gdGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4ge1B1bHNlfSBUaGUgb3V0cHV0IHB1bHNlIChvciBTdG9wUHJvcGFnYXRpb24pLiBBIGZhbHN5IHJldHVyblxuICAgICAgIHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkKSB3aWxsIGxldCB0aGUgaW5wdXQgcHVsc2UgcGFzcyB0aHJvdWdoLlxuICAqL1xuICBldmFsdWF0ZShwdWxzZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMubWFyc2hhbGwocHVsc2Uuc3RhbXApLFxuICAgICAgICAgIG91dCA9IHRoaXMudHJhbnNmb3JtKHBhcmFtcywgcHVsc2UpO1xuICAgIHBhcmFtcy5jbGVhcigpO1xuICAgIHJldHVybiBvdXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgaW5jb21pbmcgcHVsc2VzLlxuICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgdHJhbnNmb3Jtcy5cbiAgICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBfIC0gVGhlIG9wZXJhdG9yIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gVGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4ge1B1bHNlfSBUaGUgb3V0cHV0IHB1bHNlIChvciBTdG9wUHJvcGFnYXRpb24pLiBBIGZhbHN5IHJldHVyblxuICAgKiAgIHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkKSB3aWxsIGxldCB0aGUgaW5wdXQgcHVsc2UgcGFzcyB0aHJvdWdoLlxuICAgKi9cbiAgdHJhbnNmb3JtKCkge31cblxufSk7XG5cbmNvbnN0IHRyYW5zZm9ybXMgPSB7fTtcbmZ1bmN0aW9uIGRlZmluaXRpb24odHlwZSkge1xuICBjb25zdCB0ID0gdHJhbnNmb3JtKHR5cGUpO1xuICByZXR1cm4gdCAmJiB0LkRlZmluaXRpb24gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybSh0eXBlKSB7XG4gIHR5cGUgPSB0eXBlICYmIHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRyYW5zZm9ybXMsIHR5cGUpID8gdHJhbnNmb3Jtc1t0eXBlXSA6IG51bGw7XG59XG5cbmV4cG9ydCB7IERhdGFmbG93LCBFdmVudFN0cmVhbSwgTXVsdGlQdWxzZSwgT3BlcmF0b3IsIFBhcmFtZXRlcnMsIFB1bHNlLCBUcmFuc2Zvcm0sIFVuaXF1ZUxpc3QsIGFzeW5jQ2FsbGJhY2ssIGNoYW5nZXNldCwgZGVmaW5pdGlvbiwgZGVyaXZlLCBpbmdlc3QkMSBhcyBpbmdlc3QsIGlzQ2hhbmdlU2V0LCBpc1R1cGxlLCByZWRlcml2ZSwgcmVwbGFjZSwgc3RhYmxlQ29tcGFyZSwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1zLCB0dXBsZWlkIH07XG4iLCJpbXBvcnQgeyBUcmFuc2Zvcm0sIGluZ2VzdCwgdHVwbGVpZCwgc3RhYmxlQ29tcGFyZSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgdGlja0NvdW50LCB0aWNrRm9ybWF0LCB2YWxpZFRpY2tzLCB0aWNrVmFsdWVzLCBTeW1ib2xMZWdlbmQsIGxhYmVsRm9ybWF0LCBsYWJlbFZhbHVlcywgR3JhZGllbnRMZWdlbmQsIHNjYWxlRnJhY3Rpb24sIGxhYmVsRnJhY3Rpb24sIHNjYWxlLCBpc0NvbnRpbnVvdXMsIFNlcXVlbnRpYWwsIExpbmVhciwgVGltZSwgVVRDLCBQb3csIFNxcnQsIE9yZGluYWwsIHNjYWxlSW1wbGljaXQsIExvZywgU3ltbG9nLCBpc0xvZ2FyaXRobWljLCBCaW5PcmRpbmFsLCBiYW5kU3BhY2UsIGlzSW50ZXJwb2xhdGluZywgaW50ZXJwb2xhdGVSYW5nZSwgcXVhbnRpemVJbnRlcnBvbGF0b3IsIGludGVycG9sYXRlQ29sb3JzLCBpbnRlcnBvbGF0ZSwgQmFuZCwgUG9pbnQsIHNjaGVtZSwgVGhyZXNob2xkLCBRdWFudGlsZSwgUXVhbnRpemUsIERpdmVyZ2luZyB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGlzQXJyYXksIGVycm9yLCBmYXN0bWFwLCBmYWxzeSwgaXNGdW5jdGlvbiwgY29uc3RhbnQsIHBlZWssIG9uZSwgdG9TZXQsIGlzU3RyaW5nLCB6b29tTG9nLCB6b29tUG93LCB6b29tU3ltbG9nLCB6b29tTGluZWFyLCBzdHJpbmdWYWx1ZSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBzdW0sIHJhbmdlIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgaW50ZXJwb2xhdGVSb3VuZCwgaW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGUkMSB9IGZyb20gJ2QzLWludGVycG9sYXRlJztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYXhpcyB0aWNrcyBmb3IgdmlzdWFsaXppbmcgYSBzcGF0aWFsIHNjYWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge1NjYWxlfSBwYXJhbXMuc2NhbGUgLSBUaGUgc2NhbGUgdG8gZ2VuZXJhdGUgdGlja3MgZm9yLlxuICogQHBhcmFtIHsqfSBbcGFyYW1zLmNvdW50PTEwXSAtIFRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgdGlja3MsIG9yXG4gKiAgIGRlc2lyZWQgdGljayBpbnRlcnZhbCwgdG8gdXNlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gW3BhcmFtcy52YWx1ZXNdIC0gVGhlIGV4YWN0IHRpY2sgdmFsdWVzIHRvIHVzZS5cbiAqICAgVGhlc2UgbXVzdCBiZSBsZWdhbCBkb21haW4gdmFsdWVzIGZvciB0aGUgcHJvdmlkZWQgc2NhbGUuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgY291bnQgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6c3RyaW5nfSBbcGFyYW1zLmZvcm1hdFNwZWNpZmllcl0gLSBBIGZvcm1hdCBzcGVjaWZpZXJcbiAqICAgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggc2NhbGUudGlja0Zvcm1hdC4gTGVnYWwgdmFsdWVzIGFyZVxuICogICBhbnkgdmFsaWQgZDMgNC4wIGZvcm1hdCBzcGVjaWZpZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopOnN0cmluZ30gW3BhcmFtcy5mb3JtYXRdIC0gVGhlIGZvcm1hdCBmdW5jdGlvbiB0byB1c2UuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgZm9ybWF0U3BlY2lmaWVyIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cblxuZnVuY3Rpb24gQXhpc1RpY2tzKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoQXhpc1RpY2tzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSkge1xuICAgICAgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlID0gcHVsc2UuZGF0YWZsb3cubG9jYWxlKCksXG4gICAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSxcbiAgICAgICAgdGlja3MgPSB0aGlzLnZhbHVlLFxuICAgICAgICBzY2FsZSA9IF8uc2NhbGUsXG4gICAgICAgIHRhbGx5ID0gXy5jb3VudCA9PSBudWxsID8gXy52YWx1ZXMgPyBfLnZhbHVlcy5sZW5ndGggOiAxMCA6IF8uY291bnQsXG4gICAgICAgIGNvdW50ID0gdGlja0NvdW50KHNjYWxlLCB0YWxseSwgXy5taW5zdGVwKSxcbiAgICAgICAgZm9ybWF0ID0gXy5mb3JtYXQgfHwgdGlja0Zvcm1hdChsb2NhbGUsIHNjYWxlLCBjb3VudCwgXy5mb3JtYXRTcGVjaWZpZXIsIF8uZm9ybWF0VHlwZSwgISFfLnZhbHVlcyksXG4gICAgICAgIHZhbHVlcyA9IF8udmFsdWVzID8gdmFsaWRUaWNrcyhzY2FsZSwgXy52YWx1ZXMsIGNvdW50KSA6IHRpY2tWYWx1ZXMoc2NhbGUsIGNvdW50KTtcbiAgICBpZiAodGlja3MpIG91dC5yZW0gPSB0aWNrcztcbiAgICB0aWNrcyA9IHZhbHVlcy5tYXAoKHZhbHVlLCBpKSA9PiBpbmdlc3Qoe1xuICAgICAgaW5kZXg6IGkgLyAodmFsdWVzLmxlbmd0aCAtIDEgfHwgMSksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBsYWJlbDogZm9ybWF0KHZhbHVlKVxuICAgIH0pKTtcblxuICAgIGlmIChfLmV4dHJhICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgLy8gYWRkIGFuIGV4dHJhIHRpY2sgcGVnZ2VkIHRvIHRoZSBpbml0aWFsIGRvbWFpbiB2YWx1ZVxuICAgICAgLy8gdGhpcyBpcyB1c2VkIHRvIGdlbmVyYXRlIGF4ZXMgd2l0aCAnYmlubmVkJyBkb21haW5zXG4gICAgICB0aWNrcy5wdXNoKGluZ2VzdCh7XG4gICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICB2YWx1ZTogdGlja3NbMF0udmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6ICcnXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3V0LnNvdXJjZSA9IHRpY2tzO1xuICAgIG91dC5hZGQgPSB0aWNrcztcbiAgICB0aGlzLnZhbHVlID0gdGlja3M7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBKb2lucyBhIHNldCBvZiBkYXRhIGVsZW1lbnRzIGFnYWluc3QgYSBzZXQgb2YgdmlzdWFsIGl0ZW1zLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG9iamVjdH0gW3BhcmFtcy5pdGVtXSAtIEFuIGl0ZW0gZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBbcGFyYW1zLmtleV0gLSBUaGUga2V5IGZpZWxkIGFzc29jaWF0aW5nIGRhdGEgYW5kIHZpc3VhbCBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBEYXRhSm9pbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEl0ZW1DcmVhdGUoKSB7XG4gIHJldHVybiBpbmdlc3Qoe30pO1xufVxuXG5mdW5jdGlvbiBuZXdNYXAoa2V5KSB7XG4gIGNvbnN0IG1hcCA9IGZhc3RtYXAoKS50ZXN0KHQgPT4gdC5leGl0KTtcblxuICBtYXAubG9va3VwID0gdCA9PiBtYXAuZ2V0KGtleSh0KSk7XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxuaW5oZXJpdHMoRGF0YUpvaW4sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgZGYgPSBwdWxzZS5kYXRhZmxvdyxcbiAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICBpdGVtID0gXy5pdGVtIHx8IGRlZmF1bHRJdGVtQ3JlYXRlLFxuICAgICAgICBrZXkgPSBfLmtleSB8fCB0dXBsZWlkLFxuICAgICAgICBtYXAgPSB0aGlzLnZhbHVlOyAvLyBwcmV2ZW50IHRyYW5zaWVudCAoZS5nLiwgaG92ZXIpIHJlcXVlc3RzIGZyb21cbiAgICAvLyBjYXNjYWRpbmcgYWNyb3NzIG1hcmtzIGRlcml2ZWQgZnJvbSBtYXJrc1xuXG4gICAgaWYgKGlzQXJyYXkob3V0LmVuY29kZSkpIHtcbiAgICAgIG91dC5lbmNvZGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChtYXAgJiYgKF8ubW9kaWZpZWQoJ2tleScpIHx8IHB1bHNlLm1vZGlmaWVkKGtleSkpKSB7XG4gICAgICBlcnJvcignRGF0YUpvaW4gZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllZCBrZXkgZnVuY3Rpb24gb3IgZmllbGRzLicpO1xuICAgIH1cblxuICAgIGlmICghbWFwKSB7XG4gICAgICBwdWxzZSA9IHB1bHNlLmFkZEFsbCgpO1xuICAgICAgdGhpcy52YWx1ZSA9IG1hcCA9IG5ld01hcChrZXkpO1xuICAgIH1cblxuICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiB7XG4gICAgICBjb25zdCBrID0ga2V5KHQpO1xuICAgICAgbGV0IHggPSBtYXAuZ2V0KGspO1xuXG4gICAgICBpZiAoeCkge1xuICAgICAgICBpZiAoeC5leGl0KSB7XG4gICAgICAgICAgbWFwLmVtcHR5LS07XG4gICAgICAgICAgb3V0LmFkZC5wdXNoKHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dC5tb2QucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGl0ZW0odCk7XG4gICAgICAgIG1hcC5zZXQoaywgeCk7XG4gICAgICAgIG91dC5hZGQucHVzaCh4KTtcbiAgICAgIH1cblxuICAgICAgeC5kYXR1bSA9IHQ7XG4gICAgICB4LmV4aXQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgY29uc3QgayA9IGtleSh0KSxcbiAgICAgICAgICAgIHggPSBtYXAuZ2V0KGspO1xuXG4gICAgICBpZiAoeCkge1xuICAgICAgICB4LmRhdHVtID0gdDtcbiAgICAgICAgb3V0Lm1vZC5wdXNoKHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICBjb25zdCBrID0ga2V5KHQpLFxuICAgICAgICAgICAgeCA9IG1hcC5nZXQoayk7XG5cbiAgICAgIGlmICh0ID09PSB4LmRhdHVtICYmICF4LmV4aXQpIHtcbiAgICAgICAgb3V0LnJlbS5wdXNoKHgpO1xuICAgICAgICB4LmV4aXQgPSB0cnVlO1xuICAgICAgICArK21hcC5lbXB0eTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocHVsc2UuY2hhbmdlZChwdWxzZS5BRERfTU9EKSkgb3V0Lm1vZGlmaWVzKCdkYXR1bScpO1xuXG4gICAgaWYgKHB1bHNlLmNsZWFuKCkgfHwgXy5jbGVhbiAmJiBtYXAuZW1wdHkgPiBkZi5jbGVhblRocmVzaG9sZCkge1xuICAgICAgZGYucnVuQWZ0ZXIobWFwLmNsZWFuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEludm9rZXMgZW5jb2RpbmcgZnVuY3Rpb25zIGZvciB2aXN1YWwgaXRlbXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byB0aGUgZW5jb2RpbmcgZnVuY3Rpb25zLiBUaGlzXG4gKiAgIHBhcmFtZXRlciBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0byBhbGwgaW52b2tlZCBlbmNvZGluZyBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcy5tb2Q9ZmFsc2VdIC0gRmxhZyBpbmRpY2F0aW5nIGlmIHR1cGxlcyBpbiB0aGUgaW5wdXRcbiAqICAgbW9kIHNldCB0aGF0IGFyZSB1bm1vZGlmaWVkIGJ5IGVuY29kZXJzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtLmVuY29kZXJzIC0gVGhlIGVuY29kaW5nIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QsIG9iamVjdCk6IGJvb2xlYW59IFtwYXJhbS5lbmNvZGVycy51cGRhdGVdIC0gVXBkYXRlIGVuY29kaW5nIHNldFxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QsIG9iamVjdCk6IGJvb2xlYW59IFtwYXJhbS5lbmNvZGVycy5lbnRlcl0gLSBFbnRlciBlbmNvZGluZyBzZXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0LCBvYmplY3QpOiBib29sZWFufSBbcGFyYW0uZW5jb2RlcnMuZXhpdF0gLSBFeGl0IGVuY29kaW5nIHNldFxuICovXG5cbmZ1bmN0aW9uIEVuY29kZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKEVuY29kZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFERF9SRU0pLFxuICAgICAgICBmbW9kID0gXy5tb2QgfHwgZmFsc2UsXG4gICAgICAgIGVuY29kZXJzID0gXy5lbmNvZGVycyxcbiAgICAgICAgZW5jb2RlID0gcHVsc2UuZW5jb2RlOyAvLyBpZiBhbiBhcnJheSwgdGhlIGVuY29kZSBkaXJlY3RpdmUgaW5jbHVkZXMgYWRkaXRpb25hbCBzZXRzXG4gICAgLy8gdGhhdCBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgZm9yIHRoZSBwcmltYXJ5IHNldCB0byBiZSBpbnZva2VkXG4gICAgLy8gZS5nLiwgb25seSBydW4gdGhlIHVwZGF0ZSBzZXQgaWYgdGhlIGhvdmVyIHNldCBpcyBkZWZpbmVkXG5cbiAgICBpZiAoaXNBcnJheShlbmNvZGUpKSB7XG4gICAgICBpZiAob3V0LmNoYW5nZWQoKSB8fCBlbmNvZGUuZXZlcnkoZSA9PiBlbmNvZGVyc1tlXSkpIHtcbiAgICAgICAgZW5jb2RlID0gZW5jb2RlWzBdO1xuICAgICAgICBvdXQuZW5jb2RlID0gbnVsbDsgLy8gY29uc3VtZSB0YXJnZXRlZCBlbmNvZGUgZGlyZWN0aXZlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH0gLy8gbWFyc2hhbGwgZW5jb2RlciBmdW5jdGlvbnNcblxuXG4gICAgdmFyIHJlZW50ZXIgPSBlbmNvZGUgPT09ICdlbnRlcicsXG4gICAgICAgIHVwZGF0ZSA9IGVuY29kZXJzLnVwZGF0ZSB8fCBmYWxzeSxcbiAgICAgICAgZW50ZXIgPSBlbmNvZGVycy5lbnRlciB8fCBmYWxzeSxcbiAgICAgICAgZXhpdCA9IGVuY29kZXJzLmV4aXQgfHwgZmFsc3ksXG4gICAgICAgIHNldCA9IChlbmNvZGUgJiYgIXJlZW50ZXIgPyBlbmNvZGVyc1tlbmNvZGVdIDogdXBkYXRlKSB8fCBmYWxzeTtcblxuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERCkpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiB7XG4gICAgICAgIGVudGVyKHQsIF8pO1xuICAgICAgICB1cGRhdGUodCwgXyk7XG4gICAgICB9KTtcbiAgICAgIG91dC5tb2RpZmllcyhlbnRlci5vdXRwdXQpO1xuICAgICAgb3V0Lm1vZGlmaWVzKHVwZGF0ZS5vdXRwdXQpO1xuXG4gICAgICBpZiAoc2V0ICE9PSBmYWxzeSAmJiBzZXQgIT09IHVwZGF0ZSkge1xuICAgICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgICAgIHNldCh0LCBfKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dC5tb2RpZmllcyhzZXQub3V0cHV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHVsc2UuY2hhbmdlZChwdWxzZS5SRU0pICYmIGV4aXQgIT09IGZhbHN5KSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgICBleGl0KHQsIF8pO1xuICAgICAgfSk7XG4gICAgICBvdXQubW9kaWZpZXMoZXhpdC5vdXRwdXQpO1xuICAgIH1cblxuICAgIGlmIChyZWVudGVyIHx8IHNldCAhPT0gZmFsc3kpIHtcbiAgICAgIGNvbnN0IGZsYWcgPSBwdWxzZS5NT0QgfCAoXy5tb2RpZmllZCgpID8gcHVsc2UuUkVGTE9XIDogMCk7XG5cbiAgICAgIGlmIChyZWVudGVyKSB7XG4gICAgICAgIHB1bHNlLnZpc2l0KGZsYWcsIHQgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vZCA9IGVudGVyKHQsIF8pIHx8IGZtb2Q7XG4gICAgICAgICAgaWYgKHNldCh0LCBfKSB8fCBtb2QpIG91dC5tb2QucHVzaCh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdXQubW9kLmxlbmd0aCkgb3V0Lm1vZGlmaWVzKGVudGVyLm91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWxzZS52aXNpdChmbGFnLCB0ID0+IHtcbiAgICAgICAgICBpZiAoc2V0KHQsIF8pIHx8IGZtb2QpIG91dC5tb2QucHVzaCh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXQubW9kLmxlbmd0aCkgb3V0Lm1vZGlmaWVzKHNldC5vdXRwdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuY2hhbmdlZCgpID8gb3V0IDogcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBsZWdlbmQgZW50cmllcyBmb3IgdmlzdWFsaXppbmcgYSBzY2FsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtTY2FsZX0gcGFyYW1zLnNjYWxlIC0gVGhlIHNjYWxlIHRvIGdlbmVyYXRlIGl0ZW1zIGZvci5cbiAqIEBwYXJhbSB7Kn0gW3BhcmFtcy5jb3VudD01XSAtIFRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgaXRlbXMsIG9yXG4gKiAgIGRlc2lyZWQgdGljayBpbnRlcnZhbCwgdG8gdXNlLlxuICogQHBhcmFtIHsqfSBbcGFyYW1zLmxpbWl0XSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvXG4gKiAgIGluY2x1ZGUgaW4gYSBzeW1ib2wgbGVnZW5kLlxuICogQHBhcmFtIHtBcnJheTwqPn0gW3BhcmFtcy52YWx1ZXNdIC0gVGhlIGV4YWN0IHRpY2sgdmFsdWVzIHRvIHVzZS5cbiAqICAgVGhlc2UgbXVzdCBiZSBsZWdhbCBkb21haW4gdmFsdWVzIGZvciB0aGUgcHJvdmlkZWQgc2NhbGUuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgY291bnQgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmZvcm1hdFNwZWNpZmllcl0gLSBBIGZvcm1hdCBzcGVjaWZpZXJcbiAqICAgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggc2NhbGUudGlja0Zvcm1hdC4gTGVnYWwgdmFsdWVzIGFyZVxuICogICBhbnkgdmFsaWQgRDMgZm9ybWF0IHNwZWNpZmllciBzdHJpbmcuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopOnN0cmluZ30gW3BhcmFtcy5mb3JtYXRdIC0gVGhlIGZvcm1hdCBmdW5jdGlvbiB0byB1c2UuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgZm9ybWF0U3BlY2lmaWVyIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cblxuZnVuY3Rpb24gTGVnZW5kRW50cmllcyhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG59XG5pbmhlcml0cyhMZWdlbmRFbnRyaWVzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgIT0gbnVsbCAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSBwdWxzZS5kYXRhZmxvdy5sb2NhbGUoKSxcbiAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICBpdGVtcyA9IHRoaXMudmFsdWUsXG4gICAgICAgIHR5cGUgPSBfLnR5cGUgfHwgU3ltYm9sTGVnZW5kLFxuICAgICAgICBzY2FsZSA9IF8uc2NhbGUsXG4gICAgICAgIGxpbWl0ID0gK18ubGltaXQsXG4gICAgICAgIGNvdW50ID0gdGlja0NvdW50KHNjYWxlLCBfLmNvdW50ID09IG51bGwgPyA1IDogXy5jb3VudCwgXy5taW5zdGVwKSxcbiAgICAgICAgbHNraXAgPSAhIV8udmFsdWVzIHx8IHR5cGUgPT09IFN5bWJvbExlZ2VuZCxcbiAgICAgICAgZm9ybWF0ID0gXy5mb3JtYXQgfHwgbGFiZWxGb3JtYXQobG9jYWxlLCBzY2FsZSwgY291bnQsIHR5cGUsIF8uZm9ybWF0U3BlY2lmaWVyLCBfLmZvcm1hdFR5cGUsIGxza2lwKSxcbiAgICAgICAgdmFsdWVzID0gXy52YWx1ZXMgfHwgbGFiZWxWYWx1ZXMoc2NhbGUsIGNvdW50KSxcbiAgICAgICAgZG9tYWluLFxuICAgICAgICBmcmFjdGlvbixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBlbGxpcHNpcztcbiAgICBpZiAoaXRlbXMpIG91dC5yZW0gPSBpdGVtcztcblxuICAgIGlmICh0eXBlID09PSBTeW1ib2xMZWdlbmQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB2YWx1ZXMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgcHVsc2UuZGF0YWZsb3cud2FybignU3ltYm9sIGxlZ2VuZCBjb3VudCBleGNlZWRzIGxpbWl0LCBmaWx0ZXJpbmcgaXRlbXMuJyk7XG4gICAgICAgIGl0ZW1zID0gdmFsdWVzLnNsaWNlKDAsIGxpbWl0IC0gMSk7XG4gICAgICAgIGVsbGlwc2lzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zID0gdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihzaXplID0gXy5zaXplKSkge1xuICAgICAgICAvLyBpZiBmaXJzdCB2YWx1ZSBtYXBzIHRvIHNpemUgemVybywgcmVtb3ZlIGZyb20gbGlzdCAodmVnYSM3MTcpXG4gICAgICAgIGlmICghXy52YWx1ZXMgJiYgc2NhbGUoaXRlbXNbMF0pID09PSAwKSB7XG4gICAgICAgICAgaXRlbXMgPSBpdGVtcy5zbGljZSgxKTtcbiAgICAgICAgfSAvLyBjb21wdXRlIHNpemUgb2Zmc2V0IGZvciBsZWdlbmQgZW50cmllc1xuXG5cbiAgICAgICAgb2Zmc2V0ID0gaXRlbXMucmVkdWNlKChtYXgsIHZhbHVlKSA9PiBNYXRoLm1heChtYXgsIHNpemUodmFsdWUsIF8pKSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gY29uc3RhbnQob2Zmc2V0ID0gc2l6ZSB8fCA4KTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMgPSBpdGVtcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4gaW5nZXN0KHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBsYWJlbDogZm9ybWF0KHZhbHVlLCBpbmRleCwgaXRlbXMpLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBzaXplOiBzaXplKHZhbHVlLCBfKVxuICAgICAgfSkpO1xuXG4gICAgICBpZiAoZWxsaXBzaXMpIHtcbiAgICAgICAgZWxsaXBzaXMgPSB2YWx1ZXNbaXRlbXMubGVuZ3RoXTtcbiAgICAgICAgaXRlbXMucHVzaChpbmdlc3Qoe1xuICAgICAgICAgIGluZGV4OiBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgbGFiZWw6IFwiXFx1MjAyNlwiLmNvbmNhdCh2YWx1ZXMubGVuZ3RoIC0gaXRlbXMubGVuZ3RoLCBcIiBlbnRyaWVzXCIpLFxuICAgICAgICAgIHZhbHVlOiBlbGxpcHNpcyxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICBzaXplOiBzaXplKGVsbGlwc2lzLCBfKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBHcmFkaWVudExlZ2VuZCkge1xuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluKCksIGZyYWN0aW9uID0gc2NhbGVGcmFjdGlvbihzY2FsZSwgZG9tYWluWzBdLCBwZWVrKGRvbWFpbikpOyAvLyBpZiBhdXRvbWF0aWMgbGFiZWwgZ2VuZXJhdGlvbiBwcm9kdWNlcyAyIG9yIGZld2VyIHZhbHVlcyxcbiAgICAgIC8vIHVzZSB0aGUgZG9tYWluIGVuZCBwb2ludHMgaW5zdGVhZCAoZml4ZXMgdmVnYS92ZWdhIzEzNjQpXG5cbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoIDwgMyAmJiAhXy52YWx1ZXMgJiYgZG9tYWluWzBdICE9PSBwZWVrKGRvbWFpbikpIHtcbiAgICAgICAgdmFsdWVzID0gW2RvbWFpblswXSwgcGVlayhkb21haW4pXTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMgPSB2YWx1ZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+IGluZ2VzdCh7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgbGFiZWw6IGZvcm1hdCh2YWx1ZSwgaW5kZXgsIHZhbHVlcyksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcGVyYzogZnJhY3Rpb24odmFsdWUpXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICAgIGZyYWN0aW9uID0gbGFiZWxGcmFjdGlvbihzY2FsZSk7XG4gICAgICBpdGVtcyA9IHZhbHVlcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4gaW5nZXN0KHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBsYWJlbDogZm9ybWF0KHZhbHVlLCBpbmRleCwgdmFsdWVzKSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBwZXJjOiBpbmRleCA/IGZyYWN0aW9uKHZhbHVlKSA6IDAsXG4gICAgICAgIHBlcmMyOiBpbmRleCA9PT0gc2l6ZSA/IDEgOiBmcmFjdGlvbih2YWx1ZXNbaW5kZXggKyAxXSlcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvdXQuc291cmNlID0gaXRlbXM7XG4gICAgb3V0LmFkZCA9IGl0ZW1zO1xuICAgIHRoaXMudmFsdWUgPSBpdGVtcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5jb25zdCBzb3VyY2VYID0gdCA9PiB0LnNvdXJjZS54O1xuXG5jb25zdCBzb3VyY2VZID0gdCA9PiB0LnNvdXJjZS55O1xuXG5jb25zdCB0YXJnZXRYID0gdCA9PiB0LnRhcmdldC54O1xuXG5jb25zdCB0YXJnZXRZID0gdCA9PiB0LnRhcmdldC55O1xuLyoqXG4gKiBMYXlvdXQgcGF0aHMgbGlua2luZyBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cblxuZnVuY3Rpb24gTGlua1BhdGgocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIHt9LCBwYXJhbXMpO1xufVxuTGlua1BhdGguRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnTGlua1BhdGgnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzb3VyY2VYJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiAnc291cmNlLngnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3VyY2VZJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiAnc291cmNlLnknXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0YXJnZXRYJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiAndGFyZ2V0LngnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0YXJnZXRZJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiAndGFyZ2V0LnknXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcmllbnQnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICdkZWZhdWx0JzogJ3ZlcnRpY2FsJyxcbiAgICAndmFsdWVzJzogWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ3JhZGlhbCddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzaGFwZScsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAnbGluZScsXG4gICAgJ3ZhbHVlcyc6IFsnbGluZScsICdhcmMnLCAnY3VydmUnLCAnZGlhZ29uYWwnLCAnb3J0aG9nb25hbCddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyZXF1aXJlJyxcbiAgICAndHlwZSc6ICdzaWduYWwnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdwYXRoJ1xuICB9XVxufTtcbmluaGVyaXRzKExpbmtQYXRoLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIHN4ID0gXy5zb3VyY2VYIHx8IHNvdXJjZVgsXG4gICAgICAgIHN5ID0gXy5zb3VyY2VZIHx8IHNvdXJjZVksXG4gICAgICAgIHR4ID0gXy50YXJnZXRYIHx8IHRhcmdldFgsXG4gICAgICAgIHR5ID0gXy50YXJnZXRZIHx8IHRhcmdldFksXG4gICAgICAgIGFzID0gXy5hcyB8fCAncGF0aCcsXG4gICAgICAgIG9yaWVudCA9IF8ub3JpZW50IHx8ICd2ZXJ0aWNhbCcsXG4gICAgICAgIHNoYXBlID0gXy5zaGFwZSB8fCAnbGluZScsXG4gICAgICAgIHBhdGggPSBQYXRocy5nZXQoc2hhcGUgKyAnLScgKyBvcmllbnQpIHx8IFBhdGhzLmdldChzaGFwZSk7XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIGVycm9yKCdMaW5rUGF0aCB1bnN1cHBvcnRlZCB0eXBlOiAnICsgXy5zaGFwZSArIChfLm9yaWVudCA/ICctJyArIF8ub3JpZW50IDogJycpKTtcbiAgICB9XG5cbiAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgICAgdFthc10gPSBwYXRoKHN4KHQpLCBzeSh0KSwgdHgodCksIHR5KHQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5jb25zdCBsaW5lID0gKHN4LCBzeSwgdHgsIHR5KSA9PiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0wnICsgdHggKyAnLCcgKyB0eTtcblxuY29uc3QgbGluZVIgPSAoc2EsIHNyLCB0YSwgdHIpID0+IGxpbmUoc3IgKiBNYXRoLmNvcyhzYSksIHNyICogTWF0aC5zaW4oc2EpLCB0ciAqIE1hdGguY29zKHRhKSwgdHIgKiBNYXRoLnNpbih0YSkpO1xuXG5jb25zdCBhcmMgPSAoc3gsIHN5LCB0eCwgdHkpID0+IHtcbiAgdmFyIGR4ID0gdHggLSBzeCxcbiAgICAgIGR5ID0gdHkgLSBzeSxcbiAgICAgIHJyID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAvIDIsXG4gICAgICByYSA9IDE4MCAqIE1hdGguYXRhbjIoZHksIGR4KSAvIE1hdGguUEk7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0EnICsgcnIgKyAnLCcgKyByciArICcgJyArIHJhICsgJyAwIDEnICsgJyAnICsgdHggKyAnLCcgKyB0eTtcbn07XG5cbmNvbnN0IGFyY1IgPSAoc2EsIHNyLCB0YSwgdHIpID0+IGFyYyhzciAqIE1hdGguY29zKHNhKSwgc3IgKiBNYXRoLnNpbihzYSksIHRyICogTWF0aC5jb3ModGEpLCB0ciAqIE1hdGguc2luKHRhKSk7XG5cbmNvbnN0IGN1cnZlID0gKHN4LCBzeSwgdHgsIHR5KSA9PiB7XG4gIGNvbnN0IGR4ID0gdHggLSBzeCxcbiAgICAgICAgZHkgPSB0eSAtIHN5LFxuICAgICAgICBpeCA9IDAuMiAqIChkeCArIGR5KSxcbiAgICAgICAgaXkgPSAwLjIgKiAoZHkgLSBkeCk7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0MnICsgKHN4ICsgaXgpICsgJywnICsgKHN5ICsgaXkpICsgJyAnICsgKHR4ICsgaXkpICsgJywnICsgKHR5IC0gaXgpICsgJyAnICsgdHggKyAnLCcgKyB0eTtcbn07XG5cbmNvbnN0IGN1cnZlUiA9IChzYSwgc3IsIHRhLCB0cikgPT4gY3VydmUoc3IgKiBNYXRoLmNvcyhzYSksIHNyICogTWF0aC5zaW4oc2EpLCB0ciAqIE1hdGguY29zKHRhKSwgdHIgKiBNYXRoLnNpbih0YSkpO1xuXG5jb25zdCBvcnRob1ggPSAoc3gsIHN5LCB0eCwgdHkpID0+ICdNJyArIHN4ICsgJywnICsgc3kgKyAnVicgKyB0eSArICdIJyArIHR4O1xuXG5jb25zdCBvcnRob1kgPSAoc3gsIHN5LCB0eCwgdHkpID0+ICdNJyArIHN4ICsgJywnICsgc3kgKyAnSCcgKyB0eCArICdWJyArIHR5O1xuXG5jb25zdCBvcnRob1IgPSAoc2EsIHNyLCB0YSwgdHIpID0+IHtcbiAgY29uc3Qgc2MgPSBNYXRoLmNvcyhzYSksXG4gICAgICAgIHNzID0gTWF0aC5zaW4oc2EpLFxuICAgICAgICB0YyA9IE1hdGguY29zKHRhKSxcbiAgICAgICAgdHMgPSBNYXRoLnNpbih0YSksXG4gICAgICAgIHNmID0gTWF0aC5hYnModGEgLSBzYSkgPiBNYXRoLlBJID8gdGEgPD0gc2EgOiB0YSA+IHNhO1xuICByZXR1cm4gJ00nICsgc3IgKiBzYyArICcsJyArIHNyICogc3MgKyAnQScgKyBzciArICcsJyArIHNyICsgJyAwIDAsJyArIChzZiA/IDEgOiAwKSArICcgJyArIHNyICogdGMgKyAnLCcgKyBzciAqIHRzICsgJ0wnICsgdHIgKiB0YyArICcsJyArIHRyICogdHM7XG59O1xuXG5jb25zdCBkaWFnb25hbFggPSAoc3gsIHN5LCB0eCwgdHkpID0+IHtcbiAgY29uc3QgbSA9IChzeCArIHR4KSAvIDI7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0MnICsgbSArICcsJyArIHN5ICsgJyAnICsgbSArICcsJyArIHR5ICsgJyAnICsgdHggKyAnLCcgKyB0eTtcbn07XG5cbmNvbnN0IGRpYWdvbmFsWSA9IChzeCwgc3ksIHR4LCB0eSkgPT4ge1xuICBjb25zdCBtID0gKHN5ICsgdHkpIC8gMjtcbiAgcmV0dXJuICdNJyArIHN4ICsgJywnICsgc3kgKyAnQycgKyBzeCArICcsJyArIG0gKyAnICcgKyB0eCArICcsJyArIG0gKyAnICcgKyB0eCArICcsJyArIHR5O1xufTtcblxuY29uc3QgZGlhZ29uYWxSID0gKHNhLCBzciwgdGEsIHRyKSA9PiB7XG4gIGNvbnN0IHNjID0gTWF0aC5jb3Moc2EpLFxuICAgICAgICBzcyA9IE1hdGguc2luKHNhKSxcbiAgICAgICAgdGMgPSBNYXRoLmNvcyh0YSksXG4gICAgICAgIHRzID0gTWF0aC5zaW4odGEpLFxuICAgICAgICBtciA9IChzciArIHRyKSAvIDI7XG4gIHJldHVybiAnTScgKyBzciAqIHNjICsgJywnICsgc3IgKiBzcyArICdDJyArIG1yICogc2MgKyAnLCcgKyBtciAqIHNzICsgJyAnICsgbXIgKiB0YyArICcsJyArIG1yICogdHMgKyAnICcgKyB0ciAqIHRjICsgJywnICsgdHIgKiB0cztcbn07XG5cbmNvbnN0IFBhdGhzID0gZmFzdG1hcCh7XG4gICdsaW5lJzogbGluZSxcbiAgJ2xpbmUtcmFkaWFsJzogbGluZVIsXG4gICdhcmMnOiBhcmMsXG4gICdhcmMtcmFkaWFsJzogYXJjUixcbiAgJ2N1cnZlJzogY3VydmUsXG4gICdjdXJ2ZS1yYWRpYWwnOiBjdXJ2ZVIsXG4gICdvcnRob2dvbmFsLWhvcml6b250YWwnOiBvcnRob1gsXG4gICdvcnRob2dvbmFsLXZlcnRpY2FsJzogb3J0aG9ZLFxuICAnb3J0aG9nb25hbC1yYWRpYWwnOiBvcnRob1IsXG4gICdkaWFnb25hbC1ob3Jpem9udGFsJzogZGlhZ29uYWxYLFxuICAnZGlhZ29uYWwtdmVydGljYWwnOiBkaWFnb25hbFksXG4gICdkaWFnb25hbC1yYWRpYWwnOiBkaWFnb25hbFJcbn0pO1xuXG4vKipcbiAqIFBpZSBhbmQgZG9udXQgY2hhcnQgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBzaXplIHBpZSBzZWdtZW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0YXJ0QW5nbGU9MF0gLSBUaGUgc3RhcnQgYW5nbGUgKGluIHJhZGlhbnMpIG9mIHRoZSBsYXlvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5lbmRBbmdsZT0yz4BdIC0gVGhlIGVuZCBhbmdsZSAoaW4gcmFkaWFucykgb2YgdGhlIGxheW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5zb3J0XSAtIEJvb2xlYW4gZmxhZyBmb3Igc29ydGluZyBzZWN0b3JzIGJ5IHZhbHVlLlxuICovXG5cbmZ1bmN0aW9uIFBpZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblBpZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdQaWUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGFydEFuZ2xlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZW5kQW5nbGUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiA2LjI4MzE4NTMwNzE3OTU4NlxuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddXG4gIH1dXG59O1xuaW5oZXJpdHMoUGllLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIGFzID0gXy5hcyB8fCBbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSxcbiAgICAgICAgc3RhcnRBbmdsZSA9IGFzWzBdLFxuICAgICAgICBlbmRBbmdsZSA9IGFzWzFdLFxuICAgICAgICBmaWVsZCA9IF8uZmllbGQgfHwgb25lLFxuICAgICAgICBzdGFydCA9IF8uc3RhcnRBbmdsZSB8fCAwLFxuICAgICAgICBzdG9wID0gXy5lbmRBbmdsZSAhPSBudWxsID8gXy5lbmRBbmdsZSA6IDIgKiBNYXRoLlBJLFxuICAgICAgICBkYXRhID0gcHVsc2Uuc291cmNlLFxuICAgICAgICB2YWx1ZXMgPSBkYXRhLm1hcChmaWVsZCksXG4gICAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBhID0gc3RhcnQsXG4gICAgICAgIGsgPSAoc3RvcCAtIHN0YXJ0KSAvIHN1bSh2YWx1ZXMpLFxuICAgICAgICBpbmRleCA9IHJhbmdlKG4pLFxuICAgICAgICBpLFxuICAgICAgICB0LFxuICAgICAgICB2O1xuXG4gICAgaWYgKF8uc29ydCkge1xuICAgICAgaW5kZXguc29ydCgoYSwgYikgPT4gdmFsdWVzW2FdIC0gdmFsdWVzW2JdKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2ID0gdmFsdWVzW2luZGV4W2ldXTtcbiAgICAgIHQgPSBkYXRhW2luZGV4W2ldXTtcbiAgICAgIHRbc3RhcnRBbmdsZV0gPSBhO1xuICAgICAgdFtlbmRBbmdsZV0gPSBhICs9IHYgKiBrO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuY29uc3QgREVGQVVMVF9DT1VOVCA9IDU7XG5cbmZ1bmN0aW9uIGluY2x1ZGVaZXJvKHNjYWxlKSB7XG4gIGNvbnN0IHR5cGUgPSBzY2FsZS50eXBlO1xuICByZXR1cm4gIXNjYWxlLmJpbnMgJiYgKHR5cGUgPT09IExpbmVhciB8fCB0eXBlID09PSBQb3cgfHwgdHlwZSA9PT0gU3FydCk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVQYWQodHlwZSkge1xuICByZXR1cm4gaXNDb250aW51b3VzKHR5cGUpICYmIHR5cGUgIT09IFNlcXVlbnRpYWw7XG59XG5cbmNvbnN0IFNLSVAgPSB0b1NldChbJ3NldCcsICdtb2RpZmllZCcsICdjbGVhcicsICd0eXBlJywgJ3NjaGVtZScsICdzY2hlbWVFeHRlbnQnLCAnc2NoZW1lQ291bnQnLCAnZG9tYWluJywgJ2RvbWFpbk1pbicsICdkb21haW5NaWQnLCAnZG9tYWluTWF4JywgJ2RvbWFpblJhdycsICdkb21haW5JbXBsaWNpdCcsICduaWNlJywgJ3plcm8nLCAnYmlucycsICdyYW5nZScsICdyYW5nZVN0ZXAnLCAncm91bmQnLCAncmV2ZXJzZScsICdpbnRlcnBvbGF0ZScsICdpbnRlcnBvbGF0ZUdhbW1hJ10pO1xuLyoqXG4gKiBNYWludGFpbnMgYSBzY2FsZSBmdW5jdGlvbiBtYXBwaW5nIGRhdGEgdmFsdWVzIHRvIHZpc3VhbCBjaGFubmVscy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIFNjYWxlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xuICB0aGlzLm1vZGlmaWVkKHRydWUpOyAvLyBhbHdheXMgdHJlYXQgYXMgbW9kaWZpZWRcbn1cbmluaGVyaXRzKFNjYWxlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIGRmID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICAgIHNjYWxlJDEgPSB0aGlzLnZhbHVlLFxuICAgICAgICBrZXkgPSBzY2FsZUtleShfKTtcblxuICAgIGlmICghc2NhbGUkMSB8fCBrZXkgIT09IHNjYWxlJDEudHlwZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHNjYWxlJDEgPSBzY2FsZShrZXkpKCk7XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gXykgaWYgKCFTS0lQW2tleV0pIHtcbiAgICAgIC8vIHBhZGRpbmcgaXMgYSBzY2FsZSBwcm9wZXJ0eSBmb3IgYmFuZC9wb2ludCBidXQgbm90IG90aGVyc1xuICAgICAgaWYgKGtleSA9PT0gJ3BhZGRpbmcnICYmIGluY2x1ZGVQYWQoc2NhbGUkMS50eXBlKSkgY29udGludWU7IC8vIGludm9rZSBzY2FsZSBwcm9wZXJ0eSBzZXR0ZXIsIHJhaXNlIHdhcm5pbmcgaWYgbm90IGZvdW5kXG5cbiAgICAgIGlzRnVuY3Rpb24oc2NhbGUkMVtrZXldKSA/IHNjYWxlJDFba2V5XShfW2tleV0pIDogZGYud2FybignVW5zdXBwb3J0ZWQgc2NhbGUgcHJvcGVydHk6ICcgKyBrZXkpO1xuICAgIH1cblxuICAgIGNvbmZpZ3VyZVJhbmdlKHNjYWxlJDEsIF8sIGNvbmZpZ3VyZUJpbnMoc2NhbGUkMSwgXywgY29uZmlndXJlRG9tYWluKHNjYWxlJDEsIF8sIGRmKSkpO1xuICAgIHJldHVybiBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHNjYWxlS2V5KF8pIHtcbiAgdmFyIHQgPSBfLnR5cGUsXG4gICAgICBkID0gJycsXG4gICAgICBuOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwcmUgVmVnYSA1LlxuXG4gIGlmICh0ID09PSBTZXF1ZW50aWFsKSByZXR1cm4gU2VxdWVudGlhbCArICctJyArIExpbmVhcjtcblxuICBpZiAoaXNDb250aW51b3VzQ29sb3IoXykpIHtcbiAgICBuID0gXy5yYXdEb21haW4gPyBfLnJhd0RvbWFpbi5sZW5ndGggOiBfLmRvbWFpbiA/IF8uZG9tYWluLmxlbmd0aCArICsoXy5kb21haW5NaWQgIT0gbnVsbCkgOiAwO1xuICAgIGQgPSBuID09PSAyID8gU2VxdWVudGlhbCArICctJyA6IG4gPT09IDMgPyBEaXZlcmdpbmcgKyAnLScgOiAnJztcbiAgfVxuXG4gIHJldHVybiAoZCArIHQgfHwgTGluZWFyKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBpc0NvbnRpbnVvdXNDb2xvcihfKSB7XG4gIGNvbnN0IHQgPSBfLnR5cGU7XG4gIHJldHVybiBpc0NvbnRpbnVvdXModCkgJiYgdCAhPT0gVGltZSAmJiB0ICE9PSBVVEMgJiYgKF8uc2NoZW1lIHx8IF8ucmFuZ2UgJiYgXy5yYW5nZS5sZW5ndGggJiYgXy5yYW5nZS5ldmVyeShpc1N0cmluZykpO1xufVxuXG5mdW5jdGlvbiBjb25maWd1cmVEb21haW4oc2NhbGUsIF8sIGRmKSB7XG4gIC8vIGNoZWNrIHJhdyBkb21haW4sIGlmIHByb3ZpZGVkIHVzZSB0aGF0IGFuZCBleGl0IGVhcmx5XG4gIGNvbnN0IHJhdyA9IHJhd0RvbWFpbihzY2FsZSwgXy5kb21haW5SYXcsIGRmKTtcbiAgaWYgKHJhdyA+IC0xKSByZXR1cm4gcmF3O1xuICB2YXIgZG9tYWluID0gXy5kb21haW4sXG4gICAgICB0eXBlID0gc2NhbGUudHlwZSxcbiAgICAgIHplcm8gPSBfLnplcm8gfHwgXy56ZXJvID09PSB1bmRlZmluZWQgJiYgaW5jbHVkZVplcm8oc2NhbGUpLFxuICAgICAgbixcbiAgICAgIG1pZDtcbiAgaWYgKCFkb21haW4pIHJldHVybiAwOyAvLyBhZGp1c3QgY29udGludW91cyBkb21haW4gZm9yIG1pbmltdW0gcGl4ZWwgcGFkZGluZ1xuXG4gIGlmIChpbmNsdWRlUGFkKHR5cGUpICYmIF8ucGFkZGluZyAmJiBkb21haW5bMF0gIT09IHBlZWsoZG9tYWluKSkge1xuICAgIGRvbWFpbiA9IHBhZERvbWFpbih0eXBlLCBkb21haW4sIF8ucmFuZ2UsIF8ucGFkZGluZywgXy5leHBvbmVudCwgXy5jb25zdGFudCk7XG4gIH0gLy8gYWRqdXN0IGRvbWFpbiBiYXNlZCBvbiB6ZXJvLCBtaW4sIG1heCBzZXR0aW5nc1xuXG5cbiAgaWYgKHplcm8gfHwgXy5kb21haW5NaW4gIT0gbnVsbCB8fCBfLmRvbWFpbk1heCAhPSBudWxsIHx8IF8uZG9tYWluTWlkICE9IG51bGwpIHtcbiAgICBuID0gKGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpKS5sZW5ndGggLSAxIHx8IDE7XG5cbiAgICBpZiAoemVybykge1xuICAgICAgaWYgKGRvbWFpblswXSA+IDApIGRvbWFpblswXSA9IDA7XG4gICAgICBpZiAoZG9tYWluW25dIDwgMCkgZG9tYWluW25dID0gMDtcbiAgICB9XG5cbiAgICBpZiAoXy5kb21haW5NaW4gIT0gbnVsbCkgZG9tYWluWzBdID0gXy5kb21haW5NaW47XG4gICAgaWYgKF8uZG9tYWluTWF4ICE9IG51bGwpIGRvbWFpbltuXSA9IF8uZG9tYWluTWF4O1xuXG4gICAgaWYgKF8uZG9tYWluTWlkICE9IG51bGwpIHtcbiAgICAgIG1pZCA9IF8uZG9tYWluTWlkO1xuICAgICAgY29uc3QgaSA9IG1pZCA+IGRvbWFpbltuXSA/IG4gKyAxIDogbWlkIDwgZG9tYWluWzBdID8gMCA6IG47XG4gICAgICBpZiAoaSAhPT0gbikgZGYud2FybignU2NhbGUgZG9tYWluTWlkIGV4Y2VlZHMgZG9tYWluIG1pbiBvciBtYXguJywgbWlkKTtcbiAgICAgIGRvbWFpbi5zcGxpY2UoaSwgMCwgbWlkKTtcbiAgICB9XG4gIH0gLy8gc2V0IHRoZSBzY2FsZSBkb21haW5cblxuXG4gIHNjYWxlLmRvbWFpbihkb21haW5DaGVjayh0eXBlLCBkb21haW4sIGRmKSk7IC8vIGlmIG9yZGluYWwgc2NhbGUgZG9tYWluIGlzIGRlZmluZWQsIHByZXZlbnQgaW1wbGljaXRcbiAgLy8gZG9tYWluIGNvbnN0cnVjdGlvbiBhcyBzaWRlLWVmZmVjdCBvZiBzY2FsZSBsb29rdXBcblxuICBpZiAodHlwZSA9PT0gT3JkaW5hbCkge1xuICAgIHNjYWxlLnVua25vd24oXy5kb21haW5JbXBsaWNpdCA/IHNjYWxlSW1wbGljaXQgOiB1bmRlZmluZWQpO1xuICB9IC8vIHBlcmZvcm0gJ25pY2UnIGFkanVzdG1lbnQgYXMgcmVxdWVzdGVkXG5cblxuICBpZiAoXy5uaWNlICYmIHNjYWxlLm5pY2UpIHtcbiAgICBzY2FsZS5uaWNlKF8ubmljZSAhPT0gdHJ1ZSAmJiB0aWNrQ291bnQoc2NhbGUsIF8ubmljZSkgfHwgbnVsbCk7XG4gIH0gLy8gcmV0dXJuIHRoZSBjYXJkaW5hbGl0eSBvZiB0aGUgZG9tYWluXG5cblxuICByZXR1cm4gZG9tYWluLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gcmF3RG9tYWluKHNjYWxlLCByYXcsIGRmKSB7XG4gIGlmIChyYXcpIHtcbiAgICBzY2FsZS5kb21haW4oZG9tYWluQ2hlY2soc2NhbGUudHlwZSwgcmF3LCBkZikpO1xuICAgIHJldHVybiByYXcubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWREb21haW4odHlwZSwgZG9tYWluLCByYW5nZSwgcGFkLCBleHBvbmVudCwgY29uc3RhbnQpIHtcbiAgdmFyIHNwYW4gPSBNYXRoLmFicyhwZWVrKHJhbmdlKSAtIHJhbmdlWzBdKSxcbiAgICAgIGZyYWMgPSBzcGFuIC8gKHNwYW4gLSAyICogcGFkKSxcbiAgICAgIGQgPSB0eXBlID09PSBMb2cgPyB6b29tTG9nKGRvbWFpbiwgbnVsbCwgZnJhYykgOiB0eXBlID09PSBTcXJ0ID8gem9vbVBvdyhkb21haW4sIG51bGwsIGZyYWMsIDAuNSkgOiB0eXBlID09PSBQb3cgPyB6b29tUG93KGRvbWFpbiwgbnVsbCwgZnJhYywgZXhwb25lbnQgfHwgMSkgOiB0eXBlID09PSBTeW1sb2cgPyB6b29tU3ltbG9nKGRvbWFpbiwgbnVsbCwgZnJhYywgY29uc3RhbnQgfHwgMSkgOiB6b29tTGluZWFyKGRvbWFpbiwgbnVsbCwgZnJhYyk7XG4gIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpO1xuICBkb21haW5bMF0gPSBkWzBdO1xuICBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdID0gZFsxXTtcbiAgcmV0dXJuIGRvbWFpbjtcbn1cblxuZnVuY3Rpb24gZG9tYWluQ2hlY2sodHlwZSwgZG9tYWluLCBkZikge1xuICBpZiAoaXNMb2dhcml0aG1pYyh0eXBlKSkge1xuICAgIC8vIHN1bSBzaWducyBvZiBkb21haW4gdmFsdWVzXG4gICAgLy8gaWYgYWxsIHBvcyBvciBhbGwgbmVnLCBhYnMoc3VtKSA9PT0gZG9tYWluLmxlbmd0aFxuICAgIHZhciBzID0gTWF0aC5hYnMoZG9tYWluLnJlZHVjZSgocywgdikgPT4gcyArICh2IDwgMCA/IC0xIDogdiA+IDAgPyAxIDogMCksIDApKTtcblxuICAgIGlmIChzICE9PSBkb21haW4ubGVuZ3RoKSB7XG4gICAgICBkZi53YXJuKCdMb2cgc2NhbGUgZG9tYWluIGluY2x1ZGVzIHplcm86ICcgKyBzdHJpbmdWYWx1ZShkb21haW4pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tYWluO1xufVxuXG5mdW5jdGlvbiBjb25maWd1cmVCaW5zKHNjYWxlLCBfLCBjb3VudCkge1xuICBsZXQgYmlucyA9IF8uYmlucztcblxuICBpZiAoYmlucyAmJiAhaXNBcnJheShiaW5zKSkge1xuICAgIC8vIGdlbmVyYXRlIGJpbiBib3VuZGFyeSBhcnJheVxuICAgIGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgICAgIGxvID0gZG9tYWluWzBdLFxuICAgICAgICAgIGhpID0gcGVlayhkb21haW4pLFxuICAgICAgICAgIHN0ZXAgPSBiaW5zLnN0ZXA7XG4gICAgbGV0IHN0YXJ0ID0gYmlucy5zdGFydCA9PSBudWxsID8gbG8gOiBiaW5zLnN0YXJ0LFxuICAgICAgICBzdG9wID0gYmlucy5zdG9wID09IG51bGwgPyBoaSA6IGJpbnMuc3RvcDtcbiAgICBpZiAoIXN0ZXApIGVycm9yKCdTY2FsZSBiaW5zIHBhcmFtZXRlciBtaXNzaW5nIHN0ZXAgcHJvcGVydHkuJyk7XG4gICAgaWYgKHN0YXJ0IDwgbG8pIHN0YXJ0ID0gc3RlcCAqIE1hdGguY2VpbChsbyAvIHN0ZXApO1xuICAgIGlmIChzdG9wID4gaGkpIHN0b3AgPSBzdGVwICogTWF0aC5mbG9vcihoaSAvIHN0ZXApO1xuICAgIGJpbnMgPSByYW5nZShzdGFydCwgc3RvcCArIHN0ZXAgLyAyLCBzdGVwKTtcbiAgfVxuXG4gIGlmIChiaW5zKSB7XG4gICAgLy8gYXNzaWduIGJpbiBib3VuZGFyaWVzIHRvIHNjYWxlIGluc3RhbmNlXG4gICAgc2NhbGUuYmlucyA9IGJpbnM7XG4gIH0gZWxzZSBpZiAoc2NhbGUuYmlucykge1xuICAgIC8vIG5vIGN1cnJlbnQgYmlucywgcmVtb3ZlIGJpbnMgaWYgcHJldmlvdXNseSBzZXRcbiAgICBkZWxldGUgc2NhbGUuYmlucztcbiAgfSAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBiaW4tb3JkaW5hbCBzY2FsZXNcblxuXG4gIGlmIChzY2FsZS50eXBlID09PSBCaW5PcmRpbmFsKSB7XG4gICAgaWYgKCFiaW5zKSB7XG4gICAgICAvLyB0aGUgZG9tYWluIHNwZWNpZmllcyB0aGUgYmluc1xuICAgICAgc2NhbGUuYmlucyA9IHNjYWxlLmRvbWFpbigpO1xuICAgIH0gZWxzZSBpZiAoIV8uZG9tYWluICYmICFfLmRvbWFpblJhdykge1xuICAgICAgLy8gdGhlIGJpbnMgc3BlY2lmeSB0aGUgZG9tYWluXG4gICAgICBzY2FsZS5kb21haW4oYmlucyk7XG4gICAgICBjb3VudCA9IGJpbnMubGVuZ3RoO1xuICAgIH1cbiAgfSAvLyByZXR1cm4gZG9tYWluIGNhcmRpbmFsaXR5XG5cblxuICByZXR1cm4gY291bnQ7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZVJhbmdlKHNjYWxlLCBfLCBjb3VudCkge1xuICB2YXIgdHlwZSA9IHNjYWxlLnR5cGUsXG4gICAgICByb3VuZCA9IF8ucm91bmQgfHwgZmFsc2UsXG4gICAgICByYW5nZSA9IF8ucmFuZ2U7IC8vIGlmIHJhbmdlIHN0ZXAgc3BlY2lmaWVkLCBjYWxjdWxhdGUgZnVsbCByYW5nZSBleHRlbnRcblxuICBpZiAoXy5yYW5nZVN0ZXAgIT0gbnVsbCkge1xuICAgIHJhbmdlID0gY29uZmlndXJlUmFuZ2VTdGVwKHR5cGUsIF8sIGNvdW50KTtcbiAgfSAvLyBlbHNlIGlmIGEgcmFuZ2Ugc2NoZW1lIGlzIGRlZmluZWQsIHVzZSB0aGF0XG4gIGVsc2UgaWYgKF8uc2NoZW1lKSB7XG4gICAgICByYW5nZSA9IGNvbmZpZ3VyZVNjaGVtZSh0eXBlLCBfLCBjb3VudCk7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHJhbmdlKSkge1xuICAgICAgICBpZiAoc2NhbGUuaW50ZXJwb2xhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYWxlLmludGVycG9sYXRvcihyYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoXCJTY2FsZSB0eXBlIFwiLmNvbmNhdCh0eXBlLCBcIiBkb2VzIG5vdCBzdXBwb3J0IGludGVycG9sYXRpbmcgY29sb3Igc2NoZW1lcy5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBnaXZlbiBhIHJhbmdlIGFycmF5IGZvciBhbiBpbnRlcnBvbGF0aW5nIHNjYWxlLCBjb252ZXJ0IHRvIGludGVycG9sYXRvclxuXG5cbiAgaWYgKHJhbmdlICYmIGlzSW50ZXJwb2xhdGluZyh0eXBlKSkge1xuICAgIHJldHVybiBzY2FsZS5pbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVDb2xvcnMoZmxpcChyYW5nZSwgXy5yZXZlcnNlKSwgXy5pbnRlcnBvbGF0ZSwgXy5pbnRlcnBvbGF0ZUdhbW1hKSk7XG4gIH0gLy8gY29uZmlndXJlIHJvdW5kaW5nIC8gaW50ZXJwb2xhdGlvblxuXG5cbiAgaWYgKHJhbmdlICYmIF8uaW50ZXJwb2xhdGUgJiYgc2NhbGUuaW50ZXJwb2xhdGUpIHtcbiAgICBzY2FsZS5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZShfLmludGVycG9sYXRlLCBfLmludGVycG9sYXRlR2FtbWEpKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNjYWxlLnJvdW5kKSkge1xuICAgIHNjYWxlLnJvdW5kKHJvdW5kKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNjYWxlLnJhbmdlUm91bmQpKSB7XG4gICAgc2NhbGUuaW50ZXJwb2xhdGUocm91bmQgPyBpbnRlcnBvbGF0ZVJvdW5kIDogaW50ZXJwb2xhdGUkMSk7XG4gIH1cblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKGZsaXAocmFuZ2UsIF8ucmV2ZXJzZSkpO1xufVxuXG5mdW5jdGlvbiBjb25maWd1cmVSYW5nZVN0ZXAodHlwZSwgXywgY291bnQpIHtcbiAgaWYgKHR5cGUgIT09IEJhbmQgJiYgdHlwZSAhPT0gUG9pbnQpIHtcbiAgICBlcnJvcignT25seSBiYW5kIGFuZCBwb2ludCBzY2FsZXMgc3VwcG9ydCByYW5nZVN0ZXAuJyk7XG4gIH0gLy8gY2FsY3VsYXRlIGZ1bGwgcmFuZ2UgYmFzZWQgb24gcmVxdWVzdGVkIHN0ZXAgc2l6ZSBhbmQgcGFkZGluZ1xuXG5cbiAgdmFyIG91dGVyID0gKF8ucGFkZGluZ091dGVyICE9IG51bGwgPyBfLnBhZGRpbmdPdXRlciA6IF8ucGFkZGluZykgfHwgMCxcbiAgICAgIGlubmVyID0gdHlwZSA9PT0gUG9pbnQgPyAxIDogKF8ucGFkZGluZ0lubmVyICE9IG51bGwgPyBfLnBhZGRpbmdJbm5lciA6IF8ucGFkZGluZykgfHwgMDtcbiAgcmV0dXJuIFswLCBfLnJhbmdlU3RlcCAqIGJhbmRTcGFjZShjb3VudCwgaW5uZXIsIG91dGVyKV07XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZVNjaGVtZSh0eXBlLCBfLCBjb3VudCkge1xuICB2YXIgZXh0ZW50ID0gXy5zY2hlbWVFeHRlbnQsXG4gICAgICBuYW1lLFxuICAgICAgc2NoZW1lJDE7XG5cbiAgaWYgKGlzQXJyYXkoXy5zY2hlbWUpKSB7XG4gICAgc2NoZW1lJDEgPSBpbnRlcnBvbGF0ZUNvbG9ycyhfLnNjaGVtZSwgXy5pbnRlcnBvbGF0ZSwgXy5pbnRlcnBvbGF0ZUdhbW1hKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gXy5zY2hlbWUudG9Mb3dlckNhc2UoKTtcbiAgICBzY2hlbWUkMSA9IHNjaGVtZShuYW1lKTtcbiAgICBpZiAoIXNjaGVtZSQxKSBlcnJvcihcIlVucmVjb2duaXplZCBzY2hlbWUgbmFtZTogXCIuY29uY2F0KF8uc2NoZW1lKSk7XG4gIH0gLy8gZGV0ZXJtaW5lIHNpemUgZm9yIHBvdGVudGlhbCBkaXNjcmV0ZSByYW5nZVxuXG5cbiAgY291bnQgPSB0eXBlID09PSBUaHJlc2hvbGQgPyBjb3VudCArIDEgOiB0eXBlID09PSBCaW5PcmRpbmFsID8gY291bnQgLSAxIDogdHlwZSA9PT0gUXVhbnRpbGUgfHwgdHlwZSA9PT0gUXVhbnRpemUgPyArXy5zY2hlbWVDb3VudCB8fCBERUZBVUxUX0NPVU5UIDogY291bnQ7IC8vIGFkanVzdCBhbmQvb3IgcXVhbnRpemUgc2NoZW1lIGFzIGFwcHJvcHJpYXRlXG5cbiAgcmV0dXJuIGlzSW50ZXJwb2xhdGluZyh0eXBlKSA/IGFkanVzdFNjaGVtZShzY2hlbWUkMSwgZXh0ZW50LCBfLnJldmVyc2UpIDogaXNGdW5jdGlvbihzY2hlbWUkMSkgPyBxdWFudGl6ZUludGVycG9sYXRvcihhZGp1c3RTY2hlbWUoc2NoZW1lJDEsIGV4dGVudCksIGNvdW50KSA6IHR5cGUgPT09IE9yZGluYWwgPyBzY2hlbWUkMSA6IHNjaGVtZSQxLnNsaWNlKDAsIGNvdW50KTtcbn1cblxuZnVuY3Rpb24gYWRqdXN0U2NoZW1lKHNjaGVtZSwgZXh0ZW50LCByZXZlcnNlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHNjaGVtZSkgJiYgKGV4dGVudCB8fCByZXZlcnNlKSA/IGludGVycG9sYXRlUmFuZ2Uoc2NoZW1lLCBmbGlwKGV4dGVudCB8fCBbMCwgMV0sIHJldmVyc2UpKSA6IHNjaGVtZTtcbn1cblxuZnVuY3Rpb24gZmxpcChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gcmV2ZXJzZSA/IGFycmF5LnNsaWNlKCkucmV2ZXJzZSgpIDogYXJyYXk7XG59XG5cbi8qKlxuICogU29ydHMgc2NlbmVncmFwaCBpdGVtcyBpbiB0aGUgcHVsc2Ugc291cmNlIGFycmF5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEEgY29tcGFyYXRvclxuICogICBmdW5jdGlvbiBmb3Igc29ydGluZyB0dXBsZXMuXG4gKi9cblxuZnVuY3Rpb24gU29ydEl0ZW1zKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoU29ydEl0ZW1zLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgbW9kID0gXy5tb2RpZmllZCgnc29ydCcpIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREKSB8fCBwdWxzZS5tb2RpZmllZChfLnNvcnQuZmllbGRzKSB8fCBwdWxzZS5tb2RpZmllZCgnZGF0dW0nKTtcbiAgICBpZiAobW9kKSBwdWxzZS5zb3VyY2Uuc29ydChzdGFibGVDb21wYXJlKF8uc29ydCkpO1xuICAgIHRoaXMubW9kaWZpZWQobW9kKTtcbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbmNvbnN0IFplcm8gPSAnemVybycsXG4gICAgICBDZW50ZXIgPSAnY2VudGVyJyxcbiAgICAgIE5vcm1hbGl6ZSA9ICdub3JtYWxpemUnLFxuICAgICAgRGVmT3V0cHV0ID0gWyd5MCcsICd5MSddO1xuLyoqXG4gKiBTdGFjayBsYXlvdXQgZm9yIHZpc3VhbGl6YXRpb24gZWxlbWVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIHN0YWNrLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29ycyB0byBncm91cGJ5LlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3Qsb2JqZWN0KTogbnVtYmVyfSBbcGFyYW1zLnNvcnRdIC0gQSBjb21wYXJhdG9yIGZvciBzdGFjayBzb3J0aW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvZmZzZXQ9J3plcm8nXSAtIFN0YWNrIGJhc2VsaW5lIG9mZnNldC4gT25lIG9mICd6ZXJvJywgJ2NlbnRlcicsICdub3JtYWxpemUnLlxuICovXG5cbmZ1bmN0aW9uIFN0YWNrKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuU3RhY2suRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnU3RhY2snLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ29mZnNldCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiBaZXJvLFxuICAgICd2YWx1ZXMnOiBbWmVybywgQ2VudGVyLCBOb3JtYWxpemVdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogRGVmT3V0cHV0XG4gIH1dXG59O1xuaW5oZXJpdHMoU3RhY2ssIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgYXMgPSBfLmFzIHx8IERlZk91dHB1dCxcbiAgICAgICAgeTAgPSBhc1swXSxcbiAgICAgICAgeTEgPSBhc1sxXSxcbiAgICAgICAgc29ydCA9IHN0YWJsZUNvbXBhcmUoXy5zb3J0KSxcbiAgICAgICAgZmllbGQgPSBfLmZpZWxkIHx8IG9uZSxcbiAgICAgICAgc3RhY2sgPSBfLm9mZnNldCA9PT0gQ2VudGVyID8gc3RhY2tDZW50ZXIgOiBfLm9mZnNldCA9PT0gTm9ybWFsaXplID8gc3RhY2tOb3JtYWxpemUgOiBzdGFja1plcm8sXG4gICAgICAgIGdyb3VwcyxcbiAgICAgICAgaSxcbiAgICAgICAgbixcbiAgICAgICAgbWF4OyAvLyBwYXJ0aXRpb24sIHN1bSwgYW5kIHNvcnQgdGhlIHN0YWNrIGdyb3Vwc1xuXG4gICAgZ3JvdXBzID0gcGFydGl0aW9uKHB1bHNlLnNvdXJjZSwgXy5ncm91cGJ5LCBzb3J0LCBmaWVsZCk7IC8vIGNvbXB1dGUgc3RhY2sgbGF5b3V0cyBwZXIgZ3JvdXBcblxuICAgIGZvciAoaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoLCBtYXggPSBncm91cHMubWF4OyBpIDwgbjsgKytpKSB7XG4gICAgICBzdGFjayhncm91cHNbaV0sIG1heCwgZmllbGQsIHkwLCB5MSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gc3RhY2tDZW50ZXIoZ3JvdXAsIG1heCwgZmllbGQsIHkwLCB5MSkge1xuICB2YXIgbGFzdCA9IChtYXggLSBncm91cC5zdW0pIC8gMixcbiAgICAgIG0gPSBncm91cC5sZW5ndGgsXG4gICAgICBqID0gMCxcbiAgICAgIHQ7XG5cbiAgZm9yICg7IGogPCBtOyArK2opIHtcbiAgICB0ID0gZ3JvdXBbal07XG4gICAgdFt5MF0gPSBsYXN0O1xuICAgIHRbeTFdID0gbGFzdCArPSBNYXRoLmFicyhmaWVsZCh0KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhY2tOb3JtYWxpemUoZ3JvdXAsIG1heCwgZmllbGQsIHkwLCB5MSkge1xuICB2YXIgc2NhbGUgPSAxIC8gZ3JvdXAuc3VtLFxuICAgICAgbGFzdCA9IDAsXG4gICAgICBtID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgaiA9IDAsXG4gICAgICB2ID0gMCxcbiAgICAgIHQ7XG5cbiAgZm9yICg7IGogPCBtOyArK2opIHtcbiAgICB0ID0gZ3JvdXBbal07XG4gICAgdFt5MF0gPSBsYXN0O1xuICAgIHRbeTFdID0gbGFzdCA9IHNjYWxlICogKHYgKz0gTWF0aC5hYnMoZmllbGQodCkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFja1plcm8oZ3JvdXAsIG1heCwgZmllbGQsIHkwLCB5MSkge1xuICB2YXIgbGFzdFBvcyA9IDAsXG4gICAgICBsYXN0TmVnID0gMCxcbiAgICAgIG0gPSBncm91cC5sZW5ndGgsXG4gICAgICBqID0gMCxcbiAgICAgIHYsXG4gICAgICB0O1xuXG4gIGZvciAoOyBqIDwgbTsgKytqKSB7XG4gICAgdCA9IGdyb3VwW2pdO1xuICAgIHYgPSArZmllbGQodCk7XG5cbiAgICBpZiAodiA8IDApIHtcbiAgICAgIHRbeTBdID0gbGFzdE5lZztcbiAgICAgIHRbeTFdID0gbGFzdE5lZyArPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICB0W3kwXSA9IGxhc3RQb3M7XG4gICAgICB0W3kxXSA9IGxhc3RQb3MgKz0gdjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIHNvcnQsIGZpZWxkKSB7XG4gIHZhciBncm91cHMgPSBbXSxcbiAgICAgIGdldCA9IGYgPT4gZih0KSxcbiAgICAgIG1hcCxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbSxcbiAgICAgIHQsXG4gICAgICBrLFxuICAgICAgZyxcbiAgICAgIHMsXG4gICAgICBtYXg7IC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIHN0YWNrIGdyb3Vwc1xuXG5cbiAgaWYgKGdyb3VwYnkgPT0gbnVsbCkge1xuICAgIGdyb3Vwcy5wdXNoKGRhdGEuc2xpY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXAgPSB7fSwgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IGRhdGFbaV07XG4gICAgICBrID0gZ3JvdXBieS5tYXAoZ2V0KTtcbiAgICAgIGcgPSBtYXBba107XG5cbiAgICAgIGlmICghZykge1xuICAgICAgICBtYXBba10gPSBnID0gW107XG4gICAgICAgIGdyb3Vwcy5wdXNoKGcpO1xuICAgICAgfVxuXG4gICAgICBnLnB1c2godCk7XG4gICAgfVxuICB9IC8vIGNvbXB1dGUgc3VtcyBvZiBncm91cHMsIHNvcnQgZ3JvdXBzIGFzIG5lZWRlZFxuXG5cbiAgZm9yIChrID0gMCwgbWF4ID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBtOyArK2spIHtcbiAgICBnID0gZ3JvdXBzW2tdO1xuXG4gICAgZm9yIChpID0gMCwgcyA9IDAsIG4gPSBnLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgcyArPSBNYXRoLmFicyhmaWVsZChnW2ldKSk7XG4gICAgfVxuXG4gICAgZy5zdW0gPSBzO1xuICAgIGlmIChzID4gbWF4KSBtYXggPSBzO1xuICAgIGlmIChzb3J0KSBnLnNvcnQoc29ydCk7XG4gIH1cblxuICBncm91cHMubWF4ID0gbWF4O1xuICByZXR1cm4gZ3JvdXBzO1xufVxuXG5leHBvcnQgeyBBeGlzVGlja3MgYXMgYXhpc3RpY2tzLCBEYXRhSm9pbiBhcyBkYXRham9pbiwgRW5jb2RlIGFzIGVuY29kZSwgTGVnZW5kRW50cmllcyBhcyBsZWdlbmRlbnRyaWVzLCBMaW5rUGF0aCBhcyBsaW5rcGF0aCwgUGllIGFzIHBpZSwgU2NhbGUgYXMgc2NhbGUsIFNvcnRJdGVtcyBhcyBzb3J0aXRlbXMsIFN0YWNrIGFzIHN0YWNrIH07XG4iLCJjb25zdCBWSUVXID0gJ3ZpZXcnLFxuICAgICAgTEJSQUNLID0gJ1snLFxuICAgICAgUkJSQUNLID0gJ10nLFxuICAgICAgTEJSQUNFID0gJ3snLFxuICAgICAgUkJSQUNFID0gJ30nLFxuICAgICAgQ09MT04gPSAnOicsXG4gICAgICBDT01NQSA9ICcsJyxcbiAgICAgIE5BTUUgPSAnQCcsXG4gICAgICBHVCA9ICc+JyxcbiAgICAgIElMTEVHQUwgPSAvW1tcXF17fV0vLFxuICAgICAgREVGQVVMVF9NQVJLUyA9IHtcbiAgJyonOiAxLFxuICBhcmM6IDEsXG4gIGFyZWE6IDEsXG4gIGdyb3VwOiAxLFxuICBpbWFnZTogMSxcbiAgbGluZTogMSxcbiAgcGF0aDogMSxcbiAgcmVjdDogMSxcbiAgcnVsZTogMSxcbiAgc2hhcGU6IDEsXG4gIHN5bWJvbDogMSxcbiAgdGV4dDogMSxcbiAgdHJhaWw6IDFcbn07XG5sZXQgREVGQVVMVF9TT1VSQ0UsIE1BUktTO1xuLyoqXG4gKiBQYXJzZSBhbiBldmVudCBzZWxlY3RvciBzdHJpbmcuXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGV2ZW50IHN0cmVhbSBkZWZpbml0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBldmVudFNlbGVjdG9yIChzZWxlY3Rvciwgc291cmNlLCBtYXJrcykge1xuICBERUZBVUxUX1NPVVJDRSA9IHNvdXJjZSB8fCBWSUVXO1xuICBNQVJLUyA9IG1hcmtzIHx8IERFRkFVTFRfTUFSS1M7XG4gIHJldHVybiBwYXJzZU1lcmdlKHNlbGVjdG9yLnRyaW0oKSkubWFwKHBhcnNlU2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBpc01hcmtUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIE1BUktTW3R5cGVdO1xufVxuXG5mdW5jdGlvbiBmaW5kKHMsIGksIGVuZENoYXIsIHB1c2hDaGFyLCBwb3BDaGFyKSB7XG4gIGNvbnN0IG4gPSBzLmxlbmd0aDtcbiAgbGV0IGNvdW50ID0gMCxcbiAgICAgIGM7XG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBjID0gc1tpXTtcbiAgICBpZiAoIWNvdW50ICYmIGMgPT09IGVuZENoYXIpIHJldHVybiBpO2Vsc2UgaWYgKHBvcENoYXIgJiYgcG9wQ2hhci5pbmRleE9mKGMpID49IDApIC0tY291bnQ7ZWxzZSBpZiAocHVzaENoYXIgJiYgcHVzaENoYXIuaW5kZXhPZihjKSA+PSAwKSArK2NvdW50O1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWVyZ2Uocykge1xuICBjb25zdCBvdXRwdXQgPSBbXSxcbiAgICAgICAgbiA9IHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwLFxuICAgICAgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBuKSB7XG4gICAgaSA9IGZpbmQocywgaSwgQ09NTUEsIExCUkFDSyArIExCUkFDRSwgUkJSQUNLICsgUkJSQUNFKTtcbiAgICBvdXRwdXQucHVzaChzLnN1YnN0cmluZyhzdGFydCwgaSkudHJpbSgpKTtcbiAgICBzdGFydCA9ICsraTtcbiAgfVxuXG4gIGlmIChvdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgJ0VtcHR5IGV2ZW50IHNlbGVjdG9yOiAnICsgcztcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2VsZWN0b3Iocykge1xuICByZXR1cm4gc1swXSA9PT0gJ1snID8gcGFyc2VCZXR3ZWVuKHMpIDogcGFyc2VTdHJlYW0ocyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQmV0d2VlbihzKSB7XG4gIGNvbnN0IG4gPSBzLmxlbmd0aDtcbiAgbGV0IGkgPSAxLFxuICAgICAgYjtcbiAgaSA9IGZpbmQocywgaSwgUkJSQUNLLCBMQlJBQ0ssIFJCUkFDSyk7XG5cbiAgaWYgKGkgPT09IG4pIHtcbiAgICB0aHJvdyAnRW1wdHkgYmV0d2VlbiBzZWxlY3RvcjogJyArIHM7XG4gIH1cblxuICBiID0gcGFyc2VNZXJnZShzLnN1YnN0cmluZygxLCBpKSk7XG5cbiAgaWYgKGIubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgJ0JldHdlZW4gc2VsZWN0b3IgbXVzdCBoYXZlIHR3byBlbGVtZW50czogJyArIHM7XG4gIH1cblxuICBzID0gcy5zbGljZShpICsgMSkudHJpbSgpO1xuXG4gIGlmIChzWzBdICE9PSBHVCkge1xuICAgIHRocm93ICdFeHBlY3RlZCBcXCc+XFwnIGFmdGVyIGJldHdlZW4gc2VsZWN0b3I6ICcgKyBzO1xuICB9XG5cbiAgYiA9IGIubWFwKHBhcnNlU2VsZWN0b3IpO1xuICBjb25zdCBzdHJlYW0gPSBwYXJzZVNlbGVjdG9yKHMuc2xpY2UoMSkudHJpbSgpKTtcblxuICBpZiAoc3RyZWFtLmJldHdlZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogYixcbiAgICAgIHN0cmVhbTogc3RyZWFtXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uYmV0d2VlbiA9IGI7XG4gIH1cblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmVhbShzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHtcbiAgICBzb3VyY2U6IERFRkFVTFRfU09VUkNFXG4gIH0sXG4gICAgICAgIHNvdXJjZSA9IFtdO1xuICBsZXQgdGhyb3R0bGUgPSBbMCwgMF0sXG4gICAgICBtYXJrbmFtZSA9IDAsXG4gICAgICBzdGFydCA9IDAsXG4gICAgICBuID0gcy5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGosXG4gICAgICBmaWx0ZXI7IC8vIGV4dHJhY3QgdGhyb3R0bGUgZnJvbSBlbmRcblxuICBpZiAoc1tuIC0gMV0gPT09IFJCUkFDRSkge1xuICAgIGkgPSBzLmxhc3RJbmRleE9mKExCUkFDRSk7XG5cbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdHRsZSA9IHBhcnNlVGhyb3R0bGUocy5zdWJzdHJpbmcoaSArIDEsIG4gLSAxKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93ICdJbnZhbGlkIHRocm90dGxlIHNwZWNpZmljYXRpb246ICcgKyBzO1xuICAgICAgfVxuXG4gICAgICBzID0gcy5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICBuID0gcy5sZW5ndGg7XG4gICAgfSBlbHNlIHRocm93ICdVbm1hdGNoZWQgcmlnaHQgYnJhY2U6ICcgKyBzO1xuXG4gICAgaSA9IDA7XG4gIH1cblxuICBpZiAoIW4pIHRocm93IHM7IC8vIHNldCBuYW1lIGZsYWcgYmFzZWQgb24gZmlyc3QgY2hhclxuXG4gIGlmIChzWzBdID09PSBOQU1FKSBtYXJrbmFtZSA9ICsraTsgLy8gZXh0cmFjdCBmaXJzdCBwYXJ0IG9mIG11bHRpLXBhcnQgc3RyZWFtIHNlbGVjdG9yXG5cbiAgaiA9IGZpbmQocywgaSwgQ09MT04pO1xuXG4gIGlmIChqIDwgbikge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBqKS50cmltKCkpO1xuICAgIHN0YXJ0ID0gaSA9ICsrajtcbiAgfSAvLyBleHRyYWN0IHJlbWFpbmluZyBwYXJ0IG9mIHN0cmVhbSBzZWxlY3RvclxuXG5cbiAgaSA9IGZpbmQocywgaSwgTEJSQUNLKTtcblxuICBpZiAoaSA9PT0gbikge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBuKS50cmltKCkpO1xuICB9IGVsc2Uge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBpKS50cmltKCkpO1xuICAgIGZpbHRlciA9IFtdO1xuICAgIHN0YXJ0ID0gKytpO1xuICAgIGlmIChzdGFydCA9PT0gbikgdGhyb3cgJ1VubWF0Y2hlZCBsZWZ0IGJyYWNrZXQ6ICcgKyBzO1xuICB9IC8vIGV4dHJhY3QgZmlsdGVyc1xuXG5cbiAgd2hpbGUgKGkgPCBuKSB7XG4gICAgaSA9IGZpbmQocywgaSwgUkJSQUNLKTtcbiAgICBpZiAoaSA9PT0gbikgdGhyb3cgJ1VubWF0Y2hlZCBsZWZ0IGJyYWNrZXQ6ICcgKyBzO1xuICAgIGZpbHRlci5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBpKS50cmltKCkpO1xuICAgIGlmIChpIDwgbiAtIDEgJiYgc1srK2ldICE9PSBMQlJBQ0spIHRocm93ICdFeHBlY3RlZCBsZWZ0IGJyYWNrZXQ6ICcgKyBzO1xuICAgIHN0YXJ0ID0gKytpO1xuICB9IC8vIG1hcnNoYWxsIGV2ZW50IHN0cmVhbSBzcGVjaWZpY2F0aW9uXG5cblxuICBpZiAoIShuID0gc291cmNlLmxlbmd0aCkgfHwgSUxMRUdBTC50ZXN0KHNvdXJjZVtuIC0gMV0pKSB7XG4gICAgdGhyb3cgJ0ludmFsaWQgZXZlbnQgc2VsZWN0b3I6ICcgKyBzO1xuICB9XG5cbiAgaWYgKG4gPiAxKSB7XG4gICAgc3RyZWFtLnR5cGUgPSBzb3VyY2VbMV07XG5cbiAgICBpZiAobWFya25hbWUpIHtcbiAgICAgIHN0cmVhbS5tYXJrbmFtZSA9IHNvdXJjZVswXS5zbGljZSgxKTtcbiAgICB9IGVsc2UgaWYgKGlzTWFya1R5cGUoc291cmNlWzBdKSkge1xuICAgICAgc3RyZWFtLm1hcmt0eXBlID0gc291cmNlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uc291cmNlID0gc291cmNlWzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0udHlwZSA9IHNvdXJjZVswXTtcbiAgfVxuXG4gIGlmIChzdHJlYW0udHlwZS5zbGljZSgtMSkgPT09ICchJykge1xuICAgIHN0cmVhbS5jb25zdW1lID0gdHJ1ZTtcbiAgICBzdHJlYW0udHlwZSA9IHN0cmVhbS50eXBlLnNsaWNlKDAsIC0xKTtcbiAgfVxuXG4gIGlmIChmaWx0ZXIgIT0gbnVsbCkgc3RyZWFtLmZpbHRlciA9IGZpbHRlcjtcbiAgaWYgKHRocm90dGxlWzBdKSBzdHJlYW0udGhyb3R0bGUgPSB0aHJvdHRsZVswXTtcbiAgaWYgKHRocm90dGxlWzFdKSBzdHJlYW0uZGVib3VuY2UgPSB0aHJvdHRsZVsxXTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaHJvdHRsZShzKSB7XG4gIGNvbnN0IGEgPSBzLnNwbGl0KENPTU1BKTtcbiAgaWYgKCFzLmxlbmd0aCB8fCBhLmxlbmd0aCA+IDIpIHRocm93IHM7XG4gIHJldHVybiBhLm1hcChfID0+IHtcbiAgICBjb25zdCB4ID0gK187XG4gICAgaWYgKHggIT09IHgpIHRocm93IHM7XG4gICAgcmV0dXJuIHg7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBldmVudFNlbGVjdG9yIGFzIHBhcnNlU2VsZWN0b3IgfTtcbiIsImltcG9ydCB7IGVycm9yLCB0b1NldCwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGhhc093blByb3BlcnR5IH0gZnJvbSAndmVnYS11dGlsJztcblxuY29uc3QgUmF3Q29kZSA9ICdSYXdDb2RlJztcbmNvbnN0IExpdGVyYWwgPSAnTGl0ZXJhbCc7XG5jb25zdCBQcm9wZXJ0eSA9ICdQcm9wZXJ0eSc7XG5jb25zdCBJZGVudGlmaWVyID0gJ0lkZW50aWZpZXInO1xuY29uc3QgQXJyYXlFeHByZXNzaW9uID0gJ0FycmF5RXhwcmVzc2lvbic7XG5jb25zdCBCaW5hcnlFeHByZXNzaW9uID0gJ0JpbmFyeUV4cHJlc3Npb24nO1xuY29uc3QgQ2FsbEV4cHJlc3Npb24gPSAnQ2FsbEV4cHJlc3Npb24nO1xuY29uc3QgQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic7XG5jb25zdCBMb2dpY2FsRXhwcmVzc2lvbiA9ICdMb2dpY2FsRXhwcmVzc2lvbic7XG5jb25zdCBNZW1iZXJFeHByZXNzaW9uID0gJ01lbWJlckV4cHJlc3Npb24nO1xuY29uc3QgT2JqZWN0RXhwcmVzc2lvbiA9ICdPYmplY3RFeHByZXNzaW9uJztcbmNvbnN0IFVuYXJ5RXhwcmVzc2lvbiA9ICdVbmFyeUV4cHJlc3Npb24nO1xuZnVuY3Rpb24gQVNUTm9kZSh0eXBlKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG59XG5cbkFTVE5vZGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgbGV0IGMsIGksIG47XG4gIGlmICh2aXNpdG9yKHRoaXMpKSByZXR1cm4gMTtcblxuICBmb3IgKGMgPSBjaGlsZHJlbih0aGlzKSwgaSA9IDAsIG4gPSBjLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmIChjW2ldLnZpc2l0KHZpc2l0b3IpKSByZXR1cm4gMTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2hpbGRyZW4obm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgQXJyYXlFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudHM7XG5cbiAgICBjYXNlIEJpbmFyeUV4cHJlc3Npb246XG4gICAgY2FzZSBMb2dpY2FsRXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS5sZWZ0LCBub2RlLnJpZ2h0XTtcblxuICAgIGNhc2UgQ2FsbEV4cHJlc3Npb246XG4gICAgICByZXR1cm4gW25vZGUuY2FsbGVlXS5jb25jYXQobm9kZS5hcmd1bWVudHMpO1xuXG4gICAgY2FzZSBDb25kaXRpb25hbEV4cHJlc3Npb246XG4gICAgICByZXR1cm4gW25vZGUudGVzdCwgbm9kZS5jb25zZXF1ZW50LCBub2RlLmFsdGVybmF0ZV07XG5cbiAgICBjYXNlIE1lbWJlckV4cHJlc3Npb246XG4gICAgICByZXR1cm4gW25vZGUub2JqZWN0LCBub2RlLnByb3BlcnR5XTtcblxuICAgIGNhc2UgT2JqZWN0RXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBub2RlLnByb3BlcnRpZXM7XG5cbiAgICBjYXNlIFByb3BlcnR5OlxuICAgICAgcmV0dXJuIFtub2RlLmtleSwgbm9kZS52YWx1ZV07XG5cbiAgICBjYXNlIFVuYXJ5RXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS5hcmd1bWVudF07XG5cbiAgICBjYXNlIElkZW50aWZpZXI6XG4gICAgY2FzZSBMaXRlcmFsOlxuICAgIGNhc2UgUmF3Q29kZTpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qXG4gIFRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiBwYXJzZXIgaXMgYmFzZWQgb24gRXNwcmltYSAoaHR0cDovL2VzcHJpbWEub3JnLykuXG4gIE9yaWdpbmFsIGhlYWRlciBjb21tZW50IGFuZCBsaWNlbnNlIGZvciBFc3ByaW1hIGlzIGluY2x1ZGVkIGhlcmU6XG5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgVGhhZGRlZSBUeWwgPHRoYWRkZWUudHlsQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMSBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xudmFyIFRva2VuTmFtZSwgc291cmNlLCBpbmRleCwgbGVuZ3RoLCBsb29rYWhlYWQ7XG52YXIgVG9rZW5Cb29sZWFuTGl0ZXJhbCA9IDEsXG4gICAgVG9rZW5FT0YgPSAyLFxuICAgIFRva2VuSWRlbnRpZmllciA9IDMsXG4gICAgVG9rZW5LZXl3b3JkID0gNCxcbiAgICBUb2tlbk51bGxMaXRlcmFsID0gNSxcbiAgICBUb2tlbk51bWVyaWNMaXRlcmFsID0gNixcbiAgICBUb2tlblB1bmN0dWF0b3IgPSA3LFxuICAgIFRva2VuU3RyaW5nTGl0ZXJhbCA9IDgsXG4gICAgVG9rZW5SZWd1bGFyRXhwcmVzc2lvbiA9IDk7XG5Ub2tlbk5hbWUgPSB7fTtcblRva2VuTmFtZVtUb2tlbkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcblRva2VuTmFtZVtUb2tlbkVPRl0gPSAnPGVuZD4nO1xuVG9rZW5OYW1lW1Rva2VuSWRlbnRpZmllcl0gPSAnSWRlbnRpZmllcic7XG5Ub2tlbk5hbWVbVG9rZW5LZXl3b3JkXSA9ICdLZXl3b3JkJztcblRva2VuTmFtZVtUb2tlbk51bGxMaXRlcmFsXSA9ICdOdWxsJztcblRva2VuTmFtZVtUb2tlbk51bWVyaWNMaXRlcmFsXSA9ICdOdW1lcmljJztcblRva2VuTmFtZVtUb2tlblB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xuVG9rZW5OYW1lW1Rva2VuU3RyaW5nTGl0ZXJhbF0gPSAnU3RyaW5nJztcblRva2VuTmFtZVtUb2tlblJlZ3VsYXJFeHByZXNzaW9uXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XG52YXIgU3ludGF4QXJyYXlFeHByZXNzaW9uID0gJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgU3ludGF4QmluYXJ5RXhwcmVzc2lvbiA9ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICBTeW50YXhDYWxsRXhwcmVzc2lvbiA9ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgU3ludGF4Q29uZGl0aW9uYWxFeHByZXNzaW9uID0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgU3ludGF4SWRlbnRpZmllciA9ICdJZGVudGlmaWVyJyxcbiAgICBTeW50YXhMaXRlcmFsID0gJ0xpdGVyYWwnLFxuICAgIFN5bnRheExvZ2ljYWxFeHByZXNzaW9uID0gJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICBTeW50YXhNZW1iZXJFeHByZXNzaW9uID0gJ01lbWJlckV4cHJlc3Npb24nLFxuICAgIFN5bnRheE9iamVjdEV4cHJlc3Npb24gPSAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgU3ludGF4UHJvcGVydHkgPSAnUHJvcGVydHknLFxuICAgIFN5bnRheFVuYXJ5RXhwcmVzc2lvbiA9ICdVbmFyeUV4cHJlc3Npb24nOyAvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxuXG52YXIgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiA9ICdVbmV4cGVjdGVkIHRva2VuICUwJyxcbiAgICBNZXNzYWdlVW5leHBlY3RlZE51bWJlciA9ICdVbmV4cGVjdGVkIG51bWJlcicsXG4gICAgTWVzc2FnZVVuZXhwZWN0ZWRTdHJpbmcgPSAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICAgIE1lc3NhZ2VVbmV4cGVjdGVkSWRlbnRpZmllciA9ICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxuICAgIE1lc3NhZ2VVbmV4cGVjdGVkUmVzZXJ2ZWQgPSAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcbiAgICBNZXNzYWdlVW5leHBlY3RlZEVPUyA9ICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXG4gICAgTWVzc2FnZUludmFsaWRSZWdFeHAgPSAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgIE1lc3NhZ2VVbnRlcm1pbmF0ZWRSZWdFeHAgPSAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLycsXG4gICAgTWVzc2FnZVN0cmljdE9jdGFsTGl0ZXJhbCA9ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICBNZXNzYWdlU3RyaWN0RHVwbGljYXRlUHJvcGVydHkgPSAnRHVwbGljYXRlIGRhdGEgcHJvcGVydHkgaW4gb2JqZWN0IGxpdGVyYWwgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnO1xudmFyIElMTEVHQUwgPSAnSUxMRUdBTCcsXG4gICAgRElTQUJMRUQgPSAnRGlzYWJsZWQuJzsgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5weS5cblxudmFyIFJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKCdbXFxcXHhBQVxcXFx4QjVcXFxceEJBXFxcXHhDMC1cXFxceEQ2XFxcXHhEOC1cXFxceEY2XFxcXHhGOC1cXFxcdTAyQzFcXFxcdTAyQzYtXFxcXHUwMkQxXFxcXHUwMkUwLVxcXFx1MDJFNFxcXFx1MDJFQ1xcXFx1MDJFRVxcXFx1MDM3MC1cXFxcdTAzNzRcXFxcdTAzNzZcXFxcdTAzNzdcXFxcdTAzN0EtXFxcXHUwMzdEXFxcXHUwMzdGXFxcXHUwMzg2XFxcXHUwMzg4LVxcXFx1MDM4QVxcXFx1MDM4Q1xcXFx1MDM4RS1cXFxcdTAzQTFcXFxcdTAzQTMtXFxcXHUwM0Y1XFxcXHUwM0Y3LVxcXFx1MDQ4MVxcXFx1MDQ4QS1cXFxcdTA1MkZcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDVEMC1cXFxcdTA1RUFcXFxcdTA1RjAtXFxcXHUwNUYyXFxcXHUwNjIwLVxcXFx1MDY0QVxcXFx1MDY2RVxcXFx1MDY2RlxcXFx1MDY3MS1cXFxcdTA2RDNcXFxcdTA2RDVcXFxcdTA2RTVcXFxcdTA2RTZcXFxcdTA2RUVcXFxcdTA2RUZcXFxcdTA2RkEtXFxcXHUwNkZDXFxcXHUwNkZGXFxcXHUwNzEwXFxcXHUwNzEyLVxcXFx1MDcyRlxcXFx1MDc0RC1cXFxcdTA3QTVcXFxcdTA3QjFcXFxcdTA3Q0EtXFxcXHUwN0VBXFxcXHUwN0Y0XFxcXHUwN0Y1XFxcXHUwN0ZBXFxcXHUwODAwLVxcXFx1MDgxNVxcXFx1MDgxQVxcXFx1MDgyNFxcXFx1MDgyOFxcXFx1MDg0MC1cXFxcdTA4NThcXFxcdTA4QTAtXFxcXHUwOEIyXFxcXHUwOTA0LVxcXFx1MDkzOVxcXFx1MDkzRFxcXFx1MDk1MFxcXFx1MDk1OC1cXFxcdTA5NjFcXFxcdTA5NzEtXFxcXHUwOTgwXFxcXHUwOTg1LVxcXFx1MDk4Q1xcXFx1MDk4RlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5QThcXFxcdTA5QUEtXFxcXHUwOUIwXFxcXHUwOUIyXFxcXHUwOUI2LVxcXFx1MDlCOVxcXFx1MDlCRFxcXFx1MDlDRVxcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTFcXFxcdTA5RjBcXFxcdTA5RjFcXFxcdTBBMDUtXFxcXHUwQTBBXFxcXHUwQTBGXFxcXHUwQTEwXFxcXHUwQTEzLVxcXFx1MEEyOFxcXFx1MEEyQS1cXFxcdTBBMzBcXFxcdTBBMzJcXFxcdTBBMzNcXFxcdTBBMzVcXFxcdTBBMzZcXFxcdTBBMzhcXFxcdTBBMzlcXFxcdTBBNTktXFxcXHUwQTVDXFxcXHUwQTVFXFxcXHUwQTcyLVxcXFx1MEE3NFxcXFx1MEE4NS1cXFxcdTBBOERcXFxcdTBBOEYtXFxcXHUwQTkxXFxcXHUwQTkzLVxcXFx1MEFBOFxcXFx1MEFBQS1cXFxcdTBBQjBcXFxcdTBBQjJcXFxcdTBBQjNcXFxcdTBBQjUtXFxcXHUwQUI5XFxcXHUwQUJEXFxcXHUwQUQwXFxcXHUwQUUwXFxcXHUwQUUxXFxcXHUwQjA1LVxcXFx1MEIwQ1xcXFx1MEIwRlxcXFx1MEIxMFxcXFx1MEIxMy1cXFxcdTBCMjhcXFxcdTBCMkEtXFxcXHUwQjMwXFxcXHUwQjMyXFxcXHUwQjMzXFxcXHUwQjM1LVxcXFx1MEIzOVxcXFx1MEIzRFxcXFx1MEI1Q1xcXFx1MEI1RFxcXFx1MEI1Ri1cXFxcdTBCNjFcXFxcdTBCNzFcXFxcdTBCODNcXFxcdTBCODUtXFxcXHUwQjhBXFxcXHUwQjhFLVxcXFx1MEI5MFxcXFx1MEI5Mi1cXFxcdTBCOTVcXFxcdTBCOTlcXFxcdTBCOUFcXFxcdTBCOUNcXFxcdTBCOUVcXFxcdTBCOUZcXFxcdTBCQTNcXFxcdTBCQTRcXFxcdTBCQTgtXFxcXHUwQkFBXFxcXHUwQkFFLVxcXFx1MEJCOVxcXFx1MEJEMFxcXFx1MEMwNS1cXFxcdTBDMENcXFxcdTBDMEUtXFxcXHUwQzEwXFxcXHUwQzEyLVxcXFx1MEMyOFxcXFx1MEMyQS1cXFxcdTBDMzlcXFxcdTBDM0RcXFxcdTBDNThcXFxcdTBDNTlcXFxcdTBDNjBcXFxcdTBDNjFcXFxcdTBDODUtXFxcXHUwQzhDXFxcXHUwQzhFLVxcXFx1MEM5MFxcXFx1MEM5Mi1cXFxcdTBDQThcXFxcdTBDQUEtXFxcXHUwQ0IzXFxcXHUwQ0I1LVxcXFx1MENCOVxcXFx1MENCRFxcXFx1MENERVxcXFx1MENFMFxcXFx1MENFMVxcXFx1MENGMVxcXFx1MENGMlxcXFx1MEQwNS1cXFxcdTBEMENcXFxcdTBEMEUtXFxcXHUwRDEwXFxcXHUwRDEyLVxcXFx1MEQzQVxcXFx1MEQzRFxcXFx1MEQ0RVxcXFx1MEQ2MFxcXFx1MEQ2MVxcXFx1MEQ3QS1cXFxcdTBEN0ZcXFxcdTBEODUtXFxcXHUwRDk2XFxcXHUwRDlBLVxcXFx1MERCMVxcXFx1MERCMy1cXFxcdTBEQkJcXFxcdTBEQkRcXFxcdTBEQzAtXFxcXHUwREM2XFxcXHUwRTAxLVxcXFx1MEUzMFxcXFx1MEUzMlxcXFx1MEUzM1xcXFx1MEU0MC1cXFxcdTBFNDZcXFxcdTBFODFcXFxcdTBFODJcXFxcdTBFODRcXFxcdTBFODdcXFxcdTBFODhcXFxcdTBFOEFcXFxcdTBFOERcXFxcdTBFOTQtXFxcXHUwRTk3XFxcXHUwRTk5LVxcXFx1MEU5RlxcXFx1MEVBMS1cXFxcdTBFQTNcXFxcdTBFQTVcXFxcdTBFQTdcXFxcdTBFQUFcXFxcdTBFQUJcXFxcdTBFQUQtXFxcXHUwRUIwXFxcXHUwRUIyXFxcXHUwRUIzXFxcXHUwRUJEXFxcXHUwRUMwLVxcXFx1MEVDNFxcXFx1MEVDNlxcXFx1MEVEQy1cXFxcdTBFREZcXFxcdTBGMDBcXFxcdTBGNDAtXFxcXHUwRjQ3XFxcXHUwRjQ5LVxcXFx1MEY2Q1xcXFx1MEY4OC1cXFxcdTBGOENcXFxcdTEwMDAtXFxcXHUxMDJBXFxcXHUxMDNGXFxcXHUxMDUwLVxcXFx1MTA1NVxcXFx1MTA1QS1cXFxcdTEwNURcXFxcdTEwNjFcXFxcdTEwNjVcXFxcdTEwNjZcXFxcdTEwNkUtXFxcXHUxMDcwXFxcXHUxMDc1LVxcXFx1MTA4MVxcXFx1MTA4RVxcXFx1MTBBMC1cXFxcdTEwQzVcXFxcdTEwQzdcXFxcdTEwQ0RcXFxcdTEwRDAtXFxcXHUxMEZBXFxcXHUxMEZDLVxcXFx1MTI0OFxcXFx1MTI0QS1cXFxcdTEyNERcXFxcdTEyNTAtXFxcXHUxMjU2XFxcXHUxMjU4XFxcXHUxMjVBLVxcXFx1MTI1RFxcXFx1MTI2MC1cXFxcdTEyODhcXFxcdTEyOEEtXFxcXHUxMjhEXFxcXHUxMjkwLVxcXFx1MTJCMFxcXFx1MTJCMi1cXFxcdTEyQjVcXFxcdTEyQjgtXFxcXHUxMkJFXFxcXHUxMkMwXFxcXHUxMkMyLVxcXFx1MTJDNVxcXFx1MTJDOC1cXFxcdTEyRDZcXFxcdTEyRDgtXFxcXHUxMzEwXFxcXHUxMzEyLVxcXFx1MTMxNVxcXFx1MTMxOC1cXFxcdTEzNUFcXFxcdTEzODAtXFxcXHUxMzhGXFxcXHUxM0EwLVxcXFx1MTNGNFxcXFx1MTQwMS1cXFxcdTE2NkNcXFxcdTE2NkYtXFxcXHUxNjdGXFxcXHUxNjgxLVxcXFx1MTY5QVxcXFx1MTZBMC1cXFxcdTE2RUFcXFxcdTE2RUUtXFxcXHUxNkY4XFxcXHUxNzAwLVxcXFx1MTcwQ1xcXFx1MTcwRS1cXFxcdTE3MTFcXFxcdTE3MjAtXFxcXHUxNzMxXFxcXHUxNzQwLVxcXFx1MTc1MVxcXFx1MTc2MC1cXFxcdTE3NkNcXFxcdTE3NkUtXFxcXHUxNzcwXFxcXHUxNzgwLVxcXFx1MTdCM1xcXFx1MTdEN1xcXFx1MTdEQ1xcXFx1MTgyMC1cXFxcdTE4NzdcXFxcdTE4ODAtXFxcXHUxOEE4XFxcXHUxOEFBXFxcXHUxOEIwLVxcXFx1MThGNVxcXFx1MTkwMC1cXFxcdTE5MUVcXFxcdTE5NTAtXFxcXHUxOTZEXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5QUJcXFxcdTE5QzEtXFxcXHUxOUM3XFxcXHUxQTAwLVxcXFx1MUExNlxcXFx1MUEyMC1cXFxcdTFBNTRcXFxcdTFBQTdcXFxcdTFCMDUtXFxcXHUxQjMzXFxcXHUxQjQ1LVxcXFx1MUI0QlxcXFx1MUI4My1cXFxcdTFCQTBcXFxcdTFCQUVcXFxcdTFCQUZcXFxcdTFCQkEtXFxcXHUxQkU1XFxcXHUxQzAwLVxcXFx1MUMyM1xcXFx1MUM0RC1cXFxcdTFDNEZcXFxcdTFDNUEtXFxcXHUxQzdEXFxcXHUxQ0U5LVxcXFx1MUNFQ1xcXFx1MUNFRS1cXFxcdTFDRjFcXFxcdTFDRjVcXFxcdTFDRjZcXFxcdTFEMDAtXFxcXHUxREJGXFxcXHUxRTAwLVxcXFx1MUYxNVxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjAtXFxcXHUxRjQ1XFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUYtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUZCNFxcXFx1MUZCNi1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2LVxcXFx1MUZDQ1xcXFx1MUZEMC1cXFxcdTFGRDNcXFxcdTFGRDYtXFxcXHUxRkRCXFxcXHUxRkUwLVxcXFx1MUZFQ1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjYtXFxcXHUxRkZDXFxcXHUyMDcxXFxcXHUyMDdGXFxcXHUyMDkwLVxcXFx1MjA5Q1xcXFx1MjEwMlxcXFx1MjEwN1xcXFx1MjEwQS1cXFxcdTIxMTNcXFxcdTIxMTVcXFxcdTIxMTktXFxcXHUyMTFEXFxcXHUyMTI0XFxcXHUyMTI2XFxcXHUyMTI4XFxcXHUyMTJBLVxcXFx1MjEyRFxcXFx1MjEyRi1cXFxcdTIxMzlcXFxcdTIxM0MtXFxcXHUyMTNGXFxcXHUyMTQ1LVxcXFx1MjE0OVxcXFx1MjE0RVxcXFx1MjE2MC1cXFxcdTIxODhcXFxcdTJDMDAtXFxcXHUyQzJFXFxcXHUyQzMwLVxcXFx1MkM1RVxcXFx1MkM2MC1cXFxcdTJDRTRcXFxcdTJDRUItXFxcXHUyQ0VFXFxcXHUyQ0YyXFxcXHUyQ0YzXFxcXHUyRDAwLVxcXFx1MkQyNVxcXFx1MkQyN1xcXFx1MkQyRFxcXFx1MkQzMC1cXFxcdTJENjdcXFxcdTJENkZcXFxcdTJEODAtXFxcXHUyRDk2XFxcXHUyREEwLVxcXFx1MkRBNlxcXFx1MkRBOC1cXFxcdTJEQUVcXFxcdTJEQjAtXFxcXHUyREI2XFxcXHUyREI4LVxcXFx1MkRCRVxcXFx1MkRDMC1cXFxcdTJEQzZcXFxcdTJEQzgtXFxcXHUyRENFXFxcXHUyREQwLVxcXFx1MkRENlxcXFx1MkREOC1cXFxcdTJEREVcXFxcdTJFMkZcXFxcdTMwMDUtXFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyOVxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwMzgtXFxcXHUzMDNDXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5RC1cXFxcdTMwOUZcXFxcdTMwQTEtXFxcXHUzMEZBXFxcXHUzMEZDLVxcXFx1MzBGRlxcXFx1MzEwNS1cXFxcdTMxMkRcXFxcdTMxMzEtXFxcXHUzMThFXFxcXHUzMUEwLVxcXFx1MzFCQVxcXFx1MzFGMC1cXFxcdTMxRkZcXFxcdTM0MDAtXFxcXHU0REI1XFxcXHU0RTAwLVxcXFx1OUZDQ1xcXFx1QTAwMC1cXFxcdUE0OENcXFxcdUE0RDAtXFxcXHVBNEZEXFxcXHVBNTAwLVxcXFx1QTYwQ1xcXFx1QTYxMC1cXFxcdUE2MUZcXFxcdUE2MkFcXFxcdUE2MkJcXFxcdUE2NDAtXFxcXHVBNjZFXFxcXHVBNjdGLVxcXFx1QTY5RFxcXFx1QTZBMC1cXFxcdUE2RUZcXFxcdUE3MTctXFxcXHVBNzFGXFxcXHVBNzIyLVxcXFx1QTc4OFxcXFx1QTc4Qi1cXFxcdUE3OEVcXFxcdUE3OTAtXFxcXHVBN0FEXFxcXHVBN0IwXFxcXHVBN0IxXFxcXHVBN0Y3LVxcXFx1QTgwMVxcXFx1QTgwMy1cXFxcdUE4MDVcXFxcdUE4MDctXFxcXHVBODBBXFxcXHVBODBDLVxcXFx1QTgyMlxcXFx1QTg0MC1cXFxcdUE4NzNcXFxcdUE4ODItXFxcXHVBOEIzXFxcXHVBOEYyLVxcXFx1QThGN1xcXFx1QThGQlxcXFx1QTkwQS1cXFxcdUE5MjVcXFxcdUE5MzAtXFxcXHVBOTQ2XFxcXHVBOTYwLVxcXFx1QTk3Q1xcXFx1QTk4NC1cXFxcdUE5QjJcXFxcdUE5Q0ZcXFxcdUE5RTAtXFxcXHVBOUU0XFxcXHVBOUU2LVxcXFx1QTlFRlxcXFx1QTlGQS1cXFxcdUE5RkVcXFxcdUFBMDAtXFxcXHVBQTI4XFxcXHVBQTQwLVxcXFx1QUE0MlxcXFx1QUE0NC1cXFxcdUFBNEJcXFxcdUFBNjAtXFxcXHVBQTc2XFxcXHVBQTdBXFxcXHVBQTdFLVxcXFx1QUFBRlxcXFx1QUFCMVxcXFx1QUFCNVxcXFx1QUFCNlxcXFx1QUFCOS1cXFxcdUFBQkRcXFxcdUFBQzBcXFxcdUFBQzJcXFxcdUFBREItXFxcXHVBQUREXFxcXHVBQUUwLVxcXFx1QUFFQVxcXFx1QUFGMi1cXFxcdUFBRjRcXFxcdUFCMDEtXFxcXHVBQjA2XFxcXHVBQjA5LVxcXFx1QUIwRVxcXFx1QUIxMS1cXFxcdUFCMTZcXFxcdUFCMjAtXFxcXHVBQjI2XFxcXHVBQjI4LVxcXFx1QUIyRVxcXFx1QUIzMC1cXFxcdUFCNUFcXFxcdUFCNUMtXFxcXHVBQjVGXFxcXHVBQjY0XFxcXHVBQjY1XFxcXHVBQkMwLVxcXFx1QUJFMlxcXFx1QUMwMC1cXFxcdUQ3QTNcXFxcdUQ3QjAtXFxcXHVEN0M2XFxcXHVEN0NCLVxcXFx1RDdGQlxcXFx1RjkwMC1cXFxcdUZBNkRcXFxcdUZBNzAtXFxcXHVGQUQ5XFxcXHVGQjAwLVxcXFx1RkIwNlxcXFx1RkIxMy1cXFxcdUZCMTdcXFxcdUZCMURcXFxcdUZCMUYtXFxcXHVGQjI4XFxcXHVGQjJBLVxcXFx1RkIzNlxcXFx1RkIzOC1cXFxcdUZCM0NcXFxcdUZCM0VcXFxcdUZCNDBcXFxcdUZCNDFcXFxcdUZCNDNcXFxcdUZCNDRcXFxcdUZCNDYtXFxcXHVGQkIxXFxcXHVGQkQzLVxcXFx1RkQzRFxcXFx1RkQ1MC1cXFxcdUZEOEZcXFxcdUZEOTItXFxcXHVGREM3XFxcXHVGREYwLVxcXFx1RkRGQlxcXFx1RkU3MC1cXFxcdUZFNzRcXFxcdUZFNzYtXFxcXHVGRUZDXFxcXHVGRjIxLVxcXFx1RkYzQVxcXFx1RkY0MS1cXFxcdUZGNUFcXFxcdUZGNjYtXFxcXHVGRkJFXFxcXHVGRkMyLVxcXFx1RkZDN1xcXFx1RkZDQS1cXFxcdUZGQ0ZcXFxcdUZGRDItXFxcXHVGRkQ3XFxcXHVGRkRBLVxcXFx1RkZEQ10nKSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcblJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyUGFydCA9IG5ldyBSZWdFeHAoJ1tcXFxceEFBXFxcXHhCNVxcXFx4QkFcXFxceEMwLVxcXFx4RDZcXFxceEQ4LVxcXFx4RjZcXFxceEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzAwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzN0ZcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDQ4QS1cXFxcdTA1MkZcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDU5MS1cXFxcdTA1QkRcXFxcdTA1QkZcXFxcdTA1QzFcXFxcdTA1QzJcXFxcdTA1QzRcXFxcdTA1QzVcXFxcdTA1QzdcXFxcdTA1RDAtXFxcXHUwNUVBXFxcXHUwNUYwLVxcXFx1MDVGMlxcXFx1MDYxMC1cXFxcdTA2MUFcXFxcdTA2MjAtXFxcXHUwNjY5XFxcXHUwNjZFLVxcXFx1MDZEM1xcXFx1MDZENS1cXFxcdTA2RENcXFxcdTA2REYtXFxcXHUwNkU4XFxcXHUwNkVBLVxcXFx1MDZGQ1xcXFx1MDZGRlxcXFx1MDcxMC1cXFxcdTA3NEFcXFxcdTA3NEQtXFxcXHUwN0IxXFxcXHUwN0MwLVxcXFx1MDdGNVxcXFx1MDdGQVxcXFx1MDgwMC1cXFxcdTA4MkRcXFxcdTA4NDAtXFxcXHUwODVCXFxcXHUwOEEwLVxcXFx1MDhCMlxcXFx1MDhFNC1cXFxcdTA5NjNcXFxcdTA5NjYtXFxcXHUwOTZGXFxcXHUwOTcxLVxcXFx1MDk4M1xcXFx1MDk4NS1cXFxcdTA5OENcXFxcdTA5OEZcXFxcdTA5OTBcXFxcdTA5OTMtXFxcXHUwOUE4XFxcXHUwOUFBLVxcXFx1MDlCMFxcXFx1MDlCMlxcXFx1MDlCNi1cXFxcdTA5QjlcXFxcdTA5QkMtXFxcXHUwOUM0XFxcXHUwOUM3XFxcXHUwOUM4XFxcXHUwOUNCLVxcXFx1MDlDRVxcXFx1MDlEN1xcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTNcXFxcdTA5RTYtXFxcXHUwOUYxXFxcXHUwQTAxLVxcXFx1MEEwM1xcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEEzQ1xcXFx1MEEzRS1cXFxcdTBBNDJcXFxcdTBBNDdcXFxcdTBBNDhcXFxcdTBBNEItXFxcXHUwQTREXFxcXHUwQTUxXFxcXHUwQTU5LVxcXFx1MEE1Q1xcXFx1MEE1RVxcXFx1MEE2Ni1cXFxcdTBBNzVcXFxcdTBBODEtXFxcXHUwQTgzXFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkMtXFxcXHUwQUM1XFxcXHUwQUM3LVxcXFx1MEFDOVxcXFx1MEFDQi1cXFxcdTBBQ0RcXFxcdTBBRDBcXFxcdTBBRTAtXFxcXHUwQUUzXFxcXHUwQUU2LVxcXFx1MEFFRlxcXFx1MEIwMS1cXFxcdTBCMDNcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNDLVxcXFx1MEI0NFxcXFx1MEI0N1xcXFx1MEI0OFxcXFx1MEI0Qi1cXFxcdTBCNERcXFxcdTBCNTZcXFxcdTBCNTdcXFxcdTBCNUNcXFxcdTBCNURcXFxcdTBCNUYtXFxcXHUwQjYzXFxcXHUwQjY2LVxcXFx1MEI2RlxcXFx1MEI3MVxcXFx1MEI4MlxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkJFLVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNEXFxcXHUwQkQwXFxcXHUwQkQ3XFxcXHUwQkU2LVxcXFx1MEJFRlxcXFx1MEMwMC1cXFxcdTBDMDNcXFxcdTBDMDUtXFxcXHUwQzBDXFxcXHUwQzBFLVxcXFx1MEMxMFxcXFx1MEMxMi1cXFxcdTBDMjhcXFxcdTBDMkEtXFxcXHUwQzM5XFxcXHUwQzNELVxcXFx1MEM0NFxcXFx1MEM0Ni1cXFxcdTBDNDhcXFxcdTBDNEEtXFxcXHUwQzREXFxcXHUwQzU1XFxcXHUwQzU2XFxcXHUwQzU4XFxcXHUwQzU5XFxcXHUwQzYwLVxcXFx1MEM2M1xcXFx1MEM2Ni1cXFxcdTBDNkZcXFxcdTBDODEtXFxcXHUwQzgzXFxcXHUwQzg1LVxcXFx1MEM4Q1xcXFx1MEM4RS1cXFxcdTBDOTBcXFxcdTBDOTItXFxcXHUwQ0E4XFxcXHUwQ0FBLVxcXFx1MENCM1xcXFx1MENCNS1cXFxcdTBDQjlcXFxcdTBDQkMtXFxcXHUwQ0M0XFxcXHUwQ0M2LVxcXFx1MENDOFxcXFx1MENDQS1cXFxcdTBDQ0RcXFxcdTBDRDVcXFxcdTBDRDZcXFxcdTBDREVcXFxcdTBDRTAtXFxcXHUwQ0UzXFxcXHUwQ0U2LVxcXFx1MENFRlxcXFx1MENGMVxcXFx1MENGMlxcXFx1MEQwMS1cXFxcdTBEMDNcXFxcdTBEMDUtXFxcXHUwRDBDXFxcXHUwRDBFLVxcXFx1MEQxMFxcXFx1MEQxMi1cXFxcdTBEM0FcXFxcdTBEM0QtXFxcXHUwRDQ0XFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENEVcXFxcdTBENTdcXFxcdTBENjAtXFxcXHUwRDYzXFxcXHUwRDY2LVxcXFx1MEQ2RlxcXFx1MEQ3QS1cXFxcdTBEN0ZcXFxcdTBEODJcXFxcdTBEODNcXFxcdTBEODUtXFxcXHUwRDk2XFxcXHUwRDlBLVxcXFx1MERCMVxcXFx1MERCMy1cXFxcdTBEQkJcXFxcdTBEQkRcXFxcdTBEQzAtXFxcXHUwREM2XFxcXHUwRENBXFxcXHUwRENGLVxcXFx1MERENFxcXFx1MERENlxcXFx1MEREOC1cXFxcdTBEREZcXFxcdTBERTYtXFxcXHUwREVGXFxcXHUwREYyXFxcXHUwREYzXFxcXHUwRTAxLVxcXFx1MEUzQVxcXFx1MEU0MC1cXFxcdTBFNEVcXFxcdTBFNTAtXFxcXHUwRTU5XFxcXHUwRTgxXFxcXHUwRTgyXFxcXHUwRTg0XFxcXHUwRTg3XFxcXHUwRTg4XFxcXHUwRThBXFxcXHUwRThEXFxcXHUwRTk0LVxcXFx1MEU5N1xcXFx1MEU5OS1cXFxcdTBFOUZcXFxcdTBFQTEtXFxcXHUwRUEzXFxcXHUwRUE1XFxcXHUwRUE3XFxcXHUwRUFBXFxcXHUwRUFCXFxcXHUwRUFELVxcXFx1MEVCOVxcXFx1MEVCQi1cXFxcdTBFQkRcXFxcdTBFQzAtXFxcXHUwRUM0XFxcXHUwRUM2XFxcXHUwRUM4LVxcXFx1MEVDRFxcXFx1MEVEMC1cXFxcdTBFRDlcXFxcdTBFREMtXFxcXHUwRURGXFxcXHUwRjAwXFxcXHUwRjE4XFxcXHUwRjE5XFxcXHUwRjIwLVxcXFx1MEYyOVxcXFx1MEYzNVxcXFx1MEYzN1xcXFx1MEYzOVxcXFx1MEYzRS1cXFxcdTBGNDdcXFxcdTBGNDktXFxcXHUwRjZDXFxcXHUwRjcxLVxcXFx1MEY4NFxcXFx1MEY4Ni1cXFxcdTBGOTdcXFxcdTBGOTktXFxcXHUwRkJDXFxcXHUwRkM2XFxcXHUxMDAwLVxcXFx1MTA0OVxcXFx1MTA1MC1cXFxcdTEwOURcXFxcdTEwQTAtXFxcXHUxMEM1XFxcXHUxMEM3XFxcXHUxMENEXFxcXHUxMEQwLVxcXFx1MTBGQVxcXFx1MTBGQy1cXFxcdTEyNDhcXFxcdTEyNEEtXFxcXHUxMjREXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1QS1cXFxcdTEyNURcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhBLVxcXFx1MTI4RFxcXFx1MTI5MC1cXFxcdTEyQjBcXFxcdTEyQjItXFxcXHUxMkI1XFxcXHUxMkI4LVxcXFx1MTJCRVxcXFx1MTJDMFxcXFx1MTJDMi1cXFxcdTEyQzVcXFxcdTEyQzgtXFxcXHUxMkQ2XFxcXHUxMkQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVBXFxcXHUxMzVELVxcXFx1MTM1RlxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTEzQTAtXFxcXHUxM0Y0XFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2N0ZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTZFRS1cXFxcdTE2RjhcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxNFxcXFx1MTcyMC1cXFxcdTE3MzRcXFxcdTE3NDAtXFxcXHUxNzUzXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3ODAtXFxcXHUxN0QzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxN0REXFxcXHUxN0UwLVxcXFx1MTdFOVxcXFx1MTgwQi1cXFxcdTE4MERcXFxcdTE4MTAtXFxcXHUxODE5XFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxRVxcXFx1MTkyMC1cXFxcdTE5MkJcXFxcdTE5MzAtXFxcXHUxOTNCXFxcXHUxOTQ2LVxcXFx1MTk2RFxcXFx1MTk3MC1cXFxcdTE5NzRcXFxcdTE5ODAtXFxcXHUxOUFCXFxcXHUxOUIwLVxcXFx1MTlDOVxcXFx1MTlEMC1cXFxcdTE5RDlcXFxcdTFBMDAtXFxcXHUxQTFCXFxcXHUxQTIwLVxcXFx1MUE1RVxcXFx1MUE2MC1cXFxcdTFBN0NcXFxcdTFBN0YtXFxcXHUxQTg5XFxcXHUxQTkwLVxcXFx1MUE5OVxcXFx1MUFBN1xcXFx1MUFCMC1cXFxcdTFBQkRcXFxcdTFCMDAtXFxcXHUxQjRCXFxcXHUxQjUwLVxcXFx1MUI1OVxcXFx1MUI2Qi1cXFxcdTFCNzNcXFxcdTFCODAtXFxcXHUxQkYzXFxcXHUxQzAwLVxcXFx1MUMzN1xcXFx1MUM0MC1cXFxcdTFDNDlcXFxcdTFDNEQtXFxcXHUxQzdEXFxcXHUxQ0QwLVxcXFx1MUNEMlxcXFx1MUNENC1cXFxcdTFDRjZcXFxcdTFDRjhcXFxcdTFDRjlcXFxcdTFEMDAtXFxcXHUxREY1XFxcXHUxREZDLVxcXFx1MUYxNVxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjAtXFxcXHUxRjQ1XFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUYtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUZCNFxcXFx1MUZCNi1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2LVxcXFx1MUZDQ1xcXFx1MUZEMC1cXFxcdTFGRDNcXFxcdTFGRDYtXFxcXHUxRkRCXFxcXHUxRkUwLVxcXFx1MUZFQ1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjYtXFxcXHUxRkZDXFxcXHUyMDBDXFxcXHUyMDBEXFxcXHUyMDNGXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHUyMDcxXFxcXHUyMDdGXFxcXHUyMDkwLVxcXFx1MjA5Q1xcXFx1MjBEMC1cXFxcdTIwRENcXFxcdTIwRTFcXFxcdTIwRTUtXFxcXHUyMEYwXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTYwLVxcXFx1MjE4OFxcXFx1MkMwMC1cXFxcdTJDMkVcXFxcdTJDMzAtXFxcXHUyQzVFXFxcXHUyQzYwLVxcXFx1MkNFNFxcXFx1MkNFQi1cXFxcdTJDRjNcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDI3XFxcXHUyRDJEXFxcXHUyRDMwLVxcXFx1MkQ2N1xcXFx1MkQ2RlxcXFx1MkQ3Ri1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MkRFMC1cXFxcdTJERkZcXFxcdTJFMkZcXFxcdTMwMDUtXFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyRlxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwMzgtXFxcXHUzMDNDXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5OVxcXFx1MzA5QVxcXFx1MzA5RC1cXFxcdTMwOUZcXFxcdTMwQTEtXFxcXHUzMEZBXFxcXHUzMEZDLVxcXFx1MzBGRlxcXFx1MzEwNS1cXFxcdTMxMkRcXFxcdTMxMzEtXFxcXHUzMThFXFxcXHUzMUEwLVxcXFx1MzFCQVxcXFx1MzFGMC1cXFxcdTMxRkZcXFxcdTM0MDAtXFxcXHU0REI1XFxcXHU0RTAwLVxcXFx1OUZDQ1xcXFx1QTAwMC1cXFxcdUE0OENcXFxcdUE0RDAtXFxcXHVBNEZEXFxcXHVBNTAwLVxcXFx1QTYwQ1xcXFx1QTYxMC1cXFxcdUE2MkJcXFxcdUE2NDAtXFxcXHVBNjZGXFxcXHVBNjc0LVxcXFx1QTY3RFxcXFx1QTY3Ri1cXFxcdUE2OURcXFxcdUE2OUYtXFxcXHVBNkYxXFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTcyMi1cXFxcdUE3ODhcXFxcdUE3OEItXFxcXHVBNzhFXFxcXHVBNzkwLVxcXFx1QTdBRFxcXFx1QTdCMFxcXFx1QTdCMVxcXFx1QTdGNy1cXFxcdUE4MjdcXFxcdUE4NDAtXFxcXHVBODczXFxcXHVBODgwLVxcXFx1QThDNFxcXFx1QThEMC1cXFxcdUE4RDlcXFxcdUE4RTAtXFxcXHVBOEY3XFxcXHVBOEZCXFxcXHVBOTAwLVxcXFx1QTkyRFxcXFx1QTkzMC1cXFxcdUE5NTNcXFxcdUE5NjAtXFxcXHVBOTdDXFxcXHVBOTgwLVxcXFx1QTlDMFxcXFx1QTlDRi1cXFxcdUE5RDlcXFxcdUE5RTAtXFxcXHVBOUZFXFxcXHVBQTAwLVxcXFx1QUEzNlxcXFx1QUE0MC1cXFxcdUFBNERcXFxcdUFBNTAtXFxcXHVBQTU5XFxcXHVBQTYwLVxcXFx1QUE3NlxcXFx1QUE3QS1cXFxcdUFBQzJcXFxcdUFBREItXFxcXHVBQUREXFxcXHVBQUUwLVxcXFx1QUFFRlxcXFx1QUFGMi1cXFxcdUFBRjZcXFxcdUFCMDEtXFxcXHVBQjA2XFxcXHVBQjA5LVxcXFx1QUIwRVxcXFx1QUIxMS1cXFxcdUFCMTZcXFxcdUFCMjAtXFxcXHVBQjI2XFxcXHVBQjI4LVxcXFx1QUIyRVxcXFx1QUIzMC1cXFxcdUFCNUFcXFxcdUFCNUMtXFxcXHVBQjVGXFxcXHVBQjY0XFxcXHVBQjY1XFxcXHVBQkMwLVxcXFx1QUJFQVxcXFx1QUJFQ1xcXFx1QUJFRFxcXFx1QUJGMC1cXFxcdUFCRjlcXFxcdUFDMDAtXFxcXHVEN0EzXFxcXHVEN0IwLVxcXFx1RDdDNlxcXFx1RDdDQi1cXFxcdUQ3RkJcXFxcdUY5MDAtXFxcXHVGQTZEXFxcXHVGQTcwLVxcXFx1RkFEOVxcXFx1RkIwMC1cXFxcdUZCMDZcXFxcdUZCMTMtXFxcXHVGQjE3XFxcXHVGQjFELVxcXFx1RkIyOFxcXFx1RkIyQS1cXFxcdUZCMzZcXFxcdUZCMzgtXFxcXHVGQjNDXFxcXHVGQjNFXFxcXHVGQjQwXFxcXHVGQjQxXFxcXHVGQjQzXFxcXHVGQjQ0XFxcXHVGQjQ2LVxcXFx1RkJCMVxcXFx1RkJEMy1cXFxcdUZEM0RcXFxcdUZENTAtXFxcXHVGRDhGXFxcXHVGRDkyLVxcXFx1RkRDN1xcXFx1RkRGMC1cXFxcdUZERkJcXFxcdUZFMDAtXFxcXHVGRTBGXFxcXHVGRTIwLVxcXFx1RkUyRFxcXFx1RkUzM1xcXFx1RkUzNFxcXFx1RkU0RC1cXFxcdUZFNEZcXFxcdUZFNzAtXFxcXHVGRTc0XFxcXHVGRTc2LVxcXFx1RkVGQ1xcXFx1RkYxMC1cXFxcdUZGMTlcXFxcdUZGMjEtXFxcXHVGRjNBXFxcXHVGRjNGXFxcXHVGRjQxLVxcXFx1RkY1QVxcXFx1RkY2Ni1cXFxcdUZGQkVcXFxcdUZGQzItXFxcXHVGRkM3XFxcXHVGRkNBLVxcXFx1RkZDRlxcXFx1RkZEMi1cXFxcdUZGRDdcXFxcdUZGREEtXFxcXHVGRkRDXScpOyAvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4vLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbi8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuLy8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuIGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOTsgLy8gMC4uOVxufVxuXG5mdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRicuaW5kZXhPZihjaCkgPj0gMDtcbn1cblxuZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG59IC8vIDcuMiBXaGl0ZSBTcGFjZVxuXG5cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICByZXR1cm4gY2ggPT09IDB4MjAgfHwgY2ggPT09IDB4MDkgfHwgY2ggPT09IDB4MEIgfHwgY2ggPT09IDB4MEMgfHwgY2ggPT09IDB4QTAgfHwgY2ggPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MTgwRSwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjaCkgPj0gMDtcbn0gLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuXG5mdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgwQSB8fCBjaCA9PT0gMHgwRCB8fCBjaCA9PT0gMHgyMDI4IHx8IGNoID09PSAweDIwMjk7XG59IC8vIDcuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RiB8fCBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHwgY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBIHx8IGNoID09PSAweDVDIHx8IGNoID49IDB4ODAgJiYgUmVnZXhOb25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICByZXR1cm4gY2ggPT09IDB4MjQgfHwgY2ggPT09IDB4NUYgfHwgY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBIHx8IGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSB8fCBjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkgfHwgY2ggPT09IDB4NUMgfHwgY2ggPj0gMHg4MCAmJiBSZWdleE5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSk7XG59IC8vIDcuNi4xLjEgS2V5d29yZHNcblxuXG5jb25zdCBrZXl3b3JkcyA9IHtcbiAgJ2lmJzogMSxcbiAgJ2luJzogMSxcbiAgJ2RvJzogMSxcbiAgJ3Zhcic6IDEsXG4gICdmb3InOiAxLFxuICAnbmV3JzogMSxcbiAgJ3RyeSc6IDEsXG4gICdsZXQnOiAxLFxuICAndGhpcyc6IDEsXG4gICdlbHNlJzogMSxcbiAgJ2Nhc2UnOiAxLFxuICAndm9pZCc6IDEsXG4gICd3aXRoJzogMSxcbiAgJ2VudW0nOiAxLFxuICAnd2hpbGUnOiAxLFxuICAnYnJlYWsnOiAxLFxuICAnY2F0Y2gnOiAxLFxuICAndGhyb3cnOiAxLFxuICAnY29uc3QnOiAxLFxuICAneWllbGQnOiAxLFxuICAnY2xhc3MnOiAxLFxuICAnc3VwZXInOiAxLFxuICAncmV0dXJuJzogMSxcbiAgJ3R5cGVvZic6IDEsXG4gICdkZWxldGUnOiAxLFxuICAnc3dpdGNoJzogMSxcbiAgJ2V4cG9ydCc6IDEsXG4gICdpbXBvcnQnOiAxLFxuICAncHVibGljJzogMSxcbiAgJ3N0YXRpYyc6IDEsXG4gICdkZWZhdWx0JzogMSxcbiAgJ2ZpbmFsbHknOiAxLFxuICAnZXh0ZW5kcyc6IDEsXG4gICdwYWNrYWdlJzogMSxcbiAgJ3ByaXZhdGUnOiAxLFxuICAnZnVuY3Rpb24nOiAxLFxuICAnY29udGludWUnOiAxLFxuICAnZGVidWdnZXInOiAxLFxuICAnaW50ZXJmYWNlJzogMSxcbiAgJ3Byb3RlY3RlZCc6IDEsXG4gICdpbnN0YW5jZW9mJzogMSxcbiAgJ2ltcGxlbWVudHMnOiAxXG59O1xuXG5mdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY29uc3QgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICBpZiAoaXNXaGl0ZVNwYWNlKGNoKSB8fCBpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgKytpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gIHZhciBpLFxuICAgICAgbGVuLFxuICAgICAgY2gsXG4gICAgICBjb2RlID0gMDtcbiAgbGVuID0gcHJlZml4ID09PSAndScgPyA0IDogMjtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xufVxuXG5mdW5jdGlvbiBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpIHtcbiAgdmFyIGNoLCBjb2RlLCBjdTEsIGN1MjtcbiAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICBjb2RlID0gMDsgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG5cbiAgaWYgKGNoID09PSAnfScpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgaWYgKGNvZGUgPiAweDEwRkZGRiB8fCBjaCAhPT0gJ30nKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH0gLy8gVVRGLTE2IEVuY29kaW5nXG5cblxuICBpZiAoY29kZSA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIGN1MSA9IChjb2RlIC0gMHgxMDAwMCA+PiAxMCkgKyAweEQ4MDA7XG4gIGN1MiA9IChjb2RlIC0gMHgxMDAwMCAmIDEwMjMpICsgMHhEQzAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjdTEsIGN1Mik7XG59XG5cbmZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xuICB2YXIgY2gsIGlkO1xuICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KyspO1xuICBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpOyAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG5cbiAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfVxuXG4gICAgKytpbmRleDtcbiAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcblxuICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH1cblxuICAgIGlkID0gY2g7XG4gIH1cblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgICsraW5kZXg7XG4gICAgaWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7IC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cblxuICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XG5cbiAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgICB9XG5cbiAgICAgICsraW5kZXg7XG4gICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcblxuICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgICAgfVxuXG4gICAgICBpZCArPSBjaDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGdldElkZW50aWZpZXIoKSB7XG4gIHZhciBzdGFydCwgY2g7XG4gIHN0YXJ0ID0gaW5kZXgrKztcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgIGluZGV4ID0gc3RhcnQ7XG4gICAgICByZXR1cm4gZ2V0RXNjYXBlZElkZW50aWZpZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICsraW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KTtcbn1cblxuZnVuY3Rpb24gc2NhbklkZW50aWZpZXIoKSB7XG4gIHZhciBzdGFydCwgaWQsIHR5cGU7XG4gIHN0YXJ0ID0gaW5kZXg7IC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG5cbiAgaWQgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4NUMgPyBnZXRFc2NhcGVkSWRlbnRpZmllcigpIDogZ2V0SWRlbnRpZmllcigpOyAvLyBUaGVyZSBpcyBubyBrZXl3b3JkIG9yIGxpdGVyYWwgd2l0aCBvbmx5IG9uZSBjaGFyYWN0ZXIuXG4gIC8vIFRodXMsIGl0IG11c3QgYmUgYW4gaWRlbnRpZmllci5cblxuICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgdHlwZSA9IFRva2VuSWRlbnRpZmllcjtcbiAgfSBlbHNlIGlmIChrZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHR5cGUgPSBUb2tlbktleXdvcmQ7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdudWxsJykge1xuICAgIHR5cGUgPSBUb2tlbk51bGxMaXRlcmFsO1xuICB9IGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcbiAgICB0eXBlID0gVG9rZW5Cb29sZWFuTGl0ZXJhbDtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gVG9rZW5JZGVudGlmaWVyO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZhbHVlOiBpZCxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBpbmRleFxuICB9O1xufSAvLyA3LjcgUHVuY3R1YXRvcnNcblxuXG5mdW5jdGlvbiBzY2FuUHVuY3R1YXRvcigpIHtcbiAgdmFyIHN0YXJ0ID0gaW5kZXgsXG4gICAgICBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpLFxuICAgICAgY29kZTIsXG4gICAgICBjaDEgPSBzb3VyY2VbaW5kZXhdLFxuICAgICAgY2gyLFxuICAgICAgY2gzLFxuICAgICAgY2g0O1xuXG4gIHN3aXRjaCAoY29kZSkge1xuICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgIGNhc2UgMHgyRTogLy8gLiBkb3RcblxuICAgIGNhc2UgMHgyODogLy8gKCBvcGVuIGJyYWNrZXRcblxuICAgIGNhc2UgMHgyOTogLy8gKSBjbG9zZSBicmFja2V0XG5cbiAgICBjYXNlIDB4M0I6IC8vIDsgc2VtaWNvbG9uXG5cbiAgICBjYXNlIDB4MkM6IC8vICwgY29tbWFcblxuICAgIGNhc2UgMHg3QjogLy8geyBvcGVuIGN1cmx5IGJyYWNlXG5cbiAgICBjYXNlIDB4N0Q6IC8vIH0gY2xvc2UgY3VybHkgYnJhY2VcblxuICAgIGNhc2UgMHg1QjogLy8gW1xuXG4gICAgY2FzZSAweDVEOiAvLyBdXG5cbiAgICBjYXNlIDB4M0E6IC8vIDpcblxuICAgIGNhc2UgMHgzRjogLy8gP1xuXG4gICAgY2FzZSAweDdFOlxuICAgICAgLy8gflxuICAgICAgKytpbmRleDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFRva2VuUHVuY3R1YXRvcixcbiAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSksXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjb2RlMiA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSk7IC8vICc9JyAoVSswMDNEKSBtYXJrcyBhbiBhc3NpZ25tZW50IG9yIGNvbXBhcmlzb24gb3BlcmF0b3IuXG5cbiAgICAgIGlmIChjb2RlMiA9PT0gMHgzRCkge1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDB4MkI6IC8vICtcblxuICAgICAgICAgIGNhc2UgMHgyRDogLy8gLVxuXG4gICAgICAgICAgY2FzZSAweDJGOiAvLyAvXG5cbiAgICAgICAgICBjYXNlIDB4M0M6IC8vIDxcblxuICAgICAgICAgIGNhc2UgMHgzRTogLy8gPlxuXG4gICAgICAgICAgY2FzZSAweDVFOiAvLyBeXG5cbiAgICAgICAgICBjYXNlIDB4N0M6IC8vIHxcblxuICAgICAgICAgIGNhc2UgMHgyNTogLy8gJVxuXG4gICAgICAgICAgY2FzZSAweDI2OiAvLyAmXG5cbiAgICAgICAgICBjYXNlIDB4MkE6XG4gICAgICAgICAgICAvLyAqXG4gICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZTIpLFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlIDB4MjE6IC8vICFcblxuICAgICAgICAgIGNhc2UgMHgzRDpcbiAgICAgICAgICAgIC8vID1cbiAgICAgICAgICAgIGluZGV4ICs9IDI7IC8vICE9PSBhbmQgPT09XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0QpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCksXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIH0gLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvcjogPj4+PVxuXG5cbiAgY2g0ID0gc291cmNlLnN1YnN0cihpbmRleCwgNCk7XG5cbiAgaWYgKGNoNCA9PT0gJz4+Pj0nKSB7XG4gICAgaW5kZXggKz0gNDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoNCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9IC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cblxuICBjaDMgPSBjaDQuc3Vic3RyKDAsIDMpO1xuXG4gIGlmIChjaDMgPT09ICc+Pj4nIHx8IGNoMyA9PT0gJzw8PScgfHwgY2gzID09PSAnPj49Jykge1xuICAgIGluZGV4ICs9IDM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFRva2VuUHVuY3R1YXRvcixcbiAgICAgIHZhbHVlOiBjaDMsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGluZGV4XG4gICAgfTtcbiAgfSAvLyBPdGhlciAyLWNoYXJhY3RlciBwdW5jdHVhdG9yczogKysgLS0gPDwgPj4gJiYgfHxcblxuXG4gIGNoMiA9IGNoMy5zdWJzdHIoMCwgMik7XG5cbiAgaWYgKGNoMSA9PT0gY2gyWzFdICYmICcrLTw+JnwnLmluZGV4T2YoY2gxKSA+PSAwIHx8IGNoMiA9PT0gJz0+Jykge1xuICAgIGluZGV4ICs9IDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFRva2VuUHVuY3R1YXRvcixcbiAgICAgIHZhbHVlOiBjaDIsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGluZGV4XG4gICAgfTtcbiAgfVxuXG4gIGlmIChjaDIgPT09ICcvLycpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfSAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPCA+ID0gISArIC0gKiAlICYgfCBeIC9cblxuXG4gIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKGNoMSkgPj0gMCkge1xuICAgICsraW5kZXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFRva2VuUHVuY3R1YXRvcixcbiAgICAgIHZhbHVlOiBjaDEsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGluZGV4XG4gICAgfTtcbiAgfVxuXG4gIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xufSAvLyA3LjguMyBOdW1lcmljIExpdGVyYWxzXG5cblxuZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgbGV0IG51bWJlciA9ICcnO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmICghaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgfVxuXG4gIGlmIChudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cblxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUb2tlbk51bWVyaWNMaXRlcmFsLFxuICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCkge1xuICBsZXQgbnVtYmVyID0gJzAnICsgc291cmNlW2luZGV4KytdO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICB9XG5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUb2tlbk51bWVyaWNMaXRlcmFsLFxuICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgIG9jdGFsOiB0cnVlLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5OdW1lcmljTGl0ZXJhbCgpIHtcbiAgdmFyIG51bWJlciwgc3RhcnQsIGNoO1xuICBjaCA9IHNvdXJjZVtpbmRleF07XG4gIGFzc2VydChpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCBjaCA9PT0gJy4nLCAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XG4gIHN0YXJ0ID0gaW5kZXg7XG4gIG51bWJlciA9ICcnO1xuXG4gIGlmIChjaCAhPT0gJy4nKSB7XG4gICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgIGNoID0gc291cmNlW2luZGV4XTsgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXG5cbiAgICBpZiAobnVtYmVyID09PSAnMCcpIHtcbiAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgKytpbmRleDtcbiAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgcmV0dXJuIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpO1xuICAgICAgfSAvLyBkZWNpbWFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcgc3VjaCBhcyAnMDknIGlzIGlsbGVnYWwuXG5cblxuICAgICAgaWYgKGNoICYmIGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgIH1cblxuICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgIH1cblxuICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgIGNoID0gc291cmNlW2luZGV4XTtcblxuICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcbiAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgfVxuXG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFRva2VuTnVtZXJpY0xpdGVyYWwsXG4gICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBpbmRleFxuICB9O1xufSAvLyA3LjguNCBTdHJpbmcgTGl0ZXJhbHNcblxuXG5mdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgdmFyIHN0ciA9ICcnLFxuICAgICAgcXVvdGUsXG4gICAgICBzdGFydCxcbiAgICAgIGNoLFxuICAgICAgY29kZSxcbiAgICAgIG9jdGFsID0gZmFsc2U7XG4gIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgYXNzZXJ0KHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJywgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuICBzdGFydCA9IGluZGV4O1xuICArK2luZGV4O1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgcXVvdGUgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgIGlmICghY2ggfHwgIWlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICBzdHIgKz0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTsgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcblxuICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7IC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXG4gICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG5cbiAgICAgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiYgaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9IGNoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogVG9rZW5TdHJpbmdMaXRlcmFsLFxuICAgIHZhbHVlOiBzdHIsXG4gICAgb2N0YWw6IG9jdGFsLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgbGV0IHRtcCA9IHBhdHRlcm47XG5cbiAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSA+PSAwKSB7XG4gICAgLy8gUmVwbGFjZSBlYWNoIGFzdHJhbCBzeW1ib2wgYW5kIGV2ZXJ5IFVuaWNvZGUgY29kZSBwb2ludFxuICAgIC8vIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIEFTQ0lJIHN5bWJvbCB0byBhdm9pZCB0aHJvd2luZyBvblxuICAgIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBhcmUgb25seSB2YWxpZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZVxuICAgIC8vIGAvdWAgZmxhZy5cbiAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCB0aGUgQVNDSUkgc3ltYm9sIGB4YCBtaWdodCBjYXVzZSBmYWxzZVxuICAgIC8vIG5lZ2F0aXZlcyBpbiB1bmxpa2VseSBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXs2MX0tYl1gIGlzIGFcbiAgICAvLyBwZXJmZWN0bHkgdmFsaWQgcGF0dGVybiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYFthLWJdYCwgYnV0IGl0XG4gICAgLy8gd291bGQgYmUgcmVwbGFjZWQgYnkgYFt4LWJdYCB3aGljaCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgdG1wID0gdG1wLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH0vZywgKCQwLCAkMSkgPT4ge1xuICAgICAgaWYgKHBhcnNlSW50KCQxLCAxNikgPD0gMHgxMEZGRkYpIHtcbiAgICAgICAgcmV0dXJuICd4JztcbiAgICAgIH1cblxuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZUludmFsaWRSZWdFeHApO1xuICAgIH0pLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgJ3gnKTtcbiAgfSAvLyBGaXJzdCwgZGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cblxuXG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cCh0bXApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZUludmFsaWRSZWdFeHApO1xuICB9IC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXG4gIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcbiAgLy8gdXNlcy5cblxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FuUmVnRXhwQm9keSgpIHtcbiAgdmFyIGNoLCBzdHIsIGNsYXNzTWFya2VyLCB0ZXJtaW5hdGVkLCBib2R5O1xuICBjaCA9IHNvdXJjZVtpbmRleF07XG4gIGFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcbiAgc3RyID0gc291cmNlW2luZGV4KytdO1xuICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICB0ZXJtaW5hdGVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgc3RyICs9IGNoO1xuXG4gICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgIGNoID0gc291cmNlW2luZGV4KytdOyAvLyBFQ01BLTI2MiA3LjguNVxuXG4gICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IGNoO1xuICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgfSBlbHNlIGlmIChjbGFzc01hcmtlcikge1xuICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgfSAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuXG5cbiAgYm9keSA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBib2R5LFxuICAgIGxpdGVyYWw6IHN0clxuICB9O1xufVxuXG5mdW5jdGlvbiBzY2FuUmVnRXhwRmxhZ3MoKSB7XG4gIHZhciBjaCwgc3RyLCBmbGFncztcbiAgc3RyID0gJyc7XG4gIGZsYWdzID0gJyc7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICArK2luZGV4O1xuXG4gICAgaWYgKGNoID09PSAnXFxcXCcgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGFncyArPSBjaDtcbiAgICAgIHN0ciArPSBjaDtcbiAgICB9XG4gIH1cblxuICBpZiAoZmxhZ3Muc2VhcmNoKC9bXmdpbXV5XS9nKSA+PSAwKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZUludmFsaWRSZWdFeHAsIGZsYWdzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGZsYWdzLFxuICAgIGxpdGVyYWw6IHN0clxuICB9O1xufVxuXG5mdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xuICB2YXIgc3RhcnQsIGJvZHksIGZsYWdzLCB2YWx1ZTtcbiAgbG9va2FoZWFkID0gbnVsbDtcbiAgc2tpcENvbW1lbnQoKTtcbiAgc3RhcnQgPSBpbmRleDtcbiAgYm9keSA9IHNjYW5SZWdFeHBCb2R5KCk7XG4gIGZsYWdzID0gc2NhblJlZ0V4cEZsYWdzKCk7XG4gIHZhbHVlID0gdGVzdFJlZ0V4cChib2R5LnZhbHVlLCBmbGFncy52YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgbGl0ZXJhbDogYm9keS5saXRlcmFsICsgZmxhZ3MubGl0ZXJhbCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcmVnZXg6IHtcbiAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICB9LFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuSWRlbnRpZmllciB8fCB0b2tlbi50eXBlID09PSBUb2tlbktleXdvcmQgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW5Cb29sZWFuTGl0ZXJhbCB8fCB0b2tlbi50eXBlID09PSBUb2tlbk51bGxMaXRlcmFsO1xufVxuXG5mdW5jdGlvbiBhZHZhbmNlKCkge1xuICBza2lwQ29tbWVudCgpO1xuXG4gIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5FT0YsXG4gICAgICBzdGFydDogaW5kZXgsXG4gICAgICBlbmQ6IGluZGV4XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICByZXR1cm4gc2NhbklkZW50aWZpZXIoKTtcbiAgfSAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xuXG5cbiAgaWYgKGNoID09PSAweDI4IHx8IGNoID09PSAweDI5IHx8IGNoID09PSAweDNCKSB7XG4gICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gIH0gLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cblxuXG4gIGlmIChjaCA9PT0gMHgyNyB8fCBjaCA9PT0gMHgyMikge1xuICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICB9IC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG5cblxuICBpZiAoY2ggPT09IDB4MkUpIHtcbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfVxuXG4gIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gIH1cblxuICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbn1cblxuZnVuY3Rpb24gbGV4KCkge1xuICBjb25zdCB0b2tlbiA9IGxvb2thaGVhZDtcbiAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gIGxvb2thaGVhZCA9IGFkdmFuY2UoKTtcbiAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gIHJldHVybiB0b2tlbjtcbn1cblxuZnVuY3Rpb24gcGVlaygpIHtcbiAgY29uc3QgcG9zID0gaW5kZXg7XG4gIGxvb2thaGVhZCA9IGFkdmFuY2UoKTtcbiAgaW5kZXggPSBwb3M7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaEFycmF5RXhwcmVzc2lvbihlbGVtZW50cykge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4QXJyYXlFeHByZXNzaW9uKTtcbiAgbm9kZS5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnID8gU3ludGF4TG9naWNhbEV4cHJlc3Npb24gOiBTeW50YXhCaW5hcnlFeHByZXNzaW9uKTtcbiAgbm9kZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheENhbGxFeHByZXNzaW9uKTtcbiAgbm9kZS5jYWxsZWUgPSBjYWxsZWU7XG4gIG5vZGUuYXJndW1lbnRzID0gYXJncztcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheENvbmRpdGlvbmFsRXhwcmVzc2lvbik7XG4gIG5vZGUudGVzdCA9IHRlc3Q7XG4gIG5vZGUuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gIG5vZGUuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoSWRlbnRpZmllcihuYW1lKSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhJZGVudGlmaWVyKTtcbiAgbm9kZS5uYW1lID0gbmFtZTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaExpdGVyYWwodG9rZW4pIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheExpdGVyYWwpO1xuICBub2RlLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gIG5vZGUucmF3ID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuXG4gIGlmICh0b2tlbi5yZWdleCkge1xuICAgIGlmIChub2RlLnJhdyA9PT0gJy8vJykge1xuICAgICAgbm9kZS5yYXcgPSAnLyg/OikvJztcbiAgICB9XG5cbiAgICBub2RlLnJlZ2V4ID0gdG9rZW4ucmVnZXg7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTWVtYmVyRXhwcmVzc2lvbihhY2Nlc3Nvciwgb2JqZWN0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4TWVtYmVyRXhwcmVzc2lvbik7XG4gIG5vZGUuY29tcHV0ZWQgPSBhY2Nlc3NvciA9PT0gJ1snO1xuICBub2RlLm9iamVjdCA9IG9iamVjdDtcbiAgbm9kZS5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICBpZiAoIW5vZGUuY29tcHV0ZWQpIHByb3BlcnR5Lm1lbWJlciA9IHRydWU7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheE9iamVjdEV4cHJlc3Npb24pO1xuICBub2RlLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoUHJvcGVydHkoa2luZCwga2V5LCB2YWx1ZSkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4UHJvcGVydHkpO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBub2RlLmtpbmQgPSBraW5kO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4VW5hcnlFeHByZXNzaW9uKTtcbiAgbm9kZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICBub2RlLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGU7XG59IC8vIFRocm93IGFuIGV4Y2VwdGlvblxuXG5cbmZ1bmN0aW9uIHRocm93RXJyb3IodG9rZW4sIG1lc3NhZ2VGb3JtYXQpIHtcbiAgdmFyIGVycm9yLFxuICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCAod2hvbGUsIGluZGV4KSA9PiB7XG4gICAgYXNzZXJ0KGluZGV4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgcmV0dXJuIGFyZ3NbaW5kZXhdO1xuICB9KTtcbiAgZXJyb3IgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyb3IuaW5kZXggPSBpbmRleDtcbiAgZXJyb3IuZGVzY3JpcHRpb24gPSBtc2c7XG4gIHRocm93IGVycm9yO1xufSAvLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXG5cblxuZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkKHRva2VuKSB7XG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbkVPRikge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkRU9TKTtcbiAgfVxuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbk51bWVyaWNMaXRlcmFsKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWROdW1iZXIpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuU3RyaW5nTGl0ZXJhbCkge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkU3RyaW5nKTtcbiAgfVxuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbklkZW50aWZpZXIpIHtcbiAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlVW5leHBlY3RlZElkZW50aWZpZXIpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuS2V5d29yZCkge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkUmVzZXJ2ZWQpO1xuICB9IC8vIEJvb2xlYW5MaXRlcmFsLCBOdWxsTGl0ZXJhbCwgb3IgUHVuY3R1YXRvci5cblxuXG4gIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbn0gLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cbi8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG5cbmZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICBjb25zdCB0b2tlbiA9IGxleCgpO1xuXG4gIGlmICh0b2tlbi50eXBlICE9PSBUb2tlblB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgfVxufSAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblxuXG5mdW5jdGlvbiBtYXRjaCh2YWx1ZSkge1xuICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudmFsdWUgPT09IHZhbHVlO1xufSAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5d29yZFxuXG5cbmZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW5LZXl3b3JkICYmIGxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcbn0gLy8gMTEuMS40IEFycmF5IEluaXRpYWxpc2VyXG5cblxuZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgZXhwZWN0KCdbJyk7XG5cbiAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgIGxleCgpO1xuICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHMucHVzaChwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpKTtcblxuICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxleCgpO1xuICByZXR1cm4gZmluaXNoQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKTtcbn0gLy8gMTEuMS41IE9iamVjdCBJbml0aWFsaXNlclxuXG5cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICBjb25zdCB0b2tlbiA9IGxleCgpOyAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IGZyb20gcGFyc2VPYmplY3RQcm9wZXJ0eSgpLCB3aGVyZVxuICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5TdHJpbmdMaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuTnVtZXJpY0xpdGVyYWwpIHtcbiAgICBpZiAodG9rZW4ub2N0YWwpIHtcbiAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VTdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgfVxuXG4gIHJldHVybiBmaW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eSgpIHtcbiAgdmFyIHRva2VuLCBrZXksIGlkLCB2YWx1ZTtcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIHRva2VuID0gbG9va2FoZWFkO1xuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbklkZW50aWZpZXIpIHtcbiAgICBpZCA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICBleHBlY3QoJzonKTtcbiAgICB2YWx1ZSA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG4gICAgcmV0dXJuIGZpbmlzaFByb3BlcnR5KCdpbml0JywgaWQsIHZhbHVlKTtcbiAgfVxuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbkVPRiB8fCB0b2tlbi50eXBlID09PSBUb2tlblB1bmN0dWF0b3IpIHtcbiAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICBleHBlY3QoJzonKTtcbiAgICB2YWx1ZSA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG4gICAgcmV0dXJuIGZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSBbXSxcbiAgICAgIHByb3BlcnR5LFxuICAgICAgbmFtZSxcbiAgICAgIGtleSxcbiAgICAgIG1hcCA9IHt9LFxuICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICBleHBlY3QoJ3snKTtcblxuICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICBwcm9wZXJ0eSA9IHBhcnNlT2JqZWN0UHJvcGVydHkoKTtcblxuICAgIGlmIChwcm9wZXJ0eS5rZXkudHlwZSA9PT0gU3ludGF4SWRlbnRpZmllcikge1xuICAgICAgbmFtZSA9IHByb3BlcnR5LmtleS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICB9XG5cbiAgICBrZXkgPSAnJCcgKyBuYW1lO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VTdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcFtrZXldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICBleHBlY3QoJywnKTtcbiAgICB9XG4gIH1cblxuICBleHBlY3QoJ30nKTtcbiAgcmV0dXJuIGZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcyk7XG59IC8vIDExLjEuNiBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuXG5mdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgZXhwZWN0KCcoJyk7XG4gIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgZXhwZWN0KCcpJyk7XG4gIHJldHVybiBleHByO1xufSAvLyAxMS4xIFByaW1hcnkgRXhwcmVzc2lvbnNcblxuXG5jb25zdCBsZWdhbEtleXdvcmRzID0ge1xuICAnaWYnOiAxXG59O1xuXG5mdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCkge1xuICB2YXIgdHlwZSwgdG9rZW4sIGV4cHI7XG5cbiAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICByZXR1cm4gcGFyc2VHcm91cEV4cHJlc3Npb24oKTtcbiAgfVxuXG4gIGlmIChtYXRjaCgnWycpKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICB9XG5cbiAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICB9XG5cbiAgdHlwZSA9IGxvb2thaGVhZC50eXBlO1xuICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcblxuICBpZiAodHlwZSA9PT0gVG9rZW5JZGVudGlmaWVyIHx8IGxlZ2FsS2V5d29yZHNbbG9va2FoZWFkLnZhbHVlXSkge1xuICAgIGV4cHIgPSBmaW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlblN0cmluZ0xpdGVyYWwgfHwgdHlwZSA9PT0gVG9rZW5OdW1lcmljTGl0ZXJhbCkge1xuICAgIGlmIChsb29rYWhlYWQub2N0YWwpIHtcbiAgICAgIHRocm93RXJyb3IobG9va2FoZWFkLCBNZXNzYWdlU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICB9XG5cbiAgICBleHByID0gZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW5LZXl3b3JkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKERJU0FCTEVEKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbkJvb2xlYW5MaXRlcmFsKSB7XG4gICAgdG9rZW4gPSBsZXgoKTtcbiAgICB0b2tlbi52YWx1ZSA9IHRva2VuLnZhbHVlID09PSAndHJ1ZSc7XG4gICAgZXhwciA9IGZpbmlzaExpdGVyYWwodG9rZW4pO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuTnVsbExpdGVyYWwpIHtcbiAgICB0b2tlbiA9IGxleCgpO1xuICAgIHRva2VuLnZhbHVlID0gbnVsbDtcbiAgICBleHByID0gZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgIGV4cHIgPSBmaW5pc2hMaXRlcmFsKHNjYW5SZWdFeHAoKSk7XG4gICAgcGVlaygpO1xuICB9IGVsc2Uge1xuICAgIHRocm93VW5leHBlY3RlZChsZXgoKSk7XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn0gLy8gMTEuMiBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG5cbmZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICBjb25zdCBhcmdzID0gW107XG4gIGV4cGVjdCgnKCcpO1xuXG4gIGlmICghbWF0Y2goJyknKSkge1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJncy5wdXNoKHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkpO1xuXG4gICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KCcsJyk7XG4gICAgfVxuICB9XG5cbiAgZXhwZWN0KCcpJyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKSB7XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICBjb25zdCB0b2tlbiA9IGxleCgpO1xuXG4gIGlmICghaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcbiAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICB9XG5cbiAgcmV0dXJuIGZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICBleHBlY3QoJy4nKTtcbiAgcmV0dXJuIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbXB1dGVkTWVtYmVyKCkge1xuICBleHBlY3QoJ1snKTtcbiAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICBleHBlY3QoJ10nKTtcbiAgcmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpIHtcbiAgdmFyIGV4cHIsIGFyZ3MsIHByb3BlcnR5O1xuICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gIGZvciAoOzspIHtcbiAgICBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICBleHByID0gZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgZXhwciA9IGZpbmlzaENhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICBleHByID0gZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHI7XG59IC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG5cbmZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gIGNvbnN0IGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKTtcblxuICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuUHVuY3R1YXRvcikge1xuICAgIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKERJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn0gLy8gMTEuNCBVbmFyeSBPcGVyYXRvcnNcblxuXG5mdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgdmFyIHRva2VuLCBleHByO1xuXG4gIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbktleXdvcmQpIHtcbiAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICB9IGVsc2UgaWYgKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKERJU0FCTEVEKTtcbiAgfSBlbHNlIGlmIChtYXRjaCgnKycpIHx8IG1hdGNoKCctJykgfHwgbWF0Y2goJ34nKSB8fCBtYXRjaCgnIScpKSB7XG4gICAgdG9rZW4gPSBsZXgoKTtcbiAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICBleHByID0gZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpO1xuICB9IGVsc2Uge1xuICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbikge1xuICBsZXQgcHJlYyA9IDA7XG5cbiAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuUHVuY3R1YXRvciAmJiB0b2tlbi50eXBlICE9PSBUb2tlbktleXdvcmQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICBjYXNlICd8fCc6XG4gICAgICBwcmVjID0gMTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnJiYnOlxuICAgICAgcHJlYyA9IDI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3wnOlxuICAgICAgcHJlYyA9IDM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ14nOlxuICAgICAgcHJlYyA9IDQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJyYnOlxuICAgICAgcHJlYyA9IDU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJz09JzpcbiAgICBjYXNlICchPSc6XG4gICAgY2FzZSAnPT09JzpcbiAgICBjYXNlICchPT0nOlxuICAgICAgcHJlYyA9IDY7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJzwnOlxuICAgIGNhc2UgJz4nOlxuICAgIGNhc2UgJzw9JzpcbiAgICBjYXNlICc+PSc6XG4gICAgY2FzZSAnaW5zdGFuY2VvZic6XG4gICAgY2FzZSAnaW4nOlxuICAgICAgcHJlYyA9IDc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJzw8JzpcbiAgICBjYXNlICc+Pic6XG4gICAgY2FzZSAnPj4+JzpcbiAgICAgIHByZWMgPSA4O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICcrJzpcbiAgICBjYXNlICctJzpcbiAgICAgIHByZWMgPSA5O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICcqJzpcbiAgICBjYXNlICcvJzpcbiAgICBjYXNlICclJzpcbiAgICAgIHByZWMgPSAxMTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHByZWM7XG59IC8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG4vLyAxMS42IEFkZGl0aXZlIE9wZXJhdG9yc1xuLy8gMTEuNyBCaXR3aXNlIFNoaWZ0IE9wZXJhdG9yc1xuLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuLy8gMTEuOSBFcXVhbGl0eSBPcGVyYXRvcnNcbi8vIDExLjEwIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXG5cblxuZnVuY3Rpb24gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCkge1xuICB2YXIgbWFya2VyLCBtYXJrZXJzLCBleHByLCB0b2tlbiwgcHJlYywgc3RhY2ssIHJpZ2h0LCBvcGVyYXRvciwgbGVmdCwgaTtcbiAgbWFya2VyID0gbG9va2FoZWFkO1xuICBsZWZ0ID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gIHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKHRva2VuKTtcblxuICBpZiAocHJlYyA9PT0gMCkge1xuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgdG9rZW4ucHJlYyA9IHByZWM7XG4gIGxleCgpO1xuICBtYXJrZXJzID0gW21hcmtlciwgbG9va2FoZWFkXTtcbiAgcmlnaHQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xuXG4gIHdoaWxlICgocHJlYyA9IGJpbmFyeVByZWNlZGVuY2UobG9va2FoZWFkKSkgPiAwKSB7XG4gICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyICYmIHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykge1xuICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgIG9wZXJhdG9yID0gc3RhY2sucG9wKCkudmFsdWU7XG4gICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG4gICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgZXhwciA9IGZpbmlzaEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgfSAvLyBTaGlmdC5cblxuXG4gICAgdG9rZW4gPSBsZXgoKTtcbiAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICBtYXJrZXJzLnB1c2gobG9va2FoZWFkKTtcbiAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICBzdGFjay5wdXNoKGV4cHIpO1xuICB9IC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG5cblxuICBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgZXhwciA9IHN0YWNrW2ldO1xuICBtYXJrZXJzLnBvcCgpO1xuXG4gIHdoaWxlIChpID4gMSkge1xuICAgIG1hcmtlcnMucG9wKCk7XG4gICAgZXhwciA9IGZpbmlzaEJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIGV4cHIpO1xuICAgIGkgLT0gMjtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufSAvLyAxMS4xMiBDb25kaXRpb25hbCBPcGVyYXRvclxuXG5cbmZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICB2YXIgZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlO1xuICBleHByID0gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgaWYgKG1hdGNoKCc/JykpIHtcbiAgICBsZXgoKTtcbiAgICBjb25zZXF1ZW50ID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICBleHBlY3QoJzonKTtcbiAgICBhbHRlcm5hdGUgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuICAgIGV4cHIgPSBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufSAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgY29uc3QgZXhwciA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpOyAvLyBubyBzZXF1ZW5jZSBleHByZXNzaW9uc1xuICB9XG5cbiAgcmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIHBhcnNlciAoY29kZSkge1xuICBzb3VyY2UgPSBjb2RlO1xuICBpbmRleCA9IDA7XG4gIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gIGxvb2thaGVhZCA9IG51bGw7XG4gIHBlZWsoKTtcbiAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW5FT0YpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0IHRva2VuIGFmdGVyIGV4cHJlc3Npb24uJyk7XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn1cblxudmFyIENvbnN0YW50cyA9IHtcbiAgTmFOOiAnTmFOJyxcbiAgRTogJ01hdGguRScsXG4gIExOMjogJ01hdGguTE4yJyxcbiAgTE4xMDogJ01hdGguTE4xMCcsXG4gIExPRzJFOiAnTWF0aC5MT0cyRScsXG4gIExPRzEwRTogJ01hdGguTE9HMTBFJyxcbiAgUEk6ICdNYXRoLlBJJyxcbiAgU1FSVDFfMjogJ01hdGguU1FSVDFfMicsXG4gIFNRUlQyOiAnTWF0aC5TUVJUMicsXG4gIE1JTl9WQUxVRTogJ051bWJlci5NSU5fVkFMVUUnLFxuICBNQVhfVkFMVUU6ICdOdW1iZXIuTUFYX1ZBTFVFJ1xufTtcblxuZnVuY3Rpb24gRnVuY3Rpb25zIChjb2RlZ2VuKSB7XG4gIGZ1bmN0aW9uIGZuY2FsbChuYW1lLCBhcmdzLCBjYXN0LCB0eXBlKSB7XG4gICAgbGV0IG9iaiA9IGNvZGVnZW4oYXJnc1swXSk7XG5cbiAgICBpZiAoY2FzdCkge1xuICAgICAgb2JqID0gY2FzdCArICcoJyArIG9iaiArICcpJztcbiAgICAgIGlmIChjYXN0Lmxhc3RJbmRleE9mKCduZXcgJywgMCkgPT09IDApIG9iaiA9ICcoJyArIG9iaiArICcpJztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqICsgJy4nICsgbmFtZSArICh0eXBlIDwgMCA/ICcnIDogdHlwZSA9PT0gMCA/ICcoKScgOiAnKCcgKyBhcmdzLnNsaWNlKDEpLm1hcChjb2RlZ2VuKS5qb2luKCcsJykgKyAnKScpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4obmFtZSwgY2FzdCwgdHlwZSkge1xuICAgIHJldHVybiBhcmdzID0+IGZuY2FsbChuYW1lLCBhcmdzLCBjYXN0LCB0eXBlKTtcbiAgfVxuXG4gIGNvbnN0IERBVEUgPSAnbmV3IERhdGUnLFxuICAgICAgICBTVFJJTkcgPSAnU3RyaW5nJyxcbiAgICAgICAgUkVHRVhQID0gJ1JlZ0V4cCc7XG4gIHJldHVybiB7XG4gICAgLy8gTUFUSCBmdW5jdGlvbnNcbiAgICBpc05hTjogJ051bWJlci5pc05hTicsXG4gICAgaXNGaW5pdGU6ICdOdW1iZXIuaXNGaW5pdGUnLFxuICAgIGFiczogJ01hdGguYWJzJyxcbiAgICBhY29zOiAnTWF0aC5hY29zJyxcbiAgICBhc2luOiAnTWF0aC5hc2luJyxcbiAgICBhdGFuOiAnTWF0aC5hdGFuJyxcbiAgICBhdGFuMjogJ01hdGguYXRhbjInLFxuICAgIGNlaWw6ICdNYXRoLmNlaWwnLFxuICAgIGNvczogJ01hdGguY29zJyxcbiAgICBleHA6ICdNYXRoLmV4cCcsXG4gICAgZmxvb3I6ICdNYXRoLmZsb29yJyxcbiAgICBsb2c6ICdNYXRoLmxvZycsXG4gICAgbWF4OiAnTWF0aC5tYXgnLFxuICAgIG1pbjogJ01hdGgubWluJyxcbiAgICBwb3c6ICdNYXRoLnBvdycsXG4gICAgcmFuZG9tOiAnTWF0aC5yYW5kb20nLFxuICAgIHJvdW5kOiAnTWF0aC5yb3VuZCcsXG4gICAgc2luOiAnTWF0aC5zaW4nLFxuICAgIHNxcnQ6ICdNYXRoLnNxcnQnLFxuICAgIHRhbjogJ01hdGgudGFuJyxcbiAgICBjbGFtcDogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpIGVycm9yKCdNaXNzaW5nIGFyZ3VtZW50cyB0byBjbGFtcCBmdW5jdGlvbi4nKTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpIGVycm9yKCdUb28gbWFueSBhcmd1bWVudHMgdG8gY2xhbXAgZnVuY3Rpb24uJyk7XG4gICAgICBjb25zdCBhID0gYXJncy5tYXAoY29kZWdlbik7XG4gICAgICByZXR1cm4gJ01hdGgubWF4KCcgKyBhWzFdICsgJywgTWF0aC5taW4oJyArIGFbMl0gKyAnLCcgKyBhWzBdICsgJykpJztcbiAgICB9LFxuICAgIC8vIERBVEUgZnVuY3Rpb25zXG4gICAgbm93OiAnRGF0ZS5ub3cnLFxuICAgIHV0YzogJ0RhdGUuVVRDJyxcbiAgICBkYXRldGltZTogREFURSxcbiAgICBkYXRlOiBmbignZ2V0RGF0ZScsIERBVEUsIDApLFxuICAgIGRheTogZm4oJ2dldERheScsIERBVEUsIDApLFxuICAgIHllYXI6IGZuKCdnZXRGdWxsWWVhcicsIERBVEUsIDApLFxuICAgIG1vbnRoOiBmbignZ2V0TW9udGgnLCBEQVRFLCAwKSxcbiAgICBob3VyczogZm4oJ2dldEhvdXJzJywgREFURSwgMCksXG4gICAgbWludXRlczogZm4oJ2dldE1pbnV0ZXMnLCBEQVRFLCAwKSxcbiAgICBzZWNvbmRzOiBmbignZ2V0U2Vjb25kcycsIERBVEUsIDApLFxuICAgIG1pbGxpc2Vjb25kczogZm4oJ2dldE1pbGxpc2Vjb25kcycsIERBVEUsIDApLFxuICAgIHRpbWU6IGZuKCdnZXRUaW1lJywgREFURSwgMCksXG4gICAgdGltZXpvbmVvZmZzZXQ6IGZuKCdnZXRUaW1lem9uZU9mZnNldCcsIERBVEUsIDApLFxuICAgIHV0Y2RhdGU6IGZuKCdnZXRVVENEYXRlJywgREFURSwgMCksXG4gICAgdXRjZGF5OiBmbignZ2V0VVRDRGF5JywgREFURSwgMCksXG4gICAgdXRjeWVhcjogZm4oJ2dldFVUQ0Z1bGxZZWFyJywgREFURSwgMCksXG4gICAgdXRjbW9udGg6IGZuKCdnZXRVVENNb250aCcsIERBVEUsIDApLFxuICAgIHV0Y2hvdXJzOiBmbignZ2V0VVRDSG91cnMnLCBEQVRFLCAwKSxcbiAgICB1dGNtaW51dGVzOiBmbignZ2V0VVRDTWludXRlcycsIERBVEUsIDApLFxuICAgIHV0Y3NlY29uZHM6IGZuKCdnZXRVVENTZWNvbmRzJywgREFURSwgMCksXG4gICAgdXRjbWlsbGlzZWNvbmRzOiBmbignZ2V0VVRDTWlsbGlzZWNvbmRzJywgREFURSwgMCksXG4gICAgLy8gc2VxdWVuY2UgZnVuY3Rpb25zXG4gICAgbGVuZ3RoOiBmbignbGVuZ3RoJywgbnVsbCwgLTEpLFxuICAgIC8vIFNUUklORyBmdW5jdGlvbnNcbiAgICBwYXJzZUZsb2F0OiAncGFyc2VGbG9hdCcsXG4gICAgcGFyc2VJbnQ6ICdwYXJzZUludCcsXG4gICAgdXBwZXI6IGZuKCd0b1VwcGVyQ2FzZScsIFNUUklORywgMCksXG4gICAgbG93ZXI6IGZuKCd0b0xvd2VyQ2FzZScsIFNUUklORywgMCksXG4gICAgc3Vic3RyaW5nOiBmbignc3Vic3RyaW5nJywgU1RSSU5HKSxcbiAgICBzcGxpdDogZm4oJ3NwbGl0JywgU1RSSU5HKSxcbiAgICB0cmltOiBmbigndHJpbScsIFNUUklORywgMCksXG4gICAgLy8gUkVHRVhQIGZ1bmN0aW9uc1xuICAgIHJlZ2V4cDogUkVHRVhQLFxuICAgIHRlc3Q6IGZuKCd0ZXN0JywgUkVHRVhQKSxcbiAgICAvLyBDb250cm9sIEZsb3cgZnVuY3Rpb25zXG4gICAgaWY6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSBlcnJvcignTWlzc2luZyBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uJyk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSBlcnJvcignVG9vIG1hbnkgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLicpO1xuICAgICAgY29uc3QgYSA9IGFyZ3MubWFwKGNvZGVnZW4pO1xuICAgICAgcmV0dXJuICcoJyArIGFbMF0gKyAnPycgKyBhWzFdICsgJzonICsgYVsyXSArICcpJztcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmlwUXVvdGVzKHMpIHtcbiAgY29uc3QgbiA9IHMgJiYgcy5sZW5ndGggLSAxO1xuICByZXR1cm4gbiAmJiAoc1swXSA9PT0gJ1wiJyAmJiBzW25dID09PSAnXCInIHx8IHNbMF0gPT09ICdcXCcnICYmIHNbbl0gPT09ICdcXCcnKSA/IHMuc2xpY2UoMSwgLTEpIDogcztcbn1cblxuZnVuY3Rpb24gY29kZWdlbiAob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgY29uc3QgYWxsb3dlZCA9IG9wdC5hbGxvd2VkID8gdG9TZXQob3B0LmFsbG93ZWQpIDoge30sXG4gICAgICAgIGZvcmJpZGRlbiA9IG9wdC5mb3JiaWRkZW4gPyB0b1NldChvcHQuZm9yYmlkZGVuKSA6IHt9LFxuICAgICAgICBjb25zdGFudHMgPSBvcHQuY29uc3RhbnRzIHx8IENvbnN0YW50cyxcbiAgICAgICAgZnVuY3Rpb25zID0gKG9wdC5mdW5jdGlvbnMgfHwgRnVuY3Rpb25zKSh2aXNpdCksXG4gICAgICAgIGdsb2JhbHZhciA9IG9wdC5nbG9iYWx2YXIsXG4gICAgICAgIGZpZWxkdmFyID0gb3B0LmZpZWxkdmFyLFxuICAgICAgICBvdXRwdXRHbG9iYWwgPSBpc0Z1bmN0aW9uKGdsb2JhbHZhcikgPyBnbG9iYWx2YXIgOiBpZCA9PiBgJHtnbG9iYWx2YXJ9W1wiJHtpZH1cIl1gO1xuICBsZXQgZ2xvYmFscyA9IHt9LFxuICAgICAgZmllbGRzID0ge30sXG4gICAgICBtZW1iZXJEZXB0aCA9IDA7XG5cbiAgZnVuY3Rpb24gdmlzaXQoYXN0KSB7XG4gICAgaWYgKGlzU3RyaW5nKGFzdCkpIHJldHVybiBhc3Q7XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gR2VuZXJhdG9yc1thc3QudHlwZV07XG4gICAgaWYgKGdlbmVyYXRvciA9PSBudWxsKSBlcnJvcignVW5zdXBwb3J0ZWQgdHlwZTogJyArIGFzdC50eXBlKTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yKGFzdCk7XG4gIH1cblxuICBjb25zdCBHZW5lcmF0b3JzID0ge1xuICAgIExpdGVyYWw6IG4gPT4gbi5yYXcsXG4gICAgSWRlbnRpZmllcjogbiA9PiB7XG4gICAgICBjb25zdCBpZCA9IG4ubmFtZTtcblxuICAgICAgaWYgKG1lbWJlckRlcHRoID4gMCkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGZvcmJpZGRlbiwgaWQpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcignSWxsZWdhbCBpZGVudGlmaWVyOiAnICsgaWQpO1xuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShjb25zdGFudHMsIGlkKSkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnRzW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoYWxsb3dlZCwgaWQpKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbHNbaWRdID0gMTtcbiAgICAgICAgcmV0dXJuIG91dHB1dEdsb2JhbChpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBNZW1iZXJFeHByZXNzaW9uOiBuID0+IHtcbiAgICAgIGNvbnN0IGQgPSAhbi5jb21wdXRlZCxcbiAgICAgICAgICAgIG8gPSB2aXNpdChuLm9iamVjdCk7XG4gICAgICBpZiAoZCkgbWVtYmVyRGVwdGggKz0gMTtcbiAgICAgIGNvbnN0IHAgPSB2aXNpdChuLnByb3BlcnR5KTtcblxuICAgICAgaWYgKG8gPT09IGZpZWxkdmFyKSB7XG4gICAgICAgIC8vIHN0cmlwIHF1b3RlcyB0byBzYW5pdGl6ZSBmaWVsZCBuYW1lICgjMTY1MylcbiAgICAgICAgZmllbGRzW3N0cmlwUXVvdGVzKHApXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgcmV0dXJuIG8gKyAoZCA/ICcuJyArIHAgOiAnWycgKyBwICsgJ10nKTtcbiAgICB9LFxuICAgIENhbGxFeHByZXNzaW9uOiBuID0+IHtcbiAgICAgIGlmIChuLmNhbGxlZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgZXJyb3IoJ0lsbGVnYWwgY2FsbGVlIHR5cGU6ICcgKyBuLmNhbGxlZS50eXBlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FsbGVlID0gbi5jYWxsZWUubmFtZSxcbiAgICAgICAgICAgIGFyZ3MgPSBuLmFyZ3VtZW50cyxcbiAgICAgICAgICAgIGZuID0gaGFzT3duUHJvcGVydHkoZnVuY3Rpb25zLCBjYWxsZWUpICYmIGZ1bmN0aW9uc1tjYWxsZWVdO1xuICAgICAgaWYgKCFmbikgZXJyb3IoJ1VucmVjb2duaXplZCBmdW5jdGlvbjogJyArIGNhbGxlZSk7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihmbikgPyBmbihhcmdzKSA6IGZuICsgJygnICsgYXJncy5tYXAodmlzaXQpLmpvaW4oJywnKSArICcpJztcbiAgICB9LFxuICAgIEFycmF5RXhwcmVzc2lvbjogbiA9PiAnWycgKyBuLmVsZW1lbnRzLm1hcCh2aXNpdCkuam9pbignLCcpICsgJ10nLFxuICAgIEJpbmFyeUV4cHJlc3Npb246IG4gPT4gJygnICsgdmlzaXQobi5sZWZ0KSArICcgJyArIG4ub3BlcmF0b3IgKyAnICcgKyB2aXNpdChuLnJpZ2h0KSArICcpJyxcbiAgICBVbmFyeUV4cHJlc3Npb246IG4gPT4gJygnICsgbi5vcGVyYXRvciArIHZpc2l0KG4uYXJndW1lbnQpICsgJyknLFxuICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogbiA9PiAnKCcgKyB2aXNpdChuLnRlc3QpICsgJz8nICsgdmlzaXQobi5jb25zZXF1ZW50KSArICc6JyArIHZpc2l0KG4uYWx0ZXJuYXRlKSArICcpJyxcbiAgICBMb2dpY2FsRXhwcmVzc2lvbjogbiA9PiAnKCcgKyB2aXNpdChuLmxlZnQpICsgbi5vcGVyYXRvciArIHZpc2l0KG4ucmlnaHQpICsgJyknLFxuICAgIE9iamVjdEV4cHJlc3Npb246IG4gPT4gJ3snICsgbi5wcm9wZXJ0aWVzLm1hcCh2aXNpdCkuam9pbignLCcpICsgJ30nLFxuICAgIFByb3BlcnR5OiBuID0+IHtcbiAgICAgIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICBjb25zdCBrID0gdmlzaXQobi5rZXkpO1xuICAgICAgbWVtYmVyRGVwdGggLT0gMTtcbiAgICAgIHJldHVybiBrICsgJzonICsgdmlzaXQobi52YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvZGVnZW4oYXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgY29kZTogdmlzaXQoYXN0KSxcbiAgICAgIGdsb2JhbHM6IE9iamVjdC5rZXlzKGdsb2JhbHMpLFxuICAgICAgZmllbGRzOiBPYmplY3Qua2V5cyhmaWVsZHMpXG4gICAgfTtcbiAgICBnbG9iYWxzID0ge307XG4gICAgZmllbGRzID0ge307XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNvZGVnZW4uZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICBjb2RlZ2VuLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiAgcmV0dXJuIGNvZGVnZW47XG59XG5cbmV4cG9ydCB7IEFTVE5vZGUsIEFycmF5RXhwcmVzc2lvbiwgQmluYXJ5RXhwcmVzc2lvbiwgQ2FsbEV4cHJlc3Npb24sIENvbmRpdGlvbmFsRXhwcmVzc2lvbiwgSWRlbnRpZmllciwgTGl0ZXJhbCwgTG9naWNhbEV4cHJlc3Npb24sIE1lbWJlckV4cHJlc3Npb24sIE9iamVjdEV4cHJlc3Npb24sIFByb3BlcnR5LCBSYXdDb2RlLCBVbmFyeUV4cHJlc3Npb24sIGNvZGVnZW4gYXMgY29kZWdlbkV4cHJlc3Npb24sIENvbnN0YW50cyBhcyBjb25zdGFudHMsIEZ1bmN0aW9ucyBhcyBmdW5jdGlvbnMsIHBhcnNlciBhcyBwYXJzZUV4cHJlc3Npb24gfTtcbiIsImltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGFycmF5LCBpc0Z1bmN0aW9uLCBhY2Nlc3NvckZpZWxkcywgaGFzT3duUHJvcGVydHksIGVycm9yIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGZvcmNlU2ltdWxhdGlvbiwgZm9yY2VDZW50ZXIsIGZvcmNlQ29sbGlkZSwgZm9yY2VNYW55Qm9keSwgZm9yY2VMaW5rLCBmb3JjZVgsIGZvcmNlWSB9IGZyb20gJ2QzLWZvcmNlJztcblxuY29uc3QgRm9yY2VNYXAgPSB7XG4gIGNlbnRlcjogZm9yY2VDZW50ZXIsXG4gIGNvbGxpZGU6IGZvcmNlQ29sbGlkZSxcbiAgbmJvZHk6IGZvcmNlTWFueUJvZHksXG4gIGxpbms6IGZvcmNlTGluayxcbiAgeDogZm9yY2VYLFxuICB5OiBmb3JjZVlcbn07XG5jb25zdCBGb3JjZXMgPSAnZm9yY2VzJyxcbiAgICAgIEZvcmNlUGFyYW1zID0gWydhbHBoYScsICdhbHBoYU1pbicsICdhbHBoYVRhcmdldCcsICd2ZWxvY2l0eURlY2F5JywgJ2ZvcmNlcyddLFxuICAgICAgRm9yY2VDb25maWcgPSBbJ3N0YXRpYycsICdpdGVyYXRpb25zJ10sXG4gICAgICBGb3JjZU91dHB1dCA9IFsneCcsICd5JywgJ3Z4JywgJ3Z5J107XG4vKipcbiAqIEZvcmNlIHNpbXVsYXRpb24gbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IHBhcmFtcy5mb3JjZXMgLSBUaGUgZm9yY2VzIHRvIGFwcGx5LlxuICovXG5cbmZ1bmN0aW9uIEZvcmNlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuRm9yY2UuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnRm9yY2UnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzdGF0aWMnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ3Jlc3RhcnQnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2l0ZXJhdGlvbnMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAzMDBcbiAgfSwge1xuICAgICduYW1lJzogJ2FscGhhJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYWxwaGFNaW4nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwLjAwMVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYWxwaGFUYXJnZXQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd2ZWxvY2l0eURlY2F5JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMC40XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb3JjZXMnLFxuICAgICd0eXBlJzogJ3BhcmFtJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdwYXJhbXMnOiBbe1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ2NlbnRlcidcbiAgICAgIH0sXG4gICAgICAncGFyYW1zJzogW3tcbiAgICAgICAgJ25hbWUnOiAneCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMFxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICd5JyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAwXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgICdrZXknOiB7XG4gICAgICAgICdmb3JjZSc6ICdjb2xsaWRlJ1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICdyYWRpdXMnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZXhwcic6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAnc3RyZW5ndGgnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDAuN1xuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdpdGVyYXRpb25zJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAxXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgICdrZXknOiB7XG4gICAgICAgICdmb3JjZSc6ICduYm9keSdcbiAgICAgIH0sXG4gICAgICAncGFyYW1zJzogW3tcbiAgICAgICAgJ25hbWUnOiAnc3RyZW5ndGgnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IC0zMFxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICd0aGV0YScsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMC45XG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ2Rpc3RhbmNlTWluJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAxXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ2Rpc3RhbmNlTWF4JyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAna2V5Jzoge1xuICAgICAgICAnZm9yY2UnOiAnbGluaydcbiAgICAgIH0sXG4gICAgICAncGFyYW1zJzogW3tcbiAgICAgICAgJ25hbWUnOiAnbGlua3MnLFxuICAgICAgICAndHlwZSc6ICdkYXRhJ1xuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdpZCcsXG4gICAgICAgICd0eXBlJzogJ2ZpZWxkJ1xuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdkaXN0YW5jZScsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMzAsXG4gICAgICAgICdleHByJzogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdzdHJlbmd0aCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdleHByJzogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdpdGVyYXRpb25zJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAxXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgICdrZXknOiB7XG4gICAgICAgICdmb3JjZSc6ICd4J1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICdzdHJlbmd0aCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMC4xXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ3gnLFxuICAgICAgICAndHlwZSc6ICdmaWVsZCdcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ3knXG4gICAgICB9LFxuICAgICAgJ3BhcmFtcyc6IFt7XG4gICAgICAgICduYW1lJzogJ3N0cmVuZ3RoJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAwLjFcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAneScsXG4gICAgICAgICd0eXBlJzogJ2ZpZWxkJ1xuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbW9kaWZ5JzogZmFsc2UsXG4gICAgJ2RlZmF1bHQnOiBGb3JjZU91dHB1dFxuICB9XVxufTtcbmluaGVyaXRzKEZvcmNlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIHNpbSA9IHRoaXMudmFsdWUsXG4gICAgICAgIGNoYW5nZSA9IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSksXG4gICAgICAgIHBhcmFtcyA9IF8ubW9kaWZpZWQoRm9yY2VQYXJhbXMpLFxuICAgICAgICBpdGVycyA9IF8uaXRlcmF0aW9ucyB8fCAzMDA7IC8vIGNvbmZpZ3VyZSBzaW11bGF0aW9uXG5cblxuICAgIGlmICghc2ltKSB7XG4gICAgICB0aGlzLnZhbHVlID0gc2ltID0gc2ltdWxhdGlvbihwdWxzZS5zb3VyY2UsIF8pO1xuICAgICAgc2ltLm9uKCd0aWNrJywgcmVydW4ocHVsc2UuZGF0YWZsb3csIHRoaXMpKTtcblxuICAgICAgaWYgKCFfLnN0YXRpYykge1xuICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICBzaW0udGljaygpOyAvLyBlbnN1cmUgd2UgcnVuIG9uIGluaXRcbiAgICAgIH1cblxuICAgICAgcHVsc2UubW9kaWZpZXMoJ2luZGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgcHVsc2UubW9kaWZpZXMoJ2luZGV4Jyk7XG4gICAgICAgIHNpbS5ub2RlcyhwdWxzZS5zb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuTU9EKSkge1xuICAgICAgICBzZXR1cChzaW0sIF8sIDAsIHB1bHNlKTtcbiAgICAgIH1cbiAgICB9IC8vIHJ1biBzaW11bGF0aW9uXG5cblxuICAgIGlmIChwYXJhbXMgfHwgY2hhbmdlIHx8IF8ubW9kaWZpZWQoRm9yY2VDb25maWcpIHx8IHB1bHNlLmNoYW5nZWQoKSAmJiBfLnJlc3RhcnQpIHtcbiAgICAgIHNpbS5hbHBoYShNYXRoLm1heChzaW0uYWxwaGEoKSwgXy5hbHBoYSB8fCAxKSkuYWxwaGFEZWNheSgxIC0gTWF0aC5wb3coc2ltLmFscGhhTWluKCksIDEgLyBpdGVycykpO1xuXG4gICAgICBpZiAoXy5zdGF0aWMpIHtcbiAgICAgICAgZm9yIChzaW0uc3RvcCgpOyAtLWl0ZXJzID49IDA7KSBzaW0udGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNpbS5zdG9wcGVkKCkpIHNpbS5yZXN0YXJ0KCk7XG4gICAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uOyAvLyBkZWZlciB0byBzaW0gdGlja3NcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2goXywgcHVsc2UpO1xuICB9LFxuXG4gIGZpbmlzaChfLCBwdWxzZSkge1xuICAgIGNvbnN0IGRhdGFmbG93ID0gcHVsc2UuZGF0YWZsb3c7IC8vIGluc3BlY3QgZGVwZW5kZW5jaWVzLCB0b3VjaCBsaW5rIHNvdXJjZSBkYXRhXG5cbiAgICBmb3IgKGxldCBhcmdzID0gdGhpcy5fYXJnb3BzLCBqID0gMCwgbSA9IGFyZ3MubGVuZ3RoLCBhcmc7IGogPCBtOyArK2opIHtcbiAgICAgIGFyZyA9IGFyZ3Nbal07XG5cbiAgICAgIGlmIChhcmcubmFtZSAhPT0gRm9yY2VzIHx8IGFyZy5vcC5fYXJndmFsLmZvcmNlICE9PSAnbGluaycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG9wcyA9IGFyZy5vcC5fYXJnb3BzLCBpID0gMCwgbiA9IG9wcy5sZW5ndGgsIG9wOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChvcHNbaV0ubmFtZSA9PT0gJ2xpbmtzJyAmJiAob3AgPSBvcHNbaV0ub3Auc291cmNlKSkge1xuICAgICAgICAgIGRhdGFmbG93LnB1bHNlKG9wLCBkYXRhZmxvdy5jaGFuZ2VzZXQoKS5yZWZsb3coKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHJlZmxvdyBhbGwgbm9kZXNcblxuXG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKEZvcmNlT3V0cHV0KTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gcmVydW4oZGYsIG9wKSB7XG4gIHJldHVybiAoKSA9PiBkZi50b3VjaChvcCkucnVuKCk7XG59XG5cbmZ1bmN0aW9uIHNpbXVsYXRpb24obm9kZXMsIF8pIHtcbiAgY29uc3Qgc2ltID0gZm9yY2VTaW11bGF0aW9uKG5vZGVzKSxcbiAgICAgICAgc3RvcCA9IHNpbS5zdG9wLFxuICAgICAgICByZXN0YXJ0ID0gc2ltLnJlc3RhcnQ7XG4gIGxldCBzdG9wcGVkID0gZmFsc2U7XG5cbiAgc2ltLnN0b3BwZWQgPSAoKSA9PiBzdG9wcGVkO1xuXG4gIHNpbS5yZXN0YXJ0ID0gKCkgPT4gKHN0b3BwZWQgPSBmYWxzZSwgcmVzdGFydCgpKTtcblxuICBzaW0uc3RvcCA9ICgpID0+IChzdG9wcGVkID0gdHJ1ZSwgc3RvcCgpKTtcblxuICByZXR1cm4gc2V0dXAoc2ltLCBfLCB0cnVlKS5vbignZW5kJywgKCkgPT4gc3RvcHBlZCA9IHRydWUpO1xufVxuXG5mdW5jdGlvbiBzZXR1cChzaW0sIF8sIGluaXQsIHB1bHNlKSB7XG4gIHZhciBmID0gYXJyYXkoXy5mb3JjZXMpLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBwLFxuICAgICAgbmFtZTtcblxuICBmb3IgKGkgPSAwLCBuID0gRm9yY2VQYXJhbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgcCA9IEZvcmNlUGFyYW1zW2ldO1xuICAgIGlmIChwICE9PSBGb3JjZXMgJiYgXy5tb2RpZmllZChwKSkgc2ltW3BdKF9bcF0pO1xuICB9XG5cbiAgZm9yIChpID0gMCwgbiA9IGYubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgbmFtZSA9IEZvcmNlcyArIGk7XG4gICAgcCA9IGluaXQgfHwgXy5tb2RpZmllZChGb3JjZXMsIGkpID8gZ2V0Rm9yY2UoZltpXSkgOiBwdWxzZSAmJiBtb2RpZmllZChmW2ldLCBwdWxzZSkgPyBzaW0uZm9yY2UobmFtZSkgOiBudWxsO1xuICAgIGlmIChwKSBzaW0uZm9yY2UobmFtZSwgcCk7XG4gIH1cblxuICBmb3IgKG4gPSBzaW0ubnVtRm9yY2VzIHx8IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzaW0uZm9yY2UoRm9yY2VzICsgaSwgbnVsbCk7IC8vIHJlbW92ZVxuICB9XG5cbiAgc2ltLm51bUZvcmNlcyA9IGYubGVuZ3RoO1xuICByZXR1cm4gc2ltO1xufVxuXG5mdW5jdGlvbiBtb2RpZmllZChmLCBwdWxzZSkge1xuICB2YXIgaywgdjtcblxuICBmb3IgKGsgaW4gZikge1xuICAgIGlmIChpc0Z1bmN0aW9uKHYgPSBmW2tdKSAmJiBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyh2KSkpIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGdldEZvcmNlKF8pIHtcbiAgdmFyIGYsIHA7XG5cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShGb3JjZU1hcCwgXy5mb3JjZSkpIHtcbiAgICBlcnJvcignVW5yZWNvZ25pemVkIGZvcmNlOiAnICsgXy5mb3JjZSk7XG4gIH1cblxuICBmID0gRm9yY2VNYXBbXy5mb3JjZV0oKTtcblxuICBmb3IgKHAgaW4gXykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGZbcF0pKSBzZXRGb3JjZVBhcmFtKGZbcF0sIF9bcF0sIF8pO1xuICB9XG5cbiAgcmV0dXJuIGY7XG59XG5cbmZ1bmN0aW9uIHNldEZvcmNlUGFyYW0oZiwgdiwgXykge1xuICBmKGlzRnVuY3Rpb24odikgPyBkID0+IHYoZCwgXykgOiB2KTtcbn1cblxuZXhwb3J0IHsgRm9yY2UgYXMgZm9yY2UgfTtcbiIsInZhciBub29wID0ge3ZhbHVlOiAoKSA9PiB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSB8fCAvW1xccy5dLy50ZXN0KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BhdGNoO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgbm9kZXMsIHN0cmVuZ3RoID0gMTtcblxuICBpZiAoeCA9PSBudWxsKSB4ID0gMDtcbiAgaWYgKHkgPT0gbnVsbCkgeSA9IDA7XG5cbiAgZnVuY3Rpb24gZm9yY2UoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHN4ID0gMCxcbiAgICAgICAgc3kgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBzeCArPSBub2RlLngsIHN5ICs9IG5vZGUueTtcbiAgICB9XG5cbiAgICBmb3IgKHN4ID0gKHN4IC8gbiAtIHgpICogc3RyZW5ndGgsIHN5ID0gKHN5IC8gbiAtIHkpICogc3RyZW5ndGgsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueCAtPSBzeCwgbm9kZS55IC09IHN5O1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICB9O1xuXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9ICtfLCBmb3JjZSkgOiB4O1xuICB9O1xuXG4gIGZvcmNlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9ICtfLCBmb3JjZSkgOiB5O1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gK18sIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCB7cXVhZHRyZWV9IGZyb20gXCJkMy1xdWFkdHJlZVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgamlnZ2xlIGZyb20gXCIuL2ppZ2dsZS5qc1wiO1xuXG5mdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueCArIGQudng7XG59XG5cbmZ1bmN0aW9uIHkoZCkge1xuICByZXR1cm4gZC55ICsgZC52eTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFkaXVzKSB7XG4gIHZhciBub2RlcyxcbiAgICAgIHJhZGlpLFxuICAgICAgcmFuZG9tLFxuICAgICAgc3RyZW5ndGggPSAxLFxuICAgICAgaXRlcmF0aW9ucyA9IDE7XG5cbiAgaWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgcmFkaXVzID0gY29uc3RhbnQocmFkaXVzID09IG51bGwgPyAxIDogK3JhZGl1cyk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHhpLFxuICAgICAgICB5aSxcbiAgICAgICAgcmksXG4gICAgICAgIHJpMjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICB0cmVlID0gcXVhZHRyZWUobm9kZXMsIHgsIHkpLnZpc2l0QWZ0ZXIocHJlcGFyZSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgcmkgPSByYWRpaVtub2RlLmluZGV4XSwgcmkyID0gcmkgKiByaTtcbiAgICAgICAgeGkgPSBub2RlLnggKyBub2RlLnZ4O1xuICAgICAgICB5aSA9IG5vZGUueSArIG5vZGUudnk7XG4gICAgICAgIHRyZWUudmlzaXQoYXBwbHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5KHF1YWQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICB2YXIgZGF0YSA9IHF1YWQuZGF0YSwgcmogPSBxdWFkLnIsIHIgPSByaSArIHJqO1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaW5kZXggPiBub2RlLmluZGV4KSB7XG4gICAgICAgICAgdmFyIHggPSB4aSAtIGRhdGEueCAtIGRhdGEudngsXG4gICAgICAgICAgICAgIHkgPSB5aSAtIGRhdGEueSAtIGRhdGEudnksXG4gICAgICAgICAgICAgIGwgPSB4ICogeCArIHkgKiB5O1xuICAgICAgICAgIGlmIChsIDwgciAqIHIpIHtcbiAgICAgICAgICAgIGlmICh4ID09PSAwKSB4ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geCAqIHg7XG4gICAgICAgICAgICBpZiAoeSA9PT0gMCkgeSA9IGppZ2dsZShyYW5kb20pLCBsICs9IHkgKiB5O1xuICAgICAgICAgICAgbCA9IChyIC0gKGwgPSBNYXRoLnNxcnQobCkpKSAvIGwgKiBzdHJlbmd0aDtcbiAgICAgICAgICAgIG5vZGUudnggKz0gKHggKj0gbCkgKiAociA9IChyaiAqPSByaikgLyAocmkyICsgcmopKTtcbiAgICAgICAgICAgIG5vZGUudnkgKz0gKHkgKj0gbCkgKiByO1xuICAgICAgICAgICAgZGF0YS52eCAtPSB4ICogKHIgPSAxIC0gcik7XG4gICAgICAgICAgICBkYXRhLnZ5IC09IHkgKiByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4geDAgPiB4aSArIHIgfHwgeDEgPCB4aSAtIHIgfHwgeTAgPiB5aSArIHIgfHwgeTEgPCB5aSAtIHI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZShxdWFkKSB7XG4gICAgaWYgKHF1YWQuZGF0YSkgcmV0dXJuIHF1YWQuciA9IHJhZGlpW3F1YWQuZGF0YS5pbmRleF07XG4gICAgZm9yICh2YXIgaSA9IHF1YWQuciA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGlmIChxdWFkW2ldICYmIHF1YWRbaV0uciA+IHF1YWQucikge1xuICAgICAgICBxdWFkLnIgPSBxdWFkW2ldLnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG4gICAgcmFkaWkgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgbm9kZSA9IG5vZGVzW2ldLCByYWRpaVtub2RlLmluZGV4XSA9ICtyYWRpdXMobm9kZSwgaSwgbm9kZXMpO1xuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF9ub2RlcywgX3JhbmRvbSkge1xuICAgIG5vZGVzID0gX25vZGVzO1xuICAgIHJhbmRvbSA9IF9yYW5kb207XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLml0ZXJhdGlvbnMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaXRlcmF0aW9ucyA9ICtfLCBmb3JjZSkgOiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gK18sIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYW5kb20pIHtcbiAgcmV0dXJuIChyYW5kb20oKSAtIDAuNSkgKiAxZS02O1xufVxuIiwiLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2NvbmdydWVudGlhbF9nZW5lcmF0b3IjUGFyYW1ldGVyc19pbl9jb21tb25fdXNlXG5jb25zdCBhID0gMTY2NDUyNTtcbmNvbnN0IGMgPSAxMDEzOTA0MjIzO1xuY29uc3QgbSA9IDQyOTQ5NjcyOTY7IC8vIDJeMzJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIGxldCBzID0gMTtcbiAgcmV0dXJuICgpID0+IChzID0gKGEgKiBzICsgYykgJSBtKSAvIG07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBqaWdnbGUgZnJvbSBcIi4vamlnZ2xlLmpzXCI7XG5cbmZ1bmN0aW9uIGluZGV4KGQpIHtcbiAgcmV0dXJuIGQuaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGZpbmQobm9kZUJ5SWQsIG5vZGVJZCkge1xuICB2YXIgbm9kZSA9IG5vZGVCeUlkLmdldChub2RlSWQpO1xuICBpZiAoIW5vZGUpIHRocm93IG5ldyBFcnJvcihcIm5vZGUgbm90IGZvdW5kOiBcIiArIG5vZGVJZCk7XG4gIHJldHVybiBub2RlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihsaW5rcykge1xuICB2YXIgaWQgPSBpbmRleCxcbiAgICAgIHN0cmVuZ3RoID0gZGVmYXVsdFN0cmVuZ3RoLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgZGlzdGFuY2UgPSBjb25zdGFudCgzMCksXG4gICAgICBkaXN0YW5jZXMsXG4gICAgICBub2RlcyxcbiAgICAgIGNvdW50LFxuICAgICAgYmlhcyxcbiAgICAgIHJhbmRvbSxcbiAgICAgIGl0ZXJhdGlvbnMgPSAxO1xuXG4gIGlmIChsaW5rcyA9PSBudWxsKSBsaW5rcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRlZmF1bHRTdHJlbmd0aChsaW5rKSB7XG4gICAgcmV0dXJuIDEgLyBNYXRoLm1pbihjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0sIGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGsgPSAwLCBuID0gbGlua3MubGVuZ3RoOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGluaywgc291cmNlLCB0YXJnZXQsIHgsIHksIGwsIGI7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbGluayA9IGxpbmtzW2ldLCBzb3VyY2UgPSBsaW5rLnNvdXJjZSwgdGFyZ2V0ID0gbGluay50YXJnZXQ7XG4gICAgICAgIHggPSB0YXJnZXQueCArIHRhcmdldC52eCAtIHNvdXJjZS54IC0gc291cmNlLnZ4IHx8IGppZ2dsZShyYW5kb20pO1xuICAgICAgICB5ID0gdGFyZ2V0LnkgKyB0YXJnZXQudnkgLSBzb3VyY2UueSAtIHNvdXJjZS52eSB8fCBqaWdnbGUocmFuZG9tKTtcbiAgICAgICAgbCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgbCA9IChsIC0gZGlzdGFuY2VzW2ldKSAvIGwgKiBhbHBoYSAqIHN0cmVuZ3Roc1tpXTtcbiAgICAgICAgeCAqPSBsLCB5ICo9IGw7XG4gICAgICAgIHRhcmdldC52eCAtPSB4ICogKGIgPSBiaWFzW2ldKTtcbiAgICAgICAgdGFyZ2V0LnZ5IC09IHkgKiBiO1xuICAgICAgICBzb3VyY2UudnggKz0geCAqIChiID0gMSAtIGIpO1xuICAgICAgICBzb3VyY2UudnkgKz0geSAqIGI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgbSA9IGxpbmtzLmxlbmd0aCxcbiAgICAgICAgbm9kZUJ5SWQgPSBuZXcgTWFwKG5vZGVzLm1hcCgoZCwgaSkgPT4gW2lkKGQsIGksIG5vZGVzKSwgZF0pKSxcbiAgICAgICAgbGluaztcblxuICAgIGZvciAoaSA9IDAsIGNvdW50ID0gbmV3IEFycmF5KG4pOyBpIDwgbTsgKytpKSB7XG4gICAgICBsaW5rID0gbGlua3NbaV0sIGxpbmsuaW5kZXggPSBpO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rLnNvdXJjZSAhPT0gXCJvYmplY3RcIikgbGluay5zb3VyY2UgPSBmaW5kKG5vZGVCeUlkLCBsaW5rLnNvdXJjZSk7XG4gICAgICBpZiAodHlwZW9mIGxpbmsudGFyZ2V0ICE9PSBcIm9iamVjdFwiKSBsaW5rLnRhcmdldCA9IGZpbmQobm9kZUJ5SWQsIGxpbmsudGFyZ2V0KTtcbiAgICAgIGNvdW50W2xpbmsuc291cmNlLmluZGV4XSA9IChjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gfHwgMCkgKyAxO1xuICAgICAgY291bnRbbGluay50YXJnZXQuaW5kZXhdID0gKGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgYmlhcyA9IG5ldyBBcnJheShtKTsgaSA8IG07ICsraSkge1xuICAgICAgbGluayA9IGxpbmtzW2ldLCBiaWFzW2ldID0gY291bnRbbGluay5zb3VyY2UuaW5kZXhdIC8gKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSArIGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSk7XG4gICAgfVxuXG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG0pLCBpbml0aWFsaXplU3RyZW5ndGgoKTtcbiAgICBkaXN0YW5jZXMgPSBuZXcgQXJyYXkobSksIGluaXRpYWxpemVEaXN0YW5jZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZVN0cmVuZ3RoKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbGlua3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSArc3RyZW5ndGgobGlua3NbaV0sIGksIGxpbmtzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplRGlzdGFuY2UoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGRpc3RhbmNlc1tpXSA9ICtkaXN0YW5jZShsaW5rc1tpXSwgaSwgbGlua3MpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfbm9kZXMsIF9yYW5kb20pIHtcbiAgICBub2RlcyA9IF9ub2RlcztcbiAgICByYW5kb20gPSBfcmFuZG9tO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5saW5rcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsaW5rcyA9IF8sIGluaXRpYWxpemUoKSwgZm9yY2UpIDogbGlua3M7XG4gIH07XG5cbiAgZm9yY2UuaWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaWQgPSBfLCBmb3JjZSkgOiBpZDtcbiAgfTtcblxuICBmb3JjZS5pdGVyYXRpb25zID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgZm9yY2UpIDogaXRlcmF0aW9ucztcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplU3RyZW5ndGgoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2UgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZURpc3RhbmNlKCksIGZvcmNlKSA6IGRpc3RhbmNlO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCB7cXVhZHRyZWV9IGZyb20gXCJkMy1xdWFkdHJlZVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgamlnZ2xlIGZyb20gXCIuL2ppZ2dsZS5qc1wiO1xuaW1wb3J0IHt4LCB5fSBmcm9tIFwiLi9zaW11bGF0aW9uLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZXMsXG4gICAgICBub2RlLFxuICAgICAgcmFuZG9tLFxuICAgICAgYWxwaGEsXG4gICAgICBzdHJlbmd0aCA9IGNvbnN0YW50KC0zMCksXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICBkaXN0YW5jZU1pbjIgPSAxLFxuICAgICAgZGlzdGFuY2VNYXgyID0gSW5maW5pdHksXG4gICAgICB0aGV0YTIgPSAwLjgxO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKF8pIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgdHJlZSA9IHF1YWR0cmVlKG5vZGVzLCB4LCB5KS52aXNpdEFmdGVyKGFjY3VtdWxhdGUpO1xuICAgIGZvciAoYWxwaGEgPSBfLCBpID0gMDsgaSA8IG47ICsraSkgbm9kZSA9IG5vZGVzW2ldLCB0cmVlLnZpc2l0KGFwcGx5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHN0cmVuZ3Roc1tub2RlLmluZGV4XSA9ICtzdHJlbmd0aChub2RlLCBpLCBub2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBhY2N1bXVsYXRlKHF1YWQpIHtcbiAgICB2YXIgc3RyZW5ndGggPSAwLCBxLCBjLCB3ZWlnaHQgPSAwLCB4LCB5LCBpO1xuXG4gICAgLy8gRm9yIGludGVybmFsIG5vZGVzLCBhY2N1bXVsYXRlIGZvcmNlcyBmcm9tIGNoaWxkIHF1YWRyYW50cy5cbiAgICBpZiAocXVhZC5sZW5ndGgpIHtcbiAgICAgIGZvciAoeCA9IHkgPSBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICBpZiAoKHEgPSBxdWFkW2ldKSAmJiAoYyA9IE1hdGguYWJzKHEudmFsdWUpKSkge1xuICAgICAgICAgIHN0cmVuZ3RoICs9IHEudmFsdWUsIHdlaWdodCArPSBjLCB4ICs9IGMgKiBxLngsIHkgKz0gYyAqIHEueTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVhZC54ID0geCAvIHdlaWdodDtcbiAgICAgIHF1YWQueSA9IHkgLyB3ZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gRm9yIGxlYWYgbm9kZXMsIGFjY3VtdWxhdGUgZm9yY2VzIGZyb20gY29pbmNpZGVudCBxdWFkcmFudHMuXG4gICAgZWxzZSB7XG4gICAgICBxID0gcXVhZDtcbiAgICAgIHEueCA9IHEuZGF0YS54O1xuICAgICAgcS55ID0gcS5kYXRhLnk7XG4gICAgICBkbyBzdHJlbmd0aCArPSBzdHJlbmd0aHNbcS5kYXRhLmluZGV4XTtcbiAgICAgIHdoaWxlIChxID0gcS5uZXh0KTtcbiAgICB9XG5cbiAgICBxdWFkLnZhbHVlID0gc3RyZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseShxdWFkLCB4MSwgXywgeDIpIHtcbiAgICBpZiAoIXF1YWQudmFsdWUpIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIHggPSBxdWFkLnggLSBub2RlLngsXG4gICAgICAgIHkgPSBxdWFkLnkgLSBub2RlLnksXG4gICAgICAgIHcgPSB4MiAtIHgxLFxuICAgICAgICBsID0geCAqIHggKyB5ICogeTtcblxuICAgIC8vIEFwcGx5IHRoZSBCYXJuZXMtSHV0IGFwcHJveGltYXRpb24gaWYgcG9zc2libGUuXG4gICAgLy8gTGltaXQgZm9yY2VzIGZvciB2ZXJ5IGNsb3NlIG5vZGVzOyByYW5kb21pemUgZGlyZWN0aW9uIGlmIGNvaW5jaWRlbnQuXG4gICAgaWYgKHcgKiB3IC8gdGhldGEyIDwgbCkge1xuICAgICAgaWYgKGwgPCBkaXN0YW5jZU1heDIpIHtcbiAgICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUocmFuZG9tKSwgbCArPSB4ICogeDtcbiAgICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUocmFuZG9tKSwgbCArPSB5ICogeTtcbiAgICAgICAgaWYgKGwgPCBkaXN0YW5jZU1pbjIpIGwgPSBNYXRoLnNxcnQoZGlzdGFuY2VNaW4yICogbCk7XG4gICAgICAgIG5vZGUudnggKz0geCAqIHF1YWQudmFsdWUgKiBhbHBoYSAvIGw7XG4gICAgICAgIG5vZGUudnkgKz0geSAqIHF1YWQudmFsdWUgKiBhbHBoYSAvIGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgcG9pbnRzIGRpcmVjdGx5LlxuICAgIGVsc2UgaWYgKHF1YWQubGVuZ3RoIHx8IGwgPj0gZGlzdGFuY2VNYXgyKSByZXR1cm47XG5cbiAgICAvLyBMaW1pdCBmb3JjZXMgZm9yIHZlcnkgY2xvc2Ugbm9kZXM7IHJhbmRvbWl6ZSBkaXJlY3Rpb24gaWYgY29pbmNpZGVudC5cbiAgICBpZiAocXVhZC5kYXRhICE9PSBub2RlIHx8IHF1YWQubmV4dCkge1xuICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUocmFuZG9tKSwgbCArPSB4ICogeDtcbiAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geSAqIHk7XG4gICAgICBpZiAobCA8IGRpc3RhbmNlTWluMikgbCA9IE1hdGguc3FydChkaXN0YW5jZU1pbjIgKiBsKTtcbiAgICB9XG5cbiAgICBkbyBpZiAocXVhZC5kYXRhICE9PSBub2RlKSB7XG4gICAgICB3ID0gc3RyZW5ndGhzW3F1YWQuZGF0YS5pbmRleF0gKiBhbHBoYSAvIGw7XG4gICAgICBub2RlLnZ4ICs9IHggKiB3O1xuICAgICAgbm9kZS52eSArPSB5ICogdztcbiAgICB9IHdoaWxlIChxdWFkID0gcXVhZC5uZXh0KTtcbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfbm9kZXMsIF9yYW5kb20pIHtcbiAgICBub2RlcyA9IF9ub2RlcztcbiAgICByYW5kb20gPSBfcmFuZG9tO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLmRpc3RhbmNlTWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlTWluMiA9IF8gKiBfLCBmb3JjZSkgOiBNYXRoLnNxcnQoZGlzdGFuY2VNaW4yKTtcbiAgfTtcblxuICBmb3JjZS5kaXN0YW5jZU1heCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkaXN0YW5jZU1heDIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KGRpc3RhbmNlTWF4Mik7XG4gIH07XG5cbiAgZm9yY2UudGhldGEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhldGEyID0gXyAqIF8sIGZvcmNlKSA6IE1hdGguc3FydCh0aGV0YTIpO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCB7ZGlzcGF0Y2h9IGZyb20gXCJkMy1kaXNwYXRjaFwiO1xuaW1wb3J0IHt0aW1lcn0gZnJvbSBcImQzLXRpbWVyXCI7XG5pbXBvcnQgbGNnIGZyb20gXCIuL2xjZy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkLng7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGQueTtcbn1cblxudmFyIGluaXRpYWxSYWRpdXMgPSAxMCxcbiAgICBpbml0aWFsQW5nbGUgPSBNYXRoLlBJICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2Rlcykge1xuICB2YXIgc2ltdWxhdGlvbixcbiAgICAgIGFscGhhID0gMSxcbiAgICAgIGFscGhhTWluID0gMC4wMDEsXG4gICAgICBhbHBoYURlY2F5ID0gMSAtIE1hdGgucG93KGFscGhhTWluLCAxIC8gMzAwKSxcbiAgICAgIGFscGhhVGFyZ2V0ID0gMCxcbiAgICAgIHZlbG9jaXR5RGVjYXkgPSAwLjYsXG4gICAgICBmb3JjZXMgPSBuZXcgTWFwKCksXG4gICAgICBzdGVwcGVyID0gdGltZXIoc3RlcCksXG4gICAgICBldmVudCA9IGRpc3BhdGNoKFwidGlja1wiLCBcImVuZFwiKSxcbiAgICAgIHJhbmRvbSA9IGxjZygpO1xuXG4gIGlmIChub2RlcyA9PSBudWxsKSBub2RlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgdGljaygpO1xuICAgIGV2ZW50LmNhbGwoXCJ0aWNrXCIsIHNpbXVsYXRpb24pO1xuICAgIGlmIChhbHBoYSA8IGFscGhhTWluKSB7XG4gICAgICBzdGVwcGVyLnN0b3AoKTtcbiAgICAgIGV2ZW50LmNhbGwoXCJlbmRcIiwgc2ltdWxhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGljayhpdGVyYXRpb25zKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG5cbiAgICBpZiAoaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkKSBpdGVyYXRpb25zID0gMTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICBhbHBoYSArPSAoYWxwaGFUYXJnZXQgLSBhbHBoYSkgKiBhbHBoYURlY2F5O1xuXG4gICAgICBmb3JjZXMuZm9yRWFjaChmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICBmb3JjZShhbHBoYSk7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmZ4ID09IG51bGwpIG5vZGUueCArPSBub2RlLnZ4ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgIGVsc2Ugbm9kZS54ID0gbm9kZS5meCwgbm9kZS52eCA9IDA7XG4gICAgICAgIGlmIChub2RlLmZ5ID09IG51bGwpIG5vZGUueSArPSBub2RlLnZ5ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgIGVsc2Ugbm9kZS55ID0gbm9kZS5meSwgbm9kZS52eSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbXVsYXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplTm9kZXMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS5pbmRleCA9IGk7XG4gICAgICBpZiAobm9kZS5meCAhPSBudWxsKSBub2RlLnggPSBub2RlLmZ4O1xuICAgICAgaWYgKG5vZGUuZnkgIT0gbnVsbCkgbm9kZS55ID0gbm9kZS5meTtcbiAgICAgIGlmIChpc05hTihub2RlLngpIHx8IGlzTmFOKG5vZGUueSkpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGluaXRpYWxSYWRpdXMgKiBNYXRoLnNxcnQoMC41ICsgaSksIGFuZ2xlID0gaSAqIGluaXRpYWxBbmdsZTtcbiAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOYU4obm9kZS52eCkgfHwgaXNOYU4obm9kZS52eSkpIHtcbiAgICAgICAgbm9kZS52eCA9IG5vZGUudnkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVGb3JjZShmb3JjZSkge1xuICAgIGlmIChmb3JjZS5pbml0aWFsaXplKSBmb3JjZS5pbml0aWFsaXplKG5vZGVzLCByYW5kb20pO1xuICAgIHJldHVybiBmb3JjZTtcbiAgfVxuXG4gIGluaXRpYWxpemVOb2RlcygpO1xuXG4gIHJldHVybiBzaW11bGF0aW9uID0ge1xuICAgIHRpY2s6IHRpY2ssXG5cbiAgICByZXN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwcGVyLnJlc3RhcnQoc3RlcCksIHNpbXVsYXRpb247XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0ZXBwZXIuc3RvcCgpLCBzaW11bGF0aW9uO1xuICAgIH0sXG5cbiAgICBub2RlczogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZXMgPSBfLCBpbml0aWFsaXplTm9kZXMoKSwgZm9yY2VzLmZvckVhY2goaW5pdGlhbGl6ZUZvcmNlKSwgc2ltdWxhdGlvbikgOiBub2RlcztcbiAgICB9LFxuXG4gICAgYWxwaGE6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGE7XG4gICAgfSxcblxuICAgIGFscGhhTWluOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYU1pbiA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhTWluO1xuICAgIH0sXG5cbiAgICBhbHBoYURlY2F5OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYURlY2F5ID0gK18sIHNpbXVsYXRpb24pIDogK2FscGhhRGVjYXk7XG4gICAgfSxcblxuICAgIGFscGhhVGFyZ2V0OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYVRhcmdldCA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhVGFyZ2V0O1xuICAgIH0sXG5cbiAgICB2ZWxvY2l0eURlY2F5OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2ZWxvY2l0eURlY2F5ID0gMSAtIF8sIHNpbXVsYXRpb24pIDogMSAtIHZlbG9jaXR5RGVjYXk7XG4gICAgfSxcblxuICAgIHJhbmRvbVNvdXJjZTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZG9tID0gXywgZm9yY2VzLmZvckVhY2goaW5pdGlhbGl6ZUZvcmNlKSwgc2ltdWxhdGlvbikgOiByYW5kb207XG4gICAgfSxcblxuICAgIGZvcmNlOiBmdW5jdGlvbihuYW1lLCBfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoKF8gPT0gbnVsbCA/IGZvcmNlcy5kZWxldGUobmFtZSkgOiBmb3JjZXMuc2V0KG5hbWUsIGluaXRpYWxpemVGb3JjZShfKSkpLCBzaW11bGF0aW9uKSA6IGZvcmNlcy5nZXQobmFtZSk7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgZHgsXG4gICAgICAgICAgZHksXG4gICAgICAgICAgZDIsXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBjbG9zZXN0O1xuXG4gICAgICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICAgICAgZWxzZSByYWRpdXMgKj0gcmFkaXVzO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgZHggPSB4IC0gbm9kZS54O1xuICAgICAgICBkeSA9IHkgLSBub2RlLnk7XG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkMiA8IHJhZGl1cykgY2xvc2VzdCA9IG5vZGUsIHJhZGl1cyA9IGQyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uKG5hbWUsIF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IChldmVudC5vbihuYW1lLCBfKSwgc2ltdWxhdGlvbikgOiBldmVudC5vbihuYW1lKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICB2YXIgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgbm9kZXMsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICB4ejtcblxuICBpZiAodHlwZW9mIHggIT09IFwiZnVuY3Rpb25cIikgeCA9IGNvbnN0YW50KHggPT0gbnVsbCA/IDAgOiAreCk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnZ4ICs9ICh4eltpXSAtIG5vZGUueCkgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgeHogPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeHpbaV0gPSAreChub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB4O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih5KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBub2RlcyxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHl6O1xuXG4gIGlmICh0eXBlb2YgeSAhPT0gXCJmdW5jdGlvblwiKSB5ID0gY29uc3RhbnQoeSA9PSBudWxsID8gMCA6ICt5KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnkgKz0gKHl6W2ldIC0gbm9kZS55KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB5eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih5eltpXSA9ICt5KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICBjb25zdCB4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSxcbiAgICAgIHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpO1xuICByZXR1cm4gYWRkKHRoaXMuY292ZXIoeCwgeSksIHgsIHksIGQpO1xufVxuXG5mdW5jdGlvbiBhZGQodHJlZSwgeCwgeSwgZCkge1xuICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiB0cmVlOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRyZWUuX3Jvb3QsXG4gICAgICBsZWFmID0ge2RhdGE6IGR9LFxuICAgICAgeDAgPSB0cmVlLl94MCxcbiAgICAgIHkwID0gdHJlZS5feTAsXG4gICAgICB4MSA9IHRyZWUuX3gxLFxuICAgICAgeTEgPSB0cmVlLl95MSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICB4cCxcbiAgICAgIHlwLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIEZpbmQgdGhlIGV4aXN0aW5nIGxlYWYgZm9yIHRoZSBuZXcgcG9pbnQsIG9yIGFkZCBpdC5cbiAgd2hpbGUgKG5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKHBhcmVudCA9IG5vZGUsICEobm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG4gIH1cblxuICAvLyBJcyB0aGUgbmV3IHBvaW50IGlzIGV4YWN0bHkgY29pbmNpZGVudCB3aXRoIHRoZSBleGlzdGluZyBwb2ludD9cbiAgeHAgPSArdHJlZS5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIHlwID0gK3RyZWUuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICBpZiAoeCA9PT0geHAgJiYgeSA9PT0geXApIHJldHVybiBsZWFmLm5leHQgPSBub2RlLCBwYXJlbnQgPyBwYXJlbnRbaV0gPSBsZWFmIDogdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxuICBkbyB7XG4gICAgcGFyZW50ID0gcGFyZW50ID8gcGFyZW50W2ldID0gbmV3IEFycmF5KDQpIDogdHJlZS5fcm9vdCA9IG5ldyBBcnJheSg0KTtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgfSB3aGlsZSAoKGkgPSBib3R0b20gPDwgMSB8IHJpZ2h0KSA9PT0gKGogPSAoeXAgPj0geW0pIDw8IDEgfCAoeHAgPj0geG0pKSk7XG4gIHJldHVybiBwYXJlbnRbal0gPSBub2RlLCBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQWxsKGRhdGEpIHtcbiAgdmFyIGQsIGksIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeHogPSBuZXcgQXJyYXkobiksXG4gICAgICB5eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHgwID0gSW5maW5pdHksXG4gICAgICB5MCA9IEluZmluaXR5LFxuICAgICAgeDEgPSAtSW5maW5pdHksXG4gICAgICB5MSA9IC1JbmZpbml0eTtcblxuICAvLyBDb21wdXRlIHRoZSBwb2ludHMgYW5kIHRoZWlyIGV4dGVudC5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkID0gZGF0YVtpXSkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgY29udGludWU7XG4gICAgeHpbaV0gPSB4O1xuICAgIHl6W2ldID0geTtcbiAgICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gICAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICAgIGlmICh5IDwgeTApIHkwID0geTtcbiAgICBpZiAoeSA+IHkxKSB5MSA9IHk7XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlIG5vICh2YWxpZCkgcG9pbnRzLCBhYm9ydC5cbiAgaWYgKHgwID4geDEgfHwgeTAgPiB5MSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRXhwYW5kIHRoZSB0cmVlIHRvIGNvdmVyIHRoZSBuZXcgcG9pbnRzLlxuICB0aGlzLmNvdmVyKHgwLCB5MCkuY292ZXIoeDEsIHkxKTtcblxuICAvLyBBZGQgdGhlIG5ldyBwb2ludHMuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBhZGQodGhpcywgeHpbaV0sIHl6W2ldLCBkYXRhW2ldKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICBpZiAoaXNOYU4oeCA9ICt4KSB8fCBpc05hTih5ID0gK3kpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTE7XG5cbiAgLy8gSWYgdGhlIHF1YWR0cmVlIGhhcyBubyBleHRlbnQsIGluaXRpYWxpemUgdGhlbS5cbiAgLy8gSW50ZWdlciBleHRlbnQgYXJlIG5lY2Vzc2FyeSBzbyB0aGF0IGlmIHdlIGxhdGVyIGRvdWJsZSB0aGUgZXh0ZW50LFxuICAvLyB0aGUgZXhpc3RpbmcgcXVhZHJhbnQgYm91bmRhcmllcyBkb27igJl0IGNoYW5nZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3IhXG4gIGlmIChpc05hTih4MCkpIHtcbiAgICB4MSA9ICh4MCA9IE1hdGguZmxvb3IoeCkpICsgMTtcbiAgICB5MSA9ICh5MCA9IE1hdGguZmxvb3IoeSkpICsgMTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZG91YmxlIHJlcGVhdGVkbHkgdG8gY292ZXIuXG4gIGVsc2Uge1xuICAgIHZhciB6ID0geDEgLSB4MCB8fCAxLFxuICAgICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKHgwID4geCB8fCB4ID49IHgxIHx8IHkwID4geSB8fCB5ID49IHkxKSB7XG4gICAgICBpID0gKHkgPCB5MCkgPDwgMSB8ICh4IDwgeDApO1xuICAgICAgcGFyZW50ID0gbmV3IEFycmF5KDQpLCBwYXJlbnRbaV0gPSBub2RlLCBub2RlID0gcGFyZW50LCB6ICo9IDI7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOiB4MSA9IHgwICsgeiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDE6IHgwID0geDEgLSB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogeDEgPSB4MCArIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgICAgY2FzZSAzOiB4MCA9IHgxIC0geiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvIGRhdGEucHVzaChub2RlLmRhdGEpOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdLCArX1swXVsxXSkuY292ZXIoK19bMV1bMF0sICtfWzFdWzFdKVxuICAgICAgOiBpc05hTih0aGlzLl94MCkgPyB1bmRlZmluZWQgOiBbW3RoaXMuX3gwLCB0aGlzLl95MF0sIFt0aGlzLl94MSwgdGhpcy5feTFdXTtcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG4gIHZhciBkYXRhLFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MixcbiAgICAgIHgzID0gdGhpcy5feDEsXG4gICAgICB5MyA9IHRoaXMuX3kxLFxuICAgICAgcXVhZHMgPSBbXSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcSxcbiAgICAgIGk7XG5cbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgeDAsIHkwLCB4MywgeTMpKTtcbiAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgZWxzZSB7XG4gICAgeDAgPSB4IC0gcmFkaXVzLCB5MCA9IHkgLSByYWRpdXM7XG4gICAgeDMgPSB4ICsgcmFkaXVzLCB5MyA9IHkgKyByYWRpdXM7XG4gICAgcmFkaXVzICo9IHJhZGl1cztcbiAgfVxuXG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcblxuICAgIC8vIFN0b3Agc2VhcmNoaW5nIGlmIHRoaXMgcXVhZHJhbnQgY2Fu4oCZdCBjb250YWluIGEgY2xvc2VyIG5vZGUuXG4gICAgaWYgKCEobm9kZSA9IHEubm9kZSlcbiAgICAgICAgfHwgKHgxID0gcS54MCkgPiB4M1xuICAgICAgICB8fCAoeTEgPSBxLnkwKSA+IHkzXG4gICAgICAgIHx8ICh4MiA9IHEueDEpIDwgeDBcbiAgICAgICAgfHwgKHkyID0gcS55MSkgPCB5MCkgY29udGludWU7XG5cbiAgICAvLyBCaXNlY3QgdGhlIGN1cnJlbnQgcXVhZHJhbnQuXG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgIHltID0gKHkxICsgeTIpIC8gMjtcblxuICAgICAgcXVhZHMucHVzaChcbiAgICAgICAgbmV3IFF1YWQobm9kZVszXSwgeG0sIHltLCB4MiwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzJdLCB4MSwgeW0sIHhtLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMV0sIHhtLCB5MSwgeDIsIHltKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVswXSwgeDEsIHkxLCB4bSwgeW0pXG4gICAgICApO1xuXG4gICAgICAvLyBWaXNpdCB0aGUgY2xvc2VzdCBxdWFkcmFudCBmaXJzdC5cbiAgICAgIGlmIChpID0gKHkgPj0geW0pIDw8IDEgfCAoeCA+PSB4bSkpIHtcbiAgICAgICAgcSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxXSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldID0gcTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWaXNpdCB0aGlzIHBvaW50LiAoVmlzaXRpbmcgY29pbmNpZGVudCBwb2ludHMgaXNu4oCZdCBuZWNlc3NhcnkhKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGR4ID0geCAtICt0aGlzLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkeSA9IHkgLSArdGhpcy5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkMiA8IHJhZGl1cykge1xuICAgICAgICB2YXIgZCA9IE1hdGguc3FydChyYWRpdXMgPSBkMik7XG4gICAgICAgIHgwID0geCAtIGQsIHkwID0geSAtIGQ7XG4gICAgICAgIHgzID0geCArIGQsIHkzID0geSArIGQ7XG4gICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLngwID0geDA7XG4gIHRoaXMueTAgPSB5MDtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG59XG4iLCJpbXBvcnQgdHJlZV9hZGQsIHthZGRBbGwgYXMgdHJlZV9hZGRBbGx9IGZyb20gXCIuL2FkZC5qc1wiO1xuaW1wb3J0IHRyZWVfY292ZXIgZnJvbSBcIi4vY292ZXIuanNcIjtcbmltcG9ydCB0cmVlX2RhdGEgZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHRyZWVfZXh0ZW50IGZyb20gXCIuL2V4dGVudC5qc1wiO1xuaW1wb3J0IHRyZWVfZmluZCBmcm9tIFwiLi9maW5kLmpzXCI7XG5pbXBvcnQgdHJlZV9yZW1vdmUsIHtyZW1vdmVBbGwgYXMgdHJlZV9yZW1vdmVBbGx9IGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyZWVfcm9vdCBmcm9tIFwiLi9yb290LmpzXCI7XG5pbXBvcnQgdHJlZV9zaXplIGZyb20gXCIuL3NpemUuanNcIjtcbmltcG9ydCB0cmVlX3Zpc2l0IGZyb20gXCIuL3Zpc2l0LmpzXCI7XG5pbXBvcnQgdHJlZV92aXNpdEFmdGVyIGZyb20gXCIuL3Zpc2l0QWZ0ZXIuanNcIjtcbmltcG9ydCB0cmVlX3gsIHtkZWZhdWx0WH0gZnJvbSBcIi4veC5qc1wiO1xuaW1wb3J0IHRyZWVfeSwge2RlZmF1bHRZfSBmcm9tIFwiLi95LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YWR0cmVlKG5vZGVzLCB4LCB5KSB7XG4gIHZhciB0cmVlID0gbmV3IFF1YWR0cmVlKHggPT0gbnVsbCA/IGRlZmF1bHRYIDogeCwgeSA9PSBudWxsID8gZGVmYXVsdFkgOiB5LCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICByZXR1cm4gbm9kZXMgPT0gbnVsbCA/IHRyZWUgOiB0cmVlLmFkZEFsbChub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIFF1YWR0cmVlKHgsIHksIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgdGhpcy5fcm9vdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbGVhZl9jb3B5KGxlYWYpIHtcbiAgdmFyIGNvcHkgPSB7ZGF0YTogbGVhZi5kYXRhfSwgbmV4dCA9IGNvcHk7XG4gIHdoaWxlIChsZWFmID0gbGVhZi5uZXh0KSBuZXh0ID0gbmV4dC5uZXh0ID0ge2RhdGE6IGxlYWYuZGF0YX07XG4gIHJldHVybiBjb3B5O1xufVxuXG52YXIgdHJlZVByb3RvID0gcXVhZHRyZWUucHJvdG90eXBlID0gUXVhZHRyZWUucHJvdG90eXBlO1xuXG50cmVlUHJvdG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyBRdWFkdHJlZSh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSksXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIG5vZGVzLFxuICAgICAgY2hpbGQ7XG5cbiAgaWYgKCFub2RlKSByZXR1cm4gY29weTtcblxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcblxuICBub2RlcyA9IFt7c291cmNlOiBub2RlLCB0YXJnZXQ6IGNvcHkuX3Jvb3QgPSBuZXcgQXJyYXkoNCl9XTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlLnNvdXJjZVtpXSkge1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDQpfSk7XG4gICAgICAgIGVsc2Ugbm9kZS50YXJnZXRbaV0gPSBsZWFmX2NvcHkoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xudHJlZVByb3RvLmFkZEFsbCA9IHRyZWVfYWRkQWxsO1xudHJlZVByb3RvLmNvdmVyID0gdHJlZV9jb3ZlcjtcbnRyZWVQcm90by5kYXRhID0gdHJlZV9kYXRhO1xudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xudHJlZVByb3RvLmZpbmQgPSB0cmVlX2ZpbmQ7XG50cmVlUHJvdG8ucmVtb3ZlID0gdHJlZV9yZW1vdmU7XG50cmVlUHJvdG8ucmVtb3ZlQWxsID0gdHJlZV9yZW1vdmVBbGw7XG50cmVlUHJvdG8ucm9vdCA9IHRyZWVfcm9vdDtcbnRyZWVQcm90by5zaXplID0gdHJlZV9zaXplO1xudHJlZVByb3RvLnZpc2l0ID0gdHJlZV92aXNpdDtcbnRyZWVQcm90by52aXNpdEFmdGVyID0gdHJlZV92aXNpdEFmdGVyO1xudHJlZVByb3RvLnggPSB0cmVlX3g7XG50cmVlUHJvdG8ueSA9IHRyZWVfeTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGQpIHtcbiAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICByZXRhaW5lcixcbiAgICAgIHByZXZpb3VzLFxuICAgICAgbmV4dCxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdGhpcztcblxuICAvLyBGaW5kIHRoZSBsZWFmIG5vZGUgZm9yIHRoZSBwb2ludC5cbiAgLy8gV2hpbGUgZGVzY2VuZGluZywgYWxzbyByZXRhaW4gdGhlIGRlZXBlc3QgcGFyZW50IHdpdGggYSBub24tcmVtb3ZlZCBzaWJsaW5nLlxuICBpZiAobm9kZS5sZW5ndGgpIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKCEocGFyZW50ID0gbm9kZSwgbm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgYnJlYWs7XG4gICAgaWYgKHBhcmVudFsoaSArIDEpICYgM10gfHwgcGFyZW50WyhpICsgMikgJiAzXSB8fCBwYXJlbnRbKGkgKyAzKSAmIDNdKSByZXRhaW5lciA9IHBhcmVudCwgaiA9IGk7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBwb2ludCB0byByZW1vdmUuXG4gIHdoaWxlIChub2RlLmRhdGEgIT09IGQpIGlmICghKHByZXZpb3VzID0gbm9kZSwgbm9kZSA9IG5vZGUubmV4dCkpIHJldHVybiB0aGlzO1xuICBpZiAobmV4dCA9IG5vZGUubmV4dCkgZGVsZXRlIG5vZGUubmV4dDtcblxuICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29pbmNpZGVudCBwb2ludHMsIHJlbW92ZSBqdXN0IHRoZSBwb2ludC5cbiAgaWYgKHByZXZpb3VzKSByZXR1cm4gKG5leHQgPyBwcmV2aW91cy5uZXh0ID0gbmV4dCA6IGRlbGV0ZSBwcmV2aW91cy5uZXh0KSwgdGhpcztcblxuICAvLyBJZiB0aGlzIGlzIHRoZSByb290IHBvaW50LCByZW1vdmUgaXQuXG4gIGlmICghcGFyZW50KSByZXR1cm4gdGhpcy5fcm9vdCA9IG5leHQsIHRoaXM7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVhZi5cbiAgbmV4dCA/IHBhcmVudFtpXSA9IG5leHQgOiBkZWxldGUgcGFyZW50W2ldO1xuXG4gIC8vIElmIHRoZSBwYXJlbnQgbm93IGNvbnRhaW5zIGV4YWN0bHkgb25lIGxlYWYsIGNvbGxhcHNlIHN1cGVyZmx1b3VzIHBhcmVudHMuXG4gIGlmICgobm9kZSA9IHBhcmVudFswXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzJdIHx8IHBhcmVudFszXSlcbiAgICAgICYmIG5vZGUgPT09IChwYXJlbnRbM10gfHwgcGFyZW50WzJdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMF0pXG4gICAgICAmJiAhbm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGwoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyArK3NpemU7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBxLCBub2RlID0gdGhpcy5fcm9vdCwgY2hpbGQsIHgwLCB5MCwgeDEsIHkxO1xuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgaWYgKCFjYWxsYmFjayhub2RlID0gcS5ub2RlLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEpICYmIG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIG5leHQgPSBbXSwgcTtcbiAgaWYgKHRoaXMuX3Jvb3QpIHF1YWRzLnB1c2gobmV3IFF1YWQodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIHZhciBub2RlID0gcS5ub2RlO1xuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEsIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICB9XG4gICAgbmV4dC5wdXNoKHEpO1xuICB9XG4gIHdoaWxlIChxID0gbmV4dC5wb3AoKSkge1xuICAgIGNhbGxiYWNrKHEubm9kZSwgcS54MCwgcS55MCwgcS54MSwgcS55MSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGVmYXVsdFgoZCkge1xuICByZXR1cm4gZFswXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl94ID0gXywgdGhpcykgOiB0aGlzLl94O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRZKGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feSA9IF8sIHRoaXMpIDogdGhpcy5feTtcbn1cbiIsImltcG9ydCB7IHRpY2tTdGVwIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgZm9ybWF0U3BlY2lmaWVyLCBwcmVjaXNpb25GaXhlZCwgcHJlY2lzaW9uUm91bmQsIHByZWNpc2lvblByZWZpeCwgZm9ybWF0TG9jYWxlLCBmb3JtYXQsIGZvcm1hdFByZWZpeCB9IGZyb20gJ2QzLWZvcm1hdCc7XG5pbXBvcnQgeyBTRUNPTkRTLCBNSU5VVEVTLCBIT1VSUywgREFURSwgV0VFSywgTU9OVEgsIFFVQVJURVIsIFlFQVIsIE1JTExJU0VDT05EUywgREFZLCB0aW1lSW50ZXJ2YWwsIHV0Y0ludGVydmFsIH0gZnJvbSAndmVnYS10aW1lJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc09iamVjdCwgZXJyb3IsIGV4dGVuZCB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyB0aW1lRm9ybWF0LCB0aW1lUGFyc2UsIHV0Y0Zvcm1hdCwgdXRjUGFyc2UsIHRpbWVGb3JtYXRMb2NhbGUgYXMgdGltZUZvcm1hdExvY2FsZSQxIH0gZnJvbSAnZDMtdGltZS1mb3JtYXQnO1xuXG5mdW5jdGlvbiBtZW1vaXplIChtZXRob2QpIHtcbiAgY29uc3QgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIHNwZWMgPT4gY2FjaGVbc3BlY10gfHwgKGNhY2hlW3NwZWNdID0gbWV0aG9kKHNwZWMpKTtcbn1cblxuZnVuY3Rpb24gdHJpbVplcm9lcyhudW1iZXJGb3JtYXQsIGRlY2ltYWxDaGFyKSB7XG4gIHJldHVybiB4ID0+IHtcbiAgICBjb25zdCBzdHIgPSBudW1iZXJGb3JtYXQoeCksXG4gICAgICAgICAgZGVjID0gc3RyLmluZGV4T2YoZGVjaW1hbENoYXIpO1xuICAgIGlmIChkZWMgPCAwKSByZXR1cm4gc3RyO1xuICAgIGxldCBpZHggPSByaWdodG1vc3REaWdpdChzdHIsIGRlYyk7XG4gICAgY29uc3QgZW5kID0gaWR4IDwgc3RyLmxlbmd0aCA/IHN0ci5zbGljZShpZHgpIDogJyc7XG5cbiAgICB3aGlsZSAoLS1pZHggPiBkZWMpIGlmIChzdHJbaWR4XSAhPT0gJzAnKSB7XG4gICAgICArK2lkeDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgaWR4KSArIGVuZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmlnaHRtb3N0RGlnaXQoc3RyLCBkZWMpIHtcbiAgbGV0IGkgPSBzdHIubGFzdEluZGV4T2YoJ2UnKSxcbiAgICAgIGM7XG4gIGlmIChpID4gMCkgcmV0dXJuIGk7XG5cbiAgZm9yIChpID0gc3RyLmxlbmd0aDsgLS1pID4gZGVjOykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSByZXR1cm4gaSArIDE7IC8vIGlzIGRpZ2l0XG4gIH1cbn1cblxuZnVuY3Rpb24gbnVtYmVyTG9jYWxlKGxvY2FsZSkge1xuICBjb25zdCBmb3JtYXQgPSBtZW1vaXplKGxvY2FsZS5mb3JtYXQpLFxuICAgICAgICBmb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4ge1xuICAgIGZvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXgsXG5cbiAgICBmb3JtYXRGbG9hdChzcGVjKSB7XG4gICAgICBjb25zdCBzID0gZm9ybWF0U3BlY2lmaWVyKHNwZWMgfHwgJywnKTtcblxuICAgICAgaWYgKHMucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgcy5wcmVjaXNpb24gPSAxMjtcblxuICAgICAgICBzd2l0Y2ggKHMudHlwZSkge1xuICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcy5wcmVjaXNpb24gLT0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICBzLnByZWNpc2lvbiAtPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJpbVplcm9lcyhmb3JtYXQocyksIC8vIG51bWJlciBmb3JtYXRcbiAgICAgICAgZm9ybWF0KCcuMWYnKSgxKVsxXSAvLyBkZWNpbWFsIHBvaW50IGNoYXJhY3RlclxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdChzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZm9ybWF0U3BhbihzdGFydCwgc3RvcCwgY291bnQsIHNwZWNpZmllcikge1xuICAgICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gJyxmJyA6IHNwZWNpZmllcik7XG4gICAgICBjb25zdCBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICBsZXQgcHJlY2lzaW9uO1xuXG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25Sb3VuZChzdGVwLCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gJ2UnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uRml4ZWQoc3RlcCkpKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gJyUnKSAqIDI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9ybWF0KHNwZWNpZmllcik7XG4gICAgfVxuXG4gIH07XG59XG5cbmxldCBkZWZhdWx0TnVtYmVyTG9jYWxlO1xucmVzZXROdW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG5mdW5jdGlvbiByZXNldE51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoKSB7XG4gIHJldHVybiBkZWZhdWx0TnVtYmVyTG9jYWxlID0gbnVtYmVyTG9jYWxlKHtcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICB9KTtcbn1cbmZ1bmN0aW9uIG51bWJlckZvcm1hdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIHJldHVybiBudW1iZXJMb2NhbGUoZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pKTtcbn1cbmZ1bmN0aW9uIG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRlZmF1bHROdW1iZXJMb2NhbGUgPSBudW1iZXJGb3JtYXRMb2NhbGUoZGVmaW5pdGlvbikgOiBkZWZhdWx0TnVtYmVyTG9jYWxlO1xufVxuXG5mdW5jdGlvbiB0aW1lTXVsdGlGb3JtYXQoZm9ybWF0LCBpbnRlcnZhbCwgc3BlYykge1xuICBzcGVjID0gc3BlYyB8fCB7fTtcblxuICBpZiAoIWlzT2JqZWN0KHNwZWMpKSB7XG4gICAgZXJyb3IoXCJJbnZhbGlkIHRpbWUgbXVsdGktZm9ybWF0IHNwZWNpZmllcjogXCIuY29uY2F0KHNwZWMpKTtcbiAgfVxuXG4gIGNvbnN0IHNlY29uZCA9IGludGVydmFsKFNFQ09ORFMpLFxuICAgICAgICBtaW51dGUgPSBpbnRlcnZhbChNSU5VVEVTKSxcbiAgICAgICAgaG91ciA9IGludGVydmFsKEhPVVJTKSxcbiAgICAgICAgZGF5ID0gaW50ZXJ2YWwoREFURSksXG4gICAgICAgIHdlZWsgPSBpbnRlcnZhbChXRUVLKSxcbiAgICAgICAgbW9udGggPSBpbnRlcnZhbChNT05USCksXG4gICAgICAgIHF1YXJ0ZXIgPSBpbnRlcnZhbChRVUFSVEVSKSxcbiAgICAgICAgeWVhciA9IGludGVydmFsKFlFQVIpLFxuICAgICAgICBMID0gZm9ybWF0KHNwZWNbTUlMTElTRUNPTkRTXSB8fCAnLiVMJyksXG4gICAgICAgIFMgPSBmb3JtYXQoc3BlY1tTRUNPTkRTXSB8fCAnOiVTJyksXG4gICAgICAgIE0gPSBmb3JtYXQoc3BlY1tNSU5VVEVTXSB8fCAnJUk6JU0nKSxcbiAgICAgICAgSCA9IGZvcm1hdChzcGVjW0hPVVJTXSB8fCAnJUkgJXAnKSxcbiAgICAgICAgZCA9IGZvcm1hdChzcGVjW0RBVEVdIHx8IHNwZWNbREFZXSB8fCAnJWEgJWQnKSxcbiAgICAgICAgdyA9IGZvcm1hdChzcGVjW1dFRUtdIHx8ICclYiAlZCcpLFxuICAgICAgICBtID0gZm9ybWF0KHNwZWNbTU9OVEhdIHx8ICclQicpLFxuICAgICAgICBxID0gZm9ybWF0KHNwZWNbUVVBUlRFUl0gfHwgJyVCJyksXG4gICAgICAgIHkgPSBmb3JtYXQoc3BlY1tZRUFSXSB8fCAnJVknKTtcbiAgcmV0dXJuIGRhdGUgPT4gKHNlY29uZChkYXRlKSA8IGRhdGUgPyBMIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IFMgOiBob3VyKGRhdGUpIDwgZGF0ZSA/IE0gOiBkYXkoZGF0ZSkgPCBkYXRlID8gSCA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/IHdlZWsoZGF0ZSkgPCBkYXRlID8gZCA6IHcgOiB5ZWFyKGRhdGUpIDwgZGF0ZSA/IHF1YXJ0ZXIoZGF0ZSkgPCBkYXRlID8gbSA6IHEgOiB5KShkYXRlKTtcbn1cblxuZnVuY3Rpb24gdGltZUxvY2FsZShsb2NhbGUpIHtcbiAgY29uc3QgdGltZUZvcm1hdCA9IG1lbW9pemUobG9jYWxlLmZvcm1hdCksXG4gICAgICAgIHV0Y0Zvcm1hdCA9IG1lbW9pemUobG9jYWxlLnV0Y0Zvcm1hdCk7XG4gIHJldHVybiB7XG4gICAgdGltZUZvcm1hdDogc3BlYyA9PiBpc1N0cmluZyhzcGVjKSA/IHRpbWVGb3JtYXQoc3BlYykgOiB0aW1lTXVsdGlGb3JtYXQodGltZUZvcm1hdCwgdGltZUludGVydmFsLCBzcGVjKSxcbiAgICB1dGNGb3JtYXQ6IHNwZWMgPT4gaXNTdHJpbmcoc3BlYykgPyB1dGNGb3JtYXQoc3BlYykgOiB0aW1lTXVsdGlGb3JtYXQodXRjRm9ybWF0LCB1dGNJbnRlcnZhbCwgc3BlYyksXG4gICAgdGltZVBhcnNlOiBtZW1vaXplKGxvY2FsZS5wYXJzZSksXG4gICAgdXRjUGFyc2U6IG1lbW9pemUobG9jYWxlLnV0Y1BhcnNlKVxuICB9O1xufVxuXG5sZXQgZGVmYXVsdFRpbWVMb2NhbGU7XG5yZXNldFRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG5mdW5jdGlvbiByZXNldFRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCkge1xuICByZXR1cm4gZGVmYXVsdFRpbWVMb2NhbGUgPSB0aW1lTG9jYWxlKHtcbiAgICBmb3JtYXQ6IHRpbWVGb3JtYXQsXG4gICAgcGFyc2U6IHRpbWVQYXJzZSxcbiAgICB1dGNGb3JtYXQ6IHV0Y0Zvcm1hdCxcbiAgICB1dGNQYXJzZTogdXRjUGFyc2VcbiAgfSk7XG59XG5mdW5jdGlvbiB0aW1lRm9ybWF0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHRpbWVMb2NhbGUodGltZUZvcm1hdExvY2FsZSQxKGRlZmluaXRpb24pKTtcbn1cbmZ1bmN0aW9uIHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkZWZhdWx0VGltZUxvY2FsZSA9IHRpbWVGb3JtYXRMb2NhbGUoZGVmaW5pdGlvbikgOiBkZWZhdWx0VGltZUxvY2FsZTtcbn1cblxuY29uc3QgY3JlYXRlTG9jYWxlID0gKG51bWJlciwgdGltZSkgPT4gZXh0ZW5kKHt9LCBudW1iZXIsIHRpbWUpO1xuXG5mdW5jdGlvbiBsb2NhbGUobnVtYmVyU3BlYywgdGltZVNwZWMpIHtcbiAgY29uc3QgbnVtYmVyID0gbnVtYmVyU3BlYyA/IG51bWJlckZvcm1hdExvY2FsZShudW1iZXJTcGVjKSA6IG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoKTtcbiAgY29uc3QgdGltZSA9IHRpbWVTcGVjID8gdGltZUZvcm1hdExvY2FsZSh0aW1lU3BlYykgOiB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuICByZXR1cm4gY3JlYXRlTG9jYWxlKG51bWJlciwgdGltZSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0TG9jYWxlKG51bWJlclNwZWMsIHRpbWVTcGVjKSB7XG4gIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIGlmIChhcmdzICYmIGFyZ3MgIT09IDIpIHtcbiAgICBlcnJvcignZGVmYXVsdExvY2FsZSBleHBlY3RzIGVpdGhlciB6ZXJvIG9yIHR3byBhcmd1bWVudHMuJyk7XG4gIH1cblxuICByZXR1cm4gYXJncyA/IGNyZWF0ZUxvY2FsZShudW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlKG51bWJlclNwZWMpLCB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSh0aW1lU3BlYykpIDogY3JlYXRlTG9jYWxlKG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoKSwgdGltZUZvcm1hdERlZmF1bHRMb2NhbGUoKSk7XG59XG5mdW5jdGlvbiByZXNldERlZmF1bHRMb2NhbGUoKSB7XG4gIHJlc2V0TnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuICByZXNldFRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG4gIHJldHVybiBkZWZhdWx0TG9jYWxlKCk7XG59XG5cbmV4cG9ydCB7IGRlZmF1bHRMb2NhbGUsIGxvY2FsZSwgbnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSwgbnVtYmVyRm9ybWF0TG9jYWxlLCByZXNldERlZmF1bHRMb2NhbGUsIHJlc2V0TnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSwgcmVzZXRUaW1lRm9ybWF0RGVmYXVsdExvY2FsZSwgdGltZUZvcm1hdERlZmF1bHRMb2NhbGUsIHRpbWVGb3JtYXRMb2NhbGUgfTtcbiIsImltcG9ydCB7IHRydXRoeSwgZXJyb3IsIGhhc093blByb3BlcnR5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgc3RyaW5nVmFsdWUsIGV4dGVuZCwgaXNBcnJheSwgaXNPYmplY3QsIGZpZWxkLCBwZWVrLCBpZGVudGl0eSwgYXJyYXkgYXMgYXJyYXkkMSwgaXNCb29sZWFuLCBpc0RhdGUsIGlzTnVtYmVyLCBpc1JlZ0V4cCwgdG9Cb29sZWFuLCB0b0RhdGUsIHRvTnVtYmVyLCB0b1N0cmluZywgZmx1c2gsIGxlcnAsIHBhZCwgc3BhbiwgaW5yYW5nZSwgdHJ1bmNhdGUsIHF1YXJ0ZXIsIHV0Y3F1YXJ0ZXIsIGV4dGVudCwgY2xhbXBSYW5nZSwgcGFuTGluZWFyLCBwYW5Mb2csIHBhblBvdywgcGFuU3ltbG9nLCB6b29tTGluZWFyLCB6b29tTG9nLCB6b29tUG93LCB6b29tU3ltbG9nIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IExpdGVyYWwsIGNvZGVnZW5FeHByZXNzaW9uLCBjb25zdGFudHMsIGZ1bmN0aW9ucywgcGFyc2VFeHByZXNzaW9uLCBDYWxsRXhwcmVzc2lvbiB9IGZyb20gJ3ZlZ2EtZXhwcmVzc2lvbic7XG5pbXBvcnQgeyBnZW9Cb3VuZHMgYXMgZ2VvQm91bmRzJDEsIGdlb0NlbnRyb2lkIGFzIGdlb0NlbnRyb2lkJDEsIGdlb0FyZWEgYXMgZ2VvQXJlYSQxIH0gZnJvbSAnZDMtZ2VvJztcbmltcG9ydCB7IHJnYiwgbGFiLCBoY2wsIGhzbCB9IGZyb20gJ2QzLWNvbG9yJztcbmltcG9ydCB7IGlzVHVwbGUgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGJhbmRTcGFjZSwgc2NhbGUgYXMgc2NhbGUkMSwgc2NhbGVGcmFjdGlvbiB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuaW1wb3J0IHsgR3JhZGllbnQsIHBhdGhSZW5kZXIsIHBhdGhQYXJzZSwgQm91bmRzLCBpbnRlcnNlY3QgYXMgaW50ZXJzZWN0JDEgfSBmcm9tICd2ZWdhLXNjZW5lZ3JhcGgnO1xuaW1wb3J0IHsgc2VsZWN0aW9uVmlzaXRvciwgc2VsZWN0aW9uVGVzdCwgc2VsZWN0aW9uSWRUZXN0LCBzZWxlY3Rpb25SZXNvbHZlLCBzZWxlY3Rpb25UdXBsZXMgfSBmcm9tICd2ZWdhLXNlbGVjdGlvbnMnO1xuaW1wb3J0IHsgcmFuZG9tLCBjdW11bGF0aXZlTm9ybWFsLCBjdW11bGF0aXZlTG9nTm9ybWFsLCBjdW11bGF0aXZlVW5pZm9ybSwgZGVuc2l0eU5vcm1hbCwgZGVuc2l0eUxvZ05vcm1hbCwgZGVuc2l0eVVuaWZvcm0sIHF1YW50aWxlTm9ybWFsLCBxdWFudGlsZUxvZ05vcm1hbCwgcXVhbnRpbGVVbmlmb3JtLCBzYW1wbGVOb3JtYWwsIHNhbXBsZUxvZ05vcm1hbCwgc2FtcGxlVW5pZm9ybSB9IGZyb20gJ3ZlZ2Etc3RhdGlzdGljcyc7XG5pbXBvcnQgeyB1dGNPZmZzZXQsIHV0Y1NlcXVlbmNlLCB0aW1lT2Zmc2V0LCB0aW1lU2VxdWVuY2UsIHRpbWVVbml0U3BlY2lmaWVyLCB3ZWVrLCB1dGN3ZWVrLCBkYXlvZnllYXIsIHV0Y2RheW9meWVhciB9IGZyb20gJ3ZlZ2EtdGltZSc7XG5pbXBvcnQgeyByYW5nZSBhcyByYW5nZSQxIH0gZnJvbSAnZDMtYXJyYXknO1xuXG5mdW5jdGlvbiBkYXRhKG5hbWUpIHtcbiAgY29uc3QgZGF0YSA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdO1xuICByZXR1cm4gZGF0YSA/IGRhdGEudmFsdWVzLnZhbHVlIDogW107XG59XG5mdW5jdGlvbiBpbmRhdGEobmFtZSwgZmllbGQsIHZhbHVlKSB7XG4gIGNvbnN0IGluZGV4ID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV1bJ2luZGV4OicgKyBmaWVsZF0sXG4gICAgICAgIGVudHJ5ID0gaW5kZXggPyBpbmRleC52YWx1ZS5nZXQodmFsdWUpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gZW50cnkgPyBlbnRyeS5jb3VudCA6IGVudHJ5O1xufVxuZnVuY3Rpb24gc2V0ZGF0YShuYW1lLCB0dXBsZXMpIHtcbiAgY29uc3QgZGYgPSB0aGlzLmNvbnRleHQuZGF0YWZsb3csXG4gICAgICAgIGRhdGEgPSB0aGlzLmNvbnRleHQuZGF0YVtuYW1lXSxcbiAgICAgICAgaW5wdXQgPSBkYXRhLmlucHV0O1xuICBkZi5wdWxzZShpbnB1dCwgZGYuY2hhbmdlc2V0KCkucmVtb3ZlKHRydXRoeSkuaW5zZXJ0KHR1cGxlcykpO1xuICByZXR1cm4gMTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlIChpdGVtLCBuYW1lLCByZXR2YWwpIHtcbiAgaWYgKGl0ZW0pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuY29udGV4dC5kYXRhZmxvdyxcbiAgICAgICAgICB0YXJnZXQgPSBpdGVtLm1hcmsuc291cmNlO1xuICAgIGRmLnB1bHNlKHRhcmdldCwgZGYuY2hhbmdlc2V0KCkuZW5jb2RlKGl0ZW0sIG5hbWUpKTtcbiAgfVxuXG4gIHJldHVybiByZXR2YWwgIT09IHVuZGVmaW5lZCA/IHJldHZhbCA6IGl0ZW07XG59XG5cbmNvbnN0IHdyYXAgPSBtZXRob2QgPT4gZnVuY3Rpb24gKHZhbHVlLCBzcGVjKSB7XG4gIGNvbnN0IGxvY2FsZSA9IHRoaXMuY29udGV4dC5kYXRhZmxvdy5sb2NhbGUoKTtcbiAgcmV0dXJuIGxvY2FsZVttZXRob2RdKHNwZWMpKHZhbHVlKTtcbn07XG5cbmNvbnN0IGZvcm1hdCA9IHdyYXAoJ2Zvcm1hdCcpO1xuY29uc3QgdGltZUZvcm1hdCA9IHdyYXAoJ3RpbWVGb3JtYXQnKTtcbmNvbnN0IHV0Y0Zvcm1hdCA9IHdyYXAoJ3V0Y0Zvcm1hdCcpO1xuY29uc3QgdGltZVBhcnNlID0gd3JhcCgndGltZVBhcnNlJyk7XG5jb25zdCB1dGNQYXJzZSA9IHdyYXAoJ3V0Y1BhcnNlJyk7XG5jb25zdCBkYXRlT2JqID0gbmV3IERhdGUoMjAwMCwgMCwgMSk7XG5cbmZ1bmN0aW9uIHRpbWUobW9udGgsIGRheSwgc3BlY2lmaWVyKSB7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihtb250aCkgfHwgIU51bWJlci5pc0ludGVnZXIoZGF5KSkgcmV0dXJuICcnO1xuICBkYXRlT2JqLnNldFllYXIoMjAwMCk7XG4gIGRhdGVPYmouc2V0TW9udGgobW9udGgpO1xuICBkYXRlT2JqLnNldERhdGUoZGF5KTtcbiAgcmV0dXJuIHRpbWVGb3JtYXQuY2FsbCh0aGlzLCBkYXRlT2JqLCBzcGVjaWZpZXIpO1xufVxuXG5mdW5jdGlvbiBtb250aEZvcm1hdChtb250aCkge1xuICByZXR1cm4gdGltZS5jYWxsKHRoaXMsIG1vbnRoLCAxLCAnJUInKTtcbn1cbmZ1bmN0aW9uIG1vbnRoQWJicmV2Rm9ybWF0KG1vbnRoKSB7XG4gIHJldHVybiB0aW1lLmNhbGwodGhpcywgbW9udGgsIDEsICclYicpO1xufVxuZnVuY3Rpb24gZGF5Rm9ybWF0KGRheSkge1xuICByZXR1cm4gdGltZS5jYWxsKHRoaXMsIDAsIDIgKyBkYXksICclQScpO1xufVxuZnVuY3Rpb24gZGF5QWJicmV2Rm9ybWF0KGRheSkge1xuICByZXR1cm4gdGltZS5jYWxsKHRoaXMsIDAsIDIgKyBkYXksICclYScpO1xufVxuXG5jb25zdCBEYXRhUHJlZml4ID0gJzonO1xuY29uc3QgSW5kZXhQcmVmaXggPSAnQCc7XG5jb25zdCBTY2FsZVByZWZpeCA9ICclJztcbmNvbnN0IFNpZ25hbFByZWZpeCA9ICckJztcblxuZnVuY3Rpb24gZGF0YVZpc2l0b3IobmFtZSwgYXJncywgc2NvcGUsIHBhcmFtcykge1xuICBpZiAoYXJnc1swXS50eXBlICE9PSBMaXRlcmFsKSB7XG4gICAgZXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIGRhdGEgZnVuY3Rpb25zIG11c3QgYmUgYSBzdHJpbmcgbGl0ZXJhbC4nKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSBhcmdzWzBdLnZhbHVlLFxuICAgICAgICBkYXRhTmFtZSA9IERhdGFQcmVmaXggKyBkYXRhO1xuXG4gIGlmICghaGFzT3duUHJvcGVydHkoZGF0YU5hbWUsIHBhcmFtcykpIHtcbiAgICB0cnkge1xuICAgICAgcGFyYW1zW2RhdGFOYW1lXSA9IHNjb3BlLmdldERhdGEoZGF0YSkudHVwbGVzUmVmKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7Ly8gaWYgZGF0YSBzZXQgZG9lcyBub3QgZXhpc3QsIHRoZXJlJ3Mgbm90aGluZyB0byB0cmFja1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW5kYXRhVmlzaXRvcihuYW1lLCBhcmdzLCBzY29wZSwgcGFyYW1zKSB7XG4gIGlmIChhcmdzWzBdLnR5cGUgIT09IExpdGVyYWwpIGVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBpbmRhdGEgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLicpO1xuICBpZiAoYXJnc1sxXS50eXBlICE9PSBMaXRlcmFsKSBlcnJvcignU2Vjb25kIGFyZ3VtZW50IHRvIGluZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGxpdGVyYWwuJyk7XG4gIGNvbnN0IGRhdGEgPSBhcmdzWzBdLnZhbHVlLFxuICAgICAgICBmaWVsZCA9IGFyZ3NbMV0udmFsdWUsXG4gICAgICAgIGluZGV4TmFtZSA9IEluZGV4UHJlZml4ICsgZmllbGQ7XG5cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShpbmRleE5hbWUsIHBhcmFtcykpIHtcbiAgICBwYXJhbXNbaW5kZXhOYW1lXSA9IHNjb3BlLmdldERhdGEoZGF0YSkuaW5kYXRhUmVmKHNjb3BlLCBmaWVsZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNjYWxlVmlzaXRvcihuYW1lLCBhcmdzLCBzY29wZSwgcGFyYW1zKSB7XG4gIGlmIChhcmdzWzBdLnR5cGUgPT09IExpdGVyYWwpIHtcbiAgICAvLyBhZGQgc2NhbGUgZGVwZW5kZW5jeVxuICAgIGFkZFNjYWxlRGVwZW5kZW5jeShzY29wZSwgcGFyYW1zLCBhcmdzWzBdLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbmRpcmVjdCBzY2FsZSBsb29rdXA7IGFkZCBhbGwgc2NhbGVzIGFzIHBhcmFtZXRlcnNcbiAgICBmb3IgKG5hbWUgaW4gc2NvcGUuc2NhbGVzKSB7XG4gICAgICBhZGRTY2FsZURlcGVuZGVuY3koc2NvcGUsIHBhcmFtcywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFNjYWxlRGVwZW5kZW5jeShzY29wZSwgcGFyYW1zLCBuYW1lKSB7XG4gIGNvbnN0IHNjYWxlTmFtZSA9IFNjYWxlUHJlZml4ICsgbmFtZTtcblxuICBpZiAoIWhhc093blByb3BlcnR5KHBhcmFtcywgc2NhbGVOYW1lKSkge1xuICAgIHRyeSB7XG4gICAgICBwYXJhbXNbc2NhbGVOYW1lXSA9IHNjb3BlLnNjYWxlUmVmKG5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikgey8vIFRPRE86IGVycm9yIGhhbmRsaW5nPyB3YXJuaW5nP1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShuYW1lLCBjdHgpIHtcbiAgbGV0IHM7XG4gIHJldHVybiBpc0Z1bmN0aW9uKG5hbWUpID8gbmFtZSA6IGlzU3RyaW5nKG5hbWUpID8gKHMgPSBjdHguc2NhbGVzW25hbWVdKSAmJiBzLnZhbHVlIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaW50ZXJuYWxTY2FsZUZ1bmN0aW9ucyhjb2RlZ2VuLCBmbmN0eCwgdmlzaXRvcnMpIHtcbiAgLy8gYWRkIGhlbHBlciBtZXRob2QgdG8gdGhlICd0aGlzJyBleHByZXNzaW9uIGZ1bmN0aW9uIGNvbnRleHRcbiAgZm5jdHguX19iYW5kd2lkdGggPSBzID0+IHMgJiYgcy5iYW5kd2lkdGggPyBzLmJhbmR3aWR0aCgpIDogMDsgLy8gcmVnaXN0ZXIgQVNUIHZpc2l0b3JzIGZvciBpbnRlcm5hbCBzY2FsZSBmdW5jdGlvbnNcblxuXG4gIHZpc2l0b3JzLl9iYW5kd2lkdGggPSBzY2FsZVZpc2l0b3I7XG4gIHZpc2l0b3JzLl9yYW5nZSA9IHNjYWxlVmlzaXRvcjtcbiAgdmlzaXRvcnMuX3NjYWxlID0gc2NhbGVWaXNpdG9yOyAvLyByZXNvbHZlIHNjYWxlIHJlZmVyZW5jZSBkaXJlY3RseSB0byB0aGUgc2lnbmFsIGhhc2ggYXJndW1lbnRcblxuICBjb25zdCByZWYgPSBhcmcgPT4gJ19bJyArIChhcmcudHlwZSA9PT0gTGl0ZXJhbCA/IHN0cmluZ1ZhbHVlKFNjYWxlUHJlZml4ICsgYXJnLnZhbHVlKSA6IHN0cmluZ1ZhbHVlKFNjYWxlUHJlZml4KSArICcrJyArIGNvZGVnZW4oYXJnKSkgKyAnXSc7IC8vIGRlZmluZSBhbmQgcmV0dXJuIGludGVybmFsIHNjYWxlIGZ1bmN0aW9uIGNvZGUgZ2VuZXJhdG9yc1xuICAvLyB0aGVzZSBpbnRlcm5hbCBmdW5jdGlvbnMgYXJlIGNhbGxlZCBieSBtYXJrIGVuY29kZXJzXG5cblxuICByZXR1cm4ge1xuICAgIF9iYW5kd2lkdGg6IGFyZ3MgPT4gYHRoaXMuX19iYW5kd2lkdGgoJHtyZWYoYXJnc1swXSl9KWAsXG4gICAgX3JhbmdlOiBhcmdzID0+IGAke3JlZihhcmdzWzBdKX0ucmFuZ2UoKWAsXG4gICAgX3NjYWxlOiBhcmdzID0+IGAke3JlZihhcmdzWzBdKX0oJHtjb2RlZ2VuKGFyZ3NbMV0pfSlgXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdlb01ldGhvZChtZXRob2ROYW1lLCBnbG9iYWxNZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm9qZWN0aW9uLCBnZW9qc29uLCBncm91cCkge1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAvLyBwcm9qZWN0aW9uIGRlZmluZWQsIHVzZSBpdFxuICAgICAgY29uc3QgcCA9IGdldFNjYWxlKHByb2plY3Rpb24sIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgICAgIHJldHVybiBwICYmIHAucGF0aFttZXRob2ROYW1lXShnZW9qc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJvamVjdGlvbiB1bmRlZmluZWQsIHVzZSBnbG9iYWwgbWV0aG9kXG4gICAgICByZXR1cm4gZ2xvYmFsTWV0aG9kKGdlb2pzb24pO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgZ2VvQXJlYSA9IGdlb01ldGhvZCgnYXJlYScsIGdlb0FyZWEkMSk7XG5jb25zdCBnZW9Cb3VuZHMgPSBnZW9NZXRob2QoJ2JvdW5kcycsIGdlb0JvdW5kcyQxKTtcbmNvbnN0IGdlb0NlbnRyb2lkID0gZ2VvTWV0aG9kKCdjZW50cm9pZCcsIGdlb0NlbnRyb2lkJDEpO1xuXG5mdW5jdGlvbiBpblNjb3BlIChpdGVtKSB7XG4gIGNvbnN0IGdyb3VwID0gdGhpcy5jb250ZXh0Lmdyb3VwO1xuICBsZXQgdmFsdWUgPSBmYWxzZTtcbiAgaWYgKGdyb3VwKSB3aGlsZSAoaXRlbSkge1xuICAgIGlmIChpdGVtID09PSBncm91cCkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaXRlbSA9IGl0ZW0ubWFyay5ncm91cDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGxvZyhkZiwgbWV0aG9kLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgZGZbbWV0aG9kXS5hcHBseShkZiwgWydFWFBSRVNTSU9OJ10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGYud2FybihlcnIpO1xuICB9XG5cbiAgcmV0dXJuIGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbn1cblxuZnVuY3Rpb24gd2FybigpIHtcbiAgcmV0dXJuIGxvZyh0aGlzLmNvbnRleHQuZGF0YWZsb3csICd3YXJuJywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGluZm8oKSB7XG4gIHJldHVybiBsb2codGhpcy5jb250ZXh0LmRhdGFmbG93LCAnaW5mbycsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBkZWJ1ZygpIHtcbiAgcmV0dXJuIGxvZyh0aGlzLmNvbnRleHQuZGF0YWZsb3csICdkZWJ1ZycsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNoYW5uZWxfbHVtaW5hbmNlX3ZhbHVlKGNoYW5uZWxWYWx1ZSkge1xuICBjb25zdCB2YWwgPSBjaGFubmVsVmFsdWUgLyAyNTU7XG5cbiAgaWYgKHZhbCA8PSAwLjAzOTI4KSB7XG4gICAgcmV0dXJuIHZhbCAvIDEyLjkyO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgucG93KCh2YWwgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gbHVtaW5hbmNlKGNvbG9yKSB7XG4gIGNvbnN0IGMgPSByZ2IoY29sb3IpLFxuICAgICAgICByID0gY2hhbm5lbF9sdW1pbmFuY2VfdmFsdWUoYy5yKSxcbiAgICAgICAgZyA9IGNoYW5uZWxfbHVtaW5hbmNlX3ZhbHVlKGMuZyksXG4gICAgICAgIGIgPSBjaGFubmVsX2x1bWluYW5jZV92YWx1ZShjLmIpO1xuICByZXR1cm4gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xufSAvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNjb250cmFzdC1yYXRpb2RlZlxuXG5mdW5jdGlvbiBjb250cmFzdChjb2xvcjEsIGNvbG9yMikge1xuICBjb25zdCBsdW0xID0gbHVtaW5hbmNlKGNvbG9yMSksXG4gICAgICAgIGx1bTIgPSBsdW1pbmFuY2UoY29sb3IyKSxcbiAgICAgICAgbHVtTCA9IE1hdGgubWF4KGx1bTEsIGx1bTIpLFxuICAgICAgICBsdW1EID0gTWF0aC5taW4obHVtMSwgbHVtMik7XG4gIHJldHVybiAobHVtTCArIDAuMDUpIC8gKGx1bUQgKyAwLjA1KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UgKCkge1xuICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoe30pO1xuICByZXR1cm4gZXh0ZW5kKC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IGEgIT09IGEgJiYgYiAhPT0gYiA/IHRydWUgOiBpc0FycmF5KGEpID8gaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggPyBlcXVhbEFycmF5KGEsIGIpIDogZmFsc2UgOiBpc09iamVjdChhKSAmJiBpc09iamVjdChiKSA/IGVxdWFsT2JqZWN0KGEsIGIpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGVxdWFsQXJyYXkoYSwgYikge1xuICBmb3IgKGxldCBpID0gMCwgbiA9IGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0KGEsIGIpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUHJlZGljYXRlKHByb3BzKSB7XG4gIHJldHVybiBfID0+IGVxdWFsT2JqZWN0KHByb3BzLCBfKTtcbn1cblxuZnVuY3Rpb24gbW9kaWZ5IChuYW1lLCBpbnNlcnQsIHJlbW92ZSwgdG9nZ2xlLCBtb2RpZnksIHZhbHVlcykge1xuICBjb25zdCBkZiA9IHRoaXMuY29udGV4dC5kYXRhZmxvdyxcbiAgICAgICAgZGF0YSA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdLFxuICAgICAgICBpbnB1dCA9IGRhdGEuaW5wdXQsXG4gICAgICAgIHN0YW1wID0gZGYuc3RhbXAoKTtcbiAgbGV0IGNoYW5nZXMgPSBkYXRhLmNoYW5nZXMsXG4gICAgICBwcmVkaWNhdGUsXG4gICAgICBrZXk7XG5cbiAgaWYgKGRmLl90cmlnZ2VyID09PSBmYWxzZSB8fCAhKGlucHV0LnZhbHVlLmxlbmd0aCB8fCBpbnNlcnQgfHwgdG9nZ2xlKSkge1xuICAgIC8vIG5vdGhpbmcgdG8gZG8hXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoIWNoYW5nZXMgfHwgY2hhbmdlcy5zdGFtcCA8IHN0YW1wKSB7XG4gICAgZGF0YS5jaGFuZ2VzID0gY2hhbmdlcyA9IGRmLmNoYW5nZXNldCgpO1xuICAgIGNoYW5nZXMuc3RhbXAgPSBzdGFtcDtcbiAgICBkZi5ydW5BZnRlcigoKSA9PiB7XG4gICAgICBkYXRhLm1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIGRmLnB1bHNlKGlucHV0LCBjaGFuZ2VzKS5ydW4oKTtcbiAgICB9LCB0cnVlLCAxKTtcbiAgfVxuXG4gIGlmIChyZW1vdmUpIHtcbiAgICBwcmVkaWNhdGUgPSByZW1vdmUgPT09IHRydWUgPyB0cnV0aHkgOiBpc0FycmF5KHJlbW92ZSkgfHwgaXNUdXBsZShyZW1vdmUpID8gcmVtb3ZlIDogcmVtb3ZlUHJlZGljYXRlKHJlbW92ZSk7XG4gICAgY2hhbmdlcy5yZW1vdmUocHJlZGljYXRlKTtcbiAgfVxuXG4gIGlmIChpbnNlcnQpIHtcbiAgICBjaGFuZ2VzLmluc2VydChpbnNlcnQpO1xuICB9XG5cbiAgaWYgKHRvZ2dsZSkge1xuICAgIHByZWRpY2F0ZSA9IHJlbW92ZVByZWRpY2F0ZSh0b2dnbGUpO1xuXG4gICAgaWYgKGlucHV0LnZhbHVlLnNvbWUocHJlZGljYXRlKSkge1xuICAgICAgY2hhbmdlcy5yZW1vdmUocHJlZGljYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlcy5pbnNlcnQodG9nZ2xlKTtcbiAgICB9XG4gIH1cblxuICBpZiAobW9kaWZ5KSB7XG4gICAgZm9yIChrZXkgaW4gdmFsdWVzKSB7XG4gICAgICBjaGFuZ2VzLm1vZGlmeShtb2RpZnksIGtleSwgdmFsdWVzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAxO1xufVxuXG5mdW5jdGlvbiBwaW5jaERpc3RhbmNlKGV2ZW50KSB7XG4gIGNvbnN0IHQgPSBldmVudC50b3VjaGVzLFxuICAgICAgICBkeCA9IHRbMF0uY2xpZW50WCAtIHRbMV0uY2xpZW50WCxcbiAgICAgICAgZHkgPSB0WzBdLmNsaWVudFkgLSB0WzFdLmNsaWVudFk7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufVxuZnVuY3Rpb24gcGluY2hBbmdsZShldmVudCkge1xuICBjb25zdCB0ID0gZXZlbnQudG91Y2hlcztcbiAgcmV0dXJuIE1hdGguYXRhbjIodFswXS5jbGllbnRZIC0gdFsxXS5jbGllbnRZLCB0WzBdLmNsaWVudFggLSB0WzFdLmNsaWVudFgpO1xufVxuXG5jb25zdCBhY2Nlc3NvcnMgPSB7fTtcbmZ1bmN0aW9uIHBsdWNrIChkYXRhLCBuYW1lKSB7XG4gIGNvbnN0IGFjY2Vzc29yID0gYWNjZXNzb3JzW25hbWVdIHx8IChhY2Nlc3NvcnNbbmFtZV0gPSBmaWVsZChuYW1lKSk7XG4gIHJldHVybiBpc0FycmF5KGRhdGEpID8gZGF0YS5tYXAoYWNjZXNzb3IpIDogYWNjZXNzb3IoZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGFycmF5KHNlcSkge1xuICByZXR1cm4gaXNBcnJheShzZXEpIHx8IEFycmF5QnVmZmVyLmlzVmlldyhzZXEpID8gc2VxIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gc2VxdWVuY2Uoc2VxKSB7XG4gIHJldHVybiBhcnJheShzZXEpIHx8IChpc1N0cmluZyhzZXEpID8gc2VxIDogbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGpvaW4oc2VxLCAuLi5hcmdzKSB7XG4gIHJldHVybiBhcnJheShzZXEpLmpvaW4oLi4uYXJncyk7XG59XG5mdW5jdGlvbiBpbmRleG9mKHNlcSwgLi4uYXJncykge1xuICByZXR1cm4gc2VxdWVuY2Uoc2VxKS5pbmRleE9mKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gbGFzdGluZGV4b2Yoc2VxLCAuLi5hcmdzKSB7XG4gIHJldHVybiBzZXF1ZW5jZShzZXEpLmxhc3RJbmRleE9mKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gc2xpY2Uoc2VxLCAuLi5hcmdzKSB7XG4gIHJldHVybiBzZXF1ZW5jZShzZXEpLnNsaWNlKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gcmVwbGFjZShzdHIsIHBhdHRlcm4sIHJlcGwpIHtcbiAgaWYgKGlzRnVuY3Rpb24ocmVwbCkpIGVycm9yKCdGdW5jdGlvbiBhcmd1bWVudCBwYXNzZWQgdG8gcmVwbGFjZS4nKTtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocGF0dGVybiwgcmVwbCk7XG59XG5mdW5jdGlvbiByZXZlcnNlKHNlcSkge1xuICByZXR1cm4gYXJyYXkoc2VxKS5zbGljZSgpLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gYmFuZHNwYWNlKGNvdW50LCBwYWRkaW5nSW5uZXIsIHBhZGRpbmdPdXRlcikge1xuICByZXR1cm4gYmFuZFNwYWNlKGNvdW50IHx8IDAsIHBhZGRpbmdJbm5lciB8fCAwLCBwYWRkaW5nT3V0ZXIgfHwgMCk7XG59XG5mdW5jdGlvbiBiYW5kd2lkdGgobmFtZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuIHMgJiYgcy5iYW5kd2lkdGggPyBzLmJhbmR3aWR0aCgpIDogMDtcbn1cbmZ1bmN0aW9uIGNvcHkobmFtZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuIHMgPyBzLmNvcHkoKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGRvbWFpbihuYW1lLCBncm91cCkge1xuICBjb25zdCBzID0gZ2V0U2NhbGUobmFtZSwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gcyA/IHMuZG9tYWluKCkgOiBbXTtcbn1cbmZ1bmN0aW9uIGludmVydChuYW1lLCByYW5nZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuICFzID8gdW5kZWZpbmVkIDogaXNBcnJheShyYW5nZSkgPyAocy5pbnZlcnRSYW5nZSB8fCBzLmludmVydCkocmFuZ2UpIDogKHMuaW52ZXJ0IHx8IHMuaW52ZXJ0RXh0ZW50KShyYW5nZSk7XG59XG5mdW5jdGlvbiByYW5nZShuYW1lLCBncm91cCkge1xuICBjb25zdCBzID0gZ2V0U2NhbGUobmFtZSwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gcyAmJiBzLnJhbmdlID8gcy5yYW5nZSgpIDogW107XG59XG5mdW5jdGlvbiBzY2FsZShuYW1lLCB2YWx1ZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuIHMgPyBzKHZhbHVlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2NhbGVHcmFkaWVudCAoc2NhbGUsIHAwLCBwMSwgY291bnQsIGdyb3VwKSB7XG4gIHNjYWxlID0gZ2V0U2NhbGUoc2NhbGUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgY29uc3QgZ3JhZGllbnQgPSBHcmFkaWVudChwMCwgcDEpO1xuICBsZXQgc3RvcHMgPSBzY2FsZS5kb21haW4oKSxcbiAgICAgIG1pbiA9IHN0b3BzWzBdLFxuICAgICAgbWF4ID0gcGVlayhzdG9wcyksXG4gICAgICBmcmFjdGlvbiA9IGlkZW50aXR5O1xuXG4gIGlmICghKG1heCAtIG1pbikpIHtcbiAgICAvLyBleHBhbmQgc2NhbGUgaWYgZG9tYWluIGhhcyB6ZXJvIHNwYW4sIGZpeCAjMTQ3OVxuICAgIHNjYWxlID0gKHNjYWxlLmludGVycG9sYXRvciA/IHNjYWxlJDEoJ3NlcXVlbnRpYWwnKSgpLmludGVycG9sYXRvcihzY2FsZS5pbnRlcnBvbGF0b3IoKSkgOiBzY2FsZSQxKCdsaW5lYXInKSgpLmludGVycG9sYXRlKHNjYWxlLmludGVycG9sYXRlKCkpLnJhbmdlKHNjYWxlLnJhbmdlKCkpKS5kb21haW4oW21pbiA9IDAsIG1heCA9IDFdKTtcbiAgfSBlbHNlIHtcbiAgICBmcmFjdGlvbiA9IHNjYWxlRnJhY3Rpb24oc2NhbGUsIG1pbiwgbWF4KTtcbiAgfVxuXG4gIGlmIChzY2FsZS50aWNrcykge1xuICAgIHN0b3BzID0gc2NhbGUudGlja3MoK2NvdW50IHx8IDE1KTtcbiAgICBpZiAobWluICE9PSBzdG9wc1swXSkgc3RvcHMudW5zaGlmdChtaW4pO1xuICAgIGlmIChtYXggIT09IHBlZWsoc3RvcHMpKSBzdG9wcy5wdXNoKG1heCk7XG4gIH1cblxuICBzdG9wcy5mb3JFYWNoKF8gPT4gZ3JhZGllbnQuc3RvcChmcmFjdGlvbihfKSwgc2NhbGUoXykpKTtcbiAgcmV0dXJuIGdyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBnZW9TaGFwZShwcm9qZWN0aW9uLCBnZW9qc29uLCBncm91cCkge1xuICBjb25zdCBwID0gZ2V0U2NhbGUocHJvamVjdGlvbiwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gcCA/IHAucGF0aC5jb250ZXh0KGNvbnRleHQpKGdlb2pzb24pIDogJyc7XG4gIH07XG59XG5mdW5jdGlvbiBwYXRoU2hhcGUocGF0aCkge1xuICBsZXQgcCA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0ID8gcGF0aFJlbmRlcihjb250ZXh0LCBwID0gcCB8fCBwYXRoUGFyc2UocGF0aCkpIDogcGF0aDtcbiAgfTtcbn1cblxuY29uc3QgZGF0dW0gPSBkID0+IGQuZGF0YTtcblxuZnVuY3Rpb24gdHJlZU5vZGVzKG5hbWUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHJlZSA9IGRhdGEuY2FsbChjb250ZXh0LCBuYW1lKTtcbiAgcmV0dXJuIHRyZWUucm9vdCAmJiB0cmVlLnJvb3QubG9va3VwIHx8IHt9O1xufVxuXG5mdW5jdGlvbiB0cmVlUGF0aChuYW1lLCBzb3VyY2UsIHRhcmdldCkge1xuICBjb25zdCBub2RlcyA9IHRyZWVOb2RlcyhuYW1lLCB0aGlzKSxcbiAgICAgICAgcyA9IG5vZGVzW3NvdXJjZV0sXG4gICAgICAgIHQgPSBub2Rlc1t0YXJnZXRdO1xuICByZXR1cm4gcyAmJiB0ID8gcy5wYXRoKHQpLm1hcChkYXR1bSkgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0cmVlQW5jZXN0b3JzKG5hbWUsIG5vZGUpIHtcbiAgY29uc3QgbiA9IHRyZWVOb2RlcyhuYW1lLCB0aGlzKVtub2RlXTtcbiAgcmV0dXJuIG4gPyBuLmFuY2VzdG9ycygpLm1hcChkYXR1bSkgOiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IF93aW5kb3cgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgfHwgbnVsbDtcblxuZnVuY3Rpb24gc2NyZWVuKCkge1xuICBjb25zdCB3ID0gX3dpbmRvdygpO1xuXG4gIHJldHVybiB3ID8gdy5zY3JlZW4gOiB7fTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1NpemUoKSB7XG4gIGNvbnN0IHcgPSBfd2luZG93KCk7XG5cbiAgcmV0dXJuIHcgPyBbdy5pbm5lcldpZHRoLCB3LmlubmVySGVpZ2h0XSA6IFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBjb250YWluZXJTaXplKCkge1xuICBjb25zdCB2aWV3ID0gdGhpcy5jb250ZXh0LmRhdGFmbG93LFxuICAgICAgICBlbCA9IHZpZXcuY29udGFpbmVyICYmIHZpZXcuY29udGFpbmVyKCk7XG4gIHJldHVybiBlbCA/IFtlbC5jbGllbnRXaWR0aCwgZWwuY2xpZW50SGVpZ2h0XSA6IFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCAoYiwgb3B0LCBncm91cCkge1xuICBpZiAoIWIpIHJldHVybiBbXTtcbiAgY29uc3QgW3UsIHZdID0gYixcbiAgICAgICAgYm94ID0gbmV3IEJvdW5kcygpLnNldCh1WzBdLCB1WzFdLCB2WzBdLCB2WzFdKSxcbiAgICAgICAgc2NlbmUgPSBncm91cCB8fCB0aGlzLmNvbnRleHQuZGF0YWZsb3cuc2NlbmVncmFwaCgpLnJvb3Q7XG4gIHJldHVybiBpbnRlcnNlY3QkMShzY2VuZSwgYm94LCBmaWx0ZXIob3B0KSk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlcihvcHQpIHtcbiAgbGV0IHAgPSBudWxsO1xuXG4gIGlmIChvcHQpIHtcbiAgICBjb25zdCB0eXBlcyA9IGFycmF5JDEob3B0Lm1hcmt0eXBlKSxcbiAgICAgICAgICBuYW1lcyA9IGFycmF5JDEob3B0Lm1hcmtuYW1lKTtcblxuICAgIHAgPSBfID0+ICghdHlwZXMubGVuZ3RoIHx8IHR5cGVzLnNvbWUodCA9PiBfLm1hcmt0eXBlID09PSB0KSkgJiYgKCFuYW1lcy5sZW5ndGggfHwgbmFtZXMuc29tZShzID0+IF8ubmFtZSA9PT0gcykpO1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IHtcbiAgcmFuZG9tKCkge1xuICAgIHJldHVybiByYW5kb20oKTtcbiAgfSxcblxuICAvLyBvdmVycmlkZSBkZWZhdWx0XG4gIGN1bXVsYXRpdmVOb3JtYWwsXG4gIGN1bXVsYXRpdmVMb2dOb3JtYWwsXG4gIGN1bXVsYXRpdmVVbmlmb3JtLFxuICBkZW5zaXR5Tm9ybWFsLFxuICBkZW5zaXR5TG9nTm9ybWFsLFxuICBkZW5zaXR5VW5pZm9ybSxcbiAgcXVhbnRpbGVOb3JtYWwsXG4gIHF1YW50aWxlTG9nTm9ybWFsLFxuICBxdWFudGlsZVVuaWZvcm0sXG4gIHNhbXBsZU5vcm1hbCxcbiAgc2FtcGxlTG9nTm9ybWFsLFxuICBzYW1wbGVVbmlmb3JtLFxuICBpc0FycmF5LFxuICBpc0Jvb2xlYW4sXG4gIGlzRGF0ZSxcblxuICBpc0RlZmluZWQoXykge1xuICAgIHJldHVybiBfICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgaXNOdW1iZXIsXG4gIGlzT2JqZWN0LFxuICBpc1JlZ0V4cCxcbiAgaXNTdHJpbmcsXG4gIGlzVHVwbGUsXG5cbiAgaXNWYWxpZChfKSB7XG4gICAgcmV0dXJuIF8gIT0gbnVsbCAmJiBfID09PSBfO1xuICB9LFxuXG4gIHRvQm9vbGVhbixcbiAgdG9EYXRlLFxuICB0b051bWJlcixcbiAgdG9TdHJpbmcsXG4gIGluZGV4b2YsXG4gIGpvaW4sXG4gIGxhc3RpbmRleG9mLFxuICByZXBsYWNlLFxuICByZXZlcnNlLFxuICBzbGljZSxcbiAgZmx1c2gsXG4gIGxlcnAsXG4gIG1lcmdlLFxuICBwYWQsXG4gIHBlZWssXG4gIHBsdWNrLFxuICBzcGFuLFxuICBpbnJhbmdlLFxuICB0cnVuY2F0ZSxcbiAgcmdiLFxuICBsYWIsXG4gIGhjbCxcbiAgaHNsLFxuICBsdW1pbmFuY2UsXG4gIGNvbnRyYXN0LFxuICBzZXF1ZW5jZTogcmFuZ2UkMSxcbiAgZm9ybWF0LFxuICB1dGNGb3JtYXQsXG4gIHV0Y1BhcnNlLFxuICB1dGNPZmZzZXQsXG4gIHV0Y1NlcXVlbmNlLFxuICB0aW1lRm9ybWF0LFxuICB0aW1lUGFyc2UsXG4gIHRpbWVPZmZzZXQsXG4gIHRpbWVTZXF1ZW5jZSxcbiAgdGltZVVuaXRTcGVjaWZpZXIsXG4gIG1vbnRoRm9ybWF0LFxuICBtb250aEFiYnJldkZvcm1hdCxcbiAgZGF5Rm9ybWF0LFxuICBkYXlBYmJyZXZGb3JtYXQsXG4gIHF1YXJ0ZXIsXG4gIHV0Y3F1YXJ0ZXIsXG4gIHdlZWssXG4gIHV0Y3dlZWssXG4gIGRheW9meWVhcixcbiAgdXRjZGF5b2Z5ZWFyLFxuICB3YXJuLFxuICBpbmZvLFxuICBkZWJ1ZyxcbiAgZXh0ZW50LFxuICBpblNjb3BlLFxuICBpbnRlcnNlY3QsXG4gIGNsYW1wUmFuZ2UsXG4gIHBpbmNoRGlzdGFuY2UsXG4gIHBpbmNoQW5nbGUsXG4gIHNjcmVlbixcbiAgY29udGFpbmVyU2l6ZSxcbiAgd2luZG93U2l6ZSxcbiAgYmFuZHNwYWNlLFxuICBzZXRkYXRhLFxuICBwYXRoU2hhcGUsXG4gIHBhbkxpbmVhcixcbiAgcGFuTG9nLFxuICBwYW5Qb3csXG4gIHBhblN5bWxvZyxcbiAgem9vbUxpbmVhcixcbiAgem9vbUxvZyxcbiAgem9vbVBvdyxcbiAgem9vbVN5bWxvZyxcbiAgZW5jb2RlLFxuICBtb2RpZnlcbn07XG5jb25zdCBldmVudEZ1bmN0aW9ucyA9IFsndmlldycsICdpdGVtJywgJ2dyb3VwJywgJ3h5JywgJ3gnLCAneSddLFxuICAgICAgLy8gZXZlbnQgZnVuY3Rpb25zXG5ldmVudFByZWZpeCA9ICdldmVudC52ZWdhLicsXG4gICAgICAvLyBldmVudCBmdW5jdGlvbiBwcmVmaXhcbnRoaXNQcmVmaXggPSAndGhpcy4nLFxuICAgICAgLy8gZnVuY3Rpb24gY29udGV4dCBwcmVmaXhcbmFzdFZpc2l0b3JzID0ge307IC8vIEFTVCB2aXNpdG9ycyBmb3IgZGVwZW5kZW5jeSBhbmFseXNpc1xuLy8gZXhwb3J0IGNvZGUgZ2VuZXJhdG9yIHBhcmFtZXRlcnNcblxuY29uc3QgY29kZWdlblBhcmFtcyA9IHtcbiAgZm9yYmlkZGVuOiBbJ18nXSxcbiAgYWxsb3dlZDogWydkYXR1bScsICdldmVudCcsICdpdGVtJ10sXG4gIGZpZWxkdmFyOiAnZGF0dW0nLFxuICBnbG9iYWx2YXI6IGlkID0+IGBfWyR7c3RyaW5nVmFsdWUoU2lnbmFsUHJlZml4ICsgaWQpfV1gLFxuICBmdW5jdGlvbnM6IGJ1aWxkRnVuY3Rpb25zLFxuICBjb25zdGFudHM6IGNvbnN0YW50cyxcbiAgdmlzaXRvcnM6IGFzdFZpc2l0b3JzXG59OyAvLyBleHBvcnQgY29kZSBnZW5lcmF0b3JcblxuY29uc3QgY29kZUdlbmVyYXRvciA9IGNvZGVnZW5FeHByZXNzaW9uKGNvZGVnZW5QYXJhbXMpOyAvLyBCdWlsZCBleHByZXNzaW9uIGZ1bmN0aW9uIHJlZ2lzdHJ5XG5cbmZ1bmN0aW9uIGJ1aWxkRnVuY3Rpb25zKGNvZGVnZW4pIHtcbiAgY29uc3QgZm4gPSBmdW5jdGlvbnMoY29kZWdlbik7XG4gIGV2ZW50RnVuY3Rpb25zLmZvckVhY2gobmFtZSA9PiBmbltuYW1lXSA9IGV2ZW50UHJlZml4ICsgbmFtZSk7XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGZ1bmN0aW9uQ29udGV4dCkge1xuICAgIGZuW25hbWVdID0gdGhpc1ByZWZpeCArIG5hbWU7XG4gIH1cblxuICBleHRlbmQoZm4sIGludGVybmFsU2NhbGVGdW5jdGlvbnMoY29kZWdlbiwgZnVuY3Rpb25Db250ZXh0LCBhc3RWaXNpdG9ycykpO1xuICByZXR1cm4gZm47XG59IC8vIFJlZ2lzdGVyIGFuIGV4cHJlc3Npb24gZnVuY3Rpb25cblxuXG5mdW5jdGlvbiBleHByZXNzaW9uRnVuY3Rpb24obmFtZSwgZm4sIHZpc2l0b3IpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Db250ZXh0W25hbWVdO1xuICB9IC8vIHJlZ2lzdGVyIHdpdGggdGhlIGZ1bmN0aW9uQ29udGV4dFxuXG5cbiAgZnVuY3Rpb25Db250ZXh0W25hbWVdID0gZm47IC8vIGlmIHRoZXJlIGlzIGFuIGFzdFZpc2l0b3IgcmVnaXN0ZXIgdGhhdCwgdG9vXG5cbiAgaWYgKHZpc2l0b3IpIGFzdFZpc2l0b3JzW25hbWVdID0gdmlzaXRvcjsgLy8gaWYgdGhlIGNvZGUgZ2VuZXJhdG9yIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQsXG4gIC8vIHdlIG5lZWQgdG8gYWxzbyByZWdpc3RlciB0aGUgZnVuY3Rpb24gd2l0aCBpdFxuXG4gIGlmIChjb2RlR2VuZXJhdG9yKSBjb2RlR2VuZXJhdG9yLmZ1bmN0aW9uc1tuYW1lXSA9IHRoaXNQcmVmaXggKyBuYW1lO1xuICByZXR1cm4gdGhpcztcbn0gLy8gcmVnaXN0ZXIgZXhwcmVzc2lvbiBmdW5jdGlvbnMgd2l0aCBhc3QgdmlzaXRvcnNcblxuZXhwcmVzc2lvbkZ1bmN0aW9uKCdiYW5kd2lkdGgnLCBiYW5kd2lkdGgsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2NvcHknLCBjb3B5LCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdkb21haW4nLCBkb21haW4sIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3JhbmdlJywgcmFuZ2UsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2ludmVydCcsIGludmVydCwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignc2NhbGUnLCBzY2FsZSwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignZ3JhZGllbnQnLCBzY2FsZUdyYWRpZW50LCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9BcmVhJywgZ2VvQXJlYSwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignZ2VvQm91bmRzJywgZ2VvQm91bmRzLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9DZW50cm9pZCcsIGdlb0NlbnRyb2lkLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9TaGFwZScsIGdlb1NoYXBlLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdpbmRhdGEnLCBpbmRhdGEsIGluZGF0YVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdkYXRhJywgZGF0YSwgZGF0YVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCd0cmVlUGF0aCcsIHRyZWVQYXRoLCBkYXRhVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3RyZWVBbmNlc3RvcnMnLCB0cmVlQW5jZXN0b3JzLCBkYXRhVmlzaXRvcik7IC8vIHJlZ2lzdGVyIFZlZ2EtTGl0ZSBzZWxlY3Rpb24gZnVuY3Rpb25zXG5cbmV4cHJlc3Npb25GdW5jdGlvbigndmxTZWxlY3Rpb25UZXN0Jywgc2VsZWN0aW9uVGVzdCwgc2VsZWN0aW9uVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3ZsU2VsZWN0aW9uSWRUZXN0Jywgc2VsZWN0aW9uSWRUZXN0LCBzZWxlY3Rpb25WaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbigndmxTZWxlY3Rpb25SZXNvbHZlJywgc2VsZWN0aW9uUmVzb2x2ZSwgc2VsZWN0aW9uVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3ZsU2VsZWN0aW9uVHVwbGVzJywgc2VsZWN0aW9uVHVwbGVzKTtcblxuZnVuY3Rpb24gcGFyc2VyIChleHByLCBzY29wZSkge1xuICBjb25zdCBwYXJhbXMgPSB7fTsgLy8gcGFyc2UgdGhlIGV4cHJlc3Npb24gdG8gYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgKGFzdClcblxuICBsZXQgYXN0O1xuXG4gIHRyeSB7XG4gICAgZXhwciA9IGlzU3RyaW5nKGV4cHIpID8gZXhwciA6IHN0cmluZ1ZhbHVlKGV4cHIpICsgJyc7XG4gICAgYXN0ID0gcGFyc2VFeHByZXNzaW9uKGV4cHIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcignRXhwcmVzc2lvbiBwYXJzZSBlcnJvcjogJyArIGV4cHIpO1xuICB9IC8vIGFuYWx5emUgYXN0IGZ1bmN0aW9uIGNhbGxzIGZvciBkZXBlbmRlbmNpZXNcblxuXG4gIGFzdC52aXNpdChub2RlID0+IHtcbiAgICBpZiAobm9kZS50eXBlICE9PSBDYWxsRXhwcmVzc2lvbikgcmV0dXJuO1xuICAgIGNvbnN0IG5hbWUgPSBub2RlLmNhbGxlZS5uYW1lLFxuICAgICAgICAgIHZpc2l0ID0gY29kZWdlblBhcmFtcy52aXNpdG9yc1tuYW1lXTtcbiAgICBpZiAodmlzaXQpIHZpc2l0KG5hbWUsIG5vZGUuYXJndW1lbnRzLCBzY29wZSwgcGFyYW1zKTtcbiAgfSk7IC8vIHBlcmZvcm0gY29kZSBnZW5lcmF0aW9uXG5cbiAgY29uc3QgZ2VuID0gY29kZUdlbmVyYXRvcihhc3QpOyAvLyBjb2xsZWN0IHNpZ25hbCBkZXBlbmRlbmNpZXNcblxuICBnZW4uZ2xvYmFscy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IHNpZ25hbE5hbWUgPSBTaWduYWxQcmVmaXggKyBuYW1lO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShwYXJhbXMsIHNpZ25hbE5hbWUpICYmIHNjb3BlLmdldFNpZ25hbChuYW1lKSkge1xuICAgICAgcGFyYW1zW3NpZ25hbE5hbWVdID0gc2NvcGUuc2lnbmFsUmVmKG5hbWUpO1xuICAgIH1cbiAgfSk7IC8vIHJldHVybiBnZW5lcmF0ZWQgZXhwcmVzc2lvbiBjb2RlIGFuZCBkZXBlbmRlbmNpZXNcblxuICByZXR1cm4ge1xuICAgICRleHByOiBleHRlbmQoe1xuICAgICAgY29kZTogZ2VuLmNvZGVcbiAgICB9LCBzY29wZS5vcHRpb25zLmFzdCA/IHtcbiAgICAgIGFzdFxuICAgIH0gOiBudWxsKSxcbiAgICAkZmllbGRzOiBnZW4uZmllbGRzLFxuICAgICRwYXJhbXM6IHBhcmFtc1xuICB9O1xufVxuXG5leHBvcnQgeyBEYXRhUHJlZml4LCBJbmRleFByZWZpeCwgU2NhbGVQcmVmaXgsIFNpZ25hbFByZWZpeCwgYmFuZHNwYWNlLCBiYW5kd2lkdGgsIGNvZGVHZW5lcmF0b3IsIGNvZGVnZW5QYXJhbXMsIGNvbnRhaW5lclNpemUsIGNvbnRyYXN0LCBjb3B5LCBkYXRhLCBkYXRhVmlzaXRvciwgZGF5QWJicmV2Rm9ybWF0LCBkYXlGb3JtYXQsIGRlYnVnLCBkb21haW4sIGVuY29kZSwgZXhwcmVzc2lvbkZ1bmN0aW9uLCBmb3JtYXQsIGZ1bmN0aW9uQ29udGV4dCwgZ2VvQXJlYSwgZ2VvQm91bmRzLCBnZW9DZW50cm9pZCwgZ2VvU2hhcGUsIGluU2NvcGUsIGluZGF0YSwgaW5kYXRhVmlzaXRvciwgaW5kZXhvZiwgaW5mbywgaW52ZXJ0LCBqb2luLCBsYXN0aW5kZXhvZiwgbHVtaW5hbmNlLCBtZXJnZSwgbW9kaWZ5LCBtb250aEFiYnJldkZvcm1hdCwgbW9udGhGb3JtYXQsIHBhcnNlciBhcyBwYXJzZUV4cHJlc3Npb24sIHBhdGhTaGFwZSwgcGluY2hBbmdsZSwgcGluY2hEaXN0YW5jZSwgcGx1Y2ssIHJhbmdlLCByZXBsYWNlLCByZXZlcnNlLCBzY2FsZSwgc2NhbGVHcmFkaWVudCwgc2NhbGVWaXNpdG9yLCBzY3JlZW4sIHNldGRhdGEsIHNsaWNlLCB0aW1lRm9ybWF0LCB0aW1lUGFyc2UsIHRyZWVBbmNlc3RvcnMsIHRyZWVQYXRoLCB1dGNGb3JtYXQsIHV0Y1BhcnNlLCB3YXJuLCB3aW5kb3dTaXplIH07XG4iLCJpbXBvcnQgeyBUcmFuc2Zvcm0sIHJlZGVyaXZlLCBpbmdlc3QsIHJlcGxhY2UgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGVycm9yLCBleHRlbnQsIGluaGVyaXRzLCBpZGVudGl0eSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGNvbnN0YW50LCBhcnJheSwgb25lLCBhY2Nlc3Nvck5hbWUsIGFjY2Vzc29yRmllbGRzLCBmaWVsZCwgZXh0ZW5kLCB0b1NldCwgemVybyB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyByYW5nZSwgdGlja1N0ZXAsIG1heCwgc3VtIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgYmFuZHdpZHRoTlJEIH0gZnJvbSAndmVnYS1zdGF0aXN0aWNzJztcbmltcG9ydCB7IGdldFByb2plY3Rpb25QYXRoLCBwcm9qZWN0aW9uUHJvcGVydGllcywgcHJvamVjdGlvbiB9IGZyb20gJ3ZlZ2EtcHJvamVjdGlvbic7XG5pbXBvcnQgeyBnZW9HcmF0aWN1bGUgfSBmcm9tICdkMy1nZW8nO1xuaW1wb3J0IHsgcmdiIH0gZnJvbSAnZDMtY29sb3InO1xuaW1wb3J0IHsgY2FudmFzIH0gZnJvbSAndmVnYS1jYW52YXMnO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuY29uc3QgY2FzZXMgPSBbW10sIFtbWzEuMCwgMS41XSwgWzAuNSwgMS4wXV1dLCBbW1sxLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSwgW1tbMS41LCAxLjBdLCBbMC41LCAxLjBdXV0sIFtbWzEuMCwgMC41XSwgWzEuNSwgMS4wXV1dLCBbW1sxLjAsIDEuNV0sIFswLjUsIDEuMF1dLCBbWzEuMCwgMC41XSwgWzEuNSwgMS4wXV1dLCBbW1sxLjAsIDAuNV0sIFsxLjAsIDEuNV1dXSwgW1tbMS4wLCAwLjVdLCBbMC41LCAxLjBdXV0sIFtbWzAuNSwgMS4wXSwgWzEuMCwgMC41XV1dLCBbW1sxLjAsIDEuNV0sIFsxLjAsIDAuNV1dXSwgW1tbMC41LCAxLjBdLCBbMS4wLCAwLjVdXSwgW1sxLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSwgW1tbMS41LCAxLjBdLCBbMS4wLCAwLjVdXV0sIFtbWzAuNSwgMS4wXSwgWzEuNSwgMS4wXV1dLCBbW1sxLjAsIDEuNV0sIFsxLjUsIDEuMF1dXSwgW1tbMC41LCAxLjBdLCBbMS4wLCAxLjVdXV0sIFtdXTsgLy8gSW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tIGQzL2QzLWNvbnRvdXIuIFRoYW5rcyFcblxuZnVuY3Rpb24gY29udG91cnMgKCkge1xuICB2YXIgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgc21vb3RoID0gc21vb3RoTGluZWFyO1xuXG4gIGZ1bmN0aW9uIGNvbnRvdXJzKHZhbHVlcywgdHopIHtcbiAgICByZXR1cm4gdHoubWFwKHZhbHVlID0+IGNvbnRvdXIodmFsdWVzLCB2YWx1ZSkpO1xuICB9IC8vIEFjY3VtdWxhdGUsIHNtb290aCBjb250b3VyIHJpbmdzLCBhc3NpZ24gaG9sZXMgdG8gZXh0ZXJpb3IgcmluZ3MuXG4gIC8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYm9zdG9jay9zaGFwZWZpbGUvYmxvYi92MC42LjIvc2hwL3BvbHlnb24uanNcblxuXG4gIGZ1bmN0aW9uIGNvbnRvdXIodmFsdWVzLCB2YWx1ZSkge1xuICAgIHZhciBwb2x5Z29ucyA9IFtdLFxuICAgICAgICBob2xlcyA9IFtdO1xuICAgIGlzb3JpbmdzKHZhbHVlcywgdmFsdWUsIHJpbmcgPT4ge1xuICAgICAgc21vb3RoKHJpbmcsIHZhbHVlcywgdmFsdWUpO1xuICAgICAgaWYgKGFyZWEocmluZykgPiAwKSBwb2x5Z29ucy5wdXNoKFtyaW5nXSk7ZWxzZSBob2xlcy5wdXNoKHJpbmcpO1xuICAgIH0pO1xuICAgIGhvbGVzLmZvckVhY2goaG9sZSA9PiB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb25zLmxlbmd0aCwgcG9seWdvbjsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoY29udGFpbnMoKHBvbHlnb24gPSBwb2x5Z29uc1tpXSlbMF0sIGhvbGUpICE9PSAtMSkge1xuICAgICAgICAgIHBvbHlnb24ucHVzaChob2xlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBjb29yZGluYXRlczogcG9seWdvbnNcbiAgICB9O1xuICB9IC8vIE1hcmNoaW5nIHNxdWFyZXMgd2l0aCBpc29saW5lcyBzdGl0Y2hlZCBpbnRvIHJpbmdzLlxuICAvLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdG9wb2pzb24vdG9wb2pzb24tY2xpZW50L2Jsb2IvdjMuMC4wL3NyYy9zdGl0Y2guanNcblxuXG4gIGZ1bmN0aW9uIGlzb3JpbmdzKHZhbHVlcywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZyYWdtZW50QnlTdGFydCA9IG5ldyBBcnJheSgpLFxuICAgICAgICBmcmFnbWVudEJ5RW5kID0gbmV3IEFycmF5KCksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHQwLFxuICAgICAgICB0MSxcbiAgICAgICAgdDIsXG4gICAgICAgIHQzOyAvLyBTcGVjaWFsIGNhc2UgZm9yIHRoZSBmaXJzdCByb3cgKHkgPSAtMSwgdDIgPSB0MyA9IDApLlxuXG4gICAgeCA9IHkgPSAtMTtcbiAgICB0MSA9IHZhbHVlc1swXSA+PSB2YWx1ZTtcbiAgICBjYXNlc1t0MSA8PCAxXS5mb3JFYWNoKHN0aXRjaCk7XG5cbiAgICB3aGlsZSAoKyt4IDwgZHggLSAxKSB7XG4gICAgICB0MCA9IHQxLCB0MSA9IHZhbHVlc1t4ICsgMV0gPj0gdmFsdWU7XG4gICAgICBjYXNlc1t0MCB8IHQxIDw8IDFdLmZvckVhY2goc3RpdGNoKTtcbiAgICB9XG5cbiAgICBjYXNlc1t0MSA8PCAwXS5mb3JFYWNoKHN0aXRjaCk7IC8vIEdlbmVyYWwgY2FzZSBmb3IgdGhlIGludGVybWVkaWF0ZSByb3dzLlxuXG4gICAgd2hpbGUgKCsreSA8IGR5IC0gMSkge1xuICAgICAgeCA9IC0xO1xuICAgICAgdDEgPSB2YWx1ZXNbeSAqIGR4ICsgZHhdID49IHZhbHVlO1xuICAgICAgdDIgPSB2YWx1ZXNbeSAqIGR4XSA+PSB2YWx1ZTtcbiAgICAgIGNhc2VzW3QxIDw8IDEgfCB0MiA8PCAyXS5mb3JFYWNoKHN0aXRjaCk7XG5cbiAgICAgIHdoaWxlICgrK3ggPCBkeCAtIDEpIHtcbiAgICAgICAgdDAgPSB0MSwgdDEgPSB2YWx1ZXNbeSAqIGR4ICsgZHggKyB4ICsgMV0gPj0gdmFsdWU7XG4gICAgICAgIHQzID0gdDIsIHQyID0gdmFsdWVzW3kgKiBkeCArIHggKyAxXSA+PSB2YWx1ZTtcbiAgICAgICAgY2FzZXNbdDAgfCB0MSA8PCAxIHwgdDIgPDwgMiB8IHQzIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcbiAgICAgIH1cblxuICAgICAgY2FzZXNbdDEgfCB0MiA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgfSAvLyBTcGVjaWFsIGNhc2UgZm9yIHRoZSBsYXN0IHJvdyAoeSA9IGR5IC0gMSwgdDAgPSB0MSA9IDApLlxuXG5cbiAgICB4ID0gLTE7XG4gICAgdDIgPSB2YWx1ZXNbeSAqIGR4XSA+PSB2YWx1ZTtcbiAgICBjYXNlc1t0MiA8PCAyXS5mb3JFYWNoKHN0aXRjaCk7XG5cbiAgICB3aGlsZSAoKyt4IDwgZHggLSAxKSB7XG4gICAgICB0MyA9IHQyLCB0MiA9IHZhbHVlc1t5ICogZHggKyB4ICsgMV0gPj0gdmFsdWU7XG4gICAgICBjYXNlc1t0MiA8PCAyIHwgdDMgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuICAgIH1cblxuICAgIGNhc2VzW3QyIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcblxuICAgIGZ1bmN0aW9uIHN0aXRjaChsaW5lKSB7XG4gICAgICB2YXIgc3RhcnQgPSBbbGluZVswXVswXSArIHgsIGxpbmVbMF1bMV0gKyB5XSxcbiAgICAgICAgICBlbmQgPSBbbGluZVsxXVswXSArIHgsIGxpbmVbMV1bMV0gKyB5XSxcbiAgICAgICAgICBzdGFydEluZGV4ID0gaW5kZXgoc3RhcnQpLFxuICAgICAgICAgIGVuZEluZGV4ID0gaW5kZXgoZW5kKSxcbiAgICAgICAgICBmLFxuICAgICAgICAgIGc7XG5cbiAgICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydEluZGV4XSkge1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRJbmRleF0pIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcblxuICAgICAgICAgIGlmIChmID09PSBnKSB7XG4gICAgICAgICAgICBmLnJpbmcucHVzaChlbmQpO1xuICAgICAgICAgICAgY2FsbGJhY2soZi5yaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtnLmVuZF0gPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBmLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGcuZW5kLFxuICAgICAgICAgICAgICByaW5nOiBmLnJpbmcuY29uY2F0KGcucmluZylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgICAgICBmLnJpbmcucHVzaChlbmQpO1xuICAgICAgICAgIGZyYWdtZW50QnlFbmRbZi5lbmQgPSBlbmRJbmRleF0gPSBmO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGYgPSBmcmFnbWVudEJ5U3RhcnRbZW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChnID0gZnJhZ21lbnRCeUVuZFtzdGFydEluZGV4XSkge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuXG4gICAgICAgICAgaWYgKGYgPT09IGcpIHtcbiAgICAgICAgICAgIGYucmluZy5wdXNoKGVuZCk7XG4gICAgICAgICAgICBjYWxsYmFjayhmLnJpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGcuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogZi5lbmQsXG4gICAgICAgICAgICAgIHJpbmc6IGcucmluZy5jb25jYXQoZi5yaW5nKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgICAgICBmLnJpbmcudW5zaGlmdChzdGFydCk7XG4gICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydEluZGV4XSA9IGY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtzdGFydEluZGV4XSA9IGZyYWdtZW50QnlFbmRbZW5kSW5kZXhdID0ge1xuICAgICAgICAgIHN0YXJ0OiBzdGFydEluZGV4LFxuICAgICAgICAgIGVuZDogZW5kSW5kZXgsXG4gICAgICAgICAgcmluZzogW3N0YXJ0LCBlbmRdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXgocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMF0gKiAyICsgcG9pbnRbMV0gKiAoZHggKyAxKSAqIDQ7XG4gIH1cblxuICBmdW5jdGlvbiBzbW9vdGhMaW5lYXIocmluZywgdmFsdWVzLCB2YWx1ZSkge1xuICAgIHJpbmcuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICB2YXIgeCA9IHBvaW50WzBdLFxuICAgICAgICAgIHkgPSBwb2ludFsxXSxcbiAgICAgICAgICB4dCA9IHggfCAwLFxuICAgICAgICAgIHl0ID0geSB8IDAsXG4gICAgICAgICAgdjAsXG4gICAgICAgICAgdjEgPSB2YWx1ZXNbeXQgKiBkeCArIHh0XTtcblxuICAgICAgaWYgKHggPiAwICYmIHggPCBkeCAmJiB4dCA9PT0geCkge1xuICAgICAgICB2MCA9IHZhbHVlc1t5dCAqIGR4ICsgeHQgLSAxXTtcbiAgICAgICAgcG9pbnRbMF0gPSB4ICsgKHZhbHVlIC0gdjApIC8gKHYxIC0gdjApIC0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAoeSA+IDAgJiYgeSA8IGR5ICYmIHl0ID09PSB5KSB7XG4gICAgICAgIHYwID0gdmFsdWVzWyh5dCAtIDEpICogZHggKyB4dF07XG4gICAgICAgIHBvaW50WzFdID0geSArICh2YWx1ZSAtIHYwKSAvICh2MSAtIHYwKSAtIDAuNTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnRvdXJzLmNvbnRvdXIgPSBjb250b3VyO1xuXG4gIGNvbnRvdXJzLnNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtkeCwgZHldO1xuXG4gICAgdmFyIF8wID0gTWF0aC5mbG9vcihfWzBdKSxcbiAgICAgICAgXzEgPSBNYXRoLmZsb29yKF9bMV0pO1xuXG4gICAgaWYgKCEoXzAgPj0gMCAmJiBfMSA+PSAwKSkgZXJyb3IoJ2ludmFsaWQgc2l6ZScpO1xuICAgIHJldHVybiBkeCA9IF8wLCBkeSA9IF8xLCBjb250b3VycztcbiAgfTtcblxuICBjb250b3Vycy5zbW9vdGggPSBmdW5jdGlvbiAoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNtb290aCA9IF8gPyBzbW9vdGhMaW5lYXIgOiBub29wLCBjb250b3VycykgOiBzbW9vdGggPT09IHNtb290aExpbmVhcjtcbiAgfTtcblxuICByZXR1cm4gY29udG91cnM7XG59XG5cbmZ1bmN0aW9uIGFyZWEocmluZykge1xuICB2YXIgaSA9IDAsXG4gICAgICBuID0gcmluZy5sZW5ndGgsXG4gICAgICBhcmVhID0gcmluZ1tuIC0gMV1bMV0gKiByaW5nWzBdWzBdIC0gcmluZ1tuIC0gMV1bMF0gKiByaW5nWzBdWzFdO1xuXG4gIHdoaWxlICgrK2kgPCBuKSBhcmVhICs9IHJpbmdbaSAtIDFdWzFdICogcmluZ1tpXVswXSAtIHJpbmdbaSAtIDFdWzBdICogcmluZ1tpXVsxXTtcblxuICByZXR1cm4gYXJlYTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocmluZywgaG9sZSkge1xuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IGhvbGUubGVuZ3RoLFxuICAgICAgYztcblxuICB3aGlsZSAoKytpIDwgbikgaWYgKGMgPSByaW5nQ29udGFpbnMocmluZywgaG9sZVtpXSkpIHJldHVybiBjO1xuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiByaW5nQ29udGFpbnMocmluZywgcG9pbnQpIHtcbiAgdmFyIHggPSBwb2ludFswXSxcbiAgICAgIHkgPSBwb2ludFsxXSxcbiAgICAgIGNvbnRhaW5zID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSByaW5nLmxlbmd0aCwgaiA9IG4gLSAxOyBpIDwgbjsgaiA9IGkrKykge1xuICAgIHZhciBwaSA9IHJpbmdbaV0sXG4gICAgICAgIHhpID0gcGlbMF0sXG4gICAgICAgIHlpID0gcGlbMV0sXG4gICAgICAgIHBqID0gcmluZ1tqXSxcbiAgICAgICAgeGogPSBwalswXSxcbiAgICAgICAgeWogPSBwalsxXTtcbiAgICBpZiAoc2VnbWVudENvbnRhaW5zKHBpLCBwaiwgcG9pbnQpKSByZXR1cm4gMDtcbiAgICBpZiAoeWkgPiB5ICE9PSB5aiA+IHkgJiYgeCA8ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGkpIGNvbnRhaW5zID0gLWNvbnRhaW5zO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5zO1xufVxuXG5mdW5jdGlvbiBzZWdtZW50Q29udGFpbnMoYSwgYiwgYykge1xuICB2YXIgaTtcbiAgcmV0dXJuIGNvbGxpbmVhcihhLCBiLCBjKSAmJiB3aXRoaW4oYVtpID0gKyhhWzBdID09PSBiWzBdKV0sIGNbaV0sIGJbaV0pO1xufVxuXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSwgYiwgYykge1xuICByZXR1cm4gKGJbMF0gLSBhWzBdKSAqIChjWzFdIC0gYVsxXSkgPT09IChjWzBdIC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pO1xufVxuXG5mdW5jdGlvbiB3aXRoaW4ocCwgcSwgcikge1xuICByZXR1cm4gcCA8PSBxICYmIHEgPD0gciB8fCByIDw9IHEgJiYgcSA8PSBwO1xufVxuXG5mdW5jdGlvbiBxdWFudGl6ZSAoaywgbmljZSwgemVybykge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHZhciBleCA9IGV4dGVudCh2YWx1ZXMpLFxuICAgICAgICBzdGFydCA9IHplcm8gPyBNYXRoLm1pbihleFswXSwgMCkgOiBleFswXSxcbiAgICAgICAgc3RvcCA9IGV4WzFdLFxuICAgICAgICBzcGFuID0gc3RvcCAtIHN0YXJ0LFxuICAgICAgICBzdGVwID0gbmljZSA/IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBrKSA6IHNwYW4gLyAoayArIDEpO1xuICAgIHJldHVybiByYW5nZShzdGFydCArIHN0ZXAsIHN0b3AsIHN0ZXApO1xuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGlzb2NvbnRvdXJzIChsZXZlbCBzZXRzKSBiYXNlZCBvbiBpbnB1dCByYXN0ZXIgZ3JpZCBkYXRhLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IFtwYXJhbXMuZmllbGRdIC0gVGhlIGZpZWxkIHdpdGggcmFzdGVyIGdyaWRcbiAqICAgZGF0YS4gSWYgdW5zcGVjaWZpZWQsIHRoZSB0dXBsZSBpdHNlbGYgaXMgaW50ZXJwcmV0ZWQgYXMgYSByYXN0ZXIgZ3JpZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy50aHJlc2hvbGRzXSAtIENvbnRvdXIgdGhyZXNob2xkIGFycmF5LiBJZlxuICogICBzcGVjaWZpZWQsIHRoZSBsZXZlbHMsIG5pY2UsIHJlc29sdmUsIGFuZCB6ZXJvIHBhcmFtZXRlcnMgYXJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5sZXZlbHNdIC0gVGhlIGRlc2lyZWQgbnVtYmVyIG9mIGNvbnRvdXIgbGV2ZWxzLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLm5pY2VdIC0gQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGNvbnRvdXJcbiAqICAgdGhyZXNob2xkIHZhbHVlcyBzaG91bGQgYmUgYXV0b21hdGljYWxseSBhbGlnbmVkIHRvIFwibmljZVwiXG4gKiAgIGh1bWFuLWZyaWVuZGx5IHZhbHVlcy4gU2V0dGluZyB0aGlzIGZsYWcgbWF5IGNhdXNlIHRoZSBudW1iZXIgb2ZcbiAqICAgdGhyZXNob2xkcyB0byBkZXZpYXRlIGZyb20gdGhlIHNwZWNpZmllZCBsZXZlbHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5yZXNvbHZlXSAtIFRoZSBtZXRob2QgZm9yIHJlc29sdmluZyB0aHJlc2hvbGRzXG4gKiAgIGFjcm9zcyBtdWx0aXBsZSBpbnB1dCBncmlkcy4gSWYgJ2luZGVwZW5kZW50JyAodGhlIGRlZmF1bHQpLCB0aHJlc2hvbGRcbiAqICAgY2FsY3VsYXRpb24gd2lsbCBiZSBwZXJmb3JtZWQgc2VwYXJhdGVseSBmb3IgZWFjaCBncmlkLiBJZiAnc2hhcmVkJywgYVxuICogICBzaW5nbGUgc2V0IG9mIHRocmVzaG9sZCB2YWx1ZXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgaW5wdXQgZ3JpZHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuemVyb10gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgY29udG91clxuICogICB0aHJlc2hvbGQgdmFsdWVzIHNob3VsZCBpbmNsdWRlIHplcm8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc21vb3RoXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBjb250b3VyXG4gKiAgIHBvbHlnb25zIHNob3VsZCBiZSBzbW9vdGhlZCB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi4gVGhlIGRlZmF1bHQgaXNcbiAqICAgdHJ1ZS4gVGhlIHBhcmFtZXRlciBpcyBpZ25vcmVkIHdoZW4gdXNpbmcgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLnNjYWxlXSAtIE9wdGlvbmFsIG51bWVyaWNhbCB2YWx1ZSBieSB3aGljaCB0b1xuICogICBzY2FsZSB0aGUgb3V0cHV0IGlzb2NvbnRvdXIgY29vcmRpbmF0ZXMuIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSB1c2VmdWxcbiAqICAgdG8gc2NhbGUgdGhlIGNvbnRvdXJzIHRvIG1hdGNoIGEgZGVzaXJlZCBvdXRwdXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmFzPSdjb250b3VyJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgaXNvY29udG91ciBkYXRhIChkZWZhdWx0ICdjb250b3VyJykuXG4gKi9cblxuZnVuY3Rpb24gSXNvY29udG91cihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbklzb2NvbnRvdXIuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnSXNvY29udG91cicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0aHJlc2hvbGRzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2xldmVscycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnbmljZScsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncmVzb2x2ZScsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ3ZhbHVlcyc6IFsnc2hhcmVkJywgJ2luZGVwZW5kZW50J10sXG4gICAgJ2RlZmF1bHQnOiAnaW5kZXBlbmRlbnQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd6ZXJvJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3Ntb290aCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzY2FsZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3RyYW5zbGF0ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdkZWZhdWx0JzogJ2NvbnRvdXInXG4gIH1dXG59O1xuaW5oZXJpdHMoSXNvY29udG91ciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFwdWxzZS5jaGFuZ2VkKCkgJiYgIV8ubW9kaWZpZWQoKSkge1xuICAgICAgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgICAgZmllbGQgPSBfLmZpZWxkIHx8IGlkZW50aXR5LFxuICAgICAgICBjb250b3VyID0gY29udG91cnMoKS5zbW9vdGgoXy5zbW9vdGggIT09IGZhbHNlKSxcbiAgICAgICAgdHogPSBfLnRocmVzaG9sZHMgfHwgbGV2ZWxzKHNvdXJjZSwgZmllbGQsIF8pLFxuICAgICAgICBhcyA9IF8uYXMgPT09IG51bGwgPyBudWxsIDogXy5hcyB8fCAnY29udG91cicsXG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgIHNvdXJjZS5mb3JFYWNoKHQgPT4ge1xuICAgICAgY29uc3QgZ3JpZCA9IGZpZWxkKHQpOyAvLyBnZW5lcmF0ZSBjb250b3VyIHBhdGhzIGluIEdlb0pTT04gZm9ybWF0XG5cbiAgICAgIGNvbnN0IHBhdGhzID0gY29udG91ci5zaXplKFtncmlkLndpZHRoLCBncmlkLmhlaWdodF0pKGdyaWQudmFsdWVzLCBpc0FycmF5KHR6KSA/IHR6IDogdHooZ3JpZC52YWx1ZXMpKTsgLy8gYWRqdXN0IGNvbnRvdXIgcGF0aCBjb29yZGluYXRlcyBhcyBuZWVkZWRcblxuICAgICAgdHJhbnNmb3JtUGF0aHMocGF0aHMsIGdyaWQsIHQsIF8pOyAvLyBpbmdlc3Q7IGNvcHkgc291cmNlIGRhdGEgcHJvcGVydGllcyB0byBvdXRwdXRcblxuICAgICAgcGF0aHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgdmFsdWVzLnB1c2gocmVkZXJpdmUodCwgaW5nZXN0KGFzICE9IG51bGwgPyB7XG4gICAgICAgICAgW2FzXTogcFxuICAgICAgICB9IDogcCkpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnZhbHVlKSBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IG91dC5hZGQgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gbGV2ZWxzKHZhbHVlcywgZiwgXykge1xuICBjb25zdCBxID0gcXVhbnRpemUoXy5sZXZlbHMgfHwgMTAsIF8ubmljZSwgXy56ZXJvICE9PSBmYWxzZSk7XG4gIHJldHVybiBfLnJlc29sdmUgIT09ICdzaGFyZWQnID8gcSA6IHEodmFsdWVzLm1hcCh0ID0+IG1heChmKHQpLnZhbHVlcykpKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUGF0aHMocGF0aHMsIGdyaWQsIGRhdHVtLCBfKSB7XG4gIGxldCBzID0gXy5zY2FsZSB8fCBncmlkLnNjYWxlLFxuICAgICAgdCA9IF8udHJhbnNsYXRlIHx8IGdyaWQudHJhbnNsYXRlO1xuICBpZiAoaXNGdW5jdGlvbihzKSkgcyA9IHMoZGF0dW0sIF8pO1xuICBpZiAoaXNGdW5jdGlvbih0KSkgdCA9IHQoZGF0dW0sIF8pO1xuICBpZiAoKHMgPT09IDEgfHwgcyA9PSBudWxsKSAmJiAhdCkgcmV0dXJuO1xuICBjb25zdCBzeCA9IChpc051bWJlcihzKSA/IHMgOiBzWzBdKSB8fCAxLFxuICAgICAgICBzeSA9IChpc051bWJlcihzKSA/IHMgOiBzWzFdKSB8fCAxLFxuICAgICAgICB0eCA9IHQgJiYgdFswXSB8fCAwLFxuICAgICAgICB0eSA9IHQgJiYgdFsxXSB8fCAwO1xuICBwYXRocy5mb3JFYWNoKHRyYW5zZm9ybShncmlkLCBzeCwgc3ksIHR4LCB0eSkpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm0oZ3JpZCwgc3gsIHN5LCB0eCwgdHkpIHtcbiAgY29uc3QgeDEgPSBncmlkLngxIHx8IDAsXG4gICAgICAgIHkxID0gZ3JpZC55MSB8fCAwLFxuICAgICAgICBmbGlwID0gc3ggKiBzeSA8IDA7XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUG9seWdvbihjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtUmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1SaW5nKGNvb3JkaW5hdGVzKSB7XG4gICAgaWYgKGZsaXApIGNvb3JkaW5hdGVzLnJldmVyc2UoKTsgLy8gbWFpbnRhaW4gd2luZGluZyBvcmRlclxuXG4gICAgY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm1Qb2ludCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzWzBdID0gKGNvb3JkaW5hdGVzWzBdIC0geDEpICogc3ggKyB0eDtcbiAgICBjb29yZGluYXRlc1sxXSA9IChjb29yZGluYXRlc1sxXSAtIHkxKSAqIHN5ICsgdHk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm1Qb2x5Z29uKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJhZGl1cyhidywgZGF0YSwgZikge1xuICBjb25zdCB2ID0gYncgPj0gMCA/IGJ3IDogYmFuZHdpZHRoTlJEKGRhdGEsIGYpO1xuICByZXR1cm4gTWF0aC5yb3VuZCgoTWF0aC5zcXJ0KDQgKiB2ICogdiArIDEpIC0gMSkgLyAyKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKF8pIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oXykgPyBfIDogY29uc3RhbnQoK18pO1xufSAvLyBJbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb20gZDMvZDMtY29udG91ci4gVGhhbmtzIVxuXG5cbmZ1bmN0aW9uIGRlbnNpdHkyRCAoKSB7XG4gIHZhciB4ID0gZCA9PiBkWzBdLFxuICAgICAgeSA9IGQgPT4gZFsxXSxcbiAgICAgIHdlaWdodCA9IG9uZSxcbiAgICAgIGJhbmR3aWR0aCA9IFstMSwgLTFdLFxuICAgICAgZHggPSA5NjAsXG4gICAgICBkeSA9IDUwMCxcbiAgICAgIGsgPSAyOyAvLyBsb2cyKGNlbGxTaXplKVxuXG5cbiAgZnVuY3Rpb24gZGVuc2l0eShkYXRhLCBjb3VudHMpIHtcbiAgICBjb25zdCByeCA9IHJhZGl1cyhiYW5kd2lkdGhbMF0sIGRhdGEsIHgpID4+IGssXG4gICAgICAgICAgLy8gYmx1ciB4LXJhZGl1c1xuICAgIHJ5ID0gcmFkaXVzKGJhbmR3aWR0aFsxXSwgZGF0YSwgeSkgPj4gayxcbiAgICAgICAgICAvLyBibHVyIHktcmFkaXVzXG4gICAgb3ggPSByeCA/IHJ4ICsgMiA6IDAsXG4gICAgICAgICAgLy8geC1vZmZzZXQgcGFkZGluZyBmb3IgYmx1clxuICAgIG95ID0gcnkgPyByeSArIDIgOiAwLFxuICAgICAgICAgIC8vIHktb2Zmc2V0IHBhZGRpbmcgZm9yIGJsdXJcbiAgICBuID0gMiAqIG94ICsgKGR4ID4+IGspLFxuICAgICAgICAgIC8vIGdyaWQgd2lkdGhcbiAgICBtID0gMiAqIG95ICsgKGR5ID4+IGspLFxuICAgICAgICAgIC8vIGdyaWQgaGVpZ2h0XG4gICAgdmFsdWVzMCA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIG0pLFxuICAgICAgICAgIHZhbHVlczEgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBtKTtcbiAgICBsZXQgdmFsdWVzID0gdmFsdWVzMDtcbiAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICBjb25zdCB4aSA9IG94ICsgKCt4KGQpID4+IGspLFxuICAgICAgICAgICAgeWkgPSBveSArICgreShkKSA+PiBrKTtcblxuICAgICAgaWYgKHhpID49IDAgJiYgeGkgPCBuICYmIHlpID49IDAgJiYgeWkgPCBtKSB7XG4gICAgICAgIHZhbHVlczBbeGkgKyB5aSAqIG5dICs9ICt3ZWlnaHQoZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocnggPiAwICYmIHJ5ID4gMCkge1xuICAgICAgYmx1clgobiwgbSwgdmFsdWVzMCwgdmFsdWVzMSwgcngpO1xuICAgICAgYmx1clkobiwgbSwgdmFsdWVzMSwgdmFsdWVzMCwgcnkpO1xuICAgICAgYmx1clgobiwgbSwgdmFsdWVzMCwgdmFsdWVzMSwgcngpO1xuICAgICAgYmx1clkobiwgbSwgdmFsdWVzMSwgdmFsdWVzMCwgcnkpO1xuICAgICAgYmx1clgobiwgbSwgdmFsdWVzMCwgdmFsdWVzMSwgcngpO1xuICAgICAgYmx1clkobiwgbSwgdmFsdWVzMSwgdmFsdWVzMCwgcnkpO1xuICAgIH0gZWxzZSBpZiAocnggPiAwKSB7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeCk7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMxO1xuICAgIH0gZWxzZSBpZiAocnkgPiAwKSB7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeSk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeSk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeSk7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMxO1xuICAgIH0gLy8gc2NhbGUgZGVuc2l0eSBlc3RpbWF0ZXNcbiAgICAvLyBkZW5zaXR5IGluIHBvaW50cyBwZXIgc3F1YXJlIHBpeGVsIG9yIHByb2JhYmlsaXR5IGRlbnNpdHlcblxuXG4gICAgY29uc3QgcyA9IGNvdW50cyA/IE1hdGgucG93KDIsIC0yICogaykgOiAxIC8gc3VtKHZhbHVlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgc3ogPSBuICogbTsgaSA8IHN6OyArK2kpIHZhbHVlc1tpXSAqPSBzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgc2NhbGU6IDEgPDwgayxcbiAgICAgIHdpZHRoOiBuLFxuICAgICAgaGVpZ2h0OiBtLFxuICAgICAgeDE6IG94LFxuICAgICAgeTE6IG95LFxuICAgICAgeDI6IG94ICsgKGR4ID4+IGspLFxuICAgICAgeTI6IG95ICsgKGR5ID4+IGspXG4gICAgfTtcbiAgfVxuXG4gIGRlbnNpdHkueCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IG51bWJlcihfKSwgZGVuc2l0eSkgOiB4O1xuICB9O1xuXG4gIGRlbnNpdHkueSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IG51bWJlcihfKSwgZGVuc2l0eSkgOiB5O1xuICB9O1xuXG4gIGRlbnNpdHkud2VpZ2h0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3ZWlnaHQgPSBudW1iZXIoXyksIGRlbnNpdHkpIDogd2VpZ2h0O1xuICB9O1xuXG4gIGRlbnNpdHkuc2l6ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW2R4LCBkeV07XG5cbiAgICB2YXIgXzAgPSArX1swXSxcbiAgICAgICAgXzEgPSArX1sxXTtcblxuICAgIGlmICghKF8wID49IDAgJiYgXzEgPj0gMCkpIGVycm9yKCdpbnZhbGlkIHNpemUnKTtcbiAgICByZXR1cm4gZHggPSBfMCwgZHkgPSBfMSwgZGVuc2l0eTtcbiAgfTtcblxuICBkZW5zaXR5LmNlbGxTaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAxIDw8IGs7XG4gICAgaWYgKCEoKF8gPSArXykgPj0gMSkpIGVycm9yKCdpbnZhbGlkIGNlbGwgc2l6ZScpO1xuICAgIGsgPSBNYXRoLmZsb29yKE1hdGgubG9nKF8pIC8gTWF0aC5MTjIpO1xuICAgIHJldHVybiBkZW5zaXR5O1xuICB9O1xuXG4gIGRlbnNpdHkuYmFuZHdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiYW5kd2lkdGg7XG4gICAgXyA9IGFycmF5KF8pO1xuICAgIGlmIChfLmxlbmd0aCA9PT0gMSkgXyA9IFsrX1swXSwgK19bMF1dO1xuICAgIGlmIChfLmxlbmd0aCAhPT0gMikgZXJyb3IoJ2ludmFsaWQgYmFuZHdpZHRoJyk7XG4gICAgcmV0dXJuIGJhbmR3aWR0aCA9IF8sIGRlbnNpdHk7XG4gIH07XG5cbiAgcmV0dXJuIGRlbnNpdHk7XG59XG5cbmZ1bmN0aW9uIGJsdXJYKG4sIG0sIHNvdXJjZSwgdGFyZ2V0LCByKSB7XG4gIGNvbnN0IHcgPSAociA8PCAxKSArIDE7XG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKGxldCBpID0gMCwgc3IgPSAwOyBpIDwgbiArIHI7ICsraSkge1xuICAgICAgaWYgKGkgPCBuKSB7XG4gICAgICAgIHNyICs9IHNvdXJjZVtpICsgaiAqIG5dO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+PSByKSB7XG4gICAgICAgIGlmIChpID49IHcpIHtcbiAgICAgICAgICBzciAtPSBzb3VyY2VbaSAtIHcgKyBqICogbl07XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRbaSAtIHIgKyBqICogbl0gPSBzciAvIE1hdGgubWluKGkgKyAxLCBuIC0gMSArIHcgLSBpLCB3KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmx1clkobiwgbSwgc291cmNlLCB0YXJnZXQsIHIpIHtcbiAgY29uc3QgdyA9IChyIDw8IDEpICsgMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwLCBzciA9IDA7IGogPCBtICsgcjsgKytqKSB7XG4gICAgICBpZiAoaiA8IG0pIHtcbiAgICAgICAgc3IgKz0gc291cmNlW2kgKyBqICogbl07XG4gICAgICB9XG5cbiAgICAgIGlmIChqID49IHIpIHtcbiAgICAgICAgaWYgKGogPj0gdykge1xuICAgICAgICAgIHNyIC09IHNvdXJjZVtpICsgKGogLSB3KSAqIG5dO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0W2kgKyAoaiAtIHIpICogbl0gPSBzciAvIE1hdGgubWluKGogKyAxLCBtIC0gMSArIHcgLSBqLCB3KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtIDJEIGtlcm5lbC1kZW5zaXR5IGVzdGltYXRpb24gb2YgcG9pbnQgZGF0YS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYXJhbXMuc2l6ZSAtIFRoZSBbd2lkdGgsIGhlaWdodF0gZXh0ZW50IChpblxuICogICB1bml0cyBvZiBpbnB1dCBwaXhlbHMpIG92ZXIgd2hpY2ggdG8gcGVyZm9ybSBkZW5zaXR5IGVzdGltYXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG51bWJlcn0gcGFyYW1zLnggLSBUaGUgeC1jb29yZGluYXRlIGFjY2Vzc29yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBudW1iZXJ9IHBhcmFtcy55IC0gVGhlIHktY29vcmRpbmF0ZSBhY2Nlc3Nvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogbnVtYmVyfSBbcGFyYW1zLndlaWdodF0gLSBUaGUgd2VpZ2h0IGFjY2Vzc29yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29yc1xuICogICB0byBncm91cGJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuY2VsbFNpemVdIC0gQ29udG91ciBkZW5zaXR5IGNhbGN1bGF0aW9uIGNlbGwgc2l6ZS5cbiAqICAgVGhpcyBwYXJhbWV0ZXIgZGV0ZXJtaW5lcyB0aGUgbGV2ZWwgb2Ygc3BhdGlhbCBhcHByb3hpbWF0aW9uLiBGb3IgZXhhbXBsZSxcbiAqICAgdGhlIGRlZmF1bHQgdmFsdWUgb2YgNCBtYXBzIHRvIDJ4IHJlZHVjdGlvbnMgaW4gYm90aCB4LSBhbmQgeS0gZGltZW5zaW9ucy5cbiAqICAgQSB2YWx1ZSBvZiAxIHdpbGwgcmVzdWx0IGluIGFuIG91dHB1dCByYXN0ZXIgZ3JpZCB3aG9zZSBkaW1lbnNpb25zIGV4YWN0bHlcbiAqICAgbWF0Y2hlcyB0aGUgc2l6ZSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMuYmFuZHdpZHRoXSAtIFRoZSBLREUga2VybmVsIGJhbmR3aWR0aHMsXG4gKiAgIGluIHBpeGVscy4gVGhlIGlucHV0IGNhbiBiZSBhIHR3by1lbGVtZW50IGFycmF5IHNwZWNpZnlpbmcgc2VwYXJhdGVcbiAqICAgeCBhbmQgeSBiYW5kd2lkdGhzLCBvciBhIHNpbmdsZS1lbGVtZW50IGFycmF5IHNwZWNpZnlpbmcgYm90aC4gSWYgdGhlXG4gKiAgIGJhbmR3aWR0aCBpcyB1bnNwZWNpZmllZCBvciBsZXNzIHRoYW4gemVybywgdGhlIGJhbmR3aWR0aCB3aWxsIGJlXG4gKiAgIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5jb3VudHM9ZmFsc2VdIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGVcbiAqICAgb3V0cHV0IHZhbHVlcyBzaG91bGQgYmUgcHJvYmFiaWxpdHkgZXN0aW1hdGVzIChmYWxzZSwgZGVmYXVsdCkgb3JcbiAqICAgc21vb3RoZWQgY291bnRzICh0cnVlKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmFzPSdncmlkJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgcmFzdGVyIGdyaWQgKGRlZmF1bHQgJ2dyaWQnKS5cbiAqL1xuXG5mdW5jdGlvbiBLREUyRChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbktERTJELkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0tERTJEJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd4JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAneScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3dlaWdodCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnY2VsbFNpemUnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ2JhbmR3aWR0aCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdjb3VudHMnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ2dyaWQnXG4gIH1dXG59O1xuY29uc3QgUEFSQU1TID0gWyd4JywgJ3knLCAnd2VpZ2h0JywgJ3NpemUnLCAnY2VsbFNpemUnLCAnYmFuZHdpZHRoJ107XG5mdW5jdGlvbiBwYXJhbXMob2JqLCBfKSB7XG4gIFBBUkFNUy5mb3JFYWNoKHBhcmFtID0+IF9bcGFyYW1dICE9IG51bGwgPyBvYmpbcGFyYW1dKF9bcGFyYW1dKSA6IDApO1xuICByZXR1cm4gb2JqO1xufVxuaW5oZXJpdHMoS0RFMkQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhcHVsc2UuY2hhbmdlZCgpICYmICFfLm1vZGlmaWVkKCkpIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgdmFyIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSxcbiAgICAgICAgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbihzb3VyY2UsIF8uZ3JvdXBieSksXG4gICAgICAgIG5hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgIGtkZSA9IHBhcmFtcyhkZW5zaXR5MkQoKSwgXyksXG4gICAgICAgIGFzID0gXy5hcyB8fCAnZ3JpZCcsXG4gICAgICAgIHZhbHVlcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc2V0KHQsIHZhbHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHRbbmFtZXNbaV1dID0gdmFsc1tpXTtcblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfSAvLyBnZW5lcmF0ZSBkZW5zaXR5IHJhc3RlciBncmlkc1xuXG5cbiAgICB2YWx1ZXMgPSBncm91cHMubWFwKGcgPT4gaW5nZXN0KHNldCh7XG4gICAgICBbYXNdOiBrZGUoZywgXy5jb3VudHMpXG4gICAgfSwgZy5kaW1zKSkpO1xuICAgIGlmICh0aGlzLnZhbHVlKSBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IG91dC5hZGQgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcbmZ1bmN0aW9uIHBhcnRpdGlvbihkYXRhLCBncm91cGJ5KSB7XG4gIHZhciBncm91cHMgPSBbXSxcbiAgICAgIGdldCA9IGYgPT4gZih0KSxcbiAgICAgIG1hcCxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgdCxcbiAgICAgIGssXG4gICAgICBnOyAvLyBwYXJ0aXRpb24gZGF0YSBwb2ludHMgaW50byBncm91cHNcblxuXG4gIGlmIChncm91cGJ5ID09IG51bGwpIHtcbiAgICBncm91cHMucHVzaChkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcCA9IHt9LCBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gZGF0YVtpXTtcbiAgICAgIGsgPSBncm91cGJ5Lm1hcChnZXQpO1xuICAgICAgZyA9IG1hcFtrXTtcblxuICAgICAgaWYgKCFnKSB7XG4gICAgICAgIG1hcFtrXSA9IGcgPSBbXTtcbiAgICAgICAgZy5kaW1zID0gaztcbiAgICAgICAgZ3JvdXBzLnB1c2goZyk7XG4gICAgICB9XG5cbiAgICAgIGcucHVzaCh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ3JvdXBzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGNvbnRvdXJzIGJhc2VkIG9uIGtlcm5lbC1kZW5zaXR5IGVzdGltYXRpb24gb2YgcG9pbnQgZGF0YS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYXJhbXMuc2l6ZSAtIFRoZSBkaW1lbnNpb25zIFt3aWR0aCwgaGVpZ2h0XSBvdmVyIHdoaWNoIHRvIGNvbXB1dGUgY29udG91cnMuXG4gKiAgSWYgdGhlIHZhbHVlcyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoaXMgbXVzdCBiZSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgZGF0YS5cbiAqICBJZiBkZW5zaXR5IGVzdGltYXRpb24gaXMgcGVyZm9ybWVkLCB0aGlzIGlzIHRoZSBvdXRwdXQgdmlldyBkaW1lbnNpb25zIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy52YWx1ZXNdIC0gQW4gYXJyYXkgb2YgbnVtZXJpYyB2YWx1ZXMgcmVwcmVzZW50aW5nIGFuXG4gKiAgd2lkdGggeCBoZWlnaHQgZ3JpZCBvZiB2YWx1ZXMgb3ZlciB3aGljaCB0byBjb21wdXRlIGNvbnRvdXJzLiBJZiB1bnNwZWNpZmllZCwgdGhpc1xuICogIHRyYW5zZm9ybSB3aWxsIGluc3RlYWQgYXR0ZW1wdCB0byBjb21wdXRlIGNvbnRvdXJzIGZvciB0aGUga2VybmVsIGRlbnNpdHkgZXN0aW1hdGVcbiAqICB1c2luZyB2YWx1ZXMgZHJhd24gZnJvbSBkYXRhIHR1cGxlcyBpbiB0aGUgaW5wdXQgcHVsc2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG51bWJlcn0gW3BhcmFtcy54XSAtIFRoZSBwaXhlbCB4LWNvb3JkaW5hdGUgYWNjZXNzb3IgZm9yIGRlbnNpdHkgZXN0aW1hdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogbnVtYmVyfSBbcGFyYW1zLnldIC0gVGhlIHBpeGVsIHktY29vcmRpbmF0ZSBhY2Nlc3NvciBmb3IgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBudW1iZXJ9IFtwYXJhbXMud2VpZ2h0XSAtIFRoZSBkYXRhIHBvaW50IHdlaWdodCBhY2Nlc3NvciBmb3IgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuY2VsbFNpemVdIC0gQ29udG91ciBkZW5zaXR5IGNhbGN1bGF0aW9uIGNlbGwgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmJhbmR3aWR0aF0gLSBLZXJuZWwgZGVuc2l0eSBlc3RpbWF0aW9uIGJhbmR3aWR0aC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy50aHJlc2hvbGRzXSAtIENvbnRvdXIgdGhyZXNob2xkIGFycmF5LiBJZlxuICogICB0aGlzIHBhcmFtZXRlciBpcyBzZXQsIHRoZSBjb3VudCBhbmQgbmljZSBwYXJhbWV0ZXJzIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmNvdW50XSAtIFRoZSBkZXNpcmVkIG51bWJlciBvZiBjb250b3Vycy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5uaWNlXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBjb250b3VyXG4gKiAgIHRocmVzaG9sZCB2YWx1ZXMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgYWxpZ25lZCB0byBcIm5pY2VcIlxuICogICBodW1hbi1mcmllbmRseSB2YWx1ZXMuIFNldHRpbmcgdGhpcyBmbGFnIG1heSBjYXVzZSB0aGUgbnVtYmVyIG9mXG4gKiAgIHRocmVzaG9sZHMgdG8gZGV2aWF0ZSBmcm9tIHRoZSBzcGVjaWZpZWQgY291bnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc21vb3RoXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBjb250b3VyXG4gKiAgIHBvbHlnb25zIHNob3VsZCBiZSBzbW9vdGhlZCB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi4gVGhlIGRlZmF1bHQgaXNcbiAqICAgdHJ1ZS4gVGhlIHBhcmFtZXRlciBpcyBpZ25vcmVkIHdoZW4gdXNpbmcgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIENvbnRvdXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Db250b3VyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0NvbnRvdXInLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3ZhbHVlcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd4JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3knLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnd2VpZ2h0JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ2NlbGxTaXplJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdiYW5kd2lkdGgnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ2NvdW50JyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICduaWNlJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IGZhbHNlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0aHJlc2hvbGRzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3Ntb290aCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoQ29udG91ciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFwdWxzZS5jaGFuZ2VkKCkgJiYgIV8ubW9kaWZpZWQoKSkge1xuICAgICAgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICBjb250b3VyID0gY29udG91cnMoKS5zbW9vdGgoXy5zbW9vdGggIT09IGZhbHNlKSxcbiAgICAgICAgdmFsdWVzID0gXy52YWx1ZXMsXG4gICAgICAgIHRocmVzaCA9IF8udGhyZXNob2xkcyB8fCBxdWFudGl6ZShfLmNvdW50IHx8IDEwLCBfLm5pY2UsICEhdmFsdWVzKSxcbiAgICAgICAgc2l6ZSA9IF8uc2l6ZSxcbiAgICAgICAgZ3JpZCxcbiAgICAgICAgcG9zdDtcblxuICAgIGlmICghdmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZTtcbiAgICAgIGdyaWQgPSBwYXJhbXMoZGVuc2l0eTJEKCksIF8pKHZhbHVlcywgdHJ1ZSk7XG4gICAgICBwb3N0ID0gdHJhbnNmb3JtKGdyaWQsIGdyaWQuc2NhbGUgfHwgMSwgZ3JpZC5zY2FsZSB8fCAxLCAwLCAwKTtcbiAgICAgIHNpemUgPSBbZ3JpZC53aWR0aCwgZ3JpZC5oZWlnaHRdO1xuICAgICAgdmFsdWVzID0gZ3JpZC52YWx1ZXM7XG4gICAgfVxuXG4gICAgdGhyZXNoID0gaXNBcnJheSh0aHJlc2gpID8gdGhyZXNoIDogdGhyZXNoKHZhbHVlcyk7XG4gICAgdmFsdWVzID0gY29udG91ci5zaXplKHNpemUpKHZhbHVlcywgdGhyZXNoKTtcbiAgICBpZiAocG9zdCkgdmFsdWVzLmZvckVhY2gocG9zdCk7XG4gICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZCA9ICh2YWx1ZXMgfHwgW10pLm1hcChpbmdlc3QpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmNvbnN0IEZlYXR1cmUgPSAnRmVhdHVyZSc7XG5jb25zdCBGZWF0dXJlQ29sbGVjdGlvbiA9ICdGZWF0dXJlQ29sbGVjdGlvbic7XG5jb25zdCBNdWx0aVBvaW50ID0gJ011bHRpUG9pbnQnO1xuXG4vKipcbiAqIENvbnNvbGlkYXRlIGFuIGFycmF5IG9mIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBwb2ludHMgb3IgR2VvSlNPTiBmZWF0dXJlc1xuICogaW50byBhIGNvbWJpbmVkIEdlb0pTT04gb2JqZWN0LiBUaGlzIHRyYW5zZm9ybSBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvclxuICogY29tYmluaW5nIGdlbyBkYXRhIGZvciBhIFByb2plY3Rpb24ncyBmaXQgYXJndW1lbnQuIFRoZSByZXN1bHRpbmcgR2VvSlNPTlxuICogZGF0YSBpcyBhdmFpbGFibGUgYXMgdGhpcyB0cmFuc2Zvcm0ncyB2YWx1ZS4gSW5wdXQgcHVsc2VzIGFyZSB1bmNoYW5nZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZmllbGRzXSAtIEEgdHdvLWVsZW1lbnQgYXJyYXlcbiAqICAgb2YgZmllbGQgYWNjZXNzb3JzIGZvciB0aGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5nZW9qc29uIC0gQSBmaWVsZCBhY2Nlc3NvciBmb3JcbiAqICAgcmV0cmlldmluZyBHZW9KU09OIGZlYXR1cmUgZGF0YS5cbiAqL1xuXG5mdW5jdGlvbiBHZW9KU09OKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuR2VvSlNPTi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdHZW9KU09OJyxcbiAgJ21ldGFkYXRhJzoge30sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ2dlb2pzb24nLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9XVxufTtcbmluaGVyaXRzKEdlb0pTT04sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9mZWF0dXJlcyxcbiAgICAgICAgcG9pbnRzID0gdGhpcy5fcG9pbnRzLFxuICAgICAgICBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgICAgbG9uID0gZmllbGRzICYmIGZpZWxkc1swXSxcbiAgICAgICAgbGF0ID0gZmllbGRzICYmIGZpZWxkc1sxXSxcbiAgICAgICAgZ2VvanNvbiA9IF8uZ2VvanNvbiB8fCAhZmllbGRzICYmIGlkZW50aXR5LFxuICAgICAgICBmbGFnID0gcHVsc2UuQURELFxuICAgICAgICBtb2Q7XG4gICAgbW9kID0gXy5tb2RpZmllZCgpIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuUkVNKSB8fCBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyhnZW9qc29uKSkgfHwgbG9uICYmIHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKGxvbikpIHx8IGxhdCAmJiBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyhsYXQpKTtcblxuICAgIGlmICghdGhpcy52YWx1ZSB8fCBtb2QpIHtcbiAgICAgIGZsYWcgPSBwdWxzZS5TT1VSQ0U7XG4gICAgICB0aGlzLl9mZWF0dXJlcyA9IGZlYXR1cmVzID0gW107XG4gICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoZ2VvanNvbikge1xuICAgICAgcHVsc2UudmlzaXQoZmxhZywgdCA9PiBmZWF0dXJlcy5wdXNoKGdlb2pzb24odCkpKTtcbiAgICB9XG5cbiAgICBpZiAobG9uICYmIGxhdCkge1xuICAgICAgcHVsc2UudmlzaXQoZmxhZywgdCA9PiB7XG4gICAgICAgIHZhciB4ID0gbG9uKHQpLFxuICAgICAgICAgICAgeSA9IGxhdCh0KTtcblxuICAgICAgICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbCAmJiAoeCA9ICt4KSA9PT0geCAmJiAoeSA9ICt5KSA9PT0geSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKFt4LCB5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZmVhdHVyZXMgPSBmZWF0dXJlcy5jb25jYXQoe1xuICAgICAgICB0eXBlOiBGZWF0dXJlLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6IE11bHRpUG9pbnQsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHBvaW50c1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0ge1xuICAgICAgdHlwZTogRmVhdHVyZUNvbGxlY3Rpb24sXG4gICAgICBmZWF0dXJlczogZmVhdHVyZXNcbiAgICB9O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIE1hcCBHZW9KU09OIGRhdGEgdG8gYW4gU1ZHIHBhdGggc3RyaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogKn0gcGFyYW1zLnByb2plY3Rpb24gLSBUaGUgY2FydG9ncmFwaGljXG4gKiAgIHByb2plY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IFtwYXJhbXMuZmllbGRdIC0gVGhlIGZpZWxkIHdpdGggR2VvSlNPTiBkYXRhLFxuICogICBvciBudWxsIGlmIHRoZSB0dXBsZSBpdHNlbGYgaXMgYSBHZW9KU09OIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5hcz0ncGF0aCddIC0gVGhlIG91dHB1dCBmaWVsZCBpbiB3aGljaCB0byBzdG9yZVxuICogICB0aGUgZ2VuZXJhdGVkIHBhdGggZGF0YSAoZGVmYXVsdCAncGF0aCcpLlxuICovXG5cbmZ1bmN0aW9uIEdlb1BhdGgocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5HZW9QYXRoLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0dlb1BhdGgnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdwcm9qZWN0aW9uJyxcbiAgICAndHlwZSc6ICdwcm9qZWN0aW9uJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAncG9pbnRSYWRpdXMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2V4cHInOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdwYXRoJ1xuICB9XVxufTtcbmluaGVyaXRzKEdlb1BhdGgsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLFxuICAgICAgICBwYXRoID0gdGhpcy52YWx1ZSxcbiAgICAgICAgZmllbGQgPSBfLmZpZWxkIHx8IGlkZW50aXR5LFxuICAgICAgICBhcyA9IF8uYXMgfHwgJ3BhdGgnLFxuICAgICAgICBmbGFnID0gb3V0LlNPVVJDRTtcblxuICAgIGlmICghcGF0aCB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIC8vIHBhcmFtZXRlcnMgdXBkYXRlZCwgcmVzZXQgYW5kIHJlZmxvd1xuICAgICAgdGhpcy52YWx1ZSA9IHBhdGggPSBnZXRQcm9qZWN0aW9uUGF0aChfLnByb2plY3Rpb24pO1xuICAgICAgb3V0Lm1hdGVyaWFsaXplKCkucmVmbG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWcgPSBmaWVsZCA9PT0gaWRlbnRpdHkgfHwgcHVsc2UubW9kaWZpZWQoZmllbGQuZmllbGRzKSA/IG91dC5BRERfTU9EIDogb3V0LkFERDtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2ID0gaW5pdFBhdGgocGF0aCwgXy5wb2ludFJhZGl1cyk7XG4gICAgb3V0LnZpc2l0KGZsYWcsIHQgPT4gdFthc10gPSBwYXRoKGZpZWxkKHQpKSk7XG4gICAgcGF0aC5wb2ludFJhZGl1cyhwcmV2KTtcbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gaW5pdFBhdGgocGF0aCwgcG9pbnRSYWRpdXMpIHtcbiAgY29uc3QgcHJldiA9IHBhdGgucG9pbnRSYWRpdXMoKTtcbiAgcGF0aC5jb250ZXh0KG51bGwpO1xuXG4gIGlmIChwb2ludFJhZGl1cyAhPSBudWxsKSB7XG4gICAgcGF0aC5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gIH1cblxuICByZXR1cm4gcHJldjtcbn1cblxuLyoqXG4gKiBHZW8tY29kZSBhIGxvbmdpdHVkZS9sYXRpdHVkZSBwb2ludCB0byBhbiB4L3kgY29vcmRpbmF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcik6ICp9IHBhcmFtcy5wcm9qZWN0aW9uIC0gVGhlIGNhcnRvZ3JhcGhpY1xuICogICBwcm9qZWN0aW9uIHRvIGFwcGx5LlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gcGFyYW1zLmZpZWxkcyAtIEEgdHdvLWVsZW1lbnQgYXJyYXkgb2ZcbiAqICAgZmllbGQgYWNjZXNzb3JzIGZvciB0aGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gQSB0d28tZWxlbWVudCBhcnJheSBvZiBmaWVsZCBuYW1lc1xuICogICB1bmRlciB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LiBEZWZhdWx0cyB0byBbJ3gnLCd5J10uXG4gKi9cblxuZnVuY3Rpb24gR2VvUG9pbnQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5HZW9Qb2ludC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdHZW9Qb2ludCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3Byb2plY3Rpb24nLFxuICAgICd0eXBlJzogJ3Byb2plY3Rpb24nLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsneCcsICd5J11cbiAgfV1cbn07XG5pbmhlcml0cyhHZW9Qb2ludCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBwcm9qID0gXy5wcm9qZWN0aW9uLFxuICAgICAgICBsb24gPSBfLmZpZWxkc1swXSxcbiAgICAgICAgbGF0ID0gXy5maWVsZHNbMV0sXG4gICAgICAgIGFzID0gXy5hcyB8fCBbJ3gnLCAneSddLFxuICAgICAgICB4ID0gYXNbMF0sXG4gICAgICAgIHkgPSBhc1sxXSxcbiAgICAgICAgbW9kO1xuXG4gICAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICAgIGNvbnN0IHh5ID0gcHJvaihbbG9uKHQpLCBsYXQodCldKTtcblxuICAgICAgaWYgKHh5KSB7XG4gICAgICAgIHRbeF0gPSB4eVswXTtcbiAgICAgICAgdFt5XSA9IHh5WzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdFt4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdFt5XSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXy5tb2RpZmllZCgpKSB7XG4gICAgICAvLyBwYXJhbWV0ZXJzIHVwZGF0ZWQsIHJlZmxvd1xuICAgICAgcHVsc2UgPSBwdWxzZS5tYXRlcmlhbGl6ZSgpLnJlZmxvdyh0cnVlKS52aXNpdChwdWxzZS5TT1VSQ0UsIHNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZCA9IHB1bHNlLm1vZGlmaWVkKGxvbi5maWVsZHMpIHx8IHB1bHNlLm1vZGlmaWVkKGxhdC5maWVsZHMpO1xuICAgICAgcHVsc2UudmlzaXQobW9kID8gcHVsc2UuQUREX01PRCA6IHB1bHNlLkFERCwgc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2UubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEFubm90YXRlIGl0ZW1zIHdpdGggYSBnZW9wYXRoIHNoYXBlIGdlbmVyYXRvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcik6ICp9IHBhcmFtcy5wcm9qZWN0aW9uIC0gVGhlIGNhcnRvZ3JhcGhpY1xuICogICBwcm9qZWN0aW9uIHRvIGFwcGx5LlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBbcGFyYW1zLmZpZWxkXSAtIFRoZSBmaWVsZCB3aXRoIEdlb0pTT04gZGF0YSxcbiAqICAgb3IgbnVsbCBpZiB0aGUgdHVwbGUgaXRzZWxmIGlzIGEgR2VvSlNPTiBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuYXM9J3NoYXBlJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgcGF0aCBkYXRhIChkZWZhdWx0ICdzaGFwZScpLlxuICovXG5cbmZ1bmN0aW9uIEdlb1NoYXBlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuR2VvU2hhcGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnR2VvU2hhcGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZSxcbiAgICAnbm9tb2QnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3Byb2plY3Rpb24nLFxuICAgICd0eXBlJzogJ3Byb2plY3Rpb24nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdkZWZhdWx0JzogJ2RhdHVtJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAncG9pbnRSYWRpdXMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2V4cHInOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdzaGFwZSdcbiAgfV1cbn07XG5pbmhlcml0cyhHZW9TaGFwZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFMTCksXG4gICAgICAgIHNoYXBlID0gdGhpcy52YWx1ZSxcbiAgICAgICAgYXMgPSBfLmFzIHx8ICdzaGFwZScsXG4gICAgICAgIGZsYWcgPSBvdXQuQUREO1xuXG4gICAgaWYgKCFzaGFwZSB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIC8vIHBhcmFtZXRlcnMgdXBkYXRlZCwgcmVzZXQgYW5kIHJlZmxvd1xuICAgICAgdGhpcy52YWx1ZSA9IHNoYXBlID0gc2hhcGVHZW5lcmF0b3IoZ2V0UHJvamVjdGlvblBhdGgoXy5wcm9qZWN0aW9uKSwgXy5maWVsZCB8fCBmaWVsZCgnZGF0dW0nKSwgXy5wb2ludFJhZGl1cyk7XG4gICAgICBvdXQubWF0ZXJpYWxpemUoKS5yZWZsb3coKTtcbiAgICAgIGZsYWcgPSBvdXQuU09VUkNFO1xuICAgIH1cblxuICAgIG91dC52aXNpdChmbGFnLCB0ID0+IHRbYXNdID0gc2hhcGUpO1xuICAgIHJldHVybiBvdXQubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzaGFwZUdlbmVyYXRvcihwYXRoLCBmaWVsZCwgcG9pbnRSYWRpdXMpIHtcbiAgY29uc3Qgc2hhcGUgPSBwb2ludFJhZGl1cyA9PSBudWxsID8gXyA9PiBwYXRoKGZpZWxkKF8pKSA6IF8gPT4ge1xuICAgIHZhciBwcmV2ID0gcGF0aC5wb2ludFJhZGl1cygpLFxuICAgICAgICB2YWx1ZSA9IHBhdGgucG9pbnRSYWRpdXMocG9pbnRSYWRpdXMpKGZpZWxkKF8pKTtcbiAgICBwYXRoLnBvaW50UmFkaXVzKHByZXYpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBzaGFwZS5jb250ZXh0ID0gXyA9PiB7XG4gICAgcGF0aC5jb250ZXh0KF8pO1xuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcblxuICByZXR1cm4gc2hhcGU7XG59XG5cbi8qKlxuICogR2VvSlNPTiBmZWF0dXJlIGdlbmVyYXRvciBmb3IgY3JlYXRpbmcgZ3JhdGljdWxlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIEdyYXRpY3VsZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG4gIHRoaXMuZ2VuZXJhdG9yID0gZ2VvR3JhdGljdWxlKCk7XG59XG5HcmF0aWN1bGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnR3JhdGljdWxlJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdjaGFuZ2VzJzogdHJ1ZSxcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdleHRlbnQnLFxuICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdjb250ZW50Jzoge1xuICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICdhcnJheSc6IHRydWUsXG4gICAgICAnbGVuZ3RoJzogMlxuICAgIH1cbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudE1ham9yJyxcbiAgICAndHlwZSc6ICdhcnJheScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnY29udGVudCc6IHtcbiAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAnYXJyYXknOiB0cnVlLFxuICAgICAgJ2xlbmd0aCc6IDJcbiAgICB9XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdleHRlbnRNaW5vcicsXG4gICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2NvbnRlbnQnOiB7XG4gICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAgICdsZW5ndGgnOiAyXG4gICAgfVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwTWFqb3InLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFs5MCwgMzYwXVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcE1pbm9yJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBbMTAsIDEwXVxuICB9LCB7XG4gICAgJ25hbWUnOiAncHJlY2lzaW9uJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMi41XG4gIH1dXG59O1xuaW5oZXJpdHMoR3JhdGljdWxlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIHNyYyA9IHRoaXMudmFsdWUsXG4gICAgICAgIGdlbiA9IHRoaXMuZ2VuZXJhdG9yLFxuICAgICAgICB0O1xuXG4gICAgaWYgKCFzcmMubGVuZ3RoIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgZm9yIChjb25zdCBwcm9wIGluIF8pIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZ2VuW3Byb3BdKSkge1xuICAgICAgICAgIGdlbltwcm9wXShfW3Byb3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHQgPSBnZW4oKTtcblxuICAgIGlmIChzcmMubGVuZ3RoKSB7XG4gICAgICBwdWxzZS5tb2QucHVzaChyZXBsYWNlKHNyY1swXSwgdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWxzZS5hZGQucHVzaChpbmdlc3QodCkpO1xuICAgIH1cblxuICAgIHNyY1swXSA9IHQ7XG4gICAgcmV0dXJuIHB1bHNlO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFJlbmRlciBhIGhlYXRtYXAgaW1hZ2UgZm9yIGlucHV0IHJhc3RlciBncmlkIGRhdGEuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gW3BhcmFtcy5maWVsZF0gLSBUaGUgZmllbGQgd2l0aCByYXN0ZXIgZ3JpZFxuICogICBkYXRhLiBJZiB1bnNwZWNpZmllZCwgdGhlIHR1cGxlIGl0c2VsZiBpcyBpbnRlcnByZXRlZCBhcyBhIHJhc3RlciBncmlkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY29sb3JdIC0gQSBjb25zdGFudCBjb2xvciB2YWx1ZSBvciBmdW5jdGlvbiBmb3JcbiAqICAgaW5kaXZpZHVhbCBwaXhlbCBjb2xvci4gSWYgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gaW5wdXRcbiAqICAgb2JqZWN0IHRoYXQgaW5jbHVkZXMgJHgsICR5LCAkdmFsdWUsIGFuZCAkbWF4IGZpZWxkcyBmb3IgdGhlIGdyaWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5vcGFjaXR5XSAtIEEgY29uc3RhbnQgb3BhY2l0eSB2YWx1ZSBvciBmdW5jdGlvbiBmb3JcbiAqICAgaW5kaXZpZHVhbCBwaXhlbCBvcGFjaXR5LiBJZiBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCBhbiBpbnB1dFxuICogICBvYmplY3QgdGhhdCBpbmNsdWRlcyAkeCwgJHksICR2YWx1ZSwgYW5kICRtYXggZmllbGRzIGZvciB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnJlc29sdmVdIC0gVGhlIG1ldGhvZCBmb3IgcmVzb2x2aW5nIG1heGltdW0gdmFsdWVzXG4gKiAgIGFjcm9zcyBtdWx0aXBsZSBpbnB1dCBncmlkcy4gSWYgJ2luZGVwZW5kZW50JyAodGhlIGRlZmF1bHQpLCBtYXhpbXVtXG4gKiAgIGNhbGN1bGF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkIHNlcGFyYXRlbHkgZm9yIGVhY2ggZ3JpZC4gSWYgJ3NoYXJlZCcsXG4gKiAgIGEgc2luZ2xlIGdsb2JhbCBtYXhpbXVtIHdpbGwgYmUgdXNlZCBmb3IgYWxsIGlucHV0IGdyaWRzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuYXM9J2ltYWdlJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgYml0bWFwIGNhbnZhcyBpbWFnZXMgKGRlZmF1bHQgJ2ltYWdlJykuXG4gKi9cblxuZnVuY3Rpb24gSGVhdG1hcChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkhlYXRtYXAuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnaGVhdG1hcCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ2NvbG9yJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3BhY2l0eScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3Jlc29sdmUnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBbJ3NoYXJlZCcsICdpbmRlcGVuZGVudCddLFxuICAgICdkZWZhdWx0JzogJ2luZGVwZW5kZW50J1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAnaW1hZ2UnXG4gIH1dXG59O1xuaW5oZXJpdHMoSGVhdG1hcCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICghcHVsc2UuY2hhbmdlZCgpICYmICFfLm1vZGlmaWVkKCkpIHtcbiAgICAgIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICBzaGFyZWQgPSBfLnJlc29sdmUgPT09ICdzaGFyZWQnLFxuICAgICAgICBmaWVsZCA9IF8uZmllbGQgfHwgaWRlbnRpdHksXG4gICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5XyhfLm9wYWNpdHksIF8pLFxuICAgICAgICBjb2xvciA9IGNvbG9yXyhfLmNvbG9yLCBfKSxcbiAgICAgICAgYXMgPSBfLmFzIHx8ICdpbWFnZScsXG4gICAgICAgIG9iaiA9IHtcbiAgICAgICR4OiAwLFxuICAgICAgJHk6IDAsXG4gICAgICAkdmFsdWU6IDAsXG4gICAgICAkbWF4OiBzaGFyZWQgPyBtYXgoc291cmNlLm1hcCh0ID0+IG1heChmaWVsZCh0KS52YWx1ZXMpKSkgOiAwXG4gICAgfTtcbiAgICBzb3VyY2UuZm9yRWFjaCh0ID0+IHtcbiAgICAgIGNvbnN0IHYgPSBmaWVsZCh0KTsgLy8gYnVpbGQgcHJveHkgZGF0YSBvYmplY3RcblxuICAgICAgY29uc3QgbyA9IGV4dGVuZCh7fSwgdCwgb2JqKTsgLy8gc2V0IG1heGltdW0gdmFsdWUgaWYgbm90IGdsb2JhbGx5IHNoYXJlZFxuXG4gICAgICBpZiAoIXNoYXJlZCkgby4kbWF4ID0gbWF4KHYudmFsdWVzIHx8IFtdKTsgLy8gZ2VuZXJhdGUgY2FudmFzIGltYWdlXG4gICAgICAvLyBvcHRpbWl6ZSBjb2xvci9vcGFjaXR5IGlmIG5vdCBwaXhlbC1kZXBlbmRlbnRcblxuICAgICAgdFthc10gPSB0b0NhbnZhcyh2LCBvLCBjb2xvci5kZXAgPyBjb2xvciA6IGNvbnN0YW50KGNvbG9yKG8pKSwgb3BhY2l0eS5kZXAgPyBvcGFjaXR5IDogY29uc3RhbnQob3BhY2l0eShvKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3codHJ1ZSkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pOyAvLyBnZXQgaW1hZ2UgY29sb3IgZnVuY3Rpb25cblxuZnVuY3Rpb24gY29sb3JfKGNvbG9yLCBfKSB7XG4gIGxldCBmO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGNvbG9yKSkge1xuICAgIGYgPSBvYmogPT4gcmdiKGNvbG9yKG9iaiwgXykpO1xuXG4gICAgZi5kZXAgPSBkZXBlbmRlbmN5KGNvbG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBkZWZhdWx0IHRvIG1pZC1ncmV5XG4gICAgZiA9IGNvbnN0YW50KHJnYihjb2xvciB8fCAnIzg4OCcpKTtcbiAgfVxuXG4gIHJldHVybiBmO1xufSAvLyBnZXQgaW1hZ2Ugb3BhY2l0eSBmdW5jdGlvblxuXG5cbmZ1bmN0aW9uIG9wYWNpdHlfKG9wYWNpdHksIF8pIHtcbiAgbGV0IGY7XG5cbiAgaWYgKGlzRnVuY3Rpb24ob3BhY2l0eSkpIHtcbiAgICBmID0gb2JqID0+IG9wYWNpdHkob2JqLCBfKTtcblxuICAgIGYuZGVwID0gZGVwZW5kZW5jeShvcGFjaXR5KTtcbiAgfSBlbHNlIGlmIChvcGFjaXR5KSB7XG4gICAgZiA9IGNvbnN0YW50KG9wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlZmF1bHQgdG8gWzAsIG1heF0gb3BhY2l0eSBncmFkaWVudFxuICAgIGYgPSBvYmogPT4gb2JqLiR2YWx1ZSAvIG9iai4kbWF4IHx8IDA7XG5cbiAgICBmLmRlcCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZjtcbn0gLy8gY2hlY2sgaWYgZnVuY3Rpb24gZGVwZW5kcyBvbiBpbmRpdmlkdWFsIHBpeGVsIGRhdGFcblxuXG5mdW5jdGlvbiBkZXBlbmRlbmN5KGYpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGYpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHNldCA9IHRvU2V0KGFjY2Vzc29yRmllbGRzKGYpKTtcbiAgcmV0dXJuIHNldC4keCB8fCBzZXQuJHkgfHwgc2V0LiR2YWx1ZSB8fCBzZXQuJG1heDtcbn0gLy8gcmVuZGVyIHJhc3RlciBncmlkIHRvIGNhbnZhc1xuXG5cbmZ1bmN0aW9uIHRvQ2FudmFzKGdyaWQsIG9iaiwgY29sb3IsIG9wYWNpdHkpIHtcbiAgY29uc3QgbiA9IGdyaWQud2lkdGgsXG4gICAgICAgIG0gPSBncmlkLmhlaWdodCxcbiAgICAgICAgeDEgPSBncmlkLngxIHx8IDAsXG4gICAgICAgIHkxID0gZ3JpZC55MSB8fCAwLFxuICAgICAgICB4MiA9IGdyaWQueDIgfHwgbixcbiAgICAgICAgeTIgPSBncmlkLnkyIHx8IG0sXG4gICAgICAgIHZhbCA9IGdyaWQudmFsdWVzLFxuICAgICAgICB2YWx1ZSA9IHZhbCA/IGkgPT4gdmFsW2ldIDogemVybyxcbiAgICAgICAgY2FuID0gY2FudmFzKHgyIC0geDEsIHkyIC0geTEpLFxuICAgICAgICBjdHggPSBjYW4uZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgaW1nID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB4MiAtIHgxLCB5MiAtIHkxKSxcbiAgICAgICAgcGl4ID0gaW1nLmRhdGE7XG5cbiAgZm9yIChsZXQgaiA9IHkxLCBrID0gMDsgaiA8IHkyOyArK2opIHtcbiAgICBvYmouJHkgPSBqIC0geTE7XG5cbiAgICBmb3IgKGxldCBpID0geDEsIHIgPSBqICogbjsgaSA8IHgyOyArK2ksIGsgKz0gNCkge1xuICAgICAgb2JqLiR4ID0gaSAtIHgxO1xuICAgICAgb2JqLiR2YWx1ZSA9IHZhbHVlKGkgKyByKTtcbiAgICAgIGNvbnN0IHYgPSBjb2xvcihvYmopO1xuICAgICAgcGl4W2sgKyAwXSA9IHYucjtcbiAgICAgIHBpeFtrICsgMV0gPSB2Lmc7XG4gICAgICBwaXhbayArIDJdID0gdi5iO1xuICAgICAgcGl4W2sgKyAzXSA9IH5+KDI1NSAqIG9wYWNpdHkob2JqKSk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnB1dEltYWdlRGF0YShpbWcsIDAsIDApO1xuICByZXR1cm4gY2FuO1xufVxuXG4vKipcbiAqIE1haW50YWlucyBhIGNhcnRvZ3JhcGhpYyBwcm9qZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gUHJvamVjdGlvbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbiAgdGhpcy5tb2RpZmllZCh0cnVlKTsgLy8gYWx3YXlzIHRyZWF0IGFzIG1vZGlmaWVkXG59XG5pbmhlcml0cyhQcm9qZWN0aW9uLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgbGV0IHByb2ogPSB0aGlzLnZhbHVlO1xuXG4gICAgaWYgKCFwcm9qIHx8IF8ubW9kaWZpZWQoJ3R5cGUnKSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHByb2ogPSBjcmVhdGUoXy50eXBlKTtcbiAgICAgIHByb2plY3Rpb25Qcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIGlmIChfW3Byb3BdICE9IG51bGwpIHNldChwcm9qLCBwcm9wLCBfW3Byb3BdKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9qZWN0aW9uUHJvcGVydGllcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBpZiAoXy5tb2RpZmllZChwcm9wKSkgc2V0KHByb2osIHByb3AsIF9bcHJvcF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKF8ucG9pbnRSYWRpdXMgIT0gbnVsbCkgcHJvai5wYXRoLnBvaW50UmFkaXVzKF8ucG9pbnRSYWRpdXMpO1xuICAgIGlmIChfLmZpdCkgZml0KHByb2osIF8pO1xuICAgIHJldHVybiBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIGZpdChwcm9qLCBfKSB7XG4gIGNvbnN0IGRhdGEgPSBjb2xsZWN0R2VvSlNPTihfLmZpdCk7XG4gIF8uZXh0ZW50ID8gcHJvai5maXRFeHRlbnQoXy5leHRlbnQsIGRhdGEpIDogXy5zaXplID8gcHJvai5maXRTaXplKF8uc2l6ZSwgZGF0YSkgOiAwO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSkge1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IHByb2plY3Rpb24oKHR5cGUgfHwgJ21lcmNhdG9yJykudG9Mb3dlckNhc2UoKSk7XG4gIGlmICghY29uc3RydWN0b3IpIGVycm9yKCdVbnJlY29nbml6ZWQgcHJvamVjdGlvbiB0eXBlOiAnICsgdHlwZSk7XG4gIHJldHVybiBjb25zdHJ1Y3RvcigpO1xufVxuXG5mdW5jdGlvbiBzZXQocHJvaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGdW5jdGlvbihwcm9qW2tleV0pKSBwcm9qW2tleV0odmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0R2VvSlNPTihkYXRhKSB7XG4gIGRhdGEgPSBhcnJheShkYXRhKTtcbiAgcmV0dXJuIGRhdGEubGVuZ3RoID09PSAxID8gZGF0YVswXSA6IHtcbiAgICB0eXBlOiBGZWF0dXJlQ29sbGVjdGlvbixcbiAgICBmZWF0dXJlczogZGF0YS5yZWR1Y2UoKGEsIGYpID0+IGEuY29uY2F0KGZlYXR1cml6ZShmKSksIFtdKVxuICB9O1xufVxuXG5mdW5jdGlvbiBmZWF0dXJpemUoZikge1xuICByZXR1cm4gZi50eXBlID09PSBGZWF0dXJlQ29sbGVjdGlvbiA/IGYuZmVhdHVyZXMgOiBhcnJheShmKS5maWx0ZXIoZCA9PiBkICE9IG51bGwpLm1hcChkID0+IGQudHlwZSA9PT0gRmVhdHVyZSA/IGQgOiB7XG4gICAgdHlwZTogRmVhdHVyZSxcbiAgICBnZW9tZXRyeTogZFxuICB9KTtcbn1cblxuZXhwb3J0IHsgQ29udG91ciBhcyBjb250b3VyLCBHZW9KU09OIGFzIGdlb2pzb24sIEdlb1BhdGggYXMgZ2VvcGF0aCwgR2VvUG9pbnQgYXMgZ2VvcG9pbnQsIEdlb1NoYXBlIGFzIGdlb3NoYXBlLCBHcmF0aWN1bGUgYXMgZ3JhdGljdWxlLCBIZWF0bWFwIGFzIGhlYXRtYXAsIElzb2NvbnRvdXIgYXMgaXNvY29udG91ciwgS0RFMkQgYXMga2RlMmQsIFByb2plY3Rpb24gYXMgcHJvamVjdGlvbiB9O1xuIiwiaW1wb3J0IHsgVHJhbnNmb3JtLCBpc1R1cGxlLCBpbmdlc3QsIHR1cGxlaWQsIHN0YWJsZUNvbXBhcmUgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGluaGVyaXRzLCBlcnJvciwgYXJyYXksIG9uZSwgdHJ1dGh5LCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBoaWVyYXJjaHksIHBhY2ssIHBhcnRpdGlvbiwgc3RyYXRpZnksIHRyZWUsIGNsdXN0ZXIsIHRyZWVtYXAsIHRyZWVtYXBCaW5hcnksIHRyZWVtYXBEaWNlLCB0cmVlbWFwU2xpY2UsIHRyZWVtYXBTbGljZURpY2UsIHRyZWVtYXBTcXVhcmlmeSwgdHJlZW1hcFJlc3F1YXJpZnkgfSBmcm9tICdkMy1oaWVyYXJjaHknO1xuXG4vLyBCdWlsZCBsb29rdXAgdGFibGUgbWFwcGluZyB0dXBsZSBrZXlzIHRvIHRyZWUgbm9kZSBpbnN0YW5jZXNcbmZ1bmN0aW9uIGxvb2t1cCAodHJlZSwga2V5LCBmaWx0ZXIpIHtcbiAgY29uc3QgbWFwID0ge307XG4gIHRyZWUuZWFjaChub2RlID0+IHtcbiAgICBjb25zdCB0ID0gbm9kZS5kYXRhO1xuICAgIGlmIChmaWx0ZXIodCkpIG1hcFtrZXkodCldID0gbm9kZTtcbiAgfSk7XG4gIHRyZWUubG9va3VwID0gbWFwO1xuICByZXR1cm4gdHJlZTtcbn1cblxuLyoqXG4gKiBOZXN0IHR1cGxlcyBpbnRvIGEgdHJlZSBzdHJ1Y3R1cmUsIGdyb3VwZWQgYnkga2V5IHZhbHVlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gcGFyYW1zLmtleXMgLSBUaGUga2V5IGZpZWxkcyB0byBuZXN0IGJ5LCBpbiBvcmRlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5nZW5lcmF0ZT1mYWxzZV0gLSBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmXG4gKiAgIG5vbi1sZWFmIG5vZGVzIGdlbmVyYXRlZCBieSB0aGlzIHRyYW5zZm9ybSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlXG4gKiAgIG91dHB1dC4gVGhlIGRlZmF1bHQgKGZhbHNlKSBpbmNsdWRlcyBvbmx5IHRoZSBpbnB1dCBkYXRhIChsZWFmIG5vZGVzKVxuICogICBpbiB0aGUgZGF0YSBzdHJlYW0uXG4gKi9cblxuZnVuY3Rpb24gTmVzdChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbk5lc3QuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnTmVzdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZXNvdXJjZSc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2tleXMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdnZW5lcmF0ZScsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbidcbiAgfV1cbn07XG5cbmNvbnN0IGNoaWxkcmVuID0gbiA9PiBuLnZhbHVlcztcblxuaW5oZXJpdHMoTmVzdCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICghcHVsc2Uuc291cmNlKSB7XG4gICAgICBlcnJvcignTmVzdCB0cmFuc2Zvcm0gcmVxdWlyZXMgYW4gdXBzdHJlYW0gZGF0YSBzb3VyY2UuJyk7XG4gICAgfVxuXG4gICAgdmFyIGdlbiA9IF8uZ2VuZXJhdGUsXG4gICAgICAgIG1vZCA9IF8ubW9kaWZpZWQoKSxcbiAgICAgICAgb3V0ID0gcHVsc2UuY2xvbmUoKSxcbiAgICAgICAgdHJlZSA9IHRoaXMudmFsdWU7XG5cbiAgICBpZiAoIXRyZWUgfHwgbW9kIHx8IHB1bHNlLmNoYW5nZWQoKSkge1xuICAgICAgLy8gY29sbGVjdCBub2RlcyB0byByZW1vdmVcbiAgICAgIGlmICh0cmVlKSB7XG4gICAgICAgIHRyZWUuZWFjaChub2RlID0+IHtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiBpc1R1cGxlKG5vZGUuZGF0YSkpIHtcbiAgICAgICAgICAgIG91dC5yZW0ucHVzaChub2RlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIGdlbmVyYXRlIG5ldyB0cmVlIHN0cnVjdHVyZVxuXG5cbiAgICAgIHRoaXMudmFsdWUgPSB0cmVlID0gaGllcmFyY2h5KHtcbiAgICAgICAgdmFsdWVzOiBhcnJheShfLmtleXMpLnJlZHVjZSgobiwgaykgPT4ge1xuICAgICAgICAgIG4ua2V5KGspO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9LCBuZXN0KCkpLmVudHJpZXMob3V0LnNvdXJjZSlcbiAgICAgIH0sIGNoaWxkcmVuKTsgLy8gY29sbGVjdCBub2RlcyB0byBhZGRcblxuICAgICAgaWYgKGdlbikge1xuICAgICAgICB0cmVlLmVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG5vZGUgPSBpbmdlc3Qobm9kZS5kYXRhKTtcbiAgICAgICAgICAgIG91dC5hZGQucHVzaChub2RlKTtcbiAgICAgICAgICAgIG91dC5zb3VyY2UucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBidWlsZCBsb29rdXAgdGFibGVcblxuXG4gICAgICBsb29rdXAodHJlZSwgdHVwbGVpZCwgdHVwbGVpZCk7XG4gICAgfVxuXG4gICAgb3V0LnNvdXJjZS5yb290ID0gdHJlZTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBuZXN0KCkge1xuICBjb25zdCBrZXlzID0gW10sXG4gICAgICAgIG5lc3QgPSB7XG4gICAgZW50cmllczogYXJyYXkgPT4gZW50cmllcyhhcHBseShhcnJheSwgMCksIDApLFxuICAgIGtleTogZCA9PiAoa2V5cy5wdXNoKGQpLCBuZXN0KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGFwcGx5KGFycmF5LCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIGNvbnN0IG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAga2V5ID0ga2V5c1tkZXB0aCsrXSxcbiAgICAgICAgICB2YWx1ZXNCeUtleSA9IHt9LFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgIGxldCBpID0gLTEsXG4gICAgICAgIGtleVZhbHVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWVzO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGtleVZhbHVlID0ga2V5KHZhbHVlID0gYXJyYXlbaV0pICsgJyc7XG5cbiAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleVtrZXlWYWx1ZV0pIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQnlLZXlba2V5VmFsdWVdID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGtleVZhbHVlIGluIHZhbHVlc0J5S2V5KSB7XG4gICAgICByZXN1bHRba2V5VmFsdWVdID0gYXBwbHkodmFsdWVzQnlLZXlba2V5VmFsdWVdLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVudHJpZXMobWFwLCBkZXB0aCkge1xuICAgIGlmICgrK2RlcHRoID4ga2V5cy5sZW5ndGgpIHJldHVybiBtYXA7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVzOiBlbnRyaWVzKG1hcFtrZXldLCBkZXB0aClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIHJldHVybiBuZXN0O1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGZvciB0cmVlIGxheW91dC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIEhpZXJhcmNoeUxheW91dChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblxuY29uc3QgZGVmYXVsdFNlcGFyYXRpb24gPSAoYSwgYikgPT4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XG5cbmluaGVyaXRzKEhpZXJhcmNoeUxheW91dCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICghcHVsc2Uuc291cmNlIHx8ICFwdWxzZS5zb3VyY2Uucm9vdCkge1xuICAgICAgZXJyb3IodGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyB0cmFuc2Zvcm0gcmVxdWlyZXMgYSBiYWNraW5nIHRyZWUgZGF0YSBzb3VyY2UuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5sYXlvdXQoXy5tZXRob2QpLFxuICAgICAgICAgIGZpZWxkcyA9IHRoaXMuZmllbGRzLFxuICAgICAgICAgIHJvb3QgPSBwdWxzZS5zb3VyY2Uucm9vdCxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgZmllbGRzO1xuICAgIGlmIChfLmZpZWxkKSByb290LnN1bShfLmZpZWxkKTtlbHNlIHJvb3QuY291bnQoKTtcbiAgICBpZiAoXy5zb3J0KSByb290LnNvcnQoc3RhYmxlQ29tcGFyZShfLnNvcnQsIGQgPT4gZC5kYXRhKSk7XG4gICAgc2V0UGFyYW1zKGxheW91dCwgdGhpcy5wYXJhbXMsIF8pO1xuXG4gICAgaWYgKGxheW91dC5zZXBhcmF0aW9uKSB7XG4gICAgICBsYXlvdXQuc2VwYXJhdGlvbihfLnNlcGFyYXRpb24gIT09IGZhbHNlID8gZGVmYXVsdFNlcGFyYXRpb24gOiBvbmUpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnZhbHVlID0gbGF5b3V0KHJvb3QpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICByb290LmVhY2gobm9kZSA9PiBzZXRGaWVsZHMobm9kZSwgZmllbGRzLCBhcykpO1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3coXy5tb2RpZmllZCgpKS5tb2RpZmllcyhhcykubW9kaWZpZXMoJ2xlYWYnKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gc2V0UGFyYW1zKGxheW91dCwgcGFyYW1zLCBfKSB7XG4gIGZvciAobGV0IHAsIGkgPSAwLCBuID0gcGFyYW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHAgPSBwYXJhbXNbaV07XG4gICAgaWYgKHAgaW4gXykgbGF5b3V0W3BdKF9bcF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEZpZWxkcyhub2RlLCBmaWVsZHMsIGFzKSB7XG4gIGNvbnN0IHQgPSBub2RlLmRhdGEsXG4gICAgICAgIG4gPSBmaWVsZHMubGVuZ3RoIC0gMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHRbYXNbaV1dID0gbm9kZVtmaWVsZHNbaV1dO1xuICB9XG5cbiAgdFthc1tuXV0gPSBub2RlLmNoaWxkcmVuID8gbm9kZS5jaGlsZHJlbi5sZW5ndGggOiAwO1xufVxuXG5jb25zdCBPdXRwdXQgPSBbJ3gnLCAneScsICdyJywgJ2RlcHRoJywgJ2NoaWxkcmVuJ107XG4vKipcbiAqIFBhY2tlZCBjaXJjbGUgdHJlZSBsYXlvdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIHNpemUgbm9kZXMuXG4gKi9cblxuZnVuY3Rpb24gUGFjayhwYXJhbXMpIHtcbiAgSGllcmFyY2h5TGF5b3V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cblBhY2suRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUGFjaycsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZSc6IHRydWUsXG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3JhZGl1cycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdkZWZhdWx0JzogbnVsbFxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiBPdXRwdXQubGVuZ3RoLFxuICAgICdkZWZhdWx0JzogT3V0cHV0XG4gIH1dXG59O1xuaW5oZXJpdHMoUGFjaywgSGllcmFyY2h5TGF5b3V0LCB7XG4gIGxheW91dDogcGFjayxcbiAgcGFyYW1zOiBbJ3JhZGl1cycsICdzaXplJywgJ3BhZGRpbmcnXSxcbiAgZmllbGRzOiBPdXRwdXRcbn0pO1xuXG5jb25zdCBPdXRwdXQkMSA9IFsneDAnLCAneTAnLCAneDEnLCAneTEnLCAnZGVwdGgnLCAnY2hpbGRyZW4nXTtcbi8qKlxuICogUGFydGl0aW9uIHRyZWUgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBzaXplIG5vZGVzLlxuICovXG5cbmZ1bmN0aW9uIFBhcnRpdGlvbihwYXJhbXMpIHtcbiAgSGllcmFyY2h5TGF5b3V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cblBhcnRpdGlvbi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdQYXJ0aXRpb24nLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3RyZWUnOiB0cnVlLFxuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmcnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyb3VuZCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiBPdXRwdXQkMS5sZW5ndGgsXG4gICAgJ2RlZmF1bHQnOiBPdXRwdXQkMVxuICB9XVxufTtcbmluaGVyaXRzKFBhcnRpdGlvbiwgSGllcmFyY2h5TGF5b3V0LCB7XG4gIGxheW91dDogcGFydGl0aW9uLFxuICBwYXJhbXM6IFsnc2l6ZScsICdyb3VuZCcsICdwYWRkaW5nJ10sXG4gIGZpZWxkczogT3V0cHV0JDFcbn0pO1xuXG4vKipcbiAqIFN0cmF0aWZ5IGEgY29sbGVjdGlvbiBvZiB0dXBsZXMgaW50byBhIHRyZWUgc3RydWN0dXJlIGJhc2VkIG9uXG4gKiBpZCBhbmQgcGFyZW50IGlkIGZpZWxkcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMua2V5IC0gVW5pcXVlIGtleSBmaWVsZCBmb3IgZWFjaCB0dXBsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLnBhcmVudEtleSAtIEZpZWxkIHdpdGgga2V5IGZvciBwYXJlbnQgdHVwbGUuXG4gKi9cblxuZnVuY3Rpb24gU3RyYXRpZnkocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5TdHJhdGlmeS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdTdHJhdGlmeScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZXNvdXJjZSc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAna2V5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFyZW50S2V5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKFN0cmF0aWZ5LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKCFwdWxzZS5zb3VyY2UpIHtcbiAgICAgIGVycm9yKCdTdHJhdGlmeSB0cmFuc2Zvcm0gcmVxdWlyZXMgYW4gdXBzdHJlYW0gZGF0YSBzb3VyY2UuJyk7XG4gICAgfVxuXG4gICAgbGV0IHRyZWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgY29uc3QgbW9kID0gXy5tb2RpZmllZCgpLFxuICAgICAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUxMKS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLFxuICAgICAgICAgIHJ1biA9ICF0cmVlIHx8IG1vZCB8fCBwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERF9SRU0pIHx8IHB1bHNlLm1vZGlmaWVkKF8ua2V5LmZpZWxkcykgfHwgcHVsc2UubW9kaWZpZWQoXy5wYXJlbnRLZXkuZmllbGRzKTsgLy8gcHJldmVudCB1cHN0cmVhbSBzb3VyY2UgcG9sbHV0aW9uXG5cblxuICAgIG91dC5zb3VyY2UgPSBvdXQuc291cmNlLnNsaWNlKCk7XG5cbiAgICBpZiAocnVuKSB7XG4gICAgICB0cmVlID0gb3V0LnNvdXJjZS5sZW5ndGggPyBsb29rdXAoc3RyYXRpZnkoKS5pZChfLmtleSkucGFyZW50SWQoXy5wYXJlbnRLZXkpKG91dC5zb3VyY2UpLCBfLmtleSwgdHJ1dGh5KSA6IGxvb2t1cChzdHJhdGlmeSgpKFt7fV0pLCBfLmtleSwgXy5rZXkpO1xuICAgIH1cblxuICAgIG91dC5zb3VyY2Uucm9vdCA9IHRoaXMudmFsdWUgPSB0cmVlO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmNvbnN0IExheW91dHMgPSB7XG4gIHRpZHk6IHRyZWUsXG4gIGNsdXN0ZXI6IGNsdXN0ZXJcbn07XG5jb25zdCBPdXRwdXQkMiA9IFsneCcsICd5JywgJ2RlcHRoJywgJ2NoaWxkcmVuJ107XG4vKipcbiAqIFRyZWUgbGF5b3V0LiBEZXBlbmRpbmcgb24gdGhlIG1ldGhvZCBwYXJhbWV0ZXIsIHBlcmZvcm1zIGVpdGhlclxuICogUmVpbmdvbGQtVGlsZm9yZCAndGlkeScgbGF5b3V0IG9yIGRlbmRyb2dyYW0gJ2NsdXN0ZXInIGxheW91dC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIFRyZWUocGFyYW1zKSB7XG4gIEhpZXJhcmNoeUxheW91dC5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5UcmVlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1RyZWUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3RyZWUnOiB0cnVlLFxuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ21ldGhvZCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAndGlkeScsXG4gICAgJ3ZhbHVlcyc6IFsndGlkeScsICdjbHVzdGVyJ11cbiAgfSwge1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnbm9kZVNpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2VwYXJhdGlvbicsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiBPdXRwdXQkMi5sZW5ndGgsXG4gICAgJ2RlZmF1bHQnOiBPdXRwdXQkMlxuICB9XVxufTtcbmluaGVyaXRzKFRyZWUsIEhpZXJhcmNoeUxheW91dCwge1xuICAvKipcbiAgICogVHJlZSBsYXlvdXQgZ2VuZXJhdG9yLiBTdXBwb3J0cyBib3RoICd0aWR5JyBhbmQgJ2NsdXN0ZXInIGxheW91dHMuXG4gICAqL1xuICBsYXlvdXQobWV0aG9kKSB7XG4gICAgY29uc3QgbSA9IG1ldGhvZCB8fCAndGlkeSc7XG4gICAgaWYgKGhhc093blByb3BlcnR5KExheW91dHMsIG0pKSByZXR1cm4gTGF5b3V0c1ttXSgpO2Vsc2UgZXJyb3IoJ1VucmVjb2duaXplZCBUcmVlIGxheW91dCBtZXRob2Q6ICcgKyBtKTtcbiAgfSxcblxuICBwYXJhbXM6IFsnc2l6ZScsICdub2RlU2l6ZSddLFxuICBmaWVsZHM6IE91dHB1dCQyXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0dXBsZXMgcmVwcmVzZW50aW5nIGxpbmtzIGJldHdlZW4gdHJlZSBub2Rlcy5cbiAqIFRoZSByZXN1bHRpbmcgdHVwbGVzIHdpbGwgY29udGFpbiAnc291cmNlJyBhbmQgJ3RhcmdldCcgZmllbGRzLFxuICogd2hpY2ggcG9pbnQgdG8gcGFyZW50IGFuZCBjaGlsZCBub2RlIHR1cGxlcywgcmVzcGVjdGl2ZWx5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gVHJlZUxpbmtzKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbn1cblRyZWVMaW5rcy5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdUcmVlTGlua3MnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3RyZWUnOiB0cnVlLFxuICAgICdnZW5lcmF0ZXMnOiB0cnVlLFxuICAgICdjaGFuZ2VzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW11cbn07XG5pbmhlcml0cyhUcmVlTGlua3MsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBsaW5rcyA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgdHJlZSA9IHB1bHNlLnNvdXJjZSAmJiBwdWxzZS5zb3VyY2Uucm9vdCxcbiAgICAgICAgICBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksXG4gICAgICAgICAgbHV0ID0ge307XG4gICAgaWYgKCF0cmVlKSBlcnJvcignVHJlZUxpbmtzIHRyYW5zZm9ybSByZXF1aXJlcyBhIHRyZWUgZGF0YSBzb3VyY2UuJyk7XG5cbiAgICBpZiAocHVsc2UuY2hhbmdlZChwdWxzZS5BRERfUkVNKSkge1xuICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIGxpbmtzXG4gICAgICBvdXQucmVtID0gbGlua3M7IC8vIGJ1aWxkIGxvb2t1cCB0YWJsZSBvZiB2YWxpZCB0dXBsZXNcblxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IGx1dFt0dXBsZWlkKHQpXSA9IDEpOyAvLyBnZW5lcmF0ZSBsaW5rcyBmb3IgYWxsIGVkZ2VzIGluY2lkZW50IG9uIHZhbGlkIHR1cGxlc1xuXG4gICAgICB0cmVlLmVhY2gobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHQgPSBub2RlLmRhdGEsXG4gICAgICAgICAgICAgIHAgPSBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5kYXRhO1xuXG4gICAgICAgIGlmIChwICYmIGx1dFt0dXBsZWlkKHQpXSAmJiBsdXRbdHVwbGVpZChwKV0pIHtcbiAgICAgICAgICBvdXQuYWRkLnB1c2goaW5nZXN0KHtcbiAgICAgICAgICAgIHNvdXJjZTogcCxcbiAgICAgICAgICAgIHRhcmdldDogdFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnZhbHVlID0gb3V0LmFkZDtcbiAgICB9IGVsc2UgaWYgKHB1bHNlLmNoYW5nZWQocHVsc2UuTU9EKSkge1xuICAgICAgLy8gYnVpbGQgbG9va3VwIHRhYmxlIG9mIG1vZGlmaWVkIHR1cGxlc1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IGx1dFt0dXBsZWlkKHQpXSA9IDEpOyAvLyBnYXRoZXIgbGlua3MgaW5jaWRlbnQgb24gbW9kaWZpZWQgdHVwbGVzXG5cbiAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgIGlmIChsdXRbdHVwbGVpZChsaW5rLnNvdXJjZSldIHx8IGx1dFt0dXBsZWlkKGxpbmsudGFyZ2V0KV0pIHtcbiAgICAgICAgICBvdXQubW9kLnB1c2gobGluayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmNvbnN0IFRpbGVzID0ge1xuICBiaW5hcnk6IHRyZWVtYXBCaW5hcnksXG4gIGRpY2U6IHRyZWVtYXBEaWNlLFxuICBzbGljZTogdHJlZW1hcFNsaWNlLFxuICBzbGljZWRpY2U6IHRyZWVtYXBTbGljZURpY2UsXG4gIHNxdWFyaWZ5OiB0cmVlbWFwU3F1YXJpZnksXG4gIHJlc3F1YXJpZnk6IHRyZWVtYXBSZXNxdWFyaWZ5XG59O1xuY29uc3QgT3V0cHV0JDMgPSBbJ3gwJywgJ3kwJywgJ3gxJywgJ3kxJywgJ2RlcHRoJywgJ2NoaWxkcmVuJ107XG4vKipcbiAqIFRyZWVtYXAgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBzaXplIG5vZGVzLlxuICovXG5cbmZ1bmN0aW9uIFRyZWVtYXAocGFyYW1zKSB7XG4gIEhpZXJhcmNoeUxheW91dC5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5UcmVlbWFwLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1RyZWVtYXAnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3RyZWUnOiB0cnVlLFxuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ21ldGhvZCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAnc3F1YXJpZnknLFxuICAgICd2YWx1ZXMnOiBbJ3NxdWFyaWZ5JywgJ3Jlc3F1YXJpZnknLCAnYmluYXJ5JywgJ2RpY2UnLCAnc2xpY2UnLCAnc2xpY2VkaWNlJ11cbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmcnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nSW5uZXInLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nT3V0ZXInLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nVG9wJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZ1JpZ2h0JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZ0JvdHRvbScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmdMZWZ0JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncmF0aW8nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxLjYxODAzMzk4ODc0OTg5NVxuICB9LCB7XG4gICAgJ25hbWUnOiAncm91bmQnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogT3V0cHV0JDMubGVuZ3RoLFxuICAgICdkZWZhdWx0JzogT3V0cHV0JDNcbiAgfV1cbn07XG5pbmhlcml0cyhUcmVlbWFwLCBIaWVyYXJjaHlMYXlvdXQsIHtcbiAgLyoqXG4gICAqIFRyZWVtYXAgbGF5b3V0IGdlbmVyYXRvci4gQWRkcyAnbWV0aG9kJyBhbmQgJ3JhdGlvJyBwYXJhbWV0ZXJzXG4gICAqIHRvIGNvbmZpZ3VyZSB0aGUgdW5kZXJseWluZyB0aWxlIG1ldGhvZC5cbiAgICovXG4gIGxheW91dCgpIHtcbiAgICBjb25zdCB4ID0gdHJlZW1hcCgpO1xuXG4gICAgeC5yYXRpbyA9IF8gPT4ge1xuICAgICAgY29uc3QgdCA9IHgudGlsZSgpO1xuICAgICAgaWYgKHQucmF0aW8pIHgudGlsZSh0LnJhdGlvKF8pKTtcbiAgICB9O1xuXG4gICAgeC5tZXRob2QgPSBfID0+IHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShUaWxlcywgXykpIHgudGlsZShUaWxlc1tfXSk7ZWxzZSBlcnJvcignVW5yZWNvZ25pemVkIFRyZWVtYXAgbGF5b3V0IG1ldGhvZDogJyArIF8pO1xuICAgIH07XG5cbiAgICByZXR1cm4geDtcbiAgfSxcblxuICBwYXJhbXM6IFsnbWV0aG9kJywgJ3JhdGlvJywgJ3NpemUnLCAncm91bmQnLCAncGFkZGluZycsICdwYWRkaW5nSW5uZXInLCAncGFkZGluZ091dGVyJywgJ3BhZGRpbmdUb3AnLCAncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nLCAncGFkZGluZ0xlZnQnXSxcbiAgZmllbGRzOiBPdXRwdXQkM1xufSk7XG5cbmV4cG9ydCB7IE5lc3QgYXMgbmVzdCwgUGFjayBhcyBwYWNrLCBQYXJ0aXRpb24gYXMgcGFydGl0aW9uLCBTdHJhdGlmeSBhcyBzdHJhdGlmeSwgVHJlZSBhcyB0cmVlLCBUcmVlTGlua3MgYXMgdHJlZWxpbmtzLCBUcmVlbWFwIGFzIHRyZWVtYXAgfTtcbiIsImV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbChmKSB7XG4gIHJldHVybiBmID09IG51bGwgPyBudWxsIDogcmVxdWlyZWQoZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlZChmKSB7XG4gIGlmICh0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgXCJsZW5ndGhcIiBpbiB4XG4gICAgPyB4IC8vIEFycmF5LCBUeXBlZEFycmF5LCBOb2RlTGlzdCwgYXJyYXktbGlrZVxuICAgIDogQXJyYXkuZnJvbSh4KTsgLy8gTWFwLCBTZXQsIGl0ZXJhYmxlLCBzdHJpbmcsIG9yIGFueXRoaW5nIGVsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcbiAgdmFyIG0gPSBhcnJheS5sZW5ndGgsXG4gICAgICB0LFxuICAgICAgaTtcblxuICB3aGlsZSAobSkge1xuICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICB0ID0gYXJyYXlbbV07XG4gICAgYXJyYXlbbV0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpXSA9IHQ7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG4iLCJmdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbihhLCBiKSB7XG4gIHJldHVybiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcbn1cblxuZnVuY3Rpb24gbWVhblgoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShtZWFuWFJlZHVjZSwgMCkgLyBjaGlsZHJlbi5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIG1lYW5YUmVkdWNlKHgsIGMpIHtcbiAgcmV0dXJuIHggKyBjLng7XG59XG5cbmZ1bmN0aW9uIG1heFkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIDEgKyBjaGlsZHJlbi5yZWR1Y2UobWF4WVJlZHVjZSwgMCk7XG59XG5cbmZ1bmN0aW9uIG1heFlSZWR1Y2UoeSwgYykge1xuICByZXR1cm4gTWF0aC5tYXgoeSwgYy55KTtcbn1cblxuZnVuY3Rpb24gbGVhZkxlZnQobm9kZSkge1xuICB2YXIgY2hpbGRyZW47XG4gIHdoaWxlIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIG5vZGUgPSBjaGlsZHJlblswXTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGxlYWZSaWdodChub2RlKSB7XG4gIHZhciBjaGlsZHJlbjtcbiAgd2hpbGUgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgbm9kZSA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzZXBhcmF0aW9uID0gZGVmYXVsdFNlcGFyYXRpb24sXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBub2RlU2l6ZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsdXN0ZXIocm9vdCkge1xuICAgIHZhciBwcmV2aW91c05vZGUsXG4gICAgICAgIHggPSAwO1xuXG4gICAgLy8gRmlyc3Qgd2FsaywgY29tcHV0aW5nIHRoZSBpbml0aWFsIHggJiB5IHZhbHVlcy5cbiAgICByb290LmVhY2hBZnRlcihmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIG5vZGUueCA9IG1lYW5YKGNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS55ID0gbWF4WShjaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnggPSBwcmV2aW91c05vZGUgPyB4ICs9IHNlcGFyYXRpb24obm9kZSwgcHJldmlvdXNOb2RlKSA6IDA7XG4gICAgICAgIG5vZGUueSA9IDA7XG4gICAgICAgIHByZXZpb3VzTm9kZSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbGVmdCA9IGxlYWZMZWZ0KHJvb3QpLFxuICAgICAgICByaWdodCA9IGxlYWZSaWdodChyb290KSxcbiAgICAgICAgeDAgPSBsZWZ0LnggLSBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIsXG4gICAgICAgIHgxID0gcmlnaHQueCArIHNlcGFyYXRpb24ocmlnaHQsIGxlZnQpIC8gMjtcblxuICAgIC8vIFNlY29uZCB3YWxrLCBub3JtYWxpemluZyB4ICYgeSB0byB0aGUgZGVzaXJlZCBzaXplLlxuICAgIHJldHVybiByb290LmVhY2hBZnRlcihub2RlU2l6ZSA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUueCA9IChub2RlLnggLSByb290LngpICogZHg7XG4gICAgICBub2RlLnkgPSAocm9vdC55IC0gbm9kZS55KSAqIGR5O1xuICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnggPSAobm9kZS54IC0geDApIC8gKHgxIC0geDApICogZHg7XG4gICAgICBub2RlLnkgPSAoMSAtIChyb290LnkgPyBub2RlLnkgLyByb290LnkgOiAxKSkgKiBkeTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsdXN0ZXIuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzZXBhcmF0aW9uID0geCwgY2x1c3RlcikgOiBzZXBhcmF0aW9uO1xuICB9O1xuXG4gIGNsdXN0ZXIuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBjbHVzdGVyKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gIH07XG5cbiAgY2x1c3Rlci5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIGNsdXN0ZXIpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gY2x1c3Rlcjtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjb25zdGFudFplcm8oKSB7XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdO1xuICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG4iLCJmdW5jdGlvbiBjb3VudChub2RlKSB7XG4gIHZhciBzdW0gPSAwLFxuICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuICAgICAgaSA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKCFpKSBzdW0gPSAxO1xuICBlbHNlIHdoaWxlICgtLWkgPj0gMCkgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICBub2RlLnZhbHVlID0gc3VtO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEFmdGVyKGNvdW50KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGF0KSB7XG4gIGxldCBpbmRleCA9IC0xO1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcykge1xuICAgIGNhbGxiYWNrLmNhbGwodGhhdCwgbm9kZSwgKytpbmRleCwgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgdGhhdCkge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdLCBuZXh0ID0gW10sIGNoaWxkcmVuLCBpLCBuLCBpbmRleCA9IC0xO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgbmV4dC5wdXNoKG5vZGUpO1xuICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdoaWxlIChub2RlID0gbmV4dC5wb3AoKSkge1xuICAgIGNhbGxiYWNrLmNhbGwodGhhdCwgbm9kZSwgKytpbmRleCwgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgdGhhdCkge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdLCBjaGlsZHJlbiwgaSwgaW5kZXggPSAtMTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGNhbGxiYWNrLmNhbGwodGhhdCwgbm9kZSwgKytpbmRleCwgdGhpcyk7XG4gICAgaWYgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIHRoYXQpIHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzKSB7XG4gICAgaWYgKGNhbGxiYWNrLmNhbGwodGhhdCwgbm9kZSwgKytpbmRleCwgdGhpcykpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IG5vZGVfY291bnQgZnJvbSBcIi4vY291bnQuanNcIjtcbmltcG9ydCBub2RlX2VhY2ggZnJvbSBcIi4vZWFjaC5qc1wiO1xuaW1wb3J0IG5vZGVfZWFjaEJlZm9yZSBmcm9tIFwiLi9lYWNoQmVmb3JlLmpzXCI7XG5pbXBvcnQgbm9kZV9lYWNoQWZ0ZXIgZnJvbSBcIi4vZWFjaEFmdGVyLmpzXCI7XG5pbXBvcnQgbm9kZV9maW5kIGZyb20gXCIuL2ZpbmQuanNcIjtcbmltcG9ydCBub2RlX3N1bSBmcm9tIFwiLi9zdW0uanNcIjtcbmltcG9ydCBub2RlX3NvcnQgZnJvbSBcIi4vc29ydC5qc1wiO1xuaW1wb3J0IG5vZGVfcGF0aCBmcm9tIFwiLi9wYXRoLmpzXCI7XG5pbXBvcnQgbm9kZV9hbmNlc3RvcnMgZnJvbSBcIi4vYW5jZXN0b3JzLmpzXCI7XG5pbXBvcnQgbm9kZV9kZXNjZW5kYW50cyBmcm9tIFwiLi9kZXNjZW5kYW50cy5qc1wiO1xuaW1wb3J0IG5vZGVfbGVhdmVzIGZyb20gXCIuL2xlYXZlcy5qc1wiO1xuaW1wb3J0IG5vZGVfbGlua3MgZnJvbSBcIi4vbGlua3MuanNcIjtcbmltcG9ydCBub2RlX2l0ZXJhdG9yIGZyb20gXCIuL2l0ZXJhdG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhpZXJhcmNoeShkYXRhLCBjaGlsZHJlbikge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgIGRhdGEgPSBbdW5kZWZpbmVkLCBkYXRhXTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgY2hpbGRyZW4gPSBtYXBDaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2hpbGRyZW4gPSBvYmplY3RDaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByb290ID0gbmV3IE5vZGUoZGF0YSksXG4gICAgICBub2RlLFxuICAgICAgbm9kZXMgPSBbcm9vdF0sXG4gICAgICBjaGlsZCxcbiAgICAgIGNoaWxkcyxcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBpZiAoKGNoaWxkcyA9IGNoaWxkcmVuKG5vZGUuZGF0YSkpICYmIChuID0gKGNoaWxkcyA9IEFycmF5LmZyb20oY2hpbGRzKSkubGVuZ3RoKSkge1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcztcbiAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gY2hpbGRzW2ldID0gbmV3IE5vZGUoY2hpbGRzW2ldKSk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XG4gICAgICAgIGNoaWxkLmRlcHRoID0gbm9kZS5kZXB0aCArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJvb3QuZWFjaEJlZm9yZShjb21wdXRlSGVpZ2h0KTtcbn1cblxuZnVuY3Rpb24gbm9kZV9jb3B5KCkge1xuICByZXR1cm4gaGllcmFyY2h5KHRoaXMpLmVhY2hCZWZvcmUoY29weURhdGEpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RDaGlsZHJlbihkKSB7XG4gIHJldHVybiBkLmNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihkKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGQpID8gZFsxXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvcHlEYXRhKG5vZGUpIHtcbiAgaWYgKG5vZGUuZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSBub2RlLnZhbHVlID0gbm9kZS5kYXRhLnZhbHVlO1xuICBub2RlLmRhdGEgPSBub2RlLmRhdGEuZGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVIZWlnaHQobm9kZSkge1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgZG8gbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XG4gIHdoaWxlICgobm9kZSA9IG5vZGUucGFyZW50KSAmJiAobm9kZS5oZWlnaHQgPCArK2hlaWdodCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTm9kZShkYXRhKSB7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuZGVwdGggPVxuICB0aGlzLmhlaWdodCA9IDA7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbn1cblxuTm9kZS5wcm90b3R5cGUgPSBoaWVyYXJjaHkucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTm9kZSxcbiAgY291bnQ6IG5vZGVfY291bnQsXG4gIGVhY2g6IG5vZGVfZWFjaCxcbiAgZWFjaEFmdGVyOiBub2RlX2VhY2hBZnRlcixcbiAgZWFjaEJlZm9yZTogbm9kZV9lYWNoQmVmb3JlLFxuICBmaW5kOiBub2RlX2ZpbmQsXG4gIHN1bTogbm9kZV9zdW0sXG4gIHNvcnQ6IG5vZGVfc29ydCxcbiAgcGF0aDogbm9kZV9wYXRoLFxuICBhbmNlc3RvcnM6IG5vZGVfYW5jZXN0b3JzLFxuICBkZXNjZW5kYW50czogbm9kZV9kZXNjZW5kYW50cyxcbiAgbGVhdmVzOiBub2RlX2xlYXZlcyxcbiAgbGlua3M6IG5vZGVfbGlua3MsXG4gIGNvcHk6IG5vZGVfY29weSxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IG5vZGVfaXRlcmF0b3Jcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiooKSB7XG4gIHZhciBub2RlID0gdGhpcywgY3VycmVudCwgbmV4dCA9IFtub2RlXSwgY2hpbGRyZW4sIGksIG47XG4gIGRvIHtcbiAgICBjdXJyZW50ID0gbmV4dC5yZXZlcnNlKCksIG5leHQgPSBbXTtcbiAgICB3aGlsZSAobm9kZSA9IGN1cnJlbnQucG9wKCkpIHtcbiAgICAgIHlpZWxkIG5vZGU7XG4gICAgICBpZiAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBuZXh0LnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlIChuZXh0Lmxlbmd0aCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGxlYXZlcyA9IFtdO1xuICB0aGlzLmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgbGVhdmVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxlYXZlcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgcm9vdCA9IHRoaXMsIGxpbmtzID0gW107XG4gIHJvb3QuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgIT09IHJvb3QpIHsgLy8gRG9u4oCZdCBpbmNsdWRlIHRoZSByb2904oCZcyBwYXJlbnQsIGlmIGFueS5cbiAgICAgIGxpbmtzLnB1c2goe3NvdXJjZTogbm9kZS5wYXJlbnQsIHRhcmdldDogbm9kZX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsaW5rcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGVuZCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLFxuICAgICAgYW5jZXN0b3IgPSBsZWFzdENvbW1vbkFuY2VzdG9yKHN0YXJ0LCBlbmQpLFxuICAgICAgbm9kZXMgPSBbc3RhcnRdO1xuICB3aGlsZSAoc3RhcnQgIT09IGFuY2VzdG9yKSB7XG4gICAgc3RhcnQgPSBzdGFydC5wYXJlbnQ7XG4gICAgbm9kZXMucHVzaChzdGFydCk7XG4gIH1cbiAgdmFyIGsgPSBub2Rlcy5sZW5ndGg7XG4gIHdoaWxlIChlbmQgIT09IGFuY2VzdG9yKSB7XG4gICAgbm9kZXMuc3BsaWNlKGssIDAsIGVuZCk7XG4gICAgZW5kID0gZW5kLnBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIGxlYXN0Q29tbW9uQW5jZXN0b3IoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIGE7XG4gIHZhciBhTm9kZXMgPSBhLmFuY2VzdG9ycygpLFxuICAgICAgYk5vZGVzID0gYi5hbmNlc3RvcnMoKSxcbiAgICAgIGMgPSBudWxsO1xuICBhID0gYU5vZGVzLnBvcCgpO1xuICBiID0gYk5vZGVzLnBvcCgpO1xuICB3aGlsZSAoYSA9PT0gYikge1xuICAgIGMgPSBhO1xuICAgIGEgPSBhTm9kZXMucG9wKCk7XG4gICAgYiA9IGJOb2Rlcy5wb3AoKTtcbiAgfVxuICByZXR1cm4gYztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEFmdGVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgc3VtID0gK3ZhbHVlKG5vZGUuZGF0YSkgfHwgMCxcbiAgICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuICAgICAgICBpID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlICgtLWkgPj0gMCkgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICAgIG5vZGUudmFsdWUgPSBzdW07XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtzaHVmZmxlfSBmcm9tIFwiLi4vYXJyYXkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2lyY2xlcykge1xuICB2YXIgaSA9IDAsIG4gPSAoY2lyY2xlcyA9IHNodWZmbGUoQXJyYXkuZnJvbShjaXJjbGVzKSkpLmxlbmd0aCwgQiA9IFtdLCBwLCBlO1xuXG4gIHdoaWxlIChpIDwgbikge1xuICAgIHAgPSBjaXJjbGVzW2ldO1xuICAgIGlmIChlICYmIGVuY2xvc2VzV2VhayhlLCBwKSkgKytpO1xuICAgIGVsc2UgZSA9IGVuY2xvc2VCYXNpcyhCID0gZXh0ZW5kQmFzaXMoQiwgcCkpLCBpID0gMDtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBleHRlbmRCYXNpcyhCLCBwKSB7XG4gIHZhciBpLCBqO1xuXG4gIGlmIChlbmNsb3Nlc1dlYWtBbGwocCwgQikpIHJldHVybiBbcF07XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBCIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZWxlbWVudC5cbiAgZm9yIChpID0gMDsgaSA8IEIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoZW5jbG9zZXNOb3QocCwgQltpXSlcbiAgICAgICAgJiYgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczIoQltpXSwgcCksIEIpKSB7XG4gICAgICByZXR1cm4gW0JbaV0sIHBdO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIGVsZW1lbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgQi5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBmb3IgKGogPSBpICsgMTsgaiA8IEIubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIEJbal0pLCBwKVxuICAgICAgICAgICYmIGVuY2xvc2VzTm90KGVuY2xvc2VCYXNpczIoQltpXSwgcCksIEJbal0pXG4gICAgICAgICAgJiYgZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2pdLCBwKSwgQltpXSlcbiAgICAgICAgICAmJiBlbmNsb3Nlc1dlYWtBbGwoZW5jbG9zZUJhc2lzMyhCW2ldLCBCW2pdLCBwKSwgQikpIHtcbiAgICAgICAgcmV0dXJuIFtCW2ldLCBCW2pdLCBwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHNvbWV0aGluZyBpcyB2ZXJ5IHdyb25nLlxuICB0aHJvdyBuZXcgRXJyb3I7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VzTm90KGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yIC0gYi5yLCBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnk7XG4gIHJldHVybiBkciA8IDAgfHwgZHIgKiBkciA8IGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBlbmNsb3Nlc1dlYWsoYSwgYikge1xuICB2YXIgZHIgPSBhLnIgLSBiLnIgKyBNYXRoLm1heChhLnIsIGIuciwgMSkgKiAxZS05LCBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnk7XG4gIHJldHVybiBkciA+IDAgJiYgZHIgKiBkciA+IGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBlbmNsb3Nlc1dlYWtBbGwoYSwgQikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IEIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIWVuY2xvc2VzV2VhayhhLCBCW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzKEIpIHtcbiAgc3dpdGNoIChCLmxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGVuY2xvc2VCYXNpczEoQlswXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZW5jbG9zZUJhc2lzMihCWzBdLCBCWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBlbmNsb3NlQmFzaXMzKEJbMF0sIEJbMV0sIEJbMl0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpczEoYSkge1xuICByZXR1cm4ge1xuICAgIHg6IGEueCxcbiAgICB5OiBhLnksXG4gICAgcjogYS5yXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpczIoYSwgYikge1xuICB2YXIgeDEgPSBhLngsIHkxID0gYS55LCByMSA9IGEucixcbiAgICAgIHgyID0gYi54LCB5MiA9IGIueSwgcjIgPSBiLnIsXG4gICAgICB4MjEgPSB4MiAtIHgxLCB5MjEgPSB5MiAtIHkxLCByMjEgPSByMiAtIHIxLFxuICAgICAgbCA9IE1hdGguc3FydCh4MjEgKiB4MjEgKyB5MjEgKiB5MjEpO1xuICByZXR1cm4ge1xuICAgIHg6ICh4MSArIHgyICsgeDIxIC8gbCAqIHIyMSkgLyAyLFxuICAgIHk6ICh5MSArIHkyICsgeTIxIC8gbCAqIHIyMSkgLyAyLFxuICAgIHI6IChsICsgcjEgKyByMikgLyAyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpczMoYSwgYiwgYykge1xuICB2YXIgeDEgPSBhLngsIHkxID0gYS55LCByMSA9IGEucixcbiAgICAgIHgyID0gYi54LCB5MiA9IGIueSwgcjIgPSBiLnIsXG4gICAgICB4MyA9IGMueCwgeTMgPSBjLnksIHIzID0gYy5yLFxuICAgICAgYTIgPSB4MSAtIHgyLFxuICAgICAgYTMgPSB4MSAtIHgzLFxuICAgICAgYjIgPSB5MSAtIHkyLFxuICAgICAgYjMgPSB5MSAtIHkzLFxuICAgICAgYzIgPSByMiAtIHIxLFxuICAgICAgYzMgPSByMyAtIHIxLFxuICAgICAgZDEgPSB4MSAqIHgxICsgeTEgKiB5MSAtIHIxICogcjEsXG4gICAgICBkMiA9IGQxIC0geDIgKiB4MiAtIHkyICogeTIgKyByMiAqIHIyLFxuICAgICAgZDMgPSBkMSAtIHgzICogeDMgLSB5MyAqIHkzICsgcjMgKiByMyxcbiAgICAgIGFiID0gYTMgKiBiMiAtIGEyICogYjMsXG4gICAgICB4YSA9IChiMiAqIGQzIC0gYjMgKiBkMikgLyAoYWIgKiAyKSAtIHgxLFxuICAgICAgeGIgPSAoYjMgKiBjMiAtIGIyICogYzMpIC8gYWIsXG4gICAgICB5YSA9IChhMyAqIGQyIC0gYTIgKiBkMykgLyAoYWIgKiAyKSAtIHkxLFxuICAgICAgeWIgPSAoYTIgKiBjMyAtIGEzICogYzIpIC8gYWIsXG4gICAgICBBID0geGIgKiB4YiArIHliICogeWIgLSAxLFxuICAgICAgQiA9IDIgKiAocjEgKyB4YSAqIHhiICsgeWEgKiB5YiksXG4gICAgICBDID0geGEgKiB4YSArIHlhICogeWEgLSByMSAqIHIxLFxuICAgICAgciA9IC0oQSA/IChCICsgTWF0aC5zcXJ0KEIgKiBCIC0gNCAqIEEgKiBDKSkgLyAoMiAqIEEpIDogQyAvIEIpO1xuICByZXR1cm4ge1xuICAgIHg6IHgxICsgeGEgKyB4YiAqIHIsXG4gICAgeTogeTEgKyB5YSArIHliICogcixcbiAgICByOiByXG4gIH07XG59XG4iLCJpbXBvcnQge3BhY2tFbmNsb3NlfSBmcm9tIFwiLi9zaWJsaW5ncy5qc1wiO1xuaW1wb3J0IHtvcHRpb25hbH0gZnJvbSBcIi4uL2FjY2Vzc29ycy5qc1wiO1xuaW1wb3J0IGNvbnN0YW50LCB7Y29uc3RhbnRaZXJvfSBmcm9tIFwiLi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gZGVmYXVsdFJhZGl1cyhkKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoZC52YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgcmFkaXVzID0gbnVsbCxcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIHBhZGRpbmcgPSBjb25zdGFudFplcm87XG5cbiAgZnVuY3Rpb24gcGFjayhyb290KSB7XG4gICAgcm9vdC54ID0gZHggLyAyLCByb290LnkgPSBkeSAvIDI7XG4gICAgaWYgKHJhZGl1cykge1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKHJhZGl1c0xlYWYocmFkaXVzKSlcbiAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihwYWRkaW5nLCAwLjUpKVxuICAgICAgICAgIC5lYWNoQmVmb3JlKHRyYW5zbGF0ZUNoaWxkKDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKHJhZGl1c0xlYWYoZGVmYXVsdFJhZGl1cykpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4oY29uc3RhbnRaZXJvLCAxKSlcbiAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihwYWRkaW5nLCByb290LnIgLyBNYXRoLm1pbihkeCwgZHkpKSlcbiAgICAgICAgICAuZWFjaEJlZm9yZSh0cmFuc2xhdGVDaGlsZChNYXRoLm1pbihkeCwgZHkpIC8gKDIgKiByb290LnIpKSk7XG4gICAgfVxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgcGFjay5yYWRpdXMgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gb3B0aW9uYWwoeCksIHBhY2spIDogcmFkaXVzO1xuICB9O1xuXG4gIHBhY2suc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBwYWNrKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHBhY2sucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHBhY2spIDogcGFkZGluZztcbiAgfTtcblxuICByZXR1cm4gcGFjaztcbn1cblxuZnVuY3Rpb24gcmFkaXVzTGVhZihyYWRpdXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIG5vZGUuciA9IE1hdGgubWF4KDAsICtyYWRpdXMobm9kZSkgfHwgMCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYWNrQ2hpbGRyZW4ocGFkZGluZywgaykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHZhciBjaGlsZHJlbixcbiAgICAgICAgICBpLFxuICAgICAgICAgIG4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgciA9IHBhZGRpbmcobm9kZSkgKiBrIHx8IDAsXG4gICAgICAgICAgZTtcblxuICAgICAgaWYgKHIpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoaWxkcmVuW2ldLnIgKz0gcjtcbiAgICAgIGUgPSBwYWNrRW5jbG9zZShjaGlsZHJlbik7XG4gICAgICBpZiAocikgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY2hpbGRyZW5baV0uciAtPSByO1xuICAgICAgbm9kZS5yID0gZSArIHI7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVDaGlsZChrKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIG5vZGUuciAqPSBrO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIG5vZGUueCA9IHBhcmVudC54ICsgayAqIG5vZGUueDtcbiAgICAgIG5vZGUueSA9IHBhcmVudC55ICsgayAqIG5vZGUueTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgYXJyYXkgZnJvbSBcIi4uL2FycmF5LmpzXCI7XG5pbXBvcnQgZW5jbG9zZSBmcm9tIFwiLi9lbmNsb3NlLmpzXCI7XG5cbmZ1bmN0aW9uIHBsYWNlKGIsIGEsIGMpIHtcbiAgdmFyIGR4ID0gYi54IC0gYS54LCB4LCBhMixcbiAgICAgIGR5ID0gYi55IC0gYS55LCB5LCBiMixcbiAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gIGlmIChkMikge1xuICAgIGEyID0gYS5yICsgYy5yLCBhMiAqPSBhMjtcbiAgICBiMiA9IGIuciArIGMuciwgYjIgKj0gYjI7XG4gICAgaWYgKGEyID4gYjIpIHtcbiAgICAgIHggPSAoZDIgKyBiMiAtIGEyKSAvICgyICogZDIpO1xuICAgICAgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCBiMiAvIGQyIC0geCAqIHgpKTtcbiAgICAgIGMueCA9IGIueCAtIHggKiBkeCAtIHkgKiBkeTtcbiAgICAgIGMueSA9IGIueSAtIHggKiBkeSArIHkgKiBkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IChkMiArIGEyIC0gYjIpIC8gKDIgKiBkMik7XG4gICAgICB5ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGEyIC8gZDIgLSB4ICogeCkpO1xuICAgICAgYy54ID0gYS54ICsgeCAqIGR4IC0geSAqIGR5O1xuICAgICAgYy55ID0gYS55ICsgeCAqIGR5ICsgeSAqIGR4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjLnggPSBhLnggKyBjLnI7XG4gICAgYy55ID0gYS55O1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoYSwgYikge1xuICB2YXIgZHIgPSBhLnIgKyBiLnIgLSAxZS02LCBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnk7XG4gIHJldHVybiBkciA+IDAgJiYgZHIgKiBkciA+IGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBzY29yZShub2RlKSB7XG4gIHZhciBhID0gbm9kZS5fLFxuICAgICAgYiA9IG5vZGUubmV4dC5fLFxuICAgICAgYWIgPSBhLnIgKyBiLnIsXG4gICAgICBkeCA9IChhLnggKiBiLnIgKyBiLnggKiBhLnIpIC8gYWIsXG4gICAgICBkeSA9IChhLnkgKiBiLnIgKyBiLnkgKiBhLnIpIC8gYWI7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gTm9kZShjaXJjbGUpIHtcbiAgdGhpcy5fID0gY2lyY2xlO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhY2tFbmNsb3NlKGNpcmNsZXMpIHtcbiAgaWYgKCEobiA9IChjaXJjbGVzID0gYXJyYXkoY2lyY2xlcykpLmxlbmd0aCkpIHJldHVybiAwO1xuXG4gIHZhciBhLCBiLCBjLCBuLCBhYSwgY2EsIGksIGosIGssIHNqLCBzaztcblxuICAvLyBQbGFjZSB0aGUgZmlyc3QgY2lyY2xlLlxuICBhID0gY2lyY2xlc1swXSwgYS54ID0gMCwgYS55ID0gMDtcbiAgaWYgKCEobiA+IDEpKSByZXR1cm4gYS5yO1xuXG4gIC8vIFBsYWNlIHRoZSBzZWNvbmQgY2lyY2xlLlxuICBiID0gY2lyY2xlc1sxXSwgYS54ID0gLWIuciwgYi54ID0gYS5yLCBiLnkgPSAwO1xuICBpZiAoIShuID4gMikpIHJldHVybiBhLnIgKyBiLnI7XG5cbiAgLy8gUGxhY2UgdGhlIHRoaXJkIGNpcmNsZS5cbiAgcGxhY2UoYiwgYSwgYyA9IGNpcmNsZXNbMl0pO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIGZyb250LWNoYWluIHVzaW5nIHRoZSBmaXJzdCB0aHJlZSBjaXJjbGVzIGEsIGIgYW5kIGMuXG4gIGEgPSBuZXcgTm9kZShhKSwgYiA9IG5ldyBOb2RlKGIpLCBjID0gbmV3IE5vZGUoYyk7XG4gIGEubmV4dCA9IGMucHJldmlvdXMgPSBiO1xuICBiLm5leHQgPSBhLnByZXZpb3VzID0gYztcbiAgYy5uZXh0ID0gYi5wcmV2aW91cyA9IGE7XG5cbiAgLy8gQXR0ZW1wdCB0byBwbGFjZSBlYWNoIHJlbWFpbmluZyBjaXJjbGXigKZcbiAgcGFjazogZm9yIChpID0gMzsgaSA8IG47ICsraSkge1xuICAgIHBsYWNlKGEuXywgYi5fLCBjID0gY2lyY2xlc1tpXSksIGMgPSBuZXcgTm9kZShjKTtcblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW5nIGNpcmNsZSBvbiB0aGUgZnJvbnQtY2hhaW4sIGlmIGFueS5cbiAgICAvLyDigJxDbG9zZW5lc3PigJ0gaXMgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UgYWxvbmcgdGhlIGZyb250LWNoYWluLlxuICAgIC8vIOKAnEFoZWFk4oCdIG9yIOKAnGJlaGluZOKAnSBpcyBsaWtld2lzZSBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZS5cbiAgICBqID0gYi5uZXh0LCBrID0gYS5wcmV2aW91cywgc2ogPSBiLl8uciwgc2sgPSBhLl8ucjtcbiAgICBkbyB7XG4gICAgICBpZiAoc2ogPD0gc2spIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoai5fLCBjLl8pKSB7XG4gICAgICAgICAgYiA9IGosIGEubmV4dCA9IGIsIGIucHJldmlvdXMgPSBhLCAtLWk7XG4gICAgICAgICAgY29udGludWUgcGFjaztcbiAgICAgICAgfVxuICAgICAgICBzaiArPSBqLl8uciwgaiA9IGoubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKGsuXywgYy5fKSkge1xuICAgICAgICAgIGEgPSBrLCBhLm5leHQgPSBiLCBiLnByZXZpb3VzID0gYSwgLS1pO1xuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgIH1cbiAgICAgICAgc2sgKz0gay5fLnIsIGsgPSBrLnByZXZpb3VzO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGogIT09IGsubmV4dCk7XG5cbiAgICAvLyBTdWNjZXNzISBJbnNlcnQgdGhlIG5ldyBjaXJjbGUgYyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgYy5wcmV2aW91cyA9IGEsIGMubmV4dCA9IGIsIGEubmV4dCA9IGIucHJldmlvdXMgPSBiID0gYztcblxuICAgIC8vIENvbXB1dGUgdGhlIG5ldyBjbG9zZXN0IGNpcmNsZSBwYWlyIHRvIHRoZSBjZW50cm9pZC5cbiAgICBhYSA9IHNjb3JlKGEpO1xuICAgIHdoaWxlICgoYyA9IGMubmV4dCkgIT09IGIpIHtcbiAgICAgIGlmICgoY2EgPSBzY29yZShjKSkgPCBhYSkge1xuICAgICAgICBhID0gYywgYWEgPSBjYTtcbiAgICAgIH1cbiAgICB9XG4gICAgYiA9IGEubmV4dDtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGVuY2xvc2luZyBjaXJjbGUgb2YgdGhlIGZyb250IGNoYWluLlxuICBhID0gW2IuX10sIGMgPSBiOyB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSBhLnB1c2goYy5fKTsgYyA9IGVuY2xvc2UoYSk7XG5cbiAgLy8gVHJhbnNsYXRlIHRoZSBjaXJjbGVzIHRvIHB1dCB0aGUgZW5jbG9zaW5nIGNpcmNsZSBhcm91bmQgdGhlIG9yaWdpbi5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgYSA9IGNpcmNsZXNbaV0sIGEueCAtPSBjLngsIGEueSAtPSBjLnk7XG5cbiAgcmV0dXJuIGMucjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2lyY2xlcykge1xuICBwYWNrRW5jbG9zZShjaXJjbGVzKTtcbiAgcmV0dXJuIGNpcmNsZXM7XG59XG4iLCJpbXBvcnQgcm91bmROb2RlIGZyb20gXCIuL3RyZWVtYXAvcm91bmQuanNcIjtcbmltcG9ydCB0cmVlbWFwRGljZSBmcm9tIFwiLi90cmVlbWFwL2RpY2UuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nID0gMCxcbiAgICAgIHJvdW5kID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gcGFydGl0aW9uKHJvb3QpIHtcbiAgICB2YXIgbiA9IHJvb3QuaGVpZ2h0ICsgMTtcbiAgICByb290LngwID1cbiAgICByb290LnkwID0gcGFkZGluZztcbiAgICByb290LngxID0gZHg7XG4gICAgcm9vdC55MSA9IGR5IC8gbjtcbiAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKGR5LCBuKSk7XG4gICAgaWYgKHJvdW5kKSByb290LmVhY2hCZWZvcmUocm91bmROb2RlKTtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTm9kZShkeSwgbikge1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICB0cmVlbWFwRGljZShub2RlLCBub2RlLngwLCBkeSAqIChub2RlLmRlcHRoICsgMSkgLyBuLCBub2RlLngxLCBkeSAqIChub2RlLmRlcHRoICsgMikgLyBuKTtcbiAgICAgIH1cbiAgICAgIHZhciB4MCA9IG5vZGUueDAsXG4gICAgICAgICAgeTAgPSBub2RlLnkwLFxuICAgICAgICAgIHgxID0gbm9kZS54MSAtIHBhZGRpbmcsXG4gICAgICAgICAgeTEgPSBub2RlLnkxIC0gcGFkZGluZztcbiAgICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIG5vZGUueDAgPSB4MDtcbiAgICAgIG5vZGUueTAgPSB5MDtcbiAgICAgIG5vZGUueDEgPSB4MTtcbiAgICAgIG5vZGUueTEgPSB5MTtcbiAgICB9O1xuICB9XG5cbiAgcGFydGl0aW9uLnJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCBwYXJ0aXRpb24pIDogcm91bmQ7XG4gIH07XG5cbiAgcGFydGl0aW9uLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgcGFydGl0aW9uKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHBhcnRpdGlvbi5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSAreCwgcGFydGl0aW9uKSA6IHBhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIHBhcnRpdGlvbjtcbn1cbiIsImltcG9ydCB7cmVxdWlyZWR9IGZyb20gXCIuL2FjY2Vzc29ycy5qc1wiO1xuaW1wb3J0IHtOb2RlLCBjb21wdXRlSGVpZ2h0fSBmcm9tIFwiLi9oaWVyYXJjaHkvaW5kZXguanNcIjtcblxudmFyIHByZXJvb3QgPSB7ZGVwdGg6IC0xfSxcbiAgICBhbWJpZ3VvdXMgPSB7fTtcblxuZnVuY3Rpb24gZGVmYXVsdElkKGQpIHtcbiAgcmV0dXJuIGQuaWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQYXJlbnRJZChkKSB7XG4gIHJldHVybiBkLnBhcmVudElkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGlkID0gZGVmYXVsdElkLFxuICAgICAgcGFyZW50SWQgPSBkZWZhdWx0UGFyZW50SWQ7XG5cbiAgZnVuY3Rpb24gc3RyYXRpZnkoZGF0YSkge1xuICAgIHZhciBub2RlcyA9IEFycmF5LmZyb20oZGF0YSksXG4gICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGksXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZUlkLFxuICAgICAgICBub2RlS2V5LFxuICAgICAgICBub2RlQnlLZXkgPSBuZXcgTWFwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZCA9IG5vZGVzW2ldLCBub2RlID0gbm9kZXNbaV0gPSBuZXcgTm9kZShkKTtcbiAgICAgIGlmICgobm9kZUlkID0gaWQoZCwgaSwgZGF0YSkpICE9IG51bGwgJiYgKG5vZGVJZCArPSBcIlwiKSkge1xuICAgICAgICBub2RlS2V5ID0gbm9kZS5pZCA9IG5vZGVJZDtcbiAgICAgICAgbm9kZUJ5S2V5LnNldChub2RlS2V5LCBub2RlQnlLZXkuaGFzKG5vZGVLZXkpID8gYW1iaWd1b3VzIDogbm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoKG5vZGVJZCA9IHBhcmVudElkKGQsIGksIGRhdGEpKSAhPSBudWxsICYmIChub2RlSWQgKz0gXCJcIikpIHtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSBub2RlSWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGVJZCA9IG5vZGUucGFyZW50KSB7XG4gICAgICAgIHBhcmVudCA9IG5vZGVCeUtleS5nZXQobm9kZUlkKTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gYW1iaWd1b3VzKSB0aHJvdyBuZXcgRXJyb3IoXCJhbWJpZ3VvdXM6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbikgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIGVsc2UgcGFyZW50LmNoaWxkcmVuID0gW25vZGVdO1xuICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyb290KSB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSByb290c1wiKTtcbiAgICAgICAgcm9vdCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyb290KSB0aHJvdyBuZXcgRXJyb3IoXCJubyByb290XCIpO1xuICAgIHJvb3QucGFyZW50ID0gcHJlcm9vdDtcbiAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkgeyBub2RlLmRlcHRoID0gbm9kZS5wYXJlbnQuZGVwdGggKyAxOyAtLW47IH0pLmVhY2hCZWZvcmUoY29tcHV0ZUhlaWdodCk7XG4gICAgcm9vdC5wYXJlbnQgPSBudWxsO1xuICAgIGlmIChuID4gMCkgdGhyb3cgbmV3IEVycm9yKFwiY3ljbGVcIik7XG5cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIHN0cmF0aWZ5LmlkID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlkID0gcmVxdWlyZWQoeCksIHN0cmF0aWZ5KSA6IGlkO1xuICB9O1xuXG4gIHN0cmF0aWZ5LnBhcmVudElkID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhcmVudElkID0gcmVxdWlyZWQoeCksIHN0cmF0aWZ5KSA6IHBhcmVudElkO1xuICB9O1xuXG4gIHJldHVybiBzdHJhdGlmeTtcbn1cbiIsImltcG9ydCB7Tm9kZX0gZnJvbSBcIi4vaGllcmFyY2h5L2luZGV4LmpzXCI7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXBhcmF0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyO1xufVxuXG4vLyBmdW5jdGlvbiByYWRpYWxTZXBhcmF0aW9uKGEsIGIpIHtcbi8vICAgcmV0dXJuIChhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMikgLyBhLmRlcHRoO1xuLy8gfVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdHJhdmVyc2UgdGhlIGxlZnQgY29udG91ciBvZiBhIHN1YnRyZWUgKG9yXG4vLyBzdWJmb3Jlc3QpLiBJdCByZXR1cm5zIHRoZSBzdWNjZXNzb3Igb2YgdiBvbiB0aGlzIGNvbnRvdXIuIFRoaXMgc3VjY2Vzc29yIGlzXG4vLyBlaXRoZXIgZ2l2ZW4gYnkgdGhlIGxlZnRtb3N0IGNoaWxkIG9mIHYgb3IgYnkgdGhlIHRocmVhZCBvZiB2LiBUaGUgZnVuY3Rpb25cbi8vIHJldHVybnMgbnVsbCBpZiBhbmQgb25seSBpZiB2IGlzIG9uIHRoZSBoaWdoZXN0IGxldmVsIG9mIGl0cyBzdWJ0cmVlLlxuZnVuY3Rpb24gbmV4dExlZnQodikge1xuICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlblswXSA6IHYudDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3b3JrcyBhbmFsb2dvdXNseSB0byBuZXh0TGVmdC5cbmZ1bmN0aW9uIG5leHRSaWdodCh2KSB7XG4gIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIDogdi50O1xufVxuXG4vLyBTaGlmdHMgdGhlIGN1cnJlbnQgc3VidHJlZSByb290ZWQgYXQgdysuIFRoaXMgaXMgZG9uZSBieSBpbmNyZWFzaW5nXG4vLyBwcmVsaW0odyspIGFuZCBtb2QodyspIGJ5IHNoaWZ0LlxuZnVuY3Rpb24gbW92ZVN1YnRyZWUod20sIHdwLCBzaGlmdCkge1xuICB2YXIgY2hhbmdlID0gc2hpZnQgLyAod3AuaSAtIHdtLmkpO1xuICB3cC5jIC09IGNoYW5nZTtcbiAgd3AucyArPSBzaGlmdDtcbiAgd20uYyArPSBjaGFuZ2U7XG4gIHdwLnogKz0gc2hpZnQ7XG4gIHdwLm0gKz0gc2hpZnQ7XG59XG5cbi8vIEFsbCBvdGhlciBzaGlmdHMsIGFwcGxpZWQgdG8gdGhlIHNtYWxsZXIgc3VidHJlZXMgYmV0d2VlbiB3LSBhbmQgdyssIGFyZVxuLy8gcGVyZm9ybWVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIHByZXBhcmUgdGhlIHNoaWZ0cywgd2UgaGF2ZSB0byBhZGp1c3Rcbi8vIGNoYW5nZSh3KyksIHNoaWZ0KHcrKSwgYW5kIGNoYW5nZSh3LSkuXG5mdW5jdGlvbiBleGVjdXRlU2hpZnRzKHYpIHtcbiAgdmFyIHNoaWZ0ID0gMCxcbiAgICAgIGNoYW5nZSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sXG4gICAgICBpID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgdztcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgdyA9IGNoaWxkcmVuW2ldO1xuICAgIHcueiArPSBzaGlmdDtcbiAgICB3Lm0gKz0gc2hpZnQ7XG4gICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xuICB9XG59XG5cbi8vIElmIHZpLeKAmXMgYW5jZXN0b3IgaXMgYSBzaWJsaW5nIG9mIHYsIHJldHVybnMgdmkt4oCZcyBhbmNlc3Rvci4gT3RoZXJ3aXNlLFxuLy8gcmV0dXJucyB0aGUgc3BlY2lmaWVkIChkZWZhdWx0KSBhbmNlc3Rvci5cbmZ1bmN0aW9uIG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSB7XG4gIHJldHVybiB2aW0uYS5wYXJlbnQgPT09IHYucGFyZW50ID8gdmltLmEgOiBhbmNlc3Rvcjtcbn1cblxuZnVuY3Rpb24gVHJlZU5vZGUobm9kZSwgaSkge1xuICB0aGlzLl8gPSBub2RlO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLkEgPSBudWxsOyAvLyBkZWZhdWx0IGFuY2VzdG9yXG4gIHRoaXMuYSA9IHRoaXM7IC8vIGFuY2VzdG9yXG4gIHRoaXMueiA9IDA7IC8vIHByZWxpbVxuICB0aGlzLm0gPSAwOyAvLyBtb2RcbiAgdGhpcy5jID0gMDsgLy8gY2hhbmdlXG4gIHRoaXMucyA9IDA7IC8vIHNoaWZ0XG4gIHRoaXMudCA9IG51bGw7IC8vIHRocmVhZFxuICB0aGlzLmkgPSBpOyAvLyBudW1iZXJcbn1cblxuVHJlZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIHRyZWVSb290KHJvb3QpIHtcbiAgdmFyIHRyZWUgPSBuZXcgVHJlZU5vZGUocm9vdCwgMCksXG4gICAgICBub2RlLFxuICAgICAgbm9kZXMgPSBbdHJlZV0sXG4gICAgICBjaGlsZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuXy5jaGlsZHJlbikge1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ldyBBcnJheShuID0gY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBUcmVlTm9kZShjaGlsZHJlbltpXSwgaSkpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICh0cmVlLnBhcmVudCA9IG5ldyBUcmVlTm9kZShudWxsLCAwKSkuY2hpbGRyZW4gPSBbdHJlZV07XG4gIHJldHVybiB0cmVlO1xufVxuXG4vLyBOb2RlLWxpbmsgdHJlZSBkaWFncmFtIHVzaW5nIHRoZSBSZWluZ29sZC1UaWxmb3JkIFwidGlkeVwiIGFsZ29yaXRobVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzZXBhcmF0aW9uID0gZGVmYXVsdFNlcGFyYXRpb24sXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBub2RlU2l6ZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gdHJlZShyb290KSB7XG4gICAgdmFyIHQgPSB0cmVlUm9vdChyb290KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGxheW91dCB1c2luZyBCdWNoaGVpbSBldCBhbC7igJlzIGFsZ29yaXRobS5cbiAgICB0LmVhY2hBZnRlcihmaXJzdFdhbGspLCB0LnBhcmVudC5tID0gLXQuejtcbiAgICB0LmVhY2hCZWZvcmUoc2Vjb25kV2Fsayk7XG5cbiAgICAvLyBJZiBhIGZpeGVkIG5vZGUgc2l6ZSBpcyBzcGVjaWZpZWQsIHNjYWxlIHggYW5kIHkuXG4gICAgaWYgKG5vZGVTaXplKSByb290LmVhY2hCZWZvcmUoc2l6ZU5vZGUpO1xuXG4gICAgLy8gSWYgYSBmaXhlZCB0cmVlIHNpemUgaXMgc3BlY2lmaWVkLCBzY2FsZSB4IGFuZCB5IGJhc2VkIG9uIHRoZSBleHRlbnQuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbGVmdC1tb3N0LCByaWdodC1tb3N0LCBhbmQgZGVwdGgtbW9zdCBub2RlcyBmb3IgZXh0ZW50cy5cbiAgICBlbHNlIHtcbiAgICAgIHZhciBsZWZ0ID0gcm9vdCxcbiAgICAgICAgICByaWdodCA9IHJvb3QsXG4gICAgICAgICAgYm90dG9tID0gcm9vdDtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnggPCBsZWZ0LngpIGxlZnQgPSBub2RlO1xuICAgICAgICBpZiAobm9kZS54ID4gcmlnaHQueCkgcmlnaHQgPSBub2RlO1xuICAgICAgICBpZiAobm9kZS5kZXB0aCA+IGJvdHRvbS5kZXB0aCkgYm90dG9tID0gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHMgPSBsZWZ0ID09PSByaWdodCA/IDEgOiBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIsXG4gICAgICAgICAgdHggPSBzIC0gbGVmdC54LFxuICAgICAgICAgIGt4ID0gZHggLyAocmlnaHQueCArIHMgKyB0eCksXG4gICAgICAgICAga3kgPSBkeSAvIChib3R0b20uZGVwdGggfHwgMSk7XG4gICAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLnggPSAobm9kZS54ICsgdHgpICoga3g7XG4gICAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBreTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgLy8gQ29tcHV0ZXMgYSBwcmVsaW1pbmFyeSB4LWNvb3JkaW5hdGUgZm9yIHYuIEJlZm9yZSB0aGF0LCBGSVJTVCBXQUxLIGlzXG4gIC8vIGFwcGxpZWQgcmVjdXJzaXZlbHkgdG8gdGhlIGNoaWxkcmVuIG9mIHYsIGFzIHdlbGwgYXMgdGhlIGZ1bmN0aW9uXG4gIC8vIEFQUE9SVElPTi4gQWZ0ZXIgc3BhY2luZyBvdXQgdGhlIGNoaWxkcmVuIGJ5IGNhbGxpbmcgRVhFQ1VURSBTSElGVFMsIHRoZVxuICAvLyBub2RlIHYgaXMgcGxhY2VkIHRvIHRoZSBtaWRwb2ludCBvZiBpdHMgb3V0ZXJtb3N0IGNoaWxkcmVuLlxuICBmdW5jdGlvbiBmaXJzdFdhbGsodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sXG4gICAgICAgIHNpYmxpbmdzID0gdi5wYXJlbnQuY2hpbGRyZW4sXG4gICAgICAgIHcgPSB2LmkgPyBzaWJsaW5nc1t2LmkgLSAxXSA6IG51bGw7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBleGVjdXRlU2hpZnRzKHYpO1xuICAgICAgdmFyIG1pZHBvaW50ID0gKGNoaWxkcmVuWzBdLnogKyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS56KSAvIDI7XG4gICAgICBpZiAodykge1xuICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgICAgdi5tID0gdi56IC0gbWlkcG9pbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2LnogPSBtaWRwb2ludDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHcpIHtcbiAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgIH1cbiAgICB2LnBhcmVudC5BID0gYXBwb3J0aW9uKHYsIHcsIHYucGFyZW50LkEgfHwgc2libGluZ3NbMF0pO1xuICB9XG5cbiAgLy8gQ29tcHV0ZXMgYWxsIHJlYWwgeC1jb29yZGluYXRlcyBieSBzdW1taW5nIHVwIHRoZSBtb2RpZmllcnMgcmVjdXJzaXZlbHkuXG4gIGZ1bmN0aW9uIHNlY29uZFdhbGsodikge1xuICAgIHYuXy54ID0gdi56ICsgdi5wYXJlbnQubTtcbiAgICB2Lm0gKz0gdi5wYXJlbnQubTtcbiAgfVxuXG4gIC8vIFRoZSBjb3JlIG9mIHRoZSBhbGdvcml0aG0uIEhlcmUsIGEgbmV3IHN1YnRyZWUgaXMgY29tYmluZWQgd2l0aCB0aGVcbiAgLy8gcHJldmlvdXMgc3VidHJlZXMuIFRocmVhZHMgYXJlIHVzZWQgdG8gdHJhdmVyc2UgdGhlIGluc2lkZSBhbmQgb3V0c2lkZVxuICAvLyBjb250b3VycyBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZSB1cCB0byB0aGUgaGlnaGVzdCBjb21tb24gbGV2ZWwuIFRoZVxuICAvLyB2ZXJ0aWNlcyB1c2VkIGZvciB0aGUgdHJhdmVyc2FscyBhcmUgdmkrLCB2aS0sIHZvLSwgYW5kIHZvKywgd2hlcmUgdGhlXG4gIC8vIHN1cGVyc2NyaXB0IG8gbWVhbnMgb3V0c2lkZSBhbmQgaSBtZWFucyBpbnNpZGUsIHRoZSBzdWJzY3JpcHQgLSBtZWFucyBsZWZ0XG4gIC8vIHN1YnRyZWUgYW5kICsgbWVhbnMgcmlnaHQgc3VidHJlZS4gRm9yIHN1bW1pbmcgdXAgdGhlIG1vZGlmaWVycyBhbG9uZyB0aGVcbiAgLy8gY29udG91ciwgd2UgdXNlIHJlc3BlY3RpdmUgdmFyaWFibGVzIHNpKywgc2ktLCBzby0sIGFuZCBzbysuIFdoZW5ldmVyIHR3b1xuICAvLyBub2RlcyBvZiB0aGUgaW5zaWRlIGNvbnRvdXJzIGNvbmZsaWN0LCB3ZSBjb21wdXRlIHRoZSBsZWZ0IG9uZSBvZiB0aGVcbiAgLy8gZ3JlYXRlc3QgdW5jb21tb24gYW5jZXN0b3JzIHVzaW5nIHRoZSBmdW5jdGlvbiBBTkNFU1RPUiBhbmQgY2FsbCBNT1ZFXG4gIC8vIFNVQlRSRUUgdG8gc2hpZnQgdGhlIHN1YnRyZWUgYW5kIHByZXBhcmUgdGhlIHNoaWZ0cyBvZiBzbWFsbGVyIHN1YnRyZWVzLlxuICAvLyBGaW5hbGx5LCB3ZSBhZGQgYSBuZXcgdGhyZWFkIChpZiBuZWNlc3NhcnkpLlxuICBmdW5jdGlvbiBhcHBvcnRpb24odiwgdywgYW5jZXN0b3IpIHtcbiAgICBpZiAodykge1xuICAgICAgdmFyIHZpcCA9IHYsXG4gICAgICAgICAgdm9wID0gdixcbiAgICAgICAgICB2aW0gPSB3LFxuICAgICAgICAgIHZvbSA9IHZpcC5wYXJlbnQuY2hpbGRyZW5bMF0sXG4gICAgICAgICAgc2lwID0gdmlwLm0sXG4gICAgICAgICAgc29wID0gdm9wLm0sXG4gICAgICAgICAgc2ltID0gdmltLm0sXG4gICAgICAgICAgc29tID0gdm9tLm0sXG4gICAgICAgICAgc2hpZnQ7XG4gICAgICB3aGlsZSAodmltID0gbmV4dFJpZ2h0KHZpbSksIHZpcCA9IG5leHRMZWZ0KHZpcCksIHZpbSAmJiB2aXApIHtcbiAgICAgICAgdm9tID0gbmV4dExlZnQodm9tKTtcbiAgICAgICAgdm9wID0gbmV4dFJpZ2h0KHZvcCk7XG4gICAgICAgIHZvcC5hID0gdjtcbiAgICAgICAgc2hpZnQgPSB2aW0ueiArIHNpbSAtIHZpcC56IC0gc2lwICsgc2VwYXJhdGlvbih2aW0uXywgdmlwLl8pO1xuICAgICAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICAgICAgbW92ZVN1YnRyZWUobmV4dEFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpLCB2LCBzaGlmdCk7XG4gICAgICAgICAgc2lwICs9IHNoaWZ0O1xuICAgICAgICAgIHNvcCArPSBzaGlmdDtcbiAgICAgICAgfVxuICAgICAgICBzaW0gKz0gdmltLm07XG4gICAgICAgIHNpcCArPSB2aXAubTtcbiAgICAgICAgc29tICs9IHZvbS5tO1xuICAgICAgICBzb3AgKz0gdm9wLm07XG4gICAgICB9XG4gICAgICBpZiAodmltICYmICFuZXh0UmlnaHQodm9wKSkge1xuICAgICAgICB2b3AudCA9IHZpbTtcbiAgICAgICAgdm9wLm0gKz0gc2ltIC0gc29wO1xuICAgICAgfVxuICAgICAgaWYgKHZpcCAmJiAhbmV4dExlZnQodm9tKSkge1xuICAgICAgICB2b20udCA9IHZpcDtcbiAgICAgICAgdm9tLm0gKz0gc2lwIC0gc29tO1xuICAgICAgICBhbmNlc3RvciA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbmNlc3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpemVOb2RlKG5vZGUpIHtcbiAgICBub2RlLnggKj0gZHg7XG4gICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGR5O1xuICB9XG5cbiAgdHJlZS5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNlcGFyYXRpb24gPSB4LCB0cmVlKSA6IHNlcGFyYXRpb247XG4gIH07XG5cbiAgdHJlZS5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gZmFsc2UsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWUpIDogKG5vZGVTaXplID8gbnVsbCA6IFtkeCwgZHldKTtcbiAgfTtcblxuICB0cmVlLm5vZGVTaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gdHJ1ZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgdHJlZSkgOiAobm9kZVNpemUgPyBbZHgsIGR5XSA6IG51bGwpO1xuICB9O1xuXG4gIHJldHVybiB0cmVlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICBpLCBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgc3VtLCBzdW1zID0gbmV3IEFycmF5KG4gKyAxKTtcblxuICBmb3IgKHN1bXNbMF0gPSBzdW0gPSBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHN1bXNbaSArIDFdID0gc3VtICs9IG5vZGVzW2ldLnZhbHVlO1xuICB9XG5cbiAgcGFydGl0aW9uKDAsIG4sIHBhcmVudC52YWx1ZSwgeDAsIHkwLCB4MSwgeTEpO1xuXG4gIGZ1bmN0aW9uIHBhcnRpdGlvbihpLCBqLCB2YWx1ZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBpZiAoaSA+PSBqIC0gMSkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIG5vZGUueDAgPSB4MCwgbm9kZS55MCA9IHkwO1xuICAgICAgbm9kZS54MSA9IHgxLCBub2RlLnkxID0geTE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlT2Zmc2V0ID0gc3Vtc1tpXSxcbiAgICAgICAgdmFsdWVUYXJnZXQgPSAodmFsdWUgLyAyKSArIHZhbHVlT2Zmc2V0LFxuICAgICAgICBrID0gaSArIDEsXG4gICAgICAgIGhpID0gaiAtIDE7XG5cbiAgICB3aGlsZSAoayA8IGhpKSB7XG4gICAgICB2YXIgbWlkID0gayArIGhpID4+PiAxO1xuICAgICAgaWYgKHN1bXNbbWlkXSA8IHZhbHVlVGFyZ2V0KSBrID0gbWlkICsgMTtcbiAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgfVxuXG4gICAgaWYgKCh2YWx1ZVRhcmdldCAtIHN1bXNbayAtIDFdKSA8IChzdW1zW2tdIC0gdmFsdWVUYXJnZXQpICYmIGkgKyAxIDwgaykgLS1rO1xuXG4gICAgdmFyIHZhbHVlTGVmdCA9IHN1bXNba10gLSB2YWx1ZU9mZnNldCxcbiAgICAgICAgdmFsdWVSaWdodCA9IHZhbHVlIC0gdmFsdWVMZWZ0O1xuXG4gICAgaWYgKCh4MSAtIHgwKSA+ICh5MSAtIHkwKSkge1xuICAgICAgdmFyIHhrID0gdmFsdWUgPyAoeDAgKiB2YWx1ZVJpZ2h0ICsgeDEgKiB2YWx1ZUxlZnQpIC8gdmFsdWUgOiB4MTtcbiAgICAgIHBhcnRpdGlvbihpLCBrLCB2YWx1ZUxlZnQsIHgwLCB5MCwgeGssIHkxKTtcbiAgICAgIHBhcnRpdGlvbihrLCBqLCB2YWx1ZVJpZ2h0LCB4aywgeTAsIHgxLCB5MSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5ayA9IHZhbHVlID8gKHkwICogdmFsdWVSaWdodCArIHkxICogdmFsdWVMZWZ0KSAvIHZhbHVlIDogeTE7XG4gICAgICBwYXJ0aXRpb24oaSwgaywgdmFsdWVMZWZ0LCB4MCwgeTAsIHgxLCB5ayk7XG4gICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeDAsIHlrLCB4MSwgeTEpO1xuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICBub2RlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIGsgPSBwYXJlbnQudmFsdWUgJiYgKHgxIC0geDApIC8gcGFyZW50LnZhbHVlO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnkwID0geTAsIG5vZGUueTEgPSB5MTtcbiAgICBub2RlLngwID0geDAsIG5vZGUueDEgPSB4MCArPSBub2RlLnZhbHVlICogaztcbiAgfVxufVxuIiwiaW1wb3J0IHJvdW5kTm9kZSBmcm9tIFwiLi9yb3VuZC5qc1wiO1xuaW1wb3J0IHNxdWFyaWZ5IGZyb20gXCIuL3NxdWFyaWZ5LmpzXCI7XG5pbXBvcnQge3JlcXVpcmVkfSBmcm9tIFwiLi4vYWNjZXNzb3JzLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQsIHtjb25zdGFudFplcm99IGZyb20gXCIuLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHRpbGUgPSBzcXVhcmlmeSxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nU3RhY2sgPSBbMF0sXG4gICAgICBwYWRkaW5nSW5uZXIgPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nVG9wID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ1JpZ2h0ID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ0JvdHRvbSA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdMZWZ0ID0gY29uc3RhbnRaZXJvO1xuXG4gIGZ1bmN0aW9uIHRyZWVtYXAocm9vdCkge1xuICAgIHJvb3QueDAgPVxuICAgIHJvb3QueTAgPSAwO1xuICAgIHJvb3QueDEgPSBkeDtcbiAgICByb290LnkxID0gZHk7XG4gICAgcm9vdC5lYWNoQmVmb3JlKHBvc2l0aW9uTm9kZSk7XG4gICAgcGFkZGluZ1N0YWNrID0gWzBdO1xuICAgIGlmIChyb3VuZCkgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUobm9kZSkge1xuICAgIHZhciBwID0gcGFkZGluZ1N0YWNrW25vZGUuZGVwdGhdLFxuICAgICAgICB4MCA9IG5vZGUueDAgKyBwLFxuICAgICAgICB5MCA9IG5vZGUueTAgKyBwLFxuICAgICAgICB4MSA9IG5vZGUueDEgLSBwLFxuICAgICAgICB5MSA9IG5vZGUueTEgLSBwO1xuICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgbm9kZS54MCA9IHgwO1xuICAgIG5vZGUueTAgPSB5MDtcbiAgICBub2RlLngxID0geDE7XG4gICAgbm9kZS55MSA9IHkxO1xuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBwID0gcGFkZGluZ1N0YWNrW25vZGUuZGVwdGggKyAxXSA9IHBhZGRpbmdJbm5lcihub2RlKSAvIDI7XG4gICAgICB4MCArPSBwYWRkaW5nTGVmdChub2RlKSAtIHA7XG4gICAgICB5MCArPSBwYWRkaW5nVG9wKG5vZGUpIC0gcDtcbiAgICAgIHgxIC09IHBhZGRpbmdSaWdodChub2RlKSAtIHA7XG4gICAgICB5MSAtPSBwYWRkaW5nQm90dG9tKG5vZGUpIC0gcDtcbiAgICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIHRpbGUobm9kZSwgeDAsIHkwLCB4MSwgeTEpO1xuICAgIH1cbiAgfVxuXG4gIHRyZWVtYXAucm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIXgsIHRyZWVtYXApIDogcm91bmQ7XG4gIH07XG5cbiAgdHJlZW1hcC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWVtYXApIDogW2R4LCBkeV07XG4gIH07XG5cbiAgdHJlZW1hcC50aWxlID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpbGUgPSByZXF1aXJlZCh4KSwgdHJlZW1hcCkgOiB0aWxlO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyZWVtYXAucGFkZGluZ0lubmVyKHgpLnBhZGRpbmdPdXRlcih4KSA6IHRyZWVtYXAucGFkZGluZ0lubmVyKCk7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ091dGVyID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdHJlZW1hcC5wYWRkaW5nVG9wKHgpLnBhZGRpbmdSaWdodCh4KS5wYWRkaW5nQm90dG9tKHgpLnBhZGRpbmdMZWZ0KHgpIDogdHJlZW1hcC5wYWRkaW5nVG9wKCk7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nVG9wID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdUb3AgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nVG9wO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ1JpZ2h0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdSaWdodCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdSaWdodDtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdCb3R0b20gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0JvdHRvbSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdCb3R0b207XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nTGVmdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nTGVmdCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdMZWZ0O1xuICB9O1xuXG4gIHJldHVybiB0cmVlbWFwO1xufVxuIiwiaW1wb3J0IHRyZWVtYXBEaWNlIGZyb20gXCIuL2RpY2UuanNcIjtcbmltcG9ydCB0cmVlbWFwU2xpY2UgZnJvbSBcIi4vc2xpY2UuanNcIjtcbmltcG9ydCB7cGhpLCBzcXVhcmlmeVJhdGlvfSBmcm9tIFwiLi9zcXVhcmlmeS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XG5cbiAgZnVuY3Rpb24gcmVzcXVhcmlmeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgaWYgKChyb3dzID0gcGFyZW50Ll9zcXVhcmlmeSkgJiYgKHJvd3MucmF0aW8gPT09IHJhdGlvKSkge1xuICAgICAgdmFyIHJvd3MsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaiA9IC0xLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgbSA9IHJvd3MubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gcGFyZW50LnZhbHVlO1xuXG4gICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICByb3cgPSByb3dzW2pdLCBub2RlcyA9IHJvdy5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gcm93LnZhbHVlID0gMCwgbiA9IG5vZGVzLmxlbmd0aDsgaSA8IG47ICsraSkgcm93LnZhbHVlICs9IG5vZGVzW2ldLnZhbHVlO1xuICAgICAgICBpZiAocm93LmRpY2UpIHRyZWVtYXBEaWNlKHJvdywgeDAsIHkwLCB4MSwgdmFsdWUgPyB5MCArPSAoeTEgLSB5MCkgKiByb3cudmFsdWUgLyB2YWx1ZSA6IHkxKTtcbiAgICAgICAgZWxzZSB0cmVlbWFwU2xpY2Uocm93LCB4MCwgeTAsIHZhbHVlID8geDAgKz0gKHgxIC0geDApICogcm93LnZhbHVlIC8gdmFsdWUgOiB4MSwgeTEpO1xuICAgICAgICB2YWx1ZSAtPSByb3cudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5fc3F1YXJpZnkgPSByb3dzID0gc3F1YXJpZnlSYXRpbyhyYXRpbywgcGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgICByb3dzLnJhdGlvID0gcmF0aW87XG4gICAgfVxuICB9XG5cbiAgcmVzcXVhcmlmeS5yYXRpbyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY3VzdG9tKCh4ID0gK3gpID4gMSA/IHggOiAxKTtcbiAgfTtcblxuICByZXR1cm4gcmVzcXVhcmlmeTtcbn0pKHBoaSk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUueDAgPSBNYXRoLnJvdW5kKG5vZGUueDApO1xuICBub2RlLnkwID0gTWF0aC5yb3VuZChub2RlLnkwKTtcbiAgbm9kZS54MSA9IE1hdGgucm91bmQobm9kZS54MSk7XG4gIG5vZGUueTEgPSBNYXRoLnJvdW5kKG5vZGUueTEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICBub2RlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIGsgPSBwYXJlbnQudmFsdWUgJiYgKHkxIC0geTApIC8gcGFyZW50LnZhbHVlO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLngwID0geDAsIG5vZGUueDEgPSB4MTtcbiAgICBub2RlLnkwID0geTAsIG5vZGUueTEgPSB5MCArPSBub2RlLnZhbHVlICogaztcbiAgfVxufVxuIiwiaW1wb3J0IGRpY2UgZnJvbSBcIi4vZGljZS5qc1wiO1xuaW1wb3J0IHNsaWNlIGZyb20gXCIuL3NsaWNlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgKHBhcmVudC5kZXB0aCAmIDEgPyBzbGljZSA6IGRpY2UpKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xufVxuIiwiaW1wb3J0IHRyZWVtYXBEaWNlIGZyb20gXCIuL2RpY2UuanNcIjtcbmltcG9ydCB0cmVlbWFwU2xpY2UgZnJvbSBcIi4vc2xpY2UuanNcIjtcblxuZXhwb3J0IHZhciBwaGkgPSAoMSArIE1hdGguc3FydCg1KSkgLyAyO1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJpZnlSYXRpbyhyYXRpbywgcGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgcm93cyA9IFtdLFxuICAgICAgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICByb3csXG4gICAgICBub2RlVmFsdWUsXG4gICAgICBpMCA9IDAsXG4gICAgICBpMSA9IDAsXG4gICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgZHgsIGR5LFxuICAgICAgdmFsdWUgPSBwYXJlbnQudmFsdWUsXG4gICAgICBzdW1WYWx1ZSxcbiAgICAgIG1pblZhbHVlLFxuICAgICAgbWF4VmFsdWUsXG4gICAgICBuZXdSYXRpbyxcbiAgICAgIG1pblJhdGlvLFxuICAgICAgYWxwaGEsXG4gICAgICBiZXRhO1xuXG4gIHdoaWxlIChpMCA8IG4pIHtcbiAgICBkeCA9IHgxIC0geDAsIGR5ID0geTEgLSB5MDtcblxuICAgIC8vIEZpbmQgdGhlIG5leHQgbm9uLWVtcHR5IG5vZGUuXG4gICAgZG8gc3VtVmFsdWUgPSBub2Rlc1tpMSsrXS52YWx1ZTsgd2hpbGUgKCFzdW1WYWx1ZSAmJiBpMSA8IG4pO1xuICAgIG1pblZhbHVlID0gbWF4VmFsdWUgPSBzdW1WYWx1ZTtcbiAgICBhbHBoYSA9IE1hdGgubWF4KGR5IC8gZHgsIGR4IC8gZHkpIC8gKHZhbHVlICogcmF0aW8pO1xuICAgIGJldGEgPSBzdW1WYWx1ZSAqIHN1bVZhbHVlICogYWxwaGE7XG4gICAgbWluUmF0aW8gPSBNYXRoLm1heChtYXhWYWx1ZSAvIGJldGEsIGJldGEgLyBtaW5WYWx1ZSk7XG5cbiAgICAvLyBLZWVwIGFkZGluZyBub2RlcyB3aGlsZSB0aGUgYXNwZWN0IHJhdGlvIG1haW50YWlucyBvciBpbXByb3Zlcy5cbiAgICBmb3IgKDsgaTEgPCBuOyArK2kxKSB7XG4gICAgICBzdW1WYWx1ZSArPSBub2RlVmFsdWUgPSBub2Rlc1tpMV0udmFsdWU7XG4gICAgICBpZiAobm9kZVZhbHVlIDwgbWluVmFsdWUpIG1pblZhbHVlID0gbm9kZVZhbHVlO1xuICAgICAgaWYgKG5vZGVWYWx1ZSA+IG1heFZhbHVlKSBtYXhWYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICAgIGJldGEgPSBzdW1WYWx1ZSAqIHN1bVZhbHVlICogYWxwaGE7XG4gICAgICBuZXdSYXRpbyA9IE1hdGgubWF4KG1heFZhbHVlIC8gYmV0YSwgYmV0YSAvIG1pblZhbHVlKTtcbiAgICAgIGlmIChuZXdSYXRpbyA+IG1pblJhdGlvKSB7IHN1bVZhbHVlIC09IG5vZGVWYWx1ZTsgYnJlYWs7IH1cbiAgICAgIG1pblJhdGlvID0gbmV3UmF0aW87XG4gICAgfVxuXG4gICAgLy8gUG9zaXRpb24gYW5kIHJlY29yZCB0aGUgcm93IG9yaWVudGF0aW9uLlxuICAgIHJvd3MucHVzaChyb3cgPSB7dmFsdWU6IHN1bVZhbHVlLCBkaWNlOiBkeCA8IGR5LCBjaGlsZHJlbjogbm9kZXMuc2xpY2UoaTAsIGkxKX0pO1xuICAgIGlmIChyb3cuZGljZSkgdHJlZW1hcERpY2Uocm93LCB4MCwgeTAsIHgxLCB2YWx1ZSA/IHkwICs9IGR5ICogc3VtVmFsdWUgLyB2YWx1ZSA6IHkxKTtcbiAgICBlbHNlIHRyZWVtYXBTbGljZShyb3csIHgwLCB5MCwgdmFsdWUgPyB4MCArPSBkeCAqIHN1bVZhbHVlIC8gdmFsdWUgOiB4MSwgeTEpO1xuICAgIHZhbHVlIC09IHN1bVZhbHVlLCBpMCA9IGkxO1xuICB9XG5cbiAgcmV0dXJuIHJvd3M7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20ocmF0aW8pIHtcblxuICBmdW5jdGlvbiBzcXVhcmlmeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgc3F1YXJpZnlSYXRpbyhyYXRpbywgcGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG4gIH1cblxuICBzcXVhcmlmeS5yYXRpbyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY3VzdG9tKCh4ID0gK3gpID4gMSA/IHggOiAxKTtcbiAgfTtcblxuICByZXR1cm4gc3F1YXJpZnk7XG59KShwaGkpO1xuIiwiaW1wb3J0IHsgY2FudmFzIH0gZnJvbSAndmVnYS1jYW52YXMnO1xuaW1wb3J0IHsgcmVkZXJpdmUsIFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgTWFya3MsIHRleHRNZXRyaWNzIH0gZnJvbSAndmVnYS1zY2VuZWdyYXBoJztcbmltcG9ydCB7IGluaGVyaXRzLCBpc0Z1bmN0aW9uLCBlcnJvciwgYXJyYXkgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5jb25zdCBBTFBIQV9NQVNLID0gMHhmZjAwMDAwMDsgLy8gYWxwaGEgdmFsdWUgZXF1aXZhbGVudCB0byBvcGFjaXR5IDAuMDYyNVxuXG5jb25zdCBJTlNJREVfT1BBQ0lUWV9JTl9BTFBIQSA9IDB4MTAwMDAwMDA7XG5jb25zdCBJTlNJREVfT1BBQ0lUWSA9IDAuMDYyNTtcbmZ1bmN0aW9uIGJhc2VCaXRtYXBzKCQsIGRhdGEpIHtcbiAgY29uc3QgYml0bWFwID0gJC5iaXRtYXAoKTsgLy8gd2hlbiB0aGVyZSBpcyBubyBiYXNlIG1hcmsgYnV0IGRhdGEgcG9pbnRzIGFyZSB0byBiZSBhdm9pZGVkXG5cbiAgKGRhdGEgfHwgW10pLmZvckVhY2goZCA9PiBiaXRtYXAuc2V0KCQoZC5ib3VuZGFyeVswXSksICQoZC5ib3VuZGFyeVszXSkpKTtcbiAgcmV0dXJuIFtiaXRtYXAsIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBtYXJrQml0bWFwcygkLCBhdm9pZE1hcmtzLCBsYWJlbEluc2lkZSwgaXNHcm91cEFyZWEpIHtcbiAgLy8gY3JlYXRlIGNhbnZhc1xuICBjb25zdCB3aWR0aCA9ICQud2lkdGgsXG4gICAgICAgIGhlaWdodCA9ICQuaGVpZ2h0LFxuICAgICAgICBib3JkZXIgPSBsYWJlbEluc2lkZSB8fCBpc0dyb3VwQXJlYSxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcyh3aWR0aCwgaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpOyAvLyByZW5kZXIgYWxsIG1hcmtzIHRvIGJlIGF2b2lkZWQgaW50byBjYW52YXNcblxuICBhdm9pZE1hcmtzLmZvckVhY2goaXRlbXMgPT4gZHJhdyhjb250ZXh0LCBpdGVtcywgYm9yZGVyKSk7IC8vIGdldCBjYW52YXMgYnVmZmVyLCBjcmVhdGUgYml0bWFwc1xuXG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhLmJ1ZmZlciksXG4gICAgICAgIGxheWVyMSA9ICQuYml0bWFwKCksXG4gICAgICAgIGxheWVyMiA9IGJvcmRlciAmJiAkLmJpdG1hcCgpOyAvLyBwb3B1bGF0ZSBiaXRtYXAgbGF5ZXJzXG5cbiAgbGV0IHgsIHksIHUsIHYsIGFscGhhO1xuXG4gIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICBhbHBoYSA9IGJ1ZmZlclt5ICogd2lkdGggKyB4XSAmIEFMUEhBX01BU0s7XG5cbiAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICB1ID0gJCh4KTtcbiAgICAgICAgdiA9ICQoeSk7XG4gICAgICAgIGlmICghaXNHcm91cEFyZWEpIGxheWVyMS5zZXQodSwgdik7IC8vIHVwZGF0ZSBpbnRlcmlvciBiaXRtYXBcblxuICAgICAgICBpZiAoYm9yZGVyICYmIGFscGhhIF4gSU5TSURFX09QQUNJVFlfSU5fQUxQSEEpIGxheWVyMi5zZXQodSwgdik7IC8vIHVwZGF0ZSBib3JkZXIgYml0bWFwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtsYXllcjEsIGxheWVyMl07XG59XG5cbmZ1bmN0aW9uIGRyYXcoY29udGV4dCwgaXRlbXMsIGludGVyaW9yKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIGNvbnN0IHR5cGUgPSBpdGVtc1swXS5tYXJrLm1hcmt0eXBlO1xuXG4gIGlmICh0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgaXRlbXMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgICBncm91cC5pdGVtcy5mb3JFYWNoKG1hcmsgPT4gZHJhdyhjb250ZXh0LCBtYXJrLml0ZW1zLCBpbnRlcmlvcikpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIE1hcmtzW3R5cGVdLmRyYXcoY29udGV4dCwge1xuICAgICAgaXRlbXM6IGludGVyaW9yID8gaXRlbXMubWFwKHByZXBhcmUpIDogaXRlbXNcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBQcmVwYXJlIGl0ZW0gYmVmb3JlIGRyYXdpbmcgaW50byBjYW52YXMgKHNldHRpbmcgc3Ryb2tlIGFuZCBvcGFjaXR5KVxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZSBpdGVtIHRvIGJlIHByZXBhcmVkXG4gKiBAcmV0dXJucyBwcmVwYXJlZCBpdGVtXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlKHNvdXJjZSkge1xuICBjb25zdCBpdGVtID0gcmVkZXJpdmUoc291cmNlLCB7fSk7XG5cbiAgaWYgKGl0ZW0uc3Ryb2tlKSB7XG4gICAgaXRlbS5zdHJva2VPcGFjaXR5ID0gMTtcbiAgfVxuXG4gIGlmIChpdGVtLmZpbGwpIHtcbiAgICBpdGVtLmZpbGxPcGFjaXR5ID0gSU5TSURFX09QQUNJVFk7XG4gICAgaXRlbS5zdHJva2UgPSAnIzAwMCc7XG4gICAgaXRlbS5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICBpdGVtLnN0cm9rZVdpZHRoID0gMjtcbiAgfVxuXG4gIHJldHVybiBpdGVtO1xufVxuXG5jb25zdCBESVYgPSA1LFxuICAgICAgLy8gYml0IHNoaWZ0IGZyb20geCwgeSBpbmRleCB0byBiaXQgdmVjdG9yIGFycmF5IGluZGV4XG5NT0QgPSAzMSxcbiAgICAgIC8vIGJpdCBtYXNrIGZvciBpbmRleCBsb29rdXAgd2l0aGluIGEgYml0IHZlY3RvclxuU0laRSA9IDMyLFxuICAgICAgLy8gaW5kaXZpZHVhbCBiaXQgdmVjdG9yIHNpemVcblJJR0hUMCA9IG5ldyBVaW50MzJBcnJheShTSVpFICsgMSksXG4gICAgICAvLyBsZWZ0LWFuY2hvcmVkIGJpdCB2ZWN0b3JzLCBmdWxsIC0+IDBcblJJR0hUMSA9IG5ldyBVaW50MzJBcnJheShTSVpFICsgMSk7IC8vIHJpZ2h0LWFuY2hvcmVkIGJpdCB2ZWN0b3JzLCAwIC0+IGZ1bGxcblxuUklHSFQxWzBdID0gMDtcblJJR0hUMFswXSA9IH5SSUdIVDFbMF07XG5cbmZvciAobGV0IGkgPSAxOyBpIDw9IFNJWkU7ICsraSkge1xuICBSSUdIVDFbaV0gPSBSSUdIVDFbaSAtIDFdIDw8IDEgfCAxO1xuICBSSUdIVDBbaV0gPSB+UklHSFQxW2ldO1xufVxuXG5mdW5jdGlvbiBCaXRtYXAgKHcsIGgpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkofn4oKHcgKiBoICsgU0laRSkgLyBTSVpFKSk7XG5cbiAgZnVuY3Rpb24gX3NldChpbmRleCwgbWFzaykge1xuICAgIGFycmF5W2luZGV4XSB8PSBtYXNrO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsZWFyKGluZGV4LCBtYXNrKSB7XG4gICAgYXJyYXlbaW5kZXhdICY9IG1hc2s7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFycmF5OiBhcnJheSxcbiAgICBnZXQ6ICh4LCB5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHkgKiB3ICsgeDtcbiAgICAgIHJldHVybiBhcnJheVtpbmRleCA+Pj4gRElWXSAmIDEgPDwgKGluZGV4ICYgTU9EKTtcbiAgICB9LFxuICAgIHNldDogKHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0geSAqIHcgKyB4O1xuXG4gICAgICBfc2V0KGluZGV4ID4+PiBESVYsIDEgPDwgKGluZGV4ICYgTU9EKSk7XG4gICAgfSxcbiAgICBjbGVhcjogKHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0geSAqIHcgKyB4O1xuXG4gICAgICBfY2xlYXIoaW5kZXggPj4+IERJViwgfigxIDw8IChpbmRleCAmIE1PRCkpKTtcbiAgICB9LFxuICAgIGdldFJhbmdlOiAoeCwgeSwgeDIsIHkyKSA9PiB7XG4gICAgICBsZXQgciA9IHkyLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBpbmRleFN0YXJ0LFxuICAgICAgICAgIGluZGV4RW5kO1xuXG4gICAgICBmb3IgKDsgciA+PSB5OyAtLXIpIHtcbiAgICAgICAgc3RhcnQgPSByICogdyArIHg7XG4gICAgICAgIGVuZCA9IHIgKiB3ICsgeDI7XG4gICAgICAgIGluZGV4U3RhcnQgPSBzdGFydCA+Pj4gRElWO1xuICAgICAgICBpbmRleEVuZCA9IGVuZCA+Pj4gRElWO1xuXG4gICAgICAgIGlmIChpbmRleFN0YXJ0ID09PSBpbmRleEVuZCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleFN0YXJ0XSAmIFJJR0hUMFtzdGFydCAmIE1PRF0gJiBSSUdIVDFbKGVuZCAmIE1PRCkgKyAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleFN0YXJ0XSAmIFJJR0hUMFtzdGFydCAmIE1PRF0pIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleEVuZF0gJiBSSUdIVDFbKGVuZCAmIE1PRCkgKyAxXSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXhTdGFydCArIDE7IGkgPCBpbmRleEVuZDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBzZXRSYW5nZTogKHgsIHksIHgyLCB5MikgPT4ge1xuICAgICAgbGV0IHN0YXJ0LCBlbmQsIGluZGV4U3RhcnQsIGluZGV4RW5kLCBpO1xuXG4gICAgICBmb3IgKDsgeSA8PSB5MjsgKyt5KSB7XG4gICAgICAgIHN0YXJ0ID0geSAqIHcgKyB4O1xuICAgICAgICBlbmQgPSB5ICogdyArIHgyO1xuICAgICAgICBpbmRleFN0YXJ0ID0gc3RhcnQgPj4+IERJVjtcbiAgICAgICAgaW5kZXhFbmQgPSBlbmQgPj4+IERJVjtcblxuICAgICAgICBpZiAoaW5kZXhTdGFydCA9PT0gaW5kZXhFbmQpIHtcbiAgICAgICAgICBfc2V0KGluZGV4U3RhcnQsIFJJR0hUMFtzdGFydCAmIE1PRF0gJiBSSUdIVDFbKGVuZCAmIE1PRCkgKyAxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3NldChpbmRleFN0YXJ0LCBSSUdIVDBbc3RhcnQgJiBNT0RdKTtcblxuICAgICAgICAgIF9zZXQoaW5kZXhFbmQsIFJJR0hUMVsoZW5kICYgTU9EKSArIDFdKTtcblxuICAgICAgICAgIGZvciAoaSA9IGluZGV4U3RhcnQgKyAxOyBpIDwgaW5kZXhFbmQ7ICsraSkgX3NldChpLCAweGZmZmZmZmZmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXJSYW5nZTogKHgsIHksIHgyLCB5MikgPT4ge1xuICAgICAgbGV0IHN0YXJ0LCBlbmQsIGluZGV4U3RhcnQsIGluZGV4RW5kLCBpO1xuXG4gICAgICBmb3IgKDsgeSA8PSB5MjsgKyt5KSB7XG4gICAgICAgIHN0YXJ0ID0geSAqIHcgKyB4O1xuICAgICAgICBlbmQgPSB5ICogdyArIHgyO1xuICAgICAgICBpbmRleFN0YXJ0ID0gc3RhcnQgPj4+IERJVjtcbiAgICAgICAgaW5kZXhFbmQgPSBlbmQgPj4+IERJVjtcblxuICAgICAgICBpZiAoaW5kZXhTdGFydCA9PT0gaW5kZXhFbmQpIHtcbiAgICAgICAgICBfY2xlYXIoaW5kZXhTdGFydCwgUklHSFQxW3N0YXJ0ICYgTU9EXSB8IFJJR0hUMFsoZW5kICYgTU9EKSArIDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfY2xlYXIoaW5kZXhTdGFydCwgUklHSFQxW3N0YXJ0ICYgTU9EXSk7XG5cbiAgICAgICAgICBfY2xlYXIoaW5kZXhFbmQsIFJJR0hUMFsoZW5kICYgTU9EKSArIDFdKTtcblxuICAgICAgICAgIGZvciAoaSA9IGluZGV4U3RhcnQgKyAxOyBpIDwgaW5kZXhFbmQ7ICsraSkgX2NsZWFyKGksIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvdXRPZkJvdW5kczogKHgsIHksIHgyLCB5MikgPT4geCA8IDAgfHwgeSA8IDAgfHwgeTIgPj0gaCB8fCB4MiA+PSB3XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYWxlciAod2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICBjb25zdCByYXRpbyA9IE1hdGgubWF4KDEsIE1hdGguc3FydCh3aWR0aCAqIGhlaWdodCAvIDFlNikpLFxuICAgICAgICB3ID0gfn4oKHdpZHRoICsgMiAqIHBhZGRpbmcgKyByYXRpbykgLyByYXRpbyksXG4gICAgICAgIGggPSB+figoaGVpZ2h0ICsgMiAqIHBhZGRpbmcgKyByYXRpbykgLyByYXRpbyksXG4gICAgICAgIHNjYWxlID0gXyA9PiB+figoXyArIHBhZGRpbmcpIC8gcmF0aW8pO1xuXG4gIHNjYWxlLmludmVydCA9IF8gPT4gXyAqIHJhdGlvIC0gcGFkZGluZztcblxuICBzY2FsZS5iaXRtYXAgPSAoKSA9PiBCaXRtYXAodywgaCk7XG5cbiAgc2NhbGUucmF0aW8gPSByYXRpbztcbiAgc2NhbGUucGFkZGluZyA9IHBhZGRpbmc7XG4gIHNjYWxlLndpZHRoID0gd2lkdGg7XG4gIHNjYWxlLmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBwbGFjZUFyZWFMYWJlbE5haXZlICgkLCBiaXRtYXBzLCBhdm9pZEJhc2VNYXJrLCBtYXJrSW5kZXgpIHtcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSAkLmhlaWdodDsgLy8gdHJ5IHRvIHBsYWNlIGEgbGFiZWwgd2l0aGluIGFuIGlucHV0IGFyZWEgbWFya1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGNvbnN0IGl0ZW1zID0gZC5kYXR1bS5kYXR1bS5pdGVtc1ttYXJrSW5kZXhdLml0ZW1zLFxuICAgICAgICAgIC8vIGFyZWEgcG9pbnRzXG4gICAgbiA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAvLyBudW1iZXIgb2YgcG9pbnRzXG4gICAgdGV4dEhlaWdodCA9IGQuZGF0dW0uZm9udFNpemUsXG4gICAgICAgICAgLy8gbGFiZWwgd2lkdGhcbiAgICB0ZXh0V2lkdGggPSB0ZXh0TWV0cmljcy53aWR0aChkLmRhdHVtLCBkLmRhdHVtLnRleHQpOyAvLyBsYWJlbCBoZWlnaHRcblxuICAgIGxldCBtYXhBcmVhV2lkdGggPSAwLFxuICAgICAgICB4MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkxLFxuICAgICAgICB5MixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYXJlYVdpZHRoOyAvLyBmb3IgZWFjaCBhcmVhIHNhbXBsZSBwb2ludFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHgxID0gaXRlbXNbaV0ueDtcbiAgICAgIHkxID0gaXRlbXNbaV0ueTtcbiAgICAgIHgyID0gaXRlbXNbaV0ueDIgPT09IHVuZGVmaW5lZCA/IHgxIDogaXRlbXNbaV0ueDI7XG4gICAgICB5MiA9IGl0ZW1zW2ldLnkyID09PSB1bmRlZmluZWQgPyB5MSA6IGl0ZW1zW2ldLnkyO1xuICAgICAgeCA9ICh4MSArIHgyKSAvIDI7XG4gICAgICB5ID0gKHkxICsgeTIpIC8gMjtcbiAgICAgIGFyZWFXaWR0aCA9IE1hdGguYWJzKHgyIC0geDEgKyB5MiAtIHkxKTtcblxuICAgICAgaWYgKGFyZWFXaWR0aCA+PSBtYXhBcmVhV2lkdGgpIHtcbiAgICAgICAgbWF4QXJlYVdpZHRoID0gYXJlYVdpZHRoO1xuICAgICAgICBkLnggPSB4O1xuICAgICAgICBkLnkgPSB5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHggPSB0ZXh0V2lkdGggLyAyO1xuICAgIHkgPSB0ZXh0SGVpZ2h0IC8gMjtcbiAgICB4MSA9IGQueCAtIHg7XG4gICAgeDIgPSBkLnggKyB4O1xuICAgIHkxID0gZC55IC0geTtcbiAgICB5MiA9IGQueSArIHk7XG4gICAgZC5hbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgaWYgKHgxIDwgMCAmJiB4MiA8PSB3aWR0aCkge1xuICAgICAgZC5hbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKDAgPD0geDEgJiYgd2lkdGggPCB4Mikge1xuICAgICAgZC5hbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuXG4gICAgZC5iYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgaWYgKHkxIDwgMCAmJiB5MiA8PSBoZWlnaHQpIHtcbiAgICAgIGQuYmFzZWxpbmUgPSAndG9wJztcbiAgICB9IGVsc2UgaWYgKDAgPD0geTEgJiYgaGVpZ2h0IDwgeTIpIHtcbiAgICAgIGQuYmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3V0T2ZCb3VuZHMoeCwgeSwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGxldCByID0gdGV4dFdpZHRoIC8gMjtcbiAgcmV0dXJuIHggLSByIDwgMCB8fCB4ICsgciA+IHdpZHRoIHx8IHkgLSAociA9IHRleHRIZWlnaHQgLyAyKSA8IDAgfHwgeSArIHIgPiBoZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIF9vdXRPZkJvdW5kcygpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCBoLCBibTAsIGJtMSkge1xuICBjb25zdCB3ID0gdGV4dFdpZHRoICogaCAvICh0ZXh0SGVpZ2h0ICogMiksXG4gICAgICAgIHgxID0gJCh4IC0gdyksXG4gICAgICAgIHgyID0gJCh4ICsgdyksXG4gICAgICAgIHkxID0gJCh5IC0gKGggPSBoIC8gMikpLFxuICAgICAgICB5MiA9ICQoeSArIGgpO1xuICByZXR1cm4gYm0wLm91dE9mQm91bmRzKHgxLCB5MSwgeDIsIHkyKSB8fCBibTAuZ2V0UmFuZ2UoeDEsIHkxLCB4MiwgeTIpIHx8IGJtMSAmJiBibTEuZ2V0UmFuZ2UoeDEsIHkxLCB4MiwgeTIpO1xufVxuXG5mdW5jdGlvbiBfY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgaCwgYm0wLCBibTEpIHtcbiAgY29uc3QgdyA9IHRleHRXaWR0aCAqIGggLyAodGV4dEhlaWdodCAqIDIpO1xuICBsZXQgeDEgPSAkKHggLSB3KSxcbiAgICAgIHgyID0gJCh4ICsgdyksXG4gICAgICB5MSA9ICQoeSAtIChoID0gaCAvIDIpKSxcbiAgICAgIHkyID0gJCh5ICsgaCk7XG4gIHgxID0geDEgPiAwID8geDEgOiAwO1xuICB5MSA9IHkxID4gMCA/IHkxIDogMDtcbiAgeDIgPSB4MiA8ICQud2lkdGggPyB4MiA6ICQud2lkdGggLSAxO1xuICB5MiA9IHkyIDwgJC5oZWlnaHQgPyB5MiA6ICQuaGVpZ2h0IC0gMTtcbiAgcmV0dXJuIGJtMC5nZXRSYW5nZSh4MSwgeTEsIHgyLCB5MikgfHwgYm0xICYmIGJtMS5nZXRSYW5nZSh4MSwgeTEsIHgyLCB5Mik7XG59XG5cbmZ1bmN0aW9uIGdldFRlc3RzKGluZlBhZGRpbmcpIHtcbiAgcmV0dXJuIGluZlBhZGRpbmcgPyBbX2NvbGxpc2lvbiwgX291dE9mQm91bmRzXSA6IFtjb2xsaXNpb24sIG91dE9mQm91bmRzXTtcbn1cblxuZnVuY3Rpb24gcGxhY2VBcmVhTGFiZWxSZWR1Y2VkU2VhcmNoICgkLCBiaXRtYXBzLCBhdm9pZEJhc2VNYXJrLCBtYXJrSW5kZXgsIGluZlBhZGRpbmcpIHtcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSAkLmhlaWdodCxcbiAgICAgICAgW2NvbGxpc2lvbiwgb3V0T2ZCb3VuZHNdID0gZ2V0VGVzdHMoaW5mUGFkZGluZyksXG4gICAgICAgIGJtMCA9IGJpdG1hcHNbMF0sXG4gICAgICAgIC8vIHdoZXJlIGxhYmVscyBoYXZlIGJlZW4gcGxhY2VkXG4gIGJtMSA9IGJpdG1hcHNbMV07IC8vIGFyZWEgb3V0bGluZXNcblxuICBmdW5jdGlvbiB0cnlMYWJlbChfeCwgX3ksIG1heFNpemUsIHRleHRXaWR0aCwgdGV4dEhlaWdodCkge1xuICAgIGNvbnN0IHggPSAkLmludmVydChfeCksXG4gICAgICAgICAgeSA9ICQuaW52ZXJ0KF95KTtcbiAgICBsZXQgbG8gPSBtYXhTaXplLFxuICAgICAgICBoaSA9IGhlaWdodCxcbiAgICAgICAgbWlkO1xuXG4gICAgaWYgKCFvdXRPZkJvdW5kcyh4LCB5LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIHdpZHRoLCBoZWlnaHQpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCBsbywgYm0wLCBibTEpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCBibTAsIG51bGwpKSB7XG4gICAgICAvLyBpZiB0aGUgbGFiZWwgZml0cyBhdCB0aGUgY3VycmVudCBzYW1wbGUgcG9pbnQsXG4gICAgICAvLyBwZXJmb3JtIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgbGFyZ2VzdCBmb250IHNpemUgdGhhdCBmaXRzXG4gICAgICB3aGlsZSAoaGkgLSBsbyA+PSAxKSB7XG4gICAgICAgIG1pZCA9IChsbyArIGhpKSAvIDI7XG5cbiAgICAgICAgaWYgKGNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIG1pZCwgYm0wLCBibTEpKSB7XG4gICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG8gPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcGxhY2UgbGFiZWwgaWYgY3VycmVudCBsb3dlciBib3VuZCBleGNlZWRzIHByaW9yIG1heCBmb250IHNpemVcblxuXG4gICAgICBpZiAobG8gPiBtYXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbeCwgeSwgbG8sIHRydWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyB0cnkgdG8gcGxhY2UgYSBsYWJlbCB3aXRoaW4gYW4gaW5wdXQgYXJlYSBtYXJrXG5cblxuICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICBjb25zdCBpdGVtcyA9IGQuZGF0dW0uZGF0dW0uaXRlbXNbbWFya0luZGV4XS5pdGVtcyxcbiAgICAgICAgICAvLyBhcmVhIHBvaW50c1xuICAgIG4gPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgLy8gbnVtYmVyIG9mIHBvaW50c1xuICAgIHRleHRIZWlnaHQgPSBkLmRhdHVtLmZvbnRTaXplLFxuICAgICAgICAgIC8vIGxhYmVsIHdpZHRoXG4gICAgdGV4dFdpZHRoID0gdGV4dE1ldHJpY3Mud2lkdGgoZC5kYXR1bSwgZC5kYXR1bS50ZXh0KTsgLy8gbGFiZWwgaGVpZ2h0XG5cbiAgICBsZXQgbWF4U2l6ZSA9IGF2b2lkQmFzZU1hcmsgPyB0ZXh0SGVpZ2h0IDogMCxcbiAgICAgICAgbGFiZWxQbGFjZWQgPSBmYWxzZSxcbiAgICAgICAgbGFiZWxQbGFjZWQyID0gZmFsc2UsXG4gICAgICAgIG1heEFyZWFXaWR0aCA9IDAsXG4gICAgICAgIHgxLFxuICAgICAgICB4MixcbiAgICAgICAgeTEsXG4gICAgICAgIHkyLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBfeCxcbiAgICAgICAgX3ksXG4gICAgICAgIF94MSxcbiAgICAgICAgX3hNaWQsXG4gICAgICAgIF94MixcbiAgICAgICAgX3kxLFxuICAgICAgICBfeU1pZCxcbiAgICAgICAgX3kyLFxuICAgICAgICBhcmVhV2lkdGgsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgc3dhcFRtcDsgLy8gZm9yIGVhY2ggYXJlYSBzYW1wbGUgcG9pbnRcblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHgxID0gaXRlbXNbaV0ueDtcbiAgICAgIHkxID0gaXRlbXNbaV0ueTtcbiAgICAgIHgyID0gaXRlbXNbaV0ueDIgPT09IHVuZGVmaW5lZCA/IHgxIDogaXRlbXNbaV0ueDI7XG4gICAgICB5MiA9IGl0ZW1zW2ldLnkyID09PSB1bmRlZmluZWQgPyB5MSA6IGl0ZW1zW2ldLnkyO1xuXG4gICAgICBpZiAoeDEgPiB4Mikge1xuICAgICAgICBzd2FwVG1wID0geDE7XG4gICAgICAgIHgxID0geDI7XG4gICAgICAgIHgyID0gc3dhcFRtcDtcbiAgICAgIH1cblxuICAgICAgaWYgKHkxID4geTIpIHtcbiAgICAgICAgc3dhcFRtcCA9IHkxO1xuICAgICAgICB5MSA9IHkyO1xuICAgICAgICB5MiA9IHN3YXBUbXA7XG4gICAgICB9XG5cbiAgICAgIF94MSA9ICQoeDEpO1xuICAgICAgX3gyID0gJCh4Mik7XG4gICAgICBfeE1pZCA9IH5+KChfeDEgKyBfeDIpIC8gMik7XG4gICAgICBfeTEgPSAkKHkxKTtcbiAgICAgIF95MiA9ICQoeTIpO1xuICAgICAgX3lNaWQgPSB+figoX3kxICsgX3kyKSAvIDIpOyAvLyBzZWFyY2ggYWxvbmcgdGhlIGxpbmUgZnJvbSBtaWQgcG9pbnQgYmV0d2VlbiB0aGUgMiBib3JkZXIgdG8gbG93ZXIgYm9yZGVyXG5cbiAgICAgIGZvciAoX3ggPSBfeE1pZDsgX3ggPj0gX3gxOyAtLV94KSB7XG4gICAgICAgIGZvciAoX3kgPSBfeU1pZDsgX3kgPj0gX3kxOyAtLV95KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdHJ5TGFiZWwoX3gsIF95LCBtYXhTaXplLCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgW2QueCwgZC55LCBtYXhTaXplLCBsYWJlbFBsYWNlZF0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHNlYXJjaCBhbG9uZyB0aGUgbGluZSBmcm9tIG1pZCBwb2ludCBiZXR3ZWVuIHRoZSAyIGJvcmRlciB0byB1cHBlciBib3JkZXJcblxuXG4gICAgICBmb3IgKF94ID0gX3hNaWQ7IF94IDw9IF94MjsgKytfeCkge1xuICAgICAgICBmb3IgKF95ID0gX3lNaWQ7IF95IDw9IF95MjsgKytfeSkge1xuICAgICAgICAgIHJlc3VsdCA9IHRyeUxhYmVsKF94LCBfeSwgbWF4U2l6ZSwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIFtkLngsIGQueSwgbWF4U2l6ZSwgbGFiZWxQbGFjZWRdID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBwbGFjZSBsYWJlbCBhdCBzbGljZSBjZW50ZXIgaWYgbm90IHBsYWNlZCB0aHJvdWdoIG90aGVyIG1lYW5zXG4gICAgICAvLyBhbmQgaWYgd2UncmUgbm90IGF2b2lkaW5nIG92ZXJsYXAgd2l0aCBvdGhlciBhcmVhc1xuXG5cbiAgICAgIGlmICghbGFiZWxQbGFjZWQgJiYgIWF2b2lkQmFzZU1hcmspIHtcbiAgICAgICAgLy8gb25lIHNwYW4gaXMgemVybywgaGVuY2Ugd2UgY2FuIGFkZFxuICAgICAgICBhcmVhV2lkdGggPSBNYXRoLmFicyh4MiAtIHgxICsgeTIgLSB5MSk7XG4gICAgICAgIHggPSAoeDEgKyB4MikgLyAyO1xuICAgICAgICB5ID0gKHkxICsgeTIpIC8gMjsgLy8gcGxhY2UgbGFiZWwgaWYgaXQgZml0cyBhbmQgaW1wcm92ZXMgdGhlIG1heCBhcmVhIHdpZHRoXG5cbiAgICAgICAgaWYgKGFyZWFXaWR0aCA+PSBtYXhBcmVhV2lkdGggJiYgIW91dE9mQm91bmRzKHgsIHksIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgd2lkdGgsIGhlaWdodCkgJiYgIWNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIGJtMCwgbnVsbCkpIHtcbiAgICAgICAgICBtYXhBcmVhV2lkdGggPSBhcmVhV2lkdGg7XG4gICAgICAgICAgZC54ID0geDtcbiAgICAgICAgICBkLnkgPSB5O1xuICAgICAgICAgIGxhYmVsUGxhY2VkMiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHJlY29yZCBjdXJyZW50IGxhYmVsIHBsYWNlbWVudCBpbmZvcm1hdGlvbiwgdXBkYXRlIGxhYmVsIGJpdG1hcFxuXG5cbiAgICBpZiAobGFiZWxQbGFjZWQgfHwgbGFiZWxQbGFjZWQyKSB7XG4gICAgICB4ID0gdGV4dFdpZHRoIC8gMjtcbiAgICAgIHkgPSB0ZXh0SGVpZ2h0IC8gMjtcbiAgICAgIGJtMC5zZXRSYW5nZSgkKGQueCAtIHgpLCAkKGQueSAtIHkpLCAkKGQueCArIHgpLCAkKGQueSArIHkpKTtcbiAgICAgIGQuYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGQuYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBYX0RJUiA9IFstMSwgLTEsIDEsIDFdO1xuY29uc3QgWV9ESVIgPSBbLTEsIDEsIC0xLCAxXTtcbmZ1bmN0aW9uIHBsYWNlQXJlYUxhYmVsRmxvb2RGaWxsICgkLCBiaXRtYXBzLCBhdm9pZEJhc2VNYXJrLCBtYXJrSW5kZXgsIGluZlBhZGRpbmcpIHtcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSAkLmhlaWdodCxcbiAgICAgICAgW2NvbGxpc2lvbiwgb3V0T2ZCb3VuZHNdID0gZ2V0VGVzdHMoaW5mUGFkZGluZyksXG4gICAgICAgIGJtMCA9IGJpdG1hcHNbMF0sXG4gICAgICAgIC8vIHdoZXJlIGxhYmVscyBoYXZlIGJlZW4gcGxhY2VkXG4gIGJtMSA9IGJpdG1hcHNbMV0sXG4gICAgICAgIC8vIGFyZWEgb3V0bGluZXNcbiAgYm0yID0gJC5iaXRtYXAoKTsgLy8gZmxvb2QtZmlsbCB2aXNpdGF0aW9uc1xuICAvLyB0cnkgdG8gcGxhY2UgYSBsYWJlbCB3aXRoaW4gYW4gaW5wdXQgYXJlYSBtYXJrXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgY29uc3QgaXRlbXMgPSBkLmRhdHVtLmRhdHVtLml0ZW1zW21hcmtJbmRleF0uaXRlbXMsXG4gICAgICAgICAgLy8gYXJlYSBwb2ludHNcbiAgICBuID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIC8vIG51bWJlciBvZiBwb2ludHNcbiAgICB0ZXh0SGVpZ2h0ID0gZC5kYXR1bS5mb250U2l6ZSxcbiAgICAgICAgICAvLyBsYWJlbCB3aWR0aFxuICAgIHRleHRXaWR0aCA9IHRleHRNZXRyaWNzLndpZHRoKGQuZGF0dW0sIGQuZGF0dW0udGV4dCksXG4gICAgICAgICAgLy8gbGFiZWwgaGVpZ2h0XG4gICAgc3RhY2sgPSBbXTsgLy8gZmxvb2QgZmlsbCBzdGFja1xuXG4gICAgbGV0IG1heFNpemUgPSBhdm9pZEJhc2VNYXJrID8gdGV4dEhlaWdodCA6IDAsXG4gICAgICAgIGxhYmVsUGxhY2VkID0gZmFsc2UsXG4gICAgICAgIGxhYmVsUGxhY2VkMiA9IGZhbHNlLFxuICAgICAgICBtYXhBcmVhV2lkdGggPSAwLFxuICAgICAgICB4MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkxLFxuICAgICAgICB5MixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgX3gsXG4gICAgICAgIF95LFxuICAgICAgICBsbyxcbiAgICAgICAgaGksXG4gICAgICAgIG1pZCxcbiAgICAgICAgYXJlYVdpZHRoOyAvLyBmb3IgZWFjaCBhcmVhIHNhbXBsZSBwb2ludFxuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgeDEgPSBpdGVtc1tpXS54O1xuICAgICAgeTEgPSBpdGVtc1tpXS55O1xuICAgICAgeDIgPSBpdGVtc1tpXS54MiA9PT0gdW5kZWZpbmVkID8geDEgOiBpdGVtc1tpXS54MjtcbiAgICAgIHkyID0gaXRlbXNbaV0ueTIgPT09IHVuZGVmaW5lZCA/IHkxIDogaXRlbXNbaV0ueTI7IC8vIGFkZCBzY2FsZWQgY2VudGVyIHBvaW50IHRvIHN0YWNrXG5cbiAgICAgIHN0YWNrLnB1c2goWyQoKHgxICsgeDIpIC8gMiksICQoKHkxICsgeTIpIC8gMildKTsgLy8gcGVyZm9ybSBmbG9vZCBmaWxsLCB2aXNpdCBwb2ludHNcblxuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBbX3gsIF95XSA9IHN0YWNrLnBvcCgpOyAvLyBleGl0IGlmIHBvaW50IGFscmVhZHkgbWFya2VkXG5cbiAgICAgICAgaWYgKGJtMC5nZXQoX3gsIF95KSB8fCBibTEuZ2V0KF94LCBfeSkgfHwgYm0yLmdldChfeCwgX3kpKSBjb250aW51ZTsgLy8gbWFyayBwb2ludCBpbiBmbG9vZCBmaWxsIGJpdG1hcFxuICAgICAgICAvLyBhZGQgc2VhcmNoIHBvaW50cyBmb3IgYWxsIChpbiBib3VuZCkgZGlyZWN0aW9uc1xuXG4gICAgICAgIGJtMi5zZXQoX3gsIF95KTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7ICsraikge1xuICAgICAgICAgIHggPSBfeCArIFhfRElSW2pdO1xuICAgICAgICAgIHkgPSBfeSArIFlfRElSW2pdO1xuICAgICAgICAgIGlmICghYm0yLm91dE9mQm91bmRzKHgsIHksIHgsIHkpKSBzdGFjay5wdXNoKFt4LCB5XSk7XG4gICAgICAgIH0gLy8gdW5zY2FsZSBwb2ludCBiYWNrIHRvIHgsIHkgc3BhY2VcblxuXG4gICAgICAgIHggPSAkLmludmVydChfeCk7XG4gICAgICAgIHkgPSAkLmludmVydChfeSk7XG4gICAgICAgIGxvID0gbWF4U2l6ZTtcbiAgICAgICAgaGkgPSBoZWlnaHQ7IC8vIFRPRE86IG1ha2UgdGhpcyBib3VuZCBzbWFsbGVyXG5cbiAgICAgICAgaWYgKCFvdXRPZkJvdW5kcyh4LCB5LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIHdpZHRoLCBoZWlnaHQpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCBsbywgYm0wLCBibTEpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCBibTAsIG51bGwpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIGZpdHMgYXQgdGhlIGN1cnJlbnQgc2FtcGxlIHBvaW50LFxuICAgICAgICAgIC8vIHBlcmZvcm0gYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBsYXJnZXN0IGZvbnQgc2l6ZSB0aGF0IGZpdHNcbiAgICAgICAgICB3aGlsZSAoaGkgLSBsbyA+PSAxKSB7XG4gICAgICAgICAgICBtaWQgPSAobG8gKyBoaSkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgbWlkLCBibTAsIGJtMSkpIHtcbiAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsbyA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHBsYWNlIGxhYmVsIGlmIGN1cnJlbnQgbG93ZXIgYm91bmQgZXhjZWVkcyBwcmlvciBtYXggZm9udCBzaXplXG5cblxuICAgICAgICAgIGlmIChsbyA+IG1heFNpemUpIHtcbiAgICAgICAgICAgIGQueCA9IHg7XG4gICAgICAgICAgICBkLnkgPSB5O1xuICAgICAgICAgICAgbWF4U2l6ZSA9IGxvO1xuICAgICAgICAgICAgbGFiZWxQbGFjZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBwbGFjZSBsYWJlbCBhdCBzbGljZSBjZW50ZXIgaWYgbm90IHBsYWNlZCB0aHJvdWdoIG90aGVyIG1lYW5zXG4gICAgICAvLyBhbmQgaWYgd2UncmUgbm90IGF2b2lkaW5nIG92ZXJsYXAgd2l0aCBvdGhlciBhcmVhc1xuXG5cbiAgICAgIGlmICghbGFiZWxQbGFjZWQgJiYgIWF2b2lkQmFzZU1hcmspIHtcbiAgICAgICAgLy8gb25lIHNwYW4gaXMgemVybywgaGVuY2Ugd2UgY2FuIGFkZFxuICAgICAgICBhcmVhV2lkdGggPSBNYXRoLmFicyh4MiAtIHgxICsgeTIgLSB5MSk7XG4gICAgICAgIHggPSAoeDEgKyB4MikgLyAyO1xuICAgICAgICB5ID0gKHkxICsgeTIpIC8gMjsgLy8gcGxhY2UgbGFiZWwgaWYgaXQgZml0cyBhbmQgaW1wcm92ZXMgdGhlIG1heCBhcmVhIHdpZHRoXG5cbiAgICAgICAgaWYgKGFyZWFXaWR0aCA+PSBtYXhBcmVhV2lkdGggJiYgIW91dE9mQm91bmRzKHgsIHksIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgd2lkdGgsIGhlaWdodCkgJiYgIWNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIGJtMCwgbnVsbCkpIHtcbiAgICAgICAgICBtYXhBcmVhV2lkdGggPSBhcmVhV2lkdGg7XG4gICAgICAgICAgZC54ID0geDtcbiAgICAgICAgICBkLnkgPSB5O1xuICAgICAgICAgIGxhYmVsUGxhY2VkMiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHJlY29yZCBjdXJyZW50IGxhYmVsIHBsYWNlbWVudCBpbmZvcm1hdGlvbiwgdXBkYXRlIGxhYmVsIGJpdG1hcFxuXG5cbiAgICBpZiAobGFiZWxQbGFjZWQgfHwgbGFiZWxQbGFjZWQyKSB7XG4gICAgICB4ID0gdGV4dFdpZHRoIC8gMjtcbiAgICAgIHkgPSB0ZXh0SGVpZ2h0IC8gMjtcbiAgICAgIGJtMC5zZXRSYW5nZSgkKGQueCAtIHgpLCAkKGQueSAtIHkpLCAkKGQueCArIHgpLCAkKGQueSArIHkpKTtcbiAgICAgIGQuYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGQuYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBBbGlnbnMgPSBbJ3JpZ2h0JywgJ2NlbnRlcicsICdsZWZ0J10sXG4gICAgICBCYXNlbGluZXMgPSBbJ2JvdHRvbScsICdtaWRkbGUnLCAndG9wJ107XG5mdW5jdGlvbiBwbGFjZU1hcmtMYWJlbCAoJCwgYml0bWFwcywgYW5jaG9ycywgb2Zmc2V0cywgaW5mUGFkZGluZykge1xuICBjb25zdCB3aWR0aCA9ICQud2lkdGgsXG4gICAgICAgIGhlaWdodCA9ICQuaGVpZ2h0LFxuICAgICAgICBibTAgPSBiaXRtYXBzWzBdLFxuICAgICAgICBibTEgPSBiaXRtYXBzWzFdLFxuICAgICAgICBuID0gb2Zmc2V0cy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGNvbnN0IGJvdW5kYXJ5ID0gZC5ib3VuZGFyeSxcbiAgICAgICAgICB0ZXh0SGVpZ2h0ID0gZC5kYXR1bS5mb250U2l6ZTsgLy8gY2FuIG5vdCBiZSBwbGFjZWQgaWYgdGhlIG1hcmsgaXMgbm90IHZpc2libGUgaW4gdGhlIGdyYXBoIGJvdW5kXG5cbiAgICBpZiAoIWluZlBhZGRpbmcgJiYgKGJvdW5kYXJ5WzJdIDwgMCB8fCBib3VuZGFyeVs1XSA8IDAgfHwgYm91bmRhcnlbMF0gPiB3aWR0aCB8fCBib3VuZGFyeVszXSA+IGhlaWdodCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgdGV4dFdpZHRoID0gMCxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5LFxuICAgICAgICBpc0luc2lkZSxcbiAgICAgICAgc2l6ZUZhY3RvcixcbiAgICAgICAgaW5zaWRlRmFjdG9yLFxuICAgICAgICB4MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkxLFxuICAgICAgICB5MixcbiAgICAgICAgeGMsXG4gICAgICAgIHljLFxuICAgICAgICBfeDEsXG4gICAgICAgIF94MixcbiAgICAgICAgX3kxLFxuICAgICAgICBfeTI7IC8vIGZvciBlYWNoIGFuY2hvciBhbmQgb2Zmc2V0XG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBkeCA9IChhbmNob3JzW2ldICYgMHgzKSAtIDE7XG4gICAgICBkeSA9IChhbmNob3JzW2ldID4+PiAweDIgJiAweDMpIC0gMTtcbiAgICAgIGlzSW5zaWRlID0gZHggPT09IDAgJiYgZHkgPT09IDAgfHwgb2Zmc2V0c1tpXSA8IDA7XG4gICAgICBzaXplRmFjdG9yID0gZHggJiYgZHkgPyBNYXRoLlNRUlQxXzIgOiAxO1xuICAgICAgaW5zaWRlRmFjdG9yID0gb2Zmc2V0c1tpXSA8IDAgPyAtMSA6IDE7XG4gICAgICB4MSA9IGJvdW5kYXJ5WzEgKyBkeF0gKyBvZmZzZXRzW2ldICogZHggKiBzaXplRmFjdG9yO1xuICAgICAgeWMgPSBib3VuZGFyeVs0ICsgZHldICsgaW5zaWRlRmFjdG9yICogdGV4dEhlaWdodCAqIGR5IC8gMiArIG9mZnNldHNbaV0gKiBkeSAqIHNpemVGYWN0b3I7XG4gICAgICB5MSA9IHljIC0gdGV4dEhlaWdodCAvIDI7XG4gICAgICB5MiA9IHljICsgdGV4dEhlaWdodCAvIDI7XG4gICAgICBfeDEgPSAkKHgxKTtcbiAgICAgIF95MSA9ICQoeTEpO1xuICAgICAgX3kyID0gJCh5Mik7XG5cbiAgICAgIGlmIChpbmZQYWRkaW5nKSB7XG4gICAgICAgIF94MSA9IF94MSA8IDAgPyAwIDogX3gxO1xuICAgICAgICBfeTEgPSBfeTEgPCAwID8gMCA6IF95MTtcbiAgICAgICAgX3kyID0gX3kyID49ICQuaGVpZ2h0ID8gJC5oZWlnaHQgLSAxIDogX3kyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRleHRXaWR0aCkge1xuICAgICAgICAvLyB0byBhdm9pZCBmaW5kaW5nIHdpZHRoIG9mIHRleHQgbGFiZWwsXG4gICAgICAgIGlmICghdGVzdChfeDEsIF94MSwgX3kxLCBfeTIsIGJtMCwgYm0xLCB4MSwgeDEsIHkxLCB5MiwgYm91bmRhcnksIGlzSW5zaWRlKSkge1xuICAgICAgICAgIC8vIHNraXAgdGhpcyBhbmNob3Ivb2Zmc2V0IG9wdGlvbiBpZiB3ZSBmYWlsIHRvIHBsYWNlIGEgbGFiZWwgd2l0aCAxcHggd2lkdGhcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGZpbmQgdGhlIGxhYmVsIHdpZHRoXG4gICAgICAgICAgdGV4dFdpZHRoID0gdGV4dE1ldHJpY3Mud2lkdGgoZC5kYXR1bSwgZC5kYXR1bS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB4YyA9IHgxICsgaW5zaWRlRmFjdG9yICogdGV4dFdpZHRoICogZHggLyAyO1xuICAgICAgeDEgPSB4YyAtIHRleHRXaWR0aCAvIDI7XG4gICAgICB4MiA9IHhjICsgdGV4dFdpZHRoIC8gMjtcbiAgICAgIF94MSA9ICQoeDEpO1xuICAgICAgX3gyID0gJCh4Mik7XG5cbiAgICAgIGlmIChpbmZQYWRkaW5nKSB7XG4gICAgICAgIF94MSA9IF94MSA8IDAgPyAwIDogX3gxO1xuICAgICAgICBfeDIgPSBfeDIgPj0gJC53aWR0aCA/ICQud2lkdGggLSAxIDogX3gyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGVzdChfeDEsIF94MiwgX3kxLCBfeTIsIGJtMCwgYm0xLCB4MSwgeDIsIHkxLCB5MiwgYm91bmRhcnksIGlzSW5zaWRlKSkge1xuICAgICAgICAvLyBwbGFjZSBsYWJlbCBpZiB0aGUgcG9zaXRpb24gaXMgcGxhY2VhYmxlXG4gICAgICAgIGQueCA9ICFkeCA/IHhjIDogZHggKiBpbnNpZGVGYWN0b3IgPCAwID8geDIgOiB4MTtcbiAgICAgICAgZC55ID0gIWR5ID8geWMgOiBkeSAqIGluc2lkZUZhY3RvciA8IDAgPyB5MiA6IHkxO1xuICAgICAgICBkLmFsaWduID0gQWxpZ25zW2R4ICogaW5zaWRlRmFjdG9yICsgMV07XG4gICAgICAgIGQuYmFzZWxpbmUgPSBCYXNlbGluZXNbZHkgKiBpbnNpZGVGYWN0b3IgKyAxXTtcbiAgICAgICAgYm0wLnNldFJhbmdlKF94MSwgX3kxLCBfeDIsIF95Mik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn0gLy8gVGVzdCBpZiBhIGxhYmVsIHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMgY2FuIGJlIGFkZGVkIHdpdGhvdXQgb3ZlcmxhcFxuXG5mdW5jdGlvbiB0ZXN0KF94MSwgX3gyLCBfeTEsIF95MiwgYm0wLCBibTEsIHgxLCB4MiwgeTEsIHkyLCBib3VuZGFyeSwgaXNJbnNpZGUpIHtcbiAgcmV0dXJuICEoYm0wLm91dE9mQm91bmRzKF94MSwgX3kxLCBfeDIsIF95MikgfHwgKGlzSW5zaWRlICYmIGJtMSA/IGJtMS5nZXRSYW5nZShfeDEsIF95MSwgX3gyLCBfeTIpIHx8ICFpc0luTWFya0JvdW5kKHgxLCB5MSwgeDIsIHkyLCBib3VuZGFyeSkgOiBibTAuZ2V0UmFuZ2UoX3gxLCBfeTEsIF94MiwgX3kyKSkpO1xufVxuXG5mdW5jdGlvbiBpc0luTWFya0JvdW5kKHgxLCB5MSwgeDIsIHkyLCBib3VuZGFyeSkge1xuICByZXR1cm4gYm91bmRhcnlbMF0gPD0geDEgJiYgeDIgPD0gYm91bmRhcnlbMl0gJiYgYm91bmRhcnlbM10gPD0geTEgJiYgeTIgPD0gYm91bmRhcnlbNV07XG59XG5cbmNvbnN0IFRPUCA9IDB4MCxcbiAgICAgIE1JRERMRSA9IDB4NCxcbiAgICAgIEJPVFRPTSA9IDB4OCxcbiAgICAgIExFRlQgPSAweDAsXG4gICAgICBDRU5URVIgPSAweDEsXG4gICAgICBSSUdIVCA9IDB4MjsgLy8gTWFwcGluZyBmcm9tIHRleHQgYW5jaG9yIHRvIG51bWJlciByZXByZXNlbnRhdGlvblxuXG5jb25zdCBhbmNob3JDb2RlID0ge1xuICAndG9wLWxlZnQnOiBUT1AgKyBMRUZULFxuICAndG9wJzogVE9QICsgQ0VOVEVSLFxuICAndG9wLXJpZ2h0JzogVE9QICsgUklHSFQsXG4gICdsZWZ0JzogTUlERExFICsgTEVGVCxcbiAgJ21pZGRsZSc6IE1JRERMRSArIENFTlRFUixcbiAgJ3JpZ2h0JzogTUlERExFICsgUklHSFQsXG4gICdib3R0b20tbGVmdCc6IEJPVFRPTSArIExFRlQsXG4gICdib3R0b20nOiBCT1RUT00gKyBDRU5URVIsXG4gICdib3R0b20tcmlnaHQnOiBCT1RUT00gKyBSSUdIVFxufTtcbmNvbnN0IHBsYWNlQXJlYUxhYmVsID0ge1xuICAnbmFpdmUnOiBwbGFjZUFyZWFMYWJlbE5haXZlLFxuICAncmVkdWNlZC1zZWFyY2gnOiBwbGFjZUFyZWFMYWJlbFJlZHVjZWRTZWFyY2gsXG4gICdmbG9vZGZpbGwnOiBwbGFjZUFyZWFMYWJlbEZsb29kRmlsbFxufTtcbmZ1bmN0aW9uIGxhYmVsTGF5b3V0ICh0ZXh0cywgc2l6ZSwgY29tcGFyZSwgb2Zmc2V0LCBhbmNob3IsIGF2b2lkTWFya3MsIGF2b2lkQmFzZU1hcmssIGxpbmVBbmNob3IsIG1hcmtJbmRleCwgcGFkZGluZywgbWV0aG9kKSB7XG4gIC8vIGVhcmx5IGV4aXQgZm9yIGVtcHR5IGRhdGFcbiAgaWYgKCF0ZXh0cy5sZW5ndGgpIHJldHVybiB0ZXh0cztcbiAgY29uc3QgcG9zaXRpb25zID0gTWF0aC5tYXgob2Zmc2V0Lmxlbmd0aCwgYW5jaG9yLmxlbmd0aCksXG4gICAgICAgIG9mZnNldHMgPSBnZXRPZmZzZXRzKG9mZnNldCwgcG9zaXRpb25zKSxcbiAgICAgICAgYW5jaG9ycyA9IGdldEFuY2hvcnMoYW5jaG9yLCBwb3NpdGlvbnMpLFxuICAgICAgICBtYXJrdHlwZSA9IG1hcmtUeXBlKHRleHRzWzBdLmRhdHVtKSxcbiAgICAgICAgZ3JvdXB0eXBlID0gbWFya3R5cGUgPT09ICdncm91cCcgJiYgdGV4dHNbMF0uZGF0dW0uaXRlbXNbbWFya0luZGV4XS5tYXJrdHlwZSxcbiAgICAgICAgaXNHcm91cEFyZWEgPSBncm91cHR5cGUgPT09ICdhcmVhJyxcbiAgICAgICAgYm91bmRhcnkgPSBtYXJrQm91bmRhcnkobWFya3R5cGUsIGdyb3VwdHlwZSwgbGluZUFuY2hvciwgbWFya0luZGV4KSxcbiAgICAgICAgaW5mUGFkZGluZyA9IHBhZGRpbmcgPT09IG51bGwgfHwgcGFkZGluZyA9PT0gSW5maW5pdHksXG4gICAgICAgICQgPSBzY2FsZXIoc2l6ZVswXSwgc2l6ZVsxXSwgaW5mUGFkZGluZyA/IDAgOiBwYWRkaW5nKSxcbiAgICAgICAgaXNOYWl2ZUdyb3VwQXJlYSA9IGlzR3JvdXBBcmVhICYmIG1ldGhvZCA9PT0gJ25haXZlJzsgLy8gcHJlcGFyZSB0ZXh0IG1hcmsgZGF0YSBmb3IgcGxhY2luZ1xuXG4gIGNvbnN0IGRhdGEgPSB0ZXh0cy5tYXAoZCA9PiAoe1xuICAgIGRhdHVtOiBkLFxuICAgIG9wYWNpdHk6IDAsXG4gICAgeDogdW5kZWZpbmVkLFxuICAgIHk6IHVuZGVmaW5lZCxcbiAgICBhbGlnbjogdW5kZWZpbmVkLFxuICAgIGJhc2VsaW5lOiB1bmRlZmluZWQsXG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5KGQpXG4gIH0pKTtcbiAgbGV0IGJpdG1hcHM7XG5cbiAgaWYgKCFpc05haXZlR3JvdXBBcmVhKSB7XG4gICAgLy8gc29ydCBsYWJlbHMgaW4gcHJpb3JpdHkgb3JkZXIsIGlmIGNvbXBhcmF0b3IgaXMgcHJvdmlkZWRcbiAgICBpZiAoY29tcGFyZSkge1xuICAgICAgZGF0YS5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGEuZGF0dW0sIGIuZGF0dW0pKTtcbiAgICB9IC8vIGZsYWcgaW5kaWNhdGluZyBpZiBsYWJlbCBjYW4gYmUgcGxhY2VkIGluc2lkZSBpdHMgYmFzZSBtYXJrXG5cblxuICAgIGxldCBsYWJlbEluc2lkZSA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNob3JzLmxlbmd0aCAmJiAhbGFiZWxJbnNpZGU7ICsraSkge1xuICAgICAgLy8gbGFiZWwgaW5zaWRlIGlmIGFuY2hvciBpcyBhdCBjZW50ZXJcbiAgICAgIC8vIGxhYmVsIGluc2lkZSBpZiBvZmZzZXQgdG8gYmUgaW5zaWRlIHRoZSBtYXJrIGJvdW5kXG4gICAgICBsYWJlbEluc2lkZSA9IGFuY2hvcnNbaV0gPT09IDB4NSB8fCBvZmZzZXRzW2ldIDwgMDtcbiAgICB9IC8vIGV4dHJhY3QgZGF0YSBpbmZvcm1hdGlvbiBmcm9tIGJhc2UgbWFyayB3aGVuIGJhc2UgbWFyayBpcyB0byBiZSBhdm9pZGVkXG4gICAgLy8gYmFzZSBtYXJrIGlzIGltcGxpY2l0bHkgYXZvaWRlZCBpZiBpdCBpcyBhIGdyb3VwIGFyZWFcblxuXG4gICAgaWYgKG1hcmt0eXBlICYmIChhdm9pZEJhc2VNYXJrIHx8IGlzR3JvdXBBcmVhKSkge1xuICAgICAgYXZvaWRNYXJrcyA9IFt0ZXh0cy5tYXAoZCA9PiBkLmRhdHVtKV0uY29uY2F0KGF2b2lkTWFya3MpO1xuICAgIH0gLy8gZ2VuZXJhdGUgYml0bWFwcyBmb3IgbGF5b3V0IGNhbGN1bGF0aW9uXG5cblxuICAgIGJpdG1hcHMgPSBhdm9pZE1hcmtzLmxlbmd0aCA/IG1hcmtCaXRtYXBzKCQsIGF2b2lkTWFya3MsIGxhYmVsSW5zaWRlLCBpc0dyb3VwQXJlYSkgOiBiYXNlQml0bWFwcygkLCBhdm9pZEJhc2VNYXJrICYmIGRhdGEpO1xuICB9IC8vIGdlbmVyYXRlIGxhYmVsIHBsYWNlbWVudCBmdW5jdGlvblxuXG5cbiAgY29uc3QgcGxhY2UgPSBpc0dyb3VwQXJlYSA/IHBsYWNlQXJlYUxhYmVsW21ldGhvZF0oJCwgYml0bWFwcywgYXZvaWRCYXNlTWFyaywgbWFya0luZGV4LCBpbmZQYWRkaW5nKSA6IHBsYWNlTWFya0xhYmVsKCQsIGJpdG1hcHMsIGFuY2hvcnMsIG9mZnNldHMsIGluZlBhZGRpbmcpOyAvLyBwbGFjZSBhbGwgbGFiZWxzXG5cbiAgZGF0YS5mb3JFYWNoKGQgPT4gZC5vcGFjaXR5ID0gK3BsYWNlKGQpKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldHMoXywgY291bnQpIHtcbiAgY29uc3Qgb2Zmc2V0cyA9IG5ldyBGbG9hdDY0QXJyYXkoY291bnQpLFxuICAgICAgICBuID0gXy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIG9mZnNldHNbaV0gPSBfW2ldIHx8IDA7XG5cbiAgZm9yIChsZXQgaSA9IG47IGkgPCBjb3VudDsgKytpKSBvZmZzZXRzW2ldID0gb2Zmc2V0c1tuIC0gMV07XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldEFuY2hvcnMoXywgY291bnQpIHtcbiAgY29uc3QgYW5jaG9ycyA9IG5ldyBJbnQ4QXJyYXkoY291bnQpLFxuICAgICAgICBuID0gXy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIGFuY2hvcnNbaV0gfD0gYW5jaG9yQ29kZVtfW2ldXTtcblxuICBmb3IgKGxldCBpID0gbjsgaSA8IGNvdW50OyArK2kpIGFuY2hvcnNbaV0gPSBhbmNob3JzW24gLSAxXTtcblxuICByZXR1cm4gYW5jaG9ycztcbn1cblxuZnVuY3Rpb24gbWFya1R5cGUoaXRlbSkge1xuICByZXR1cm4gaXRlbSAmJiBpdGVtLm1hcmsgJiYgaXRlbS5tYXJrLm1hcmt0eXBlO1xufVxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBmdW5jdGlvbiBmb3IgZ2V0dGluZyBiYXNlIG1hcmsgYm91bmRhcnksIGRlcGVuZGluZ1xuICogb24gbWFyayBhbmQgZ3JvdXAgdHlwZS4gV2hlbiBtYXJrIHR5cGUgaXMgdW5kZWZpbmVkLCBsaW5lIG9yIGFyZWE6IGJvdW5kYXJ5XG4gKiBpcyB0aGUgY29vcmRpbmF0ZSBvZiBlYWNoIGRhdGEgcG9pbnQuIFdoZW4gYmFzZSBtYXJrIGlzIGdyb3VwZWQgbGluZSxcbiAqIGJvdW5kYXJ5IGlzIGVpdGhlciBhdCB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgbGluZSBkZXBlbmRpbmcgb24gdGhlXG4gKiB2YWx1ZSBvZiBsaW5lQW5jaG9yLiBPdGhlcndpc2UsIHVzZSBib3VuZHMgb2YgYmFzZSBtYXJrLlxuICovXG5cblxuZnVuY3Rpb24gbWFya0JvdW5kYXJ5KG1hcmt0eXBlLCBncm91cHR5cGUsIGxpbmVBbmNob3IsIG1hcmtJbmRleCkge1xuICBjb25zdCB4eSA9IGQgPT4gW2QueCwgZC54LCBkLngsIGQueSwgZC55LCBkLnldO1xuXG4gIGlmICghbWFya3R5cGUpIHtcbiAgICByZXR1cm4geHk7IC8vIG5vIHJlYWN0aXZlIGdlb21ldHJ5XG4gIH0gZWxzZSBpZiAobWFya3R5cGUgPT09ICdsaW5lJyB8fCBtYXJrdHlwZSA9PT0gJ2FyZWEnKSB7XG4gICAgcmV0dXJuIGQgPT4geHkoZC5kYXR1bSk7XG4gIH0gZWxzZSBpZiAoZ3JvdXB0eXBlID09PSAnbGluZScpIHtcbiAgICByZXR1cm4gZCA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IGQuZGF0dW0uaXRlbXNbbWFya0luZGV4XS5pdGVtcztcbiAgICAgIHJldHVybiB4eShpdGVtcy5sZW5ndGggPyBpdGVtc1tsaW5lQW5jaG9yID09PSAnc3RhcnQnID8gMCA6IGl0ZW1zLmxlbmd0aCAtIDFdIDoge1xuICAgICAgICB4OiBOYU4sXG4gICAgICAgIHk6IE5hTlxuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZCA9PiB7XG4gICAgICBjb25zdCBiID0gZC5kYXR1bS5ib3VuZHM7XG4gICAgICByZXR1cm4gW2IueDEsIChiLngxICsgYi54MikgLyAyLCBiLngyLCBiLnkxLCAoYi55MSArIGIueTIpIC8gMiwgYi55Ml07XG4gICAgfTtcbiAgfVxufVxuXG5jb25zdCBPdXRwdXQgPSBbJ3gnLCAneScsICdvcGFjaXR5JywgJ2FsaWduJywgJ2Jhc2VsaW5lJ107XG5jb25zdCBBbmNob3JzID0gWyd0b3AtbGVmdCcsICdsZWZ0JywgJ2JvdHRvbS1sZWZ0JywgJ3RvcCcsICdib3R0b20nLCAndG9wLXJpZ2h0JywgJ3JpZ2h0JywgJ2JvdHRvbS1yaWdodCddO1xuLyoqXG4gKiBDb21wdXRlIHRleHQgbGFiZWwgbGF5b3V0IHRvIGFubm90YXRlIG1hcmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBhcmFtcy5zaXplIC0gVGhlIHNpemUgb2YgdGhlIGxheW91dCwgcHJvdmlkZWQgYXMgYSBbd2lkdGgsIGhlaWdodF0gYXJyYXkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEFuIG9wdGlvbmFsXG4gKiAgIGNvbXBhcmF0b3IgZnVuY3Rpb24gZm9yIHNvcnRpbmcgbGFiZWwgZGF0YSBpbiBwcmlvcml0eSBvcmRlci5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hbmNob3JdIC0gTGFiZWwgYW5jaG9yIHBvaW50cyByZWxhdGl2ZSB0byB0aGUgYmFzZSBtYXJrIGJvdW5kaW5nIGJveC5cbiAqICAgVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZSAndG9wLWxlZnQnLCAnbGVmdCcsICdib3R0b20tbGVmdCcsICd0b3AnLFxuICogICAnYm90dG9tJywgJ3RvcC1yaWdodCcsICdyaWdodCcsICdib3R0b20tcmlnaHQnLCAnbWlkZGxlJy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5vZmZzZXRdIC0gTGFiZWwgb2Zmc2V0cyAoaW4gcGl4ZWxzKSBmcm9tIHRoZSBiYXNlIG1hcmsgYm91bmRpbmcgYm94LlxuICogICBUaGlzIHBhcmFtZXRlciBpcyBwYXJhbGxlbCB0byB0aGUgbGlzdCBvZiBhbmNob3IgcG9pbnRzLlxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbcGFyYW1zLnBhZGRpbmc9MF0gLSBUaGUgYW1vdW50IChpbiBwaXhlbHMpIHRoYXQgYSBsYWJlbCBtYXkgZXhjZWVkIHRoZSBsYXlvdXQgc2l6ZS5cbiAqICAgSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbnVsbCwgYSBsYWJlbCBtYXkgZXhjZWVkIHRoZSBsYXlvdXQgc2l6ZSB3aXRob3V0IGFueSBib3VuZGFyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmxpbmVBbmNob3I9J2VuZCddIC0gRm9yIGdyb3VwIGxpbmUgbWFyayBsYWJlbHMgb25seSwgaW5kaWNhdGVzIHRoZSBhbmNob3JcbiAqICAgcG9zaXRpb24gZm9yIGxhYmVscy4gT25lIG9mICdzdGFydCcgb3IgJ2VuZCcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5tYXJrSW5kZXg9MF0gLSBGb3IgZ3JvdXAgbWFyayBsYWJlbHMgb25seSwgYW4gaW5kZXggaW5kaWNhdGluZ1xuICogICB3aGljaCBtYXJrIHdpdGhpbiB0aGUgZ3JvdXAgc2hvdWxkIGJlIGxhYmVsZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMuYXZvaWRNYXJrc10gLSBBIGxpc3Qgb2YgYWRkaXRpb25hbCBtYXJrIG5hbWVzIGZvciB3aGljaCB0aGUgbGFiZWxcbiAqICAgbGF5b3V0IHNob3VsZCBhdm9pZCBvdmVybGFwLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmF2b2lkQmFzZU1hcms9dHJ1ZV0gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiBsYWJlbHMgc2hvdWxkIGF2b2lkXG4gKiAgIG92ZXJsYXAgd2l0aCB0aGUgdW5kZXJseWluZyBiYXNlIG1hcmsgYmVpbmcgbGFiZWxlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLm1ldGhvZD0nbmFpdmUnXSAtIEZvciBhcmVhIG1ha2UgbGFiZWxzIG9ubHksIGEgbWV0aG9kIGZvclxuICogICBwbGFjZSBsYWJlbHMuIE9uZSBvZiAnbmFpdmUnLCAncmVkdWNlZC1zZWFyY2gnLCBvciAnZmxvb2RmaWxsJy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBUaGUgb3V0cHV0IGZpZWxkcyB3cml0dGVuIGJ5IHRoZSB0cmFuc2Zvcm0uXG4gKiAgIFRoZSBkZWZhdWx0IGlzIFsneCcsICd5JywgJ29wYWNpdHknLCAnYWxpZ24nLCAnYmFzZWxpbmUnXS5cbiAqL1xuXG5mdW5jdGlvbiBMYWJlbChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkxhYmVsLkRlZmluaXRpb24gPSB7XG4gIHR5cGU6ICdMYWJlbCcsXG4gIG1ldGFkYXRhOiB7XG4gICAgbW9kaWZpZXM6IHRydWVcbiAgfSxcbiAgcGFyYW1zOiBbe1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBhcnJheTogdHJ1ZSxcbiAgICBsZW5ndGg6IDIsXG4gICAgcmVxdWlyZWQ6IHRydWVcbiAgfSwge1xuICAgIG5hbWU6ICdzb3J0JyxcbiAgICB0eXBlOiAnY29tcGFyZSdcbiAgfSwge1xuICAgIG5hbWU6ICdhbmNob3InLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGFycmF5OiB0cnVlLFxuICAgIGRlZmF1bHQ6IEFuY2hvcnNcbiAgfSwge1xuICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIGFycmF5OiB0cnVlLFxuICAgIGRlZmF1bHQ6IFsxXVxuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmcnLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbnVsbDogdHJ1ZVxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmVBbmNob3InLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbHVlczogWydzdGFydCcsICdlbmQnXSxcbiAgICBkZWZhdWx0OiAnZW5kJ1xuICB9LCB7XG4gICAgbmFtZTogJ21hcmtJbmRleCcsXG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgbmFtZTogJ2F2b2lkQmFzZU1hcmsnLFxuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAnYXZvaWRNYXJrcycsXG4gICAgdHlwZTogJ2RhdGEnLFxuICAgIGFycmF5OiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAnbWV0aG9kJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiAnbmFpdmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnYXMnLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGFycmF5OiB0cnVlLFxuICAgIGxlbmd0aDogT3V0cHV0Lmxlbmd0aCxcbiAgICBkZWZhdWx0OiBPdXRwdXRcbiAgfV1cbn07XG5pbmhlcml0cyhMYWJlbCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGZ1bmN0aW9uIG1vZHAocGFyYW0pIHtcbiAgICAgIGNvbnN0IHAgPSBfW3BhcmFtXTtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHApICYmIHB1bHNlLm1vZGlmaWVkKHAuZmllbGRzKTtcbiAgICB9XG5cbiAgICBjb25zdCBtb2QgPSBfLm1vZGlmaWVkKCk7XG5cbiAgICBpZiAoIShtb2QgfHwgcHVsc2UuY2hhbmdlZChwdWxzZS5BRERfUkVNKSB8fCBtb2RwKCdzb3J0JykpKSByZXR1cm47XG5cbiAgICBpZiAoIV8uc2l6ZSB8fCBfLnNpemUubGVuZ3RoICE9PSAyKSB7XG4gICAgICBlcnJvcignU2l6ZSBwYXJhbWV0ZXIgc2hvdWxkIGJlIHNwZWNpZmllZCBhcyBhIFt3aWR0aCwgaGVpZ2h0XSBhcnJheS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcyA9IF8uYXMgfHwgT3V0cHV0OyAvLyBydW4gbGFiZWwgbGF5b3V0XG5cbiAgICBsYWJlbExheW91dChwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSB8fCBbXSwgXy5zaXplLCBfLnNvcnQsIGFycmF5KF8ub2Zmc2V0ID09IG51bGwgPyAxIDogXy5vZmZzZXQpLCBhcnJheShfLmFuY2hvciB8fCBBbmNob3JzKSwgXy5hdm9pZE1hcmtzIHx8IFtdLCBfLmF2b2lkQmFzZU1hcmsgIT09IGZhbHNlLCBfLmxpbmVBbmNob3IgfHwgJ2VuZCcsIF8ubWFya0luZGV4IHx8IDAsIF8ucGFkZGluZyA9PT0gdW5kZWZpbmVkID8gMCA6IF8ucGFkZGluZywgXy5tZXRob2QgfHwgJ25haXZlJykuZm9yRWFjaChsID0+IHtcbiAgICAgIC8vIHdyaXRlIGxheW91dCByZXN1bHRzIHRvIGRhdGEgc3RyZWFtXG4gICAgICBjb25zdCB0ID0gbC5kYXR1bTtcbiAgICAgIHRbYXNbMF1dID0gbC54O1xuICAgICAgdFthc1sxXV0gPSBsLnk7XG4gICAgICB0W2FzWzJdXSA9IGwub3BhY2l0eTtcbiAgICAgIHRbYXNbM11dID0gbC5hbGlnbjtcbiAgICAgIHRbYXNbNF1dID0gbC5iYXNlbGluZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KG1vZCkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5leHBvcnQgeyBMYWJlbCBhcyBsYWJlbCB9O1xuIiwiaW1wb3J0IHsgZXh0ZW5kLCBlcnJvciwgaXNGdW5jdGlvbiwgc3RyaW5nVmFsdWUsIHRvQm9vbGVhbiwgdG9OdW1iZXIsIHRvRGF0ZSwgdG9TdHJpbmcsIGlkZW50aXR5LCBmaWVsZCwgaXNPYmplY3QsIGlzQXJyYXksIGlzSXRlcmFibGUsIGhhc093blByb3BlcnR5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGRzdkZvcm1hdCB9IGZyb20gJ2QzLWRzdic7XG5pbXBvcnQgeyBmZWF0dXJlLCBtZXNoIH0gZnJvbSAndG9wb2pzb24tY2xpZW50JztcbmltcG9ydCB7IHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlIH0gZnJvbSAndmVnYS1mb3JtYXQnO1xuXG4vLyAgIGh0dHBzOi8vLi4uICAgIGZpbGU6Ly8uLi4gICAgLy8uLi5cblxuY29uc3QgcHJvdG9jb2xfcmUgPSAvXihkYXRhOnwoW0EtWmEtel0rOik/XFwvXFwvKS87IC8vIE1hdGNoZXMgYWxsb3dlZCBVUklzLiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvbWFzdGVyL3NyYy9yZWdleHAuanMgd2l0aCBhZGRlZCBmaWxlOi8vXG5cbmNvbnN0IGFsbG93ZWRfcmUgPSAvXig/Oig/Oig/OmZ8aHQpdHBzP3xtYWlsdG98dGVsfGNhbGx0b3xjaWR8eG1wcHxmaWxlfGRhdGEpOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2k7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuY29uc3Qgd2hpdGVzcGFjZV9yZSA9IC9bXFx1MDAwMC1cXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDI5XFx1MjA1ZlxcdTMwMDBdL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuLy8gU3BlY2lhbCB0cmVhdG1lbnQgaW4gbm9kZS5qcyBmb3IgdGhlIGZpbGU6IHByb3RvY29sXG5cbmNvbnN0IGZpbGVQcm90b2NvbCA9ICdmaWxlOi8vJztcbi8qKlxuICogRmFjdG9yeSBmb3IgYSBsb2FkZXIgY29uc3RydWN0b3IgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciByZXF1ZXN0aW5nXG4gKiBmaWxlcyBmcm9tIGVpdGhlciB0aGUgbmV0d29yayBvciBkaXNrLCBhbmQgZm9yIHNhbml0aXppbmcgcmVxdWVzdCBVUklzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmV0Y2ggLSBUaGUgRmV0Y2ggQVBJIGZvciBIVFRQIG5ldHdvcmsgcmVxdWVzdHMuXG4gKiAgIElmIG51bGwgb3IgdW5kZWZpbmVkLCBIVFRQIGxvYWRpbmcgd2lsbCBiZSBkaXNhYmxlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBmcyAtIFRoZSBmaWxlIHN5c3RlbSBpbnRlcmZhY2UgZm9yIGZpbGUgbG9hZGluZy5cbiAqICAgSWYgbnVsbCBvciB1bmRlZmluZWQsIGxvY2FsIGZpbGUgbG9hZGluZyB3aWxsIGJlIGRpc2FibGVkLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEEgbG9hZGVyIGNvbnN0cnVjdG9yIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKiAgIHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGRlZmF1bHQgbG9hZGluZyBvcHRpb25zIHRvIHVzZS5cbiAqICAgcmV0dXJuIHtvYmplY3R9IC0gQSBuZXcgbG9hZGVyIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGxvYWRlckZhY3RvcnkgKGZldGNoLCBmcykge1xuICByZXR1cm4gb3B0aW9ucyA9PiAoe1xuICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXG4gICAgc2FuaXRpemU6IHNhbml0aXplLFxuICAgIGxvYWQ6IGxvYWQsXG4gICAgZmlsZUFjY2VzczogISFmcyxcbiAgICBmaWxlOiBmaWxlTG9hZGVyKGZzKSxcbiAgICBodHRwOiBodHRwTG9hZGVyKGZldGNoKVxuICB9KTtcbn1cbi8qKlxuICogTG9hZCBhbiBleHRlcm5hbCByZXNvdXJjZSwgdHlwaWNhbGx5IGVpdGhlciBmcm9tIHRoZSB3ZWIgb3IgZnJvbSB0aGUgbG9jYWxcbiAqIGZpbGVzeXN0ZW0uIFRoaXMgZnVuY3Rpb24gdXNlcyB7QGxpbmsgc2FuaXRpemV9IHRvIGZpcnN0IHNhbml0aXplIHRoZSB1cmksXG4gKiB0aGVuIGNhbGxzIGVpdGhlciB7QGxpbmsgaHR0cH0gKGZvciB3ZWIgcmVxdWVzdHMpIG9yIHtAbGluayBmaWxlfSAoZm9yXG4gKiBmaWxlc3lzdGVtIGxvYWRpbmcpLlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaSAtIFRoZSByZXNvdXJjZSBpbmRpY2F0b3IgKGUuZy4sIFVSTCBvciBmaWxlbmFtZSkuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgbG9hZGluZyBvcHRpb25zLiBUaGVzZSBvcHRpb25zIHdpbGxcbiAqICAgb3ZlcnJpZGUgYW55IGV4aXN0aW5nIGRlZmF1bHQgb3B0aW9ucy5cbiAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxvYWRlZCBjb250ZW50LlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWQodXJpLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdCA9IGF3YWl0IHRoaXMuc2FuaXRpemUodXJpLCBvcHRpb25zKSxcbiAgICAgICAgdXJsID0gb3B0LmhyZWY7XG4gIHJldHVybiBvcHQubG9jYWxGaWxlID8gdGhpcy5maWxlKHVybCkgOiB0aGlzLmh0dHAodXJsLCBvcHRpb25zKTtcbn1cbi8qKlxuICogVVJJIHNhbml0aXplciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgdXJpICh1cmwgb3IgZmlsZW5hbWUpIHRvIGNoZWNrLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBbiBvcHRpb25zIGhhc2guXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiAgc2FuaXRpemVkIHVyaSBkYXRhLCBvciByZWplY3RzIGl0IHRoZSBpbnB1dCB1cmkgaXMgZGVlbWVkIGludmFsaWQuXG4gKiAgVGhlIHByb3BlcnRpZXMgb2YgdGhlIHJlc29sdmVkIG9iamVjdCBhcmUgYXNzdW1lZCB0byBiZVxuICogIHZhbGlkIGF0dHJpYnV0ZXMgZm9yIGFuIEhUTUwgJ2EnIHRhZy4gVGhlIHNhbml0aXplZCB1cmkgKm11c3QqIGJlXG4gKiAgcHJvdmlkZWQgYnkgdGhlICdocmVmJyBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICovXG5cblxuYXN5bmMgZnVuY3Rpb24gc2FuaXRpemUodXJpLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBleHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIGNvbnN0IGZpbGVBY2Nlc3MgPSB0aGlzLmZpbGVBY2Nlc3MsXG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICBocmVmOiBudWxsXG4gIH07XG4gIGxldCBpc0ZpbGUsIGxvYWRGaWxlLCBiYXNlO1xuICBjb25zdCBpc0FsbG93ZWQgPSBhbGxvd2VkX3JlLnRlc3QodXJpLnJlcGxhY2Uod2hpdGVzcGFjZV9yZSwgJycpKTtcblxuICBpZiAodXJpID09IG51bGwgfHwgdHlwZW9mIHVyaSAhPT0gJ3N0cmluZycgfHwgIWlzQWxsb3dlZCkge1xuICAgIGVycm9yKCdTYW5pdGl6ZSBmYWlsdXJlLCBpbnZhbGlkIFVSSTogJyArIHN0cmluZ1ZhbHVlKHVyaSkpO1xuICB9XG5cbiAgY29uc3QgaGFzUHJvdG9jb2wgPSBwcm90b2NvbF9yZS50ZXN0KHVyaSk7IC8vIGlmIHJlbGF0aXZlIHVybCAobm8gcHJvdG9jb2wvaG9zdCksIHByZXBlbmQgYmFzZVVSTFxuXG4gIGlmICgoYmFzZSA9IG9wdGlvbnMuYmFzZVVSTCkgJiYgIWhhc1Byb3RvY29sKSB7XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYSBzbGFzaCBiZXR3ZWVuIHRoZSBiYXNlVVJMIChlLmcuIGhvc3RuYW1lKSBhbmQgdXJsXG4gICAgaWYgKCF1cmkuc3RhcnRzV2l0aCgnLycpICYmICFiYXNlLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgIHVyaSA9ICcvJyArIHVyaTtcbiAgICB9XG5cbiAgICB1cmkgPSBiYXNlICsgdXJpO1xuICB9IC8vIHNob3VsZCB3ZSBsb2FkIGZyb20gZmlsZSBzeXN0ZW0/XG5cblxuICBsb2FkRmlsZSA9IChpc0ZpbGUgPSB1cmkuc3RhcnRzV2l0aChmaWxlUHJvdG9jb2wpKSB8fCBvcHRpb25zLm1vZGUgPT09ICdmaWxlJyB8fCBvcHRpb25zLm1vZGUgIT09ICdodHRwJyAmJiAhaGFzUHJvdG9jb2wgJiYgZmlsZUFjY2VzcztcblxuICBpZiAoaXNGaWxlKSB7XG4gICAgLy8gc3RyaXAgZmlsZSBwcm90b2NvbFxuICAgIHVyaSA9IHVyaS5zbGljZShmaWxlUHJvdG9jb2wubGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh1cmkuc3RhcnRzV2l0aCgnLy8nKSkge1xuICAgIGlmIChvcHRpb25zLmRlZmF1bHRQcm90b2NvbCA9PT0gJ2ZpbGUnKSB7XG4gICAgICAvLyBpZiBpcyBmaWxlLCBzdHJpcCBwcm90b2NvbCBhbmQgc2V0IGxvYWRGaWxlIGZsYWdcbiAgICAgIHVyaSA9IHVyaS5zbGljZSgyKTtcbiAgICAgIGxvYWRGaWxlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgcmVsYXRpdmUgcHJvdG9jb2wgKHN0YXJ0cyB3aXRoICcvLycpLCBwcmVwZW5kIGRlZmF1bHQgcHJvdG9jb2xcbiAgICAgIHVyaSA9IChvcHRpb25zLmRlZmF1bHRQcm90b2NvbCB8fCAnaHR0cCcpICsgJzonICsgdXJpO1xuICAgIH1cbiAgfSAvLyBzZXQgbm9uLWVudW1lcmFibGUgbW9kZSBmbGFnIHRvIGluZGljYXRlIGxvY2FsIGZpbGUgbG9hZFxuXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ2xvY2FsRmlsZScsIHtcbiAgICB2YWx1ZTogISFsb2FkRmlsZVxuICB9KTsgLy8gc2V0IHVyaVxuXG4gIHJlc3VsdC5ocmVmID0gdXJpOyAvLyBzZXQgZGVmYXVsdCByZXN1bHQgdGFyZ2V0LCBpZiBzcGVjaWZpZWRcblxuICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICByZXN1bHQudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgKyAnJztcbiAgfSAvLyBzZXQgZGVmYXVsdCByZXN1bHQgcmVsLCBpZiBzcGVjaWZpZWQgKCMxNTQyKVxuXG5cbiAgaWYgKG9wdGlvbnMucmVsKSB7XG4gICAgcmVzdWx0LnJlbCA9IG9wdGlvbnMucmVsICsgJyc7XG4gIH0gLy8gcHJvdmlkZSBjb250cm9sIG92ZXIgY3Jvc3Mtb3JpZ2luIGltYWdlIGhhbmRsaW5nICgjMjIzOClcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2VcblxuXG4gIGlmIChvcHRpb25zLmNvbnRleHQgPT09ICdpbWFnZScgJiYgb3B0aW9ucy5jcm9zc09yaWdpbikge1xuICAgIHJlc3VsdC5jcm9zc09yaWdpbiA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4gKyAnJztcbiAgfSAvLyByZXR1cm5cblxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEZpbGUgc3lzdGVtIGxvYWRlciBmYWN0b3J5LlxuICogQHBhcmFtIHtvYmplY3R9IGZzIC0gVGhlIGZpbGUgc3lzdGVtIGludGVyZmFjZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSAtIEEgZmlsZSBsb2FkZXIgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqICAgcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBUaGUgZmlsZSBzeXN0ZW0gcGF0aCB0byBsb2FkLlxuICogICBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBmaWxlIHN5c3RlbSBwYXRoIHRvIGxvYWQuXG4gKiAgIHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZpbGUgY29udGVudHMuXG4gKi9cblxuXG5mdW5jdGlvbiBmaWxlTG9hZGVyKGZzKSB7XG4gIHJldHVybiBmcyA/IGZpbGVuYW1lID0+IG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWRGaWxlKGZpbGVuYW1lLCAoZXJyb3IsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnJvcikgcmVqZWN0KGVycm9yKTtlbHNlIGFjY2VwdChkYXRhKTtcbiAgICB9KTtcbiAgfSkgOiBmaWxlUmVqZWN0O1xufVxuLyoqXG4gKiBEZWZhdWx0IGZpbGUgc3lzdGVtIGxvYWRlciB0aGF0IHNpbXBseSByZWplY3RzLlxuICovXG5cblxuYXN5bmMgZnVuY3Rpb24gZmlsZVJlamVjdCgpIHtcbiAgZXJyb3IoJ05vIGZpbGUgc3lzdGVtIGFjY2Vzcy4nKTtcbn1cbi8qKlxuICogSFRUUCByZXF1ZXN0IGhhbmRsZXIgZmFjdG9yeS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZldGNoIC0gVGhlIEZldGNoIEFQSSBtZXRob2QuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gLSBBbiBodHRwIGxvYWRlciB3aXRoIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICogICBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIHJlcXVlc3QuXG4gKiAgIHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBbiBvcHRpb25zIGhhc2guXG4gKiAgIHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmlsZSBjb250ZW50cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGh0dHBMb2FkZXIoZmV0Y2gpIHtcbiAgcmV0dXJuIGZldGNoID8gYXN5bmMgZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9wdCA9IGV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmh0dHAsIG9wdGlvbnMpLFxuICAgICAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMucmVzcG9uc2UsXG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdCk7XG4gICAgcmV0dXJuICFyZXNwb25zZS5vayA/IGVycm9yKHJlc3BvbnNlLnN0YXR1cyArICcnICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCkgOiBpc0Z1bmN0aW9uKHJlc3BvbnNlW3R5cGVdKSA/IHJlc3BvbnNlW3R5cGVdKCkgOiByZXNwb25zZS50ZXh0KCk7XG4gIH0gOiBodHRwUmVqZWN0O1xufVxuLyoqXG4gKiBEZWZhdWx0IGh0dHAgcmVxdWVzdCBoYW5kbGVyIHRoYXQgc2ltcGx5IHJlamVjdHMuXG4gKi9cblxuXG5hc3luYyBmdW5jdGlvbiBodHRwUmVqZWN0KCkge1xuICBlcnJvcignTm8gSFRUUCBmZXRjaCBtZXRob2QgYXZhaWxhYmxlLicpO1xufVxuXG5jb25zdCBpc1ZhbGlkID0gXyA9PiBfICE9IG51bGwgJiYgXyA9PT0gXztcblxuY29uc3QgaXNCb29sZWFuID0gXyA9PiBfID09PSAndHJ1ZScgfHwgXyA9PT0gJ2ZhbHNlJyB8fCBfID09PSB0cnVlIHx8IF8gPT09IGZhbHNlO1xuXG5jb25zdCBpc0RhdGUgPSBfID0+ICFOdW1iZXIuaXNOYU4oRGF0ZS5wYXJzZShfKSk7XG5cbmNvbnN0IGlzTnVtYmVyID0gXyA9PiAhTnVtYmVyLmlzTmFOKCtfKSAmJiAhKF8gaW5zdGFuY2VvZiBEYXRlKTtcblxuY29uc3QgaXNJbnRlZ2VyID0gXyA9PiBpc051bWJlcihfKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKCtfKTtcblxuY29uc3QgdHlwZVBhcnNlcnMgPSB7XG4gIGJvb2xlYW46IHRvQm9vbGVhbixcbiAgaW50ZWdlcjogdG9OdW1iZXIsXG4gIG51bWJlcjogdG9OdW1iZXIsXG4gIGRhdGU6IHRvRGF0ZSxcbiAgc3RyaW5nOiB0b1N0cmluZyxcbiAgdW5rbm93bjogaWRlbnRpdHlcbn07XG5jb25zdCB0eXBlVGVzdHMgPSBbaXNCb29sZWFuLCBpc0ludGVnZXIsIGlzTnVtYmVyLCBpc0RhdGVdO1xuY29uc3QgdHlwZUxpc3QgPSBbJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInLCAnZGF0ZSddO1xuZnVuY3Rpb24gaW5mZXJUeXBlKHZhbHVlcywgZmllbGQpIHtcbiAgaWYgKCF2YWx1ZXMgfHwgIXZhbHVlcy5sZW5ndGgpIHJldHVybiAndW5rbm93bic7XG4gIGNvbnN0IG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBtID0gdHlwZVRlc3RzLmxlbmd0aCxcbiAgICAgICAgYSA9IHR5cGVUZXN0cy5tYXAoKF8sIGkpID0+IGkgKyAxKTtcblxuICBmb3IgKGxldCBpID0gMCwgdCA9IDAsIGosIHZhbHVlOyBpIDwgbjsgKytpKSB7XG4gICAgdmFsdWUgPSBmaWVsZCA/IHZhbHVlc1tpXVtmaWVsZF0gOiB2YWx1ZXNbaV07XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoYVtqXSAmJiBpc1ZhbGlkKHZhbHVlKSAmJiAhdHlwZVRlc3RzW2pdKHZhbHVlKSkge1xuICAgICAgICBhW2pdID0gMDtcbiAgICAgICAgKyt0O1xuICAgICAgICBpZiAodCA9PT0gdHlwZVRlc3RzLmxlbmd0aCkgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0eXBlTGlzdFthLnJlZHVjZSgodSwgdikgPT4gdSA9PT0gMCA/IHYgOiB1LCAwKSAtIDFdO1xufVxuZnVuY3Rpb24gaW5mZXJUeXBlcyhkYXRhLCBmaWVsZHMpIHtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKHR5cGVzLCBmaWVsZCkgPT4ge1xuICAgIHR5cGVzW2ZpZWxkXSA9IGluZmVyVHlwZShkYXRhLCBmaWVsZCk7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGRlbGltaXRlZEZvcm1hdChkZWxpbWl0ZXIpIHtcbiAgY29uc3QgcGFyc2UgPSBmdW5jdGlvbiAoZGF0YSwgZm9ybWF0KSB7XG4gICAgY29uc3QgZGVsaW0gPSB7XG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlclxuICAgIH07XG4gICAgcmV0dXJuIGRzdihkYXRhLCBmb3JtYXQgPyBleHRlbmQoZm9ybWF0LCBkZWxpbSkgOiBkZWxpbSk7XG4gIH07XG5cbiAgcGFyc2UucmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuICByZXR1cm4gcGFyc2U7XG59XG5mdW5jdGlvbiBkc3YoZGF0YSwgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQuaGVhZGVyKSB7XG4gICAgZGF0YSA9IGZvcm1hdC5oZWFkZXIubWFwKHN0cmluZ1ZhbHVlKS5qb2luKGZvcm1hdC5kZWxpbWl0ZXIpICsgJ1xcbicgKyBkYXRhO1xuICB9XG5cbiAgcmV0dXJuIGRzdkZvcm1hdChmb3JtYXQuZGVsaW1pdGVyKS5wYXJzZShkYXRhICsgJycpO1xufVxuZHN2LnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcblxuZnVuY3Rpb24gaXNCdWZmZXIoXykge1xuICByZXR1cm4gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Z1bmN0aW9uKEJ1ZmZlci5pc0J1ZmZlcikgPyBCdWZmZXIuaXNCdWZmZXIoXykgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24ganNvbihkYXRhLCBmb3JtYXQpIHtcbiAgY29uc3QgcHJvcCA9IGZvcm1hdCAmJiBmb3JtYXQucHJvcGVydHkgPyBmaWVsZChmb3JtYXQucHJvcGVydHkpIDogaWRlbnRpdHk7XG4gIHJldHVybiBpc09iamVjdChkYXRhKSAmJiAhaXNCdWZmZXIoZGF0YSkgPyBwYXJzZUpTT04ocHJvcChkYXRhKSwgZm9ybWF0KSA6IHByb3AoSlNPTi5wYXJzZShkYXRhKSk7XG59XG5qc29uLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcblxuZnVuY3Rpb24gcGFyc2VKU09OKGRhdGEsIGZvcm1hdCkge1xuICBpZiAoIWlzQXJyYXkoZGF0YSkgJiYgaXNJdGVyYWJsZShkYXRhKSkge1xuICAgIGRhdGEgPSBbLi4uZGF0YV07XG4gIH1cblxuICByZXR1cm4gZm9ybWF0ICYmIGZvcm1hdC5jb3B5ID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgOiBkYXRhO1xufVxuXG5jb25zdCBmaWx0ZXJzID0ge1xuICBpbnRlcmlvcjogKGEsIGIpID0+IGEgIT09IGIsXG4gIGV4dGVyaW9yOiAoYSwgYikgPT4gYSA9PT0gYlxufTtcbmZ1bmN0aW9uIHRvcG9qc29uKGRhdGEsIGZvcm1hdCkge1xuICBsZXQgbWV0aG9kLCBvYmplY3QsIHByb3BlcnR5LCBmaWx0ZXI7XG4gIGRhdGEgPSBqc29uKGRhdGEsIGZvcm1hdCk7XG5cbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQuZmVhdHVyZSkge1xuICAgIG1ldGhvZCA9IGZlYXR1cmU7XG4gICAgcHJvcGVydHkgPSBmb3JtYXQuZmVhdHVyZTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgJiYgZm9ybWF0Lm1lc2gpIHtcbiAgICBtZXRob2QgPSBtZXNoO1xuICAgIHByb3BlcnR5ID0gZm9ybWF0Lm1lc2g7XG4gICAgZmlsdGVyID0gZmlsdGVyc1tmb3JtYXQuZmlsdGVyXTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcignTWlzc2luZyBUb3BvSlNPTiBmZWF0dXJlIG9yIG1lc2ggcGFyYW1ldGVyLicpO1xuICB9XG5cbiAgb2JqZWN0ID0gKG9iamVjdCA9IGRhdGEub2JqZWN0c1twcm9wZXJ0eV0pID8gbWV0aG9kKGRhdGEsIG9iamVjdCwgZmlsdGVyKSA6IGVycm9yKCdJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogJyArIHByb3BlcnR5KTtcbiAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuZmVhdHVyZXMgfHwgW29iamVjdF07XG59XG50b3BvanNvbi5yZXNwb25zZVR5cGUgPSAnanNvbic7XG5cbmNvbnN0IGZvcm1hdCA9IHtcbiAgZHN2OiBkc3YsXG4gIGNzdjogZGVsaW1pdGVkRm9ybWF0KCcsJyksXG4gIHRzdjogZGVsaW1pdGVkRm9ybWF0KCdcXHQnKSxcbiAganNvbjoganNvbixcbiAgdG9wb2pzb246IHRvcG9qc29uXG59O1xuZnVuY3Rpb24gZm9ybWF0cyhuYW1lLCByZWFkZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgZm9ybWF0W25hbWVdID0gcmVhZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eShmb3JtYXQsIG5hbWUpID8gZm9ybWF0W25hbWVdIDogbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzcG9uc2VUeXBlKHR5cGUpIHtcbiAgY29uc3QgZiA9IGZvcm1hdHModHlwZSk7XG4gIHJldHVybiBmICYmIGYucmVzcG9uc2VUeXBlIHx8ICd0ZXh0Jztcbn1cblxuZnVuY3Rpb24gcmVhZCAoZGF0YSwgc2NoZW1hLCB0aW1lUGFyc2VyLCB1dGNQYXJzZXIpIHtcbiAgc2NoZW1hID0gc2NoZW1hIHx8IHt9O1xuICBjb25zdCByZWFkZXIgPSBmb3JtYXRzKHNjaGVtYS50eXBlIHx8ICdqc29uJyk7XG4gIGlmICghcmVhZGVyKSBlcnJvcignVW5rbm93biBkYXRhIGZvcm1hdCB0eXBlOiAnICsgc2NoZW1hLnR5cGUpO1xuICBkYXRhID0gcmVhZGVyKGRhdGEsIHNjaGVtYSk7XG4gIGlmIChzY2hlbWEucGFyc2UpIHBhcnNlKGRhdGEsIHNjaGVtYS5wYXJzZSwgdGltZVBhcnNlciwgdXRjUGFyc2VyKTtcbiAgaWYgKGhhc093blByb3BlcnR5KGRhdGEsICdjb2x1bW5zJykpIGRlbGV0ZSBkYXRhLmNvbHVtbnM7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZShkYXRhLCB0eXBlcywgdGltZVBhcnNlciwgdXRjUGFyc2VyKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjsgLy8gZWFybHkgZXhpdCBmb3IgZW1wdHkgZGF0YVxuXG4gIGNvbnN0IGxvY2FsZSA9IHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG4gIHRpbWVQYXJzZXIgPSB0aW1lUGFyc2VyIHx8IGxvY2FsZS50aW1lUGFyc2U7XG4gIHV0Y1BhcnNlciA9IHV0Y1BhcnNlciB8fCBsb2NhbGUudXRjUGFyc2U7XG4gIGxldCBmaWVsZHMgPSBkYXRhLmNvbHVtbnMgfHwgT2JqZWN0LmtleXMoZGF0YVswXSksXG4gICAgICBkYXR1bSxcbiAgICAgIGZpZWxkLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICBuLFxuICAgICAgbTtcbiAgaWYgKHR5cGVzID09PSAnYXV0bycpIHR5cGVzID0gaW5mZXJUeXBlcyhkYXRhLCBmaWVsZHMpO1xuICBmaWVsZHMgPSBPYmplY3Qua2V5cyh0eXBlcyk7XG4gIGNvbnN0IHBhcnNlcnMgPSBmaWVsZHMubWFwKGZpZWxkID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbZmllbGRdO1xuICAgIGxldCBwYXJ0cywgcGF0dGVybjtcblxuICAgIGlmICh0eXBlICYmICh0eXBlLnN0YXJ0c1dpdGgoJ2RhdGU6JykgfHwgdHlwZS5zdGFydHNXaXRoKCd1dGM6JykpKSB7XG4gICAgICBwYXJ0cyA9IHR5cGUuc3BsaXQoLzooLispPy8sIDIpOyAvLyBzcGxpdCBvbiBmaXJzdCA6XG5cbiAgICAgIHBhdHRlcm4gPSBwYXJ0c1sxXTtcblxuICAgICAgaWYgKHBhdHRlcm5bMF0gPT09ICdcXCcnICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGggLSAxXSA9PT0gJ1xcJycgfHwgcGF0dGVyblswXSA9PT0gJ1wiJyAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZSA9IHBhcnRzWzBdID09PSAndXRjJyA/IHV0Y1BhcnNlciA6IHRpbWVQYXJzZXI7XG4gICAgICByZXR1cm4gcGFyc2UocGF0dGVybik7XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlUGFyc2Vyc1t0eXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0lsbGVnYWwgZm9ybWF0IHBhdHRlcm46ICcgKyBmaWVsZCArICc6JyArIHR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlUGFyc2Vyc1t0eXBlXTtcbiAgfSk7XG5cbiAgZm9yIChpID0gMCwgbiA9IGRhdGEubGVuZ3RoLCBtID0gZmllbGRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGRhdHVtID0gZGF0YVtpXTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGZpZWxkID0gZmllbGRzW2pdO1xuICAgICAgZGF0dW1bZmllbGRdID0gcGFyc2Vyc1tqXShkYXR1bVtmaWVsZF0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBsb2FkZXIgPSBsb2FkZXJGYWN0b3J5KHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcgJiYgZmV0Y2gsIC8vIHVzZSBidWlsdC1pbiBmZXRjaCBBUElcbm51bGwgLy8gbm8gZmlsZSBzeXN0ZW0gYWNjZXNzXG4pO1xuXG5leHBvcnQgeyBmb3JtYXQsIGZvcm1hdHMsIGluZmVyVHlwZSwgaW5mZXJUeXBlcywgbG9hZGVyLCByZWFkLCByZXNwb25zZVR5cGUsIHR5cGVQYXJzZXJzIH07XG4iLCJpbXBvcnQgeyBpc09iamVjdCwgaXNBcnJheSwgZXh0ZW5kLCBoYXNPd25Qcm9wZXJ0eSwgYXJyYXksIHN0cmluZ1ZhbHVlLCBwZWVrLCBpc1N0cmluZywgZXJyb3IsIHNwbGl0QWNjZXNzUGF0aCwgbWVyZ2VDb25maWcgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgcGFyc2VFeHByZXNzaW9uIH0gZnJvbSAndmVnYS1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgcGFyc2VTZWxlY3RvciB9IGZyb20gJ3ZlZ2EtZXZlbnQtc2VsZWN0b3InO1xuaW1wb3J0IHsgaXNWYWxpZFNjYWxlVHlwZSwgaXNEaXNjcmV0ZSwgaXNRdWFudGlsZSwgaXNEaXNjcmV0aXppbmcsIGlzQ29udGludW91cyB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuaW1wb3J0IHsgZGVmaW5pdGlvbiBhcyBkZWZpbml0aW9uJDEgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcblxuZnVuY3Rpb24gcGFyc2VBdXRvc2l6ZSAoc3BlYykge1xuICByZXR1cm4gaXNPYmplY3Qoc3BlYykgPyBzcGVjIDoge1xuICAgIHR5cGU6IHNwZWMgfHwgJ3BhZCdcbiAgfTtcbn1cblxuY29uc3QgbnVtYmVyID0gXyA9PiArXyB8fCAwO1xuXG5jb25zdCBwYWRkaW5nT2JqZWN0ID0gXyA9PiAoe1xuICB0b3A6IF8sXG4gIGJvdHRvbTogXyxcbiAgbGVmdDogXyxcbiAgcmlnaHQ6IF9cbn0pO1xuXG5mdW5jdGlvbiBwYXJzZVBhZGRpbmcgKHNwZWMpIHtcbiAgcmV0dXJuICFpc09iamVjdChzcGVjKSA/IHBhZGRpbmdPYmplY3QobnVtYmVyKHNwZWMpKSA6IHNwZWMuc2lnbmFsID8gc3BlYyA6IHtcbiAgICB0b3A6IG51bWJlcihzcGVjLnRvcCksXG4gICAgYm90dG9tOiBudW1iZXIoc3BlYy5ib3R0b20pLFxuICAgIGxlZnQ6IG51bWJlcihzcGVjLmxlZnQpLFxuICAgIHJpZ2h0OiBudW1iZXIoc3BlYy5yaWdodClcbiAgfTtcbn1cblxuY29uc3QgZW5jb2RlciA9IF8gPT4gaXNPYmplY3QoXykgJiYgIWlzQXJyYXkoXykgPyBleHRlbmQoe30sIF8pIDoge1xuICB2YWx1ZTogX1xufTtcbmZ1bmN0aW9uIGFkZEVuY29kZShvYmplY3QsIG5hbWUsIHZhbHVlLCBzZXQpIHtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBjb25zdCBpc0VuY29kZXIgPSBpc09iamVjdCh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCAmJiBpc09iamVjdCh2YWx1ZVswXSk7IC8vIEFsd2F5cyBhc3NpZ24gc2lnbmFsIHRvIHVwZGF0ZSwgZXZlbiBpZiB0aGUgc2lnbmFsIGlzIGZyb20gdGhlIGVudGVyIGJsb2NrXG5cbiAgICBpZiAoaXNFbmNvZGVyKSB7XG4gICAgICBvYmplY3QudXBkYXRlW25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFtzZXQgfHwgJ2VudGVyJ11bbmFtZV0gPSB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuZnVuY3Rpb24gYWRkRW5jb2RlcnMob2JqZWN0LCBlbnRlciwgdXBkYXRlKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBlbnRlcikge1xuICAgIGFkZEVuY29kZShvYmplY3QsIG5hbWUsIGVudGVyW25hbWVdKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbmFtZSBpbiB1cGRhdGUpIHtcbiAgICBhZGRFbmNvZGUob2JqZWN0LCBuYW1lLCB1cGRhdGVbbmFtZV0sICd1cGRhdGUnKTtcbiAgfVxufVxuZnVuY3Rpb24gZXh0ZW5kRW5jb2RlKGVuY29kZSwgZXh0cmEsIHNraXApIHtcbiAgZm9yIChjb25zdCBuYW1lIGluIGV4dHJhKSB7XG4gICAgaWYgKHNraXAgJiYgaGFzT3duUHJvcGVydHkoc2tpcCwgbmFtZSkpIGNvbnRpbnVlO1xuICAgIGVuY29kZVtuYW1lXSA9IGV4dGVuZChlbmNvZGVbbmFtZV0gfHwge30sIGV4dHJhW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBlbmNvZGU7XG59XG5mdW5jdGlvbiBoYXMoa2V5LCBlbmNvZGUpIHtcbiAgcmV0dXJuIGVuY29kZSAmJiAoZW5jb2RlLmVudGVyICYmIGVuY29kZS5lbnRlcltrZXldIHx8IGVuY29kZS51cGRhdGUgJiYgZW5jb2RlLnVwZGF0ZVtrZXldKTtcbn1cblxuY29uc3QgTWFya1JvbGUgPSAnbWFyayc7XG5jb25zdCBGcmFtZVJvbGUgPSAnZnJhbWUnO1xuY29uc3QgU2NvcGVSb2xlID0gJ3Njb3BlJztcbmNvbnN0IEF4aXNSb2xlID0gJ2F4aXMnO1xuY29uc3QgQXhpc0RvbWFpblJvbGUgPSAnYXhpcy1kb21haW4nO1xuY29uc3QgQXhpc0dyaWRSb2xlID0gJ2F4aXMtZ3JpZCc7XG5jb25zdCBBeGlzTGFiZWxSb2xlID0gJ2F4aXMtbGFiZWwnO1xuY29uc3QgQXhpc1RpY2tSb2xlID0gJ2F4aXMtdGljayc7XG5jb25zdCBBeGlzVGl0bGVSb2xlID0gJ2F4aXMtdGl0bGUnO1xuY29uc3QgTGVnZW5kUm9sZSA9ICdsZWdlbmQnO1xuY29uc3QgTGVnZW5kQmFuZFJvbGUgPSAnbGVnZW5kLWJhbmQnO1xuY29uc3QgTGVnZW5kRW50cnlSb2xlID0gJ2xlZ2VuZC1lbnRyeSc7XG5jb25zdCBMZWdlbmRHcmFkaWVudFJvbGUgPSAnbGVnZW5kLWdyYWRpZW50JztcbmNvbnN0IExlZ2VuZExhYmVsUm9sZSA9ICdsZWdlbmQtbGFiZWwnO1xuY29uc3QgTGVnZW5kU3ltYm9sUm9sZSA9ICdsZWdlbmQtc3ltYm9sJztcbmNvbnN0IExlZ2VuZFRpdGxlUm9sZSA9ICdsZWdlbmQtdGl0bGUnO1xuY29uc3QgVGl0bGVSb2xlID0gJ3RpdGxlJztcbmNvbnN0IFRpdGxlVGV4dFJvbGUgPSAndGl0bGUtdGV4dCc7XG5jb25zdCBUaXRsZVN1YnRpdGxlUm9sZSA9ICd0aXRsZS1zdWJ0aXRsZSc7XG5cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMgKGVuY29kZSwgdHlwZSwgcm9sZSwgc3R5bGUsIGNvbmZpZykge1xuICBjb25zdCBkZWZhdWx0cyA9IHt9LFxuICAgICAgICBlbnRlciA9IHt9O1xuICBsZXQgdXBkYXRlLCBrZXksIHNraXAsIHByb3BzOyAvLyBpZiB0ZXh0IG1hcmssIGFwcGx5IGdsb2JhbCBsaW5lQnJlYWsgc2V0dGluZ3MgKCMyMzcwKVxuXG4gIGtleSA9ICdsaW5lQnJlYWsnO1xuXG4gIGlmICh0eXBlID09PSAndGV4dCcgJiYgY29uZmlnW2tleV0gIT0gbnVsbCAmJiAhaGFzKGtleSwgZW5jb2RlKSkge1xuICAgIGFwcGx5RGVmYXVsdChkZWZhdWx0cywga2V5LCBjb25maWdba2V5XSk7XG4gIH0gLy8gaWdub3JlIGxlZ2VuZCBhbmQgYXhpcyByb2xlc1xuXG5cbiAgaWYgKHJvbGUgPT0gJ2xlZ2VuZCcgfHwgU3RyaW5nKHJvbGUpLnN0YXJ0c1dpdGgoJ2F4aXMnKSkge1xuICAgIHJvbGUgPSBudWxsO1xuICB9IC8vIHJlc29sdmUgbWFyayBjb25maWdcblxuXG4gIHByb3BzID0gcm9sZSA9PT0gRnJhbWVSb2xlID8gY29uZmlnLmdyb3VwIDogcm9sZSA9PT0gTWFya1JvbGUgPyBleHRlbmQoe30sIGNvbmZpZy5tYXJrLCBjb25maWdbdHlwZV0pIDogbnVsbDtcblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIC8vIGRvIG5vdCBhcHBseSBkZWZhdWx0cyBpZiByZWxldmFudCBmaWVsZHMgYXJlIGRlZmluZWRcbiAgICBza2lwID0gaGFzKGtleSwgZW5jb2RlKSB8fCAoa2V5ID09PSAnZmlsbCcgfHwga2V5ID09PSAnc3Ryb2tlJykgJiYgKGhhcygnZmlsbCcsIGVuY29kZSkgfHwgaGFzKCdzdHJva2UnLCBlbmNvZGUpKTtcbiAgICBpZiAoIXNraXApIGFwcGx5RGVmYXVsdChkZWZhdWx0cywga2V5LCBwcm9wc1trZXldKTtcbiAgfSAvLyByZXNvbHZlIHN0eWxlcywgYXBwbHkgd2l0aCBpbmNyZWFzaW5nIHByZWNlZGVuY2VcblxuXG4gIGFycmF5KHN0eWxlKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gY29uZmlnLnN0eWxlICYmIGNvbmZpZy5zdHlsZVtuYW1lXTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIWhhcyhrZXksIGVuY29kZSkpIHtcbiAgICAgICAgYXBwbHlEZWZhdWx0KGRlZmF1bHRzLCBrZXksIHByb3BzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGVuY29kZSA9IGV4dGVuZCh7fSwgZW5jb2RlKTsgLy8gZGVmZW5zaXZlIGNvcHlcblxuICBmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuICAgIHByb3BzID0gZGVmYXVsdHNba2V5XTtcblxuICAgIGlmIChwcm9wcy5zaWduYWwpIHtcbiAgICAgICh1cGRhdGUgPSB1cGRhdGUgfHwge30pW2tleV0gPSBwcm9wcztcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJba2V5XSA9IHByb3BzO1xuICAgIH1cbiAgfVxuXG4gIGVuY29kZS5lbnRlciA9IGV4dGVuZChlbnRlciwgZW5jb2RlLmVudGVyKTtcbiAgaWYgKHVwZGF0ZSkgZW5jb2RlLnVwZGF0ZSA9IGV4dGVuZCh1cGRhdGUsIGVuY29kZS51cGRhdGUpO1xuICByZXR1cm4gZW5jb2RlO1xufVxuXG5mdW5jdGlvbiBhcHBseURlZmF1bHQoZGVmYXVsdHMsIGtleSwgdmFsdWUpIHtcbiAgZGVmYXVsdHNba2V5XSA9IHZhbHVlICYmIHZhbHVlLnNpZ25hbCA/IHtcbiAgICBzaWduYWw6IHZhbHVlLnNpZ25hbFxuICB9IDoge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufVxuXG5jb25zdCBzY2FsZVJlZiA9IHNjYWxlID0+IGlzU3RyaW5nKHNjYWxlKSA/IHN0cmluZ1ZhbHVlKHNjYWxlKSA6IHNjYWxlLnNpZ25hbCA/IGAoJHtzY2FsZS5zaWduYWx9KWAgOiBmaWVsZChzY2FsZSk7XG5cbmZ1bmN0aW9uIGVudHJ5JDEoZW5jKSB7XG4gIGlmIChlbmMuZ3JhZGllbnQgIT0gbnVsbCkge1xuICAgIHJldHVybiBncmFkaWVudChlbmMpO1xuICB9XG5cbiAgbGV0IHZhbHVlID0gZW5jLnNpZ25hbCA/IGAoJHtlbmMuc2lnbmFsfSlgIDogZW5jLmNvbG9yID8gY29sb3IoZW5jLmNvbG9yKSA6IGVuYy5maWVsZCAhPSBudWxsID8gZmllbGQoZW5jLmZpZWxkKSA6IGVuYy52YWx1ZSAhPT0gdW5kZWZpbmVkID8gc3RyaW5nVmFsdWUoZW5jLnZhbHVlKSA6IHVuZGVmaW5lZDtcblxuICBpZiAoZW5jLnNjYWxlICE9IG51bGwpIHtcbiAgICB2YWx1ZSA9IHNjYWxlKGVuYywgdmFsdWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoZW5jLmV4cG9uZW50ICE9IG51bGwpIHtcbiAgICB2YWx1ZSA9IGBwb3coJHt2YWx1ZX0sJHtwcm9wZXJ0eShlbmMuZXhwb25lbnQpfSlgO1xuICB9XG5cbiAgaWYgKGVuYy5tdWx0ICE9IG51bGwpIHtcbiAgICB2YWx1ZSArPSBgKiR7cHJvcGVydHkoZW5jLm11bHQpfWA7XG4gIH1cblxuICBpZiAoZW5jLm9mZnNldCAhPSBudWxsKSB7XG4gICAgdmFsdWUgKz0gYCske3Byb3BlcnR5KGVuYy5vZmZzZXQpfWA7XG4gIH1cblxuICBpZiAoZW5jLnJvdW5kKSB7XG4gICAgdmFsdWUgPSBgcm91bmQoJHt2YWx1ZX0pYDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuY29uc3QgX2NvbG9yID0gKHR5cGUsIHgsIHksIHopID0+IGAoJHt0eXBlfSgke1t4LCB5LCB6XS5tYXAoZW50cnkkMSkuam9pbignLCcpfSkrJycpYDtcblxuZnVuY3Rpb24gY29sb3IoZW5jKSB7XG4gIHJldHVybiBlbmMuYyA/IF9jb2xvcignaGNsJywgZW5jLmgsIGVuYy5jLCBlbmMubCkgOiBlbmMuaCB8fCBlbmMucyA/IF9jb2xvcignaHNsJywgZW5jLmgsIGVuYy5zLCBlbmMubCkgOiBlbmMubCB8fCBlbmMuYSA/IF9jb2xvcignbGFiJywgZW5jLmwsIGVuYy5hLCBlbmMuYikgOiBlbmMuciB8fCBlbmMuZyB8fCBlbmMuYiA/IF9jb2xvcigncmdiJywgZW5jLnIsIGVuYy5nLCBlbmMuYikgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBncmFkaWVudChlbmMpIHtcbiAgLy8gbWFwIHVuZGVmaW5lZCB0byBudWxsOyBleHByZXNzaW9uIGxhbmcgZG9lcyBub3QgYWxsb3cgdW5kZWZpbmVkXG4gIGNvbnN0IGFyZ3MgPSBbZW5jLnN0YXJ0LCBlbmMuc3RvcCwgZW5jLmNvdW50XS5tYXAoXyA9PiBfID09IG51bGwgPyBudWxsIDogc3RyaW5nVmFsdWUoXykpOyAvLyB0cmltIG51bGwgaW5wdXRzIGZyb20gdGhlIGVuZFxuXG4gIHdoaWxlIChhcmdzLmxlbmd0aCAmJiBwZWVrKGFyZ3MpID09IG51bGwpIGFyZ3MucG9wKCk7XG5cbiAgYXJncy51bnNoaWZ0KHNjYWxlUmVmKGVuYy5ncmFkaWVudCkpO1xuICByZXR1cm4gYGdyYWRpZW50KCR7YXJncy5qb2luKCcsJyl9KWA7XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5KHByb3BlcnR5KSB7XG4gIHJldHVybiBpc09iamVjdChwcm9wZXJ0eSkgPyAnKCcgKyBlbnRyeSQxKHByb3BlcnR5KSArICcpJyA6IHByb3BlcnR5O1xufVxuXG5mdW5jdGlvbiBmaWVsZChyZWYpIHtcbiAgcmV0dXJuIHJlc29sdmVGaWVsZChpc09iamVjdChyZWYpID8gcmVmIDoge1xuICAgIGRhdHVtOiByZWZcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGaWVsZChyZWYpIHtcbiAgbGV0IG9iamVjdCwgbGV2ZWwsIGZpZWxkO1xuXG4gIGlmIChyZWYuc2lnbmFsKSB7XG4gICAgb2JqZWN0ID0gJ2RhdHVtJztcbiAgICBmaWVsZCA9IHJlZi5zaWduYWw7XG4gIH0gZWxzZSBpZiAocmVmLmdyb3VwIHx8IHJlZi5wYXJlbnQpIHtcbiAgICBsZXZlbCA9IE1hdGgubWF4KDEsIHJlZi5sZXZlbCB8fCAxKTtcbiAgICBvYmplY3QgPSAnaXRlbSc7XG5cbiAgICB3aGlsZSAobGV2ZWwtLSA+IDApIHtcbiAgICAgIG9iamVjdCArPSAnLm1hcmsuZ3JvdXAnO1xuICAgIH1cblxuICAgIGlmIChyZWYucGFyZW50KSB7XG4gICAgICBmaWVsZCA9IHJlZi5wYXJlbnQ7XG4gICAgICBvYmplY3QgKz0gJy5kYXR1bSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkID0gcmVmLmdyb3VwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWYuZGF0dW0pIHtcbiAgICBvYmplY3QgPSAnZGF0dW0nO1xuICAgIGZpZWxkID0gcmVmLmRhdHVtO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKCdJbnZhbGlkIGZpZWxkIHJlZmVyZW5jZTogJyArIHN0cmluZ1ZhbHVlKHJlZikpO1xuICB9XG5cbiAgaWYgKCFyZWYuc2lnbmFsKSB7XG4gICAgZmllbGQgPSBpc1N0cmluZyhmaWVsZCkgPyBzcGxpdEFjY2Vzc1BhdGgoZmllbGQpLm1hcChzdHJpbmdWYWx1ZSkuam9pbignXVsnKSA6IHJlc29sdmVGaWVsZChmaWVsZCk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0ICsgJ1snICsgZmllbGQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHNjYWxlKGVuYywgdmFsdWUpIHtcbiAgY29uc3Qgc2NhbGUgPSBzY2FsZVJlZihlbmMuc2NhbGUpO1xuXG4gIGlmIChlbmMucmFuZ2UgIT0gbnVsbCkge1xuICAgIC8vIHB1bGwgdmFsdWUgZnJvbSBzY2FsZSByYW5nZVxuICAgIHZhbHVlID0gYGxlcnAoX3JhbmdlKCR7c2NhbGV9KSwgJHsrZW5jLnJhbmdlfSlgO1xuICB9IGVsc2Uge1xuICAgIC8vIHJ1biB2YWx1ZSB0aHJvdWdoIHNjYWxlIGFuZC9vciBwdWxsIHNjYWxlIGJhbmR3aWR0aFxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB2YWx1ZSA9IGBfc2NhbGUoJHtzY2FsZX0sICR7dmFsdWV9KWA7XG5cbiAgICBpZiAoZW5jLmJhbmQpIHtcbiAgICAgIHZhbHVlID0gKHZhbHVlID8gdmFsdWUgKyAnKycgOiAnJykgKyBgX2JhbmR3aWR0aCgke3NjYWxlfSlgICsgKCtlbmMuYmFuZCA9PT0gMSA/ICcnIDogJyonICsgcHJvcGVydHkoZW5jLmJhbmQpKTtcblxuICAgICAgaWYgKGVuYy5leHRyYSkge1xuICAgICAgICAvLyBpbmNsdWRlIGxvZ2ljIHRvIGhhbmRsZSBleHRyYW5lb3VzIGVsZW1lbnRzXG4gICAgICAgIHZhbHVlID0gYChkYXR1bS5leHRyYSA/IF9zY2FsZSgke3NjYWxlfSwgZGF0dW0uZXh0cmEudmFsdWUpIDogJHt2YWx1ZX0pYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSAnMCc7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJ1bGUgKGVuYykge1xuICBsZXQgY29kZSA9ICcnO1xuICBlbmMuZm9yRWFjaChydWxlID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGVudHJ5JDEocnVsZSk7XG4gICAgY29kZSArPSBydWxlLnRlc3QgPyBgKCR7cnVsZS50ZXN0fSk/JHt2YWx1ZX06YCA6IHZhbHVlO1xuICB9KTsgLy8gaWYgbm8gZWxzZSBjbGF1c2UsIHRlcm1pbmF0ZSB3aXRoIG51bGwgKCMxMzY2KVxuXG4gIGlmIChwZWVrKGNvZGUpID09PSAnOicpIHtcbiAgICBjb2RlICs9ICdudWxsJztcbiAgfVxuXG4gIHJldHVybiBjb2RlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVuY29kZSAoZW5jb2RlLCB0eXBlLCByb2xlLCBzdHlsZSwgc2NvcGUsIHBhcmFtcykge1xuICBjb25zdCBlbmMgPSB7fTtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMuZW5jb2RlcnMgPSB7XG4gICAgJGVuY29kZTogZW5jXG4gIH07XG4gIGVuY29kZSA9IGFwcGx5RGVmYXVsdHMoZW5jb2RlLCB0eXBlLCByb2xlLCBzdHlsZSwgc2NvcGUuY29uZmlnKTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBlbmNvZGUpIHtcbiAgICBlbmNba2V5XSA9IHBhcnNlQmxvY2soZW5jb2RlW2tleV0sIHR5cGUsIHBhcmFtcywgc2NvcGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gcGFyc2VCbG9jayhibG9jaywgbWFya3R5cGUsIHBhcmFtcywgc2NvcGUpIHtcbiAgY29uc3QgY2hhbm5lbHMgPSB7fSxcbiAgICAgICAgZmllbGRzID0ge307XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGJsb2NrKSB7XG4gICAgaWYgKGJsb2NrW25hbWVdICE9IG51bGwpIHtcbiAgICAgIC8vIHNraXAgYW55IG51bGwgZW50cmllc1xuICAgICAgY2hhbm5lbHNbbmFtZV0gPSBwYXJzZSQxKGV4cHIoYmxvY2tbbmFtZV0pLCBzY29wZSwgcGFyYW1zLCBmaWVsZHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJGV4cHI6IHtcbiAgICAgIG1hcmt0eXBlLFxuICAgICAgY2hhbm5lbHNcbiAgICB9LFxuICAgICRmaWVsZHM6IE9iamVjdC5rZXlzKGZpZWxkcyksXG4gICAgJG91dHB1dDogT2JqZWN0LmtleXMoYmxvY2spXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cHIoZW5jKSB7XG4gIHJldHVybiBpc0FycmF5KGVuYykgPyBydWxlKGVuYykgOiBlbnRyeSQxKGVuYyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlJDEoY29kZSwgc2NvcGUsIHBhcmFtcywgZmllbGRzKSB7XG4gIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oY29kZSwgc2NvcGUpO1xuICBleHByLiRmaWVsZHMuZm9yRWFjaChuYW1lID0+IGZpZWxkc1tuYW1lXSA9IDEpO1xuICBleHRlbmQocGFyYW1zLCBleHByLiRwYXJhbXMpO1xuICByZXR1cm4gZXhwci4kZXhwcjtcbn1cblxuY29uc3QgT1VURVIgPSAnb3V0ZXInLFxuICAgICAgT1VURVJfSU5WQUxJRCA9IFsndmFsdWUnLCAndXBkYXRlJywgJ2luaXQnLCAncmVhY3QnLCAnYmluZCddO1xuXG5mdW5jdGlvbiBvdXRlckVycm9yKHByZWZpeCwgbmFtZSkge1xuICBlcnJvcihwcmVmaXggKyAnIGZvciBcIm91dGVyXCIgcHVzaDogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTaWduYWwgKHNpZ25hbCwgc2NvcGUpIHtcbiAgY29uc3QgbmFtZSA9IHNpZ25hbC5uYW1lO1xuXG4gIGlmIChzaWduYWwucHVzaCA9PT0gT1VURVIpIHtcbiAgICAvLyBzaWduYWwgbXVzdCBhbHJlYWR5IGJlIGRlZmluZWQsIHJhaXNlIGVycm9yIGlmIG5vdFxuICAgIGlmICghc2NvcGUuc2lnbmFsc1tuYW1lXSkgb3V0ZXJFcnJvcignTm8gcHJpb3Igc2lnbmFsIGRlZmluaXRpb24nLCBuYW1lKTsgLy8gc2lnbmFsIHB1c2ggbXVzdCBub3QgdXNlIHByb3BlcnRpZXMgcmVzZXJ2ZWQgZm9yIHN0YW5kYXJkIGRlZmluaXRpb25cblxuICAgIE9VVEVSX0lOVkFMSUQuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIGlmIChzaWduYWxbcHJvcF0gIT09IHVuZGVmaW5lZCkgb3V0ZXJFcnJvcignSW52YWxpZCBwcm9wZXJ0eSAnLCBwcm9wKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBkZWZpbmUgYSBuZXcgc2lnbmFsIGluIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgY29uc3Qgb3AgPSBzY29wZS5hZGRTaWduYWwobmFtZSwgc2lnbmFsLnZhbHVlKTtcbiAgICBpZiAoc2lnbmFsLnJlYWN0ID09PSBmYWxzZSkgb3AucmVhY3QgPSBmYWxzZTtcbiAgICBpZiAoc2lnbmFsLmJpbmQpIHNjb3BlLmFkZEJpbmRpbmcobmFtZSwgc2lnbmFsLmJpbmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIEVudHJ5KHR5cGUsIHZhbHVlLCBwYXJhbXMsIHBhcmVudCkge1xuICB0aGlzLmlkID0gLTE7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIGlmIChwYXJlbnQpIHRoaXMucGFyZW50ID0gcGFyZW50O1xufVxuZnVuY3Rpb24gZW50cnkodHlwZSwgdmFsdWUsIHBhcmFtcywgcGFyZW50KSB7XG4gIHJldHVybiBuZXcgRW50cnkodHlwZSwgdmFsdWUsIHBhcmFtcywgcGFyZW50KTtcbn1cbmZ1bmN0aW9uIG9wZXJhdG9yKHZhbHVlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGVudHJ5KCdvcGVyYXRvcicsIHZhbHVlLCBwYXJhbXMpO1xufSAvLyAtLS0tLVxuXG5mdW5jdGlvbiByZWYob3ApIHtcbiAgY29uc3QgcmVmID0ge1xuICAgICRyZWY6IG9wLmlkXG4gIH07IC8vIGlmIG9wZXJhdG9yIG5vdCB5ZXQgcmVnaXN0ZXJlZCwgY2FjaGUgcmVmIHRvIHJlc29sdmUgbGF0ZXJcblxuICBpZiAob3AuaWQgPCAwKSAob3AucmVmcyA9IG9wLnJlZnMgfHwgW10pLnB1c2gocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn1cbmZ1bmN0aW9uIGZpZWxkUmVmJDEoZmllbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgPyB7XG4gICAgJGZpZWxkOiBmaWVsZCxcbiAgICAkbmFtZTogbmFtZVxuICB9IDoge1xuICAgICRmaWVsZDogZmllbGRcbiAgfTtcbn1cbmNvbnN0IGtleUZpZWxkUmVmID0gZmllbGRSZWYkMSgna2V5Jyk7XG5mdW5jdGlvbiBjb21wYXJlUmVmKGZpZWxkcywgb3JkZXJzKSB7XG4gIHJldHVybiB7XG4gICAgJGNvbXBhcmU6IGZpZWxkcyxcbiAgICAkb3JkZXI6IG9yZGVyc1xuICB9O1xufVxuZnVuY3Rpb24ga2V5UmVmKGZpZWxkcywgZmxhdCkge1xuICBjb25zdCByZWYgPSB7XG4gICAgJGtleTogZmllbGRzXG4gIH07XG4gIGlmIChmbGF0KSByZWYuJGZsYXQgPSB0cnVlO1xuICByZXR1cm4gcmVmO1xufSAvLyAtLS0tLVxuXG5jb25zdCBBc2NlbmRpbmcgPSAnYXNjZW5kaW5nJztcbmNvbnN0IERlc2NlbmRpbmcgPSAnZGVzY2VuZGluZyc7XG5mdW5jdGlvbiBzb3J0S2V5KHNvcnQpIHtcbiAgcmV0dXJuICFpc09iamVjdChzb3J0KSA/ICcnIDogKHNvcnQub3JkZXIgPT09IERlc2NlbmRpbmcgPyAnLScgOiAnKycpICsgYWdnckZpZWxkKHNvcnQub3AsIHNvcnQuZmllbGQpO1xufVxuZnVuY3Rpb24gYWdnckZpZWxkKG9wLCBmaWVsZCkge1xuICByZXR1cm4gKG9wICYmIG9wLnNpZ25hbCA/ICckJyArIG9wLnNpZ25hbCA6IG9wIHx8ICcnKSArIChvcCAmJiBmaWVsZCA/ICdfJyA6ICcnKSArIChmaWVsZCAmJiBmaWVsZC5zaWduYWwgPyAnJCcgKyBmaWVsZC5zaWduYWwgOiBmaWVsZCB8fCAnJyk7XG59IC8vIC0tLS0tXG5cbmNvbnN0IFNjb3BlJDEgPSAnc2NvcGUnO1xuY29uc3QgVmlldyA9ICd2aWV3JztcbmZ1bmN0aW9uIGlzU2lnbmFsKF8pIHtcbiAgcmV0dXJuIF8gJiYgXy5zaWduYWw7XG59XG5mdW5jdGlvbiBpc0V4cHIkMShfKSB7XG4gIHJldHVybiBfICYmIF8uZXhwcjtcbn1cbmZ1bmN0aW9uIGhhc1NpZ25hbChfKSB7XG4gIGlmIChpc1NpZ25hbChfKSkgcmV0dXJuIHRydWU7XG4gIGlmIChpc09iamVjdChfKSkgZm9yIChjb25zdCBrZXkgaW4gXykge1xuICAgIGlmIChoYXNTaWduYWwoX1trZXldKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdmFsdWUoc3BlY1ZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHNwZWNWYWx1ZSAhPSBudWxsID8gc3BlY1ZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gZGVyZWYodikge1xuICByZXR1cm4gdiAmJiB2LnNpZ25hbCB8fCB2O1xufVxuXG5jb25zdCBUaW1lciA9ICd0aW1lcic7XG5mdW5jdGlvbiBwYXJzZVN0cmVhbShzdHJlYW0sIHNjb3BlKSB7XG4gIGNvbnN0IG1ldGhvZCA9IHN0cmVhbS5tZXJnZSA/IG1lcmdlU3RyZWFtIDogc3RyZWFtLnN0cmVhbSA/IG5lc3RlZFN0cmVhbSA6IHN0cmVhbS50eXBlID8gZXZlbnRTdHJlYW0gOiBlcnJvcignSW52YWxpZCBzdHJlYW0gc3BlY2lmaWNhdGlvbjogJyArIHN0cmluZ1ZhbHVlKHN0cmVhbSkpO1xuICByZXR1cm4gbWV0aG9kKHN0cmVhbSwgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBldmVudFNvdXJjZShzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSA9PT0gU2NvcGUkMSA/IFZpZXcgOiBzb3VyY2UgfHwgVmlldztcbn1cblxuZnVuY3Rpb24gbWVyZ2VTdHJlYW0oc3RyZWFtLCBzY29wZSkge1xuICBjb25zdCBsaXN0ID0gc3RyZWFtLm1lcmdlLm1hcChzID0+IHBhcnNlU3RyZWFtKHMsIHNjb3BlKSksXG4gICAgICAgIGVudHJ5ID0gc3RyZWFtUGFyYW1ldGVycyh7XG4gICAgbWVyZ2U6IGxpc3RcbiAgfSwgc3RyZWFtLCBzY29wZSk7XG4gIHJldHVybiBzY29wZS5hZGRTdHJlYW0oZW50cnkpLmlkO1xufVxuXG5mdW5jdGlvbiBuZXN0ZWRTdHJlYW0oc3RyZWFtLCBzY29wZSkge1xuICBjb25zdCBpZCA9IHBhcnNlU3RyZWFtKHN0cmVhbS5zdHJlYW0sIHNjb3BlKSxcbiAgICAgICAgZW50cnkgPSBzdHJlYW1QYXJhbWV0ZXJzKHtcbiAgICBzdHJlYW06IGlkXG4gIH0sIHN0cmVhbSwgc2NvcGUpO1xuICByZXR1cm4gc2NvcGUuYWRkU3RyZWFtKGVudHJ5KS5pZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRTdHJlYW0oc3RyZWFtLCBzY29wZSkge1xuICBsZXQgaWQ7XG5cbiAgaWYgKHN0cmVhbS50eXBlID09PSBUaW1lcikge1xuICAgIGlkID0gc2NvcGUuZXZlbnQoVGltZXIsIHN0cmVhbS50aHJvdHRsZSk7XG4gICAgc3RyZWFtID0ge1xuICAgICAgYmV0d2Vlbjogc3RyZWFtLmJldHdlZW4sXG4gICAgICBmaWx0ZXI6IHN0cmVhbS5maWx0ZXJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGlkID0gc2NvcGUuZXZlbnQoZXZlbnRTb3VyY2Uoc3RyZWFtLnNvdXJjZSksIHN0cmVhbS50eXBlKTtcbiAgfVxuXG4gIGNvbnN0IGVudHJ5ID0gc3RyZWFtUGFyYW1ldGVycyh7XG4gICAgc3RyZWFtOiBpZFxuICB9LCBzdHJlYW0sIHNjb3BlKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGVudHJ5KS5sZW5ndGggPT09IDEgPyBpZCA6IHNjb3BlLmFkZFN0cmVhbShlbnRyeSkuaWQ7XG59XG5cbmZ1bmN0aW9uIHN0cmVhbVBhcmFtZXRlcnMoZW50cnksIHN0cmVhbSwgc2NvcGUpIHtcbiAgbGV0IHBhcmFtID0gc3RyZWFtLmJldHdlZW47XG5cbiAgaWYgKHBhcmFtKSB7XG4gICAgaWYgKHBhcmFtLmxlbmd0aCAhPT0gMikge1xuICAgICAgZXJyb3IoJ1N0cmVhbSBcImJldHdlZW5cIiBwYXJhbWV0ZXIgbXVzdCBoYXZlIDIgZW50cmllczogJyArIHN0cmluZ1ZhbHVlKHN0cmVhbSkpO1xuICAgIH1cblxuICAgIGVudHJ5LmJldHdlZW4gPSBbcGFyc2VTdHJlYW0ocGFyYW1bMF0sIHNjb3BlKSwgcGFyc2VTdHJlYW0ocGFyYW1bMV0sIHNjb3BlKV07XG4gIH1cblxuICBwYXJhbSA9IHN0cmVhbS5maWx0ZXIgPyBbXS5jb25jYXQoc3RyZWFtLmZpbHRlcikgOiBbXTtcblxuICBpZiAoc3RyZWFtLm1hcmt0eXBlIHx8IHN0cmVhbS5tYXJrbmFtZSB8fCBzdHJlYW0ubWFya3JvbGUpIHtcbiAgICAvLyBhZGQgZmlsdGVyIGZvciBtYXJrIHR5cGUsIG5hbWUgYW5kL29yIHJvbGVcbiAgICBwYXJhbS5wdXNoKGZpbHRlck1hcmsoc3RyZWFtLm1hcmt0eXBlLCBzdHJlYW0ubWFya25hbWUsIHN0cmVhbS5tYXJrcm9sZSkpO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5zb3VyY2UgPT09IFNjb3BlJDEpIHtcbiAgICAvLyBhZGQgZmlsdGVyIHRvIGxpbWl0IGV2ZW50cyBmcm9tIHN1Yi1zY29wZSBvbmx5XG4gICAgcGFyYW0ucHVzaCgnaW5TY29wZShldmVudC5pdGVtKScpO1xuICB9XG5cbiAgaWYgKHBhcmFtLmxlbmd0aCkge1xuICAgIGVudHJ5LmZpbHRlciA9IHBhcnNlRXhwcmVzc2lvbignKCcgKyBwYXJhbS5qb2luKCcpJiYoJykgKyAnKScsIHNjb3BlKS4kZXhwcjtcbiAgfVxuXG4gIGlmICgocGFyYW0gPSBzdHJlYW0udGhyb3R0bGUpICE9IG51bGwpIHtcbiAgICBlbnRyeS50aHJvdHRsZSA9ICtwYXJhbTtcbiAgfVxuXG4gIGlmICgocGFyYW0gPSBzdHJlYW0uZGVib3VuY2UpICE9IG51bGwpIHtcbiAgICBlbnRyeS5kZWJvdW5jZSA9ICtwYXJhbTtcbiAgfVxuXG4gIGlmIChzdHJlYW0uY29uc3VtZSkge1xuICAgIGVudHJ5LmNvbnN1bWUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGVudHJ5O1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJNYXJrKHR5cGUsIG5hbWUsIHJvbGUpIHtcbiAgY29uc3QgaXRlbSA9ICdldmVudC5pdGVtJztcbiAgcmV0dXJuIGl0ZW0gKyAodHlwZSAmJiB0eXBlICE9PSAnKicgPyAnJiYnICsgaXRlbSArICcubWFyay5tYXJrdHlwZT09PVxcJycgKyB0eXBlICsgJ1xcJycgOiAnJykgKyAocm9sZSA/ICcmJicgKyBpdGVtICsgJy5tYXJrLnJvbGU9PT1cXCcnICsgcm9sZSArICdcXCcnIDogJycpICsgKG5hbWUgPyAnJiYnICsgaXRlbSArICcubWFyay5uYW1lPT09XFwnJyArIG5hbWUgKyAnXFwnJyA6ICcnKTtcbn1cblxuY29uc3QgT1BfVkFMVUVfRVhQUiA9IHtcbiAgY29kZTogJ18uJHZhbHVlJyxcbiAgYXN0OiB7XG4gICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgIHZhbHVlOiAndmFsdWUnXG4gIH1cbn07XG5mdW5jdGlvbiBwYXJzZVVwZGF0ZSAoc3BlYywgc2NvcGUsIHRhcmdldCkge1xuICBjb25zdCBlbmNvZGUgPSBzcGVjLmVuY29kZSxcbiAgICAgICAgZW50cnkgPSB7XG4gICAgdGFyZ2V0OiB0YXJnZXRcbiAgfTtcbiAgbGV0IGV2ZW50cyA9IHNwZWMuZXZlbnRzLFxuICAgICAgdXBkYXRlID0gc3BlYy51cGRhdGUsXG4gICAgICBzb3VyY2VzID0gW107XG5cbiAgaWYgKCFldmVudHMpIHtcbiAgICBlcnJvcignU2lnbmFsIHVwZGF0ZSBtaXNzaW5nIGV2ZW50cyBzcGVjaWZpY2F0aW9uLicpO1xuICB9IC8vIGludGVycHJldCBhcyBhbiBldmVudCBzZWxlY3RvciBzdHJpbmdcblxuXG4gIGlmIChpc1N0cmluZyhldmVudHMpKSB7XG4gICAgZXZlbnRzID0gcGFyc2VTZWxlY3RvcihldmVudHMsIHNjb3BlLmlzU3Vic2NvcGUoKSA/IFNjb3BlJDEgOiBWaWV3KTtcbiAgfSAvLyBzZXBhcmF0ZSBldmVudCBzdHJlYW1zIGZyb20gc2lnbmFsIHVwZGF0ZXNcblxuXG4gIGV2ZW50cyA9IGFycmF5KGV2ZW50cykuZmlsdGVyKHMgPT4gcy5zaWduYWwgfHwgcy5zY2FsZSA/IChzb3VyY2VzLnB1c2gocyksIDApIDogMSk7IC8vIG1lcmdlIGludGVybmFsIG9wZXJhdG9yIGxpc3RlbmVyc1xuXG4gIGlmIChzb3VyY2VzLmxlbmd0aCA+IDEpIHtcbiAgICBzb3VyY2VzID0gW21lcmdlU291cmNlcyhzb3VyY2VzKV07XG4gIH0gLy8gbWVyZ2UgZXZlbnQgc3RyZWFtcywgaW5jbHVkZSBhcyBzb3VyY2VcblxuXG4gIGlmIChldmVudHMubGVuZ3RoKSB7XG4gICAgc291cmNlcy5wdXNoKGV2ZW50cy5sZW5ndGggPiAxID8ge1xuICAgICAgbWVyZ2U6IGV2ZW50c1xuICAgIH0gOiBldmVudHNbMF0pO1xuICB9XG5cbiAgaWYgKGVuY29kZSAhPSBudWxsKSB7XG4gICAgaWYgKHVwZGF0ZSkgZXJyb3IoJ1NpZ25hbCBlbmNvZGUgYW5kIHVwZGF0ZSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLicpO1xuICAgIHVwZGF0ZSA9ICdlbmNvZGUoaXRlbSgpLCcgKyBzdHJpbmdWYWx1ZShlbmNvZGUpICsgJyknO1xuICB9IC8vIHJlc29sdmUgdXBkYXRlIHZhbHVlXG5cblxuICBlbnRyeS51cGRhdGUgPSBpc1N0cmluZyh1cGRhdGUpID8gcGFyc2VFeHByZXNzaW9uKHVwZGF0ZSwgc2NvcGUpIDogdXBkYXRlLmV4cHIgIT0gbnVsbCA/IHBhcnNlRXhwcmVzc2lvbih1cGRhdGUuZXhwciwgc2NvcGUpIDogdXBkYXRlLnZhbHVlICE9IG51bGwgPyB1cGRhdGUudmFsdWUgOiB1cGRhdGUuc2lnbmFsICE9IG51bGwgPyB7XG4gICAgJGV4cHI6IE9QX1ZBTFVFX0VYUFIsXG4gICAgJHBhcmFtczoge1xuICAgICAgJHZhbHVlOiBzY29wZS5zaWduYWxSZWYodXBkYXRlLnNpZ25hbClcbiAgICB9XG4gIH0gOiBlcnJvcignSW52YWxpZCBzaWduYWwgdXBkYXRlIHNwZWNpZmljYXRpb24uJyk7XG5cbiAgaWYgKHNwZWMuZm9yY2UpIHtcbiAgICBlbnRyeS5vcHRpb25zID0ge1xuICAgICAgZm9yY2U6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKHNvdXJjZSA9PiBzY29wZS5hZGRVcGRhdGUoZXh0ZW5kKHN0cmVhbVNvdXJjZShzb3VyY2UsIHNjb3BlKSwgZW50cnkpKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmVhbVNvdXJjZShzdHJlYW0sIHNjb3BlKSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlOiBzdHJlYW0uc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKHN0cmVhbS5zaWduYWwpIDogc3RyZWFtLnNjYWxlID8gc2NvcGUuc2NhbGVSZWYoc3RyZWFtLnNjYWxlKSA6IHBhcnNlU3RyZWFtKHN0cmVhbSwgc2NvcGUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlU291cmNlcyhzb3VyY2VzKSB7XG4gIHJldHVybiB7XG4gICAgc2lnbmFsOiAnWycgKyBzb3VyY2VzLm1hcChzID0+IHMuc2NhbGUgPyAnc2NhbGUoXCInICsgcy5zY2FsZSArICdcIiknIDogcy5zaWduYWwpICsgJ10nXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2lnbmFsVXBkYXRlcyAoc2lnbmFsLCBzY29wZSkge1xuICBjb25zdCBvcCA9IHNjb3BlLmdldFNpZ25hbChzaWduYWwubmFtZSk7XG4gIGxldCBleHByID0gc2lnbmFsLnVwZGF0ZTtcblxuICBpZiAoc2lnbmFsLmluaXQpIHtcbiAgICBpZiAoZXhwcikge1xuICAgICAgZXJyb3IoJ1NpZ25hbHMgY2FuIG5vdCBpbmNsdWRlIGJvdGggaW5pdCBhbmQgdXBkYXRlIGV4cHJlc3Npb25zLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHByID0gc2lnbmFsLmluaXQ7XG4gICAgICBvcC5pbml0b25seSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHIpIHtcbiAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKGV4cHIsIHNjb3BlKTtcbiAgICBvcC51cGRhdGUgPSBleHByLiRleHByO1xuICAgIG9wLnBhcmFtcyA9IGV4cHIuJHBhcmFtcztcbiAgfVxuXG4gIGlmIChzaWduYWwub24pIHtcbiAgICBzaWduYWwub24uZm9yRWFjaChfID0+IHBhcnNlVXBkYXRlKF8sIHNjb3BlLCBvcC5pZCkpO1xuICB9XG59XG5cbmNvbnN0IHRyYW5zZm9ybSA9IG5hbWUgPT4gKHBhcmFtcywgdmFsdWUsIHBhcmVudCkgPT4gZW50cnkobmFtZSwgdmFsdWUsIHBhcmFtcyB8fCB1bmRlZmluZWQsIHBhcmVudCk7XG5cbmNvbnN0IEFnZ3JlZ2F0ZSA9IHRyYW5zZm9ybSgnYWdncmVnYXRlJyk7XG5jb25zdCBBeGlzVGlja3MgPSB0cmFuc2Zvcm0oJ2F4aXN0aWNrcycpO1xuY29uc3QgQm91bmQgPSB0cmFuc2Zvcm0oJ2JvdW5kJyk7XG5jb25zdCBDb2xsZWN0ID0gdHJhbnNmb3JtKCdjb2xsZWN0Jyk7XG5jb25zdCBDb21wYXJlID0gdHJhbnNmb3JtKCdjb21wYXJlJyk7XG5jb25zdCBEYXRhSm9pbiA9IHRyYW5zZm9ybSgnZGF0YWpvaW4nKTtcbmNvbnN0IEVuY29kZSA9IHRyYW5zZm9ybSgnZW5jb2RlJyk7XG5jb25zdCBFeHByZXNzaW9uID0gdHJhbnNmb3JtKCdleHByZXNzaW9uJyk7XG5jb25zdCBGYWNldCA9IHRyYW5zZm9ybSgnZmFjZXQnKTtcbmNvbnN0IEZpZWxkID0gdHJhbnNmb3JtKCdmaWVsZCcpO1xuY29uc3QgS2V5ID0gdHJhbnNmb3JtKCdrZXknKTtcbmNvbnN0IExlZ2VuZEVudHJpZXMgPSB0cmFuc2Zvcm0oJ2xlZ2VuZGVudHJpZXMnKTtcbmNvbnN0IExvYWQgPSB0cmFuc2Zvcm0oJ2xvYWQnKTtcbmNvbnN0IE1hcmsgPSB0cmFuc2Zvcm0oJ21hcmsnKTtcbmNvbnN0IE11bHRpRXh0ZW50ID0gdHJhbnNmb3JtKCdtdWx0aWV4dGVudCcpO1xuY29uc3QgTXVsdGlWYWx1ZXMgPSB0cmFuc2Zvcm0oJ211bHRpdmFsdWVzJyk7XG5jb25zdCBPdmVybGFwID0gdHJhbnNmb3JtKCdvdmVybGFwJyk7XG5jb25zdCBQYXJhbXMgPSB0cmFuc2Zvcm0oJ3BhcmFtcycpO1xuY29uc3QgUHJlRmFjZXQgPSB0cmFuc2Zvcm0oJ3ByZWZhY2V0Jyk7XG5jb25zdCBQcm9qZWN0aW9uID0gdHJhbnNmb3JtKCdwcm9qZWN0aW9uJyk7XG5jb25zdCBQcm94eSA9IHRyYW5zZm9ybSgncHJveHknKTtcbmNvbnN0IFJlbGF5ID0gdHJhbnNmb3JtKCdyZWxheScpO1xuY29uc3QgUmVuZGVyID0gdHJhbnNmb3JtKCdyZW5kZXInKTtcbmNvbnN0IFNjYWxlID0gdHJhbnNmb3JtKCdzY2FsZScpO1xuY29uc3QgU2lldmUgPSB0cmFuc2Zvcm0oJ3NpZXZlJyk7XG5jb25zdCBTb3J0SXRlbXMgPSB0cmFuc2Zvcm0oJ3NvcnRpdGVtcycpO1xuY29uc3QgVmlld0xheW91dCA9IHRyYW5zZm9ybSgndmlld2xheW91dCcpO1xuY29uc3QgVmFsdWVzID0gdHJhbnNmb3JtKCd2YWx1ZXMnKTtcblxubGV0IEZJRUxEX1JFRl9JRCA9IDA7XG5jb25zdCBNVUxUSURPTUFJTl9TT1JUX09QUyA9IHtcbiAgbWluOiAnbWluJyxcbiAgbWF4OiAnbWF4JyxcbiAgY291bnQ6ICdzdW0nXG59O1xuZnVuY3Rpb24gaW5pdFNjYWxlKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IHR5cGUgPSBzcGVjLnR5cGUgfHwgJ2xpbmVhcic7XG5cbiAgaWYgKCFpc1ZhbGlkU2NhbGVUeXBlKHR5cGUpKSB7XG4gICAgZXJyb3IoJ1VucmVjb2duaXplZCBzY2FsZSB0eXBlOiAnICsgc3RyaW5nVmFsdWUodHlwZSkpO1xuICB9XG5cbiAgc2NvcGUuYWRkU2NhbGUoc3BlYy5uYW1lLCB7XG4gICAgdHlwZSxcbiAgICBkb21haW46IHVuZGVmaW5lZFxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlU2NhbGUoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgcGFyYW1zID0gc2NvcGUuZ2V0U2NhbGUoc3BlYy5uYW1lKS5wYXJhbXM7XG4gIGxldCBrZXk7XG4gIHBhcmFtcy5kb21haW4gPSBwYXJzZVNjYWxlRG9tYWluKHNwZWMuZG9tYWluLCBzcGVjLCBzY29wZSk7XG5cbiAgaWYgKHNwZWMucmFuZ2UgIT0gbnVsbCkge1xuICAgIHBhcmFtcy5yYW5nZSA9IHBhcnNlU2NhbGVSYW5nZShzcGVjLCBzY29wZSwgcGFyYW1zKTtcbiAgfVxuXG4gIGlmIChzcGVjLmludGVycG9sYXRlICE9IG51bGwpIHtcbiAgICBwYXJzZVNjYWxlSW50ZXJwb2xhdGUoc3BlYy5pbnRlcnBvbGF0ZSwgcGFyYW1zKTtcbiAgfVxuXG4gIGlmIChzcGVjLm5pY2UgIT0gbnVsbCkge1xuICAgIHBhcmFtcy5uaWNlID0gcGFyc2VTY2FsZU5pY2Uoc3BlYy5uaWNlKTtcbiAgfVxuXG4gIGlmIChzcGVjLmJpbnMgIT0gbnVsbCkge1xuICAgIHBhcmFtcy5iaW5zID0gcGFyc2VTY2FsZUJpbnMoc3BlYy5iaW5zLCBzY29wZSk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBzcGVjKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHBhcmFtcywga2V5KSB8fCBrZXkgPT09ICduYW1lJykgY29udGludWU7XG4gICAgcGFyYW1zW2tleV0gPSBwYXJzZUxpdGVyYWwoc3BlY1trZXldLCBzY29wZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMaXRlcmFsKHYsIHNjb3BlKSB7XG4gIHJldHVybiAhaXNPYmplY3QodikgPyB2IDogdi5zaWduYWwgPyBzY29wZS5zaWduYWxSZWYodi5zaWduYWwpIDogZXJyb3IoJ1Vuc3VwcG9ydGVkIG9iamVjdDogJyArIHN0cmluZ1ZhbHVlKHYpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBcnJheSh2LCBzY29wZSkge1xuICByZXR1cm4gdi5zaWduYWwgPyBzY29wZS5zaWduYWxSZWYodi5zaWduYWwpIDogdi5tYXAodiA9PiBwYXJzZUxpdGVyYWwodiwgc2NvcGUpKTtcbn1cblxuZnVuY3Rpb24gZGF0YUxvb2t1cEVycm9yKG5hbWUpIHtcbiAgZXJyb3IoJ0NhbiBub3QgZmluZCBkYXRhIHNldDogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbn0gLy8gLS0gU0NBTEUgRE9NQUlOIC0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlRG9tYWluKGRvbWFpbiwgc3BlYywgc2NvcGUpIHtcbiAgaWYgKCFkb21haW4pIHtcbiAgICBpZiAoc3BlYy5kb21haW5NaW4gIT0gbnVsbCB8fCBzcGVjLmRvbWFpbk1heCAhPSBudWxsKSB7XG4gICAgICBlcnJvcignTm8gc2NhbGUgZG9tYWluIGRlZmluZWQgZm9yIGRvbWFpbk1pbi9kb21haW5NYXggdG8gb3ZlcnJpZGUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuOyAvLyBkZWZhdWx0IGRvbWFpblxuICB9XG5cbiAgcmV0dXJuIGRvbWFpbi5zaWduYWwgPyBzY29wZS5zaWduYWxSZWYoZG9tYWluLnNpZ25hbCkgOiAoaXNBcnJheShkb21haW4pID8gZXhwbGljaXREb21haW4gOiBkb21haW4uZmllbGRzID8gbXVsdGlwbGVEb21haW4gOiBzaW5ndWxhckRvbWFpbikoZG9tYWluLCBzcGVjLCBzY29wZSk7XG59XG5cbmZ1bmN0aW9uIGV4cGxpY2l0RG9tYWluKGRvbWFpbiwgc3BlYywgc2NvcGUpIHtcbiAgcmV0dXJuIGRvbWFpbi5tYXAodiA9PiBwYXJzZUxpdGVyYWwodiwgc2NvcGUpKTtcbn1cblxuZnVuY3Rpb24gc2luZ3VsYXJEb21haW4oZG9tYWluLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCBkYXRhID0gc2NvcGUuZ2V0RGF0YShkb21haW4uZGF0YSk7XG4gIGlmICghZGF0YSkgZGF0YUxvb2t1cEVycm9yKGRvbWFpbi5kYXRhKTtcbiAgcmV0dXJuIGlzRGlzY3JldGUoc3BlYy50eXBlKSA/IGRhdGEudmFsdWVzUmVmKHNjb3BlLCBkb21haW4uZmllbGQsIHBhcnNlU29ydChkb21haW4uc29ydCwgZmFsc2UpKSA6IGlzUXVhbnRpbGUoc3BlYy50eXBlKSA/IGRhdGEuZG9tYWluUmVmKHNjb3BlLCBkb21haW4uZmllbGQpIDogZGF0YS5leHRlbnRSZWYoc2NvcGUsIGRvbWFpbi5maWVsZCk7XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlRG9tYWluKGRvbWFpbiwgc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgZGF0YSA9IGRvbWFpbi5kYXRhLFxuICAgICAgICBmaWVsZHMgPSBkb21haW4uZmllbGRzLnJlZHVjZSgoZG9tLCBkKSA9PiB7XG4gICAgZCA9IGlzU3RyaW5nKGQpID8ge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGZpZWxkOiBkXG4gICAgfSA6IGlzQXJyYXkoZCkgfHwgZC5zaWduYWwgPyBmaWVsZFJlZihkLCBzY29wZSkgOiBkO1xuICAgIGRvbS5wdXNoKGQpO1xuICAgIHJldHVybiBkb207XG4gIH0sIFtdKTtcbiAgcmV0dXJuIChpc0Rpc2NyZXRlKHNwZWMudHlwZSkgPyBvcmRpbmFsTXVsdGlwbGVEb21haW4gOiBpc1F1YW50aWxlKHNwZWMudHlwZSkgPyBxdWFudGlsZU11bHRpcGxlRG9tYWluIDogbnVtZXJpY011bHRpcGxlRG9tYWluKShkb21haW4sIHNjb3BlLCBmaWVsZHMpO1xufVxuXG5mdW5jdGlvbiBmaWVsZFJlZihkYXRhLCBzY29wZSkge1xuICBjb25zdCBuYW1lID0gJ186dmVnYTpfJyArIEZJRUxEX1JFRl9JRCsrLFxuICAgICAgICBjb2xsID0gQ29sbGVjdCh7fSk7XG5cbiAgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBjb2xsLnZhbHVlID0ge1xuICAgICAgJGluZ2VzdDogZGF0YVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZGF0YS5zaWduYWwpIHtcbiAgICBjb25zdCBjb2RlID0gJ3NldGRhdGEoJyArIHN0cmluZ1ZhbHVlKG5hbWUpICsgJywnICsgZGF0YS5zaWduYWwgKyAnKSc7XG4gICAgY29sbC5wYXJhbXMuaW5wdXQgPSBzY29wZS5zaWduYWxSZWYoY29kZSk7XG4gIH1cblxuICBzY29wZS5hZGREYXRhUGlwZWxpbmUobmFtZSwgW2NvbGwsIFNpZXZlKHt9KV0pO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IG5hbWUsXG4gICAgZmllbGQ6ICdkYXRhJ1xuICB9O1xufVxuXG5mdW5jdGlvbiBvcmRpbmFsTXVsdGlwbGVEb21haW4oZG9tYWluLCBzY29wZSwgZmllbGRzKSB7XG4gIGNvbnN0IHNvcnQgPSBwYXJzZVNvcnQoZG9tYWluLnNvcnQsIHRydWUpO1xuICBsZXQgYSwgdjsgLy8gZ2V0IHZhbHVlIGNvdW50cyBmb3IgZWFjaCBkb21haW4gZmllbGRcblxuICBjb25zdCBjb3VudHMgPSBmaWVsZHMubWFwKGYgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBzY29wZS5nZXREYXRhKGYuZGF0YSk7XG4gICAgaWYgKCFkYXRhKSBkYXRhTG9va3VwRXJyb3IoZi5kYXRhKTtcbiAgICByZXR1cm4gZGF0YS5jb3VudHNSZWYoc2NvcGUsIGYuZmllbGQsIHNvcnQpO1xuICB9KTsgLy8gYWdncmVnYXRlIHRoZSByZXN1bHRzIGZyb20gZWFjaCBkb21haW4gZmllbGRcblxuICBjb25zdCBwID0ge1xuICAgIGdyb3VwYnk6IGtleUZpZWxkUmVmLFxuICAgIHB1bHNlOiBjb3VudHNcbiAgfTtcblxuICBpZiAoc29ydCkge1xuICAgIGEgPSBzb3J0Lm9wIHx8ICdjb3VudCc7XG4gICAgdiA9IHNvcnQuZmllbGQgPyBhZ2dyRmllbGQoYSwgc29ydC5maWVsZCkgOiAnY291bnQnO1xuICAgIHAub3BzID0gW01VTFRJRE9NQUlOX1NPUlRfT1BTW2FdXTtcbiAgICBwLmZpZWxkcyA9IFtzY29wZS5maWVsZFJlZih2KV07XG4gICAgcC5hcyA9IFt2XTtcbiAgfVxuXG4gIGEgPSBzY29wZS5hZGQoQWdncmVnYXRlKHApKTsgLy8gY29sbGVjdCBhZ2dyZWdhdGUgb3V0cHV0XG5cbiAgY29uc3QgYyA9IHNjb3BlLmFkZChDb2xsZWN0KHtcbiAgICBwdWxzZTogcmVmKGEpXG4gIH0pKTsgLy8gZXh0cmFjdCB2YWx1ZXMgZm9yIGNvbWJpbmVkIGRvbWFpblxuXG4gIHYgPSBzY29wZS5hZGQoVmFsdWVzKHtcbiAgICBmaWVsZDoga2V5RmllbGRSZWYsXG4gICAgc29ydDogc2NvcGUuc29ydFJlZihzb3J0KSxcbiAgICBwdWxzZTogcmVmKGMpXG4gIH0pKTtcbiAgcmV0dXJuIHJlZih2KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTb3J0KHNvcnQsIG11bHRpZG9tYWluKSB7XG4gIGlmIChzb3J0KSB7XG4gICAgaWYgKCFzb3J0LmZpZWxkICYmICFzb3J0Lm9wKSB7XG4gICAgICBpZiAoaXNPYmplY3Qoc29ydCkpIHNvcnQuZmllbGQgPSAna2V5JztlbHNlIHNvcnQgPSB7XG4gICAgICAgIGZpZWxkOiAna2V5J1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFzb3J0LmZpZWxkICYmIHNvcnQub3AgIT09ICdjb3VudCcpIHtcbiAgICAgIGVycm9yKCdObyBmaWVsZCBwcm92aWRlZCBmb3Igc29ydCBhZ2dyZWdhdGUgb3A6ICcgKyBzb3J0Lm9wKTtcbiAgICB9IGVsc2UgaWYgKG11bHRpZG9tYWluICYmIHNvcnQuZmllbGQpIHtcbiAgICAgIGlmIChzb3J0Lm9wICYmICFNVUxUSURPTUFJTl9TT1JUX09QU1tzb3J0Lm9wXSkge1xuICAgICAgICBlcnJvcignTXVsdGlwbGUgZG9tYWluIHNjYWxlcyBjYW4gbm90IGJlIHNvcnRlZCB1c2luZyAnICsgc29ydC5vcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvcnQ7XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlTXVsdGlwbGVEb21haW4oZG9tYWluLCBzY29wZSwgZmllbGRzKSB7XG4gIC8vIGdldCB2YWx1ZSBhcnJheXMgZm9yIGVhY2ggZG9tYWluIGZpZWxkXG4gIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoZiA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHNjb3BlLmdldERhdGEoZi5kYXRhKTtcbiAgICBpZiAoIWRhdGEpIGRhdGFMb29rdXBFcnJvcihmLmRhdGEpO1xuICAgIHJldHVybiBkYXRhLmRvbWFpblJlZihzY29wZSwgZi5maWVsZCk7XG4gIH0pOyAvLyBjb21iaW5lIHZhbHVlIGFycmF5c1xuXG4gIHJldHVybiByZWYoc2NvcGUuYWRkKE11bHRpVmFsdWVzKHtcbiAgICB2YWx1ZXM6IHZhbHVlc1xuICB9KSkpO1xufVxuXG5mdW5jdGlvbiBudW1lcmljTXVsdGlwbGVEb21haW4oZG9tYWluLCBzY29wZSwgZmllbGRzKSB7XG4gIC8vIGdldCBleHRlbnRzIGZvciBlYWNoIGRvbWFpbiBmaWVsZFxuICBjb25zdCBleHRlbnRzID0gZmllbGRzLm1hcChmID0+IHtcbiAgICBjb25zdCBkYXRhID0gc2NvcGUuZ2V0RGF0YShmLmRhdGEpO1xuICAgIGlmICghZGF0YSkgZGF0YUxvb2t1cEVycm9yKGYuZGF0YSk7XG4gICAgcmV0dXJuIGRhdGEuZXh0ZW50UmVmKHNjb3BlLCBmLmZpZWxkKTtcbiAgfSk7IC8vIGNvbWJpbmUgZXh0ZW50c1xuXG4gIHJldHVybiByZWYoc2NvcGUuYWRkKE11bHRpRXh0ZW50KHtcbiAgICBleHRlbnRzOiBleHRlbnRzXG4gIH0pKSk7XG59IC8vIC0tIFNDQUxFIEJJTlMgLS0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlQmlucyh2LCBzY29wZSkge1xuICByZXR1cm4gdi5zaWduYWwgfHwgaXNBcnJheSh2KSA/IHBhcnNlQXJyYXkodiwgc2NvcGUpIDogc2NvcGUub2JqZWN0UHJvcGVydHkodik7XG59IC8vIC0tIFNDQUxFIE5JQ0UgLS0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlTmljZShuaWNlKSB7XG4gIHJldHVybiBpc09iamVjdChuaWNlKSA/IHtcbiAgICBpbnRlcnZhbDogcGFyc2VMaXRlcmFsKG5pY2UuaW50ZXJ2YWwpLFxuICAgIHN0ZXA6IHBhcnNlTGl0ZXJhbChuaWNlLnN0ZXApXG4gIH0gOiBwYXJzZUxpdGVyYWwobmljZSk7XG59IC8vIC0tIFNDQUxFIElOVEVSUE9MQVRJT04gLS0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlSW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUsIHBhcmFtcykge1xuICBwYXJhbXMuaW50ZXJwb2xhdGUgPSBwYXJzZUxpdGVyYWwoaW50ZXJwb2xhdGUudHlwZSB8fCBpbnRlcnBvbGF0ZSk7XG5cbiAgaWYgKGludGVycG9sYXRlLmdhbW1hICE9IG51bGwpIHtcbiAgICBwYXJhbXMuaW50ZXJwb2xhdGVHYW1tYSA9IHBhcnNlTGl0ZXJhbChpbnRlcnBvbGF0ZS5nYW1tYSk7XG4gIH1cbn0gLy8gLS0gU0NBTEUgUkFOR0UgLS0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlUmFuZ2Uoc3BlYywgc2NvcGUsIHBhcmFtcykge1xuICBjb25zdCBjb25maWcgPSBzY29wZS5jb25maWcucmFuZ2U7XG4gIGxldCByYW5nZSA9IHNwZWMucmFuZ2U7XG5cbiAgaWYgKHJhbmdlLnNpZ25hbCkge1xuICAgIHJldHVybiBzY29wZS5zaWduYWxSZWYocmFuZ2Uuc2lnbmFsKTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhyYW5nZSkpIHtcbiAgICBpZiAoY29uZmlnICYmIGhhc093blByb3BlcnR5KGNvbmZpZywgcmFuZ2UpKSB7XG4gICAgICBzcGVjID0gZXh0ZW5kKHt9LCBzcGVjLCB7XG4gICAgICAgIHJhbmdlOiBjb25maWdbcmFuZ2VdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJzZVNjYWxlUmFuZ2Uoc3BlYywgc2NvcGUsIHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gJ3dpZHRoJykge1xuICAgICAgcmFuZ2UgPSBbMCwge1xuICAgICAgICBzaWduYWw6ICd3aWR0aCdcbiAgICAgIH1dO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09ICdoZWlnaHQnKSB7XG4gICAgICByYW5nZSA9IGlzRGlzY3JldGUoc3BlYy50eXBlKSA/IFswLCB7XG4gICAgICAgIHNpZ25hbDogJ2hlaWdodCdcbiAgICAgIH1dIDogW3tcbiAgICAgICAgc2lnbmFsOiAnaGVpZ2h0J1xuICAgICAgfSwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdVbnJlY29nbml6ZWQgc2NhbGUgcmFuZ2UgdmFsdWU6ICcgKyBzdHJpbmdWYWx1ZShyYW5nZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyYW5nZS5zY2hlbWUpIHtcbiAgICBwYXJhbXMuc2NoZW1lID0gaXNBcnJheShyYW5nZS5zY2hlbWUpID8gcGFyc2VBcnJheShyYW5nZS5zY2hlbWUsIHNjb3BlKSA6IHBhcnNlTGl0ZXJhbChyYW5nZS5zY2hlbWUsIHNjb3BlKTtcbiAgICBpZiAocmFuZ2UuZXh0ZW50KSBwYXJhbXMuc2NoZW1lRXh0ZW50ID0gcGFyc2VBcnJheShyYW5nZS5leHRlbnQsIHNjb3BlKTtcbiAgICBpZiAocmFuZ2UuY291bnQpIHBhcmFtcy5zY2hlbWVDb3VudCA9IHBhcnNlTGl0ZXJhbChyYW5nZS5jb3VudCwgc2NvcGUpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChyYW5nZS5zdGVwKSB7XG4gICAgcGFyYW1zLnJhbmdlU3RlcCA9IHBhcnNlTGl0ZXJhbChyYW5nZS5zdGVwLCBzY29wZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlzRGlzY3JldGUoc3BlYy50eXBlKSAmJiAhaXNBcnJheShyYW5nZSkpIHtcbiAgICByZXR1cm4gcGFyc2VTY2FsZURvbWFpbihyYW5nZSwgc3BlYywgc2NvcGUpO1xuICB9IGVsc2UgaWYgKCFpc0FycmF5KHJhbmdlKSkge1xuICAgIGVycm9yKCdVbnN1cHBvcnRlZCByYW5nZSB0eXBlOiAnICsgc3RyaW5nVmFsdWUocmFuZ2UpKTtcbiAgfVxuXG4gIHJldHVybiByYW5nZS5tYXAodiA9PiAoaXNBcnJheSh2KSA/IHBhcnNlQXJyYXkgOiBwYXJzZUxpdGVyYWwpKHYsIHNjb3BlKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUHJvamVjdGlvbiAocHJvaiwgc2NvcGUpIHtcbiAgY29uc3QgY29uZmlnID0gc2NvcGUuY29uZmlnLnByb2plY3Rpb24gfHwge30sXG4gICAgICAgIHBhcmFtcyA9IHt9O1xuXG4gIGZvciAoY29uc3QgbmFtZSBpbiBwcm9qKSB7XG4gICAgaWYgKG5hbWUgPT09ICduYW1lJykgY29udGludWU7XG4gICAgcGFyYW1zW25hbWVdID0gcGFyc2VQYXJhbWV0ZXIkMShwcm9qW25hbWVdLCBuYW1lLCBzY29wZSk7XG4gIH0gLy8gYXBwbHkgcHJvamVjdGlvbiBkZWZhdWx0cyBmcm9tIGNvbmZpZ1xuXG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGNvbmZpZykge1xuICAgIGlmIChwYXJhbXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgcGFyYW1zW25hbWVdID0gcGFyc2VQYXJhbWV0ZXIkMShjb25maWdbbmFtZV0sIG5hbWUsIHNjb3BlKTtcbiAgICB9XG4gIH1cblxuICBzY29wZS5hZGRQcm9qZWN0aW9uKHByb2oubmFtZSwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIkMShfLCBuYW1lLCBzY29wZSkge1xuICByZXR1cm4gaXNBcnJheShfKSA/IF8ubWFwKF8gPT4gcGFyc2VQYXJhbWV0ZXIkMShfLCBuYW1lLCBzY29wZSkpIDogIWlzT2JqZWN0KF8pID8gXyA6IF8uc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKF8uc2lnbmFsKSA6IG5hbWUgPT09ICdmaXQnID8gXyA6IGVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXIgb2JqZWN0OiAnICsgc3RyaW5nVmFsdWUoXykpO1xufVxuXG5jb25zdCBUb3AgPSAndG9wJztcbmNvbnN0IExlZnQgPSAnbGVmdCc7XG5jb25zdCBSaWdodCA9ICdyaWdodCc7XG5jb25zdCBCb3R0b20gPSAnYm90dG9tJztcbmNvbnN0IENlbnRlciA9ICdjZW50ZXInO1xuY29uc3QgVmVydGljYWwgPSAndmVydGljYWwnO1xuY29uc3QgU3RhcnQgPSAnc3RhcnQnO1xuY29uc3QgTWlkZGxlID0gJ21pZGRsZSc7XG5jb25zdCBFbmQgPSAnZW5kJztcbmNvbnN0IEluZGV4ID0gJ2luZGV4JztcbmNvbnN0IExhYmVsID0gJ2xhYmVsJztcbmNvbnN0IE9mZnNldCA9ICdvZmZzZXQnO1xuY29uc3QgUGVyYyA9ICdwZXJjJztcbmNvbnN0IFBlcmMyID0gJ3BlcmMyJztcbmNvbnN0IFZhbHVlID0gJ3ZhbHVlJztcbmNvbnN0IEd1aWRlTGFiZWxTdHlsZSA9ICdndWlkZS1sYWJlbCc7XG5jb25zdCBHdWlkZVRpdGxlU3R5bGUgPSAnZ3VpZGUtdGl0bGUnO1xuY29uc3QgR3JvdXBUaXRsZVN0eWxlID0gJ2dyb3VwLXRpdGxlJztcbmNvbnN0IEdyb3VwU3VidGl0bGVTdHlsZSA9ICdncm91cC1zdWJ0aXRsZSc7XG5jb25zdCBTeW1ib2xzID0gJ3N5bWJvbCc7XG5jb25zdCBHcmFkaWVudCA9ICdncmFkaWVudCc7XG5jb25zdCBEaXNjcmV0ZSA9ICdkaXNjcmV0ZSc7XG5jb25zdCBTaXplID0gJ3NpemUnO1xuY29uc3QgU2hhcGUgPSAnc2hhcGUnO1xuY29uc3QgRmlsbCA9ICdmaWxsJztcbmNvbnN0IFN0cm9rZSA9ICdzdHJva2UnO1xuY29uc3QgU3Ryb2tlV2lkdGggPSAnc3Ryb2tlV2lkdGgnO1xuY29uc3QgU3Ryb2tlRGFzaCA9ICdzdHJva2VEYXNoJztcbmNvbnN0IE9wYWNpdHkgPSAnb3BhY2l0eSc7IC8vIEVuY29kaW5nIGNoYW5uZWxzIHN1cHBvcnRlZCBieSBsZWdlbmRzXG4vLyBJbiBwcmlvcml0eSBvcmRlciBvZiAnY2Fub25pY2FsJyBzY2FsZVxuXG5jb25zdCBMZWdlbmRTY2FsZXMgPSBbU2l6ZSwgU2hhcGUsIEZpbGwsIFN0cm9rZSwgU3Ryb2tlV2lkdGgsIFN0cm9rZURhc2gsIE9wYWNpdHldO1xuY29uc3QgU2tpcCA9IHtcbiAgbmFtZTogMSxcbiAgc3R5bGU6IDEsXG4gIGludGVyYWN0aXZlOiAxXG59O1xuY29uc3QgemVybyA9IHtcbiAgdmFsdWU6IDBcbn07XG5jb25zdCBvbmUgPSB7XG4gIHZhbHVlOiAxXG59O1xuXG5jb25zdCBHcm91cE1hcmsgPSAnZ3JvdXAnO1xuY29uc3QgUmVjdE1hcmsgPSAncmVjdCc7XG5jb25zdCBSdWxlTWFyayA9ICdydWxlJztcbmNvbnN0IFN5bWJvbE1hcmsgPSAnc3ltYm9sJztcbmNvbnN0IFRleHRNYXJrID0gJ3RleHQnO1xuXG5mdW5jdGlvbiBndWlkZUdyb3VwIChtYXJrKSB7XG4gIG1hcmsudHlwZSA9IEdyb3VwTWFyaztcbiAgbWFyay5pbnRlcmFjdGl2ZSA9IG1hcmsuaW50ZXJhY3RpdmUgfHwgZmFsc2U7XG4gIHJldHVybiBtYXJrO1xufVxuXG5mdW5jdGlvbiBsb29rdXAoc3BlYywgY29uZmlnKSB7XG4gIGNvbnN0IF8gPSAobmFtZSwgZGZsdCkgPT4gdmFsdWUoc3BlY1tuYW1lXSwgdmFsdWUoY29uZmlnW25hbWVdLCBkZmx0KSk7XG5cbiAgXy5pc1ZlcnRpY2FsID0gcyA9PiBWZXJ0aWNhbCA9PT0gdmFsdWUoc3BlYy5kaXJlY3Rpb24sIGNvbmZpZy5kaXJlY3Rpb24gfHwgKHMgPyBjb25maWcuc3ltYm9sRGlyZWN0aW9uIDogY29uZmlnLmdyYWRpZW50RGlyZWN0aW9uKSk7XG5cbiAgXy5ncmFkaWVudExlbmd0aCA9ICgpID0+IHZhbHVlKHNwZWMuZ3JhZGllbnRMZW5ndGgsIGNvbmZpZy5ncmFkaWVudExlbmd0aCB8fCBjb25maWcuZ3JhZGllbnRXaWR0aCk7XG5cbiAgXy5ncmFkaWVudFRoaWNrbmVzcyA9ICgpID0+IHZhbHVlKHNwZWMuZ3JhZGllbnRUaGlja25lc3MsIGNvbmZpZy5ncmFkaWVudFRoaWNrbmVzcyB8fCBjb25maWcuZ3JhZGllbnRIZWlnaHQpO1xuXG4gIF8uZW50cnlDb2x1bW5zID0gKCkgPT4gdmFsdWUoc3BlYy5jb2x1bW5zLCB2YWx1ZShjb25maWcuY29sdW1ucywgK18uaXNWZXJ0aWNhbCh0cnVlKSkpO1xuXG4gIHJldHVybiBfO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RpbmcobmFtZSwgZW5jb2RlKSB7XG4gIGNvbnN0IHYgPSBlbmNvZGUgJiYgKGVuY29kZS51cGRhdGUgJiYgZW5jb2RlLnVwZGF0ZVtuYW1lXSB8fCBlbmNvZGUuZW50ZXIgJiYgZW5jb2RlLmVudGVyW25hbWVdKTtcbiAgcmV0dXJuIHYgJiYgdi5zaWduYWwgPyB2IDogdiA/IHYudmFsdWUgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U3R5bGUobmFtZSwgc2NvcGUsIHN0eWxlKSB7XG4gIGNvbnN0IHMgPSBzY29wZS5jb25maWcuc3R5bGVbc3R5bGVdO1xuICByZXR1cm4gcyAmJiBzW25hbWVdO1xufVxuZnVuY3Rpb24gYW5jaG9yRXhwcihzLCBlLCBtKSB7XG4gIHJldHVybiBgaXRlbS5hbmNob3IgPT09ICcke1N0YXJ0fScgPyAke3N9IDogaXRlbS5hbmNob3IgPT09ICcke0VuZH0nID8gJHtlfSA6ICR7bX1gO1xufVxuY29uc3QgYWxpZ25FeHByJDEgPSBhbmNob3JFeHByKHN0cmluZ1ZhbHVlKExlZnQpLCBzdHJpbmdWYWx1ZShSaWdodCksIHN0cmluZ1ZhbHVlKENlbnRlcikpO1xuZnVuY3Rpb24gdGlja0JhbmQoXykge1xuICBjb25zdCB2ID0gXygndGlja0JhbmQnKTtcblxuICBsZXQgb2Zmc2V0ID0gXygndGlja09mZnNldCcpLFxuICAgICAgYmFuZCxcbiAgICAgIGV4dHJhO1xuXG4gIGlmICghdikge1xuICAgIC8vIGlmIG5vIHRpY2sgYmFuZCBlbnRyeSwgZmFsbCBiYWNrIG9uIG90aGVyIHByb3BlcnRpZXNcbiAgICBiYW5kID0gXygnYmFuZFBvc2l0aW9uJyk7XG4gICAgZXh0cmEgPSBfKCd0aWNrRXh0cmEnKTtcbiAgfSBlbHNlIGlmICh2LnNpZ25hbCkge1xuICAgIC8vIGlmIHNpZ25hbCwgYXVnbWVudCBjb2RlIHRvIGludGVycHJldCB2YWx1ZXNcbiAgICBiYW5kID0ge1xuICAgICAgc2lnbmFsOiBgKCR7di5zaWduYWx9KSA9PT0gJ2V4dGVudCcgPyAxIDogMC41YFxuICAgIH07XG4gICAgZXh0cmEgPSB7XG4gICAgICBzaWduYWw6IGAoJHt2LnNpZ25hbH0pID09PSAnZXh0ZW50J2BcbiAgICB9O1xuXG4gICAgaWYgKCFpc09iamVjdChvZmZzZXQpKSB7XG4gICAgICBvZmZzZXQgPSB7XG4gICAgICAgIHNpZ25hbDogYCgke3Yuc2lnbmFsfSkgPT09ICdleHRlbnQnID8gMCA6ICR7b2Zmc2V0fWBcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHYgPT09ICdleHRlbnQnKSB7XG4gICAgLy8gaWYgY29uc3RhbnQsIHNpbXBseSBzZXQgdmFsdWVzXG4gICAgYmFuZCA9IDE7XG4gICAgZXh0cmEgPSB0cnVlO1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgYmFuZCA9IDAuNTtcbiAgICBleHRyYSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHRyYSxcbiAgICBiYW5kLFxuICAgIG9mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gZXh0ZW5kT2Zmc2V0KHZhbHVlLCBvZmZzZXQpIHtcbiAgcmV0dXJuICFvZmZzZXQgPyB2YWx1ZSA6ICF2YWx1ZSA/IG9mZnNldCA6ICFpc09iamVjdCh2YWx1ZSkgPyB7XG4gICAgdmFsdWUsXG4gICAgb2Zmc2V0XG4gIH0gOiBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSwge1xuICAgIG9mZnNldDogZXh0ZW5kT2Zmc2V0KHZhbHVlLm9mZnNldCwgb2Zmc2V0KVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ3VpZGVNYXJrIChtYXJrLCBleHRyYXMpIHtcbiAgaWYgKGV4dHJhcykge1xuICAgIG1hcmsubmFtZSA9IGV4dHJhcy5uYW1lO1xuICAgIG1hcmsuc3R5bGUgPSBleHRyYXMuc3R5bGUgfHwgbWFyay5zdHlsZTtcbiAgICBtYXJrLmludGVyYWN0aXZlID0gISFleHRyYXMuaW50ZXJhY3RpdmU7XG4gICAgbWFyay5lbmNvZGUgPSBleHRlbmRFbmNvZGUobWFyay5lbmNvZGUsIGV4dHJhcywgU2tpcCk7XG4gIH0gZWxzZSB7XG4gICAgbWFyay5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG1hcms7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEdyYWRpZW50IChzcGVjLCBzY2FsZSwgY29uZmlnLCB1c2VyRW5jb2RlKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgdmVydGljYWwgPSBfLmlzVmVydGljYWwoKSxcbiAgICAgICAgdGhpY2tuZXNzID0gXy5ncmFkaWVudFRoaWNrbmVzcygpLFxuICAgICAgICBsZW5ndGggPSBfLmdyYWRpZW50TGVuZ3RoKCk7XG5cbiAgbGV0IGVudGVyLCBzdGFydCwgc3RvcCwgd2lkdGgsIGhlaWdodDtcblxuICBpZiAodmVydGljYWwpIHtcbiAgICBzdGFydCA9IFswLCAxXTtcbiAgICBzdG9wID0gWzAsIDBdO1xuICAgIHdpZHRoID0gdGhpY2tuZXNzO1xuICAgIGhlaWdodCA9IGxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IFswLCAwXTtcbiAgICBzdG9wID0gWzEsIDBdO1xuICAgIHdpZHRoID0gbGVuZ3RoO1xuICAgIGhlaWdodCA9IHRoaWNrbmVzcztcbiAgfVxuXG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvLFxuICAgICAgeDogemVybyxcbiAgICAgIHk6IHplcm8sXG4gICAgICB3aWR0aDogZW5jb2Rlcih3aWR0aCksXG4gICAgICBoZWlnaHQ6IGVuY29kZXIoaGVpZ2h0KVxuICAgIH0sXG4gICAgdXBkYXRlOiBleHRlbmQoe30sIGVudGVyLCB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICBmaWxsOiB7XG4gICAgICAgIGdyYWRpZW50OiBzY2FsZSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBzdG9wOiBzdG9wXG4gICAgICB9XG4gICAgfSksXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgc3Ryb2tlOiBfKCdncmFkaWVudFN0cm9rZUNvbG9yJyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ2dyYWRpZW50U3Ryb2tlV2lkdGgnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgb3BhY2l0eTogXygnZ3JhZGllbnRPcGFjaXR5JylcbiAgfSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJlY3RNYXJrLFxuICAgIHJvbGU6IExlZ2VuZEdyYWRpZW50Um9sZSxcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEdyYWRpZW50RGlzY3JldGUgKHNwZWMsIHNjYWxlLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgICAgICB2ZXJ0aWNhbCA9IF8uaXNWZXJ0aWNhbCgpLFxuICAgICAgICB0aGlja25lc3MgPSBfLmdyYWRpZW50VGhpY2tuZXNzKCksXG4gICAgICAgIGxlbmd0aCA9IF8uZ3JhZGllbnRMZW5ndGgoKTtcblxuICBsZXQgdSxcbiAgICAgIHYsXG4gICAgICB1dSxcbiAgICAgIHZ2LFxuICAgICAgYWRqdXN0ID0gJyc7XG4gIHZlcnRpY2FsID8gKHUgPSAneScsIHV1ID0gJ3kyJywgdiA9ICd4JywgdnYgPSAnd2lkdGgnLCBhZGp1c3QgPSAnMS0nKSA6ICh1ID0gJ3gnLCB1dSA9ICd4MicsIHYgPSAneScsIHZ2ID0gJ2hlaWdodCcpO1xuICBjb25zdCBlbnRlciA9IHtcbiAgICBvcGFjaXR5OiB6ZXJvLFxuICAgIGZpbGw6IHtcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIGZpZWxkOiBWYWx1ZVxuICAgIH1cbiAgfTtcbiAgZW50ZXJbdV0gPSB7XG4gICAgc2lnbmFsOiBhZGp1c3QgKyAnZGF0dW0uJyArIFBlcmMsXG4gICAgbXVsdDogbGVuZ3RoXG4gIH07XG4gIGVudGVyW3ZdID0gemVybztcbiAgZW50ZXJbdXVdID0ge1xuICAgIHNpZ25hbDogYWRqdXN0ICsgJ2RhdHVtLicgKyBQZXJjMixcbiAgICBtdWx0OiBsZW5ndGhcbiAgfTtcbiAgZW50ZXJbdnZdID0gZW5jb2Rlcih0aGlja25lc3MpO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyLFxuICAgIHVwZGF0ZTogZXh0ZW5kKHt9LCBlbnRlciwge1xuICAgICAgb3BhY2l0eTogb25lXG4gICAgfSksXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgc3Ryb2tlOiBfKCdncmFkaWVudFN0cm9rZUNvbG9yJyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ2dyYWRpZW50U3Ryb2tlV2lkdGgnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgb3BhY2l0eTogXygnZ3JhZGllbnRPcGFjaXR5JylcbiAgfSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJlY3RNYXJrLFxuICAgIHJvbGU6IExlZ2VuZEJhbmRSb2xlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmNvbnN0IGFsaWduRXhwciA9IGBkYXR1bS4ke1BlcmN9PD0wP1wiJHtMZWZ0fVwiOmRhdHVtLiR7UGVyY30+PTE/XCIke1JpZ2h0fVwiOlwiJHtDZW50ZXJ9XCJgLFxuICAgICAgYmFzZWxpbmVFeHByID0gYGRhdHVtLiR7UGVyY308PTA/XCIke0JvdHRvbX1cIjpkYXR1bS4ke1BlcmN9Pj0xP1wiJHtUb3B9XCI6XCIke01pZGRsZX1cImA7XG5mdW5jdGlvbiBsZWdlbmRHcmFkaWVudExhYmVscyAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgdmVydGljYWwgPSBfLmlzVmVydGljYWwoKSxcbiAgICAgICAgdGhpY2tuZXNzID0gZW5jb2RlcihfLmdyYWRpZW50VGhpY2tuZXNzKCkpLFxuICAgICAgICBsZW5ndGggPSBfLmdyYWRpZW50TGVuZ3RoKCk7XG5cbiAgbGV0IG92ZXJsYXAgPSBfKCdsYWJlbE92ZXJsYXAnKSxcbiAgICAgIGVudGVyLFxuICAgICAgdXBkYXRlLFxuICAgICAgdSxcbiAgICAgIHYsXG4gICAgICBhZGp1c3QgPSAnJztcblxuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB0ZXh0OiB7XG4gICAgICAgIGZpZWxkOiBMYWJlbFxuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgZmlsbDogXygnbGFiZWxDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCdsYWJlbE9wYWNpdHknKSxcbiAgICBmb250OiBfKCdsYWJlbEZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnbGFiZWxGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygnbGFiZWxGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdsYWJlbEZvbnRXZWlnaHQnKSxcbiAgICBsaW1pdDogdmFsdWUoc3BlYy5sYWJlbExpbWl0LCBjb25maWcuZ3JhZGllbnRMYWJlbExpbWl0KVxuICB9KTtcblxuICBpZiAodmVydGljYWwpIHtcbiAgICBlbnRlci5hbGlnbiA9IHtcbiAgICAgIHZhbHVlOiAnbGVmdCdcbiAgICB9O1xuICAgIGVudGVyLmJhc2VsaW5lID0gdXBkYXRlLmJhc2VsaW5lID0ge1xuICAgICAgc2lnbmFsOiBiYXNlbGluZUV4cHJcbiAgICB9O1xuICAgIHUgPSAneSc7XG4gICAgdiA9ICd4JztcbiAgICBhZGp1c3QgPSAnMS0nO1xuICB9IGVsc2Uge1xuICAgIGVudGVyLmFsaWduID0gdXBkYXRlLmFsaWduID0ge1xuICAgICAgc2lnbmFsOiBhbGlnbkV4cHJcbiAgICB9O1xuICAgIGVudGVyLmJhc2VsaW5lID0ge1xuICAgICAgdmFsdWU6ICd0b3AnXG4gICAgfTtcbiAgICB1ID0gJ3gnO1xuICAgIHYgPSAneSc7XG4gIH1cblxuICBlbnRlclt1XSA9IHVwZGF0ZVt1XSA9IHtcbiAgICBzaWduYWw6IGFkanVzdCArICdkYXR1bS4nICsgUGVyYyxcbiAgICBtdWx0OiBsZW5ndGhcbiAgfTtcbiAgZW50ZXJbdl0gPSB1cGRhdGVbdl0gPSB0aGlja25lc3M7XG4gIHRoaWNrbmVzcy5vZmZzZXQgPSB2YWx1ZShzcGVjLmxhYmVsT2Zmc2V0LCBjb25maWcuZ3JhZGllbnRMYWJlbE9mZnNldCkgfHwgMDtcbiAgb3ZlcmxhcCA9IG92ZXJsYXAgPyB7XG4gICAgc2VwYXJhdGlvbjogXygnbGFiZWxTZXBhcmF0aW9uJyksXG4gICAgbWV0aG9kOiBvdmVybGFwLFxuICAgIG9yZGVyOiAnZGF0dW0uJyArIEluZGV4XG4gIH0gOiB1bmRlZmluZWQ7IC8vIHR5cGUsIHJvbGUsIHN0eWxlLCBrZXksIGRhdGFSZWYsIGVuY29kZSwgZXh0cmFzXG5cbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogTGVnZW5kTGFiZWxSb2xlLFxuICAgIHN0eWxlOiBHdWlkZUxhYmVsU3R5bGUsXG4gICAga2V5OiBWYWx1ZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZSxcbiAgICBvdmVybGFwXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRTeW1ib2xHcm91cHMgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZiwgY29sdW1ucykge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIGVudHJpZXMgPSB1c2VyRW5jb2RlLmVudHJpZXMsXG4gICAgICAgIGludGVyYWN0aXZlID0gISEoZW50cmllcyAmJiBlbnRyaWVzLmludGVyYWN0aXZlKSxcbiAgICAgICAgbmFtZSA9IGVudHJpZXMgPyBlbnRyaWVzLm5hbWUgOiB1bmRlZmluZWQsXG4gICAgICAgIGhlaWdodCA9IF8oJ2NsaXBIZWlnaHQnKSxcbiAgICAgICAgc3ltYm9sT2Zmc2V0ID0gXygnc3ltYm9sT2Zmc2V0JyksXG4gICAgICAgIHZhbHVlUmVmID0ge1xuICAgIGRhdGE6ICd2YWx1ZSdcbiAgfSxcbiAgICAgICAgeFNpZ25hbCA9IGAoJHtjb2x1bW5zfSkgPyBkYXR1bS4ke09mZnNldH0gOiBkYXR1bS4ke1NpemV9YCxcbiAgICAgICAgeUVuY29kZSA9IGhlaWdodCA/IGVuY29kZXIoaGVpZ2h0KSA6IHtcbiAgICBmaWVsZDogU2l6ZVxuICB9LFxuICAgICAgICBpbmRleCA9IGBkYXR1bS4ke0luZGV4fWAsXG4gICAgICAgIG5jb2xzID0gYG1heCgxLCAke2NvbHVtbnN9KWA7XG5cbiAgbGV0IGVuY29kZSwgZW50ZXIsIHVwZGF0ZSwgbnJvd3MsIHNvcnQ7XG4gIHlFbmNvZGUubXVsdCA9IDAuNTsgLy8gLS0gTEVHRU5EIFNZTUJPTFMgLS1cblxuICBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVybyxcbiAgICAgIHg6IHtcbiAgICAgICAgc2lnbmFsOiB4U2lnbmFsLFxuICAgICAgICBtdWx0OiAwLjUsXG4gICAgICAgIG9mZnNldDogc3ltYm9sT2Zmc2V0XG4gICAgICB9LFxuICAgICAgeTogeUVuY29kZVxuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB4OiBlbnRlci54LFxuICAgICAgeTogZW50ZXIueVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgbGV0IGJhc2VGaWxsID0gbnVsbCxcbiAgICAgIGJhc2VTdHJva2UgPSBudWxsO1xuXG4gIGlmICghc3BlYy5maWxsKSB7XG4gICAgYmFzZUZpbGwgPSBjb25maWcuc3ltYm9sQmFzZUZpbGxDb2xvcjtcbiAgICBiYXNlU3Ryb2tlID0gY29uZmlnLnN5bWJvbEJhc2VTdHJva2VDb2xvcjtcbiAgfVxuXG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGZpbGw6IF8oJ3N5bWJvbEZpbGxDb2xvcicsIGJhc2VGaWxsKSxcbiAgICBzaGFwZTogXygnc3ltYm9sVHlwZScpLFxuICAgIHNpemU6IF8oJ3N5bWJvbFNpemUnKSxcbiAgICBzdHJva2U6IF8oJ3N5bWJvbFN0cm9rZUNvbG9yJywgYmFzZVN0cm9rZSksXG4gICAgc3Ryb2tlRGFzaDogXygnc3ltYm9sRGFzaCcpLFxuICAgIHN0cm9rZURhc2hPZmZzZXQ6IF8oJ3N5bWJvbERhc2hPZmZzZXQnKSxcbiAgICBzdHJva2VXaWR0aDogXygnc3ltYm9sU3Ryb2tlV2lkdGgnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgb3BhY2l0eTogXygnc3ltYm9sT3BhY2l0eScpXG4gIH0pO1xuICBMZWdlbmRTY2FsZXMuZm9yRWFjaChzY2FsZSA9PiB7XG4gICAgaWYgKHNwZWNbc2NhbGVdKSB7XG4gICAgICB1cGRhdGVbc2NhbGVdID0gZW50ZXJbc2NhbGVdID0ge1xuICAgICAgICBzY2FsZTogc3BlY1tzY2FsZV0sXG4gICAgICAgIGZpZWxkOiBWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzeW1ib2xzID0gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBTeW1ib2xNYXJrLFxuICAgIHJvbGU6IExlZ2VuZFN5bWJvbFJvbGUsXG4gICAga2V5OiBWYWx1ZSxcbiAgICBmcm9tOiB2YWx1ZVJlZixcbiAgICBjbGlwOiBoZWlnaHQgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlLnN5bWJvbHMpOyAvLyAtLSBMRUdFTkQgTEFCRUxTIC0tXG5cbiAgY29uc3QgbGFiZWxPZmZzZXQgPSBlbmNvZGVyKHN5bWJvbE9mZnNldCk7XG4gIGxhYmVsT2Zmc2V0Lm9mZnNldCA9IF8oJ2xhYmVsT2Zmc2V0Jyk7XG4gIGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvLFxuICAgICAgeDoge1xuICAgICAgICBzaWduYWw6IHhTaWduYWwsXG4gICAgICAgIG9mZnNldDogbGFiZWxPZmZzZXRcbiAgICAgIH0sXG4gICAgICB5OiB5RW5jb2RlXG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IG9uZSxcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgZmllbGQ6IExhYmVsXG4gICAgICB9LFxuICAgICAgeDogZW50ZXIueCxcbiAgICAgIHk6IGVudGVyLnlcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGFsaWduOiBfKCdsYWJlbEFsaWduJyksXG4gICAgYmFzZWxpbmU6IF8oJ2xhYmVsQmFzZWxpbmUnKSxcbiAgICBmaWxsOiBfKCdsYWJlbENvbG9yJyksXG4gICAgZmlsbE9wYWNpdHk6IF8oJ2xhYmVsT3BhY2l0eScpLFxuICAgIGZvbnQ6IF8oJ2xhYmVsRm9udCcpLFxuICAgIGZvbnRTaXplOiBfKCdsYWJlbEZvbnRTaXplJyksXG4gICAgZm9udFN0eWxlOiBfKCdsYWJlbEZvbnRTdHlsZScpLFxuICAgIGZvbnRXZWlnaHQ6IF8oJ2xhYmVsRm9udFdlaWdodCcpLFxuICAgIGxpbWl0OiBfKCdsYWJlbExpbWl0JylcbiAgfSk7XG4gIGNvbnN0IGxhYmVscyA9IGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogTGVnZW5kTGFiZWxSb2xlLFxuICAgIHN0eWxlOiBHdWlkZUxhYmVsU3R5bGUsXG4gICAga2V5OiBWYWx1ZSxcbiAgICBmcm9tOiB2YWx1ZVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZS5sYWJlbHMpOyAvLyAtLSBMRUdFTkQgRU5UUlkgR1JPVVBTIC0tXG5cbiAgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7XG4gICAgICBub0JvdW5kOiB7XG4gICAgICAgIHZhbHVlOiAhaGVpZ2h0XG4gICAgICB9LFxuICAgICAgLy8gaWdub3JlIHdpZHRoL2hlaWdodCBpbiBib3VuZHMgY2FsY1xuICAgICAgd2lkdGg6IHplcm8sXG4gICAgICBoZWlnaHQ6IGhlaWdodCA/IGVuY29kZXIoaGVpZ2h0KSA6IHplcm8sXG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IG9uZSxcbiAgICAgIHJvdzoge1xuICAgICAgICBzaWduYWw6IG51bGxcbiAgICAgIH0sXG4gICAgICBjb2x1bW46IHtcbiAgICAgICAgc2lnbmFsOiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBhbm5vdGF0ZSBhbmQgc29ydCBncm91cHMgdG8gZW5zdXJlIGNvcnJlY3Qgb3JkZXJpbmdcblxuICBpZiAoXy5pc1ZlcnRpY2FsKHRydWUpKSB7XG4gICAgbnJvd3MgPSBgY2VpbChpdGVtLm1hcmsuaXRlbXMubGVuZ3RoIC8gJHtuY29sc30pYDtcbiAgICB1cGRhdGUucm93LnNpZ25hbCA9IGAke2luZGV4fSUke25yb3dzfWA7XG4gICAgdXBkYXRlLmNvbHVtbi5zaWduYWwgPSBgZmxvb3IoJHtpbmRleH0gLyAke25yb3dzfSlgO1xuICAgIHNvcnQgPSB7XG4gICAgICBmaWVsZDogWydyb3cnLCBpbmRleF1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZS5yb3cuc2lnbmFsID0gYGZsb29yKCR7aW5kZXh9IC8gJHtuY29sc30pYDtcbiAgICB1cGRhdGUuY29sdW1uLnNpZ25hbCA9IGAke2luZGV4fSAlICR7bmNvbHN9YDtcbiAgICBzb3J0ID0ge1xuICAgICAgZmllbGQ6IGluZGV4XG4gICAgfTtcbiAgfSAvLyBoYW5kbGUgemVybyBjb2x1bW4gY2FzZSAoaW1wbGllcyBpbmZpbml0ZSBjb2x1bW5zKVxuXG5cbiAgdXBkYXRlLmNvbHVtbi5zaWduYWwgPSBgKCR7Y29sdW1uc30pPyR7dXBkYXRlLmNvbHVtbi5zaWduYWx9OiR7aW5kZXh9YDsgLy8gZmFjZXQgbGVnZW5kIGVudHJpZXMgaW50byBzdWItZ3JvdXBzXG5cbiAgZGF0YVJlZiA9IHtcbiAgICBmYWNldDoge1xuICAgICAgZGF0YTogZGF0YVJlZixcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICBncm91cGJ5OiBJbmRleFxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGd1aWRlR3JvdXAoe1xuICAgIHJvbGU6IFNjb3BlUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZXh0ZW5kRW5jb2RlKGVuY29kZSwgZW50cmllcywgU2tpcCksXG4gICAgbWFya3M6IFtzeW1ib2xzLCBsYWJlbHNdLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc29ydFxuICB9KTtcbn1cbmZ1bmN0aW9uIGxlZ2VuZFN5bWJvbExheW91dChzcGVjLCBjb25maWcpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpOyAvLyBsYXlvdXQgcGFyYW1ldGVycyBmb3IgbGVnZW5kIGVudHJpZXNcblxuXG4gIHJldHVybiB7XG4gICAgYWxpZ246IF8oJ2dyaWRBbGlnbicpLFxuICAgIGNvbHVtbnM6IF8uZW50cnlDb2x1bW5zKCksXG4gICAgY2VudGVyOiB7XG4gICAgICByb3c6IHRydWUsXG4gICAgICBjb2x1bW46IGZhbHNlXG4gICAgfSxcbiAgICBwYWRkaW5nOiB7XG4gICAgICByb3c6IF8oJ3Jvd1BhZGRpbmcnKSxcbiAgICAgIGNvbHVtbjogXygnY29sdW1uUGFkZGluZycpXG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBpc0wgPSAnaXRlbS5vcmllbnQgPT09IFwibGVmdFwiJyxcbiAgICAgIGlzUiA9ICdpdGVtLm9yaWVudCA9PT0gXCJyaWdodFwiJyxcbiAgICAgIGlzTFIgPSBgKCR7aXNMfSB8fCAke2lzUn0pYCxcbiAgICAgIGlzVkcgPSBgZGF0dW0udmdyYWQgJiYgJHtpc0xSfWAsXG4gICAgICBiYXNlbGluZSA9IGFuY2hvckV4cHIoJ1widG9wXCInLCAnXCJib3R0b21cIicsICdcIm1pZGRsZVwiJyksXG4gICAgICBhbGlnbkZsaXAgPSBhbmNob3JFeHByKCdcInJpZ2h0XCInLCAnXCJsZWZ0XCInLCAnXCJjZW50ZXJcIicpLFxuICAgICAgZXhwckFsaWduID0gYGRhdHVtLnZncmFkICYmICR7aXNSfSA/ICgke2FsaWduRmxpcH0pIDogKCR7aXNMUn0gJiYgIShkYXR1bS52Z3JhZCAmJiAke2lzTH0pKSA/IFwibGVmdFwiIDogJHthbGlnbkV4cHIkMX1gLFxuICAgICAgZXhwckFuY2hvciA9IGBpdGVtLl9hbmNob3IgfHwgKCR7aXNMUn0gPyBcIm1pZGRsZVwiIDogXCJzdGFydFwiKWAsXG4gICAgICBleHByQW5nbGUgPSBgJHtpc1ZHfSA/ICgke2lzTH0gPyAtOTAgOiA5MCkgOiAwYCxcbiAgICAgIGV4cHJCYXNlbGluZSA9IGAke2lzTFJ9ID8gKGRhdHVtLnZncmFkID8gKCR7aXNSfSA/IFwiYm90dG9tXCIgOiBcInRvcFwiKSA6ICR7YmFzZWxpbmV9KSA6IFwidG9wXCJgO1xuZnVuY3Rpb24gbGVnZW5kVGl0bGUgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZikge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyk7XG5cbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHtcbiAgICAgIG9wYWNpdHk6IG9uZSxcbiAgICAgIHg6IHtcbiAgICAgICAgZmllbGQ6IHtcbiAgICAgICAgICBncm91cDogJ3BhZGRpbmcnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGZpZWxkOiB7XG4gICAgICAgICAgZ3JvdXA6ICdwYWRkaW5nJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBvcmllbnQ6IF8oJ3RpdGxlT3JpZW50JyksXG4gICAgX2FuY2hvcjogXygndGl0bGVBbmNob3InKSxcbiAgICBhbmNob3I6IHtcbiAgICAgIHNpZ25hbDogZXhwckFuY2hvclxuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgIHNpZ25hbDogZXhwckFuZ2xlXG4gICAgfSxcbiAgICBhbGlnbjoge1xuICAgICAgc2lnbmFsOiBleHByQWxpZ25cbiAgICB9LFxuICAgIGJhc2VsaW5lOiB7XG4gICAgICBzaWduYWw6IGV4cHJCYXNlbGluZVxuICAgIH0sXG4gICAgdGV4dDogc3BlYy50aXRsZSxcbiAgICBmaWxsOiBfKCd0aXRsZUNvbG9yJyksXG4gICAgZmlsbE9wYWNpdHk6IF8oJ3RpdGxlT3BhY2l0eScpLFxuICAgIGZvbnQ6IF8oJ3RpdGxlRm9udCcpLFxuICAgIGZvbnRTaXplOiBfKCd0aXRsZUZvbnRTaXplJyksXG4gICAgZm9udFN0eWxlOiBfKCd0aXRsZUZvbnRTdHlsZScpLFxuICAgIGZvbnRXZWlnaHQ6IF8oJ3RpdGxlRm9udFdlaWdodCcpLFxuICAgIGxpbWl0OiBfKCd0aXRsZUxpbWl0JyksXG4gICAgbGluZUhlaWdodDogXygndGl0bGVMaW5lSGVpZ2h0JylcbiAgfSwge1xuICAgIC8vIHJlcXVpcmUgdXBkYXRlXG4gICAgYWxpZ246IF8oJ3RpdGxlQWxpZ24nKSxcbiAgICBiYXNlbGluZTogXygndGl0bGVCYXNlbGluZScpXG4gIH0pO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBUZXh0TWFyayxcbiAgICByb2xlOiBMZWdlbmRUaXRsZVJvbGUsXG4gICAgc3R5bGU6IEd1aWRlVGl0bGVTdHlsZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gY2xpcCAoY2xpcCwgc2NvcGUpIHtcbiAgbGV0IGV4cHI7XG5cbiAgaWYgKGlzT2JqZWN0KGNsaXApKSB7XG4gICAgaWYgKGNsaXAuc2lnbmFsKSB7XG4gICAgICBleHByID0gY2xpcC5zaWduYWw7XG4gICAgfSBlbHNlIGlmIChjbGlwLnBhdGgpIHtcbiAgICAgIGV4cHIgPSAncGF0aFNoYXBlKCcgKyBwYXJhbShjbGlwLnBhdGgpICsgJyknO1xuICAgIH0gZWxzZSBpZiAoY2xpcC5zcGhlcmUpIHtcbiAgICAgIGV4cHIgPSAnZ2VvU2hhcGUoJyArIHBhcmFtKGNsaXAuc3BoZXJlKSArICcsIHt0eXBlOiBcIlNwaGVyZVwifSknO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByID8gc2NvcGUuc2lnbmFsUmVmKGV4cHIpIDogISFjbGlwO1xufVxuXG5mdW5jdGlvbiBwYXJhbSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLnNpZ25hbCA/IHZhbHVlLnNpZ25hbCA6IHN0cmluZ1ZhbHVlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Um9sZSAoc3BlYykge1xuICBjb25zdCByb2xlID0gc3BlYy5yb2xlIHx8ICcnO1xuICByZXR1cm4gIXJvbGUuaW5kZXhPZignYXhpcycpIHx8ICFyb2xlLmluZGV4T2YoJ2xlZ2VuZCcpIHx8ICFyb2xlLmluZGV4T2YoJ3RpdGxlJykgPyByb2xlIDogc3BlYy50eXBlID09PSBHcm91cE1hcmsgPyBTY29wZVJvbGUgOiByb2xlIHx8IE1hcmtSb2xlO1xufVxuXG5mdW5jdGlvbiBkZWZpbml0aW9uIChzcGVjKSB7XG4gIHJldHVybiB7XG4gICAgbWFya3R5cGU6IHNwZWMudHlwZSxcbiAgICBuYW1lOiBzcGVjLm5hbWUgfHwgdW5kZWZpbmVkLFxuICAgIHJvbGU6IHNwZWMucm9sZSB8fCBnZXRSb2xlKHNwZWMpLFxuICAgIHppbmRleDogK3NwZWMuemluZGV4IHx8IHVuZGVmaW5lZCxcbiAgICBhcmlhOiBzcGVjLmFyaWEsXG4gICAgZGVzY3JpcHRpb246IHNwZWMuZGVzY3JpcHRpb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJhY3RpdmUgKHNwZWMsIHNjb3BlKSB7XG4gIHJldHVybiBzcGVjICYmIHNwZWMuc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKHNwZWMuc2lnbmFsKSA6IHNwZWMgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgZGF0YSB0cmFuc2Zvcm0gc3BlY2lmaWNhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybSAoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgZGVmID0gZGVmaW5pdGlvbiQxKHNwZWMudHlwZSk7XG4gIGlmICghZGVmKSBlcnJvcignVW5yZWNvZ25pemVkIHRyYW5zZm9ybSB0eXBlOiAnICsgc3RyaW5nVmFsdWUoc3BlYy50eXBlKSk7XG4gIGNvbnN0IHQgPSBlbnRyeShkZWYudHlwZS50b0xvd2VyQ2FzZSgpLCBudWxsLCBwYXJzZVBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSkpO1xuICBpZiAoc3BlYy5zaWduYWwpIHNjb3BlLmFkZFNpZ25hbChzcGVjLnNpZ25hbCwgc2NvcGUucHJveHkodCkpO1xuICB0Lm1ldGFkYXRhID0gZGVmLm1ldGFkYXRhIHx8IHt9O1xuICByZXR1cm4gdDtcbn1cbi8qKlxuICogUGFyc2UgYWxsIHBhcmFtZXRlcnMgb2YgYSBkYXRhIHRyYW5zZm9ybS5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCBwYXJhbXMgPSB7fSxcbiAgICAgICAgbiA9IGRlZi5wYXJhbXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgcGRlZiA9IGRlZi5wYXJhbXNbaV07XG4gICAgcGFyYW1zW3BkZWYubmFtZV0gPSBwYXJzZVBhcmFtZXRlcihwZGVmLCBzcGVjLCBzY29wZSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufVxuLyoqXG4gKiBQYXJzZSBhIGRhdGEgdHJhbnNmb3JtIHBhcmFtZXRlci5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKGRlZiwgc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgdHlwZSA9IGRlZi50eXBlLFxuICAgICAgICB2YWx1ZSA9IHNwZWNbZGVmLm5hbWVdO1xuXG4gIGlmICh0eXBlID09PSAnaW5kZXgnKSB7XG4gICAgcmV0dXJuIHBhcnNlSW5kZXhQYXJhbWV0ZXIoZGVmLCBzcGVjLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkZWYucmVxdWlyZWQpIHtcbiAgICAgIGVycm9yKCdNaXNzaW5nIHJlcXVpcmVkICcgKyBzdHJpbmdWYWx1ZShzcGVjLnR5cGUpICsgJyBwYXJhbWV0ZXI6ICcgKyBzdHJpbmdWYWx1ZShkZWYubmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncGFyYW0nKSB7XG4gICAgcmV0dXJuIHBhcnNlU3ViUGFyYW1ldGVycyhkZWYsIHNwZWMsIHNjb3BlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncHJvamVjdGlvbicpIHtcbiAgICByZXR1cm4gc2NvcGUucHJvamVjdGlvblJlZihzcGVjW2RlZi5uYW1lXSk7XG4gIH1cblxuICByZXR1cm4gZGVmLmFycmF5ICYmICFpc1NpZ25hbCh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBwYXJhbWV0ZXJWYWx1ZShkZWYsIHYsIHNjb3BlKSkgOiBwYXJhbWV0ZXJWYWx1ZShkZWYsIHZhbHVlLCBzY29wZSk7XG59XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHBhcmFtZXRlciB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcmFtZXRlclZhbHVlKGRlZiwgdmFsdWUsIHNjb3BlKSB7XG4gIGNvbnN0IHR5cGUgPSBkZWYudHlwZTtcblxuICBpZiAoaXNTaWduYWwodmFsdWUpKSB7XG4gICAgcmV0dXJuIGlzRXhwcih0eXBlKSA/IGVycm9yKCdFeHByZXNzaW9uIHJlZmVyZW5jZXMgY2FuIG5vdCBiZSBzaWduYWxzLicpIDogaXNGaWVsZCh0eXBlKSA/IHNjb3BlLmZpZWxkUmVmKHZhbHVlKSA6IGlzQ29tcGFyZSh0eXBlKSA/IHNjb3BlLmNvbXBhcmVSZWYodmFsdWUpIDogc2NvcGUuc2lnbmFsUmVmKHZhbHVlLnNpZ25hbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXhwciA9IGRlZi5leHByIHx8IGlzRmllbGQodHlwZSk7XG4gICAgcmV0dXJuIGV4cHIgJiYgb3V0ZXJFeHByKHZhbHVlKSA/IHNjb3BlLmV4cHJSZWYodmFsdWUuZXhwciwgdmFsdWUuYXMpIDogZXhwciAmJiBvdXRlckZpZWxkKHZhbHVlKSA/IGZpZWxkUmVmJDEodmFsdWUuZmllbGQsIHZhbHVlLmFzKSA6IGlzRXhwcih0eXBlKSA/IHBhcnNlRXhwcmVzc2lvbih2YWx1ZSwgc2NvcGUpIDogaXNEYXRhKHR5cGUpID8gcmVmKHNjb3BlLmdldERhdGEodmFsdWUpLnZhbHVlcykgOiBpc0ZpZWxkKHR5cGUpID8gZmllbGRSZWYkMSh2YWx1ZSkgOiBpc0NvbXBhcmUodHlwZSkgPyBzY29wZS5jb21wYXJlUmVmKHZhbHVlKSA6IHZhbHVlO1xuICB9XG59XG4vKipcbiAqIFBhcnNlIHBhcmFtZXRlciBmb3IgYWNjZXNzaW5nIGFuIGluZGV4IG9mIGFub3RoZXIgZGF0YSBzZXQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUluZGV4UGFyYW1ldGVyKGRlZiwgc3BlYywgc2NvcGUpIHtcbiAgaWYgKCFpc1N0cmluZyhzcGVjLmZyb20pKSB7XG4gICAgZXJyb3IoJ0xvb2t1cCBcImZyb21cIiBwYXJhbWV0ZXIgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLicpO1xuICB9XG5cbiAgcmV0dXJuIHNjb3BlLmdldERhdGEoc3BlYy5mcm9tKS5sb29rdXBSZWYoc2NvcGUsIHNwZWMua2V5KTtcbn1cbi8qKlxuICogUGFyc2UgYSBwYXJhbWV0ZXIgdGhhdCBjb250YWlucyBvbmUgb3IgbW9yZSBzdWItcGFyYW1ldGVyIG9iamVjdHMuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVN1YlBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCB2YWx1ZSA9IHNwZWNbZGVmLm5hbWVdO1xuXG4gIGlmIChkZWYuYXJyYXkpIHtcbiAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBzaWduYWxzIG5vdCBhbGxvd2VkIVxuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGFuIGFycmF5IG9mIHN1Yi1wYXJhbWV0ZXJzLiBJbnN0ZWFkOiAnICsgc3RyaW5nVmFsdWUodmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUubWFwKHYgPT4gcGFyc2VTdWJQYXJhbWV0ZXIoZGVmLCB2LCBzY29wZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZVN1YlBhcmFtZXRlcihkZWYsIHZhbHVlLCBzY29wZSk7XG4gIH1cbn1cbi8qKlxuICogUGFyc2UgYSBzdWItcGFyYW1ldGVyIG9iamVjdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlU3ViUGFyYW1ldGVyKGRlZiwgdmFsdWUsIHNjb3BlKSB7XG4gIGNvbnN0IG4gPSBkZWYucGFyYW1zLmxlbmd0aDtcbiAgbGV0IHBkZWY7IC8vIGxvb3Agb3ZlciBkZWZzIHRvIGZpbmQgbWF0Y2hpbmcga2V5XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBwZGVmID0gZGVmLnBhcmFtc1tpXTtcblxuICAgIGZvciAoY29uc3QgayBpbiBwZGVmLmtleSkge1xuICAgICAgaWYgKHBkZWYua2V5W2tdICE9PSB2YWx1ZVtrXSkge1xuICAgICAgICBwZGVmID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBkZWYpIGJyZWFrO1xuICB9IC8vIHJhaXNlIGVycm9yIGlmIG1hdGNoaW5nIGtleSBub3QgZm91bmRcblxuXG4gIGlmICghcGRlZikgZXJyb3IoJ1Vuc3VwcG9ydGVkIHBhcmFtZXRlcjogJyArIHN0cmluZ1ZhbHVlKHZhbHVlKSk7IC8vIHBhcnNlIHBhcmFtcywgY3JlYXRlIFBhcmFtcyB0cmFuc2Zvcm0sIHJldHVybiByZWZcblxuICBjb25zdCBwYXJhbXMgPSBleHRlbmQocGFyc2VQYXJhbWV0ZXJzKHBkZWYsIHZhbHVlLCBzY29wZSksIHBkZWYua2V5KTtcbiAgcmV0dXJuIHJlZihzY29wZS5hZGQoUGFyYW1zKHBhcmFtcykpKTtcbn0gLy8gLS0gVXRpbGl0aWVzIC0tLS0tXG5cblxuY29uc3Qgb3V0ZXJFeHByID0gXyA9PiBfICYmIF8uZXhwcjtcbmNvbnN0IG91dGVyRmllbGQgPSBfID0+IF8gJiYgXy5maWVsZDtcbmNvbnN0IGlzRGF0YSA9IF8gPT4gXyA9PT0gJ2RhdGEnO1xuY29uc3QgaXNFeHByID0gXyA9PiBfID09PSAnZXhwcic7XG5jb25zdCBpc0ZpZWxkID0gXyA9PiBfID09PSAnZmllbGQnO1xuY29uc3QgaXNDb21wYXJlID0gXyA9PiBfID09PSAnY29tcGFyZSc7XG5cbmZ1bmN0aW9uIHBhcnNlRGF0YSQxIChmcm9tLCBncm91cCwgc2NvcGUpIHtcbiAgbGV0IGZhY2V0LCBrZXksIG9wLCBkYXRhUmVmLCBwYXJlbnQ7IC8vIGlmIG5vIHNvdXJjZSBkYXRhLCBnZW5lcmF0ZSBzaW5nbGV0b24gZGF0dW1cblxuICBpZiAoIWZyb20pIHtcbiAgICBkYXRhUmVmID0gcmVmKHNjb3BlLmFkZChDb2xsZWN0KG51bGwsIFt7fV0pKSk7XG4gIH0gLy8gaWYgZmFjZXRlZCwgcHJvY2VzcyBmYWNldCBzcGVjaWZpY2F0aW9uXG4gIGVsc2UgaWYgKGZhY2V0ID0gZnJvbS5mYWNldCkge1xuICAgIGlmICghZ3JvdXApIGVycm9yKCdPbmx5IGdyb3VwIG1hcmtzIGNhbiBiZSBmYWNldGVkLicpOyAvLyB1c2UgcHJlLWZhY2V0ZWQgc291cmNlIGRhdGEsIGlmIGF2YWlsYWJsZVxuXG4gICAgaWYgKGZhY2V0LmZpZWxkICE9IG51bGwpIHtcbiAgICAgIGRhdGFSZWYgPSBwYXJlbnQgPSBnZXREYXRhUmVmKGZhY2V0LCBzY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdlbmVyYXRlIGZhY2V0IGFnZ3JlZ2F0ZXMgaWYgbm8gZGlyZWN0IGRhdGEgc3BlY2lmaWNhdGlvblxuICAgICAgaWYgKCFmcm9tLmRhdGEpIHtcbiAgICAgICAgb3AgPSBwYXJzZVRyYW5zZm9ybShleHRlbmQoe1xuICAgICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgICAgIGdyb3VwYnk6IGFycmF5KGZhY2V0Lmdyb3VwYnkpXG4gICAgICAgIH0sIGZhY2V0LmFnZ3JlZ2F0ZSksIHNjb3BlKTtcbiAgICAgICAgb3AucGFyYW1zLmtleSA9IHNjb3BlLmtleVJlZihmYWNldC5ncm91cGJ5KTtcbiAgICAgICAgb3AucGFyYW1zLnB1bHNlID0gZ2V0RGF0YVJlZihmYWNldCwgc2NvcGUpO1xuICAgICAgICBkYXRhUmVmID0gcGFyZW50ID0gcmVmKHNjb3BlLmFkZChvcCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gcmVmKHNjb3BlLmdldERhdGEoZnJvbS5kYXRhKS5hZ2dyZWdhdGUpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBzY29wZS5rZXlSZWYoZmFjZXQuZ3JvdXBieSwgdHJ1ZSk7XG4gICAgfVxuICB9IC8vIGlmIG5vdCB5ZXQgZGVmaW5lZCwgZ2V0IHNvdXJjZSBkYXRhIHJlZmVyZW5jZVxuXG5cbiAgaWYgKCFkYXRhUmVmKSB7XG4gICAgZGF0YVJlZiA9IGdldERhdGFSZWYoZnJvbSwgc2NvcGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGtleSxcbiAgICBwdWxzZTogZGF0YVJlZixcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGF0YVJlZihmcm9tLCBzY29wZSkge1xuICByZXR1cm4gZnJvbS4kcmVmID8gZnJvbSA6IGZyb20uZGF0YSAmJiBmcm9tLmRhdGEuJHJlZiA/IGZyb20uZGF0YSA6IHJlZihzY29wZS5nZXREYXRhKGZyb20uZGF0YSkub3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gRGF0YVNjb3BlKHNjb3BlLCBpbnB1dCwgb3V0cHV0LCB2YWx1ZXMsIGFnZ3IpIHtcbiAgdGhpcy5zY29wZSA9IHNjb3BlOyAvLyBwYXJlbnQgc2NvcGUgb2JqZWN0XG5cbiAgdGhpcy5pbnB1dCA9IGlucHV0OyAvLyBmaXJzdCBvcGVyYXRvciBpbiBwaXBlbGluZSAodHVwbGUgaW5wdXQpXG5cbiAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7IC8vIGxhc3Qgb3BlcmF0b3IgaW4gcGlwZWxpbmUgKHR1cGxlIG91dHB1dClcblxuICB0aGlzLnZhbHVlcyA9IHZhbHVlczsgLy8gb3BlcmF0b3IgZm9yIGFjY2Vzc2luZyB0dXBsZXMgKGJ1dCBub3QgdHVwbGUgZmxvdylcbiAgLy8gbGFzdCBhZ2dyZWdhdGUgaW4gdHJhbnNmb3JtIHBpcGVsaW5lXG5cbiAgdGhpcy5hZ2dyZWdhdGUgPSBhZ2dyOyAvLyBsb29rdXAgdGFibGUgb2YgZmllbGQgaW5kaWNlc1xuXG4gIHRoaXMuaW5kZXggPSB7fTtcbn1cblxuRGF0YVNjb3BlLmZyb21FbnRyaWVzID0gZnVuY3Rpb24gKHNjb3BlLCBlbnRyaWVzKSB7XG4gIGNvbnN0IG4gPSBlbnRyaWVzLmxlbmd0aCxcbiAgICAgICAgdmFsdWVzID0gZW50cmllc1tuIC0gMV0sXG4gICAgICAgIG91dHB1dCA9IGVudHJpZXNbbiAtIDJdO1xuICBsZXQgaW5wdXQgPSBlbnRyaWVzWzBdLFxuICAgICAgYWdnciA9IG51bGwsXG4gICAgICBpID0gMTtcblxuICBpZiAoaW5wdXQgJiYgaW5wdXQudHlwZSA9PT0gJ2xvYWQnKSB7XG4gICAgaW5wdXQgPSBlbnRyaWVzWzFdO1xuICB9IC8vIGFkZCBvcGVyYXRvciBlbnRyaWVzIHRvIHRoaXMgc2NvcGUsIHdpcmUgdXAgcHVsc2UgY2hhaW5cblxuXG4gIHNjb3BlLmFkZChlbnRyaWVzWzBdKTtcblxuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIGVudHJpZXNbaV0ucGFyYW1zLnB1bHNlID0gcmVmKGVudHJpZXNbaSAtIDFdKTtcbiAgICBzY29wZS5hZGQoZW50cmllc1tpXSk7XG4gICAgaWYgKGVudHJpZXNbaV0udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIGFnZ3IgPSBlbnRyaWVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRhU2NvcGUoc2NvcGUsIGlucHV0LCBvdXRwdXQsIHZhbHVlcywgYWdncik7XG59O1xuXG5mdW5jdGlvbiBmaWVsZEtleShmaWVsZCkge1xuICByZXR1cm4gaXNTdHJpbmcoZmllbGQpID8gZmllbGQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRTb3J0RmllbGQoc2NvcGUsIHAsIHNvcnQpIHtcbiAgY29uc3QgYXMgPSBhZ2dyRmllbGQoc29ydC5vcCwgc29ydC5maWVsZCk7XG4gIGxldCBzO1xuXG4gIGlmIChwLm9wcykge1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gcC5hcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChwLmFzW2ldID09PSBhcykgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm9wcyA9IFsnY291bnQnXTtcbiAgICBwLmZpZWxkcyA9IFtudWxsXTtcbiAgICBwLmFzID0gWydjb3VudCddO1xuICB9XG5cbiAgaWYgKHNvcnQub3ApIHtcbiAgICBwLm9wcy5wdXNoKChzID0gc29ydC5vcC5zaWduYWwpID8gc2NvcGUuc2lnbmFsUmVmKHMpIDogc29ydC5vcCk7XG4gICAgcC5maWVsZHMucHVzaChzY29wZS5maWVsZFJlZihzb3J0LmZpZWxkKSk7XG4gICAgcC5hcy5wdXNoKGFzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZShzY29wZSwgZHMsIG5hbWUsIG9wdHlwZSwgZmllbGQsIGNvdW50cywgaW5kZXgpIHtcbiAgY29uc3QgY2FjaGUgPSBkc1tuYW1lXSB8fCAoZHNbbmFtZV0gPSB7fSksXG4gICAgICAgIHNvcnQgPSBzb3J0S2V5KGNvdW50cyk7XG4gIGxldCBrID0gZmllbGRLZXkoZmllbGQpLFxuICAgICAgdixcbiAgICAgIG9wO1xuXG4gIGlmIChrICE9IG51bGwpIHtcbiAgICBzY29wZSA9IGRzLnNjb3BlO1xuICAgIGsgPSBrICsgKHNvcnQgPyAnfCcgKyBzb3J0IDogJycpO1xuICAgIHYgPSBjYWNoZVtrXTtcbiAgfVxuXG4gIGlmICghdikge1xuICAgIGNvbnN0IHBhcmFtcyA9IGNvdW50cyA/IHtcbiAgICAgIGZpZWxkOiBrZXlGaWVsZFJlZixcbiAgICAgIHB1bHNlOiBkcy5jb3VudHNSZWYoc2NvcGUsIGZpZWxkLCBjb3VudHMpXG4gICAgfSA6IHtcbiAgICAgIGZpZWxkOiBzY29wZS5maWVsZFJlZihmaWVsZCksXG4gICAgICBwdWxzZTogcmVmKGRzLm91dHB1dClcbiAgICB9O1xuICAgIGlmIChzb3J0KSBwYXJhbXMuc29ydCA9IHNjb3BlLnNvcnRSZWYoY291bnRzKTtcbiAgICBvcCA9IHNjb3BlLmFkZChlbnRyeShvcHR5cGUsIHVuZGVmaW5lZCwgcGFyYW1zKSk7XG4gICAgaWYgKGluZGV4KSBkcy5pbmRleFtmaWVsZF0gPSBvcDtcbiAgICB2ID0gcmVmKG9wKTtcbiAgICBpZiAoayAhPSBudWxsKSBjYWNoZVtrXSA9IHY7XG4gIH1cblxuICByZXR1cm4gdjtcbn1cblxuRGF0YVNjb3BlLnByb3RvdHlwZSA9IHtcbiAgY291bnRzUmVmKHNjb3BlLCBmaWVsZCwgc29ydCkge1xuICAgIGNvbnN0IGRzID0gdGhpcyxcbiAgICAgICAgICBjYWNoZSA9IGRzLmNvdW50cyB8fCAoZHMuY291bnRzID0ge30pLFxuICAgICAgICAgIGsgPSBmaWVsZEtleShmaWVsZCk7XG4gICAgbGV0IHYsIGEsIHA7XG5cbiAgICBpZiAoayAhPSBudWxsKSB7XG4gICAgICBzY29wZSA9IGRzLnNjb3BlO1xuICAgICAgdiA9IGNhY2hlW2tdO1xuICAgIH1cblxuICAgIGlmICghdikge1xuICAgICAgcCA9IHtcbiAgICAgICAgZ3JvdXBieTogc2NvcGUuZmllbGRSZWYoZmllbGQsICdrZXknKSxcbiAgICAgICAgcHVsc2U6IHJlZihkcy5vdXRwdXQpXG4gICAgICB9O1xuICAgICAgaWYgKHNvcnQgJiYgc29ydC5maWVsZCkgYWRkU29ydEZpZWxkKHNjb3BlLCBwLCBzb3J0KTtcbiAgICAgIGEgPSBzY29wZS5hZGQoQWdncmVnYXRlKHApKTtcbiAgICAgIHYgPSBzY29wZS5hZGQoQ29sbGVjdCh7XG4gICAgICAgIHB1bHNlOiByZWYoYSlcbiAgICAgIH0pKTtcbiAgICAgIHYgPSB7XG4gICAgICAgIGFnZzogYSxcbiAgICAgICAgcmVmOiByZWYodilcbiAgICAgIH07XG4gICAgICBpZiAoayAhPSBudWxsKSBjYWNoZVtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChzb3J0ICYmIHNvcnQuZmllbGQpIHtcbiAgICAgIGFkZFNvcnRGaWVsZChzY29wZSwgdi5hZ2cucGFyYW1zLCBzb3J0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdi5yZWY7XG4gIH0sXG5cbiAgdHVwbGVzUmVmKCkge1xuICAgIHJldHVybiByZWYodGhpcy52YWx1ZXMpO1xuICB9LFxuXG4gIGV4dGVudFJlZihzY29wZSwgZmllbGQpIHtcbiAgICByZXR1cm4gY2FjaGUoc2NvcGUsIHRoaXMsICdleHRlbnQnLCAnZXh0ZW50JywgZmllbGQsIGZhbHNlKTtcbiAgfSxcblxuICBkb21haW5SZWYoc2NvcGUsIGZpZWxkKSB7XG4gICAgcmV0dXJuIGNhY2hlKHNjb3BlLCB0aGlzLCAnZG9tYWluJywgJ3ZhbHVlcycsIGZpZWxkLCBmYWxzZSk7XG4gIH0sXG5cbiAgdmFsdWVzUmVmKHNjb3BlLCBmaWVsZCwgc29ydCkge1xuICAgIHJldHVybiBjYWNoZShzY29wZSwgdGhpcywgJ3ZhbHMnLCAndmFsdWVzJywgZmllbGQsIHNvcnQgfHwgdHJ1ZSk7XG4gIH0sXG5cbiAgbG9va3VwUmVmKHNjb3BlLCBmaWVsZCkge1xuICAgIHJldHVybiBjYWNoZShzY29wZSwgdGhpcywgJ2xvb2t1cCcsICd0dXBsZWluZGV4JywgZmllbGQsIGZhbHNlKTtcbiAgfSxcblxuICBpbmRhdGFSZWYoc2NvcGUsIGZpZWxkKSB7XG4gICAgcmV0dXJuIGNhY2hlKHNjb3BlLCB0aGlzLCAnaW5kYXRhJywgJ3R1cGxlaW5kZXgnLCBmaWVsZCwgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gcGFyc2VGYWNldCAoc3BlYywgc2NvcGUsIGdyb3VwKSB7XG4gIGNvbnN0IGZhY2V0ID0gc3BlYy5mcm9tLmZhY2V0LFxuICAgICAgICBuYW1lID0gZmFjZXQubmFtZSxcbiAgICAgICAgZGF0YSA9IGdldERhdGFSZWYoZmFjZXQsIHNjb3BlKTtcbiAgbGV0IG9wO1xuXG4gIGlmICghZmFjZXQubmFtZSkge1xuICAgIGVycm9yKCdGYWNldCBtdXN0IGhhdmUgYSBuYW1lOiAnICsgc3RyaW5nVmFsdWUoZmFjZXQpKTtcbiAgfVxuXG4gIGlmICghZmFjZXQuZGF0YSkge1xuICAgIGVycm9yKCdGYWNldCBtdXN0IHJlZmVyZW5jZSBhIGRhdGEgc2V0OiAnICsgc3RyaW5nVmFsdWUoZmFjZXQpKTtcbiAgfVxuXG4gIGlmIChmYWNldC5maWVsZCkge1xuICAgIG9wID0gc2NvcGUuYWRkKFByZUZhY2V0KHtcbiAgICAgIGZpZWxkOiBzY29wZS5maWVsZFJlZihmYWNldC5maWVsZCksXG4gICAgICBwdWxzZTogZGF0YVxuICAgIH0pKTtcbiAgfSBlbHNlIGlmIChmYWNldC5ncm91cGJ5KSB7XG4gICAgb3AgPSBzY29wZS5hZGQoRmFjZXQoe1xuICAgICAga2V5OiBzY29wZS5rZXlSZWYoZmFjZXQuZ3JvdXBieSksXG4gICAgICBncm91cDogcmVmKHNjb3BlLnByb3h5KGdyb3VwLnBhcmVudCkpLFxuICAgICAgcHVsc2U6IGRhdGFcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0ZhY2V0IG11c3Qgc3BlY2lmeSBncm91cGJ5IG9yIGZpZWxkOiAnICsgc3RyaW5nVmFsdWUoZmFjZXQpKTtcbiAgfSAvLyBpbml0aWFsaXplIGZhY2V0IHN1YnNjb3BlXG5cblxuICBjb25zdCBzdWJzY29wZSA9IHNjb3BlLmZvcmsoKSxcbiAgICAgICAgc291cmNlID0gc3Vic2NvcGUuYWRkKENvbGxlY3QoKSksXG4gICAgICAgIHZhbHVlcyA9IHN1YnNjb3BlLmFkZChTaWV2ZSh7XG4gICAgcHVsc2U6IHJlZihzb3VyY2UpXG4gIH0pKTtcbiAgc3Vic2NvcGUuYWRkRGF0YShuYW1lLCBuZXcgRGF0YVNjb3BlKHN1YnNjb3BlLCBzb3VyY2UsIHNvdXJjZSwgdmFsdWVzKSk7XG4gIHN1YnNjb3BlLmFkZFNpZ25hbCgncGFyZW50JywgbnVsbCk7IC8vIHBhcnNlIGZhY2V0ZWQgc3ViZmxvd1xuXG4gIG9wLnBhcmFtcy5zdWJmbG93ID0ge1xuICAgICRzdWJmbG93OiBzdWJzY29wZS5wYXJzZShzcGVjKS50b1J1bnRpbWUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVN1YmZsb3cgKHNwZWMsIHNjb3BlLCBpbnB1dCkge1xuICBjb25zdCBvcCA9IHNjb3BlLmFkZChQcmVGYWNldCh7XG4gICAgcHVsc2U6IGlucHV0LnB1bHNlXG4gIH0pKSxcbiAgICAgICAgc3Vic2NvcGUgPSBzY29wZS5mb3JrKCk7XG4gIHN1YnNjb3BlLmFkZChTaWV2ZSgpKTtcbiAgc3Vic2NvcGUuYWRkU2lnbmFsKCdwYXJlbnQnLCBudWxsKTsgLy8gcGFyc2UgZ3JvdXAgbWFyayBzdWJmbG93XG5cbiAgb3AucGFyYW1zLnN1YmZsb3cgPSB7XG4gICAgJHN1YmZsb3c6IHN1YnNjb3BlLnBhcnNlKHNwZWMpLnRvUnVudGltZSgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJpZ2dlciAoc3BlYywgc2NvcGUsIG5hbWUpIHtcbiAgY29uc3QgcmVtb3ZlID0gc3BlYy5yZW1vdmUsXG4gICAgICAgIGluc2VydCA9IHNwZWMuaW5zZXJ0LFxuICAgICAgICB0b2dnbGUgPSBzcGVjLnRvZ2dsZSxcbiAgICAgICAgbW9kaWZ5ID0gc3BlYy5tb2RpZnksXG4gICAgICAgIHZhbHVlcyA9IHNwZWMudmFsdWVzLFxuICAgICAgICBvcCA9IHNjb3BlLmFkZChvcGVyYXRvcigpKTtcbiAgY29uc3QgdXBkYXRlID0gJ2lmKCcgKyBzcGVjLnRyaWdnZXIgKyAnLG1vZGlmeShcIicgKyBuYW1lICsgJ1wiLCcgKyBbaW5zZXJ0LCByZW1vdmUsIHRvZ2dsZSwgbW9kaWZ5LCB2YWx1ZXNdLm1hcChfID0+IF8gPT0gbnVsbCA/ICdudWxsJyA6IF8pLmpvaW4oJywnKSArICcpLDApJztcbiAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbih1cGRhdGUsIHNjb3BlKTtcbiAgb3AudXBkYXRlID0gZXhwci4kZXhwcjtcbiAgb3AucGFyYW1zID0gZXhwci4kcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hcmsgKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IHJvbGUgPSBnZXRSb2xlKHNwZWMpLFxuICAgICAgICBncm91cCA9IHNwZWMudHlwZSA9PT0gR3JvdXBNYXJrLFxuICAgICAgICBmYWNldCA9IHNwZWMuZnJvbSAmJiBzcGVjLmZyb20uZmFjZXQsXG4gICAgICAgIG92ZXJsYXAgPSBzcGVjLm92ZXJsYXA7XG4gIGxldCBsYXlvdXQgPSBzcGVjLmxheW91dCB8fCByb2xlID09PSBTY29wZVJvbGUgfHwgcm9sZSA9PT0gRnJhbWVSb2xlLFxuICAgICAgb3BzLFxuICAgICAgb3AsXG4gICAgICBzdG9yZSxcbiAgICAgIGVuYyxcbiAgICAgIG5hbWUsXG4gICAgICBsYXlvdXRSZWYsXG4gICAgICBib3VuZFJlZjtcbiAgY29uc3QgbmVzdGVkID0gcm9sZSA9PT0gTWFya1JvbGUgfHwgbGF5b3V0IHx8IGZhY2V0OyAvLyByZXNvbHZlIGlucHV0IGRhdGFcblxuICBjb25zdCBpbnB1dCA9IHBhcnNlRGF0YSQxKHNwZWMuZnJvbSwgZ3JvdXAsIHNjb3BlKTsgLy8gZGF0YSBqb2luIHRvIG1hcCB0dXBsZXMgdG8gdmlzdWFsIGl0ZW1zXG5cbiAgb3AgPSBzY29wZS5hZGQoRGF0YUpvaW4oe1xuICAgIGtleTogaW5wdXQua2V5IHx8IChzcGVjLmtleSA/IGZpZWxkUmVmJDEoc3BlYy5rZXkpIDogdW5kZWZpbmVkKSxcbiAgICBwdWxzZTogaW5wdXQucHVsc2UsXG4gICAgY2xlYW46ICFncm91cFxuICB9KSk7XG4gIGNvbnN0IGpvaW5SZWYgPSByZWYob3ApOyAvLyBjb2xsZWN0IHZpc3VhbCBpdGVtc1xuXG4gIG9wID0gc3RvcmUgPSBzY29wZS5hZGQoQ29sbGVjdCh7XG4gICAgcHVsc2U6IGpvaW5SZWZcbiAgfSkpOyAvLyBjb25uZWN0IHZpc3VhbCBpdGVtcyB0byBzY2VuZWdyYXBoXG5cbiAgb3AgPSBzY29wZS5hZGQoTWFyayh7XG4gICAgbWFya2RlZjogZGVmaW5pdGlvbihzcGVjKSxcbiAgICBpbnRlcmFjdGl2ZTogaW50ZXJhY3RpdmUoc3BlYy5pbnRlcmFjdGl2ZSwgc2NvcGUpLFxuICAgIGNsaXA6IGNsaXAoc3BlYy5jbGlwLCBzY29wZSksXG4gICAgY29udGV4dDoge1xuICAgICAgJGNvbnRleHQ6IHRydWVcbiAgICB9LFxuICAgIGdyb3Vwczogc2NvcGUubG9va3VwKCksXG4gICAgcGFyZW50OiBzY29wZS5zaWduYWxzLnBhcmVudCA/IHNjb3BlLnNpZ25hbFJlZigncGFyZW50JykgOiBudWxsLFxuICAgIGluZGV4OiBzY29wZS5tYXJrcGF0aCgpLFxuICAgIHB1bHNlOiByZWYob3ApXG4gIH0pKTtcbiAgY29uc3QgbWFya1JlZiA9IHJlZihvcCk7IC8vIGFkZCB2aXN1YWwgZW5jb2RlcnNcblxuICBvcCA9IGVuYyA9IHNjb3BlLmFkZChFbmNvZGUocGFyc2VFbmNvZGUoc3BlYy5lbmNvZGUsIHNwZWMudHlwZSwgcm9sZSwgc3BlYy5zdHlsZSwgc2NvcGUsIHtcbiAgICBtb2Q6IGZhbHNlLFxuICAgIHB1bHNlOiBtYXJrUmVmXG4gIH0pKSk7IC8vIG1vbml0b3IgcGFyZW50IG1hcmtzIHRvIHByb3BhZ2F0ZSBjaGFuZ2VzXG5cbiAgb3AucGFyYW1zLnBhcmVudCA9IHNjb3BlLmVuY29kZSgpOyAvLyBhZGQgcG9zdC1lbmNvZGluZyB0cmFuc2Zvcm1zLCBpZiBkZWZpbmVkXG5cbiAgaWYgKHNwZWMudHJhbnNmb3JtKSB7XG4gICAgc3BlYy50cmFuc2Zvcm0uZm9yRWFjaChfID0+IHtcbiAgICAgIGNvbnN0IHR4ID0gcGFyc2VUcmFuc2Zvcm0oXywgc2NvcGUpLFxuICAgICAgICAgICAgbWQgPSB0eC5tZXRhZGF0YTtcblxuICAgICAgaWYgKG1kLmdlbmVyYXRlcyB8fCBtZC5jaGFuZ2VzKSB7XG4gICAgICAgIGVycm9yKCdNYXJrIHRyYW5zZm9ybXMgc2hvdWxkIG5vdCBnZW5lcmF0ZSBuZXcgZGF0YS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtZC5ub21vZCkgZW5jLnBhcmFtcy5tb2QgPSB0cnVlOyAvLyB1cGRhdGUgZW5jb2RlIG1vZCBoYW5kbGluZ1xuXG4gICAgICB0eC5wYXJhbXMucHVsc2UgPSByZWYob3ApO1xuICAgICAgc2NvcGUuYWRkKG9wID0gdHgpO1xuICAgIH0pO1xuICB9IC8vIGlmIGl0ZW0gc29ydCBzcGVjaWZpZWQsIHBlcmZvcm0gcG9zdC1lbmNvZGluZ1xuXG5cbiAgaWYgKHNwZWMuc29ydCkge1xuICAgIG9wID0gc2NvcGUuYWRkKFNvcnRJdGVtcyh7XG4gICAgICBzb3J0OiBzY29wZS5jb21wYXJlUmVmKHNwZWMuc29ydCksXG4gICAgICBwdWxzZTogcmVmKG9wKVxuICAgIH0pKTtcbiAgfVxuXG4gIGNvbnN0IGVuY29kZVJlZiA9IHJlZihvcCk7IC8vIGFkZCB2aWV3IGxheW91dCBvcGVyYXRvciBpZiBuZWVkZWRcblxuICBpZiAoZmFjZXQgfHwgbGF5b3V0KSB7XG4gICAgbGF5b3V0ID0gc2NvcGUuYWRkKFZpZXdMYXlvdXQoe1xuICAgICAgbGF5b3V0OiBzY29wZS5vYmplY3RQcm9wZXJ0eShzcGVjLmxheW91dCksXG4gICAgICBsZWdlbmRzOiBzY29wZS5sZWdlbmRzLFxuICAgICAgbWFyazogbWFya1JlZixcbiAgICAgIHB1bHNlOiBlbmNvZGVSZWZcbiAgICB9KSk7XG4gICAgbGF5b3V0UmVmID0gcmVmKGxheW91dCk7XG4gIH0gLy8gY29tcHV0ZSBib3VuZGluZyBib3hlc1xuXG5cbiAgY29uc3QgYm91bmQgPSBzY29wZS5hZGQoQm91bmQoe1xuICAgIG1hcms6IG1hcmtSZWYsXG4gICAgcHVsc2U6IGxheW91dFJlZiB8fCBlbmNvZGVSZWZcbiAgfSkpO1xuICBib3VuZFJlZiA9IHJlZihib3VuZCk7IC8vIGlmIGdyb3VwIG1hcmssIHJlY3Vyc2UgdG8gcGFyc2UgbmVzdGVkIGNvbnRlbnRcblxuICBpZiAoZ3JvdXApIHtcbiAgICAvLyBqdWdnbGUgbGF5b3V0ICYgYm91bmRzIHRvIGVuc3VyZSB0aGV5IHJ1biAqYWZ0ZXIqIGFueSBmYWNldGluZyB0cmFuc2Zvcm1zXG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgb3BzID0gc2NvcGUub3BlcmF0b3JzO1xuICAgICAgb3BzLnBvcCgpO1xuICAgICAgaWYgKGxheW91dCkgb3BzLnBvcCgpO1xuICAgIH1cblxuICAgIHNjb3BlLnB1c2hTdGF0ZShlbmNvZGVSZWYsIGxheW91dFJlZiB8fCBib3VuZFJlZiwgam9pblJlZik7XG4gICAgZmFjZXQgPyBwYXJzZUZhY2V0KHNwZWMsIHNjb3BlLCBpbnB1dCkgLy8gZXhwbGljaXQgZmFjZXRcbiAgICA6IG5lc3RlZCA/IHBhcnNlU3ViZmxvdyhzcGVjLCBzY29wZSwgaW5wdXQpIC8vIHN0YW5kYXJkIG1hcmsgZ3JvdXBcbiAgICA6IHNjb3BlLnBhcnNlKHNwZWMpOyAvLyBndWlkZSBncm91cCwgd2UgY2FuIGF2b2lkIG5lc3RlZCBzY29wZXNcblxuICAgIHNjb3BlLnBvcFN0YXRlKCk7XG5cbiAgICBpZiAobmVzdGVkKSB7XG4gICAgICBpZiAobGF5b3V0KSBvcHMucHVzaChsYXlvdXQpO1xuICAgICAgb3BzLnB1c2goYm91bmQpO1xuICAgIH1cbiAgfSAvLyBpZiByZXF1ZXN0ZWQsIGFkZCBvdmVybGFwIHJlbW92YWwgdHJhbnNmb3JtXG5cblxuICBpZiAob3ZlcmxhcCkge1xuICAgIGJvdW5kUmVmID0gcGFyc2VPdmVybGFwKG92ZXJsYXAsIGJvdW5kUmVmLCBzY29wZSk7XG4gIH0gLy8gcmVuZGVyIC8gc2lldmUgaXRlbXNcblxuXG4gIGNvbnN0IHJlbmRlciA9IHNjb3BlLmFkZChSZW5kZXIoe1xuICAgIHB1bHNlOiBib3VuZFJlZlxuICB9KSksXG4gICAgICAgIHNpZXZlID0gc2NvcGUuYWRkKFNpZXZlKHtcbiAgICBwdWxzZTogcmVmKHJlbmRlcilcbiAgfSwgdW5kZWZpbmVkLCBzY29wZS5wYXJlbnQoKSkpOyAvLyBpZiBtYXJrIGlzIG5hbWVkLCBtYWtlIGFjY2Vzc2libGUgYXMgcmVhY3RpdmUgZ2VvbWV0cnlcbiAgLy8gYWRkIHRyaWdnZXIgdXBkYXRlcyBpZiBkZWZpbmVkXG5cbiAgaWYgKHNwZWMubmFtZSAhPSBudWxsKSB7XG4gICAgbmFtZSA9IHNwZWMubmFtZTtcbiAgICBzY29wZS5hZGREYXRhKG5hbWUsIG5ldyBEYXRhU2NvcGUoc2NvcGUsIHN0b3JlLCByZW5kZXIsIHNpZXZlKSk7XG4gICAgaWYgKHNwZWMub24pIHNwZWMub24uZm9yRWFjaChvbiA9PiB7XG4gICAgICBpZiAob24uaW5zZXJ0IHx8IG9uLnJlbW92ZSB8fCBvbi50b2dnbGUpIHtcbiAgICAgICAgZXJyb3IoJ01hcmtzIG9ubHkgc3VwcG9ydCBtb2RpZnkgdHJpZ2dlcnMuJyk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlVHJpZ2dlcihvbiwgc2NvcGUsIG5hbWUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlT3ZlcmxhcChvdmVybGFwLCBzb3VyY2UsIHNjb3BlKSB7XG4gIGNvbnN0IG1ldGhvZCA9IG92ZXJsYXAubWV0aG9kLFxuICAgICAgICBib3VuZCA9IG92ZXJsYXAuYm91bmQsXG4gICAgICAgIHNlcCA9IG92ZXJsYXAuc2VwYXJhdGlvbjtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIHNlcGFyYXRpb246IGlzU2lnbmFsKHNlcCkgPyBzY29wZS5zaWduYWxSZWYoc2VwLnNpZ25hbCkgOiBzZXAsXG4gICAgbWV0aG9kOiBpc1NpZ25hbChtZXRob2QpID8gc2NvcGUuc2lnbmFsUmVmKG1ldGhvZC5zaWduYWwpIDogbWV0aG9kLFxuICAgIHB1bHNlOiBzb3VyY2VcbiAgfTtcblxuICBpZiAob3ZlcmxhcC5vcmRlcikge1xuICAgIHBhcmFtcy5zb3J0ID0gc2NvcGUuY29tcGFyZVJlZih7XG4gICAgICBmaWVsZDogb3ZlcmxhcC5vcmRlclxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGJvdW5kKSB7XG4gICAgY29uc3QgdG9sID0gYm91bmQudG9sZXJhbmNlO1xuICAgIHBhcmFtcy5ib3VuZFRvbGVyYW5jZSA9IGlzU2lnbmFsKHRvbCkgPyBzY29wZS5zaWduYWxSZWYodG9sLnNpZ25hbCkgOiArdG9sO1xuICAgIHBhcmFtcy5ib3VuZFNjYWxlID0gc2NvcGUuc2NhbGVSZWYoYm91bmQuc2NhbGUpO1xuICAgIHBhcmFtcy5ib3VuZE9yaWVudCA9IGJvdW5kLm9yaWVudDtcbiAgfVxuXG4gIHJldHVybiByZWYoc2NvcGUuYWRkKE92ZXJsYXAocGFyYW1zKSkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxlZ2VuZCAoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgY29uZmlnID0gc2NvcGUuY29uZmlnLmxlZ2VuZCxcbiAgICAgICAgZW5jb2RlID0gc3BlYy5lbmNvZGUgfHwge30sXG4gICAgICAgIF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgbGVnZW5kRW5jb2RlID0gZW5jb2RlLmxlZ2VuZCB8fCB7fSxcbiAgICAgICAgbmFtZSA9IGxlZ2VuZEVuY29kZS5uYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgaW50ZXJhY3RpdmUgPSBsZWdlbmRFbmNvZGUuaW50ZXJhY3RpdmUsXG4gICAgICAgIHN0eWxlID0gbGVnZW5kRW5jb2RlLnN0eWxlLFxuICAgICAgICBzY2FsZXMgPSB7fTtcblxuICBsZXQgc2NhbGUgPSAwLFxuICAgICAgZW50cnlMYXlvdXQsXG4gICAgICBwYXJhbXMsXG4gICAgICBjaGlsZHJlbjsgLy8gcmVzb2x2ZSBzY2FsZXMgYW5kICdjYW5vbmljYWwnIHNjYWxlIG5hbWVcblxuICBMZWdlbmRTY2FsZXMuZm9yRWFjaChzID0+IHNwZWNbc10gPyAoc2NhbGVzW3NdID0gc3BlY1tzXSwgc2NhbGUgPSBzY2FsZSB8fCBzcGVjW3NdKSA6IDApO1xuICBpZiAoIXNjYWxlKSBlcnJvcignTWlzc2luZyB2YWxpZCBzY2FsZSBmb3IgbGVnZW5kLicpOyAvLyByZXNvbHZlIGxlZ2VuZCB0eXBlIChzeW1ib2wsIGdyYWRpZW50LCBvciBkaXNjcmV0ZSBncmFkaWVudClcblxuICBjb25zdCB0eXBlID0gbGVnZW5kVHlwZShzcGVjLCBzY29wZS5zY2FsZVR5cGUoc2NhbGUpKTsgLy8gc2luZ2xlLWVsZW1lbnQgZGF0YSBzb3VyY2UgZm9yIGxlZ2VuZCBncm91cFxuXG4gIGNvbnN0IGRhdHVtID0ge1xuICAgIHRpdGxlOiBzcGVjLnRpdGxlICE9IG51bGwsXG4gICAgc2NhbGVzOiBzY2FsZXMsXG4gICAgdHlwZTogdHlwZSxcbiAgICB2Z3JhZDogdHlwZSAhPT0gJ3N5bWJvbCcgJiYgXy5pc1ZlcnRpY2FsKClcbiAgfTtcbiAgY29uc3QgZGF0YVJlZiA9IHJlZihzY29wZS5hZGQoQ29sbGVjdChudWxsLCBbZGF0dW1dKSkpOyAvLyBlbmNvZGluZyBwcm9wZXJ0aWVzIGZvciBsZWdlbmQgZW50cnkgc3ViLWdyb3VwXG5cbiAgY29uc3QgZW50cnlFbmNvZGUgPSB7XG4gICAgZW50ZXI6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBkYXRhIHNvdXJjZSBmb3IgbGVnZW5kIHZhbHVlc1xuXG4gIGNvbnN0IGVudHJ5UmVmID0gcmVmKHNjb3BlLmFkZChMZWdlbmRFbnRyaWVzKHBhcmFtcyA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNjYWxlOiBzY29wZS5zY2FsZVJlZihzY2FsZSksXG4gICAgY291bnQ6IHNjb3BlLm9iamVjdFByb3BlcnR5KF8oJ3RpY2tDb3VudCcpKSxcbiAgICBsaW1pdDogc2NvcGUucHJvcGVydHkoXygnc3ltYm9sTGltaXQnKSksXG4gICAgdmFsdWVzOiBzY29wZS5vYmplY3RQcm9wZXJ0eShzcGVjLnZhbHVlcyksXG4gICAgbWluc3RlcDogc2NvcGUucHJvcGVydHkoc3BlYy50aWNrTWluU3RlcCksXG4gICAgZm9ybWF0VHlwZTogc2NvcGUucHJvcGVydHkoc3BlYy5mb3JtYXRUeXBlKSxcbiAgICBmb3JtYXRTcGVjaWZpZXI6IHNjb3BlLnByb3BlcnR5KHNwZWMuZm9ybWF0KVxuICB9KSkpOyAvLyBjb250aW51b3VzIGdyYWRpZW50IGxlZ2VuZFxuXG4gIGlmICh0eXBlID09PSBHcmFkaWVudCkge1xuICAgIGNoaWxkcmVuID0gW2xlZ2VuZEdyYWRpZW50KHNwZWMsIHNjYWxlLCBjb25maWcsIGVuY29kZS5ncmFkaWVudCksIGxlZ2VuZEdyYWRpZW50TGFiZWxzKHNwZWMsIGNvbmZpZywgZW5jb2RlLmxhYmVscywgZW50cnlSZWYpXTsgLy8gYWRqdXN0IGRlZmF1bHQgdGljayBjb3VudCBiYXNlZCBvbiB0aGUgZ3JhZGllbnQgbGVuZ3RoXG5cbiAgICBwYXJhbXMuY291bnQgPSBwYXJhbXMuY291bnQgfHwgc2NvcGUuc2lnbmFsUmVmKGBtYXgoMiwyKmZsb29yKCgke2RlcmVmKF8uZ3JhZGllbnRMZW5ndGgoKSl9KS8xMDApKWApO1xuICB9IC8vIGRpc2NyZXRlIGdyYWRpZW50IGxlZ2VuZFxuICBlbHNlIGlmICh0eXBlID09PSBEaXNjcmV0ZSkge1xuICAgIGNoaWxkcmVuID0gW2xlZ2VuZEdyYWRpZW50RGlzY3JldGUoc3BlYywgc2NhbGUsIGNvbmZpZywgZW5jb2RlLmdyYWRpZW50LCBlbnRyeVJlZiksIGxlZ2VuZEdyYWRpZW50TGFiZWxzKHNwZWMsIGNvbmZpZywgZW5jb2RlLmxhYmVscywgZW50cnlSZWYpXTtcbiAgfSAvLyBzeW1ib2wgbGVnZW5kXG4gIGVsc2Uge1xuICAgIC8vIGRldGVybWluZSBsZWdlbmQgc3ltYm9sIGdyb3VwIGxheW91dFxuICAgIGVudHJ5TGF5b3V0ID0gbGVnZW5kU3ltYm9sTGF5b3V0KHNwZWMsIGNvbmZpZyk7XG4gICAgY2hpbGRyZW4gPSBbbGVnZW5kU3ltYm9sR3JvdXBzKHNwZWMsIGNvbmZpZywgZW5jb2RlLCBlbnRyeVJlZiwgZGVyZWYoZW50cnlMYXlvdXQuY29sdW1ucykpXTsgLy8gcGFzcyBzeW1ib2wgc2l6ZSBpbmZvcm1hdGlvbiB0byBsZWdlbmQgZW50cnkgZ2VuZXJhdG9yXG5cbiAgICBwYXJhbXMuc2l6ZSA9IHNpemVFeHByZXNzaW9uKHNwZWMsIHNjb3BlLCBjaGlsZHJlblswXS5tYXJrcyk7XG4gIH0gLy8gZ2VuZXJhdGUgbGVnZW5kIG1hcmtzXG5cblxuICBjaGlsZHJlbiA9IFtndWlkZUdyb3VwKHtcbiAgICByb2xlOiBMZWdlbmRFbnRyeVJvbGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGU6IGVudHJ5RW5jb2RlLFxuICAgIG1hcmtzOiBjaGlsZHJlbixcbiAgICBsYXlvdXQ6IGVudHJ5TGF5b3V0LFxuICAgIGludGVyYWN0aXZlXG4gIH0pXTsgLy8gaW5jbHVkZSBsZWdlbmQgdGl0bGUgaWYgZGVmaW5lZFxuXG4gIGlmIChkYXR1bS50aXRsZSkge1xuICAgIGNoaWxkcmVuLnB1c2gobGVnZW5kVGl0bGUoc3BlYywgY29uZmlnLCBlbmNvZGUudGl0bGUsIGRhdGFSZWYpKTtcbiAgfSAvLyBwYXJzZSBsZWdlbmQgc3BlY2lmaWNhdGlvblxuXG5cbiAgcmV0dXJuIHBhcnNlTWFyayhndWlkZUdyb3VwKHtcbiAgICByb2xlOiBMZWdlbmRSb2xlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlOiBleHRlbmRFbmNvZGUoYnVpbGRMZWdlbmRFbmNvZGUoXywgc3BlYywgY29uZmlnKSwgbGVnZW5kRW5jb2RlLCBTa2lwKSxcbiAgICBtYXJrczogY2hpbGRyZW4sXG4gICAgYXJpYTogXygnYXJpYScpLFxuICAgIGRlc2NyaXB0aW9uOiBfKCdkZXNjcmlwdGlvbicpLFxuICAgIHppbmRleDogXygnemluZGV4JyksXG4gICAgbmFtZSxcbiAgICBpbnRlcmFjdGl2ZSxcbiAgICBzdHlsZVxuICB9KSwgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRUeXBlKHNwZWMsIHNjYWxlVHlwZSkge1xuICBsZXQgdHlwZSA9IHNwZWMudHlwZSB8fCBTeW1ib2xzO1xuXG4gIGlmICghc3BlYy50eXBlICYmIHNjYWxlQ291bnQoc3BlYykgPT09IDEgJiYgKHNwZWMuZmlsbCB8fCBzcGVjLnN0cm9rZSkpIHtcbiAgICB0eXBlID0gaXNDb250aW51b3VzKHNjYWxlVHlwZSkgPyBHcmFkaWVudCA6IGlzRGlzY3JldGl6aW5nKHNjYWxlVHlwZSkgPyBEaXNjcmV0ZSA6IFN5bWJvbHM7XG4gIH1cblxuICByZXR1cm4gdHlwZSAhPT0gR3JhZGllbnQgPyB0eXBlIDogaXNEaXNjcmV0aXppbmcoc2NhbGVUeXBlKSA/IERpc2NyZXRlIDogR3JhZGllbnQ7XG59XG5cbmZ1bmN0aW9uIHNjYWxlQ291bnQoc3BlYykge1xuICByZXR1cm4gTGVnZW5kU2NhbGVzLnJlZHVjZSgoY291bnQsIHR5cGUpID0+IGNvdW50ICsgKHNwZWNbdHlwZV0gPyAxIDogMCksIDApO1xufVxuXG5mdW5jdGlvbiBidWlsZExlZ2VuZEVuY29kZShfLCBzcGVjLCBjb25maWcpIHtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7fSxcbiAgICB1cGRhdGU6IHt9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIG9yaWVudDogXygnb3JpZW50JyksXG4gICAgb2Zmc2V0OiBfKCdvZmZzZXQnKSxcbiAgICBwYWRkaW5nOiBfKCdwYWRkaW5nJyksXG4gICAgdGl0bGVQYWRkaW5nOiBfKCd0aXRsZVBhZGRpbmcnKSxcbiAgICBjb3JuZXJSYWRpdXM6IF8oJ2Nvcm5lclJhZGl1cycpLFxuICAgIGZpbGw6IF8oJ2ZpbGxDb2xvcicpLFxuICAgIHN0cm9rZTogXygnc3Ryb2tlQ29sb3InKSxcbiAgICBzdHJva2VXaWR0aDogY29uZmlnLnN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2g6IGNvbmZpZy5zdHJva2VEYXNoLFxuICAgIHg6IF8oJ2xlZ2VuZFgnKSxcbiAgICB5OiBfKCdsZWdlbmRZJyksXG4gICAgLy8gYWNjZXNzaWJpbGl0eSBzdXBwb3J0XG4gICAgZm9ybWF0OiBzcGVjLmZvcm1hdCxcbiAgICBmb3JtYXRUeXBlOiBzcGVjLmZvcm1hdFR5cGVcbiAgfSk7XG4gIHJldHVybiBlbmNvZGU7XG59XG5cbmZ1bmN0aW9uIHNpemVFeHByZXNzaW9uKHNwZWMsIHNjb3BlLCBtYXJrcykge1xuICBjb25zdCBzaXplID0gZGVyZWYoZ2V0Q2hhbm5lbCgnc2l6ZScsIHNwZWMsIG1hcmtzKSksXG4gICAgICAgIHN0cm9rZVdpZHRoID0gZGVyZWYoZ2V0Q2hhbm5lbCgnc3Ryb2tlV2lkdGgnLCBzcGVjLCBtYXJrcykpLFxuICAgICAgICBmb250U2l6ZSA9IGRlcmVmKGdldEZvbnRTaXplKG1hcmtzWzFdLmVuY29kZSwgc2NvcGUsIEd1aWRlTGFiZWxTdHlsZSkpO1xuICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKGBtYXgoY2VpbChzcXJ0KCR7c2l6ZX0pKyR7c3Ryb2tlV2lkdGh9KSwke2ZvbnRTaXplfSlgLCBzY29wZSk7XG59XG5cbmZ1bmN0aW9uIGdldENoYW5uZWwobmFtZSwgc3BlYywgbWFya3MpIHtcbiAgcmV0dXJuIHNwZWNbbmFtZV0gPyBgc2NhbGUoXCIke3NwZWNbbmFtZV19XCIsZGF0dW0pYCA6IGdldEVuY29kaW5nKG5hbWUsIG1hcmtzWzBdLmVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRTaXplKGVuY29kZSwgc2NvcGUsIHN0eWxlKSB7XG4gIHJldHVybiBnZXRFbmNvZGluZygnZm9udFNpemUnLCBlbmNvZGUpIHx8IGdldFN0eWxlKCdmb250U2l6ZScsIHNjb3BlLCBzdHlsZSk7XG59XG5cbmNvbnN0IGFuZ2xlRXhwciA9IGBpdGVtLm9yaWVudD09PVwiJHtMZWZ0fVwiPy05MDppdGVtLm9yaWVudD09PVwiJHtSaWdodH1cIj85MDowYDtcbmZ1bmN0aW9uIHBhcnNlVGl0bGUgKHNwZWMsIHNjb3BlKSB7XG4gIHNwZWMgPSBpc1N0cmluZyhzcGVjKSA/IHtcbiAgICB0ZXh0OiBzcGVjXG4gIH0gOiBzcGVjO1xuXG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgc2NvcGUuY29uZmlnLnRpdGxlKSxcbiAgICAgICAgZW5jb2RlID0gc3BlYy5lbmNvZGUgfHwge30sXG4gICAgICAgIHVzZXJFbmNvZGUgPSBlbmNvZGUuZ3JvdXAgfHwge30sXG4gICAgICAgIG5hbWUgPSB1c2VyRW5jb2RlLm5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBpbnRlcmFjdGl2ZSA9IHVzZXJFbmNvZGUuaW50ZXJhY3RpdmUsXG4gICAgICAgIHN0eWxlID0gdXNlckVuY29kZS5zdHlsZSxcbiAgICAgICAgY2hpbGRyZW4gPSBbXTsgLy8gc2luZ2xlLWVsZW1lbnQgZGF0YSBzb3VyY2UgZm9yIGdyb3VwIHRpdGxlXG5cblxuICBjb25zdCBkYXR1bSA9IHt9LFxuICAgICAgICBkYXRhUmVmID0gcmVmKHNjb3BlLmFkZChDb2xsZWN0KG51bGwsIFtkYXR1bV0pKSk7IC8vIGluY2x1ZGUgdGl0bGUgdGV4dFxuXG4gIGNoaWxkcmVuLnB1c2goYnVpbGRUaXRsZShzcGVjLCBfLCB0aXRsZUVuY29kZShzcGVjKSwgZGF0YVJlZikpOyAvLyBpbmNsdWRlIHN1YnRpdGxlIHRleHRcblxuICBpZiAoc3BlYy5zdWJ0aXRsZSkge1xuICAgIGNoaWxkcmVuLnB1c2goYnVpbGRTdWJUaXRsZShzcGVjLCBfLCBlbmNvZGUuc3VidGl0bGUsIGRhdGFSZWYpKTtcbiAgfSAvLyBwYXJzZSB0aXRsZSBzcGVjaWZpY2F0aW9uXG5cblxuICByZXR1cm4gcGFyc2VNYXJrKGd1aWRlR3JvdXAoe1xuICAgIHJvbGU6IFRpdGxlUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZ3JvdXBFbmNvZGUoXywgdXNlckVuY29kZSksXG4gICAgbWFya3M6IGNoaWxkcmVuLFxuICAgIGFyaWE6IF8oJ2FyaWEnKSxcbiAgICBkZXNjcmlwdGlvbjogXygnZGVzY3JpcHRpb24nKSxcbiAgICB6aW5kZXg6IF8oJ3ppbmRleCcpLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc3R5bGVcbiAgfSksIHNjb3BlKTtcbn0gLy8gcHJvdmlkZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGl0bGUgY3VzdG9tIGVuY29kZTtcbi8vIHRoZSB0b3AtbGV2ZWwgZW5jb2RlIGJsb2NrIGhhcyBiZWVuICpkZXByZWNhdGVkKi5cblxuZnVuY3Rpb24gdGl0bGVFbmNvZGUoc3BlYykge1xuICBjb25zdCBlbmNvZGUgPSBzcGVjLmVuY29kZTtcbiAgcmV0dXJuIGVuY29kZSAmJiBlbmNvZGUudGl0bGUgfHwgZXh0ZW5kKHtcbiAgICBuYW1lOiBzcGVjLm5hbWUsXG4gICAgaW50ZXJhY3RpdmU6IHNwZWMuaW50ZXJhY3RpdmUsXG4gICAgc3R5bGU6IHNwZWMuc3R5bGVcbiAgfSwgZW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBFbmNvZGUoXywgdXNlckVuY29kZSkge1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IHt9LFxuICAgIHVwZGF0ZToge31cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgb3JpZW50OiBfKCdvcmllbnQnKSxcbiAgICBhbmNob3I6IF8oJ2FuY2hvcicpLFxuICAgIGFsaWduOiB7XG4gICAgICBzaWduYWw6IGFsaWduRXhwciQxXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgc2lnbmFsOiBhbmdsZUV4cHJcbiAgICB9LFxuICAgIGxpbWl0OiBfKCdsaW1pdCcpLFxuICAgIGZyYW1lOiBfKCdmcmFtZScpLFxuICAgIG9mZnNldDogXygnb2Zmc2V0JykgfHwgMCxcbiAgICBwYWRkaW5nOiBfKCdzdWJ0aXRsZVBhZGRpbmcnKVxuICB9KTtcbiAgcmV0dXJuIGV4dGVuZEVuY29kZShlbmNvZGUsIHVzZXJFbmNvZGUsIFNraXApO1xufVxuXG5mdW5jdGlvbiBidWlsZFRpdGxlKHNwZWMsIF8sIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgemVybyA9IHtcbiAgICB2YWx1ZTogMFxuICB9LFxuICAgICAgICB0ZXh0ID0gc3BlYy50ZXh0LFxuICAgICAgICBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9LFxuICAgIHVwZGF0ZToge1xuICAgICAgb3BhY2l0eToge1xuICAgICAgICB2YWx1ZTogMVxuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgdGV4dDogdGV4dCxcbiAgICBhbGlnbjoge1xuICAgICAgc2lnbmFsOiAnaXRlbS5tYXJrLmdyb3VwLmFsaWduJ1xuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgIHNpZ25hbDogJ2l0ZW0ubWFyay5ncm91cC5hbmdsZSdcbiAgICB9LFxuICAgIGxpbWl0OiB7XG4gICAgICBzaWduYWw6ICdpdGVtLm1hcmsuZ3JvdXAubGltaXQnXG4gICAgfSxcbiAgICBiYXNlbGluZTogJ3RvcCcsXG4gICAgZHg6IF8oJ2R4JyksXG4gICAgZHk6IF8oJ2R5JyksXG4gICAgZmlsbDogXygnY29sb3InKSxcbiAgICBmb250OiBfKCdmb250JyksXG4gICAgZm9udFNpemU6IF8oJ2ZvbnRTaXplJyksXG4gICAgZm9udFN0eWxlOiBfKCdmb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdmb250V2VpZ2h0JyksXG4gICAgbGluZUhlaWdodDogXygnbGluZUhlaWdodCcpXG4gIH0sIHtcbiAgICAvLyB1cGRhdGVcbiAgICBhbGlnbjogXygnYWxpZ24nKSxcbiAgICBhbmdsZTogXygnYW5nbGUnKSxcbiAgICBiYXNlbGluZTogXygnYmFzZWxpbmUnKVxuICB9KTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogVGl0bGVUZXh0Um9sZSxcbiAgICBzdHlsZTogR3JvdXBUaXRsZVN0eWxlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBidWlsZFN1YlRpdGxlKHNwZWMsIF8sIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgemVybyA9IHtcbiAgICB2YWx1ZTogMFxuICB9LFxuICAgICAgICB0ZXh0ID0gc3BlYy5zdWJ0aXRsZSxcbiAgICAgICAgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHtcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgdmFsdWU6IDFcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHRleHQ6IHRleHQsXG4gICAgYWxpZ246IHtcbiAgICAgIHNpZ25hbDogJ2l0ZW0ubWFyay5ncm91cC5hbGlnbidcbiAgICB9LFxuICAgIGFuZ2xlOiB7XG4gICAgICBzaWduYWw6ICdpdGVtLm1hcmsuZ3JvdXAuYW5nbGUnXG4gICAgfSxcbiAgICBsaW1pdDoge1xuICAgICAgc2lnbmFsOiAnaXRlbS5tYXJrLmdyb3VwLmxpbWl0J1xuICAgIH0sXG4gICAgYmFzZWxpbmU6ICd0b3AnLFxuICAgIGR4OiBfKCdkeCcpLFxuICAgIGR5OiBfKCdkeScpLFxuICAgIGZpbGw6IF8oJ3N1YnRpdGxlQ29sb3InKSxcbiAgICBmb250OiBfKCdzdWJ0aXRsZUZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnc3VidGl0bGVGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygnc3VidGl0bGVGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdzdWJ0aXRsZUZvbnRXZWlnaHQnKSxcbiAgICBsaW5lSGVpZ2h0OiBfKCdzdWJ0aXRsZUxpbmVIZWlnaHQnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgYWxpZ246IF8oJ2FsaWduJyksXG4gICAgYW5nbGU6IF8oJ2FuZ2xlJyksXG4gICAgYmFzZWxpbmU6IF8oJ2Jhc2VsaW5lJylcbiAgfSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IFRpdGxlU3VidGl0bGVSb2xlLFxuICAgIHN0eWxlOiBHcm91cFN1YnRpdGxlU3R5bGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0YShkYXRhLCBzY29wZSkge1xuICBjb25zdCB0cmFuc2Zvcm1zID0gW107XG5cbiAgaWYgKGRhdGEudHJhbnNmb3JtKSB7XG4gICAgZGF0YS50cmFuc2Zvcm0uZm9yRWFjaCh0eCA9PiB7XG4gICAgICB0cmFuc2Zvcm1zLnB1c2gocGFyc2VUcmFuc2Zvcm0odHgsIHNjb3BlKSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGF0YS5vbikge1xuICAgIGRhdGEub24uZm9yRWFjaChvbiA9PiB7XG4gICAgICBwYXJzZVRyaWdnZXIob24sIHNjb3BlLCBkYXRhLm5hbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgc2NvcGUuYWRkRGF0YVBpcGVsaW5lKGRhdGEubmFtZSwgYW5hbHl6ZShkYXRhLCBzY29wZSwgdHJhbnNmb3JtcykpO1xufVxuLyoqXG4gKiBBbmFseXplIGEgZGF0YSBwaXBlbGluZSwgYWRkIG5lZWRlZCBvcGVyYXRvcnMuXG4gKi9cblxuZnVuY3Rpb24gYW5hbHl6ZShkYXRhLCBzY29wZSwgb3BzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBsZXQgc291cmNlID0gbnVsbCxcbiAgICAgIG1vZGlmeSA9IGZhbHNlLFxuICAgICAgZ2VuZXJhdGUgPSBmYWxzZSxcbiAgICAgIHVwc3RyZWFtLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICB0LFxuICAgICAgbTtcblxuICBpZiAoZGF0YS52YWx1ZXMpIHtcbiAgICAvLyBoYXJkLXdpcmVkIGlucHV0IGRhdGEgc2V0XG4gICAgaWYgKGlzU2lnbmFsKGRhdGEudmFsdWVzKSB8fCBoYXNTaWduYWwoZGF0YS5mb3JtYXQpKSB7XG4gICAgICAvLyBpZiBlaXRoZXIgdmFsdWVzIGlzIHNpZ25hbCBvciBmb3JtYXQgaGFzIHNpZ25hbCwgdXNlIGR5bmFtaWMgbG9hZGVyXG4gICAgICBvdXRwdXQucHVzaChsb2FkKHNjb3BlLCBkYXRhKSk7XG4gICAgICBvdXRwdXQucHVzaChzb3VyY2UgPSBjb2xsZWN0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIGluZ2VzdCB1cG9uIGRhdGFmbG93IGluaXRcbiAgICAgIG91dHB1dC5wdXNoKHNvdXJjZSA9IGNvbGxlY3Qoe1xuICAgICAgICAkaW5nZXN0OiBkYXRhLnZhbHVlcyxcbiAgICAgICAgJGZvcm1hdDogZGF0YS5mb3JtYXRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YS51cmwpIHtcbiAgICAvLyBsb2FkIGRhdGEgZnJvbSBleHRlcm5hbCBzb3VyY2VcbiAgICBpZiAoaGFzU2lnbmFsKGRhdGEudXJsKSB8fCBoYXNTaWduYWwoZGF0YS5mb3JtYXQpKSB7XG4gICAgICAvLyBpZiBlaXRoZXIgdXJsIG9yIGZvcm1hdCBoYXMgc2lnbmFsLCB1c2UgZHluYW1pYyBsb2FkZXJcbiAgICAgIG91dHB1dC5wdXNoKGxvYWQoc2NvcGUsIGRhdGEpKTtcbiAgICAgIG91dHB1dC5wdXNoKHNvdXJjZSA9IGNvbGxlY3QoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSwgcmVxdWVzdCBsb2FkIHVwb24gZGF0YWZsb3cgaW5pdFxuICAgICAgb3V0cHV0LnB1c2goc291cmNlID0gY29sbGVjdCh7XG4gICAgICAgICRyZXF1ZXN0OiBkYXRhLnVybCxcbiAgICAgICAgJGZvcm1hdDogZGF0YS5mb3JtYXRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YS5zb3VyY2UpIHtcbiAgICAvLyBkZXJpdmVzIGZyb20gb25lIG9yIG1vcmUgb3RoZXIgZGF0YSBzZXRzXG4gICAgc291cmNlID0gdXBzdHJlYW0gPSBhcnJheShkYXRhLnNvdXJjZSkubWFwKGQgPT4gcmVmKHNjb3BlLmdldERhdGEoZCkub3V0cHV0KSk7XG4gICAgb3V0cHV0LnB1c2gobnVsbCk7IC8vIHBvcHVsYXRlIGxhdGVyXG4gIH0gLy8gc2NhbiBkYXRhIHRyYW5zZm9ybXMsIGFkZCBjb2xsZWN0b3JzIGFzIG5lZWRlZFxuXG5cbiAgZm9yIChpID0gMCwgbiA9IG9wcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB0ID0gb3BzW2ldO1xuICAgIG0gPSB0Lm1ldGFkYXRhO1xuXG4gICAgaWYgKCFzb3VyY2UgJiYgIW0uc291cmNlKSB7XG4gICAgICBvdXRwdXQucHVzaChzb3VyY2UgPSBjb2xsZWN0KCkpO1xuICAgIH1cblxuICAgIG91dHB1dC5wdXNoKHQpO1xuICAgIGlmIChtLmdlbmVyYXRlcykgZ2VuZXJhdGUgPSB0cnVlO1xuICAgIGlmIChtLm1vZGlmaWVzICYmICFnZW5lcmF0ZSkgbW9kaWZ5ID0gdHJ1ZTtcbiAgICBpZiAobS5zb3VyY2UpIHNvdXJjZSA9IHQ7ZWxzZSBpZiAobS5jaGFuZ2VzKSBzb3VyY2UgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVwc3RyZWFtKSB7XG4gICAgbiA9IHVwc3RyZWFtLmxlbmd0aCAtIDE7XG4gICAgb3V0cHV0WzBdID0gUmVsYXkoe1xuICAgICAgZGVyaXZlOiBtb2RpZnksXG4gICAgICBwdWxzZTogbiA/IHVwc3RyZWFtIDogdXBzdHJlYW1bMF1cbiAgICB9KTtcblxuICAgIGlmIChtb2RpZnkgfHwgbikge1xuICAgICAgLy8gY29sbGVjdCBkZXJpdmVkIGFuZCBtdWx0aS1wdWxzZSB0dXBsZXNcbiAgICAgIG91dHB1dC5zcGxpY2UoMSwgMCwgY29sbGVjdCgpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNvdXJjZSkgb3V0cHV0LnB1c2goY29sbGVjdCgpKTtcbiAgb3V0cHV0LnB1c2goU2lldmUoe30pKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gY29sbGVjdCh2YWx1ZXMpIHtcbiAgY29uc3QgcyA9IENvbGxlY3Qoe30sIHZhbHVlcyk7XG4gIHMubWV0YWRhdGEgPSB7XG4gICAgc291cmNlOiB0cnVlXG4gIH07XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBsb2FkKHNjb3BlLCBkYXRhKSB7XG4gIHJldHVybiBMb2FkKHtcbiAgICB1cmw6IGRhdGEudXJsID8gc2NvcGUucHJvcGVydHkoZGF0YS51cmwpIDogdW5kZWZpbmVkLFxuICAgIGFzeW5jOiBkYXRhLmFzeW5jID8gc2NvcGUucHJvcGVydHkoZGF0YS5hc3luYykgOiB1bmRlZmluZWQsXG4gICAgdmFsdWVzOiBkYXRhLnZhbHVlcyA/IHNjb3BlLnByb3BlcnR5KGRhdGEudmFsdWVzKSA6IHVuZGVmaW5lZCxcbiAgICBmb3JtYXQ6IHNjb3BlLm9iamVjdFByb3BlcnR5KGRhdGEuZm9ybWF0KVxuICB9KTtcbn1cblxuY29uc3QgaXNYID0gb3JpZW50ID0+IG9yaWVudCA9PT0gQm90dG9tIHx8IG9yaWVudCA9PT0gVG9wOyAvLyBnZXQgc2lnbiBjb2VmZmljaWVudCBiYXNlZCBvbiBheGlzIG9yaWVudFxuXG5cbmNvbnN0IGdldFNpZ24gPSAob3JpZW50LCBhLCBiKSA9PiBpc1NpZ25hbChvcmllbnQpID8gaWZMZWZ0VG9wRXhwcihvcmllbnQuc2lnbmFsLCBhLCBiKSA6IG9yaWVudCA9PT0gTGVmdCB8fCBvcmllbnQgPT09IFRvcCA/IGEgOiBiOyAvLyBjb25kaXRpb24gb24gYXhpcyB4LWRpcmVjdGlvblxuXG5jb25zdCBpZlggPSAob3JpZW50LCBhLCBiKSA9PiBpc1NpZ25hbChvcmllbnQpID8gaWZYRW5jKG9yaWVudC5zaWduYWwsIGEsIGIpIDogaXNYKG9yaWVudCkgPyBhIDogYjsgLy8gY29uZGl0aW9uIG9uIGF4aXMgeS1kaXJlY3Rpb25cblxuY29uc3QgaWZZID0gKG9yaWVudCwgYSwgYikgPT4gaXNTaWduYWwob3JpZW50KSA/IGlmWUVuYyhvcmllbnQuc2lnbmFsLCBhLCBiKSA6IGlzWChvcmllbnQpID8gYiA6IGE7XG5jb25zdCBpZlRvcCA9IChvcmllbnQsIGEsIGIpID0+IGlzU2lnbmFsKG9yaWVudCkgPyBpZlRvcEV4cHIob3JpZW50LnNpZ25hbCwgYSwgYikgOiBvcmllbnQgPT09IFRvcCA/IHtcbiAgdmFsdWU6IGFcbn0gOiB7XG4gIHZhbHVlOiBiXG59O1xuY29uc3QgaWZSaWdodCA9IChvcmllbnQsIGEsIGIpID0+IGlzU2lnbmFsKG9yaWVudCkgPyBpZlJpZ2h0RXhwcihvcmllbnQuc2lnbmFsLCBhLCBiKSA6IG9yaWVudCA9PT0gUmlnaHQgPyB7XG4gIHZhbHVlOiBhXG59IDoge1xuICB2YWx1ZTogYlxufTtcblxuY29uc3QgaWZYRW5jID0gKCRvcmllbnQsIGEsIGIpID0+IGlmRW5jKGAkeyRvcmllbnR9ID09PSAnJHtUb3B9JyB8fCAkeyRvcmllbnR9ID09PSAnJHtCb3R0b219J2AsIGEsIGIpO1xuXG5jb25zdCBpZllFbmMgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFbmMoYCR7JG9yaWVudH0gIT09ICcke1RvcH0nICYmICR7JG9yaWVudH0gIT09ICcke0JvdHRvbX0nYCwgYSwgYik7XG5cbmNvbnN0IGlmTGVmdFRvcEV4cHIgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFeHByKGAkeyRvcmllbnR9ID09PSAnJHtMZWZ0fScgfHwgJHskb3JpZW50fSA9PT0gJyR7VG9wfSdgLCBhLCBiKTtcblxuY29uc3QgaWZUb3BFeHByID0gKCRvcmllbnQsIGEsIGIpID0+IGlmRXhwcihgJHskb3JpZW50fSA9PT0gJyR7VG9wfSdgLCBhLCBiKTtcblxuY29uc3QgaWZSaWdodEV4cHIgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFeHByKGAkeyRvcmllbnR9ID09PSAnJHtSaWdodH0nYCwgYSwgYik7XG5cbmNvbnN0IGlmRW5jID0gKHRlc3QsIGEsIGIpID0+IHtcbiAgLy8gZW5zdXJlIGlucHV0cyBhcmUgZW5jb2RlciBvYmplY3RzIChvciBudWxsKVxuICBhID0gYSAhPSBudWxsID8gZW5jb2RlcihhKSA6IGE7XG4gIGIgPSBiICE9IG51bGwgPyBlbmNvZGVyKGIpIDogYjtcblxuICBpZiAoaXNTaW1wbGUoYSkgJiYgaXNTaW1wbGUoYikpIHtcbiAgICAvLyBpZiBwb3NzaWJsZSBnZW5lcmF0ZSBzaW1wbGUgc2lnbmFsIGV4cHJlc3Npb25cbiAgICBhID0gYSA/IGEuc2lnbmFsIHx8IHN0cmluZ1ZhbHVlKGEudmFsdWUpIDogbnVsbDtcbiAgICBiID0gYiA/IGIuc2lnbmFsIHx8IHN0cmluZ1ZhbHVlKGIudmFsdWUpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmFsOiBgJHt0ZXN0fSA/ICgke2F9KSA6ICgke2J9KWBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSBnZW5lcmF0ZSBydWxlIHNldFxuICAgIHJldHVybiBbZXh0ZW5kKHtcbiAgICAgIHRlc3RcbiAgICB9LCBhKV0uY29uY2F0KGIgfHwgW10pO1xuICB9XG59O1xuXG5jb25zdCBpc1NpbXBsZSA9IGVuYyA9PiBlbmMgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyhlbmMpLmxlbmd0aCA9PT0gMTtcblxuY29uc3QgaWZFeHByID0gKHRlc3QsIGEsIGIpID0+ICh7XG4gIHNpZ25hbDogYCR7dGVzdH0gPyAoJHt0b0V4cHIoYSl9KSA6ICgke3RvRXhwcihiKX0pYFxufSk7XG5cbmNvbnN0IGlmT3JpZW50ID0gKCRvcmllbnQsIHQsIGIsIGwsIHIpID0+ICh7XG4gIHNpZ25hbDogKGwgIT0gbnVsbCA/IGAkeyRvcmllbnR9ID09PSAnJHtMZWZ0fScgPyAoJHt0b0V4cHIobCl9KSA6IGAgOiAnJykgKyAoYiAhPSBudWxsID8gYCR7JG9yaWVudH0gPT09ICcke0JvdHRvbX0nID8gKCR7dG9FeHByKGIpfSkgOiBgIDogJycpICsgKHIgIT0gbnVsbCA/IGAkeyRvcmllbnR9ID09PSAnJHtSaWdodH0nID8gKCR7dG9FeHByKHIpfSkgOiBgIDogJycpICsgKHQgIT0gbnVsbCA/IGAkeyRvcmllbnR9ID09PSAnJHtUb3B9JyA/ICgke3RvRXhwcih0KX0pIDogYCA6ICcnKSArICcobnVsbCknXG59KTtcblxuY29uc3QgdG9FeHByID0gdiA9PiBpc1NpZ25hbCh2KSA/IHYuc2lnbmFsIDogdiA9PSBudWxsID8gbnVsbCA6IHN0cmluZ1ZhbHVlKHYpO1xuXG5jb25zdCBtdWx0ID0gKHNpZ24sIHZhbHVlKSA9PiB2YWx1ZSA9PT0gMCA/IDAgOiBpc1NpZ25hbChzaWduKSA/IHtcbiAgc2lnbmFsOiBgKCR7c2lnbi5zaWduYWx9KSAqICR7dmFsdWV9YFxufSA6IHtcbiAgdmFsdWU6IHNpZ24gKiB2YWx1ZVxufTtcbmNvbnN0IHBhdGNoID0gKHZhbHVlLCBiYXNlKSA9PiB7XG4gIGNvbnN0IHMgPSB2YWx1ZS5zaWduYWw7XG4gIHJldHVybiBzICYmIHMuZW5kc1dpdGgoJyhudWxsKScpID8ge1xuICAgIHNpZ25hbDogcy5zbGljZSgwLCAtNikgKyBiYXNlLnNpZ25hbFxuICB9IDogdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBmYWxsYmFjayhwcm9wLCBjb25maWcsIGF4aXNDb25maWcsIHN0eWxlKSB7XG4gIGxldCBzdHlsZVByb3A7XG5cbiAgaWYgKGNvbmZpZyAmJiBoYXNPd25Qcm9wZXJ0eShjb25maWcsIHByb3ApKSB7XG4gICAgcmV0dXJuIGNvbmZpZ1twcm9wXTtcbiAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShheGlzQ29uZmlnLCBwcm9wKSkge1xuICAgIHJldHVybiBheGlzQ29uZmlnW3Byb3BdO1xuICB9IGVsc2UgaWYgKHByb3Auc3RhcnRzV2l0aCgndGl0bGUnKSkge1xuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSAndGl0bGVDb2xvcic6XG4gICAgICAgIHN0eWxlUHJvcCA9ICdmaWxsJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RpdGxlRm9udCc6XG4gICAgICBjYXNlICd0aXRsZUZvbnRTaXplJzpcbiAgICAgIGNhc2UgJ3RpdGxlRm9udFdlaWdodCc6XG4gICAgICAgIHN0eWxlUHJvcCA9IHByb3BbNV0udG9Mb3dlckNhc2UoKSArIHByb3Auc2xpY2UoNik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlW0d1aWRlVGl0bGVTdHlsZV1bc3R5bGVQcm9wXTtcbiAgfSBlbHNlIGlmIChwcm9wLnN0YXJ0c1dpdGgoJ2xhYmVsJykpIHtcbiAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgIGNhc2UgJ2xhYmVsQ29sb3InOlxuICAgICAgICBzdHlsZVByb3AgPSAnZmlsbCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsYWJlbEZvbnQnOlxuICAgICAgY2FzZSAnbGFiZWxGb250U2l6ZSc6XG4gICAgICAgIHN0eWxlUHJvcCA9IHByb3BbNV0udG9Mb3dlckNhc2UoKSArIHByb3Auc2xpY2UoNik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlW0d1aWRlTGFiZWxTdHlsZV1bc3R5bGVQcm9wXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBrZXlzKG9iamVjdHMpIHtcbiAgY29uc3QgbWFwID0ge307XG5cbiAgZm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuICAgIGlmICghb2JqKSBjb250aW51ZTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikgbWFwW2tleV0gPSAxO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59XG5cbmZ1bmN0aW9uIGF4aXNDb25maWcgKHNwZWMsIHNjb3BlKSB7XG4gIHZhciBjb25maWcgPSBzY29wZS5jb25maWcsXG4gICAgICBzdHlsZSA9IGNvbmZpZy5zdHlsZSxcbiAgICAgIGF4aXMgPSBjb25maWcuYXhpcyxcbiAgICAgIGJhbmQgPSBzY29wZS5zY2FsZVR5cGUoc3BlYy5zY2FsZSkgPT09ICdiYW5kJyAmJiBjb25maWcuYXhpc0JhbmQsXG4gICAgICBvcmllbnQgPSBzcGVjLm9yaWVudCxcbiAgICAgIHh5LFxuICAgICAgb3IsXG4gICAgICBrZXk7XG5cbiAgaWYgKGlzU2lnbmFsKG9yaWVudCkpIHtcbiAgICBjb25zdCB4eUtleXMgPSBrZXlzKFtjb25maWcuYXhpc1gsIGNvbmZpZy5heGlzWV0pLFxuICAgICAgICAgIG9yaWVudEtleXMgPSBrZXlzKFtjb25maWcuYXhpc1RvcCwgY29uZmlnLmF4aXNCb3R0b20sIGNvbmZpZy5heGlzTGVmdCwgY29uZmlnLmF4aXNSaWdodF0pO1xuICAgIHh5ID0ge307XG5cbiAgICBmb3IgKGtleSBvZiB4eUtleXMpIHtcbiAgICAgIHh5W2tleV0gPSBpZlgob3JpZW50LCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzWCwgYXhpcywgc3R5bGUpLCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzWSwgYXhpcywgc3R5bGUpKTtcbiAgICB9XG5cbiAgICBvciA9IHt9O1xuXG4gICAgZm9yIChrZXkgb2Ygb3JpZW50S2V5cykge1xuICAgICAgb3Jba2V5XSA9IGlmT3JpZW50KG9yaWVudC5zaWduYWwsIGZhbGxiYWNrKGtleSwgY29uZmlnLmF4aXNUb3AsIGF4aXMsIHN0eWxlKSwgZmFsbGJhY2soa2V5LCBjb25maWcuYXhpc0JvdHRvbSwgYXhpcywgc3R5bGUpLCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzTGVmdCwgYXhpcywgc3R5bGUpLCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzUmlnaHQsIGF4aXMsIHN0eWxlKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHh5ID0gb3JpZW50ID09PSBUb3AgfHwgb3JpZW50ID09PSBCb3R0b20gPyBjb25maWcuYXhpc1ggOiBjb25maWcuYXhpc1k7XG4gICAgb3IgPSBjb25maWdbJ2F4aXMnICsgb3JpZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBvcmllbnQuc2xpY2UoMSldO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0geHkgfHwgb3IgfHwgYmFuZCA/IGV4dGVuZCh7fSwgYXhpcywgeHksIG9yLCBiYW5kKSA6IGF4aXM7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGF4aXNEb21haW4gKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZikge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIG9yaWVudCA9IHNwZWMub3JpZW50O1xuXG4gIGxldCBlbnRlciwgdXBkYXRlO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmVcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHN0cm9rZTogXygnZG9tYWluQ29sb3InKSxcbiAgICBzdHJva2VDYXA6IF8oJ2RvbWFpbkNhcCcpLFxuICAgIHN0cm9rZURhc2g6IF8oJ2RvbWFpbkRhc2gnKSxcbiAgICBzdHJva2VEYXNoT2Zmc2V0OiBfKCdkb21haW5EYXNoT2Zmc2V0JyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ2RvbWFpbldpZHRoJyksXG4gICAgc3Ryb2tlT3BhY2l0eTogXygnZG9tYWluT3BhY2l0eScpXG4gIH0pO1xuICBjb25zdCBwb3MwID0gcG9zaXRpb24oc3BlYywgMCk7XG4gIGNvbnN0IHBvczEgPSBwb3NpdGlvbihzcGVjLCAxKTtcbiAgZW50ZXIueCA9IHVwZGF0ZS54ID0gaWZYKG9yaWVudCwgcG9zMCwgemVybyk7XG4gIGVudGVyLngyID0gdXBkYXRlLngyID0gaWZYKG9yaWVudCwgcG9zMSk7XG4gIGVudGVyLnkgPSB1cGRhdGUueSA9IGlmWShvcmllbnQsIHBvczAsIHplcm8pO1xuICBlbnRlci55MiA9IHVwZGF0ZS55MiA9IGlmWShvcmllbnQsIHBvczEpO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBSdWxlTWFyayxcbiAgICByb2xlOiBBeGlzRG9tYWluUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb24oc3BlYywgcG9zKSB7XG4gIHJldHVybiB7XG4gICAgc2NhbGU6IHNwZWMuc2NhbGUsXG4gICAgcmFuZ2U6IHBvc1xuICB9O1xufVxuXG5mdW5jdGlvbiBheGlzR3JpZCAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmLCBiYW5kKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgb3JpZW50ID0gc3BlYy5vcmllbnQsXG4gICAgICAgIHZzY2FsZSA9IHNwZWMuZ3JpZFNjYWxlLFxuICAgICAgICBzaWduID0gZ2V0U2lnbihvcmllbnQsIDEsIC0xKSxcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUoc3BlYy5vZmZzZXQsIHNpZ24pO1xuXG4gIGxldCBlbnRlciwgZXhpdCwgdXBkYXRlO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmVcbiAgICB9LFxuICAgIGV4aXQ6IGV4aXQgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBzdHJva2U6IF8oJ2dyaWRDb2xvcicpLFxuICAgIHN0cm9rZUNhcDogXygnZ3JpZENhcCcpLFxuICAgIHN0cm9rZURhc2g6IF8oJ2dyaWREYXNoJyksXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogXygnZ3JpZERhc2hPZmZzZXQnKSxcbiAgICBzdHJva2VPcGFjaXR5OiBfKCdncmlkT3BhY2l0eScpLFxuICAgIHN0cm9rZVdpZHRoOiBfKCdncmlkV2lkdGgnKVxuICB9KTtcbiAgY29uc3QgdGlja1BvcyA9IHtcbiAgICBzY2FsZTogc3BlYy5zY2FsZSxcbiAgICBmaWVsZDogVmFsdWUsXG4gICAgYmFuZDogYmFuZC5iYW5kLFxuICAgIGV4dHJhOiBiYW5kLmV4dHJhLFxuICAgIG9mZnNldDogYmFuZC5vZmZzZXQsXG4gICAgcm91bmQ6IF8oJ3RpY2tSb3VuZCcpXG4gIH07XG4gIGNvbnN0IHN6ID0gaWZYKG9yaWVudCwge1xuICAgIHNpZ25hbDogJ2hlaWdodCdcbiAgfSwge1xuICAgIHNpZ25hbDogJ3dpZHRoJ1xuICB9KTtcbiAgY29uc3QgZ3JpZFN0YXJ0ID0gdnNjYWxlID8ge1xuICAgIHNjYWxlOiB2c2NhbGUsXG4gICAgcmFuZ2U6IDAsXG4gICAgbXVsdDogc2lnbixcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9IDoge1xuICAgIHZhbHVlOiAwLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG4gIGNvbnN0IGdyaWRFbmQgPSB2c2NhbGUgPyB7XG4gICAgc2NhbGU6IHZzY2FsZSxcbiAgICByYW5nZTogMSxcbiAgICBtdWx0OiBzaWduLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH0gOiBleHRlbmQoc3osIHtcbiAgICBtdWx0OiBzaWduLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH0pO1xuICBlbnRlci54ID0gdXBkYXRlLnggPSBpZlgob3JpZW50LCB0aWNrUG9zLCBncmlkU3RhcnQpO1xuICBlbnRlci55ID0gdXBkYXRlLnkgPSBpZlkob3JpZW50LCB0aWNrUG9zLCBncmlkU3RhcnQpO1xuICBlbnRlci54MiA9IHVwZGF0ZS54MiA9IGlmWShvcmllbnQsIGdyaWRFbmQpO1xuICBlbnRlci55MiA9IHVwZGF0ZS55MiA9IGlmWChvcmllbnQsIGdyaWRFbmQpO1xuICBleGl0LnggPSBpZlgob3JpZW50LCB0aWNrUG9zKTtcbiAgZXhpdC55ID0gaWZZKG9yaWVudCwgdGlja1Bvcyk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJ1bGVNYXJrLFxuICAgIHJvbGU6IEF4aXNHcmlkUm9sZSxcbiAgICBrZXk6IFZhbHVlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBvZmZzZXRWYWx1ZShvZmZzZXQsIHNpZ24pIHtcbiAgaWYgKHNpZ24gPT09IDEpIDsgZWxzZSBpZiAoIWlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBpc1NpZ25hbChzaWduKSA/IHtcbiAgICAgIHNpZ25hbDogYCgke3NpZ24uc2lnbmFsfSkgKiAoJHtvZmZzZXQgfHwgMH0pYFxuICAgIH0gOiBzaWduICogKG9mZnNldCB8fCAwKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZW50cnkgPSBvZmZzZXQgPSBleHRlbmQoe30sIG9mZnNldCk7XG5cbiAgICB3aGlsZSAoZW50cnkubXVsdCAhPSBudWxsKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KGVudHJ5Lm11bHQpKSB7XG4gICAgICAgIGVudHJ5Lm11bHQgPSBpc1NpZ25hbChzaWduKSAvLyBubyBvZmZzZXQgaWYgc2lnbiA9PT0gMVxuICAgICAgICA/IHtcbiAgICAgICAgICBzaWduYWw6IGAoJHtlbnRyeS5tdWx0fSkgKiAoJHtzaWduLnNpZ25hbH0pYFxuICAgICAgICB9IDogZW50cnkubXVsdCAqIHNpZ247XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeSA9IGVudHJ5Lm11bHQgPSBleHRlbmQoe30sIGVudHJ5Lm11bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVudHJ5Lm11bHQgPSBzaWduO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gYXhpc1RpY2tzIChzcGVjLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYsIHNpemUsIGJhbmQpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgICAgICBvcmllbnQgPSBzcGVjLm9yaWVudCxcbiAgICAgICAgc2lnbiA9IGdldFNpZ24ob3JpZW50LCAtMSwgMSk7XG5cbiAgbGV0IGVudGVyLCBleGl0LCB1cGRhdGU7XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IG9uZVxuICAgIH0sXG4gICAgZXhpdDogZXhpdCA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHN0cm9rZTogXygndGlja0NvbG9yJyksXG4gICAgc3Ryb2tlQ2FwOiBfKCd0aWNrQ2FwJyksXG4gICAgc3Ryb2tlRGFzaDogXygndGlja0Rhc2gnKSxcbiAgICBzdHJva2VEYXNoT2Zmc2V0OiBfKCd0aWNrRGFzaE9mZnNldCcpLFxuICAgIHN0cm9rZU9wYWNpdHk6IF8oJ3RpY2tPcGFjaXR5JyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ3RpY2tXaWR0aCcpXG4gIH0pO1xuICBjb25zdCB0aWNrU2l6ZSA9IGVuY29kZXIoc2l6ZSk7XG4gIHRpY2tTaXplLm11bHQgPSBzaWduO1xuICBjb25zdCB0aWNrUG9zID0ge1xuICAgIHNjYWxlOiBzcGVjLnNjYWxlLFxuICAgIGZpZWxkOiBWYWx1ZSxcbiAgICBiYW5kOiBiYW5kLmJhbmQsXG4gICAgZXh0cmE6IGJhbmQuZXh0cmEsXG4gICAgb2Zmc2V0OiBiYW5kLm9mZnNldCxcbiAgICByb3VuZDogXygndGlja1JvdW5kJylcbiAgfTtcbiAgdXBkYXRlLnkgPSBlbnRlci55ID0gaWZYKG9yaWVudCwgemVybywgdGlja1Bvcyk7XG4gIHVwZGF0ZS55MiA9IGVudGVyLnkyID0gaWZYKG9yaWVudCwgdGlja1NpemUpO1xuICBleGl0LnggPSBpZlgob3JpZW50LCB0aWNrUG9zKTtcbiAgdXBkYXRlLnggPSBlbnRlci54ID0gaWZZKG9yaWVudCwgemVybywgdGlja1Bvcyk7XG4gIHVwZGF0ZS54MiA9IGVudGVyLngyID0gaWZZKG9yaWVudCwgdGlja1NpemUpO1xuICBleGl0LnkgPSBpZlkob3JpZW50LCB0aWNrUG9zKTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogUnVsZU1hcmssXG4gICAgcm9sZTogQXhpc1RpY2tSb2xlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoRXhwcihzY2FsZSwgdGhyZXNob2xkLCBhLCBiLCBjKSB7XG4gIHJldHVybiB7XG4gICAgc2lnbmFsOiAnZmx1c2gocmFuZ2UoXCInICsgc2NhbGUgKyAnXCIpLCAnICsgJ3NjYWxlKFwiJyArIHNjYWxlICsgJ1wiLCBkYXR1bS52YWx1ZSksICcgKyB0aHJlc2hvbGQgKyAnLCcgKyBhICsgJywnICsgYiArICcsJyArIGMgKyAnKSdcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXhpc0xhYmVscyAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmLCBzaXplLCBiYW5kKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgb3JpZW50ID0gc3BlYy5vcmllbnQsXG4gICAgICAgIHNjYWxlID0gc3BlYy5zY2FsZSxcbiAgICAgICAgc2lnbiA9IGdldFNpZ24ob3JpZW50LCAtMSwgMSksXG4gICAgICAgIGZsdXNoID0gZGVyZWYoXygnbGFiZWxGbHVzaCcpKSxcbiAgICAgICAgZmx1c2hPZmZzZXQgPSBkZXJlZihfKCdsYWJlbEZsdXNoT2Zmc2V0JykpLFxuICAgICAgICBsYWJlbEFsaWduID0gXygnbGFiZWxBbGlnbicpLFxuICAgICAgICBsYWJlbEJhc2VsaW5lID0gXygnbGFiZWxCYXNlbGluZScpO1xuXG4gIGxldCBmbHVzaE9uID0gZmx1c2ggPT09IDAgfHwgISFmbHVzaCxcbiAgICAgIHVwZGF0ZTtcbiAgY29uc3QgdGlja1NpemUgPSBlbmNvZGVyKHNpemUpO1xuICB0aWNrU2l6ZS5tdWx0ID0gc2lnbjtcbiAgdGlja1NpemUub2Zmc2V0ID0gZW5jb2RlcihfKCdsYWJlbFBhZGRpbmcnKSB8fCAwKTtcbiAgdGlja1NpemUub2Zmc2V0Lm11bHQgPSBzaWduO1xuICBjb25zdCB0aWNrUG9zID0ge1xuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBmaWVsZDogVmFsdWUsXG4gICAgYmFuZDogMC41LFxuICAgIG9mZnNldDogZXh0ZW5kT2Zmc2V0KGJhbmQub2Zmc2V0LCBfKCdsYWJlbE9mZnNldCcpKVxuICB9O1xuICBjb25zdCBhbGlnbiA9IGlmWChvcmllbnQsIGZsdXNoT24gPyBmbHVzaEV4cHIoc2NhbGUsIGZsdXNoLCAnXCJsZWZ0XCInLCAnXCJyaWdodFwiJywgJ1wiY2VudGVyXCInKSA6IHtcbiAgICB2YWx1ZTogJ2NlbnRlcidcbiAgfSwgaWZSaWdodChvcmllbnQsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBiYXNlbGluZSA9IGlmWChvcmllbnQsIGlmVG9wKG9yaWVudCwgJ2JvdHRvbScsICd0b3AnKSwgZmx1c2hPbiA/IGZsdXNoRXhwcihzY2FsZSwgZmx1c2gsICdcInRvcFwiJywgJ1wiYm90dG9tXCInLCAnXCJtaWRkbGVcIicpIDoge1xuICAgIHZhbHVlOiAnbWlkZGxlJ1xuICB9KTtcbiAgY29uc3Qgb2Zmc2V0RXhwciA9IGZsdXNoRXhwcihzY2FsZSwgZmx1c2gsIGAtKCR7Zmx1c2hPZmZzZXR9KWAsIGZsdXNoT2Zmc2V0LCAwKTtcbiAgZmx1c2hPbiA9IGZsdXNoT24gJiYgZmx1c2hPZmZzZXQ7XG4gIGNvbnN0IGVudGVyID0ge1xuICAgIG9wYWNpdHk6IHplcm8sXG4gICAgeDogaWZYKG9yaWVudCwgdGlja1BvcywgdGlja1NpemUpLFxuICAgIHk6IGlmWShvcmllbnQsIHRpY2tQb3MsIHRpY2tTaXplKVxuICB9O1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyLFxuICAgIHVwZGF0ZTogdXBkYXRlID0ge1xuICAgICAgb3BhY2l0eTogb25lLFxuICAgICAgdGV4dDoge1xuICAgICAgICBmaWVsZDogTGFiZWxcbiAgICAgIH0sXG4gICAgICB4OiBlbnRlci54LFxuICAgICAgeTogZW50ZXIueSxcbiAgICAgIGFsaWduLFxuICAgICAgYmFzZWxpbmVcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm8sXG4gICAgICB4OiBlbnRlci54LFxuICAgICAgeTogZW50ZXIueVxuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgZHg6ICFsYWJlbEFsaWduICYmIGZsdXNoT24gPyBpZlgob3JpZW50LCBvZmZzZXRFeHByKSA6IG51bGwsXG4gICAgZHk6ICFsYWJlbEJhc2VsaW5lICYmIGZsdXNoT24gPyBpZlkob3JpZW50LCBvZmZzZXRFeHByKSA6IG51bGxcbiAgfSk7XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGFuZ2xlOiBfKCdsYWJlbEFuZ2xlJyksXG4gICAgZmlsbDogXygnbGFiZWxDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCdsYWJlbE9wYWNpdHknKSxcbiAgICBmb250OiBfKCdsYWJlbEZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnbGFiZWxGb250U2l6ZScpLFxuICAgIGZvbnRXZWlnaHQ6IF8oJ2xhYmVsRm9udFdlaWdodCcpLFxuICAgIGZvbnRTdHlsZTogXygnbGFiZWxGb250U3R5bGUnKSxcbiAgICBsaW1pdDogXygnbGFiZWxMaW1pdCcpLFxuICAgIGxpbmVIZWlnaHQ6IF8oJ2xhYmVsTGluZUhlaWdodCcpXG4gIH0sIHtcbiAgICBhbGlnbjogbGFiZWxBbGlnbixcbiAgICBiYXNlbGluZTogbGFiZWxCYXNlbGluZVxuICB9KTtcblxuICBjb25zdCBib3VuZCA9IF8oJ2xhYmVsQm91bmQnKTtcblxuICBsZXQgb3ZlcmxhcCA9IF8oJ2xhYmVsT3ZlcmxhcCcpOyAvLyBpZiBvdmVybGFwIG1ldGhvZCBvciBib3VuZCBkZWZpbmVkLCByZXF1ZXN0IGxhYmVsIG92ZXJsYXAgcmVtb3ZhbFxuXG5cbiAgb3ZlcmxhcCA9IG92ZXJsYXAgfHwgYm91bmQgPyB7XG4gICAgc2VwYXJhdGlvbjogXygnbGFiZWxTZXBhcmF0aW9uJyksXG4gICAgbWV0aG9kOiBvdmVybGFwLFxuICAgIG9yZGVyOiAnZGF0dW0uaW5kZXgnLFxuICAgIGJvdW5kOiBib3VuZCA/IHtcbiAgICAgIHNjYWxlLFxuICAgICAgb3JpZW50LFxuICAgICAgdG9sZXJhbmNlOiBib3VuZFxuICAgIH0gOiBudWxsXG4gIH0gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHVwZGF0ZS5hbGlnbiAhPT0gYWxpZ24pIHtcbiAgICB1cGRhdGUuYWxpZ24gPSBwYXRjaCh1cGRhdGUuYWxpZ24sIGFsaWduKTtcbiAgfVxuXG4gIGlmICh1cGRhdGUuYmFzZWxpbmUgIT09IGJhc2VsaW5lKSB7XG4gICAgdXBkYXRlLmJhc2VsaW5lID0gcGF0Y2godXBkYXRlLmJhc2VsaW5lLCBiYXNlbGluZSk7XG4gIH1cblxuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBUZXh0TWFyayxcbiAgICByb2xlOiBBeGlzTGFiZWxSb2xlLFxuICAgIHN0eWxlOiBHdWlkZUxhYmVsU3R5bGUsXG4gICAga2V5OiBWYWx1ZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZSxcbiAgICBvdmVybGFwXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBheGlzVGl0bGUgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZikge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIG9yaWVudCA9IHNwZWMub3JpZW50LFxuICAgICAgICBzaWduID0gZ2V0U2lnbihvcmllbnQsIC0xLCAxKTtcblxuICBsZXQgZW50ZXIsIHVwZGF0ZTtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiBlbnRlciA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm8sXG4gICAgICBhbmNob3I6IGVuY29kZXIoXygndGl0bGVBbmNob3InLCBudWxsKSksXG4gICAgICBhbGlnbjoge1xuICAgICAgICBzaWduYWw6IGFsaWduRXhwciQxXG4gICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IGV4dGVuZCh7fSwgZW50ZXIsIHtcbiAgICAgIG9wYWNpdHk6IG9uZSxcbiAgICAgIHRleHQ6IGVuY29kZXIoc3BlYy50aXRsZSlcbiAgICB9KSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBjb25zdCB0aXRsZVBvcyA9IHtcbiAgICBzaWduYWw6IGBsZXJwKHJhbmdlKFwiJHtzcGVjLnNjYWxlfVwiKSwgJHthbmNob3JFeHByKDAsIDEsIDAuNSl9KWBcbiAgfTtcbiAgdXBkYXRlLnggPSBpZlgob3JpZW50LCB0aXRsZVBvcyk7XG4gIHVwZGF0ZS55ID0gaWZZKG9yaWVudCwgdGl0bGVQb3MpO1xuICBlbnRlci5hbmdsZSA9IGlmWChvcmllbnQsIHplcm8sIG11bHQoc2lnbiwgOTApKTtcbiAgZW50ZXIuYmFzZWxpbmUgPSBpZlgob3JpZW50LCBpZlRvcChvcmllbnQsIEJvdHRvbSwgVG9wKSwge1xuICAgIHZhbHVlOiBCb3R0b21cbiAgfSk7XG4gIHVwZGF0ZS5hbmdsZSA9IGVudGVyLmFuZ2xlO1xuICB1cGRhdGUuYmFzZWxpbmUgPSBlbnRlci5iYXNlbGluZTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgZmlsbDogXygndGl0bGVDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCd0aXRsZU9wYWNpdHknKSxcbiAgICBmb250OiBfKCd0aXRsZUZvbnQnKSxcbiAgICBmb250U2l6ZTogXygndGl0bGVGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygndGl0bGVGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCd0aXRsZUZvbnRXZWlnaHQnKSxcbiAgICBsaW1pdDogXygndGl0bGVMaW1pdCcpLFxuICAgIGxpbmVIZWlnaHQ6IF8oJ3RpdGxlTGluZUhlaWdodCcpXG4gIH0sIHtcbiAgICAvLyByZXF1aXJlIHVwZGF0ZVxuICAgIGFsaWduOiBfKCd0aXRsZUFsaWduJyksXG4gICAgYW5nbGU6IF8oJ3RpdGxlQW5nbGUnKSxcbiAgICBiYXNlbGluZTogXygndGl0bGVCYXNlbGluZScpXG4gIH0pO1xuICBhdXRvTGF5b3V0KF8sIG9yaWVudCwgZW5jb2RlLCB1c2VyRW5jb2RlKTtcbiAgZW5jb2RlLnVwZGF0ZS5hbGlnbiA9IHBhdGNoKGVuY29kZS51cGRhdGUuYWxpZ24sIGVudGVyLmFsaWduKTtcbiAgZW5jb2RlLnVwZGF0ZS5hbmdsZSA9IHBhdGNoKGVuY29kZS51cGRhdGUuYW5nbGUsIGVudGVyLmFuZ2xlKTtcbiAgZW5jb2RlLnVwZGF0ZS5iYXNlbGluZSA9IHBhdGNoKGVuY29kZS51cGRhdGUuYmFzZWxpbmUsIGVudGVyLmJhc2VsaW5lKTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogQXhpc1RpdGxlUm9sZSxcbiAgICBzdHlsZTogR3VpZGVUaXRsZVN0eWxlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBhdXRvTGF5b3V0KF8sIG9yaWVudCwgZW5jb2RlLCB1c2VyRW5jb2RlKSB7XG4gIGNvbnN0IGF1dG8gPSAodmFsdWUsIGRpbSkgPT4gdmFsdWUgIT0gbnVsbCA/IChlbmNvZGUudXBkYXRlW2RpbV0gPSBwYXRjaChlbmNvZGVyKHZhbHVlKSwgZW5jb2RlLnVwZGF0ZVtkaW1dKSwgZmFsc2UpIDogIWhhcyhkaW0sIHVzZXJFbmNvZGUpID8gdHJ1ZSA6IGZhbHNlO1xuXG4gIGNvbnN0IGF1dG9ZID0gYXV0byhfKCd0aXRsZVgnKSwgJ3gnKSxcbiAgICAgICAgYXV0b1ggPSBhdXRvKF8oJ3RpdGxlWScpLCAneScpO1xuICBlbmNvZGUuZW50ZXIuYXV0byA9IGF1dG9YID09PSBhdXRvWSA/IGVuY29kZXIoYXV0b1gpIDogaWZYKG9yaWVudCwgZW5jb2RlcihhdXRvWCksIGVuY29kZXIoYXV0b1kpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBeGlzIChzcGVjLCBzY29wZSkge1xuICBjb25zdCBjb25maWcgPSBheGlzQ29uZmlnKHNwZWMsIHNjb3BlKSxcbiAgICAgICAgZW5jb2RlID0gc3BlYy5lbmNvZGUgfHwge30sXG4gICAgICAgIGF4aXNFbmNvZGUgPSBlbmNvZGUuYXhpcyB8fCB7fSxcbiAgICAgICAgbmFtZSA9IGF4aXNFbmNvZGUubmFtZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGludGVyYWN0aXZlID0gYXhpc0VuY29kZS5pbnRlcmFjdGl2ZSxcbiAgICAgICAgc3R5bGUgPSBheGlzRW5jb2RlLnN0eWxlLFxuICAgICAgICBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIGJhbmQgPSB0aWNrQmFuZChfKTsgLy8gc2luZ2xlLWVsZW1lbnQgZGF0YSBzb3VyY2UgZm9yIGF4aXMgZ3JvdXBcblxuXG4gIGNvbnN0IGRhdHVtID0ge1xuICAgIHNjYWxlOiBzcGVjLnNjYWxlLFxuICAgIHRpY2tzOiAhIV8oJ3RpY2tzJyksXG4gICAgbGFiZWxzOiAhIV8oJ2xhYmVscycpLFxuICAgIGdyaWQ6ICEhXygnZ3JpZCcpLFxuICAgIGRvbWFpbjogISFfKCdkb21haW4nKSxcbiAgICB0aXRsZTogc3BlYy50aXRsZSAhPSBudWxsXG4gIH07XG4gIGNvbnN0IGRhdGFSZWYgPSByZWYoc2NvcGUuYWRkKENvbGxlY3Qoe30sIFtkYXR1bV0pKSk7IC8vIGRhdGEgc291cmNlIGZvciBheGlzIHRpY2tzXG5cbiAgY29uc3QgdGlja3NSZWYgPSByZWYoc2NvcGUuYWRkKEF4aXNUaWNrcyh7XG4gICAgc2NhbGU6IHNjb3BlLnNjYWxlUmVmKHNwZWMuc2NhbGUpLFxuICAgIGV4dHJhOiBzY29wZS5wcm9wZXJ0eShiYW5kLmV4dHJhKSxcbiAgICBjb3VudDogc2NvcGUub2JqZWN0UHJvcGVydHkoc3BlYy50aWNrQ291bnQpLFxuICAgIHZhbHVlczogc2NvcGUub2JqZWN0UHJvcGVydHkoc3BlYy52YWx1ZXMpLFxuICAgIG1pbnN0ZXA6IHNjb3BlLnByb3BlcnR5KHNwZWMudGlja01pblN0ZXApLFxuICAgIGZvcm1hdFR5cGU6IHNjb3BlLnByb3BlcnR5KHNwZWMuZm9ybWF0VHlwZSksXG4gICAgZm9ybWF0U3BlY2lmaWVyOiBzY29wZS5wcm9wZXJ0eShzcGVjLmZvcm1hdClcbiAgfSkpKTsgLy8gZ2VuZXJhdGUgYXhpcyBtYXJrc1xuXG4gIGNvbnN0IGNoaWxkcmVuID0gW107XG4gIGxldCBzaXplOyAvLyBpbmNsdWRlIGF4aXMgZ3JpZGxpbmVzIGlmIHJlcXVlc3RlZFxuXG4gIGlmIChkYXR1bS5ncmlkKSB7XG4gICAgY2hpbGRyZW4ucHVzaChheGlzR3JpZChzcGVjLCBjb25maWcsIGVuY29kZS5ncmlkLCB0aWNrc1JlZiwgYmFuZCkpO1xuICB9IC8vIGluY2x1ZGUgYXhpcyB0aWNrcyBpZiByZXF1ZXN0ZWRcblxuXG4gIGlmIChkYXR1bS50aWNrcykge1xuICAgIHNpemUgPSBfKCd0aWNrU2l6ZScpO1xuICAgIGNoaWxkcmVuLnB1c2goYXhpc1RpY2tzKHNwZWMsIGNvbmZpZywgZW5jb2RlLnRpY2tzLCB0aWNrc1JlZiwgc2l6ZSwgYmFuZCkpO1xuICB9IC8vIGluY2x1ZGUgYXhpcyBsYWJlbHMgaWYgcmVxdWVzdGVkXG5cblxuICBpZiAoZGF0dW0ubGFiZWxzKSB7XG4gICAgc2l6ZSA9IGRhdHVtLnRpY2tzID8gc2l6ZSA6IDA7XG4gICAgY2hpbGRyZW4ucHVzaChheGlzTGFiZWxzKHNwZWMsIGNvbmZpZywgZW5jb2RlLmxhYmVscywgdGlja3NSZWYsIHNpemUsIGJhbmQpKTtcbiAgfSAvLyBpbmNsdWRlIGF4aXMgZG9tYWluIHBhdGggaWYgcmVxdWVzdGVkXG5cblxuICBpZiAoZGF0dW0uZG9tYWluKSB7XG4gICAgY2hpbGRyZW4ucHVzaChheGlzRG9tYWluKHNwZWMsIGNvbmZpZywgZW5jb2RlLmRvbWFpbiwgZGF0YVJlZikpO1xuICB9IC8vIGluY2x1ZGUgYXhpcyB0aXRsZSBpZiBkZWZpbmVkXG5cblxuICBpZiAoZGF0dW0udGl0bGUpIHtcbiAgICBjaGlsZHJlbi5wdXNoKGF4aXNUaXRsZShzcGVjLCBjb25maWcsIGVuY29kZS50aXRsZSwgZGF0YVJlZikpO1xuICB9IC8vIHBhcnNlIGF4aXMgc3BlY2lmaWNhdGlvblxuXG5cbiAgcmV0dXJuIHBhcnNlTWFyayhndWlkZUdyb3VwKHtcbiAgICByb2xlOiBBeGlzUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZXh0ZW5kRW5jb2RlKGJ1aWxkQXhpc0VuY29kZShfLCBzcGVjKSwgYXhpc0VuY29kZSwgU2tpcCksXG4gICAgbWFya3M6IGNoaWxkcmVuLFxuICAgIGFyaWE6IF8oJ2FyaWEnKSxcbiAgICBkZXNjcmlwdGlvbjogXygnZGVzY3JpcHRpb24nKSxcbiAgICB6aW5kZXg6IF8oJ3ppbmRleCcpLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc3R5bGVcbiAgfSksIHNjb3BlKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBeGlzRW5jb2RlKF8sIHNwZWMpIHtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7fSxcbiAgICB1cGRhdGU6IHt9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIG9yaWVudDogXygnb3JpZW50JyksXG4gICAgb2Zmc2V0OiBfKCdvZmZzZXQnKSB8fCAwLFxuICAgIHBvc2l0aW9uOiB2YWx1ZShzcGVjLnBvc2l0aW9uLCAwKSxcbiAgICB0aXRsZVBhZGRpbmc6IF8oJ3RpdGxlUGFkZGluZycpLFxuICAgIG1pbkV4dGVudDogXygnbWluRXh0ZW50JyksXG4gICAgbWF4RXh0ZW50OiBfKCdtYXhFeHRlbnQnKSxcbiAgICByYW5nZToge1xuICAgICAgc2lnbmFsOiBgYWJzKHNwYW4ocmFuZ2UoXCIke3NwZWMuc2NhbGV9XCIpKSlgXG4gICAgfSxcbiAgICB0cmFuc2xhdGU6IF8oJ3RyYW5zbGF0ZScpLFxuICAgIC8vIGFjY2Vzc2liaWxpdHkgc3VwcG9ydFxuICAgIGZvcm1hdDogc3BlYy5mb3JtYXQsXG4gICAgZm9ybWF0VHlwZTogc3BlYy5mb3JtYXRUeXBlXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNjb3BlIChzcGVjLCBzY29wZSwgcHJlcHJvY2Vzc2VkKSB7XG4gIGNvbnN0IHNpZ25hbHMgPSBhcnJheShzcGVjLnNpZ25hbHMpLFxuICAgICAgICBzY2FsZXMgPSBhcnJheShzcGVjLnNjYWxlcyk7IC8vIHBhcnNlIHNpZ25hbCBkZWZpbml0aW9ucywgaWYgbm90IGFscmVhZHkgcHJlcHJvY2Vzc2VkXG5cbiAgaWYgKCFwcmVwcm9jZXNzZWQpIHNpZ25hbHMuZm9yRWFjaChfID0+IHBhcnNlU2lnbmFsKF8sIHNjb3BlKSk7IC8vIHBhcnNlIGNhcnRvZ3JhcGhpYyBwcm9qZWN0aW9uIGRlZmluaXRpb25zXG5cbiAgYXJyYXkoc3BlYy5wcm9qZWN0aW9ucykuZm9yRWFjaChfID0+IHBhcnNlUHJvamVjdGlvbihfLCBzY29wZSkpOyAvLyBpbml0aWFsaXplIHNjYWxlIHJlZmVyZW5jZXNcblxuICBzY2FsZXMuZm9yRWFjaChfID0+IGluaXRTY2FsZShfLCBzY29wZSkpOyAvLyBwYXJzZSBkYXRhIHNvdXJjZXNcblxuICBhcnJheShzcGVjLmRhdGEpLmZvckVhY2goXyA9PiBwYXJzZURhdGEoXywgc2NvcGUpKTsgLy8gcGFyc2Ugc2NhbGUgZGVmaW5pdGlvbnNcblxuICBzY2FsZXMuZm9yRWFjaChfID0+IHBhcnNlU2NhbGUoXywgc2NvcGUpKTsgLy8gcGFyc2Ugc2lnbmFsIHVwZGF0ZXNcblxuICAocHJlcHJvY2Vzc2VkIHx8IHNpZ25hbHMpLmZvckVhY2goXyA9PiBwYXJzZVNpZ25hbFVwZGF0ZXMoXywgc2NvcGUpKTsgLy8gcGFyc2UgYXhpcyBkZWZpbml0aW9uc1xuXG4gIGFycmF5KHNwZWMuYXhlcykuZm9yRWFjaChfID0+IHBhcnNlQXhpcyhfLCBzY29wZSkpOyAvLyBwYXJzZSBtYXJrIGRlZmluaXRpb25zXG5cbiAgYXJyYXkoc3BlYy5tYXJrcykuZm9yRWFjaChfID0+IHBhcnNlTWFyayhfLCBzY29wZSkpOyAvLyBwYXJzZSBsZWdlbmQgZGVmaW5pdGlvbnNcblxuICBhcnJheShzcGVjLmxlZ2VuZHMpLmZvckVhY2goXyA9PiBwYXJzZUxlZ2VuZChfLCBzY29wZSkpOyAvLyBwYXJzZSB0aXRsZSwgaWYgZGVmaW5lZFxuXG4gIGlmIChzcGVjLnRpdGxlKSBwYXJzZVRpdGxlKHNwZWMudGl0bGUsIHNjb3BlKTsgLy8gcGFyc2UgY29sbGVjdGVkIGxhbWJkYSAoYW5vbnltb3VzKSBleHByZXNzaW9uc1xuXG4gIHNjb3BlLnBhcnNlTGFtYmRhcygpO1xuICByZXR1cm4gc2NvcGU7XG59XG5cbmNvbnN0IHJvb3RFbmNvZGUgPSBzcGVjID0+IGV4dGVuZEVuY29kZSh7XG4gIGVudGVyOiB7XG4gICAgeDoge1xuICAgICAgdmFsdWU6IDBcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfVxuICB9LFxuICB1cGRhdGU6IHtcbiAgICB3aWR0aDoge1xuICAgICAgc2lnbmFsOiAnd2lkdGgnXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHNpZ25hbDogJ2hlaWdodCdcbiAgICB9XG4gIH1cbn0sIHNwZWMpO1xuXG5mdW5jdGlvbiBwYXJzZVZpZXcoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgY29uZmlnID0gc2NvcGUuY29uZmlnOyAvLyBhZGQgc2NlbmVncmFwaCByb290XG5cbiAgY29uc3Qgcm9vdCA9IHJlZihzY29wZS5yb290ID0gc2NvcGUuYWRkKG9wZXJhdG9yKCkpKTsgLy8gcGFyc2UgdG9wLWxldmVsIHNpZ25hbCBkZWZpbml0aW9uc1xuXG4gIGNvbnN0IHNpZ25hbHMgPSBjb2xsZWN0U2lnbmFscyhzcGVjLCBjb25maWcpO1xuICBzaWduYWxzLmZvckVhY2goXyA9PiBwYXJzZVNpZ25hbChfLCBzY29wZSkpOyAvLyBhc3NpZ24gZGVzY3JpcHRpb24sIGV2ZW50LCBsZWdlbmQsIGFuZCBsb2NhbGUgY29uZmlndXJhdGlvblxuXG4gIHNjb3BlLmRlc2NyaXB0aW9uID0gc3BlYy5kZXNjcmlwdGlvbiB8fCBjb25maWcuZGVzY3JpcHRpb247XG4gIHNjb3BlLmV2ZW50Q29uZmlnID0gY29uZmlnLmV2ZW50cztcbiAgc2NvcGUubGVnZW5kcyA9IHNjb3BlLm9iamVjdFByb3BlcnR5KGNvbmZpZy5sZWdlbmQgJiYgY29uZmlnLmxlZ2VuZC5sYXlvdXQpO1xuICBzY29wZS5sb2NhbGUgPSBjb25maWcubG9jYWxlOyAvLyBzdG9yZSByb290IGdyb3VwIGl0ZW1cblxuICBjb25zdCBpbnB1dCA9IHNjb3BlLmFkZChDb2xsZWN0KCkpOyAvLyBlbmNvZGUgcm9vdCBncm91cCBpdGVtXG5cbiAgY29uc3QgZW5jb2RlID0gc2NvcGUuYWRkKEVuY29kZShwYXJzZUVuY29kZShyb290RW5jb2RlKHNwZWMuZW5jb2RlKSwgR3JvdXBNYXJrLCBGcmFtZVJvbGUsIHNwZWMuc3R5bGUsIHNjb3BlLCB7XG4gICAgcHVsc2U6IHJlZihpbnB1dClcbiAgfSkpKTsgLy8gcGVyZm9ybSB2aWV3IGxheW91dFxuXG4gIGNvbnN0IHBhcmVudCA9IHNjb3BlLmFkZChWaWV3TGF5b3V0KHtcbiAgICBsYXlvdXQ6IHNjb3BlLm9iamVjdFByb3BlcnR5KHNwZWMubGF5b3V0KSxcbiAgICBsZWdlbmRzOiBzY29wZS5sZWdlbmRzLFxuICAgIGF1dG9zaXplOiBzY29wZS5zaWduYWxSZWYoJ2F1dG9zaXplJyksXG4gICAgbWFyazogcm9vdCxcbiAgICBwdWxzZTogcmVmKGVuY29kZSlcbiAgfSkpO1xuICBzY29wZS5vcGVyYXRvcnMucG9wKCk7IC8vIHBhcnNlIHJlbWFpbmRlciBvZiBzcGVjaWZpY2F0aW9uXG5cbiAgc2NvcGUucHVzaFN0YXRlKHJlZihlbmNvZGUpLCByZWYocGFyZW50KSwgbnVsbCk7XG4gIHBhcnNlU2NvcGUoc3BlYywgc2NvcGUsIHNpZ25hbHMpO1xuICBzY29wZS5vcGVyYXRvcnMucHVzaChwYXJlbnQpOyAvLyBib3VuZCAvIHJlbmRlciAvIHNpZXZlIHJvb3QgaXRlbVxuXG4gIGxldCBvcCA9IHNjb3BlLmFkZChCb3VuZCh7XG4gICAgbWFyazogcm9vdCxcbiAgICBwdWxzZTogcmVmKHBhcmVudClcbiAgfSkpO1xuICBvcCA9IHNjb3BlLmFkZChSZW5kZXIoe1xuICAgIHB1bHNlOiByZWYob3ApXG4gIH0pKTtcbiAgb3AgPSBzY29wZS5hZGQoU2lldmUoe1xuICAgIHB1bHNlOiByZWYob3ApXG4gIH0pKTsgLy8gdHJhY2sgbWV0YWRhdGEgZm9yIHJvb3QgaXRlbVxuXG4gIHNjb3BlLmFkZERhdGEoJ3Jvb3QnLCBuZXcgRGF0YVNjb3BlKHNjb3BlLCBpbnB1dCwgaW5wdXQsIG9wKSk7XG4gIHJldHVybiBzY29wZTtcbn1cblxuZnVuY3Rpb24gc2lnbmFsT2JqZWN0KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5zaWduYWwgPyB7XG4gICAgbmFtZSxcbiAgICB1cGRhdGU6IHZhbHVlLnNpZ25hbFxuICB9IDoge1xuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfTtcbn1cbi8qKlxuICogQ29sbGVjdCB0b3AtbGV2ZWwgc2lnbmFscywgbWVyZ2luZyB2YWx1ZXMgYXMgbmVlZGVkLiBTaWduYWxzXG4gKiBkZWZpbmVkIGluIHRoZSBjb25maWcgc2lnbmFscyBhcnJheXMgYXJlIGFkZGVkIG9ubHkgaWYgdGhhdFxuICogc2lnbmFsIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgaW4gdGhlIHNwZWNpZmljYXRpb24uXG4gKiBCdWlsdC1pbiBzaWduYWxzIChhdXRvc2l6ZSwgYmFja2dyb3VuZCwgcGFkZGluZywgd2lkdGgsIGhlaWdodClcbiAqIHJlY2VpdmUgc3BlY2lhbCB0cmVhdG1lbnQuIFRoZXkgYXJlIGluaXRpYWxpemVkIHVzaW5nIHRoZVxuICogdG9wLWxldmVsIHNwZWMgcHJvcGVydHksIG9yLCBpZiB1bmRlZmluZWQgaW4gdGhlIHNwZWMsIHVzaW5nXG4gKiB0aGUgY29ycmVzcG9uZGluZyB0b3AtbGV2ZWwgY29uZmlnIHByb3BlcnR5LiBJZiB0aGlzIHByb3BlcnR5XG4gKiBpcyBhIHNpZ25hbCByZWZlcmVuY2Ugb2JqZWN0LCB0aGUgc2lnbmFsIGV4cHJlc3Npb24gbWFwcyB0byB0aGVcbiAqIHNpZ25hbCAndXBkYXRlJyBwcm9wZXJ0eS4gSWYgdGhlIHNwZWMncyB0b3AtbGV2ZWwgc2lnbmFsIGFycmF5XG4gKiBjb250YWlucyBhbiBlbnRyeSB0aGF0IG1hdGNoZXMgYSBidWlsdC1pbiBzaWduYWwsIHRoYXQgZW50cnlcbiAqIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGJ1aWx0LWluIHNwZWNpZmljYXRpb24sIHBvdGVudGlhbGx5XG4gKiBvdmVyd3JpdGluZyBleGlzdGluZyAndmFsdWUnIG9yICd1cGRhdGUnIHByb3BlcnRpZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBjb2xsZWN0U2lnbmFscyhzcGVjLCBjb25maWcpIHtcbiAgY29uc3QgXyA9IG5hbWUgPT4gdmFsdWUoc3BlY1tuYW1lXSwgY29uZmlnW25hbWVdKSxcbiAgICAgICAgc2lnbmFscyA9IFtzaWduYWxPYmplY3QoJ2JhY2tncm91bmQnLCBfKCdiYWNrZ3JvdW5kJykpLCBzaWduYWxPYmplY3QoJ2F1dG9zaXplJywgcGFyc2VBdXRvc2l6ZShfKCdhdXRvc2l6ZScpKSksIHNpZ25hbE9iamVjdCgncGFkZGluZycsIHBhcnNlUGFkZGluZyhfKCdwYWRkaW5nJykpKSwgc2lnbmFsT2JqZWN0KCd3aWR0aCcsIF8oJ3dpZHRoJykgfHwgMCksIHNpZ25hbE9iamVjdCgnaGVpZ2h0JywgXygnaGVpZ2h0JykgfHwgMCldLFxuICAgICAgICBwcmUgPSBzaWduYWxzLnJlZHVjZSgocCwgcykgPT4gKHBbcy5uYW1lXSA9IHMsIHApLCB7fSksXG4gICAgICAgIG1hcCA9IHt9OyAvLyBhZGQgc3BlYyBzaWduYWwgYXJyYXlcblxuXG4gIGFycmF5KHNwZWMuc2lnbmFscykuZm9yRWFjaChzID0+IHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkocHJlLCBzLm5hbWUpKSB7XG4gICAgICAvLyBtZXJnZSBpZiBidWlsdC1pbiBzaWduYWxcbiAgICAgIHMgPSBleHRlbmQocHJlW3MubmFtZV0sIHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UgYWRkIHRvIHNpZ25hbCBsaXN0XG4gICAgICBzaWduYWxzLnB1c2gocyk7XG4gICAgfVxuXG4gICAgbWFwW3MubmFtZV0gPSBzO1xuICB9KTsgLy8gYWRkIGNvbmZpZyBzaWduYWwgYXJyYXlcblxuICBhcnJheShjb25maWcuc2lnbmFscykuZm9yRWFjaChzID0+IHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KG1hcCwgcy5uYW1lKSAmJiAhaGFzT3duUHJvcGVydHkocHJlLCBzLm5hbWUpKSB7XG4gICAgICAvLyBhZGQgdG8gc2lnbmFsIGxpc3QgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICAgICAgc2lnbmFscy5wdXNoKHMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzaWduYWxzO1xufVxuXG5mdW5jdGlvbiBTY29wZShjb25maWcsIG9wdGlvbnMpIHtcbiAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgdGhpcy5maWVsZCA9IHt9O1xuICB0aGlzLnNpZ25hbHMgPSB7fTtcbiAgdGhpcy5sYW1iZGFzID0ge307XG4gIHRoaXMuc2NhbGVzID0ge307XG4gIHRoaXMuZXZlbnRzID0ge307XG4gIHRoaXMuZGF0YSA9IHt9O1xuICB0aGlzLnN0cmVhbXMgPSBbXTtcbiAgdGhpcy51cGRhdGVzID0gW107XG4gIHRoaXMub3BlcmF0b3JzID0gW107XG4gIHRoaXMuZXZlbnRDb25maWcgPSBudWxsO1xuICB0aGlzLmxvY2FsZSA9IG51bGw7XG4gIHRoaXMuX2lkID0gMDtcbiAgdGhpcy5fc3ViaWQgPSAwO1xuICB0aGlzLl9uZXh0c3ViID0gWzBdO1xuICB0aGlzLl9wYXJlbnQgPSBbXTtcbiAgdGhpcy5fZW5jb2RlID0gW107XG4gIHRoaXMuX2xvb2t1cCA9IFtdO1xuICB0aGlzLl9tYXJrcGF0aCA9IFtdO1xufVxuXG5mdW5jdGlvbiBTdWJzY29wZShzY29wZSkge1xuICB0aGlzLmNvbmZpZyA9IHNjb3BlLmNvbmZpZztcbiAgdGhpcy5vcHRpb25zID0gc2NvcGUub3B0aW9ucztcbiAgdGhpcy5sZWdlbmRzID0gc2NvcGUubGVnZW5kcztcbiAgdGhpcy5maWVsZCA9IE9iamVjdC5jcmVhdGUoc2NvcGUuZmllbGQpO1xuICB0aGlzLnNpZ25hbHMgPSBPYmplY3QuY3JlYXRlKHNjb3BlLnNpZ25hbHMpO1xuICB0aGlzLmxhbWJkYXMgPSBPYmplY3QuY3JlYXRlKHNjb3BlLmxhbWJkYXMpO1xuICB0aGlzLnNjYWxlcyA9IE9iamVjdC5jcmVhdGUoc2NvcGUuc2NhbGVzKTtcbiAgdGhpcy5ldmVudHMgPSBPYmplY3QuY3JlYXRlKHNjb3BlLmV2ZW50cyk7XG4gIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUoc2NvcGUuZGF0YSk7XG4gIHRoaXMuc3RyZWFtcyA9IFtdO1xuICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgdGhpcy5vcGVyYXRvcnMgPSBbXTtcbiAgdGhpcy5faWQgPSAwO1xuICB0aGlzLl9zdWJpZCA9ICsrc2NvcGUuX25leHRzdWJbMF07XG4gIHRoaXMuX25leHRzdWIgPSBzY29wZS5fbmV4dHN1YjtcbiAgdGhpcy5fcGFyZW50ID0gc2NvcGUuX3BhcmVudC5zbGljZSgpO1xuICB0aGlzLl9lbmNvZGUgPSBzY29wZS5fZW5jb2RlLnNsaWNlKCk7XG4gIHRoaXMuX2xvb2t1cCA9IHNjb3BlLl9sb29rdXAuc2xpY2UoKTtcbiAgdGhpcy5fbWFya3BhdGggPSBzY29wZS5fbWFya3BhdGg7XG59XG5cblNjb3BlLnByb3RvdHlwZSA9IFN1YnNjb3BlLnByb3RvdHlwZSA9IHtcbiAgcGFyc2Uoc3BlYykge1xuICAgIHJldHVybiBwYXJzZVNjb3BlKHNwZWMsIHRoaXMpO1xuICB9LFxuXG4gIGZvcmsoKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY29wZSh0aGlzKTtcbiAgfSxcblxuICBpc1N1YnNjb3BlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJpZCA+IDA7XG4gIH0sXG5cbiAgdG9SdW50aW1lKCkge1xuICAgIHRoaXMuZmluaXNoKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgb3BlcmF0b3JzOiB0aGlzLm9wZXJhdG9ycyxcbiAgICAgIHN0cmVhbXM6IHRoaXMuc3RyZWFtcyxcbiAgICAgIHVwZGF0ZXM6IHRoaXMudXBkYXRlcyxcbiAgICAgIGJpbmRpbmdzOiB0aGlzLmJpbmRpbmdzLFxuICAgICAgZXZlbnRDb25maWc6IHRoaXMuZXZlbnRDb25maWcsXG4gICAgICBsb2NhbGU6IHRoaXMubG9jYWxlXG4gICAgfTtcbiAgfSxcblxuICBpZCgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3N1YmlkID8gdGhpcy5fc3ViaWQgKyAnOicgOiAwKSArIHRoaXMuX2lkKys7XG4gIH0sXG5cbiAgYWRkKG9wKSB7XG4gICAgdGhpcy5vcGVyYXRvcnMucHVzaChvcCk7XG4gICAgb3AuaWQgPSB0aGlzLmlkKCk7IC8vIGlmIHByZS1yZWdpc3RyYXRpb24gcmVmZXJlbmNlcyBleGlzdCwgcmVzb2x2ZSB0aGVtIG5vd1xuXG4gICAgaWYgKG9wLnJlZnMpIHtcbiAgICAgIG9wLnJlZnMuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgICByZWYuJHJlZiA9IG9wLmlkO1xuICAgICAgfSk7XG4gICAgICBvcC5yZWZzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3A7XG4gIH0sXG5cbiAgcHJveHkob3ApIHtcbiAgICBjb25zdCB2cmVmID0gb3AgaW5zdGFuY2VvZiBFbnRyeSA/IHJlZihvcCkgOiBvcDtcbiAgICByZXR1cm4gdGhpcy5hZGQoUHJveHkoe1xuICAgICAgdmFsdWU6IHZyZWZcbiAgICB9KSk7XG4gIH0sXG5cbiAgYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuc3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgc3RyZWFtLmlkID0gdGhpcy5pZCgpO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH0sXG5cbiAgYWRkVXBkYXRlKHVwZGF0ZSkge1xuICAgIHRoaXMudXBkYXRlcy5wdXNoKHVwZGF0ZSk7XG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfSxcblxuICAvLyBBcHBseSBtZXRhZGF0YVxuICBmaW5pc2goKSB7XG4gICAgbGV0IG5hbWUsIGRzOyAvLyBhbm5vdGF0ZSByb290XG5cbiAgICBpZiAodGhpcy5yb290KSB0aGlzLnJvb3Qucm9vdCA9IHRydWU7IC8vIGFubm90YXRlIHNpZ25hbHNcblxuICAgIGZvciAobmFtZSBpbiB0aGlzLnNpZ25hbHMpIHtcbiAgICAgIHRoaXMuc2lnbmFsc1tuYW1lXS5zaWduYWwgPSBuYW1lO1xuICAgIH0gLy8gYW5ub3RhdGUgc2NhbGVzXG5cblxuICAgIGZvciAobmFtZSBpbiB0aGlzLnNjYWxlcykge1xuICAgICAgdGhpcy5zY2FsZXNbbmFtZV0uc2NhbGUgPSBuYW1lO1xuICAgIH0gLy8gYW5ub3RhdGUgZGF0YSBzZXRzXG5cblxuICAgIGZ1bmN0aW9uIGFubm90YXRlKG9wLCBuYW1lLCB0eXBlKSB7XG4gICAgICBsZXQgZGF0YSwgbGlzdDtcblxuICAgICAgaWYgKG9wKSB7XG4gICAgICAgIGRhdGEgPSBvcC5kYXRhIHx8IChvcC5kYXRhID0ge30pO1xuICAgICAgICBsaXN0ID0gZGF0YVtuYW1lXSB8fCAoZGF0YVtuYW1lXSA9IFtdKTtcbiAgICAgICAgbGlzdC5wdXNoKHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobmFtZSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgIGRzID0gdGhpcy5kYXRhW25hbWVdO1xuICAgICAgYW5ub3RhdGUoZHMuaW5wdXQsIG5hbWUsICdpbnB1dCcpO1xuICAgICAgYW5ub3RhdGUoZHMub3V0cHV0LCBuYW1lLCAnb3V0cHV0Jyk7XG4gICAgICBhbm5vdGF0ZShkcy52YWx1ZXMsIG5hbWUsICd2YWx1ZXMnKTtcblxuICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBkcy5pbmRleCkge1xuICAgICAgICBhbm5vdGF0ZShkcy5pbmRleFtmaWVsZF0sIG5hbWUsICdpbmRleDonICsgZmllbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgcHVzaFN0YXRlKGVuY29kZSwgcGFyZW50LCBsb29rdXApIHtcbiAgICB0aGlzLl9lbmNvZGUucHVzaChyZWYodGhpcy5hZGQoU2lldmUoe1xuICAgICAgcHVsc2U6IGVuY29kZVxuICAgIH0pKSkpO1xuXG4gICAgdGhpcy5fcGFyZW50LnB1c2gocGFyZW50KTtcblxuICAgIHRoaXMuX2xvb2t1cC5wdXNoKGxvb2t1cCA/IHJlZih0aGlzLnByb3h5KGxvb2t1cCkpIDogbnVsbCk7XG5cbiAgICB0aGlzLl9tYXJrcGF0aC5wdXNoKC0xKTtcbiAgfSxcblxuICBwb3BTdGF0ZSgpIHtcbiAgICB0aGlzLl9lbmNvZGUucG9wKCk7XG5cbiAgICB0aGlzLl9wYXJlbnQucG9wKCk7XG5cbiAgICB0aGlzLl9sb29rdXAucG9wKCk7XG5cbiAgICB0aGlzLl9tYXJrcGF0aC5wb3AoKTtcbiAgfSxcblxuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHBlZWsodGhpcy5fcGFyZW50KTtcbiAgfSxcblxuICBlbmNvZGUoKSB7XG4gICAgcmV0dXJuIHBlZWsodGhpcy5fZW5jb2RlKTtcbiAgfSxcblxuICBsb29rdXAoKSB7XG4gICAgcmV0dXJuIHBlZWsodGhpcy5fbG9va3VwKTtcbiAgfSxcblxuICBtYXJrcGF0aCgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fbWFya3BhdGg7XG4gICAgcmV0dXJuICsrcFtwLmxlbmd0aCAtIDFdO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgZmllbGRSZWYoZmllbGQsIG5hbWUpIHtcbiAgICBpZiAoaXNTdHJpbmcoZmllbGQpKSByZXR1cm4gZmllbGRSZWYkMShmaWVsZCwgbmFtZSk7XG5cbiAgICBpZiAoIWZpZWxkLnNpZ25hbCkge1xuICAgICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIGZpZWxkIHJlZmVyZW5jZTogJyArIHN0cmluZ1ZhbHVlKGZpZWxkKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcyA9IGZpZWxkLnNpZ25hbDtcbiAgICBsZXQgZiA9IHRoaXMuZmllbGRbc107XG5cbiAgICBpZiAoIWYpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5zaWduYWxSZWYocylcbiAgICAgIH07XG4gICAgICBpZiAobmFtZSkgcGFyYW1zLmFzID0gbmFtZTtcbiAgICAgIHRoaXMuZmllbGRbc10gPSBmID0gcmVmKHRoaXMuYWRkKEZpZWxkKHBhcmFtcykpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZjtcbiAgfSxcblxuICBjb21wYXJlUmVmKGNtcCkge1xuICAgIGxldCBzaWduYWwgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNoZWNrID0gXyA9PiBpc1NpZ25hbChfKSA/IChzaWduYWwgPSB0cnVlLCB0aGlzLnNpZ25hbFJlZihfLnNpZ25hbCkpIDogaXNFeHByJDEoXykgPyAoc2lnbmFsID0gdHJ1ZSwgdGhpcy5leHByUmVmKF8uZXhwcikpIDogXztcblxuICAgIGNvbnN0IGZpZWxkcyA9IGFycmF5KGNtcC5maWVsZCkubWFwKGNoZWNrKSxcbiAgICAgICAgICBvcmRlcnMgPSBhcnJheShjbXAub3JkZXIpLm1hcChjaGVjayk7XG4gICAgcmV0dXJuIHNpZ25hbCA/IHJlZih0aGlzLmFkZChDb21wYXJlKHtcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgb3JkZXJzOiBvcmRlcnNcbiAgICB9KSkpIDogY29tcGFyZVJlZihmaWVsZHMsIG9yZGVycyk7XG4gIH0sXG5cbiAga2V5UmVmKGZpZWxkcywgZmxhdCkge1xuICAgIGxldCBzaWduYWwgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNoZWNrID0gXyA9PiBpc1NpZ25hbChfKSA/IChzaWduYWwgPSB0cnVlLCByZWYoc2lnW18uc2lnbmFsXSkpIDogXztcblxuICAgIGNvbnN0IHNpZyA9IHRoaXMuc2lnbmFscztcbiAgICBmaWVsZHMgPSBhcnJheShmaWVsZHMpLm1hcChjaGVjayk7XG4gICAgcmV0dXJuIHNpZ25hbCA/IHJlZih0aGlzLmFkZChLZXkoe1xuICAgICAgZmllbGRzOiBmaWVsZHMsXG4gICAgICBmbGF0OiBmbGF0XG4gICAgfSkpKSA6IGtleVJlZihmaWVsZHMsIGZsYXQpO1xuICB9LFxuXG4gIHNvcnRSZWYoc29ydCkge1xuICAgIGlmICghc29ydCkgcmV0dXJuIHNvcnQ7IC8vIGluY2x1ZGluZyBpZCBlbnN1cmVzIHN0YWJsZSBzb3J0aW5nXG5cbiAgICBjb25zdCBhID0gYWdnckZpZWxkKHNvcnQub3AsIHNvcnQuZmllbGQpLFxuICAgICAgICAgIG8gPSBzb3J0Lm9yZGVyIHx8IEFzY2VuZGluZztcbiAgICByZXR1cm4gby5zaWduYWwgPyByZWYodGhpcy5hZGQoQ29tcGFyZSh7XG4gICAgICBmaWVsZHM6IGEsXG4gICAgICBvcmRlcnM6IHRoaXMuc2lnbmFsUmVmKG8uc2lnbmFsKVxuICAgIH0pKSkgOiBjb21wYXJlUmVmKGEsIG8pO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgZXZlbnQoc291cmNlLCB0eXBlKSB7XG4gICAgY29uc3Qga2V5ID0gc291cmNlICsgJzonICsgdHlwZTtcblxuICAgIGlmICghdGhpcy5ldmVudHNba2V5XSkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmlkKCk7XG4gICAgICB0aGlzLnN0cmVhbXMucHVzaCh7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ldmVudHNba2V5XSA9IGlkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV2ZW50c1trZXldO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgaGFzT3duU2lnbmFsKG5hbWUpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkodGhpcy5zaWduYWxzLCBuYW1lKTtcbiAgfSxcblxuICBhZGRTaWduYWwobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNPd25TaWduYWwobmFtZSkpIHtcbiAgICAgIGVycm9yKCdEdXBsaWNhdGUgc2lnbmFsIG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3AgPSB2YWx1ZSBpbnN0YW5jZW9mIEVudHJ5ID8gdmFsdWUgOiB0aGlzLmFkZChvcGVyYXRvcih2YWx1ZSkpO1xuICAgIHJldHVybiB0aGlzLnNpZ25hbHNbbmFtZV0gPSBvcDtcbiAgfSxcblxuICBnZXRTaWduYWwobmFtZSkge1xuICAgIGlmICghdGhpcy5zaWduYWxzW25hbWVdKSB7XG4gICAgICBlcnJvcignVW5yZWNvZ25pemVkIHNpZ25hbCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNpZ25hbHNbbmFtZV07XG4gIH0sXG5cbiAgc2lnbmFsUmVmKHMpIHtcbiAgICBpZiAodGhpcy5zaWduYWxzW3NdKSB7XG4gICAgICByZXR1cm4gcmVmKHRoaXMuc2lnbmFsc1tzXSk7XG4gICAgfSBlbHNlIGlmICghaGFzT3duUHJvcGVydHkodGhpcy5sYW1iZGFzLCBzKSkge1xuICAgICAgdGhpcy5sYW1iZGFzW3NdID0gdGhpcy5hZGQob3BlcmF0b3IobnVsbCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZWYodGhpcy5sYW1iZGFzW3NdKTtcbiAgfSxcblxuICBwYXJzZUxhbWJkYXMoKSB7XG4gICAgY29uc3QgY29kZSA9IE9iamVjdC5rZXlzKHRoaXMubGFtYmRhcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNvZGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBzID0gY29kZVtpXSxcbiAgICAgICAgICAgIGUgPSBwYXJzZUV4cHJlc3Npb24ocywgdGhpcyksXG4gICAgICAgICAgICBvcCA9IHRoaXMubGFtYmRhc1tzXTtcbiAgICAgIG9wLnBhcmFtcyA9IGUuJHBhcmFtcztcbiAgICAgIG9wLnVwZGF0ZSA9IGUuJGV4cHI7XG4gICAgfVxuICB9LFxuXG4gIHByb3BlcnR5KHNwZWMpIHtcbiAgICByZXR1cm4gc3BlYyAmJiBzcGVjLnNpZ25hbCA/IHRoaXMuc2lnbmFsUmVmKHNwZWMuc2lnbmFsKSA6IHNwZWM7XG4gIH0sXG5cbiAgb2JqZWN0UHJvcGVydHkoc3BlYykge1xuICAgIHJldHVybiAhc3BlYyB8fCAhaXNPYmplY3Qoc3BlYykgPyBzcGVjIDogdGhpcy5zaWduYWxSZWYoc3BlYy5zaWduYWwgfHwgcHJvcGVydHlMYW1iZGEoc3BlYykpO1xuICB9LFxuXG4gIGV4cHJSZWYoY29kZSwgbmFtZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGV4cHI6IHBhcnNlRXhwcmVzc2lvbihjb2RlLCB0aGlzKVxuICAgIH07XG4gICAgaWYgKG5hbWUpIHBhcmFtcy5leHByLiRuYW1lID0gbmFtZTtcbiAgICByZXR1cm4gcmVmKHRoaXMuYWRkKEV4cHJlc3Npb24ocGFyYW1zKSkpO1xuICB9LFxuXG4gIGFkZEJpbmRpbmcobmFtZSwgYmluZCkge1xuICAgIGlmICghdGhpcy5iaW5kaW5ncykge1xuICAgICAgZXJyb3IoJ05lc3RlZCBzaWduYWxzIGRvIG5vdCBzdXBwb3J0IGJpbmRpbmc6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuXG4gICAgdGhpcy5iaW5kaW5ncy5wdXNoKGV4dGVuZCh7XG4gICAgICBzaWduYWw6IG5hbWVcbiAgICB9LCBiaW5kKSk7XG4gIH0sXG5cbiAgLy8gLS0tLVxuICBhZGRTY2FsZVByb2oobmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHRoaXMuc2NhbGVzLCBuYW1lKSkge1xuICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBzY2FsZSBvciBwcm9qZWN0aW9uIG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuXG4gICAgdGhpcy5zY2FsZXNbbmFtZV0gPSB0aGlzLmFkZCh0cmFuc2Zvcm0pO1xuICB9LFxuXG4gIGFkZFNjYWxlKG5hbWUsIHBhcmFtcykge1xuICAgIHRoaXMuYWRkU2NhbGVQcm9qKG5hbWUsIFNjYWxlKHBhcmFtcykpO1xuICB9LFxuXG4gIGFkZFByb2plY3Rpb24obmFtZSwgcGFyYW1zKSB7XG4gICAgdGhpcy5hZGRTY2FsZVByb2oobmFtZSwgUHJvamVjdGlvbihwYXJhbXMpKTtcbiAgfSxcblxuICBnZXRTY2FsZShuYW1lKSB7XG4gICAgaWYgKCF0aGlzLnNjYWxlc1tuYW1lXSkge1xuICAgICAgZXJyb3IoJ1VucmVjb2duaXplZCBzY2FsZSBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNjYWxlc1tuYW1lXTtcbiAgfSxcblxuICBzY2FsZVJlZihuYW1lKSB7XG4gICAgcmV0dXJuIHJlZih0aGlzLmdldFNjYWxlKG5hbWUpKTtcbiAgfSxcblxuICBzY2FsZVR5cGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldFNjYWxlKG5hbWUpLnBhcmFtcy50eXBlO1xuICB9LFxuXG4gIHByb2plY3Rpb25SZWYobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlUmVmKG5hbWUpO1xuICB9LFxuXG4gIHByb2plY3Rpb25UeXBlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZVR5cGUobmFtZSk7XG4gIH0sXG5cbiAgLy8gLS0tLVxuICBhZGREYXRhKG5hbWUsIGRhdGFTY29wZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh0aGlzLmRhdGEsIG5hbWUpKSB7XG4gICAgICBlcnJvcignRHVwbGljYXRlIGRhdGEgc2V0IG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YVtuYW1lXSA9IGRhdGFTY29wZTtcbiAgfSxcblxuICBnZXREYXRhKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuZGF0YVtuYW1lXSkge1xuICAgICAgZXJyb3IoJ1VuZGVmaW5lZCBkYXRhIHNldCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFbbmFtZV07XG4gIH0sXG5cbiAgYWRkRGF0YVBpcGVsaW5lKG5hbWUsIGVudHJpZXMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodGhpcy5kYXRhLCBuYW1lKSkge1xuICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBkYXRhIHNldCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkZERhdGEobmFtZSwgRGF0YVNjb3BlLmZyb21FbnRyaWVzKHRoaXMsIGVudHJpZXMpKTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBwcm9wZXJ0eUxhbWJkYShzcGVjKSB7XG4gIHJldHVybiAoaXNBcnJheShzcGVjKSA/IGFycmF5TGFtYmRhIDogb2JqZWN0TGFtYmRhKShzcGVjKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlMYW1iZGEoYXJyYXkpIHtcbiAgY29uc3QgbiA9IGFycmF5Lmxlbmd0aDtcbiAgbGV0IGNvZGUgPSAnWyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGFycmF5W2ldO1xuICAgIGNvZGUgKz0gKGkgPiAwID8gJywnIDogJycpICsgKGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlLnNpZ25hbCB8fCBwcm9wZXJ0eUxhbWJkYSh2YWx1ZSkgOiBzdHJpbmdWYWx1ZSh2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIGNvZGUgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIG9iamVjdExhbWJkYShvYmopIHtcbiAgbGV0IGNvZGUgPSAneycsXG4gICAgICBpID0gMCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIHZhbHVlID0gb2JqW2tleV07XG4gICAgY29kZSArPSAoKytpID4gMSA/ICcsJyA6ICcnKSArIHN0cmluZ1ZhbHVlKGtleSkgKyAnOicgKyAoaXNPYmplY3QodmFsdWUpID8gdmFsdWUuc2lnbmFsIHx8IHByb3BlcnR5TGFtYmRhKHZhbHVlKSA6IHN0cmluZ1ZhbHVlKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gY29kZSArICd9Jztcbn1cblxuLyoqXG4gKiBTdGFuZGFyZCBjb25maWd1cmF0aW9uIGRlZmF1bHRzIGZvciBWZWdhIHNwZWNpZmljYXRpb24gcGFyc2luZy5cbiAqIFVzZXJzIGNhbiBwcm92aWRlIHRoZWlyIG93biAoc3ViLSlzZXQgb2YgdGhlc2UgZGVmYXVsdCB2YWx1ZXNcbiAqIGJ5IHBhc3NpbmcgaW4gYSBjb25maWcgb2JqZWN0IHRvIHRoZSB0b3AtbGV2ZWwgcGFyc2UgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0cyAoKSB7XG4gIGNvbnN0IGRlZmF1bHRGb250ID0gJ3NhbnMtc2VyaWYnLFxuICAgICAgICBkZWZhdWx0U3ltYm9sU2l6ZSA9IDMwLFxuICAgICAgICBkZWZhdWx0U3Ryb2tlV2lkdGggPSAyLFxuICAgICAgICBkZWZhdWx0Q29sb3IgPSAnIzRjNzhhOCcsXG4gICAgICAgIGJsYWNrID0gJyMwMDAnLFxuICAgICAgICBncmF5ID0gJyM4ODgnLFxuICAgICAgICBsaWdodEdyYXkgPSAnI2RkZCc7XG4gIHJldHVybiB7XG4gICAgLy8gZGVmYXVsdCB2aXN1YWxpemF0aW9uIGRlc2NyaXB0aW9uXG4gICAgZGVzY3JpcHRpb246ICdWZWdhIHZpc3VhbGl6YXRpb24nLFxuICAgIC8vIGRlZmF1bHQgcGFkZGluZyBhcm91bmQgdmlzdWFsaXphdGlvblxuICAgIHBhZGRpbmc6IDAsXG4gICAgLy8gZGVmYXVsdCBmb3IgYXV0b21hdGljIHNpemluZzsgb3B0aW9uczogJ25vbmUnLCAncGFkJywgJ2ZpdCdcbiAgICAvLyBvciBwcm92aWRlIGFuIG9iamVjdCAoZS5nLiwgeyd0eXBlJzogJ3BhZCcsICdyZXNpemUnOiB0cnVlfSlcbiAgICBhdXRvc2l6ZTogJ3BhZCcsXG4gICAgLy8gZGVmYXVsdCB2aWV3IGJhY2tncm91bmQgY29sb3JcbiAgICAvLyBjb3ZlcnMgdGhlIGVudGlyZSB2aWV3IGNvbXBvbmVudFxuICAgIGJhY2tncm91bmQ6IG51bGwsXG4gICAgLy8gZGVmYXVsdCBldmVudCBoYW5kbGluZyBjb25maWd1cmF0aW9uXG4gICAgLy8gcHJldmVudERlZmF1bHQgZm9yIHZpZXctc291cmNlZCBldmVudCB0eXBlcyBleGNlcHQgJ3doZWVsJ1xuICAgIGV2ZW50czoge1xuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgYWxsb3c6IFsnd2hlZWwnXVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gZGVmYXVsdHMgZm9yIHRvcC1sZXZlbCBncm91cCBtYXJrc1xuICAgIC8vIGFjY2VwdHMgbWFyayBwcm9wZXJ0aWVzIChmaWxsLCBzdHJva2UsIGV0YylcbiAgICAvLyBjb3ZlcnMgdGhlIGRhdGEgcmVjdGFuZ2xlIHdpdGhpbiBncm91cCB3aWR0aC9oZWlnaHRcbiAgICBncm91cDogbnVsbCxcbiAgICAvLyBkZWZhdWx0cyBmb3IgYmFzaWMgbWFyayB0eXBlc1xuICAgIC8vIGVhY2ggc3Vic2V0IGFjY2VwdHMgbWFyayBwcm9wZXJ0aWVzIChmaWxsLCBzdHJva2UsIGV0YylcbiAgICBtYXJrOiBudWxsLFxuICAgIGFyYzoge1xuICAgICAgZmlsbDogZGVmYXVsdENvbG9yXG4gICAgfSxcbiAgICBhcmVhOiB7XG4gICAgICBmaWxsOiBkZWZhdWx0Q29sb3JcbiAgICB9LFxuICAgIGltYWdlOiBudWxsLFxuICAgIGxpbmU6IHtcbiAgICAgIHN0cm9rZTogZGVmYXVsdENvbG9yLFxuICAgICAgc3Ryb2tlV2lkdGg6IGRlZmF1bHRTdHJva2VXaWR0aFxuICAgIH0sXG4gICAgcGF0aDoge1xuICAgICAgc3Ryb2tlOiBkZWZhdWx0Q29sb3JcbiAgICB9LFxuICAgIHJlY3Q6IHtcbiAgICAgIGZpbGw6IGRlZmF1bHRDb2xvclxuICAgIH0sXG4gICAgcnVsZToge1xuICAgICAgc3Ryb2tlOiBibGFja1xuICAgIH0sXG4gICAgc2hhcGU6IHtcbiAgICAgIHN0cm9rZTogZGVmYXVsdENvbG9yXG4gICAgfSxcbiAgICBzeW1ib2w6IHtcbiAgICAgIGZpbGw6IGRlZmF1bHRDb2xvcixcbiAgICAgIHNpemU6IDY0XG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICBmaWxsOiBibGFjayxcbiAgICAgIGZvbnQ6IGRlZmF1bHRGb250LFxuICAgICAgZm9udFNpemU6IDExXG4gICAgfSxcbiAgICB0cmFpbDoge1xuICAgICAgZmlsbDogZGVmYXVsdENvbG9yLFxuICAgICAgc2l6ZTogZGVmYXVsdFN0cm9rZVdpZHRoXG4gICAgfSxcbiAgICAvLyBzdHlsZSBkZWZpbml0aW9uc1xuICAgIHN0eWxlOiB7XG4gICAgICAvLyBheGlzICYgbGVnZW5kIGxhYmVsc1xuICAgICAgJ2d1aWRlLWxhYmVsJzoge1xuICAgICAgICBmaWxsOiBibGFjayxcbiAgICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICAgIGZvbnRTaXplOiAxMFxuICAgICAgfSxcbiAgICAgIC8vIGF4aXMgJiBsZWdlbmQgdGl0bGVzXG4gICAgICAnZ3VpZGUtdGl0bGUnOiB7XG4gICAgICAgIGZpbGw6IGJsYWNrLFxuICAgICAgICBmb250OiBkZWZhdWx0Rm9udCxcbiAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCdcbiAgICAgIH0sXG4gICAgICAvLyBoZWFkZXJzLCBpbmNsdWRpbmcgY2hhcnQgdGl0bGVcbiAgICAgICdncm91cC10aXRsZSc6IHtcbiAgICAgICAgZmlsbDogYmxhY2ssXG4gICAgICAgIGZvbnQ6IGRlZmF1bHRGb250LFxuICAgICAgICBmb250U2l6ZTogMTMsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJ1xuICAgICAgfSxcbiAgICAgIC8vIGNoYXJ0IHN1YnRpdGxlXG4gICAgICAnZ3JvdXAtc3VidGl0bGUnOiB7XG4gICAgICAgIGZpbGw6IGJsYWNrLFxuICAgICAgICBmb250OiBkZWZhdWx0Rm9udCxcbiAgICAgICAgZm9udFNpemU6IDEyXG4gICAgICB9LFxuICAgICAgLy8gZGVmYXVsdHMgZm9yIHN0eWxlZCBwb2ludCBtYXJrcyBpbiBWZWdhLUxpdGVcbiAgICAgIHBvaW50OiB7XG4gICAgICAgIHNpemU6IGRlZmF1bHRTeW1ib2xTaXplLFxuICAgICAgICBzdHJva2VXaWR0aDogZGVmYXVsdFN0cm9rZVdpZHRoLFxuICAgICAgICBzaGFwZTogJ2NpcmNsZSdcbiAgICAgIH0sXG4gICAgICBjaXJjbGU6IHtcbiAgICAgICAgc2l6ZTogZGVmYXVsdFN5bWJvbFNpemUsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBkZWZhdWx0U3Ryb2tlV2lkdGhcbiAgICAgIH0sXG4gICAgICBzcXVhcmU6IHtcbiAgICAgICAgc2l6ZTogZGVmYXVsdFN5bWJvbFNpemUsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBkZWZhdWx0U3Ryb2tlV2lkdGgsXG4gICAgICAgIHNoYXBlOiAnc3F1YXJlJ1xuICAgICAgfSxcbiAgICAgIC8vIGRlZmF1bHRzIGZvciBzdHlsZWQgZ3JvdXAgbWFya3MgaW4gVmVnYS1MaXRlXG4gICAgICBjZWxsOiB7XG4gICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIHN0cm9rZTogbGlnaHRHcmF5XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBkZWZhdWx0cyBmb3IgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgb3JpZW50OiAndG9wJyxcbiAgICAgIGFuY2hvcjogJ21pZGRsZScsXG4gICAgICBvZmZzZXQ6IDQsXG4gICAgICBzdWJ0aXRsZVBhZGRpbmc6IDNcbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciBheGVzXG4gICAgYXhpczoge1xuICAgICAgbWluRXh0ZW50OiAwLFxuICAgICAgbWF4RXh0ZW50OiAyMDAsXG4gICAgICBiYW5kUG9zaXRpb246IDAuNSxcbiAgICAgIGRvbWFpbjogdHJ1ZSxcbiAgICAgIGRvbWFpbldpZHRoOiAxLFxuICAgICAgZG9tYWluQ29sb3I6IGdyYXksXG4gICAgICBncmlkOiBmYWxzZSxcbiAgICAgIGdyaWRXaWR0aDogMSxcbiAgICAgIGdyaWRDb2xvcjogbGlnaHRHcmF5LFxuICAgICAgbGFiZWxzOiB0cnVlLFxuICAgICAgbGFiZWxBbmdsZTogMCxcbiAgICAgIGxhYmVsTGltaXQ6IDE4MCxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgbGFiZWxQYWRkaW5nOiAyLFxuICAgICAgdGlja3M6IHRydWUsXG4gICAgICB0aWNrQ29sb3I6IGdyYXksXG4gICAgICB0aWNrT2Zmc2V0OiAwLFxuICAgICAgdGlja1JvdW5kOiB0cnVlLFxuICAgICAgdGlja1NpemU6IDUsXG4gICAgICB0aWNrV2lkdGg6IDEsXG4gICAgICB0aXRsZVBhZGRpbmc6IDRcbiAgICB9LFxuICAgIC8vIGNvcnJlY3Rpb24gZm9yIGNlbnRlcmluZyBiaWFzXG4gICAgYXhpc0JhbmQ6IHtcbiAgICAgIHRpY2tPZmZzZXQ6IC0wLjVcbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciBjYXJ0b2dyYXBoaWMgcHJvamVjdGlvblxuICAgIHByb2plY3Rpb246IHtcbiAgICAgIHR5cGU6ICdtZXJjYXRvcidcbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciBsZWdlbmRzXG4gICAgbGVnZW5kOiB7XG4gICAgICBvcmllbnQ6ICdyaWdodCcsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgZ3JpZEFsaWduOiAnZWFjaCcsXG4gICAgICBjb2x1bW5QYWRkaW5nOiAxMCxcbiAgICAgIHJvd1BhZGRpbmc6IDIsXG4gICAgICBzeW1ib2xEaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gICAgICBncmFkaWVudERpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgIGdyYWRpZW50TGVuZ3RoOiAyMDAsXG4gICAgICBncmFkaWVudFRoaWNrbmVzczogMTYsXG4gICAgICBncmFkaWVudFN0cm9rZUNvbG9yOiBsaWdodEdyYXksXG4gICAgICBncmFkaWVudFN0cm9rZVdpZHRoOiAwLFxuICAgICAgZ3JhZGllbnRMYWJlbE9mZnNldDogMixcbiAgICAgIGxhYmVsQWxpZ246ICdsZWZ0JyxcbiAgICAgIGxhYmVsQmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgbGFiZWxMaW1pdDogMTYwLFxuICAgICAgbGFiZWxPZmZzZXQ6IDQsXG4gICAgICBsYWJlbE92ZXJsYXA6IHRydWUsXG4gICAgICBzeW1ib2xMaW1pdDogMzAsXG4gICAgICBzeW1ib2xUeXBlOiAnY2lyY2xlJyxcbiAgICAgIHN5bWJvbFNpemU6IDEwMCxcbiAgICAgIHN5bWJvbE9mZnNldDogMCxcbiAgICAgIHN5bWJvbFN0cm9rZVdpZHRoOiAxLjUsXG4gICAgICBzeW1ib2xCYXNlRmlsbENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgc3ltYm9sQmFzZVN0cm9rZUNvbG9yOiBncmF5LFxuICAgICAgdGl0bGVMaW1pdDogMTgwLFxuICAgICAgdGl0bGVPcmllbnQ6ICd0b3AnLFxuICAgICAgdGl0bGVQYWRkaW5nOiA1LFxuICAgICAgbGF5b3V0OiB7XG4gICAgICAgIG9mZnNldDogMTgsXG4gICAgICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgZGlyZWN0aW9uOiAndmVydGljYWwnXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgZGlyZWN0aW9uOiAndmVydGljYWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciBzY2FsZSByYW5nZXNcbiAgICByYW5nZToge1xuICAgICAgY2F0ZWdvcnk6IHtcbiAgICAgICAgc2NoZW1lOiAndGFibGVhdTEwJ1xuICAgICAgfSxcbiAgICAgIG9yZGluYWw6IHtcbiAgICAgICAgc2NoZW1lOiAnYmx1ZXMnXG4gICAgICB9LFxuICAgICAgaGVhdG1hcDoge1xuICAgICAgICBzY2hlbWU6ICd5ZWxsb3dncmVlbmJsdWUnXG4gICAgICB9LFxuICAgICAgcmFtcDoge1xuICAgICAgICBzY2hlbWU6ICdibHVlcydcbiAgICAgIH0sXG4gICAgICBkaXZlcmdpbmc6IHtcbiAgICAgICAgc2NoZW1lOiAnYmx1ZW9yYW5nZScsXG4gICAgICAgIGV4dGVudDogWzEsIDBdXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiBbJ2NpcmNsZScsICdzcXVhcmUnLCAndHJpYW5nbGUtdXAnLCAnY3Jvc3MnLCAnZGlhbW9uZCcsICd0cmlhbmdsZS1yaWdodCcsICd0cmlhbmdsZS1kb3duJywgJ3RyaWFuZ2xlLWxlZnQnXVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2UgKHNwZWMsIGNvbmZpZywgb3B0aW9ucykge1xuICBpZiAoIWlzT2JqZWN0KHNwZWMpKSB7XG4gICAgZXJyb3IoJ0lucHV0IFZlZ2Egc3BlY2lmaWNhdGlvbiBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKGRlZmF1bHRzKCksIGNvbmZpZywgc3BlYy5jb25maWcpO1xuICByZXR1cm4gcGFyc2VWaWV3KHNwZWMsIG5ldyBTY29wZShjb25maWcsIG9wdGlvbnMpKS50b1J1bnRpbWUoKTtcbn1cblxuZXhwb3J0IHsgQXhpc0RvbWFpblJvbGUsIEF4aXNHcmlkUm9sZSwgQXhpc0xhYmVsUm9sZSwgQXhpc1JvbGUsIEF4aXNUaWNrUm9sZSwgQXhpc1RpdGxlUm9sZSwgRGF0YVNjb3BlLCBGcmFtZVJvbGUsIExlZ2VuZEVudHJ5Um9sZSwgTGVnZW5kTGFiZWxSb2xlLCBMZWdlbmRSb2xlLCBMZWdlbmRTeW1ib2xSb2xlLCBMZWdlbmRUaXRsZVJvbGUsIE1hcmtSb2xlLCBTY29wZSwgU2NvcGVSb2xlLCBkZWZhdWx0cyBhcyBjb25maWcsIHBhcnNlLCBwYXJzZVNpZ25hbCBhcyBzaWduYWwsIHBhcnNlU2lnbmFsVXBkYXRlcyBhcyBzaWduYWxVcGRhdGVzLCBwYXJzZVN0cmVhbSBhcyBzdHJlYW0gfTtcbiIsImltcG9ydCB7IGdlb1BhdGgsIGdlb0FsYmVycywgZ2VvQWxiZXJzVXNhLCBnZW9BemltdXRoYWxFcXVhbEFyZWEsIGdlb0F6aW11dGhhbEVxdWlkaXN0YW50LCBnZW9Db25pY0NvbmZvcm1hbCwgZ2VvQ29uaWNFcXVhbEFyZWEsIGdlb0NvbmljRXF1aWRpc3RhbnQsIGdlb0VxdWFsRWFydGgsIGdlb0VxdWlyZWN0YW5ndWxhciwgZ2VvR25vbW9uaWMsIGdlb0lkZW50aXR5LCBnZW9NZXJjYXRvciwgZ2VvTmF0dXJhbEVhcnRoMSwgZ2VvT3J0aG9ncmFwaGljLCBnZW9TdGVyZW9ncmFwaGljLCBnZW9UcmFuc3ZlcnNlTWVyY2F0b3IgfSBmcm9tICdkMy1nZW8nO1xuaW1wb3J0IHsgZ2VvTW9sbHdlaWRlIH0gZnJvbSAnZDMtZ2VvLXByb2plY3Rpb24nO1xuXG5jb25zdCBkZWZhdWx0UGF0aCA9IGdlb1BhdGgoKTtcbmNvbnN0IHByb2plY3Rpb25Qcm9wZXJ0aWVzID0gWy8vIHN0YW5kYXJkIHByb3BlcnRpZXMgaW4gZDMtZ2VvXG4nY2xpcEFuZ2xlJywgJ2NsaXBFeHRlbnQnLCAnc2NhbGUnLCAndHJhbnNsYXRlJywgJ2NlbnRlcicsICdyb3RhdGUnLCAncGFyYWxsZWxzJywgJ3ByZWNpc2lvbicsICdyZWZsZWN0WCcsICdyZWZsZWN0WScsIC8vIGV4dGVuZGVkIHByb3BlcnRpZXMgaW4gZDMtZ2VvLXByb2plY3Rpb25zXG4nY29lZmZpY2llbnQnLCAnZGlzdGFuY2UnLCAnZnJhY3Rpb24nLCAnbG9iZXMnLCAncGFyYWxsZWwnLCAncmFkaXVzJywgJ3JhdGlvJywgJ3NwYWNpbmcnLCAndGlsdCddO1xuLyoqXG4gKiBBdWdtZW50IHByb2plY3Rpb25zIHdpdGggdGhlaXIgdHlwZSBhbmQgYSBjb3B5IG1ldGhvZC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSwgY29uc3RydWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb2plY3Rpb24oKSB7XG4gICAgY29uc3QgcCA9IGNvbnN0cnVjdG9yKCk7XG4gICAgcC50eXBlID0gdHlwZTtcbiAgICBwLnBhdGggPSBnZW9QYXRoKCkucHJvamVjdGlvbihwKTtcblxuICAgIHAuY29weSA9IHAuY29weSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBjID0gcHJvamVjdGlvbigpO1xuICAgICAgcHJvamVjdGlvblByb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgaWYgKHBbcHJvcF0pIGNbcHJvcF0ocFtwcm9wXSgpKTtcbiAgICAgIH0pO1xuICAgICAgYy5wYXRoLnBvaW50UmFkaXVzKHAucGF0aC5wb2ludFJhZGl1cygpKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG5cbiAgICByZXR1cm4gcDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdGlvbih0eXBlLCBwcm9qKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3Rpb24gdHlwZSBtdXN0IGJlIGEgbmFtZSBzdHJpbmcuJyk7XG4gIH1cblxuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHByb2plY3Rpb25zW3R5cGVdID0gY3JlYXRlKHR5cGUsIHByb2opO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcm9qZWN0aW9uc1t0eXBlXSB8fCBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQcm9qZWN0aW9uUGF0aChwcm9qKSB7XG4gIHJldHVybiBwcm9qICYmIHByb2oucGF0aCB8fCBkZWZhdWx0UGF0aDtcbn1cbmNvbnN0IHByb2plY3Rpb25zID0ge1xuICAvLyBiYXNlIGQzLWdlbyBwcm9qZWN0aW9uIHR5cGVzXG4gIGFsYmVyczogZ2VvQWxiZXJzLFxuICBhbGJlcnN1c2E6IGdlb0FsYmVyc1VzYSxcbiAgYXppbXV0aGFsZXF1YWxhcmVhOiBnZW9BemltdXRoYWxFcXVhbEFyZWEsXG4gIGF6aW11dGhhbGVxdWlkaXN0YW50OiBnZW9BemltdXRoYWxFcXVpZGlzdGFudCxcbiAgY29uaWNjb25mb3JtYWw6IGdlb0NvbmljQ29uZm9ybWFsLFxuICBjb25pY2VxdWFsYXJlYTogZ2VvQ29uaWNFcXVhbEFyZWEsXG4gIGNvbmljZXF1aWRpc3RhbnQ6IGdlb0NvbmljRXF1aWRpc3RhbnQsXG4gIGVxdWFsRWFydGg6IGdlb0VxdWFsRWFydGgsXG4gIGVxdWlyZWN0YW5ndWxhcjogZ2VvRXF1aXJlY3Rhbmd1bGFyLFxuICBnbm9tb25pYzogZ2VvR25vbW9uaWMsXG4gIGlkZW50aXR5OiBnZW9JZGVudGl0eSxcbiAgbWVyY2F0b3I6IGdlb01lcmNhdG9yLFxuICBtb2xsd2VpZGU6IGdlb01vbGx3ZWlkZSxcbiAgbmF0dXJhbEVhcnRoMTogZ2VvTmF0dXJhbEVhcnRoMSxcbiAgb3J0aG9ncmFwaGljOiBnZW9PcnRob2dyYXBoaWMsXG4gIHN0ZXJlb2dyYXBoaWM6IGdlb1N0ZXJlb2dyYXBoaWMsXG4gIHRyYW5zdmVyc2VtZXJjYXRvcjogZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yXG59O1xuXG5mb3IgKGNvbnN0IGtleSBpbiBwcm9qZWN0aW9ucykge1xuICBwcm9qZWN0aW9uKGtleSwgcHJvamVjdGlvbnNba2V5XSk7XG59XG5cbmV4cG9ydCB7IGdldFByb2plY3Rpb25QYXRoLCBwcm9qZWN0aW9uLCBwcm9qZWN0aW9uUHJvcGVydGllcyB9O1xuIiwiZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjZWlsID0gTWF0aC5jZWlsO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgZXhwID0gTWF0aC5leHA7XG5leHBvcnQgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbmV4cG9ydCB2YXIgbG9nID0gTWF0aC5sb2c7XG5leHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcG93ID0gTWF0aC5wb3c7XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbmV4cG9ydCB2YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbmV4cG9ydCB2YXIgc2luID0gTWF0aC5zaW47XG5leHBvcnQgdmFyIHRhbiA9IE1hdGgudGFuO1xuXG5leHBvcnQgdmFyIGVwc2lsb24gPSAxZS02O1xuZXhwb3J0IHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuZXhwb3J0IHZhciBwaSA9IE1hdGguUEk7XG5leHBvcnQgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuZXhwb3J0IHZhciBzcXJ0MV8yID0gTWF0aC5TUVJUMV8yO1xuZXhwb3J0IHZhciBzcXJ0MiA9IHNxcnQoMik7XG5leHBvcnQgdmFyIHNxcnRQaSA9IHNxcnQocGkpO1xuZXhwb3J0IHZhciB0YXUgPSBwaSAqIDI7XG5leHBvcnQgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbmV4cG9ydCB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuXG5leHBvcnQgZnVuY3Rpb24gc2luY2koeCkge1xuICByZXR1cm4geCA/IHggLyBNYXRoLnNpbih4KSA6IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXJ0KHgpIHtcbiAgcmV0dXJuIHggPiAwID8gTWF0aC5zcXJ0KHgpIDogMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhbmgoeCkge1xuICB4ID0gZXhwKDIgKiB4KTtcbiAgcmV0dXJuICh4IC0gMSkgLyAoeCArIDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoZXhwKHgpIC0gZXhwKC14KSkgLyAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoZXhwKHgpICsgZXhwKC14KSkgLyAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJzaW5oKHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyY29zaCh4KSB7XG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxKSk7XG59XG4iLCJpbXBvcnQge2dlb1Byb2plY3Rpb24gYXMgcHJvamVjdGlvbn0gZnJvbSBcImQzLWdlb1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGNvcywgZXBzaWxvbiwgaGFsZlBpLCBwaSwgc2luLCBzcXJ0Mn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9sbHdlaWRlQnJvbWxleVRoZXRhKGNwLCBwaGkpIHtcbiAgdmFyIGNwc2luUGhpID0gY3AgKiBzaW4ocGhpKSwgaSA9IDMwLCBkZWx0YTtcbiAgZG8gcGhpIC09IGRlbHRhID0gKHBoaSArIHNpbihwaGkpIC0gY3BzaW5QaGkpIC8gKDEgKyBjb3MocGhpKSk7XG4gIHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgcmV0dXJuIHBoaSAvIDI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2xsd2VpZGVCcm9tbGV5UmF3KGN4LCBjeSwgY3ApIHtcblxuICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIFtjeCAqIGxhbWJkYSAqIGNvcyhwaGkgPSBtb2xsd2VpZGVCcm9tbGV5VGhldGEoY3AsIHBoaSkpLCBjeSAqIHNpbihwaGkpXTtcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB5ID0gYXNpbih5IC8gY3kpLCBbeCAvIChjeCAqIGNvcyh5KSksIGFzaW4oKDIgKiB5ICsgc2luKDIgKiB5KSkgLyBjcCldO1xuICB9O1xuXG4gIHJldHVybiBmb3J3YXJkO1xufVxuXG5leHBvcnQgdmFyIG1vbGx3ZWlkZVJhdyA9IG1vbGx3ZWlkZUJyb21sZXlSYXcoc3FydDIgLyBoYWxmUGksIHNxcnQyLCBwaSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihtb2xsd2VpZGVSYXcpXG4gICAgICAuc2NhbGUoMTY5LjUyOSk7XG59XG4iLCJpbXBvcnQgeyByZWdyZXNzaW9uTG9lc3MsIHNhbXBsZUN1cnZlLCByZWdyZXNzaW9uTGluZWFyLCByZWdyZXNzaW9uTG9nLCByZWdyZXNzaW9uRXhwLCByZWdyZXNzaW9uUG93LCByZWdyZXNzaW9uUXVhZCwgcmVncmVzc2lvblBvbHkgfSBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuaW1wb3J0IHsgVHJhbnNmb3JtLCBpbmdlc3QgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGluaGVyaXRzLCBhY2Nlc3Nvck5hbWUsIGhhc093blByb3BlcnR5LCBlcnJvciwgZXh0ZW50IH0gZnJvbSAndmVnYS11dGlsJztcblxuZnVuY3Rpb24gcGFydGl0aW9uIChkYXRhLCBncm91cGJ5KSB7XG4gIHZhciBncm91cHMgPSBbXSxcbiAgICAgIGdldCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYodCk7XG4gIH0sXG4gICAgICBtYXAsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIHQsXG4gICAgICBrLFxuICAgICAgZzsgLy8gcGFydGl0aW9uIGRhdGEgcG9pbnRzIGludG8gc3RhY2sgZ3JvdXBzXG5cblxuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXAgPSB7fSwgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IGRhdGFbaV07XG4gICAgICBrID0gZ3JvdXBieS5tYXAoZ2V0KTtcbiAgICAgIGcgPSBtYXBba107XG5cbiAgICAgIGlmICghZykge1xuICAgICAgICBtYXBba10gPSBnID0gW107XG4gICAgICAgIGcuZGltcyA9IGs7XG4gICAgICAgIGdyb3Vwcy5wdXNoKGcpO1xuICAgICAgfVxuXG4gICAgICBnLnB1c2godCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxuLyoqXG4gKiBDb21wdXRlIGxvY2FsbHktd2VpZ2h0ZWQgcmVncmVzc2lvbiBmaXRzIGZvciBvbmUgb3IgbW9yZSBkYXRhIGdyb3Vwcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMueCAtIEFuIGFjY2Vzc29yIGZvciB0aGUgcHJlZGljdG9yIGRhdGEgZmllbGQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy55IC0gQW4gYWNjZXNzb3IgZm9yIHRoZSBwcmVkaWN0ZWQgZGF0YSBmaWVsZC5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnMgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmJhbmR3aWR0aD0wLjNdIC0gVGhlIGxvZXNzIGJhbmR3aWR0aC5cbiAqL1xuXG5mdW5jdGlvbiBMb2VzcyhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkxvZXNzLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0xvZXNzJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3gnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2JhbmR3aWR0aCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDAuM1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKExvZXNzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpO1xuXG4gICAgaWYgKCF0aGlzLnZhbHVlIHx8IHB1bHNlLmNoYW5nZWQoKSB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICAgICAgZ3JvdXBzID0gcGFydGl0aW9uKHNvdXJjZSwgXy5ncm91cGJ5KSxcbiAgICAgICAgICAgIG5hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgICAgICBtID0gbmFtZXMubGVuZ3RoLFxuICAgICAgICAgICAgYXMgPSBfLmFzIHx8IFthY2Nlc3Nvck5hbWUoXy54KSwgYWNjZXNzb3JOYW1lKF8ueSldLFxuICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICBncm91cHMuZm9yRWFjaChnID0+IHtcbiAgICAgICAgcmVncmVzc2lvbkxvZXNzKGcsIF8ueCwgXy55LCBfLmJhbmR3aWR0aCB8fCAwLjMpLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IHt9O1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgICAgIHRbbmFtZXNbaV1dID0gZy5kaW1zW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRbYXNbMF1dID0gcFswXTtcbiAgICAgICAgICB0W2FzWzFdXSA9IHBbMV07XG4gICAgICAgICAgdmFsdWVzLnB1c2goaW5nZXN0KHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSBvdXQuYWRkID0gb3V0LnNvdXJjZSA9IHZhbHVlcztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5jb25zdCBNZXRob2RzID0ge1xuICBsaW5lYXI6IHJlZ3Jlc3Npb25MaW5lYXIsXG4gIGxvZzogcmVncmVzc2lvbkxvZyxcbiAgZXhwOiByZWdyZXNzaW9uRXhwLFxuICBwb3c6IHJlZ3Jlc3Npb25Qb3csXG4gIHF1YWQ6IHJlZ3Jlc3Npb25RdWFkLFxuICBwb2x5OiByZWdyZXNzaW9uUG9seVxufTtcblxuY29uc3QgZGVncmVlc09mRnJlZWRvbSA9IChtZXRob2QsIG9yZGVyKSA9PiBtZXRob2QgPT09ICdwb2x5JyA/IG9yZGVyIDogbWV0aG9kID09PSAncXVhZCcgPyAyIDogMTtcbi8qKlxuICogQ29tcHV0ZSByZWdyZXNzaW9uIGZpdHMgZm9yIG9uZSBvciBtb3JlIGRhdGEgZ3JvdXBzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy54IC0gQW4gYWNjZXNzb3IgZm9yIHRoZSBwcmVkaWN0b3IgZGF0YSBmaWVsZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLnkgLSBBbiBhY2Nlc3NvciBmb3IgdGhlIHByZWRpY3RlZCBkYXRhIGZpZWxkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMubWV0aG9kPSdsaW5lYXInXSAtIFRoZSByZWdyZXNzaW9uIG1ldGhvZCB0byBhcHBseS5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnMgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5leHRlbnRdIC0gVGhlIGRvbWFpbiBleHRlbnQgb3ZlciB3aGljaCB0byBwbG90IHRoZSByZWdyZXNzaW9uIGxpbmUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5vcmRlcj0zXSAtIFRoZSBwb2x5bm9taWFsIG9yZGVyLiBPbmx5IGFwcGxpZXMgdG8gdGhlICdwb2x5JyBtZXRob2QuXG4gKi9cblxuXG5mdW5jdGlvbiBSZWdyZXNzaW9uKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuUmVncmVzc2lvbi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdSZWdyZXNzaW9uJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3gnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ21ldGhvZCcsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdsaW5lYXInLFxuICAgICd2YWx1ZXMnOiBPYmplY3Qua2V5cyhNZXRob2RzKVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3JkZXInLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAzXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdleHRlbnQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFyYW1zJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IGZhbHNlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoUmVncmVzc2lvbiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcblxuICAgIGlmICghdGhpcy52YWx1ZSB8fCBwdWxzZS5jaGFuZ2VkKCkgfHwgXy5tb2RpZmllZCgpKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbihzb3VyY2UsIF8uZ3JvdXBieSksXG4gICAgICAgICAgICBuYW1lcyA9IChfLmdyb3VwYnkgfHwgW10pLm1hcChhY2Nlc3Nvck5hbWUpLFxuICAgICAgICAgICAgbWV0aG9kID0gXy5tZXRob2QgfHwgJ2xpbmVhcicsXG4gICAgICAgICAgICBvcmRlciA9IF8ub3JkZXIgfHwgMyxcbiAgICAgICAgICAgIGRvZiA9IGRlZ3JlZXNPZkZyZWVkb20obWV0aG9kLCBvcmRlciksXG4gICAgICAgICAgICBhcyA9IF8uYXMgfHwgW2FjY2Vzc29yTmFtZShfLngpLCBhY2Nlc3Nvck5hbWUoXy55KV0sXG4gICAgICAgICAgICBmaXQgPSBNZXRob2RzW21ldGhvZF0sXG4gICAgICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgIGxldCBkb21haW4gPSBfLmV4dGVudDtcblxuICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShNZXRob2RzLCBtZXRob2QpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHJlZ3Jlc3Npb24gbWV0aG9kOiAnICsgbWV0aG9kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvbWFpbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdsb2cnICYmIGRvbWFpblswXSA8PSAwKSB7XG4gICAgICAgICAgcHVsc2UuZGF0YWZsb3cud2FybignSWdub3JpbmcgZXh0ZW50IHdpdGggdmFsdWVzIDw9IDAgZm9yIGxvZyByZWdyZXNzaW9uLicpO1xuICAgICAgICAgIGRvbWFpbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ3JvdXBzLmZvckVhY2goZyA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBnLmxlbmd0aDtcblxuICAgICAgICBpZiAobiA8PSBkb2YpIHtcbiAgICAgICAgICBwdWxzZS5kYXRhZmxvdy53YXJuKCdTa2lwcGluZyByZWdyZXNzaW9uIHdpdGggbW9yZSBwYXJhbWV0ZXJzIHRoYW4gZGF0YSBwb2ludHMuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kZWwgPSBmaXQoZywgXy54LCBfLnksIG9yZGVyKTtcblxuICAgICAgICBpZiAoXy5wYXJhbXMpIHtcbiAgICAgICAgICAvLyBpZiBwYXJhbWV0ZXIgdmVjdG9ycyByZXF1ZXN0ZWQgcmV0dXJuIHRob3NlXG4gICAgICAgICAgdmFsdWVzLnB1c2goaW5nZXN0KHtcbiAgICAgICAgICAgIGtleXM6IGcuZGltcyxcbiAgICAgICAgICAgIGNvZWY6IG1vZGVsLmNvZWYsXG4gICAgICAgICAgICByU3F1YXJlZDogbW9kZWwuclNxdWFyZWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZG9tID0gZG9tYWluIHx8IGV4dGVudChnLCBfLngpLFxuICAgICAgICAgICAgICBhZGQgPSBwID0+IHtcbiAgICAgICAgICBjb25zdCB0ID0ge307XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0W25hbWVzW2ldXSA9IGcuZGltc1tpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0W2FzWzBdXSA9IHBbMF07XG4gICAgICAgICAgdFthc1sxXV0gPSBwWzFdO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh0KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAvLyBmb3IgbGluZWFyIHJlZ3Jlc3Npb24gd2Ugb25seSBuZWVkIHRoZSBlbmQgcG9pbnRzXG4gICAgICAgICAgZG9tLmZvckVhY2goeCA9PiBhZGQoW3gsIG1vZGVsLnByZWRpY3QoeCldKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHJldHVybiB0cmVuZCBsaW5lIHNhbXBsZSBwb2ludHNcbiAgICAgICAgICBzYW1wbGVDdXJ2ZShtb2RlbC5wcmVkaWN0LCBkb20sIDI1LCAyMDApLmZvckVhY2goYWRkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gb3V0LmFkZCA9IG91dC5zb3VyY2UgPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuZXhwb3J0IHsgTG9lc3MgYXMgbG9lc3MsIFJlZ3Jlc3Npb24gYXMgcmVncmVzc2lvbiB9O1xuIiwiaW1wb3J0IHsgdG9TZXQsIHN0cmluZ1ZhbHVlLCBlcnJvciwgaXNBcnJheSwgaXNPYmplY3QsIGhhc093blByb3BlcnR5LCBhY2Nlc3Nvciwga2V5LCBmaWVsZCwgYXJyYXksIGNvbXBhcmUsIHRydXRoeSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyB0dXBsZWlkIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5cbi8qKlxuICogUGFyc2UgYSBzZXJpYWxpemVkIGRhdGFmbG93IHNwZWNpZmljYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzcGVjKSB7XG4gIGNvbnN0IGN0eCA9IHRoaXMsXG4gICAgICAgIG9wZXJhdG9ycyA9IHNwZWMub3BlcmF0b3JzIHx8IFtdOyAvLyBwYXJzZSBiYWNrZ3JvdW5kXG5cbiAgaWYgKHNwZWMuYmFja2dyb3VuZCkge1xuICAgIGN0eC5iYWNrZ3JvdW5kID0gc3BlYy5iYWNrZ3JvdW5kO1xuICB9IC8vIHBhcnNlIGV2ZW50IGNvbmZpZ3VyYXRpb25cblxuXG4gIGlmIChzcGVjLmV2ZW50Q29uZmlnKSB7XG4gICAgY3R4LmV2ZW50Q29uZmlnID0gc3BlYy5ldmVudENvbmZpZztcbiAgfSAvLyBwYXJzZSBsb2NhbGUgY29uZmlndXJhdGlvblxuXG5cbiAgaWYgKHNwZWMubG9jYWxlKSB7XG4gICAgY3R4LmxvY2FsZSA9IHNwZWMubG9jYWxlO1xuICB9IC8vIHBhcnNlIG9wZXJhdG9yc1xuXG5cbiAgb3BlcmF0b3JzLmZvckVhY2goZW50cnkgPT4gY3R4LnBhcnNlT3BlcmF0b3IoZW50cnkpKTsgLy8gcGFyc2Ugb3BlcmF0b3IgcGFyYW1ldGVyc1xuXG4gIG9wZXJhdG9ycy5mb3JFYWNoKGVudHJ5ID0+IGN0eC5wYXJzZU9wZXJhdG9yUGFyYW1ldGVycyhlbnRyeSkpOyAvLyBwYXJzZSBzdHJlYW1zXG5cbiAgKHNwZWMuc3RyZWFtcyB8fCBbXSkuZm9yRWFjaChlbnRyeSA9PiBjdHgucGFyc2VTdHJlYW0oZW50cnkpKTsgLy8gcGFyc2UgdXBkYXRlc1xuXG4gIChzcGVjLnVwZGF0ZXMgfHwgW10pLmZvckVhY2goZW50cnkgPT4gY3R4LnBhcnNlVXBkYXRlKGVudHJ5KSk7XG4gIHJldHVybiBjdHgucmVzb2x2ZSgpO1xufVxuXG5jb25zdCBTa2lwID0gdG9TZXQoWydydWxlJ10pLFxuICAgICAgU3dhcCA9IHRvU2V0KFsnZ3JvdXAnLCAnaW1hZ2UnLCAncmVjdCddKTtcbmZ1bmN0aW9uIGFkanVzdFNwYXRpYWwoZW5jb2RlLCBtYXJrdHlwZSkge1xuICBsZXQgY29kZSA9ICcnO1xuICBpZiAoU2tpcFttYXJrdHlwZV0pIHJldHVybiBjb2RlO1xuXG4gIGlmIChlbmNvZGUueDIpIHtcbiAgICBpZiAoZW5jb2RlLngpIHtcbiAgICAgIGlmIChTd2FwW21hcmt0eXBlXSkge1xuICAgICAgICBjb2RlICs9ICdpZihvLng+by54MikkPW8ueCxvLng9by54MixvLngyPSQ7JztcbiAgICAgIH1cblxuICAgICAgY29kZSArPSAnby53aWR0aD1vLngyLW8ueDsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9ICdvLng9by54Mi0oby53aWR0aHx8MCk7JztcbiAgICB9XG4gIH1cblxuICBpZiAoZW5jb2RlLnhjKSB7XG4gICAgY29kZSArPSAnby54PW8ueGMtKG8ud2lkdGh8fDApLzI7JztcbiAgfVxuXG4gIGlmIChlbmNvZGUueTIpIHtcbiAgICBpZiAoZW5jb2RlLnkpIHtcbiAgICAgIGlmIChTd2FwW21hcmt0eXBlXSkge1xuICAgICAgICBjb2RlICs9ICdpZihvLnk+by55MikkPW8ueSxvLnk9by55MixvLnkyPSQ7JztcbiAgICAgIH1cblxuICAgICAgY29kZSArPSAnby5oZWlnaHQ9by55Mi1vLnk7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSAnby55PW8ueTItKG8uaGVpZ2h0fHwwKTsnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmNvZGUueWMpIHtcbiAgICBjb2RlICs9ICdvLnk9by55Yy0oby5oZWlnaHR8fDApLzI7JztcbiAgfVxuXG4gIHJldHVybiBjb2RlO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsVHlwZSh0eXBlKSB7XG4gIHJldHVybiAodHlwZSArICcnKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaXNPcGVyYXRvcih0eXBlKSB7XG4gIHJldHVybiBjYW5vbmljYWxUeXBlKHR5cGUpID09PSAnb3BlcmF0b3InO1xufVxuZnVuY3Rpb24gaXNDb2xsZWN0KHR5cGUpIHtcbiAgcmV0dXJuIGNhbm9uaWNhbFR5cGUodHlwZSkgPT09ICdjb2xsZWN0Jztcbn1cblxuZnVuY3Rpb24gZXhwcmVzc2lvbihjdHgsIGFyZ3MsIGNvZGUpIHtcbiAgLy8gd3JhcCBjb2RlIGluIHJldHVybiBzdGF0ZW1lbnQgaWYgZXhwcmVzc2lvbiBkb2VzIG5vdCB0ZXJtaW5hdGVcbiAgaWYgKGNvZGVbY29kZS5sZW5ndGggLSAxXSAhPT0gJzsnKSB7XG4gICAgY29kZSA9ICdyZXR1cm4oJyArIGNvZGUgKyAnKTsnO1xuICB9XG5cbiAgY29uc3QgZm4gPSBGdW5jdGlvbiguLi5hcmdzLmNvbmNhdChjb2RlKSk7XG4gIHJldHVybiBjdHggJiYgY3R4LmZ1bmN0aW9ucyA/IGZuLmJpbmQoY3R4LmZ1bmN0aW9ucykgOiBmbjtcbn0gLy8gZ2VuZXJhdGUgY29kZSBmb3IgY29tcGFyaW5nIGEgc2luZ2xlIGZpZWxkXG5cblxuZnVuY3Rpb24gX2NvbXBhcmUodSwgdiwgbHQsIGd0KSB7XG4gIHJldHVybiBcIigodSA9IFwiLmNvbmNhdCh1LCBcIikgPCAodiA9IFwiKS5jb25jYXQodiwgXCIpIHx8IHUgPT0gbnVsbCkgJiYgdiAhPSBudWxsID8gXCIpLmNvbmNhdChsdCwgXCJcXG4gIDogKHUgPiB2IHx8IHYgPT0gbnVsbCkgJiYgdSAhPSBudWxsID8gXCIpLmNvbmNhdChndCwgXCJcXG4gIDogKCh2ID0gdiBpbnN0YW5jZW9mIERhdGUgPyArdiA6IHYpLCAodSA9IHUgaW5zdGFuY2VvZiBEYXRlID8gK3UgOiB1KSkgIT09IHUgJiYgdiA9PT0gdiA/IFwiKS5jb25jYXQobHQsIFwiXFxuICA6IHYgIT09IHYgJiYgdSA9PT0gdSA/IFwiKS5jb25jYXQoZ3QsIFwiIDogXCIpO1xufVxuXG52YXIgZXhwcmVzc2lvbkNvZGVnZW4gPSB7XG4gIC8qKlxuICAgKiBQYXJzZSBhbiBleHByZXNzaW9uIHVzZWQgdG8gdXBkYXRlIGFuIG9wZXJhdG9yIHZhbHVlLlxuICAgKi9cbiAgb3BlcmF0b3I6IChjdHgsIGV4cHIpID0+IGV4cHJlc3Npb24oY3R4LCBbJ18nXSwgZXhwci5jb2RlKSxcblxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiBwcm92aWRlZCBhcyBhbiBvcGVyYXRvciBwYXJhbWV0ZXIgdmFsdWUuXG4gICAqL1xuICBwYXJhbWV0ZXI6IChjdHgsIGV4cHIpID0+IGV4cHJlc3Npb24oY3R4LCBbJ2RhdHVtJywgJ18nXSwgZXhwci5jb2RlKSxcblxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiBhcHBsaWVkIHRvIGFuIGV2ZW50IHN0cmVhbS5cbiAgICovXG4gIGV2ZW50OiAoY3R4LCBleHByKSA9PiBleHByZXNzaW9uKGN0eCwgWydldmVudCddLCBleHByLmNvZGUpLFxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBleHByZXNzaW9uIHVzZWQgdG8gaGFuZGxlIGFuIGV2ZW50LWRyaXZlbiBvcGVyYXRvciB1cGRhdGUuXG4gICAqL1xuICBoYW5kbGVyOiAoY3R4LCBleHByKSA9PiB7XG4gICAgY29uc3QgY29kZSA9IFwidmFyIGRhdHVtPWV2ZW50Lml0ZW0mJmV2ZW50Lml0ZW0uZGF0dW07cmV0dXJuIFwiLmNvbmNhdChleHByLmNvZGUsIFwiO1wiKTtcbiAgICByZXR1cm4gZXhwcmVzc2lvbihjdHgsIFsnXycsICdldmVudCddLCBjb2RlKTtcbiAgfSxcblxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiB0aGF0IHBlcmZvcm1zIHZpc3VhbCBlbmNvZGluZy5cbiAgICovXG4gIGVuY29kZTogKGN0eCwgZW5jb2RlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbWFya3R5cGUsXG4gICAgICBjaGFubmVsc1xuICAgIH0gPSBlbmNvZGU7XG4gICAgbGV0IGNvZGUgPSAndmFyIG89aXRlbSxkYXR1bT1vLmRhdHVtLG09MCwkOyc7XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gY2hhbm5lbHMpIHtcbiAgICAgIGNvbnN0IG8gPSAnb1snICsgc3RyaW5nVmFsdWUobmFtZSkgKyAnXSc7XG4gICAgICBjb2RlICs9IFwiJD1cIi5jb25jYXQoY2hhbm5lbHNbbmFtZV0uY29kZSwgXCI7aWYoXCIpLmNvbmNhdChvLCBcIiE9PSQpXCIpLmNvbmNhdChvLCBcIj0kLG09MTtcIik7XG4gICAgfVxuXG4gICAgY29kZSArPSBhZGp1c3RTcGF0aWFsKGNoYW5uZWxzLCBtYXJrdHlwZSk7XG4gICAgY29kZSArPSAncmV0dXJuIG07JztcbiAgICByZXR1cm4gZXhwcmVzc2lvbihjdHgsIFsnaXRlbScsICdfJ10sIGNvZGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPcHRpbWl6ZWQgY29kZSBnZW5lcmF0b3JzIGZvciBhY2Nlc3MgYW5kIGNvbXBhcmlzb24uXG4gICAqL1xuICBjb2RlZ2VuOiB7XG4gICAgZ2V0KHBhdGgpIHtcbiAgICAgIGNvbnN0IHJlZiA9IFwiW1wiLmNvbmNhdChwYXRoLm1hcChzdHJpbmdWYWx1ZSkuam9pbignXVsnKSwgXCJdXCIpO1xuICAgICAgY29uc3QgZ2V0ID0gRnVuY3Rpb24oJ18nLCBcInJldHVybiBfXCIuY29uY2F0KHJlZiwgXCI7XCIpKTtcbiAgICAgIGdldC5wYXRoID0gcmVmO1xuICAgICAgcmV0dXJuIGdldDtcbiAgICB9LFxuXG4gICAgY29tcGFyYXRvcihmaWVsZHMsIG9yZGVycykge1xuICAgICAgbGV0IHQ7XG5cbiAgICAgIGNvbnN0IG1hcCA9IChmLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBvcmRlcnNbaV07XG4gICAgICAgIGxldCB1LCB2O1xuXG4gICAgICAgIGlmIChmLnBhdGgpIHtcbiAgICAgICAgICB1ID0gXCJhXCIuY29uY2F0KGYucGF0aCk7XG4gICAgICAgICAgdiA9IFwiYlwiLmNvbmNhdChmLnBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICh0ID0gdCB8fCB7fSlbJ2YnICsgaV0gPSBmO1xuICAgICAgICAgIHUgPSBcInRoaXMuZlwiLmNvbmNhdChpLCBcIihhKVwiKTtcbiAgICAgICAgICB2ID0gXCJ0aGlzLmZcIi5jb25jYXQoaSwgXCIoYilcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2NvbXBhcmUodSwgdiwgLW8sIG8pO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZm4gPSBGdW5jdGlvbignYScsICdiJywgJ3ZhciB1LCB2OyByZXR1cm4gJyArIGZpZWxkcy5tYXAobWFwKS5qb2luKCcnKSArICcwOycpO1xuICAgICAgcmV0dXJuIHQgPyBmbi5iaW5kKHQpIDogZm47XG4gICAgfVxuXG4gIH1cbn07XG5cbi8qKlxuICogUGFyc2UgYSBkYXRhZmxvdyBvcGVyYXRvci5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU9wZXJhdG9yKHNwZWMpIHtcbiAgY29uc3QgY3R4ID0gdGhpcztcblxuICBpZiAoaXNPcGVyYXRvcihzcGVjLnR5cGUpIHx8ICFzcGVjLnR5cGUpIHtcbiAgICBjdHgub3BlcmF0b3Ioc3BlYywgc3BlYy51cGRhdGUgPyBjdHgub3BlcmF0b3JFeHByZXNzaW9uKHNwZWMudXBkYXRlKSA6IG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGN0eC50cmFuc2Zvcm0oc3BlYywgc3BlYy50eXBlKTtcbiAgfVxufVxuLyoqXG4gKiBQYXJzZSBhbmQgYXNzaWduIG9wZXJhdG9yIHBhcmFtZXRlcnMuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VPcGVyYXRvclBhcmFtZXRlcnMoc3BlYykge1xuICBjb25zdCBjdHggPSB0aGlzO1xuXG4gIGlmIChzcGVjLnBhcmFtcykge1xuICAgIGNvbnN0IG9wID0gY3R4LmdldChzcGVjLmlkKTtcbiAgICBpZiAoIW9wKSBlcnJvcignSW52YWxpZCBvcGVyYXRvciBpZDogJyArIHNwZWMuaWQpO1xuICAgIGN0eC5kYXRhZmxvdy5jb25uZWN0KG9wLCBvcC5wYXJhbWV0ZXJzKGN0eC5wYXJzZVBhcmFtZXRlcnMoc3BlYy5wYXJhbXMpLCBzcGVjLnJlYWN0LCBzcGVjLmluaXRvbmx5KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHNldCBvZiBvcGVyYXRvciBwYXJhbWV0ZXJzLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVycyhzcGVjLCBwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb25zdCBjdHggPSB0aGlzO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIHNwZWMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNwZWNba2V5XTtcbiAgICBwYXJhbXNba2V5XSA9IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gcGFyc2VQYXJhbWV0ZXIodiwgY3R4LCBwYXJhbXMpKSA6IHBhcnNlUGFyYW1ldGVyKHZhbHVlLCBjdHgsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufVxuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBwYXJhbWV0ZXIuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIoc3BlYywgY3R4LCBwYXJhbXMpIHtcbiAgaWYgKCFzcGVjIHx8ICFpc09iamVjdChzcGVjKSkgcmV0dXJuIHNwZWM7XG5cbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBQQVJTRVJTLmxlbmd0aCwgcDsgaSA8IG47ICsraSkge1xuICAgIHAgPSBQQVJTRVJTW2ldO1xuXG4gICAgaWYgKGhhc093blByb3BlcnR5KHNwZWMsIHAua2V5KSkge1xuICAgICAgcmV0dXJuIHAucGFyc2Uoc3BlYywgY3R4LCBwYXJhbXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzcGVjO1xufVxuLyoqIFJlZmVyZW5jZSBwYXJzZXJzLiAqL1xuXG5cbnZhciBQQVJTRVJTID0gW3tcbiAga2V5OiAnJHJlZicsXG4gIHBhcnNlOiBnZXRPcGVyYXRvclxufSwge1xuICBrZXk6ICcka2V5JyxcbiAgcGFyc2U6IGdldEtleVxufSwge1xuICBrZXk6ICckZXhwcicsXG4gIHBhcnNlOiBnZXRFeHByZXNzaW9uXG59LCB7XG4gIGtleTogJyRmaWVsZCcsXG4gIHBhcnNlOiBnZXRGaWVsZFxufSwge1xuICBrZXk6ICckZW5jb2RlJyxcbiAgcGFyc2U6IGdldEVuY29kZVxufSwge1xuICBrZXk6ICckY29tcGFyZScsXG4gIHBhcnNlOiBnZXRDb21wYXJlXG59LCB7XG4gIGtleTogJyRjb250ZXh0JyxcbiAgcGFyc2U6IGdldENvbnRleHRcbn0sIHtcbiAga2V5OiAnJHN1YmZsb3cnLFxuICBwYXJzZTogZ2V0U3ViZmxvd1xufSwge1xuICBrZXk6ICckdHVwbGVpZCcsXG4gIHBhcnNlOiBnZXRUdXBsZUlkXG59XTtcbi8qKlxuICogUmVzb2x2ZSBhbiBvcGVyYXRvciByZWZlcmVuY2UuXG4gKi9cblxuZnVuY3Rpb24gZ2V0T3BlcmF0b3IoXywgY3R4KSB7XG4gIHJldHVybiBjdHguZ2V0KF8uJHJlZikgfHwgZXJyb3IoJ09wZXJhdG9yIG5vdCBkZWZpbmVkOiAnICsgXy4kcmVmKTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhbiBleHByZXNzaW9uIHJlZmVyZW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEV4cHJlc3Npb24oXywgY3R4LCBwYXJhbXMpIHtcbiAgaWYgKF8uJHBhcmFtcykge1xuICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gcGFyYW1ldGVyc1xuICAgIGN0eC5wYXJzZVBhcmFtZXRlcnMoXy4kcGFyYW1zLCBwYXJhbXMpO1xuICB9XG5cbiAgY29uc3QgayA9ICdlOicgKyBfLiRleHByLmNvZGUgKyAnXycgKyBfLiRuYW1lO1xuICByZXR1cm4gY3R4LmZuW2tdIHx8IChjdHguZm5ba10gPSBhY2Nlc3NvcihjdHgucGFyYW1ldGVyRXhwcmVzc2lvbihfLiRleHByKSwgXy4kZmllbGRzLCBfLiRuYW1lKSk7XG59XG4vKipcbiAqIFJlc29sdmUgYSBrZXkgYWNjZXNzb3IgcmVmZXJlbmNlLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0S2V5KF8sIGN0eCkge1xuICBjb25zdCBrID0gJ2s6JyArIF8uJGtleSArICdfJyArICEhXy4kZmxhdDtcbiAgcmV0dXJuIGN0eC5mbltrXSB8fCAoY3R4LmZuW2tdID0ga2V5KF8uJGtleSwgXy4kZmxhdCwgY3R4LmV4cHIuY29kZWdlbikpO1xufVxuLyoqXG4gKiBSZXNvbHZlIGEgZmllbGQgYWNjZXNzb3IgcmVmZXJlbmNlLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RmllbGQoXywgY3R4KSB7XG4gIGlmICghXy4kZmllbGQpIHJldHVybiBudWxsO1xuICBjb25zdCBrID0gJ2Y6JyArIF8uJGZpZWxkICsgJ18nICsgXy4kbmFtZTtcbiAgcmV0dXJuIGN0eC5mbltrXSB8fCAoY3R4LmZuW2tdID0gZmllbGQoXy4kZmllbGQsIF8uJG5hbWUsIGN0eC5leHByLmNvZGVnZW4pKTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gcmVmZXJlbmNlLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29tcGFyZShfLCBjdHgpIHtcbiAgLy8gQXMgb2YgVmVnYSA1LjUuMywgJHR1cGxlaWQgc29ydCBpcyBubyBsb25nZXIgdXNlZC5cbiAgLy8gS2VlcCBoZXJlIGZvciBub3cgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBjb25zdCBrID0gJ2M6JyArIF8uJGNvbXBhcmUgKyAnXycgKyBfLiRvcmRlcixcbiAgICAgICAgYyA9IGFycmF5KF8uJGNvbXBhcmUpLm1hcChfID0+IF8gJiYgXy4kdHVwbGVpZCA/IHR1cGxlaWQgOiBfKTtcbiAgcmV0dXJuIGN0eC5mbltrXSB8fCAoY3R4LmZuW2tdID0gY29tcGFyZShjLCBfLiRvcmRlciwgY3R4LmV4cHIuY29kZWdlbikpO1xufVxuLyoqXG4gKiBSZXNvbHZlIGFuIGVuY29kZSBvcGVyYXRvciByZWZlcmVuY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbmNvZGUoXywgY3R4KSB7XG4gIGNvbnN0IHNwZWMgPSBfLiRlbmNvZGUsXG4gICAgICAgIGVuY29kZSA9IHt9O1xuXG4gIGZvciAoY29uc3QgbmFtZSBpbiBzcGVjKSB7XG4gICAgY29uc3QgZW5jID0gc3BlY1tuYW1lXTtcbiAgICBlbmNvZGVbbmFtZV0gPSBhY2Nlc3NvcihjdHguZW5jb2RlRXhwcmVzc2lvbihlbmMuJGV4cHIpLCBlbmMuJGZpZWxkcyk7XG4gICAgZW5jb2RlW25hbWVdLm91dHB1dCA9IGVuYy4kb3V0cHV0O1xuICB9XG5cbiAgcmV0dXJuIGVuY29kZTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhIGNvbnRleHQgcmVmZXJlbmNlLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dChfLCBjdHgpIHtcbiAgcmV0dXJuIGN0eDtcbn1cbi8qKlxuICogUmVzb2x2ZSBhIHJlY3Vyc2l2ZSBzdWJmbG93IHNwZWNpZmljYXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTdWJmbG93KF8sIGN0eCkge1xuICBjb25zdCBzcGVjID0gXy4kc3ViZmxvdztcbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhZmxvdywga2V5LCBwYXJlbnQpIHtcbiAgICBjb25zdCBzdWJjdHggPSBjdHguZm9yaygpLnBhcnNlKHNwZWMpLFxuICAgICAgICAgIG9wID0gc3ViY3R4LmdldChzcGVjLm9wZXJhdG9yc1swXS5pZCksXG4gICAgICAgICAgcCA9IHN1YmN0eC5zaWduYWxzLnBhcmVudDtcbiAgICBpZiAocCkgcC5zZXQocGFyZW50KTtcblxuICAgIG9wLmRldGFjaFN1YmZsb3cgPSAoKSA9PiBjdHguZGV0YWNoKHN1YmN0eCk7XG5cbiAgICByZXR1cm4gb3A7XG4gIH07XG59XG4vKipcbiAqIFJlc29sdmUgYSB0dXBsZSBpZCByZWZlcmVuY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUdXBsZUlkKCkge1xuICByZXR1cm4gdHVwbGVpZDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBldmVudCBzdHJlYW0gc3BlY2lmaWNhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmVhbSAoc3BlYykge1xuICB2YXIgY3R4ID0gdGhpcyxcbiAgICAgIGZpbHRlciA9IHNwZWMuZmlsdGVyICE9IG51bGwgPyBjdHguZXZlbnRFeHByZXNzaW9uKHNwZWMuZmlsdGVyKSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0cmVhbSA9IHNwZWMuc3RyZWFtICE9IG51bGwgPyBjdHguZ2V0KHNwZWMuc3RyZWFtKSA6IHVuZGVmaW5lZCxcbiAgICAgIGFyZ3M7XG5cbiAgaWYgKHNwZWMuc291cmNlKSB7XG4gICAgc3RyZWFtID0gY3R4LmV2ZW50cyhzcGVjLnNvdXJjZSwgc3BlYy50eXBlLCBmaWx0ZXIpO1xuICB9IGVsc2UgaWYgKHNwZWMubWVyZ2UpIHtcbiAgICBhcmdzID0gc3BlYy5tZXJnZS5tYXAoXyA9PiBjdHguZ2V0KF8pKTtcbiAgICBzdHJlYW0gPSBhcmdzWzBdLm1lcmdlLmFwcGx5KGFyZ3NbMF0sIGFyZ3Muc2xpY2UoMSkpO1xuICB9XG5cbiAgaWYgKHNwZWMuYmV0d2Vlbikge1xuICAgIGFyZ3MgPSBzcGVjLmJldHdlZW4ubWFwKF8gPT4gY3R4LmdldChfKSk7XG4gICAgc3RyZWFtID0gc3RyZWFtLmJldHdlZW4oYXJnc1swXSwgYXJnc1sxXSk7XG4gIH1cblxuICBpZiAoc3BlYy5maWx0ZXIpIHtcbiAgICBzdHJlYW0gPSBzdHJlYW0uZmlsdGVyKGZpbHRlcik7XG4gIH1cblxuICBpZiAoc3BlYy50aHJvdHRsZSAhPSBudWxsKSB7XG4gICAgc3RyZWFtID0gc3RyZWFtLnRocm90dGxlKCtzcGVjLnRocm90dGxlKTtcbiAgfVxuXG4gIGlmIChzcGVjLmRlYm91bmNlICE9IG51bGwpIHtcbiAgICBzdHJlYW0gPSBzdHJlYW0uZGVib3VuY2UoK3NwZWMuZGVib3VuY2UpO1xuICB9XG5cbiAgaWYgKHN0cmVhbSA9PSBudWxsKSB7XG4gICAgZXJyb3IoJ0ludmFsaWQgc3RyZWFtIGRlZmluaXRpb246ICcgKyBKU09OLnN0cmluZ2lmeShzcGVjKSk7XG4gIH1cblxuICBpZiAoc3BlYy5jb25zdW1lKSBzdHJlYW0uY29uc3VtZSh0cnVlKTtcbiAgY3R4LnN0cmVhbShzcGVjLCBzdHJlYW0pO1xufVxuXG4vKipcbiAqIFBhcnNlIGFuIGV2ZW50LWRyaXZlbiBvcGVyYXRvciB1cGRhdGUuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VVcGRhdGUgKHNwZWMpIHtcbiAgdmFyIGN0eCA9IHRoaXMsXG4gICAgICBzcmNpZCA9IGlzT2JqZWN0KHNyY2lkID0gc3BlYy5zb3VyY2UpID8gc3JjaWQuJHJlZiA6IHNyY2lkLFxuICAgICAgc291cmNlID0gY3R4LmdldChzcmNpZCksXG4gICAgICB0YXJnZXQgPSBudWxsLFxuICAgICAgdXBkYXRlID0gc3BlYy51cGRhdGUsXG4gICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gIGlmICghc291cmNlKSBlcnJvcignU291cmNlIG5vdCBkZWZpbmVkOiAnICsgc3BlYy5zb3VyY2UpO1xuICB0YXJnZXQgPSBzcGVjLnRhcmdldCAmJiBzcGVjLnRhcmdldC4kZXhwciA/IGN0eC5ldmVudEV4cHJlc3Npb24oc3BlYy50YXJnZXQuJGV4cHIpIDogY3R4LmdldChzcGVjLnRhcmdldCk7XG5cbiAgaWYgKHVwZGF0ZSAmJiB1cGRhdGUuJGV4cHIpIHtcbiAgICBpZiAodXBkYXRlLiRwYXJhbXMpIHtcbiAgICAgIHBhcmFtcyA9IGN0eC5wYXJzZVBhcmFtZXRlcnModXBkYXRlLiRwYXJhbXMpO1xuICAgIH1cblxuICAgIHVwZGF0ZSA9IGN0eC5oYW5kbGVyRXhwcmVzc2lvbih1cGRhdGUuJGV4cHIpO1xuICB9XG5cbiAgY3R4LnVwZGF0ZShzcGVjLCBzb3VyY2UsIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMpO1xufVxuXG5jb25zdCBTS0lQID0ge1xuICBza2lwOiB0cnVlXG59O1xuZnVuY3Rpb24gZ2V0U3RhdGUob3B0aW9ucykge1xuICB2YXIgY3R4ID0gdGhpcyxcbiAgICAgIHN0YXRlID0ge307XG5cbiAgaWYgKG9wdGlvbnMuc2lnbmFscykge1xuICAgIHZhciBzaWduYWxzID0gc3RhdGUuc2lnbmFscyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGN0eC5zaWduYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBvcCA9IGN0eC5zaWduYWxzW2tleV07XG5cbiAgICAgIGlmIChvcHRpb25zLnNpZ25hbHMoa2V5LCBvcCkpIHtcbiAgICAgICAgc2lnbmFsc1trZXldID0gb3AudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBzdGF0ZS5kYXRhID0ge307XG4gICAgT2JqZWN0LmtleXMoY3R4LmRhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBjdHguZGF0YVtrZXldO1xuXG4gICAgICBpZiAob3B0aW9ucy5kYXRhKGtleSwgZGF0YXNldCkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gZGF0YXNldC5pbnB1dC52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjdHguc3ViY29udGV4dCAmJiBvcHRpb25zLnJlY3Vyc2UgIT09IGZhbHNlKSB7XG4gICAgc3RhdGUuc3ViY29udGV4dCA9IGN0eC5zdWJjb250ZXh0Lm1hcChjdHggPT4gY3R4LmdldFN0YXRlKG9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gIHZhciBjdHggPSB0aGlzLFxuICAgICAgZGYgPSBjdHguZGF0YWZsb3csXG4gICAgICBkYXRhID0gc3RhdGUuZGF0YSxcbiAgICAgIHNpZ25hbHMgPSBzdGF0ZS5zaWduYWxzO1xuICBPYmplY3Qua2V5cyhzaWduYWxzIHx8IHt9KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZGYudXBkYXRlKGN0eC5zaWduYWxzW2tleV0sIHNpZ25hbHNba2V5XSwgU0tJUCk7XG4gIH0pO1xuICBPYmplY3Qua2V5cyhkYXRhIHx8IHt9KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZGYucHVsc2UoY3R4LmRhdGFba2V5XS5pbnB1dCwgZGYuY2hhbmdlc2V0KCkucmVtb3ZlKHRydXRoeSkuaW5zZXJ0KGRhdGFba2V5XSkpO1xuICB9KTtcbiAgKHN0YXRlLnN1YmNvbnRleHQgfHwgW10pLmZvckVhY2goKHN1YnN0YXRlLCBpKSA9PiB7XG4gICAgY29uc3Qgc3ViY3R4ID0gY3R4LnN1YmNvbnRleHRbaV07XG4gICAgaWYgKHN1YmN0eCkgc3ViY3R4LnNldFN0YXRlKHN1YnN0YXRlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udGV4dCBvYmplY3RzIHN0b3JlIHRoZSBjdXJyZW50IHBhcnNlIHN0YXRlLlxuICogRW5hYmxlcyBsb29rdXAgb2YgcGFyc2VkIG9wZXJhdG9ycywgZXZlbnQgc3RyZWFtcywgYWNjZXNzb3JzLCBldGMuXG4gKiBQcm92aWRlcyBhICdmb3JrJyBtZXRob2QgZm9yIGNyZWF0aW5nIGNoaWxkIGNvbnRleHRzIGZvciBzdWJmbG93cy5cbiAqL1xuXG5mdW5jdGlvbiBjb250ZXh0IChkZiwgdHJhbnNmb3JtcywgZnVuY3Rpb25zLCBleHByKSB7XG4gIHJldHVybiBuZXcgQ29udGV4dChkZiwgdHJhbnNmb3JtcywgZnVuY3Rpb25zLCBleHByKTtcbn1cblxuZnVuY3Rpb24gQ29udGV4dChkZiwgdHJhbnNmb3JtcywgZnVuY3Rpb25zLCBleHByKSB7XG4gIHRoaXMuZGF0YWZsb3cgPSBkZjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtcztcbiAgdGhpcy5ldmVudHMgPSBkZi5ldmVudHMuYmluZChkZik7XG4gIHRoaXMuZXhwciA9IGV4cHIgfHwgZXhwcmVzc2lvbkNvZGVnZW4sIHRoaXMuc2lnbmFscyA9IHt9O1xuICB0aGlzLnNjYWxlcyA9IHt9O1xuICB0aGlzLm5vZGVzID0ge307XG4gIHRoaXMuZGF0YSA9IHt9O1xuICB0aGlzLmZuID0ge307XG5cbiAgaWYgKGZ1bmN0aW9ucykge1xuICAgIHRoaXMuZnVuY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShmdW5jdGlvbnMpO1xuICAgIHRoaXMuZnVuY3Rpb25zLmNvbnRleHQgPSB0aGlzO1xuICB9XG59XG5cbmZ1bmN0aW9uIFN1YmNvbnRleHQoY3R4KSB7XG4gIHRoaXMuZGF0YWZsb3cgPSBjdHguZGF0YWZsb3c7XG4gIHRoaXMudHJhbnNmb3JtcyA9IGN0eC50cmFuc2Zvcm1zO1xuICB0aGlzLmV2ZW50cyA9IGN0eC5ldmVudHM7XG4gIHRoaXMuZXhwciA9IGN0eC5leHByO1xuICB0aGlzLnNpZ25hbHMgPSBPYmplY3QuY3JlYXRlKGN0eC5zaWduYWxzKTtcbiAgdGhpcy5zY2FsZXMgPSBPYmplY3QuY3JlYXRlKGN0eC5zY2FsZXMpO1xuICB0aGlzLm5vZGVzID0gT2JqZWN0LmNyZWF0ZShjdHgubm9kZXMpO1xuICB0aGlzLmRhdGEgPSBPYmplY3QuY3JlYXRlKGN0eC5kYXRhKTtcbiAgdGhpcy5mbiA9IE9iamVjdC5jcmVhdGUoY3R4LmZuKTtcblxuICBpZiAoY3R4LmZ1bmN0aW9ucykge1xuICAgIHRoaXMuZnVuY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShjdHguZnVuY3Rpb25zKTtcbiAgICB0aGlzLmZ1bmN0aW9ucy5jb250ZXh0ID0gdGhpcztcbiAgfVxufVxuXG5Db250ZXh0LnByb3RvdHlwZSA9IFN1YmNvbnRleHQucHJvdG90eXBlID0ge1xuICBmb3JrKCkge1xuICAgIGNvbnN0IGN0eCA9IG5ldyBTdWJjb250ZXh0KHRoaXMpO1xuICAgICh0aGlzLnN1YmNvbnRleHQgfHwgKHRoaXMuc3ViY29udGV4dCA9IFtdKSkucHVzaChjdHgpO1xuICAgIHJldHVybiBjdHg7XG4gIH0sXG5cbiAgZGV0YWNoKGN0eCkge1xuICAgIHRoaXMuc3ViY29udGV4dCA9IHRoaXMuc3ViY29udGV4dC5maWx0ZXIoYyA9PiBjICE9PSBjdHgpOyAvLyBkaXNjb25uZWN0IGFsbCBub2RlcyBpbiB0aGUgc3ViY29udGV4dFxuICAgIC8vIHdpcGUgb3V0IHRhcmdldHMgZmlyc3QgZm9yIGJldHRlciBlZmZpY2llbmN5XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY3R4Lm5vZGVzKTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIGN0eC5ub2Rlc1trZXldLl90YXJnZXRzID0gbnVsbDtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIGN0eC5ub2Rlc1trZXldLmRldGFjaCgpO1xuXG4gICAgY3R4Lm5vZGVzID0gbnVsbDtcbiAgfSxcblxuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1tpZF07XG4gIH0sXG5cbiAgc2V0KGlkLCBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNbaWRdID0gbm9kZTtcbiAgfSxcblxuICBhZGQoc3BlYywgb3ApIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLFxuICAgICAgICAgIGRmID0gY3R4LmRhdGFmbG93LFxuICAgICAgICAgIGRhdGEgPSBzcGVjLnZhbHVlO1xuICAgIGN0eC5zZXQoc3BlYy5pZCwgb3ApO1xuXG4gICAgaWYgKGlzQ29sbGVjdChzcGVjLnR5cGUpICYmIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLiRpbmdlc3QpIHtcbiAgICAgICAgZGYuaW5nZXN0KG9wLCBkYXRhLiRpbmdlc3QsIGRhdGEuJGZvcm1hdCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuJHJlcXVlc3QpIHtcbiAgICAgICAgZGYucHJlbG9hZChvcCwgZGF0YS4kcmVxdWVzdCwgZGF0YS4kZm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRmLnB1bHNlKG9wLCBkZi5jaGFuZ2VzZXQoKS5pbnNlcnQoZGF0YSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGVjLnJvb3QpIHtcbiAgICAgIGN0eC5yb290ID0gb3A7XG4gICAgfVxuXG4gICAgaWYgKHNwZWMucGFyZW50KSB7XG4gICAgICBsZXQgcCA9IGN0eC5nZXQoc3BlYy5wYXJlbnQuJHJlZik7XG5cbiAgICAgIGlmIChwKSB7XG4gICAgICAgIGRmLmNvbm5lY3QocCwgW29wXSk7XG4gICAgICAgIG9wLnRhcmdldHMoKS5hZGQocCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoY3R4LnVucmVzb2x2ZWQgPSBjdHgudW5yZXNvbHZlZCB8fCBbXSkucHVzaCgoKSA9PiB7XG4gICAgICAgICAgcCA9IGN0eC5nZXQoc3BlYy5wYXJlbnQuJHJlZik7XG4gICAgICAgICAgZGYuY29ubmVjdChwLCBbb3BdKTtcbiAgICAgICAgICBvcC50YXJnZXRzKCkuYWRkKHApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3BlYy5zaWduYWwpIHtcbiAgICAgIGN0eC5zaWduYWxzW3NwZWMuc2lnbmFsXSA9IG9wO1xuICAgIH1cblxuICAgIGlmIChzcGVjLnNjYWxlKSB7XG4gICAgICBjdHguc2NhbGVzW3NwZWMuc2NhbGVdID0gb3A7XG4gICAgfVxuXG4gICAgaWYgKHNwZWMuZGF0YSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHNwZWMuZGF0YSkge1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGFbbmFtZV0gfHwgKGN0eC5kYXRhW25hbWVdID0ge30pO1xuICAgICAgICBzcGVjLmRhdGFbbmFtZV0uZm9yRWFjaChyb2xlID0+IGRhdGFbcm9sZV0gPSBvcCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHJlc29sdmUoKSB7XG4gICAgKHRoaXMudW5yZXNvbHZlZCB8fCBbXSkuZm9yRWFjaChmbiA9PiBmbigpKTtcbiAgICBkZWxldGUgdGhpcy51bnJlc29sdmVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9wZXJhdG9yKHNwZWMsIHVwZGF0ZSkge1xuICAgIHRoaXMuYWRkKHNwZWMsIHRoaXMuZGF0YWZsb3cuYWRkKHNwZWMudmFsdWUsIHVwZGF0ZSkpO1xuICB9LFxuXG4gIHRyYW5zZm9ybShzcGVjLCB0eXBlKSB7XG4gICAgdGhpcy5hZGQoc3BlYywgdGhpcy5kYXRhZmxvdy5hZGQodGhpcy50cmFuc2Zvcm1zW2Nhbm9uaWNhbFR5cGUodHlwZSldKSk7XG4gIH0sXG5cbiAgc3RyZWFtKHNwZWMsIHN0cmVhbSkge1xuICAgIHRoaXMuc2V0KHNwZWMuaWQsIHN0cmVhbSk7XG4gIH0sXG5cbiAgdXBkYXRlKHNwZWMsIHN0cmVhbSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcykge1xuICAgIHRoaXMuZGF0YWZsb3cub24oc3RyZWFtLCB0YXJnZXQsIHVwZGF0ZSwgcGFyYW1zLCBzcGVjLm9wdGlvbnMpO1xuICB9LFxuXG4gIC8vIGV4cHJlc3Npb24gcGFyc2luZ1xuICBvcGVyYXRvckV4cHJlc3Npb24oZXhwcikge1xuICAgIHJldHVybiB0aGlzLmV4cHIub3BlcmF0b3IodGhpcywgZXhwcik7XG4gIH0sXG5cbiAgcGFyYW1ldGVyRXhwcmVzc2lvbihleHByKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwci5wYXJhbWV0ZXIodGhpcywgZXhwcik7XG4gIH0sXG5cbiAgZXZlbnRFeHByZXNzaW9uKGV4cHIpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLmV2ZW50KHRoaXMsIGV4cHIpO1xuICB9LFxuXG4gIGhhbmRsZXJFeHByZXNzaW9uKGV4cHIpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLmhhbmRsZXIodGhpcywgZXhwcik7XG4gIH0sXG5cbiAgZW5jb2RlRXhwcmVzc2lvbihlbmNvZGUpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLmVuY29kZSh0aGlzLCBlbmNvZGUpO1xuICB9LFxuXG4gIC8vIHBhcnNlIG1ldGhvZHNcbiAgcGFyc2UsXG4gIHBhcnNlT3BlcmF0b3IsXG4gIHBhcnNlT3BlcmF0b3JQYXJhbWV0ZXJzLFxuICBwYXJzZVBhcmFtZXRlcnMsXG4gIHBhcnNlU3RyZWFtLFxuICBwYXJzZVVwZGF0ZSxcbiAgLy8gc3RhdGUgbWV0aG9kc1xuICBnZXRTdGF0ZSxcbiAgc2V0U3RhdGVcbn07XG5cbmV4cG9ydCB7IGNvbnRleHQgfTtcbiIsImltcG9ydCB7IHRvTnVtYmVyLCBwZWVrLCBoYXNPd25Qcm9wZXJ0eSwgdG9TZXQsIGFycmF5LCBjb25zdGFudCwgaXNOdW1iZXIsIHNwYW4sIGlzT2JqZWN0LCBpc1N0cmluZywgZXJyb3IsIGlzQXJyYXkgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgYmlzZWN0UmlnaHQsIHJhbmdlLCBiaXNlY3QgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBzY2FsZU9yZGluYWwsIHRpY2tGb3JtYXQgYXMgdGlja0Zvcm1hdCQxLCBzY2FsZUlkZW50aXR5LCBzY2FsZUxpbmVhciwgc2NhbGVMb2csIHNjYWxlUG93LCBzY2FsZVNxcnQsIHNjYWxlU3ltbG9nLCBzY2FsZVRpbWUsIHNjYWxlVXRjLCBzY2FsZVNlcXVlbnRpYWwsIHNjYWxlU2VxdWVudGlhbExvZywgc2NhbGVTZXF1ZW50aWFsUG93LCBzY2FsZVNlcXVlbnRpYWxTcXJ0LCBzY2FsZVNlcXVlbnRpYWxTeW1sb2csIHNjYWxlRGl2ZXJnaW5nLCBzY2FsZURpdmVyZ2luZ0xvZywgc2NhbGVEaXZlcmdpbmdQb3csIHNjYWxlRGl2ZXJnaW5nU3FydCwgc2NhbGVEaXZlcmdpbmdTeW1sb2csIHNjYWxlUXVhbnRpbGUsIHNjYWxlUXVhbnRpemUsIHNjYWxlVGhyZXNob2xkIH0gZnJvbSAnZDMtc2NhbGUnO1xuZXhwb3J0IHsgc2NhbGVJbXBsaWNpdCB9IGZyb20gJ2QzLXNjYWxlJztcbmltcG9ydCAqIGFzICQgZnJvbSAnZDMtaW50ZXJwb2xhdGUnO1xuaW1wb3J0IHsgcGllY2V3aXNlIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnO1xuaW1wb3J0IHsgdGltZUludGVydmFsLCB1dGNJbnRlcnZhbCB9IGZyb20gJ3ZlZ2EtdGltZSc7XG5cbmZ1bmN0aW9uIGJhbmRTcGFjZSAoY291bnQsIHBhZGRpbmdJbm5lciwgcGFkZGluZ091dGVyKSB7XG4gIGNvbnN0IHNwYWNlID0gY291bnQgLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyO1xuICByZXR1cm4gY291bnQgPyBzcGFjZSA+IDAgPyBzcGFjZSA6IDEgOiAwO1xufVxuXG5jb25zdCBJZGVudGl0eSA9ICdpZGVudGl0eSc7XG5jb25zdCBMaW5lYXIgPSAnbGluZWFyJztcbmNvbnN0IExvZyA9ICdsb2cnO1xuY29uc3QgUG93ID0gJ3Bvdyc7XG5jb25zdCBTcXJ0ID0gJ3NxcnQnO1xuY29uc3QgU3ltbG9nID0gJ3N5bWxvZyc7XG5jb25zdCBUaW1lID0gJ3RpbWUnO1xuY29uc3QgVVRDID0gJ3V0Yyc7XG5jb25zdCBTZXF1ZW50aWFsID0gJ3NlcXVlbnRpYWwnO1xuY29uc3QgRGl2ZXJnaW5nID0gJ2RpdmVyZ2luZyc7XG5jb25zdCBRdWFudGlsZSA9ICdxdWFudGlsZSc7XG5jb25zdCBRdWFudGl6ZSA9ICdxdWFudGl6ZSc7XG5jb25zdCBUaHJlc2hvbGQgPSAndGhyZXNob2xkJztcbmNvbnN0IE9yZGluYWwgPSAnb3JkaW5hbCc7XG5jb25zdCBQb2ludCA9ICdwb2ludCc7XG5jb25zdCBCYW5kID0gJ2JhbmQnO1xuY29uc3QgQmluT3JkaW5hbCA9ICdiaW4tb3JkaW5hbCc7IC8vIGNhdGVnb3JpZXNcblxuY29uc3QgQ29udGludW91cyA9ICdjb250aW51b3VzJztcbmNvbnN0IERpc2NyZXRlID0gJ2Rpc2NyZXRlJztcbmNvbnN0IERpc2NyZXRpemluZyA9ICdkaXNjcmV0aXppbmcnO1xuY29uc3QgSW50ZXJwb2xhdGluZyA9ICdpbnRlcnBvbGF0aW5nJztcbmNvbnN0IFRlbXBvcmFsID0gJ3RlbXBvcmFsJztcblxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2UgKHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoXykge1xuICAgIGxldCBsbyA9IF9bMF0sXG4gICAgICAgIGhpID0gX1sxXSxcbiAgICAgICAgdDtcblxuICAgIGlmIChoaSA8IGxvKSB7XG4gICAgICB0ID0gbG87XG4gICAgICBsbyA9IGhpO1xuICAgICAgaGkgPSB0O1xuICAgIH1cblxuICAgIHJldHVybiBbc2NhbGUuaW52ZXJ0KGxvKSwgc2NhbGUuaW52ZXJ0KGhpKV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmVydFJhbmdlRXh0ZW50IChzY2FsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKF8pIHtcbiAgICBjb25zdCByYW5nZSA9IHNjYWxlLnJhbmdlKCk7XG4gICAgbGV0IGxvID0gX1swXSxcbiAgICAgICAgaGkgPSBfWzFdLFxuICAgICAgICBtaW4gPSAtMSxcbiAgICAgICAgbWF4LFxuICAgICAgICB0LFxuICAgICAgICBpLFxuICAgICAgICBuO1xuXG4gICAgaWYgKGhpIDwgbG8pIHtcbiAgICAgIHQgPSBsbztcbiAgICAgIGxvID0gaGk7XG4gICAgICBoaSA9IHQ7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbiA9IHJhbmdlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKHJhbmdlW2ldID49IGxvICYmIHJhbmdlW2ldIDw9IGhpKSB7XG4gICAgICAgIGlmIChtaW4gPCAwKSBtaW4gPSBpO1xuICAgICAgICBtYXggPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW4gPCAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxvID0gc2NhbGUuaW52ZXJ0RXh0ZW50KHJhbmdlW21pbl0pO1xuICAgIGhpID0gc2NhbGUuaW52ZXJ0RXh0ZW50KHJhbmdlW21heF0pO1xuICAgIHJldHVybiBbbG9bMF0gPT09IHVuZGVmaW5lZCA/IGxvWzFdIDogbG9bMF0sIGhpWzFdID09PSB1bmRlZmluZWQgPyBoaVswXSA6IGhpWzFdXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmFuZCgpIHtcbiAgY29uc3Qgc2NhbGUgPSBzY2FsZU9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgICAgb3JkaW5hbFJhbmdlID0gc2NhbGUucmFuZ2U7XG4gIGxldCByYW5nZSQxID0gWzAsIDFdLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuICBkZWxldGUgc2NhbGUudW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIGNvbnN0IG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgICAgcmV2ZXJzZSA9IHJhbmdlJDFbMV0gPCByYW5nZSQxWzBdLFxuICAgICAgICAgIHN0b3AgPSByYW5nZSQxWzEgLSByZXZlcnNlXSxcbiAgICAgICAgICBzcGFjZSA9IGJhbmRTcGFjZShuLCBwYWRkaW5nSW5uZXIsIHBhZGRpbmdPdXRlcik7XG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2UkMVtyZXZlcnNlIC0gMF07XG4gICAgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gKHNwYWNlIHx8IDEpO1xuXG4gICAgaWYgKHJvdW5kKSB7XG4gICAgICBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICB9XG5cbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuXG4gICAgaWYgKHJvdW5kKSB7XG4gICAgICBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpO1xuICAgICAgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlcyA9IHJhbmdlKG4pLm1hcChpID0+IHN0YXJ0ICsgc3RlcCAqIGkpO1xuICAgIHJldHVybiBvcmRpbmFsUmFuZ2UocmV2ZXJzZSA/IHZhbHVlcy5yZXZlcnNlKCkgOiB2YWx1ZXMpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZG9tYWluKF8pO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRvbWFpbigpO1xuICAgIH1cbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJhbmdlJDEgPSBbK19bMF0sICtfWzFdXTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByYW5nZSQxLnNsaWNlKCk7XG4gICAgfVxuICB9O1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbiAoXykge1xuICAgIHJhbmdlJDEgPSBbK19bMF0sICtfWzFdXTtcbiAgICByb3VuZCA9IHRydWU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcblxuICBzY2FsZS5zdGVwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdGVwO1xuICB9O1xuXG4gIHNjYWxlLnJvdW5kID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcm91bmQgPSAhIV87XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm91bmQ7XG4gICAgfVxuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBwYWRkaW5nT3V0ZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSk7XG4gICAgICBwYWRkaW5nSW5uZXIgPSBwYWRkaW5nT3V0ZXI7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFkZGluZ0lubmVyO1xuICAgIH1cbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBwYWRkaW5nSW5uZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSk7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFkZGluZ0lubmVyO1xuICAgIH1cbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBwYWRkaW5nT3V0ZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSk7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFkZGluZ091dGVyO1xuICAgIH1cbiAgfTtcblxuICBzY2FsZS5hbGlnbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH1cbiAgfTtcblxuICBzY2FsZS5pbnZlcnRSYW5nZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgLy8gYmFpbCBpZiByYW5nZSBoYXMgbnVsbCBvciB1bmRlZmluZWQgdmFsdWVzXG4gICAgaWYgKF9bMF0gPT0gbnVsbCB8fCBfWzFdID09IG51bGwpIHJldHVybjtcbiAgICBjb25zdCByZXZlcnNlID0gcmFuZ2UkMVsxXSA8IHJhbmdlJDFbMF0sXG4gICAgICAgICAgdmFsdWVzID0gcmV2ZXJzZSA/IG9yZGluYWxSYW5nZSgpLnJldmVyc2UoKSA6IG9yZGluYWxSYW5nZSgpLFxuICAgICAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICBsZXQgbG8gPSArX1swXSxcbiAgICAgICAgaGkgPSArX1sxXSxcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgdDsgLy8gYmFpbCBpZiBlaXRoZXIgcmFuZ2UgZW5kcG9pbnQgaXMgaW52YWxpZFxuXG4gICAgaWYgKGxvICE9PSBsbyB8fCBoaSAhPT0gaGkpIHJldHVybjsgLy8gb3JkZXIgcmFuZ2UgaW5wdXRzLCBiYWlsIGlmIG91dHNpZGUgb2Ygc2NhbGUgcmFuZ2VcblxuICAgIGlmIChoaSA8IGxvKSB7XG4gICAgICB0ID0gbG87XG4gICAgICBsbyA9IGhpO1xuICAgICAgaGkgPSB0O1xuICAgIH1cblxuICAgIGlmIChoaSA8IHZhbHVlc1swXSB8fCBsbyA+IHJhbmdlJDFbMSAtIHJldmVyc2VdKSByZXR1cm47IC8vIGJpbmFyeSBzZWFyY2ggdG8gaW5kZXggaW50byBzY2FsZSByYW5nZVxuXG4gICAgYSA9IE1hdGgubWF4KDAsIGJpc2VjdFJpZ2h0KHZhbHVlcywgbG8pIC0gMSk7XG4gICAgYiA9IGxvID09PSBoaSA/IGEgOiBiaXNlY3RSaWdodCh2YWx1ZXMsIGhpKSAtIDE7IC8vIGluY3JlbWVudCBpbmRleCBhIGlmIGxvIGlzIHdpdGhpbiBwYWRkaW5nIGdhcFxuXG4gICAgaWYgKGxvIC0gdmFsdWVzW2FdID4gYmFuZHdpZHRoICsgMWUtMTApICsrYTtcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAvLyBtYXAgKyBzd2FwXG4gICAgICB0ID0gYTtcbiAgICAgIGEgPSBuIC0gYjtcbiAgICAgIGIgPSBuIC0gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gYSA+IGIgPyB1bmRlZmluZWQgOiBkb21haW4oKS5zbGljZShhLCBiICsgMSk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNjYWxlLmludmVydFJhbmdlKFtfLCBfXSk7XG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWVbMF0gOiB2YWx1ZTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBiYW5kKCkuZG9tYWluKGRvbWFpbigpKS5yYW5nZShyYW5nZSQxKS5yb3VuZChyb3VuZCkucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcikucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlcikuYWxpZ24oYWxpZ24pO1xuICB9O1xuXG4gIHJldHVybiByZXNjYWxlKCk7XG59XG5cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIGNvbnN0IGNvcHkgPSBzY2FsZS5jb3B5O1xuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBvaW50aXNoKGNvcHkoKSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBwb2ludCgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQoKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuXG52YXIgbWFwID0gQXJyYXkucHJvdG90eXBlLm1hcDtcbmZ1bmN0aW9uIG51bWJlcnMoXykge1xuICByZXR1cm4gbWFwLmNhbGwoXywgdG9OdW1iZXIpO1xufVxuXG5jb25zdCBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gc2NhbGVCaW5PcmRpbmFsKCkge1xuICBsZXQgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsIHx8IHggIT09IHggPyB1bmRlZmluZWQgOiByYW5nZVsoYmlzZWN0KGRvbWFpbiwgeCkgLSAxKSAlIHJhbmdlLmxlbmd0aF07XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBkb21haW4gPSBudW1iZXJzKF8pO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgfVxuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmFuZ2UgPSBzbGljZS5jYWxsKF8pO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmFuZ2Uuc2xpY2UoKTtcbiAgICB9XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uIChjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIHRpY2tGb3JtYXQkMShkb21haW5bMF0sIHBlZWsoZG9tYWluKSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQsIHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2NhbGVCaW5PcmRpbmFsKCkuZG9tYWluKHNjYWxlLmRvbWFpbigpKS5yYW5nZShzY2FsZS5yYW5nZSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmNvbnN0IHNjYWxlcyA9IHt9O1xuLyoqXG4gKiBBdWdtZW50IHNjYWxlcyB3aXRoIHRoZWlyIHR5cGUgYW5kIG5lZWRlZCBpbnZlcnNlIG1ldGhvZHMuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHR5cGUsIGNvbnN0cnVjdG9yLCBtZXRhZGF0YSkge1xuICBjb25zdCBjdHIgPSBmdW5jdGlvbiBzY2FsZSgpIHtcbiAgICBjb25zdCBzID0gY29uc3RydWN0b3IoKTtcblxuICAgIGlmICghcy5pbnZlcnRSYW5nZSkge1xuICAgICAgcy5pbnZlcnRSYW5nZSA9IHMuaW52ZXJ0ID8gaW52ZXJ0UmFuZ2UocykgOiBzLmludmVydEV4dGVudCA/IGludmVydFJhbmdlRXh0ZW50KHMpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHMudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHM7XG4gIH07XG5cbiAgY3RyLm1ldGFkYXRhID0gdG9TZXQoYXJyYXkobWV0YWRhdGEpKTtcbiAgcmV0dXJuIGN0cjtcbn1cblxuZnVuY3Rpb24gc2NhbGUodHlwZSwgc2NhbGUsIG1ldGFkYXRhKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHNjYWxlc1t0eXBlXSA9IGNyZWF0ZSh0eXBlLCBzY2FsZSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc1ZhbGlkU2NhbGVUeXBlKHR5cGUpID8gc2NhbGVzW3R5cGVdIDogdW5kZWZpbmVkO1xuICB9XG59IC8vIGlkZW50aXR5IHNjYWxlXG5cbnNjYWxlKElkZW50aXR5LCBzY2FsZUlkZW50aXR5KTsgLy8gY29udGludW91cyBzY2FsZXNcblxuc2NhbGUoTGluZWFyLCBzY2FsZUxpbmVhciwgQ29udGludW91cyk7XG5zY2FsZShMb2csIHNjYWxlTG9nLCBbQ29udGludW91cywgTG9nXSk7XG5zY2FsZShQb3csIHNjYWxlUG93LCBDb250aW51b3VzKTtcbnNjYWxlKFNxcnQsIHNjYWxlU3FydCwgQ29udGludW91cyk7XG5zY2FsZShTeW1sb2csIHNjYWxlU3ltbG9nLCBDb250aW51b3VzKTtcbnNjYWxlKFRpbWUsIHNjYWxlVGltZSwgW0NvbnRpbnVvdXMsIFRlbXBvcmFsXSk7XG5zY2FsZShVVEMsIHNjYWxlVXRjLCBbQ29udGludW91cywgVGVtcG9yYWxdKTsgLy8gc2VxdWVudGlhbCBzY2FsZXNcblxuc2NhbGUoU2VxdWVudGlhbCwgc2NhbGVTZXF1ZW50aWFsLCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pOyAvLyBiYWNrd2FyZHMgY29tcGF0XG5cbnNjYWxlKFwiXCIuY29uY2F0KFNlcXVlbnRpYWwsIFwiLVwiKS5jb25jYXQoTGluZWFyKSwgc2NhbGVTZXF1ZW50aWFsLCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pO1xuc2NhbGUoXCJcIi5jb25jYXQoU2VxdWVudGlhbCwgXCItXCIpLmNvbmNhdChMb2cpLCBzY2FsZVNlcXVlbnRpYWxMb2csIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nLCBMb2ddKTtcbnNjYWxlKFwiXCIuY29uY2F0KFNlcXVlbnRpYWwsIFwiLVwiKS5jb25jYXQoUG93KSwgc2NhbGVTZXF1ZW50aWFsUG93LCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pO1xuc2NhbGUoXCJcIi5jb25jYXQoU2VxdWVudGlhbCwgXCItXCIpLmNvbmNhdChTcXJ0KSwgc2NhbGVTZXF1ZW50aWFsU3FydCwgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTtcbnNjYWxlKFwiXCIuY29uY2F0KFNlcXVlbnRpYWwsIFwiLVwiKS5jb25jYXQoU3ltbG9nKSwgc2NhbGVTZXF1ZW50aWFsU3ltbG9nLCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pOyAvLyBkaXZlcmdpbmcgc2NhbGVzXG5cbnNjYWxlKFwiXCIuY29uY2F0KERpdmVyZ2luZywgXCItXCIpLmNvbmNhdChMaW5lYXIpLCBzY2FsZURpdmVyZ2luZywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTtcbnNjYWxlKFwiXCIuY29uY2F0KERpdmVyZ2luZywgXCItXCIpLmNvbmNhdChMb2cpLCBzY2FsZURpdmVyZ2luZ0xvZywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmcsIExvZ10pO1xuc2NhbGUoXCJcIi5jb25jYXQoRGl2ZXJnaW5nLCBcIi1cIikuY29uY2F0KFBvdyksIHNjYWxlRGl2ZXJnaW5nUG93LCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pO1xuc2NhbGUoXCJcIi5jb25jYXQoRGl2ZXJnaW5nLCBcIi1cIikuY29uY2F0KFNxcnQpLCBzY2FsZURpdmVyZ2luZ1NxcnQsIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5zY2FsZShcIlwiLmNvbmNhdChEaXZlcmdpbmcsIFwiLVwiKS5jb25jYXQoU3ltbG9nKSwgc2NhbGVEaXZlcmdpbmdTeW1sb2csIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7IC8vIGRpc2NyZXRpemluZyBzY2FsZXNcblxuc2NhbGUoUXVhbnRpbGUsIHNjYWxlUXVhbnRpbGUsIFtEaXNjcmV0aXppbmcsIFF1YW50aWxlXSk7XG5zY2FsZShRdWFudGl6ZSwgc2NhbGVRdWFudGl6ZSwgRGlzY3JldGl6aW5nKTtcbnNjYWxlKFRocmVzaG9sZCwgc2NhbGVUaHJlc2hvbGQsIERpc2NyZXRpemluZyk7IC8vIGRpc2NyZXRlIHNjYWxlc1xuXG5zY2FsZShCaW5PcmRpbmFsLCBzY2FsZUJpbk9yZGluYWwsIFtEaXNjcmV0ZSwgRGlzY3JldGl6aW5nXSk7XG5zY2FsZShPcmRpbmFsLCBzY2FsZU9yZGluYWwsIERpc2NyZXRlKTtcbnNjYWxlKEJhbmQsIGJhbmQsIERpc2NyZXRlKTtcbnNjYWxlKFBvaW50LCBwb2ludCwgRGlzY3JldGUpO1xuZnVuY3Rpb24gaXNWYWxpZFNjYWxlVHlwZSh0eXBlKSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eShzY2FsZXMsIHR5cGUpO1xufVxuXG5mdW5jdGlvbiBoYXNUeXBlKGtleSwgdHlwZSkge1xuICBjb25zdCBzID0gc2NhbGVzW2tleV07XG4gIHJldHVybiBzICYmIHMubWV0YWRhdGFbdHlwZV07XG59XG5cbmZ1bmN0aW9uIGlzQ29udGludW91cyhrZXkpIHtcbiAgcmV0dXJuIGhhc1R5cGUoa2V5LCBDb250aW51b3VzKTtcbn1cbmZ1bmN0aW9uIGlzRGlzY3JldGUoa2V5KSB7XG4gIHJldHVybiBoYXNUeXBlKGtleSwgRGlzY3JldGUpO1xufVxuZnVuY3Rpb24gaXNEaXNjcmV0aXppbmcoa2V5KSB7XG4gIHJldHVybiBoYXNUeXBlKGtleSwgRGlzY3JldGl6aW5nKTtcbn1cbmZ1bmN0aW9uIGlzTG9nYXJpdGhtaWMoa2V5KSB7XG4gIHJldHVybiBoYXNUeXBlKGtleSwgTG9nKTtcbn1cbmZ1bmN0aW9uIGlzVGVtcG9yYWwoa2V5KSB7XG4gIHJldHVybiBoYXNUeXBlKGtleSwgVGVtcG9yYWwpO1xufVxuZnVuY3Rpb24gaXNJbnRlcnBvbGF0aW5nKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIEludGVycG9sYXRpbmcpO1xufVxuZnVuY3Rpb24gaXNRdWFudGlsZShrZXkpIHtcbiAgcmV0dXJuIGhhc1R5cGUoa2V5LCBRdWFudGlsZSk7XG59XG5cbmNvbnN0IHNjYWxlUHJvcHMgPSBbJ2NsYW1wJywgJ2Jhc2UnLCAnY29uc3RhbnQnLCAnZXhwb25lbnQnXTtcbmZ1bmN0aW9uIGludGVycG9sYXRlUmFuZ2UoaW50ZXJwb2xhdG9yLCByYW5nZSkge1xuICBjb25zdCBzdGFydCA9IHJhbmdlWzBdLFxuICAgICAgICBzcGFuID0gcGVlayhyYW5nZSkgLSBzdGFydDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRvcihzdGFydCArIGkgKiBzcGFuKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3JzKGNvbG9ycywgdHlwZSwgZ2FtbWEpIHtcbiAgcmV0dXJuIHBpZWNld2lzZShpbnRlcnBvbGF0ZSh0eXBlIHx8ICdyZ2InLCBnYW1tYSksIGNvbG9ycyk7XG59XG5mdW5jdGlvbiBxdWFudGl6ZUludGVycG9sYXRvcihpbnRlcnBvbGF0b3IsIGNvdW50KSB7XG4gIGNvbnN0IHNhbXBsZXMgPSBuZXcgQXJyYXkoY291bnQpLFxuICAgICAgICBuID0gY291bnQgKyAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7KSBzYW1wbGVzW2ldID0gaW50ZXJwb2xhdG9yKCsraSAvIG4pO1xuXG4gIHJldHVybiBzYW1wbGVzO1xufVxuZnVuY3Rpb24gc2NhbGVDb3B5KHNjYWxlKSB7XG4gIGNvbnN0IHQgPSBzY2FsZS50eXBlLFxuICAgICAgICBzID0gc2NhbGUuY29weSgpO1xuICBzLnR5cGUgPSB0O1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHNjYWxlRnJhY3Rpb24oc2NhbGUkMSwgbWluLCBtYXgpIHtcbiAgY29uc3QgZGVsdGEgPSBtYXggLSBtaW47XG4gIGxldCBpLCB0LCBzO1xuXG4gIGlmICghZGVsdGEgfHwgIU51bWJlci5pc0Zpbml0ZShkZWx0YSkpIHtcbiAgICByZXR1cm4gY29uc3RhbnQoMC41KTtcbiAgfSBlbHNlIHtcbiAgICBpID0gKHQgPSBzY2FsZSQxLnR5cGUpLmluZGV4T2YoJy0nKTtcbiAgICB0ID0gaSA8IDAgPyB0IDogdC5zbGljZShpICsgMSk7XG4gICAgcyA9IHNjYWxlKHQpKCkuZG9tYWluKFttaW4sIG1heF0pLnJhbmdlKFswLCAxXSk7XG4gICAgc2NhbGVQcm9wcy5mb3JFYWNoKG0gPT4gc2NhbGUkMVttXSA/IHNbbV0oc2NhbGUkMVttXSgpKSA6IDApO1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0eXBlLCBnYW1tYSkge1xuICBjb25zdCBpbnRlcnAgPSAkW21ldGhvZCh0eXBlKV07XG4gIHJldHVybiBnYW1tYSAhPSBudWxsICYmIGludGVycCAmJiBpbnRlcnAuZ2FtbWEgPyBpbnRlcnAuZ2FtbWEoZ2FtbWEpIDogaW50ZXJwO1xufVxuXG5mdW5jdGlvbiBtZXRob2QodHlwZSkge1xuICByZXR1cm4gJ2ludGVycG9sYXRlJyArIHR5cGUudG9Mb3dlckNhc2UoKS5zcGxpdCgnLScpLm1hcChzID0+IHNbMF0udG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSkpLmpvaW4oJycpO1xufVxuXG5jb25zdCBjb250aW51b3VzID0ge1xuICBibHVlczogJ2NmZTFmMmJlZDhlY2E4Y2VlNThmYzFkZTc0YjJkNzViYTNjZjQ1OTJjNjMxODFiZDIwNmZiMjEyNWNhNDBhNGE5MCcsXG4gIGdyZWVuczogJ2QzZWVjZGMwZTZiYWFiZGRhNTk0ZDM5MTdiYzc3ZDYwYmE2YzQ2YWI1ZTMyOWE1MTIwODk0MzBlNzczNTAzNjQyOScsXG4gIGdyZXlzOiAnZTJlMmUyZDRkNGQ0YzRjNGM0YjFiMWIxOWQ5ZDlkODg4ODg4NzU3NTc1NjI2MjYyNGQ0ZDRkMzUzNTM1MWUxZTFlJyxcbiAgb3JhbmdlczogJ2ZkZDhiM2ZkYzk5OGZkYjg3YmZkYTU1ZWZjOTI0NGY4N2YyY2YwNmIxOGU0NTgwYmQxNDkwNGI5M2QwMjlmMzMwMycsXG4gIHB1cnBsZXM6ICdlMmUxZWZkNGQ0ZThjNGM1ZTBiNGIzZDZhM2EwY2M5MjhlYzM4MjdjYjk3NTY2YWU2ODRlYTI1YzM2OTY1MDFmOGMnLFxuICByZWRzOiAnZmRjOWI0ZmNiNDlhZmM5ZTgwZmM4NzY3ZmE3MDUxZjY1NzNmZWMzZjJmZGMyYTI1YzgxYjFkYjIxMjE4OTcwYjEzJyxcbiAgYmx1ZUdyZWVuOiAnZDVlZmVkYzFlOGUwYTdkZGQxOGJkMmJlNzBjNmE5NThiYTkxNDRhZDc3MzE5YzVkMjA4OTQ2MGU3NzM2MDM2NDI5JyxcbiAgYmx1ZVB1cnBsZTogJ2NjZGRlY2JhZDBlNGE4YzJkZDlhYjBkNDkxOWNjOThkODViZThiNmRiMjhhNTVhNjg3M2M5OTgyMjI4NzczMGY3MScsXG4gIGdyZWVuQmx1ZTogJ2QzZWVjZWM1ZThjM2IxZTFiYjliZDhiYjgyY2VjMjY5YzJjYTUxYjJjZDNjOWZjNzI4OGFiZDE2NzViMTBiNjBhMScsXG4gIG9yYW5nZVJlZDogJ2ZkZGNhZmZkY2Y5YmZkYzE4YWZkYWQ3N2ZiOTU2MmY2N2Q1M2VlNjU0NWUyNDkzMmQzMmQxZWJmMTMwZGE3MDQwMycsXG4gIHB1cnBsZUJsdWU6ICdkYmRhZWJjOGNlZTRiMWMzZGU5N2I3ZDg3YmFjZDE1YjlmYzkzYTkwYzAxZTdmYjcwYjcwYWIwNTYxOTkwNDUyODEnLFxuICBwdXJwbGVCbHVlR3JlZW46ICdkYmQ4ZWFjOGNlZTRiMGMzZGU5M2I3ZDg3MmFjZDE1NDlmYzgzODkyYmIxYzg4YTMwOTdmODcwMjczNmIwMTYzNTMnLFxuICBwdXJwbGVSZWQ6ICdkY2M5ZTJkM2IzZDdjZTllY2NkMTg2YzBkYTZiYjJlMTRkYTBlMjMxODlkOTFlNmZjNjExNTlhYjA3NDk4ZjAyM2EnLFxuICByZWRQdXJwbGU6ICdmY2NmY2NmY2JlYzBmYWE5YjhmOThmYWZmNTcxYTVlYzUzOWRkYjM2OTVjNDFiOGFhOTA4ODA4ZDAxNzk3MDAxNzQnLFxuICB5ZWxsb3dHcmVlbjogJ2U0ZjRhY2QxZWNhMGI5ZTI5NDllZDY4ODgwYzk3YzYyYmI2ZTQ3YWE1ZTMyOTc1MDIwODM0NDBlNzIzYjAzNjAzNCcsXG4gIHllbGxvd09yYW5nZUJyb3duOiAnZmVlYWExZmVkZDg0ZmVjYzYzZmViNzQ2ZmNhMDMxZjY4OTIxZWI3MjE1ZGI1ZTBiYzU0YzA1YWIzZDAzOGYzMjA0JyxcbiAgeWVsbG93T3JhbmdlUmVkOiAnZmVlMDg3ZmVkMTZmZmViZDU5ZmVhODQ5ZmQ5MDNlZmM3MzM1Zjk1MjJiZWUzNDIzZGUxYjIwY2EwYjIyYWYwMjI1JyxcbiAgYmx1ZU9yYW5nZTogJzEzNGI4NTJmNzhiMzVkYTJjYjlkY2FlMWQyZTVlZmYyZjBlYmZjZTBiYWZiYmY3NGU4OTMyZmM1NjkwZDk5NGEwNycsXG4gIGJyb3duQmx1ZUdyZWVuOiAnNzA0MTA4YTA2NTFhYzc5NTQ4ZTNjNzhhZjNlNmM2ZWVmMWVhYzllOWU0OGVkMWM3NGRhNzllMTg3YTcyMDI1MTQ3JyxcbiAgcHVycGxlR3JlZW46ICc1YjE2Njc4MzQ3OTJhNjdmYjZjOWFlZDNlNmQ2ZThlZmYwZWZkOWVmZDVhZWRkYTk3MWJiNzUzNjhlNDkwZTVlMjknLFxuICBwdXJwbGVPcmFuZ2U6ICc0MTE0Njk2NjQ3OTY4ZjgzYjdiOWI0ZDZkYWRiZWJmM2VlZWFmY2UwYmFmYmJmNzRlODkzMmZjNTY5MGQ5OTRhMDcnLFxuICByZWRCbHVlOiAnOGMwZDI1YmYzNjNhZGY3NDVlZjRhZTkxZmJkYmM5ZjJlZmVlZDJlNWVmOWRjYWUxNWRhMmNiMmY3OGIzMTM0Yjg1JyxcbiAgcmVkR3JleTogJzhjMGQyNWJmMzYzYWRmNzQ1ZWY0YWU5MWZjZGNjYmZhZjRmMWUyZTJlMmMwYzBjMDk2OTY5NjY0NjQ2NDM0MzQzNCcsXG4gIHllbGxvd0dyZWVuQmx1ZTogJ2VmZjliZGRiZjFiNGJkZTViNTk0ZDViOTY5YzViZTQ1YjRjMjJjOWVjMDIxODJiODIxNjNhYTIzNDc5YzFjMzE4NScsXG4gIHJlZFllbGxvd0JsdWU6ICdhNTAwMjZkNDMyMmNmMTZlNDNmY2FjNjRmZWRkOTBmYWY4YzFkY2YxZWNhYmQ2ZTg3NWFiZDA0YTc0YjQzMTM2OTUnLFxuICByZWRZZWxsb3dHcmVlbjogJ2E1MDAyNmQ0MzIyY2YxNmU0M2ZjYWM2M2ZlZGQ4ZGY5ZjdhZWQ3ZWU4ZWE0ZDg2ZTY0YmM2MTIyOTY0ZjAwNjgzNycsXG4gIHBpbmtZZWxsb3dHcmVlbjogJzhlMDE1MmMwMjY3ZWRkNzJhZGYwYjNkNmZhZGRlZGY1ZjNlZmUxZjJjYWI2ZGU4NzgwYmI0NzRmOTEyNTI3NjQxOScsXG4gIHNwZWN0cmFsOiAnOWUwMTQyZDEzYzRiZjA3MDRhZmNhYzYzZmVkZDhkZmJmOGIwZTBmM2ExYTlkZGEyNjliZGE5NDI4OGI1NWU0ZmEyJyxcbiAgdmlyaWRpczogJzQ0MDE1NDQ3MGU2MTQ4MWE2YzQ4MjU3NTQ3MmY3ZDQ0M2E4MzQxNDQ4NzNkNGU4YTM5NTY4YzM1NjA4ZDMxNjg4ZTJkNzA4ZTJhNzg4ZTI3ODE4ZTIzODg4ZTIxOTE4ZDFmOTg4YjFmYTA4ODIyYTg4NDJhYjA3ZjM1Yjc3OTQzYmY3MTU0YzU2ODY2Y2M1ZDdhZDE1MThmZDc0NGE1ZGIzNmJjZGYyN2QyZTIxYmU5ZTUxYWZkZTcyNScsXG4gIG1hZ21hOiAnMDAwMDA0MDQwNDEzMGIwOTI0MTUwZTM3MjAxMTRiMmMxMTYwM2IwZjcwNGExMDc5NTcxNTdlNjUxYTgwNzIxZjgxN2YyNDgyOGMyOTgxOWEyZTgwYTgzMjdkYjYzNzdhYzQzYzc1ZDE0MjZmZGU0OTY4ZTk1NDYyZjE2MDVkZjc2ZjVjZmE3ZjVlZmM4ZjY1ZmU5ZjZkZmVhZjc4ZmViZjg0ZmVjZTkxZmRkZWEwZmNlZGFmZmNmZGJmJyxcbiAgaW5mZXJubzogJzAwMDAwNDA0MDMxMzBjMDgyNjE3MGMzYjI0MGM0ZjMzMGE1ZjQyMGE2ODUwMGQ2YzVkMTI2ZTZiMTc2ZTc4MWM2ZDg2MjE2YjkzMjY2N2ExMmI2MmFlMzA1Y2JiMzc1NWM3M2U0Y2QyNDY0NGRkNTEzYWU2NWMzMGVkNjkyNWYzNzcxYWY4ODUwZmZiOTUwNmZjYTUwYWZjYjUxOWZhYzYyZGY2ZDY0NWYyZTY2MWYzZjQ4NGZjZmZhNCcsXG4gIHBsYXNtYTogJzBkMDg4NzIzMDY5MDMzMDU5NzQyMDM5ZDUwMDJhMjVkMDFhNjZhMDBhODc4MDFhODg0MDVhNzkwMGRhNDljMTc5ZWE3MjE5OGIxMmE5MGJhMzQ4OGMzM2Q4MGNiNDc3OWQzNTE3MWRhNWE2OWUxNjQ2MmU3NmU1YmVkNzk1M2YyODM0Y2Y2OGY0NGZhOWEzZGZjYTYzNmZkYjMyZmZlYzAyOWZjY2UyNWY5ZGMyNGY1ZWEyN2YwZjkyMScsXG4gIGNpdmlkaXM6ICcwMDIwNTEwMDIzNTgwMDI2NWQwMDI5NjEwMTJiNjUwNDJlNjcwODMxNjkwZDM0NmIxMTM2NmMxNjM5NmQxYzNjNmUyMTNmNmUyNjQyNmUyYzQ1NmUzMTQ3NmUzNzRhNmUzYzRkNmU0MjUwNmU0NzUzNmQ0YzU2NmQ1MTU4NmU1NTViNmU1YTVlNmU1ZTYxNmU2MjY0NmY2NjY3NmY2YTZhNzA2ZTZkNzE3MjcwNzE3NTczNzI3OTc2NzM3Yzc5NzQ3ZjdjNzU4MjdmNzU4NjgyNzY4OTg1Nzc4Yzg4Nzc5MDhiNzg5MzhlNzg5NjkxNzg5YTk0Nzg5ZTk3NzhhMTliNzhhNTllNzdhOWExNzdhZWE1NzViMmE4NzRiNmFiNzNiYmFmNzFjMGIyNmZjNWI2NmRjOWI5NmFjZWJkNjhkM2MwNjVkOGM0NjJkZGM4NWZlMmNiNWNlN2NmNThlYmQzNTVmMGQ2NTJmM2RhNGZmN2RlNGNmYWUyNDlmY2U2NDcnLFxuICByYWluYm93OiAnNmU0MGFhODgzZWIxYTQzZGIzYmYzY2FmZDgzZmE0ZWU0Mzk1ZmU0YjgzZmY1NzZlZmY2NjU5ZmY3ODQ3ZmY4YzM4ZjNhMTMwZTJiNzJmY2ZjYzM2YmVlMDQ0YWZmMDViOGZmNDU3NmZmNjViNTJmNjY3M2FmMjc4MjhlYThkMWRkZmEzMTlkMGI4MWNiZWNiMjNhYmQ4MmY5NmUwM2Q4MmUxNGM2ZWRiNWE1ZGQwNjY0ZGJmNmU0MGFhJyxcbiAgc2luZWJvdzogJ2ZmNDA0MGZjNTgyYWY0NzIxOGU3OGQwYmQ1YTcwM2JmYmYwMGE3ZDUwMzhkZTcwYjcyZjQxODU4ZmMyYTQwZmY0MDJhZmM1ODE4ZjQ3MjBiZTc4ZDAzZDVhNzAwYmZiZjAzYTdkNTBiOGRlNzE4NzJmNDJhNThmYzQwNDBmZjU4MmFmYzcyMThmNDhkMGJlN2E3MDNkNWJmMDBiZmQ1MDNhN2U3MGI4ZGY0MTg3MmZjMmE1OGZmNDA0MCcsXG4gIHR1cmJvOiAnMjMxNzFiMzIyMDRhM2UyYTcxNDUzNDkzNDkzZWFlNGI0OWM1NGE1M2Q3NDg1ZWU0NDU2OWVlNDA3NGY1M2M3ZmY4Mzc4YWY5MzI5NWY3MmU5ZmY0MmJhOWVmMjhiM2U5MjZiY2UxMjVjNWQ5MjVjZGNmMjdkNWM2MjlkY2JjMmRlM2IyMzJlOWE3MzhlZTlkM2ZmMzkzNDdmNjg5NTBmOTgwNWFmYzc3NjVmZDZlNzBmZTY2N2NmZDVlODhmYzU3OTVmYjUxYTFmODRiYWRmNTQ1YjlmMTQwYzVlYzNjZDBlNjM3ZGFlMDM0ZTRkOTMxZWNkMTJlZjRjOTJiZmFjMDI5ZmZiNjI2ZmZhZDI0ZmZhMjIzZmY5ODIxZmY4ZDFmZmY4MjFkZmY3NzFjZmQ2YzFhZjc2MTE4ZjA1NjE2ZTg0YjE0ZGY0MTExZDUzODBmY2IyZjBkYzAyNjBhYjYxZjA3YWMxODA1YTMxMzAyOWIwZjAwOTUwYzAwOTEwYjAwJyxcbiAgYnJvd25zOiAnZWVkYmJkZWNjYTk2ZTliOTdhZTRhODY1ZGM5ODU2ZDE4OTU0Yzc3ODRjYzA2NzNmYjg1NTM2YWQ0NDMzOWYzNjMyJyxcbiAgdGVhbEJsdWVzOiAnYmNlNGQ4OWRkM2QxODFjM2NiNjViM2MyNDVhMmI5MzY4ZmFlMzQ3ZGEwMzA2YTkzMmM1OTg1JyxcbiAgdGVhbHM6ICdiYmRmZGZhMmQ0ZDU4YWM5Yzk3NWJjYmI2MWIwYWY0ZGE1YTQzNzk5OTgyYjhiOGMxZTdmN2YxMjcyNzMwMDY2NjcnLFxuICB3YXJtR3JleXM6ICdkY2Q0ZDBjZWM1YzFjMGI4YjRiM2FhYTdhNTljOTk5ODkwOGM4YjgyN2Y3ZTc2NzM3MjY4NjY2NjVjNWE1OTUwNGUnLFxuICBnb2xkR3JlZW46ICdmNGQxNjZkNWNhNjBiNmMzNWM5OGJiNTk3Y2IyNTc2MGE2NTY0YjljNTMzZjhmNGYzMzgzNGEyNTc3NDAxNDZjMzYnLFxuICBnb2xkT3JhbmdlOiAnZjRkMTY2ZjhiZTVjZjhhYTRjZjU5ODNiZjM4NTJhZWY3MDFiZTI2MjFmZDY1MzIyYzU0OTIzYjE0MjIzOWUzYTI2JyxcbiAgZ29sZFJlZDogJ2Y0ZDE2NmY2YmU1OWY5YWE1MWZjOTY0ZWY2ODM0YmVlNzM0YWU1NjI0OWRiNTI0N2NmNDI0NGM0MzE0MWI3MWQzZScsXG4gIGxpZ2h0R3JleVJlZDogJ2VmZTllNmUxZGFkN2Q1Y2JjOGM4YmRiOWJiYWVhOWNkOTY3ZGRjN2I0M2UxNWYxOWRmNDAxMWRjMDAwYicsXG4gIGxpZ2h0R3JleVRlYWw6ICdlNGVhZWFkNmRjZGRjOGNlZDJiN2MyYzdhNmI0YmM2NGIwYmYyMmE2YzMyMjk1YzExZjg1YmUxODc2YmMnLFxuICBsaWdodE11bHRpOiAnZTBmMWYyYzRlOWQwYjBkZTlmZDBlMTgxZjZlMDcyZjZjMDUzZjM5OTNlZjc3NDQwZWY0YTNjJyxcbiAgbGlnaHRPcmFuZ2U6ICdmMmU3ZGFmN2Q1YmFmOWM0OTlmYWIxODRmYTljNzNmNjg5NjdlZjc4NjBlODY0NWJkZTUxNWJkNDNkNWInLFxuICBsaWdodFRlYWxCbHVlOiAnZTNlOWUwYzBkY2NmOWFjZWNhN2FiZmM4NTlhZmMwMzg5ZmI5MzI4ZGFkMmY3Y2EwMjc2Yjk1MjU1OTg4JyxcbiAgZGFya0JsdWU6ICczMjMyMzIyZDQ2NjgxYTVjOTMwMDc0YWYwMDhjYmYwNWE3Y2UyNWMwZGQzOGRhZWQ1MGYzZmFmZmZmZmYnLFxuICBkYXJrR29sZDogJzNjM2MzYzU4NGIzNzcyNWUzNDhjNzYzMWFlOGIyYmNmYTQyNGVjYzMxZWY5ZGUzMGZmZjE4NGZmZmZmZicsXG4gIGRhcmtHcmVlbjogJzNhM2EzYTIxNTc0ODAwNmY0ZDA0ODk0MjQ4OWU0Mjc2YjM0MGE2YzYzZGQyZDgzNmZmZWIyY2ZmZmZhYScsXG4gIGRhcmtNdWx0aTogJzM3MzczNzFmNTI4NzE5N2Q4YzI5YTg2OTk1Y2UzZmZmZTgwMGZmZmZmZicsXG4gIGRhcmtSZWQ6ICczNDM0MzQ3MDM2MzM5ZTNjMzhjYzQwMzdlNzVkMWVlYzg2MjBlZWFiMjlmMGNlMzJmZmViMmMnXG59O1xuY29uc3QgZGlzY3JldGUgPSB7XG4gIGNhdGVnb3J5MTA6ICcxZjc3YjRmZjdmMGUyY2EwMmNkNjI3Mjg5NDY3YmQ4YzU2NGJlMzc3YzI3ZjdmN2ZiY2JkMjIxN2JlY2YnLFxuICBjYXRlZ29yeTIwOiAnMWY3N2I0YWVjN2U4ZmY3ZjBlZmZiYjc4MmNhMDJjOThkZjhhZDYyNzI4ZmY5ODk2OTQ2N2JkYzViMGQ1OGM1NjRiYzQ5Yzk0ZTM3N2MyZjdiNmQyN2Y3ZjdmYzdjN2M3YmNiZDIyZGJkYjhkMTdiZWNmOWVkYWU1JyxcbiAgY2F0ZWdvcnkyMGI6ICczOTNiNzk1MjU0YTM2YjZlY2Y5YzllZGU2Mzc5Mzk4Y2EyNTJiNWNmNmJjZWRiOWM4YzZkMzFiZDllMzllN2JhNTJlN2NiOTQ4NDNjMzlhZDQ5NGFkNjYxNmJlNzk2OWM3YjQxNzNhNTUxOTRjZTZkYmRkZTllZDYnLFxuICBjYXRlZ29yeTIwYzogJzMxODJiZDZiYWVkNjllY2FlMWM2ZGJlZmU2NTUwZGZkOGQzY2ZkYWU2YmZkZDBhMjMxYTM1NDc0YzQ3NmExZDk5YmM3ZTljMDc1NmJiMTllOWFjOGJjYmRkY2RhZGFlYjYzNjM2Mzk2OTY5NmJkYmRiZGQ5ZDlkOScsXG4gIHRhYmxlYXUxMDogJzRjNzhhOGY1ODUxOGU0NTc1NjcyYjdiMjU0YTI0YmVlY2EzYmIyNzlhMmZmOWRhNjlkNzU1ZGJhYjBhYycsXG4gIHRhYmxlYXUyMDogJzRjNzhhODllY2FlOWY1ODUxOGZmYmY3OTU0YTI0Yjg4ZDI3YWI3OWEyMGYyY2Y1YjQzOTg5NDgzYmNiNmU0NTc1NmZmOWQ5ODc5NzA2ZWJhYjBhY2Q2NzE5NWZjYmZkMmIyNzlhMmQ2YTVjOTllNzY1ZmQ4YjVhNScsXG4gIGFjY2VudDogJzdmYzk3ZmJlYWVkNGZkYzA4NmZmZmY5OTM4NmNiMGYwMDI3ZmJmNWIxNzY2NjY2NicsXG4gIGRhcmsyOiAnMWI5ZTc3ZDk1ZjAyNzU3MGIzZTcyOThhNjZhNjFlZTZhYjAyYTY3NjFkNjY2NjY2JyxcbiAgcGFpcmVkOiAnYTZjZWUzMWY3OGI0YjJkZjhhMzNhMDJjZmI5YTk5ZTMxYTFjZmRiZjZmZmY3ZjAwY2FiMmQ2NmEzZDlhZmZmZjk5YjE1OTI4JyxcbiAgcGFzdGVsMTogJ2ZiYjRhZWIzY2RlM2NjZWJjNWRlY2JlNGZlZDlhNmZmZmZjY2U1ZDhiZGZkZGFlY2YyZjJmMicsXG4gIHBhc3RlbDI6ICdiM2UyY2RmZGNkYWNjYmQ1ZThmNGNhZTRlNmY1YzlmZmYyYWVmMWUyY2NjY2NjY2MnLFxuICBzZXQxOiAnZTQxYTFjMzc3ZWI4NGRhZjRhOTg0ZWEzZmY3ZjAwZmZmZjMzYTY1NjI4Zjc4MWJmOTk5OTk5JyxcbiAgc2V0MjogJzY2YzJhNWZjOGQ2MjhkYTBjYmU3OGFjM2E2ZDg1NGZmZDkyZmU1YzQ5NGIzYjNiMycsXG4gIHNldDM6ICc4ZGQzYzdmZmZmYjNiZWJhZGFmYjgwNzI4MGIxZDNmZGI0NjJiM2RlNjlmY2NkZTVkOWQ5ZDliYzgwYmRjY2ViYzVmZmVkNmYnXG59O1xuXG5mdW5jdGlvbiBjb2xvcnMocGFsZXR0ZSkge1xuICBjb25zdCBuID0gcGFsZXR0ZS5sZW5ndGggLyA2IHwgMCxcbiAgICAgICAgYyA9IG5ldyBBcnJheShuKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47KSB7XG4gICAgY1tpXSA9ICcjJyArIHBhbGV0dGUuc2xpY2UoaSAqIDYsICsraSAqIDYpO1xuICB9XG5cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIGFwcGx5KF8sIGYpIHtcbiAgZm9yIChjb25zdCBrIGluIF8pIHNjaGVtZShrLCBmKF9ba10pKTtcbn1cblxuY29uc3Qgc2NoZW1lcyA9IHt9O1xuYXBwbHkoZGlzY3JldGUsIGNvbG9ycyk7XG5hcHBseShjb250aW51b3VzLCBfID0+IGludGVycG9sYXRlQ29sb3JzKGNvbG9ycyhfKSkpO1xuZnVuY3Rpb24gc2NoZW1lKG5hbWUsIHNjaGVtZSkge1xuICBuYW1lID0gbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgc2NoZW1lc1tuYW1lXSA9IHNjaGVtZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NoZW1lc1tuYW1lXTtcbiAgfVxufVxuXG5jb25zdCBTeW1ib2xMZWdlbmQgPSAnc3ltYm9sJztcbmNvbnN0IERpc2NyZXRlTGVnZW5kID0gJ2Rpc2NyZXRlJztcbmNvbnN0IEdyYWRpZW50TGVnZW5kID0gJ2dyYWRpZW50JztcblxuY29uc3QgZGVmYXVsdEZvcm1hdHRlciA9IHZhbHVlID0+IGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gU3RyaW5nKHYpKSA6IFN0cmluZyh2YWx1ZSk7XG5cbmNvbnN0IGFzY2VuZGluZyA9IChhLCBiKSA9PiBhWzFdIC0gYlsxXTtcblxuY29uc3QgZGVzY2VuZGluZyA9IChhLCBiKSA9PiBiWzFdIC0gYVsxXTtcbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0aWNrIGNvdW50IG9yIGludGVydmFsIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGUgLSBUaGUgc2NhbGUgZm9yIHdoaWNoIHRvIGdlbmVyYXRlIHRpY2sgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBjb3VudCAtIFRoZSBkZXNpcmVkIHRpY2sgY291bnQgb3IgaW50ZXJ2YWwgc3BlY2lmaWVyLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblN0ZXAgLSBUaGUgZGVzaXJlZCBtaW5pbXVtIHN0ZXAgYmV0d2VlbiB0aWNrIHZhbHVlcy5cbiAqIEByZXR1cm4geyp9IC0gVGhlIHRpY2sgY291bnQgb3IgaW50ZXJ2YWwgZnVuY3Rpb24uXG4gKi9cblxuXG5mdW5jdGlvbiB0aWNrQ291bnQoc2NhbGUsIGNvdW50LCBtaW5TdGVwKSB7XG4gIGxldCBzdGVwO1xuXG4gIGlmIChpc051bWJlcihjb3VudCkpIHtcbiAgICBpZiAoc2NhbGUuYmlucykge1xuICAgICAgY291bnQgPSBNYXRoLm1heChjb3VudCwgc2NhbGUuYmlucy5sZW5ndGgpO1xuICAgIH1cblxuICAgIGlmIChtaW5TdGVwICE9IG51bGwpIHtcbiAgICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIE1hdGguZmxvb3Ioc3BhbihzY2FsZS5kb21haW4oKSkgLyBtaW5TdGVwIHx8IDEpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPYmplY3QoY291bnQpKSB7XG4gICAgc3RlcCA9IGNvdW50LnN0ZXA7XG4gICAgY291bnQgPSBjb3VudC5pbnRlcnZhbDtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhjb3VudCkpIHtcbiAgICBjb3VudCA9IHNjYWxlLnR5cGUgPT09IFRpbWUgPyB0aW1lSW50ZXJ2YWwoY291bnQpIDogc2NhbGUudHlwZSA9PSBVVEMgPyB1dGNJbnRlcnZhbChjb3VudCkgOiBlcnJvcignT25seSB0aW1lIGFuZCB1dGMgc2NhbGVzIGFjY2VwdCBpbnRlcnZhbCBzdHJpbmdzLicpO1xuICAgIGlmIChzdGVwKSBjb3VudCA9IGNvdW50LmV2ZXJ5KHN0ZXApO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuLyoqXG4gKiBGaWx0ZXIgYSBzZXQgb2YgY2FuZGlkYXRlIHRpY2sgdmFsdWVzLCBlbnN1cmluZyB0aGF0IG9ubHkgdGljayB2YWx1ZXNcbiAqIHRoYXQgbGllIHdpdGhpbiB0aGUgc2NhbGUgcmFuZ2UgYXJlIGluY2x1ZGVkLlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGUgLSBUaGUgc2NhbGUgZm9yIHdoaWNoIHRvIGdlbmVyYXRlIHRpY2sgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTwqPn0gdGlja3MgLSBUaGUgY2FuZGlkYXRlIHRpY2sgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBjb3VudCAtIFRoZSB0aWNrIGNvdW50IG9yIGludGVydmFsIGZ1bmN0aW9uLlxuICogQHJldHVybiB7QXJyYXk8Kj59IC0gVGhlIGZpbHRlcmVkIHRpY2sgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkVGlja3Moc2NhbGUsIHRpY2tzLCBjb3VudCkge1xuICBsZXQgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpLFxuICAgICAgbG8gPSByYW5nZVswXSxcbiAgICAgIGhpID0gcGVlayhyYW5nZSksXG4gICAgICBjbXAgPSBhc2NlbmRpbmc7XG5cbiAgaWYgKGxvID4gaGkpIHtcbiAgICByYW5nZSA9IGhpO1xuICAgIGhpID0gbG87XG4gICAgbG8gPSByYW5nZTtcbiAgICBjbXAgPSBkZXNjZW5kaW5nO1xuICB9XG5cbiAgbG8gPSBNYXRoLmZsb29yKGxvKTtcbiAgaGkgPSBNYXRoLmNlaWwoaGkpOyAvLyBmaWx0ZXIgdGlja3MgdG8gdmFsaWQgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2VcbiAgLy8gYWRkaXRpb25hbGx5IHNvcnQgdGlja3MgaW4gcmFuZ2Ugb3JkZXIgKCMyNTc5KVxuXG4gIHRpY2tzID0gdGlja3MubWFwKHYgPT4gW3YsIHNjYWxlKHYpXSkuZmlsdGVyKF8gPT4gbG8gPD0gX1sxXSAmJiBfWzFdIDw9IGhpKS5zb3J0KGNtcCkubWFwKF8gPT4gX1swXSk7XG5cbiAgaWYgKGNvdW50ID4gMCAmJiB0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgZW5kcG9pbnRzID0gW3RpY2tzWzBdLCBwZWVrKHRpY2tzKV07XG5cbiAgICB3aGlsZSAodGlja3MubGVuZ3RoID4gY291bnQgJiYgdGlja3MubGVuZ3RoID49IDMpIHtcbiAgICAgIHRpY2tzID0gdGlja3MuZmlsdGVyKChfLCBpKSA9PiAhKGkgJSAyKSk7XG4gICAgfVxuXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHRpY2tzID0gZW5kcG9pbnRzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aWNrcztcbn1cbi8qKlxuICogR2VuZXJhdGUgdGljayB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBzY2FsZSBhbmQgYXBwcm94aW1hdGUgdGljayBjb3VudCBvclxuICogaW50ZXJ2YWwgdmFsdWUuIElmIHRoZSBzY2FsZSBoYXMgYSAndGlja3MnIG1ldGhvZCwgaXQgd2lsbCBiZSB1c2VkIHRvXG4gKiBnZW5lcmF0ZSB0aGUgdGlja3MsIHdpdGggdGhlIGNvdW50IGFyZ3VtZW50IHBhc3NlZCBhcyBhIHBhcmFtZXRlci4gSWYgdGhlXG4gKiBzY2FsZSBsYWNrcyBhICd0aWNrcycgbWV0aG9kLCB0aGUgZnVsbCBzY2FsZSBkb21haW4gd2lsbCBiZSByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlIC0gVGhlIHNjYWxlIGZvciB3aGljaCB0byBnZW5lcmF0ZSB0aWNrIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW2NvdW50XSAtIFRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgZGVzaXJlZCB0aWNrcy5cbiAqIEByZXR1cm4ge0FycmF5PCo+fSAtIFRoZSBnZW5lcmF0ZWQgdGljayB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gdGlja1ZhbHVlcyhzY2FsZSwgY291bnQpIHtcbiAgcmV0dXJuIHNjYWxlLmJpbnMgPyB2YWxpZFRpY2tzKHNjYWxlLCBzY2FsZS5iaW5zKSA6IHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MoY291bnQpIDogc2NhbGUuZG9tYWluKCk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgbGFiZWwgZm9ybWF0IGZ1bmN0aW9uIGZvciBhIHNjYWxlLiBJZiB0aGUgc2NhbGUgaGFzIGFcbiAqICd0aWNrRm9ybWF0JyBtZXRob2QsIGl0IHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZm9ybWF0dGVyLCB3aXRoIHRoZVxuICogY291bnQgYW5kIHNwZWNpZmllciBhcmd1bWVudHMgcGFzc2VkIGFzIHBhcmFtZXRlcnMuIElmIHRoZSBzY2FsZSBsYWNrcyBhXG4gKiAndGlja0Zvcm1hdCcgbWV0aG9kLCB0aGUgcmV0dXJuZWQgZm9ybWF0dGVyIHBlcmZvcm1zIHNpbXBsZSBzdHJpbmcgY29lcmNpb24uXG4gKiBJZiB0aGUgaW5wdXQgc2NhbGUgaXMgYSBsb2dhcml0aG1pYyBzY2FsZSBhbmQgdGhlIGZvcm1hdCBzcGVjaWZpZXIgZG9lcyBub3RcbiAqIGluZGljYXRlIGEgZGVzaXJlZCBkZWNpbWFsIHByZWNpc2lvbiwgYSBzcGVjaWFsIHZhcmlhYmxlIHByZWNpc2lvbiBmb3JtYXR0ZXJcbiAqIHRoYXQgYXV0b21hdGljYWxseSB0cmltcyB0cmFpbGluZyB6ZXJvZXMgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZSAtIFRoZSBzY2FsZSBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgdGhlIGxhYmVsIGZvcm1hdHRlci5cbiAqIEBwYXJhbSB7Kn0gW2NvdW50XSAtIFRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgZGVzaXJlZCB0aWNrcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3BlY2lmaWVyXSAtIFRoZSBmb3JtYXQgc3BlY2lmaWVyLiBNdXN0IGJlIGEgbGVnYWwgZDNcbiAqICAgc3BlY2lmaWVyIHN0cmluZyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1mb3JtYXQjZm9ybWF0U3BlY2lmaWVyKSBvclxuICogICB0aW1lIG11bHRpLWZvcm1hdCBzcGVjaWZpZXIgb2JqZWN0LlxuICogQHJldHVybiB7ZnVuY3Rpb24oKik6c3RyaW5nfSAtIFRoZSBnZW5lcmF0ZWQgbGFiZWwgZm9ybWF0dGVyLlxuICovXG5cbmZ1bmN0aW9uIHRpY2tGb3JtYXQobG9jYWxlLCBzY2FsZSwgY291bnQsIHNwZWNpZmllciwgZm9ybWF0VHlwZSwgbm9Ta2lwKSB7XG4gIGNvbnN0IHR5cGUgPSBzY2FsZS50eXBlO1xuICBsZXQgZm9ybWF0ID0gZGVmYXVsdEZvcm1hdHRlcjtcblxuICBpZiAodHlwZSA9PT0gVGltZSB8fCBmb3JtYXRUeXBlID09PSBUaW1lKSB7XG4gICAgZm9ybWF0ID0gbG9jYWxlLnRpbWVGb3JtYXQoc3BlY2lmaWVyKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBVVEMgfHwgZm9ybWF0VHlwZSA9PT0gVVRDKSB7XG4gICAgZm9ybWF0ID0gbG9jYWxlLnV0Y0Zvcm1hdChzcGVjaWZpZXIpO1xuICB9IGVsc2UgaWYgKGlzTG9nYXJpdGhtaWModHlwZSkpIHtcbiAgICBjb25zdCB2YXJmbXQgPSBsb2NhbGUuZm9ybWF0RmxvYXQoc3BlY2lmaWVyKTtcblxuICAgIGlmIChub1NraXAgfHwgc2NhbGUuYmlucykge1xuICAgICAgZm9ybWF0ID0gdmFyZm10O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0ZXN0ID0gdGlja0xvZyhzY2FsZSwgY291bnQsIGZhbHNlKTtcblxuICAgICAgZm9ybWF0ID0gXyA9PiB0ZXN0KF8pID8gdmFyZm10KF8pIDogJyc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNjYWxlLnRpY2tGb3JtYXQpIHtcbiAgICAvLyBpZiBkMyBzY2FsZSBoYXMgdGlja0Zvcm1hdCwgaXQgbXVzdCBiZSBjb250aW51b3VzXG4gICAgY29uc3QgZCA9IHNjYWxlLmRvbWFpbigpO1xuICAgIGZvcm1hdCA9IGxvY2FsZS5mb3JtYXRTcGFuKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQsIHNwZWNpZmllcik7XG4gIH0gZWxzZSBpZiAoc3BlY2lmaWVyKSB7XG4gICAgZm9ybWF0ID0gbG9jYWxlLmZvcm1hdChzcGVjaWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdDtcbn1cbmZ1bmN0aW9uIHRpY2tMb2coc2NhbGUsIGNvdW50LCB2YWx1ZXMpIHtcbiAgY29uc3QgdGlja3MgPSB0aWNrVmFsdWVzKHNjYWxlLCBjb3VudCksXG4gICAgICAgIGJhc2UgPSBzY2FsZS5iYXNlKCksXG4gICAgICAgIGxvZ2IgPSBNYXRoLmxvZyhiYXNlKSxcbiAgICAgICAgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHRpY2tzLmxlbmd0aCk7IC8vIGFwcGx5IGQzLXNjYWxlJ3MgbG9nIGZvcm1hdCBmaWx0ZXIgY3JpdGVyaWFcblxuICBjb25zdCB0ZXN0ID0gZCA9PiB7XG4gICAgbGV0IGkgPSBkIC8gTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhkKSAvIGxvZ2IpKTtcbiAgICBpZiAoaSAqIGJhc2UgPCBiYXNlIC0gMC41KSBpICo9IGJhc2U7XG4gICAgcmV0dXJuIGkgPD0gaztcbiAgfTtcblxuICByZXR1cm4gdmFsdWVzID8gdGlja3MuZmlsdGVyKHRlc3QpIDogdGVzdDtcbn1cblxuY29uc3Qgc3ltYm9scyA9IHtcbiAgW1F1YW50aWxlXTogJ3F1YW50aWxlcycsXG4gIFtRdWFudGl6ZV06ICd0aHJlc2hvbGRzJyxcbiAgW1RocmVzaG9sZF06ICdkb21haW4nXG59O1xuY29uc3QgZm9ybWF0cyA9IHtcbiAgW1F1YW50aWxlXTogJ3F1YW50aWxlcycsXG4gIFtRdWFudGl6ZV06ICdkb21haW4nXG59O1xuZnVuY3Rpb24gbGFiZWxWYWx1ZXMoc2NhbGUsIGNvdW50KSB7XG4gIHJldHVybiBzY2FsZS5iaW5zID8gYmluVmFsdWVzKHNjYWxlLmJpbnMpIDogc2NhbGUudHlwZSA9PT0gTG9nID8gdGlja0xvZyhzY2FsZSwgY291bnQsIHRydWUpIDogc3ltYm9sc1tzY2FsZS50eXBlXSA/IHRocmVzaG9sZFZhbHVlcyhzY2FsZVtzeW1ib2xzW3NjYWxlLnR5cGVdXSgpKSA6IHRpY2tWYWx1ZXMoc2NhbGUsIGNvdW50KTtcbn1cbmZ1bmN0aW9uIHRocmVzaG9sZEZvcm1hdChsb2NhbGUsIHNjYWxlLCBzcGVjaWZpZXIpIHtcbiAgY29uc3QgXyA9IHNjYWxlW2Zvcm1hdHNbc2NhbGUudHlwZV1dKCksXG4gICAgICAgIG4gPSBfLmxlbmd0aDtcblxuICBsZXQgZCA9IG4gPiAxID8gX1sxXSAtIF9bMF0gOiBfWzBdLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgZCA9IE1hdGgubWluKGQsIF9baV0gLSBfW2kgLSAxXSk7XG4gIH0gLy8gdGlja0NvdW50ID0gMyB0aWNrcyB0aW1lcyAxMCBmb3IgaW5jcmVhc2VkIHJlc29sdXRpb25cblxuXG4gIHJldHVybiBsb2NhbGUuZm9ybWF0U3BhbigwLCBkLCAzICogMTAsIHNwZWNpZmllcik7XG59XG5cbmZ1bmN0aW9uIHRocmVzaG9sZFZhbHVlcyh0aHJlc2hvbGRzKSB7XG4gIGNvbnN0IHZhbHVlcyA9IFstSW5maW5pdHldLmNvbmNhdCh0aHJlc2hvbGRzKTtcbiAgdmFsdWVzLm1heCA9ICtJbmZpbml0eTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuZnVuY3Rpb24gYmluVmFsdWVzKGJpbnMpIHtcbiAgY29uc3QgdmFsdWVzID0gYmlucy5zbGljZSgwLCAtMSk7XG4gIHZhbHVlcy5tYXggPSBwZWVrKGJpbnMpO1xuICByZXR1cm4gdmFsdWVzO1xufVxuXG5jb25zdCBpc0Rpc2NyZXRlUmFuZ2UgPSBzY2FsZSA9PiBzeW1ib2xzW3NjYWxlLnR5cGVdIHx8IHNjYWxlLmJpbnM7XG5cbmZ1bmN0aW9uIGxhYmVsRm9ybWF0KGxvY2FsZSwgc2NhbGUsIGNvdW50LCB0eXBlLCBzcGVjaWZpZXIsIGZvcm1hdFR5cGUsIG5vU2tpcCkge1xuICBjb25zdCBmb3JtYXQgPSBmb3JtYXRzW3NjYWxlLnR5cGVdICYmIGZvcm1hdFR5cGUgIT09IFRpbWUgJiYgZm9ybWF0VHlwZSAhPT0gVVRDID8gdGhyZXNob2xkRm9ybWF0KGxvY2FsZSwgc2NhbGUsIHNwZWNpZmllcikgOiB0aWNrRm9ybWF0KGxvY2FsZSwgc2NhbGUsIGNvdW50LCBzcGVjaWZpZXIsIGZvcm1hdFR5cGUsIG5vU2tpcCk7XG4gIHJldHVybiB0eXBlID09PSBTeW1ib2xMZWdlbmQgJiYgaXNEaXNjcmV0ZVJhbmdlKHNjYWxlKSA/IGZvcm1hdFJhbmdlKGZvcm1hdCkgOiB0eXBlID09PSBEaXNjcmV0ZUxlZ2VuZCA/IGZvcm1hdERpc2NyZXRlKGZvcm1hdCkgOiBmb3JtYXRQb2ludChmb3JtYXQpO1xufVxuXG5jb25zdCBmb3JtYXRSYW5nZSA9IGZvcm1hdCA9PiAodmFsdWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICBjb25zdCBsaW1pdCA9IGdldChhcnJheVtpbmRleCArIDFdLCBnZXQoYXJyYXkubWF4LCArSW5maW5pdHkpKSxcbiAgICAgICAgbG8gPSBmb3JtYXRWYWx1ZSh2YWx1ZSwgZm9ybWF0KSxcbiAgICAgICAgaGkgPSBmb3JtYXRWYWx1ZShsaW1pdCwgZm9ybWF0KTtcbiAgcmV0dXJuIGxvICYmIGhpID8gbG8gKyAnIFxcdTIwMTMgJyArIGhpIDogaGkgPyAnPCAnICsgaGkgOiAnXFx1MjI2NSAnICsgbG87XG59O1xuXG5jb25zdCBnZXQgPSAodmFsdWUsIGRmbHQpID0+IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGRmbHQ7XG5cbmNvbnN0IGZvcm1hdERpc2NyZXRlID0gZm9ybWF0ID0+ICh2YWx1ZSwgaW5kZXgpID0+IGluZGV4ID8gZm9ybWF0KHZhbHVlKSA6IG51bGw7XG5cbmNvbnN0IGZvcm1hdFBvaW50ID0gZm9ybWF0ID0+IHZhbHVlID0+IGZvcm1hdCh2YWx1ZSk7XG5cbmNvbnN0IGZvcm1hdFZhbHVlID0gKHZhbHVlLCBmb3JtYXQpID0+IE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPyBmb3JtYXQodmFsdWUpIDogbnVsbDtcblxuZnVuY3Rpb24gbGFiZWxGcmFjdGlvbihzY2FsZSkge1xuICBjb25zdCBkb21haW4gPSBzY2FsZS5kb21haW4oKSxcbiAgICAgICAgY291bnQgPSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gK2RvbWFpblswXSxcbiAgICAgIGhpID0gK3BlZWsoZG9tYWluKSxcbiAgICAgIHNwYW4gPSBoaSAtIGxvO1xuXG4gIGlmIChzY2FsZS50eXBlID09PSBUaHJlc2hvbGQpIHtcbiAgICBjb25zdCBhZGp1c3QgPSBjb3VudCA/IHNwYW4gLyBjb3VudCA6IDAuMTtcbiAgICBsbyAtPSBhZGp1c3Q7XG4gICAgaGkgKz0gYWRqdXN0O1xuICAgIHNwYW4gPSBoaSAtIGxvO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlID0+ICh2YWx1ZSAtIGxvKSAvIHNwYW47XG59XG5cbmZ1bmN0aW9uIGZvcm1hdChsb2NhbGUsIHNjYWxlLCBzcGVjaWZpZXIsIGZvcm1hdFR5cGUpIHtcbiAgY29uc3QgdHlwZSA9IGZvcm1hdFR5cGUgfHwgc2NhbGUudHlwZTsgLy8gcmVwbGFjZSBhYmJyZXZpYXRlZCB0aW1lIHNwZWNpZmllcnMgdG8gaW1wcm92ZSBzY3JlZW4gcmVhZGVyIGV4cGVyaWVuY2VcblxuICBpZiAoaXNTdHJpbmcoc3BlY2lmaWVyKSAmJiBpc1RlbXBvcmFsKHR5cGUpKSB7XG4gICAgc3BlY2lmaWVyID0gc3BlY2lmaWVyLnJlcGxhY2UoLyVhL2csICclQScpLnJlcGxhY2UoLyViL2csICclQicpO1xuICB9XG5cbiAgcmV0dXJuICFzcGVjaWZpZXIgJiYgdHlwZSA9PT0gVGltZSA/IGxvY2FsZS50aW1lRm9ybWF0KCclQSwgJWQgJUIgJVksICVYJykgOiAhc3BlY2lmaWVyICYmIHR5cGUgPT09IFVUQyA/IGxvY2FsZS51dGNGb3JtYXQoJyVBLCAlZCAlQiAlWSwgJVggVVRDJykgOiBsYWJlbEZvcm1hdChsb2NhbGUsIHNjYWxlLCA1LCBudWxsLCBzcGVjaWZpZXIsIGZvcm1hdFR5cGUsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBkb21haW5DYXB0aW9uKGxvY2FsZSwgc2NhbGUsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KDMsIG9wdC5tYXhsZW4gfHwgNyksXG4gICAgICAgIGZtdCA9IGZvcm1hdChsb2NhbGUsIHNjYWxlLCBvcHQuZm9ybWF0LCBvcHQuZm9ybWF0VHlwZSk7IC8vIGlmIHNjYWxlIGJyZWFrcyBkb21haW4gaW50byBiaW5zLCBkZXNjcmliZSBib3VuZGFyaWVzXG5cbiAgaWYgKGlzRGlzY3JldGl6aW5nKHNjYWxlLnR5cGUpKSB7XG4gICAgY29uc3QgdiA9IGxhYmVsVmFsdWVzKHNjYWxlKS5zbGljZSgxKS5tYXAoZm10KSxcbiAgICAgICAgICBuID0gdi5sZW5ndGg7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG4sIFwiIGJvdW5kYXJcIikuY29uY2F0KG4gPT09IDEgPyAneScgOiAnaWVzJywgXCI6IFwiKS5jb25jYXQodi5qb2luKCcsICcpKTtcbiAgfSAvLyBpZiBzY2FsZSBkb21haW4gaXMgZGlzY3JldGUsIGxpc3QgdmFsdWVzXG4gIGVsc2UgaWYgKGlzRGlzY3JldGUoc2NhbGUudHlwZSkpIHtcbiAgICAgIGNvbnN0IGQgPSBzY2FsZS5kb21haW4oKSxcbiAgICAgICAgICAgIG4gPSBkLmxlbmd0aCxcbiAgICAgICAgICAgIHYgPSBuID4gbWF4ID8gZC5zbGljZSgwLCBtYXggLSAyKS5tYXAoZm10KS5qb2luKCcsICcpICsgJywgZW5kaW5nIHdpdGggJyArIGQuc2xpY2UoLTEpLm1hcChmbXQpIDogZC5tYXAoZm10KS5qb2luKCcsICcpO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG4sIFwiIHZhbHVlXCIpLmNvbmNhdChuID09PSAxID8gJycgOiAncycsIFwiOiBcIikuY29uY2F0KHYpO1xuICAgIH0gLy8gaWYgc2NhbGUgZG9tYWluIGlzIGNvbnRpbnVvdXMsIGRlc2NyaWJlIHZhbHVlIHJhbmdlXG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGQgPSBzY2FsZS5kb21haW4oKTtcbiAgICAgICAgcmV0dXJuIFwidmFsdWVzIGZyb20gXCIuY29uY2F0KGZtdChkWzBdKSwgXCIgdG8gXCIpLmNvbmNhdChmbXQocGVlayhkKSkpO1xuICAgICAgfVxufVxuXG5leHBvcnQgeyBCYW5kLCBCaW5PcmRpbmFsLCBEaXNjcmV0ZUxlZ2VuZCwgRGl2ZXJnaW5nLCBHcmFkaWVudExlZ2VuZCwgSWRlbnRpdHksIExpbmVhciwgTG9nLCBPcmRpbmFsLCBQb2ludCwgUG93LCBRdWFudGlsZSwgUXVhbnRpemUsIFNlcXVlbnRpYWwsIFNxcnQsIFN5bWJvbExlZ2VuZCwgU3ltbG9nLCBUaHJlc2hvbGQsIFRpbWUsIFVUQywgYmFuZFNwYWNlLCBkb21haW5DYXB0aW9uLCBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGVDb2xvcnMsIGludGVycG9sYXRlUmFuZ2UsIGlzQ29udGludW91cywgaXNEaXNjcmV0ZSwgaXNEaXNjcmV0aXppbmcsIGlzSW50ZXJwb2xhdGluZywgaXNMb2dhcml0aG1pYywgaXNRdWFudGlsZSwgaXNUZW1wb3JhbCwgaXNWYWxpZFNjYWxlVHlwZSwgbGFiZWxGb3JtYXQsIGxhYmVsRnJhY3Rpb24sIGxhYmVsVmFsdWVzLCBxdWFudGl6ZUludGVycG9sYXRvciwgc2NhbGUsIHNjYWxlQ29weSwgc2NhbGVGcmFjdGlvbiwgc2NoZW1lLCB0aWNrQ291bnQsIHRpY2tGb3JtYXQsIHRpY2tWYWx1ZXMsIHZhbGlkVGlja3MgfTtcbiIsImltcG9ydCB7IGhhc093blByb3BlcnR5LCBpc0Z1bmN0aW9uLCBpbmhlcml0cywgdHJ1dGh5LCBscnVDYWNoZSwgaXNBcnJheSwgZXJyb3IsIHRvU2V0LCBhcnJheSwgcGVlaywgZXh0ZW5kLCBpc051bWJlciwgaXNPYmplY3QgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgY3VydmVCYXNpcywgY3VydmVCYXNpc0Nsb3NlZCwgY3VydmVCYXNpc09wZW4sIGN1cnZlQnVuZGxlLCBjdXJ2ZUNhcmRpbmFsLCBjdXJ2ZUNhcmRpbmFsT3BlbiwgY3VydmVDYXJkaW5hbENsb3NlZCwgY3VydmVDYXRtdWxsUm9tLCBjdXJ2ZUNhdG11bGxSb21DbG9zZWQsIGN1cnZlQ2F0bXVsbFJvbU9wZW4sIGN1cnZlTGluZWFyLCBjdXJ2ZUxpbmVhckNsb3NlZCwgY3VydmVNb25vdG9uZVksIGN1cnZlTW9ub3RvbmVYLCBjdXJ2ZU5hdHVyYWwsIGN1cnZlU3RlcCwgY3VydmVTdGVwQWZ0ZXIsIGN1cnZlU3RlcEJlZm9yZSwgYXJjIGFzIGFyYyQyLCBhcmVhIGFzIGFyZWEkMiwgbGluZSBhcyBsaW5lJDIsIHN5bWJvbCBhcyBzeW1ib2wkMiB9IGZyb20gJ2QzLXNoYXBlJztcbmltcG9ydCB7IHBhdGggYXMgcGF0aCQzIH0gZnJvbSAnZDMtcGF0aCc7XG5pbXBvcnQgeyBpbWFnZSBhcyBpbWFnZSQxLCBjYW52YXMgfSBmcm9tICd2ZWdhLWNhbnZhcyc7XG5pbXBvcnQgeyBsb2FkZXIgfSBmcm9tICd2ZWdhLWxvYWRlcic7XG5pbXBvcnQgeyBpc0Rpc2NyZXRlLCBkb21haW5DYXB0aW9uIH0gZnJvbSAndmVnYS1zY2FsZSc7XG5cbmxldCBncmFkaWVudF9pZCA9IDA7XG5mdW5jdGlvbiByZXNldFNWR0dyYWRpZW50SWQoKSB7XG4gIGdyYWRpZW50X2lkID0gMDtcbn1cbmNvbnN0IHBhdHRlcm5QcmVmaXggPSAncF8nO1xuZnVuY3Rpb24gaXNHcmFkaWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuZ3JhZGllbnQ7XG59XG5mdW5jdGlvbiBncmFkaWVudFJlZihnLCBkZWZzLCBiYXNlKSB7XG4gIGNvbnN0IHR5cGUgPSBnLmdyYWRpZW50O1xuICBsZXQgaWQgPSBnLmlkLFxuICAgICAgcHJlZml4ID0gdHlwZSA9PT0gJ3JhZGlhbCcgPyBwYXR0ZXJuUHJlZml4IDogJyc7IC8vIGNoZWNrIGlkLCBhc3NpZ24gZGVmYXVsdCB2YWx1ZXMgYXMgbmVlZGVkXG5cbiAgaWYgKCFpZCkge1xuICAgIGlkID0gZy5pZCA9ICdncmFkaWVudF8nICsgZ3JhZGllbnRfaWQrKztcblxuICAgIGlmICh0eXBlID09PSAncmFkaWFsJykge1xuICAgICAgZy54MSA9IGdldChnLngxLCAwLjUpO1xuICAgICAgZy55MSA9IGdldChnLnkxLCAwLjUpO1xuICAgICAgZy5yMSA9IGdldChnLnIxLCAwKTtcbiAgICAgIGcueDIgPSBnZXQoZy54MiwgMC41KTtcbiAgICAgIGcueTIgPSBnZXQoZy55MiwgMC41KTtcbiAgICAgIGcucjIgPSBnZXQoZy5yMiwgMC41KTtcbiAgICAgIHByZWZpeCA9IHBhdHRlcm5QcmVmaXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGcueDEgPSBnZXQoZy54MSwgMCk7XG4gICAgICBnLnkxID0gZ2V0KGcueTEsIDApO1xuICAgICAgZy54MiA9IGdldChnLngyLCAxKTtcbiAgICAgIGcueTIgPSBnZXQoZy55MiwgMCk7XG4gICAgfVxuICB9IC8vIHJlZ2lzdGVyIGRlZmluaXRpb25cblxuXG4gIGRlZnNbaWRdID0gZzsgLy8gcmV0dXJuIHVybCByZWZlcmVuY2VcblxuICByZXR1cm4gJ3VybCgnICsgKGJhc2UgfHwgJycpICsgJyMnICsgcHJlZml4ICsgaWQgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIGdldCh2YWwsIGRlZikge1xuICByZXR1cm4gdmFsICE9IG51bGwgPyB2YWwgOiBkZWY7XG59XG5cbmZ1bmN0aW9uIEdyYWRpZW50IChwMCwgcDEpIHtcbiAgdmFyIHN0b3BzID0gW10sXG4gICAgICBncmFkaWVudDtcbiAgcmV0dXJuIGdyYWRpZW50ID0ge1xuICAgIGdyYWRpZW50OiAnbGluZWFyJyxcbiAgICB4MTogcDAgPyBwMFswXSA6IDAsXG4gICAgeTE6IHAwID8gcDBbMV0gOiAwLFxuICAgIHgyOiBwMSA/IHAxWzBdIDogMSxcbiAgICB5MjogcDEgPyBwMVsxXSA6IDAsXG4gICAgc3RvcHM6IHN0b3BzLFxuICAgIHN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgICBzdG9wcy5wdXNoKHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBsb29rdXAgPSB7XG4gICdiYXNpcyc6IHtcbiAgICBjdXJ2ZTogY3VydmVCYXNpc1xuICB9LFxuICAnYmFzaXMtY2xvc2VkJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUJhc2lzQ2xvc2VkXG4gIH0sXG4gICdiYXNpcy1vcGVuJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUJhc2lzT3BlblxuICB9LFxuICAnYnVuZGxlJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUJ1bmRsZSxcbiAgICB0ZW5zaW9uOiAnYmV0YScsXG4gICAgdmFsdWU6IDAuODVcbiAgfSxcbiAgJ2NhcmRpbmFsJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUNhcmRpbmFsLFxuICAgIHRlbnNpb246ICd0ZW5zaW9uJyxcbiAgICB2YWx1ZTogMFxuICB9LFxuICAnY2FyZGluYWwtb3Blbic6IHtcbiAgICBjdXJ2ZTogY3VydmVDYXJkaW5hbE9wZW4sXG4gICAgdGVuc2lvbjogJ3RlbnNpb24nLFxuICAgIHZhbHVlOiAwXG4gIH0sXG4gICdjYXJkaW5hbC1jbG9zZWQnOiB7XG4gICAgY3VydmU6IGN1cnZlQ2FyZGluYWxDbG9zZWQsXG4gICAgdGVuc2lvbjogJ3RlbnNpb24nLFxuICAgIHZhbHVlOiAwXG4gIH0sXG4gICdjYXRtdWxsLXJvbSc6IHtcbiAgICBjdXJ2ZTogY3VydmVDYXRtdWxsUm9tLFxuICAgIHRlbnNpb246ICdhbHBoYScsXG4gICAgdmFsdWU6IDAuNVxuICB9LFxuICAnY2F0bXVsbC1yb20tY2xvc2VkJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUNhdG11bGxSb21DbG9zZWQsXG4gICAgdGVuc2lvbjogJ2FscGhhJyxcbiAgICB2YWx1ZTogMC41XG4gIH0sXG4gICdjYXRtdWxsLXJvbS1vcGVuJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUNhdG11bGxSb21PcGVuLFxuICAgIHRlbnNpb246ICdhbHBoYScsXG4gICAgdmFsdWU6IDAuNVxuICB9LFxuICAnbGluZWFyJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUxpbmVhclxuICB9LFxuICAnbGluZWFyLWNsb3NlZCc6IHtcbiAgICBjdXJ2ZTogY3VydmVMaW5lYXJDbG9zZWRcbiAgfSxcbiAgJ21vbm90b25lJzoge1xuICAgIGhvcml6b250YWw6IGN1cnZlTW9ub3RvbmVZLFxuICAgIHZlcnRpY2FsOiBjdXJ2ZU1vbm90b25lWFxuICB9LFxuICAnbmF0dXJhbCc6IHtcbiAgICBjdXJ2ZTogY3VydmVOYXR1cmFsXG4gIH0sXG4gICdzdGVwJzoge1xuICAgIGN1cnZlOiBjdXJ2ZVN0ZXBcbiAgfSxcbiAgJ3N0ZXAtYWZ0ZXInOiB7XG4gICAgY3VydmU6IGN1cnZlU3RlcEFmdGVyXG4gIH0sXG4gICdzdGVwLWJlZm9yZSc6IHtcbiAgICBjdXJ2ZTogY3VydmVTdGVwQmVmb3JlXG4gIH1cbn07XG5mdW5jdGlvbiBjdXJ2ZXModHlwZSwgb3JpZW50YXRpb24sIHRlbnNpb24pIHtcbiAgdmFyIGVudHJ5ID0gaGFzT3duUHJvcGVydHkobG9va3VwLCB0eXBlKSAmJiBsb29rdXBbdHlwZV0sXG4gICAgICBjdXJ2ZSA9IG51bGw7XG5cbiAgaWYgKGVudHJ5KSB7XG4gICAgY3VydmUgPSBlbnRyeS5jdXJ2ZSB8fCBlbnRyeVtvcmllbnRhdGlvbiB8fCAndmVydGljYWwnXTtcblxuICAgIGlmIChlbnRyeS50ZW5zaW9uICYmIHRlbnNpb24gIT0gbnVsbCkge1xuICAgICAgY3VydmUgPSBjdXJ2ZVtlbnRyeS50ZW5zaW9uXSh0ZW5zaW9uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VydmU7XG59XG5cbi8vIFBhdGggcGFyc2luZyBhbmQgcmVuZGVyaW5nIGNvZGUgYWRhcHRlZCBmcm9tIGZhYnJpYy5qcyAtLSBUaGFua3MhXG5jb25zdCBjbWRsZW4gPSB7XG4gIG06IDIsXG4gIGw6IDIsXG4gIGg6IDEsXG4gIHY6IDEsXG4gIGM6IDYsXG4gIHM6IDQsXG4gIHE6IDQsXG4gIHQ6IDIsXG4gIGE6IDdcbn0sXG4gICAgICByZWdleHAgPSBbLyhbTUxIVkNTUVRBWm1saHZjc3F0YXpdKS9nLCAvIyMjLywgLyhcXC5cXGQrKShcXC5cXGQpL2csIC8oXFxkKShbLStdKS9nLCAvXFxzfCx8IyMjL107XG5mdW5jdGlvbiBwYXRoUGFyc2UgKHBhdGhzdHIpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBjdXJyLCBjaHVua3MsIHBhcnNlZCwgcGFyYW0sIGNtZCwgbGVuLCBpLCBqLCBuLCBtOyAvLyBGaXJzdCwgYnJlYWsgcGF0aCBpbnRvIGNvbW1hbmQgc2VxdWVuY2VcblxuICBjb25zdCBwYXRoID0gcGF0aHN0ci5zbGljZSgpLnJlcGxhY2UocmVnZXhwWzBdLCAnIyMjJDEnKS5zcGxpdChyZWdleHBbMV0pLnNsaWNlKDEpOyAvLyBOZXh0LCBwYXJzZSBlYWNoIGNvbW1hbmQgaW4gdHVyblxuXG4gIGZvciAoaSA9IDAsIG4gPSBwYXRoLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGN1cnIgPSBwYXRoW2ldO1xuICAgIGNodW5rcyA9IGN1cnIuc2xpY2UoMSkudHJpbSgpLnJlcGxhY2UocmVnZXhwWzJdLCAnJDEjIyMkMicpLnJlcGxhY2UocmVnZXhwWzNdLCAnJDEjIyMkMicpLnNwbGl0KHJlZ2V4cFs0XSk7XG4gICAgY21kID0gY3Vyci5jaGFyQXQoMCk7XG4gICAgcGFyc2VkID0gW2NtZF07XG5cbiAgICBmb3IgKGogPSAwLCBtID0gY2h1bmtzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChwYXJhbSA9ICtjaHVua3Nbal0pID09PSBwYXJhbSkge1xuICAgICAgICAvLyBub3QgTmFOXG4gICAgICAgIHBhcnNlZC5wdXNoKHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSBjbWRsZW5bY21kLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgaWYgKHBhcnNlZC5sZW5ndGggLSAxID4gbGVuKSB7XG4gICAgICBjb25zdCBtID0gcGFyc2VkLmxlbmd0aDtcbiAgICAgIGogPSAxO1xuICAgICAgcmVzdWx0LnB1c2goW2NtZF0uY29uY2F0KHBhcnNlZC5zbGljZShqLCBqICs9IGxlbikpKTsgLy8gaGFuZGxlIGltcGxpY2l0IGxpbmVUbyAoIzI4MDMpXG5cbiAgICAgIGNtZCA9IGNtZCA9PT0gJ00nID8gJ0wnIDogY21kID09PSAnbScgPyAnbCcgOiBjbWQ7XG5cbiAgICAgIGZvciAoOyBqIDwgbTsgaiArPSBsZW4pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW2NtZF0uY29uY2F0KHBhcnNlZC5zbGljZShqLCBqICsgbGVuKSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChwYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IERlZ1RvUmFkID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IEVwc2lsb24gPSAxZS0xNDtcbmNvbnN0IEhhbGZQaSA9IE1hdGguUEkgLyAyO1xuY29uc3QgVGF1ID0gTWF0aC5QSSAqIDI7XG5jb25zdCBIYWxmU3FydDMgPSBNYXRoLnNxcnQoMykgLyAyO1xuXG52YXIgc2VnbWVudENhY2hlID0ge307XG52YXIgYmV6aWVyQ2FjaGUgPSB7fTtcbnZhciBqb2luID0gW10uam9pbjsgLy8gQ29waWVkIGZyb20gSW5rc2NhcGUgc3ZndG9wZGYsIHRoYW5rcyFcblxuZnVuY3Rpb24gc2VnbWVudHMoeCwgeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgsIG94LCBveSkge1xuICBjb25zdCBrZXkgPSBqb2luLmNhbGwoYXJndW1lbnRzKTtcblxuICBpZiAoc2VnbWVudENhY2hlW2tleV0pIHtcbiAgICByZXR1cm4gc2VnbWVudENhY2hlW2tleV07XG4gIH1cblxuICBjb25zdCB0aCA9IHJvdGF0ZVggKiBEZWdUb1JhZDtcbiAgY29uc3Qgc2luX3RoID0gTWF0aC5zaW4odGgpO1xuICBjb25zdCBjb3NfdGggPSBNYXRoLmNvcyh0aCk7XG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcbiAgY29uc3QgcHggPSBjb3NfdGggKiAob3ggLSB4KSAqIDAuNSArIHNpbl90aCAqIChveSAtIHkpICogMC41O1xuICBjb25zdCBweSA9IGNvc190aCAqIChveSAtIHkpICogMC41IC0gc2luX3RoICogKG94IC0geCkgKiAwLjU7XG4gIGxldCBwbCA9IHB4ICogcHggLyAocnggKiByeCkgKyBweSAqIHB5IC8gKHJ5ICogcnkpO1xuXG4gIGlmIChwbCA+IDEpIHtcbiAgICBwbCA9IE1hdGguc3FydChwbCk7XG4gICAgcnggKj0gcGw7XG4gICAgcnkgKj0gcGw7XG4gIH1cblxuICBjb25zdCBhMDAgPSBjb3NfdGggLyByeDtcbiAgY29uc3QgYTAxID0gc2luX3RoIC8gcng7XG4gIGNvbnN0IGExMCA9IC1zaW5fdGggLyByeTtcbiAgY29uc3QgYTExID0gY29zX3RoIC8gcnk7XG4gIGNvbnN0IHgwID0gYTAwICogb3ggKyBhMDEgKiBveTtcbiAgY29uc3QgeTAgPSBhMTAgKiBveCArIGExMSAqIG95O1xuICBjb25zdCB4MSA9IGEwMCAqIHggKyBhMDEgKiB5O1xuICBjb25zdCB5MSA9IGExMCAqIHggKyBhMTEgKiB5O1xuICBjb25zdCBkID0gKHgxIC0geDApICogKHgxIC0geDApICsgKHkxIC0geTApICogKHkxIC0geTApO1xuICBsZXQgc2ZhY3Rvcl9zcSA9IDEgLyBkIC0gMC4yNTtcbiAgaWYgKHNmYWN0b3Jfc3EgPCAwKSBzZmFjdG9yX3NxID0gMDtcbiAgbGV0IHNmYWN0b3IgPSBNYXRoLnNxcnQoc2ZhY3Rvcl9zcSk7XG4gIGlmIChzd2VlcCA9PSBsYXJnZSkgc2ZhY3RvciA9IC1zZmFjdG9yO1xuICBjb25zdCB4YyA9IDAuNSAqICh4MCArIHgxKSAtIHNmYWN0b3IgKiAoeTEgLSB5MCk7XG4gIGNvbnN0IHljID0gMC41ICogKHkwICsgeTEpICsgc2ZhY3RvciAqICh4MSAtIHgwKTtcbiAgY29uc3QgdGgwID0gTWF0aC5hdGFuMih5MCAtIHljLCB4MCAtIHhjKTtcbiAgY29uc3QgdGgxID0gTWF0aC5hdGFuMih5MSAtIHljLCB4MSAtIHhjKTtcbiAgbGV0IHRoX2FyYyA9IHRoMSAtIHRoMDtcblxuICBpZiAodGhfYXJjIDwgMCAmJiBzd2VlcCA9PT0gMSkge1xuICAgIHRoX2FyYyArPSBUYXU7XG4gIH0gZWxzZSBpZiAodGhfYXJjID4gMCAmJiBzd2VlcCA9PT0gMCkge1xuICAgIHRoX2FyYyAtPSBUYXU7XG4gIH1cblxuICBjb25zdCBzZWdzID0gTWF0aC5jZWlsKE1hdGguYWJzKHRoX2FyYyAvIChIYWxmUGkgKyAwLjAwMSkpKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzOyArK2kpIHtcbiAgICBjb25zdCB0aDIgPSB0aDAgKyBpICogdGhfYXJjIC8gc2VncztcbiAgICBjb25zdCB0aDMgPSB0aDAgKyAoaSArIDEpICogdGhfYXJjIC8gc2VncztcbiAgICByZXN1bHRbaV0gPSBbeGMsIHljLCB0aDIsIHRoMywgcngsIHJ5LCBzaW5fdGgsIGNvc190aF07XG4gIH1cblxuICByZXR1cm4gc2VnbWVudENhY2hlW2tleV0gPSByZXN1bHQ7XG59XG5mdW5jdGlvbiBiZXppZXIocGFyYW1zKSB7XG4gIGNvbnN0IGtleSA9IGpvaW4uY2FsbChwYXJhbXMpO1xuXG4gIGlmIChiZXppZXJDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIGJlemllckNhY2hlW2tleV07XG4gIH1cblxuICB2YXIgY3ggPSBwYXJhbXNbMF0sXG4gICAgICBjeSA9IHBhcmFtc1sxXSxcbiAgICAgIHRoMCA9IHBhcmFtc1syXSxcbiAgICAgIHRoMSA9IHBhcmFtc1szXSxcbiAgICAgIHJ4ID0gcGFyYW1zWzRdLFxuICAgICAgcnkgPSBwYXJhbXNbNV0sXG4gICAgICBzaW5fdGggPSBwYXJhbXNbNl0sXG4gICAgICBjb3NfdGggPSBwYXJhbXNbN107XG4gIGNvbnN0IGEwMCA9IGNvc190aCAqIHJ4O1xuICBjb25zdCBhMDEgPSAtc2luX3RoICogcnk7XG4gIGNvbnN0IGExMCA9IHNpbl90aCAqIHJ4O1xuICBjb25zdCBhMTEgPSBjb3NfdGggKiByeTtcbiAgY29uc3QgY29zX3RoMCA9IE1hdGguY29zKHRoMCk7XG4gIGNvbnN0IHNpbl90aDAgPSBNYXRoLnNpbih0aDApO1xuICBjb25zdCBjb3NfdGgxID0gTWF0aC5jb3ModGgxKTtcbiAgY29uc3Qgc2luX3RoMSA9IE1hdGguc2luKHRoMSk7XG4gIGNvbnN0IHRoX2hhbGYgPSAwLjUgKiAodGgxIC0gdGgwKTtcbiAgY29uc3Qgc2luX3RoX2gyID0gTWF0aC5zaW4odGhfaGFsZiAqIDAuNSk7XG4gIGNvbnN0IHQgPSA4IC8gMyAqIHNpbl90aF9oMiAqIHNpbl90aF9oMiAvIE1hdGguc2luKHRoX2hhbGYpO1xuICBjb25zdCB4MSA9IGN4ICsgY29zX3RoMCAtIHQgKiBzaW5fdGgwO1xuICBjb25zdCB5MSA9IGN5ICsgc2luX3RoMCArIHQgKiBjb3NfdGgwO1xuICBjb25zdCB4MyA9IGN4ICsgY29zX3RoMTtcbiAgY29uc3QgeTMgPSBjeSArIHNpbl90aDE7XG4gIGNvbnN0IHgyID0geDMgKyB0ICogc2luX3RoMTtcbiAgY29uc3QgeTIgPSB5MyAtIHQgKiBjb3NfdGgxO1xuICByZXR1cm4gYmV6aWVyQ2FjaGVba2V5XSA9IFthMDAgKiB4MSArIGEwMSAqIHkxLCBhMTAgKiB4MSArIGExMSAqIHkxLCBhMDAgKiB4MiArIGEwMSAqIHkyLCBhMTAgKiB4MiArIGExMSAqIHkyLCBhMDAgKiB4MyArIGEwMSAqIHkzLCBhMTAgKiB4MyArIGExMSAqIHkzXTtcbn1cblxuY29uc3QgdGVtcCA9IFsnbCcsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuXG5mdW5jdGlvbiBzY2FsZSQxKGN1cnJlbnQsIHNYLCBzWSkge1xuICBjb25zdCBjID0gdGVtcFswXSA9IGN1cnJlbnRbMF07XG5cbiAgaWYgKGMgPT09ICdhJyB8fCBjID09PSAnQScpIHtcbiAgICB0ZW1wWzFdID0gc1ggKiBjdXJyZW50WzFdO1xuICAgIHRlbXBbMl0gPSBzWSAqIGN1cnJlbnRbMl07XG4gICAgdGVtcFszXSA9IGN1cnJlbnRbM107XG4gICAgdGVtcFs0XSA9IGN1cnJlbnRbNF07XG4gICAgdGVtcFs1XSA9IGN1cnJlbnRbNV07XG4gICAgdGVtcFs2XSA9IHNYICogY3VycmVudFs2XTtcbiAgICB0ZW1wWzddID0gc1kgKiBjdXJyZW50WzddO1xuICB9IGVsc2UgaWYgKGMgPT09ICdoJyB8fCBjID09PSAnSCcpIHtcbiAgICB0ZW1wWzFdID0gc1ggKiBjdXJyZW50WzFdO1xuICB9IGVsc2UgaWYgKGMgPT09ICd2JyB8fCBjID09PSAnVicpIHtcbiAgICB0ZW1wWzFdID0gc1kgKiBjdXJyZW50WzFdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAxLCBuID0gY3VycmVudC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHRlbXBbaV0gPSAoaSAlIDIgPT0gMSA/IHNYIDogc1kpICogY3VycmVudFtpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGVtcDtcbn1cblxuZnVuY3Rpb24gcGF0aFJlbmRlciAoY29udGV4dCwgcGF0aCwgbCwgdCwgc1gsIHNZKSB7XG4gIHZhciBjdXJyZW50LFxuICAgICAgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICBwcmV2aW91cyA9IG51bGwsXG4gICAgICB4ID0gMCxcbiAgICAgIC8vIGN1cnJlbnQgeFxuICB5ID0gMCxcbiAgICAgIC8vIGN1cnJlbnQgeVxuICBjb250cm9sWCA9IDAsXG4gICAgICAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICBjb250cm9sWSA9IDAsXG4gICAgICAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeVxuICB0ZW1wWCxcbiAgICAgIHRlbXBZLFxuICAgICAgdGVtcENvbnRyb2xYLFxuICAgICAgdGVtcENvbnRyb2xZO1xuICBpZiAobCA9PSBudWxsKSBsID0gMDtcbiAgaWYgKHQgPT0gbnVsbCkgdCA9IDA7XG4gIGlmIChzWCA9PSBudWxsKSBzWCA9IDE7XG4gIGlmIChzWSA9PSBudWxsKSBzWSA9IHNYO1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gcGF0aFtpXTtcblxuICAgIGlmIChzWCAhPT0gMSB8fCBzWSAhPT0gMSkge1xuICAgICAgY3VycmVudCA9IHNjYWxlJDEoY3VycmVudCwgc1gsIHNZKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHtcbiAgICAgIC8vIGZpcnN0IGxldHRlclxuICAgICAgY2FzZSAnbCc6XG4gICAgICAgIC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGNvbnRleHQubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGNvbnRleHQubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoJzpcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRleHQubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2JzpcbiAgICAgICAgLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRleHQubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdNJzpcbiAgICAgICAgLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHggKyBjdXJyZW50WzFdICsgbCwgLy8geDFcbiAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LCAvLyB5MVxuICAgICAgICBjb250cm9sWCArIGwsIC8vIHgyXG4gICAgICAgIGNvbnRyb2xZICsgdCwgLy8geTJcbiAgICAgICAgdGVtcFggKyBsLCB0ZW1wWSArIHQpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY3VycmVudFsxXSArIGwsIGN1cnJlbnRbMl0gKyB0LCBjb250cm9sWCArIGwsIGNvbnRyb2xZICsgdCwgeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdOyAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIHggKyBjdXJyZW50WzFdICsgbCwgeSArIGN1cnJlbnRbMl0gKyB0LCB0ZW1wWCArIGwsIHRlbXBZICsgdCk7IC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2ZcbiAgICAgICAgLy8gdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTsgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcblxuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNvbnRyb2xYICsgbCwgY29udHJvbFkgKyB0LCBjdXJyZW50WzFdICsgbCwgY3VycmVudFsyXSArIHQsIHRlbXBYICsgbCwgdGVtcFkgKyB0KTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7IC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2ZcbiAgICAgICAgLy8gdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuXG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncSc6XG4gICAgICAgIC8vIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xYICsgbCwgY29udHJvbFkgKyB0LCB0ZW1wWCArIGwsIHRlbXBZICsgdCk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudFsxXSArIGwsIGN1cnJlbnRbMl0gKyB0LCB0ZW1wWCArIGwsIHRlbXBZICsgdCk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICd0Jykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciB0XG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIHRlbXBDb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gdGVtcENvbnRyb2xZO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAncScpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgcVxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wQ29udHJvbFggPSBjb250cm9sWDtcbiAgICAgICAgdGVtcENvbnRyb2xZID0gY29udHJvbFk7XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjb250cm9sWCArIGwsIGNvbnRyb2xZICsgdCwgdGVtcFggKyBsLCB0ZW1wWSArIHQpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0gY3VycmVudFsyXTsgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcblxuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xYICsgbCwgY29udHJvbFkgKyB0LCB0ZW1wWCArIGwsIHRlbXBZICsgdCk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGRyYXdBcmMoY29udGV4dCwgeCArIGwsIHkgKyB0LCBbY3VycmVudFsxXSwgY3VycmVudFsyXSwgY3VycmVudFszXSwgY3VycmVudFs0XSwgY3VycmVudFs1XSwgY3VycmVudFs2XSArIHggKyBsLCBjdXJyZW50WzddICsgeSArIHRdKTtcbiAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgZHJhd0FyYyhjb250ZXh0LCB4ICsgbCwgeSArIHQsIFtjdXJyZW50WzFdLCBjdXJyZW50WzJdLCBjdXJyZW50WzNdLCBjdXJyZW50WzRdLCBjdXJyZW50WzVdLCBjdXJyZW50WzZdICsgbCwgY3VycmVudFs3XSArIHRdKTtcbiAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdBcmMoY29udGV4dCwgeCwgeSwgY29vcmRzKSB7XG4gIGNvbnN0IHNlZyA9IHNlZ21lbnRzKGNvb3Jkc1s1XSwgLy8gZW5kIHhcbiAgY29vcmRzWzZdLCAvLyBlbmQgeVxuICBjb29yZHNbMF0sIC8vIHJhZGl1cyB4XG4gIGNvb3Jkc1sxXSwgLy8gcmFkaXVzIHlcbiAgY29vcmRzWzNdLCAvLyBsYXJnZSBmbGFnXG4gIGNvb3Jkc1s0XSwgLy8gc3dlZXAgZmxhZ1xuICBjb29yZHNbMl0sIC8vIHJvdGF0aW9uXG4gIHgsIHkpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYmV6ID0gYmV6aWVyKHNlZ1tpXSk7XG4gICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGJlelswXSwgYmV6WzFdLCBiZXpbMl0sIGJlelszXSwgYmV6WzRdLCBiZXpbNV0pO1xuICB9XG59XG5cbmNvbnN0IFRhbjMwID0gMC41NzczNTAyNjkxODk2MjU3O1xuY29uc3QgYnVpbHRpbnMgPSB7XG4gICdjaXJjbGUnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIGNvbnN0IHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyO1xuICAgICAgY29udGV4dC5tb3ZlVG8ociwgMCk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCBUYXUpO1xuICAgIH1cbiAgfSxcbiAgJ2Nyb3NzJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgICAgcyA9IHIgLyAyLjU7XG4gICAgICBjb250ZXh0Lm1vdmVUbygtciwgLXMpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXIsIHMpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXMsIHMpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXMsIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8ocywgcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzLCBzKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHIsIHMpO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgLXMpO1xuICAgICAgY29udGV4dC5saW5lVG8ocywgLXMpO1xuICAgICAgY29udGV4dC5saW5lVG8ocywgLXIpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXMsIC1yKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1zLCAtcyk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ2RpYW1vbmQnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIGNvbnN0IHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyO1xuICAgICAgY29udGV4dC5tb3ZlVG8oLXIsIDApO1xuICAgICAgY29udGV4dC5saW5lVG8oMCwgLXIpO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgMCk7XG4gICAgICBjb250ZXh0LmxpbmVUbygwLCByKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAnc3F1YXJlJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgdyA9IE1hdGguc3FydChzaXplKSxcbiAgICAgICAgICB4ID0gLXcgLyAyO1xuICAgICAgY29udGV4dC5yZWN0KHgsIHgsIHcsIHcpO1xuICAgIH1cbiAgfSxcbiAgJ2Fycm93Jzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgICAgcyA9IHIgLyA3LFxuICAgICAgICAgIHQgPSByIC8gMi41LFxuICAgICAgICAgIHYgPSByIC8gODtcbiAgICAgIGNvbnRleHQubW92ZVRvKC1zLCByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMsIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8ocywgLXYpO1xuICAgICAgY29udGV4dC5saW5lVG8odCwgLXYpO1xuICAgICAgY29udGV4dC5saW5lVG8oMCwgLXIpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXQsIC12KTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1zLCAtdik7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3dlZGdlJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgICAgaCA9IEhhbGZTcXJ0MyAqIHIsXG4gICAgICAgICAgbyA9IGggLSByICogVGFuMzAsXG4gICAgICAgICAgYiA9IHIgLyA0O1xuICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLWggLSBvKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1iLCBoIC0gbyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhiLCBoIC0gbyk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3RyaWFuZ2xlJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgICAgaCA9IEhhbGZTcXJ0MyAqIHIsXG4gICAgICAgICAgbyA9IGggLSByICogVGFuMzA7XG4gICAgICBjb250ZXh0Lm1vdmVUbygwLCAtaCAtIG8pO1xuICAgICAgY29udGV4dC5saW5lVG8oLXIsIGggLSBvKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHIsIGggLSBvKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAndHJpYW5nbGUtdXAnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMixcbiAgICAgICAgICBoID0gSGFsZlNxcnQzICogcjtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIC1oKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1yLCBoKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHIsIGgpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICd0cmlhbmdsZS1kb3duJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgICAgaCA9IEhhbGZTcXJ0MyAqIHI7XG4gICAgICBjb250ZXh0Lm1vdmVUbygwLCBoKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1yLCAtaCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhyLCAtaCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3RyaWFuZ2xlLXJpZ2h0Jzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgICAgaCA9IEhhbGZTcXJ0MyAqIHI7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhoLCAwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1oLCAtcik7XG4gICAgICBjb250ZXh0LmxpbmVUbygtaCwgcik7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3RyaWFuZ2xlLWxlZnQnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMixcbiAgICAgICAgICBoID0gSGFsZlNxcnQzICogcjtcbiAgICAgIGNvbnRleHQubW92ZVRvKC1oLCAwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGgsIC1yKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGgsIHIpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICdzdHJva2UnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIGNvbnN0IHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyO1xuICAgICAgY29udGV4dC5tb3ZlVG8oLXIsIDApO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgMCk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc3ltYm9scyhfKSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eShidWlsdGlucywgXykgPyBidWlsdGluc1tfXSA6IGN1c3RvbVN5bWJvbChfKTtcbn1cbnZhciBjdXN0b20gPSB7fTtcblxuZnVuY3Rpb24gY3VzdG9tU3ltYm9sKHBhdGgpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShjdXN0b20sIHBhdGgpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGF0aFBhcnNlKHBhdGgpO1xuICAgIGN1c3RvbVtwYXRoXSA9IHtcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICAgIHBhdGhSZW5kZXIoY29udGV4dCwgcGFyc2VkLCAwLCAwLCBNYXRoLnNxcnQoc2l6ZSkgLyAyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGN1c3RvbVtwYXRoXTtcbn1cblxuY29uc3QgQyA9IDAuNDQ4MDg0OTc1NTA2OyAvLyBDID0gMSAtIGNcblxuZnVuY3Rpb24gcmVjdGFuZ2xlWChkKSB7XG4gIHJldHVybiBkLng7XG59XG5cbmZ1bmN0aW9uIHJlY3RhbmdsZVkoZCkge1xuICByZXR1cm4gZC55O1xufVxuXG5mdW5jdGlvbiByZWN0YW5nbGVXaWR0aChkKSB7XG4gIHJldHVybiBkLndpZHRoO1xufVxuXG5mdW5jdGlvbiByZWN0YW5nbGVIZWlnaHQoZCkge1xuICByZXR1cm4gZC5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIG51bWJlcihfKSB7XG4gIHJldHVybiB0eXBlb2YgXyA9PT0gJ2Z1bmN0aW9uJyA/IF8gOiAoKSA9PiArXztcbn1cblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbn1cblxuZnVuY3Rpb24gdmdfcmVjdCAoKSB7XG4gIHZhciB4ID0gcmVjdGFuZ2xlWCxcbiAgICAgIHkgPSByZWN0YW5nbGVZLFxuICAgICAgd2lkdGggPSByZWN0YW5nbGVXaWR0aCxcbiAgICAgIGhlaWdodCA9IHJlY3RhbmdsZUhlaWdodCxcbiAgICAgIGNyVEwgPSBudW1iZXIoMCksXG4gICAgICBjclRSID0gY3JUTCxcbiAgICAgIGNyQkwgPSBjclRMLFxuICAgICAgY3JCUiA9IGNyVEwsXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiByZWN0YW5nbGUoXywgeDAsIHkwKSB7XG4gICAgdmFyIGJ1ZmZlcixcbiAgICAgICAgeDEgPSB4MCAhPSBudWxsID8geDAgOiAreC5jYWxsKHRoaXMsIF8pLFxuICAgICAgICB5MSA9IHkwICE9IG51bGwgPyB5MCA6ICt5LmNhbGwodGhpcywgXyksXG4gICAgICAgIHcgPSArd2lkdGguY2FsbCh0aGlzLCBfKSxcbiAgICAgICAgaCA9ICtoZWlnaHQuY2FsbCh0aGlzLCBfKSxcbiAgICAgICAgcyA9IE1hdGgubWluKHcsIGgpIC8gMixcbiAgICAgICAgdGwgPSBjbGFtcCgrY3JUTC5jYWxsKHRoaXMsIF8pLCAwLCBzKSxcbiAgICAgICAgdHIgPSBjbGFtcCgrY3JUUi5jYWxsKHRoaXMsIF8pLCAwLCBzKSxcbiAgICAgICAgYmwgPSBjbGFtcCgrY3JCTC5jYWxsKHRoaXMsIF8pLCAwLCBzKSxcbiAgICAgICAgYnIgPSBjbGFtcCgrY3JCUi5jYWxsKHRoaXMsIF8pLCAwLCBzKTtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoJDMoKTtcblxuICAgIGlmICh0bCA8PSAwICYmIHRyIDw9IDAgJiYgYmwgPD0gMCAmJiBiciA8PSAwKSB7XG4gICAgICBjb250ZXh0LnJlY3QoeDEsIHkxLCB3LCBoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHgyID0geDEgKyB3LFxuICAgICAgICAgIHkyID0geTEgKyBoO1xuICAgICAgY29udGV4dC5tb3ZlVG8oeDEgKyB0bCwgeTEpO1xuICAgICAgY29udGV4dC5saW5lVG8oeDIgLSB0ciwgeTEpO1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgyIC0gQyAqIHRyLCB5MSwgeDIsIHkxICsgQyAqIHRyLCB4MiwgeTEgKyB0cik7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIgLSBicik7XG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeDIsIHkyIC0gQyAqIGJyLCB4MiAtIEMgKiBiciwgeTIsIHgyIC0gYnIsIHkyKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHgxICsgYmwsIHkyKTtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MSArIEMgKiBibCwgeTIsIHgxLCB5MiAtIEMgKiBibCwgeDEsIHkyIC0gYmwpO1xuICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxICsgdGwpO1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSArIEMgKiB0bCwgeDEgKyBDICogdGwsIHkxLCB4MSArIHRsLCB5MSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgcmV0dXJuIGJ1ZmZlciArICcnIHx8IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmVjdGFuZ2xlLnggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB4ID0gbnVtYmVyKF8pO1xuICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9O1xuXG4gIHJlY3RhbmdsZS55ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgeSA9IG51bWJlcihfKTtcbiAgICAgIHJldHVybiByZWN0YW5nbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgfTtcblxuICByZWN0YW5nbGUud2lkdGggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB3aWR0aCA9IG51bWJlcihfKTtcbiAgICAgIHJldHVybiByZWN0YW5nbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG4gIH07XG5cbiAgcmVjdGFuZ2xlLmhlaWdodCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGhlaWdodCA9IG51bWJlcihfKTtcbiAgICAgIHJldHVybiByZWN0YW5nbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuICB9O1xuXG4gIHJlY3RhbmdsZS5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbiAodGwsIHRyLCBiciwgYmwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY3JUTCA9IG51bWJlcih0bCk7XG4gICAgICBjclRSID0gdHIgIT0gbnVsbCA/IG51bWJlcih0cikgOiBjclRMO1xuICAgICAgY3JCUiA9IGJyICE9IG51bGwgPyBudW1iZXIoYnIpIDogY3JUTDtcbiAgICAgIGNyQkwgPSBibCAhPSBudWxsID8gbnVtYmVyKGJsKSA6IGNyVFI7XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JUTDtcbiAgICB9XG4gIH07XG5cbiAgcmVjdGFuZ2xlLmNvbnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF87XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHJlY3RhbmdsZTtcbn1cblxuZnVuY3Rpb24gdmdfdHJhaWwgKCkge1xuICB2YXIgeCxcbiAgICAgIHksXG4gICAgICBzaXplLFxuICAgICAgZGVmaW5lZCxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgcmVhZHksXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgcjE7XG5cbiAgZnVuY3Rpb24gcG9pbnQoeDIsIHkyLCB3Mikge1xuICAgIGNvbnN0IHIyID0gdzIgLyAyO1xuXG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICB2YXIgdXggPSB5MSAtIHkyLFxuICAgICAgICAgIHV5ID0geDIgLSB4MTtcblxuICAgICAgaWYgKHV4IHx8IHV5KSB7XG4gICAgICAgIC8vIGdldCBub3JtYWwgdmVjdG9yXG4gICAgICAgIHZhciB1ZCA9IE1hdGguc3FydCh1eCAqIHV4ICsgdXkgKiB1eSksXG4gICAgICAgICAgICByeCA9ICh1eCAvPSB1ZCkgKiByMSxcbiAgICAgICAgICAgIHJ5ID0gKHV5IC89IHVkKSAqIHIxLFxuICAgICAgICAgICAgdCA9IE1hdGguYXRhbjIodXksIHV4KTsgLy8gZHJhdyBzZWdtZW50XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDEgLSByeCwgeTEgLSByeSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgyIC0gdXggKiByMiwgeTIgLSB1eSAqIHIyKTtcbiAgICAgICAgY29udGV4dC5hcmMoeDIsIHkyLCByMiwgdCAtIE1hdGguUEksIHQpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MSArIHJ4LCB5MSArIHJ5KTtcbiAgICAgICAgY29udGV4dC5hcmMoeDEsIHkxLCByMSwgdCwgdCArIE1hdGguUEkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5hcmMoeDIsIHkyLCByMiwgMCwgVGF1KTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZHkgPSAxO1xuICAgIH1cblxuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgICByMSA9IHIyO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWwoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjtcbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCQzKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIHJlYWR5ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluZWQwKSBwb2ludCgreChkLCBpLCBkYXRhKSwgK3koZCwgaSwgZGF0YSksICtzaXplKGQsIGksIGRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSB7XG4gICAgICBjb250ZXh0ID0gbnVsbDtcbiAgICAgIHJldHVybiBidWZmZXIgKyAnJyB8fCBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHRyYWlsLnggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB4ID0gXztcbiAgICAgIHJldHVybiB0cmFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9O1xuXG4gIHRyYWlsLnkgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB5ID0gXztcbiAgICAgIHJldHVybiB0cmFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHk7XG4gICAgfVxuICB9O1xuXG4gIHRyYWlsLnNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBzaXplID0gXztcbiAgICAgIHJldHVybiB0cmFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9O1xuXG4gIHRyYWlsLmRlZmluZWQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBkZWZpbmVkID0gXztcbiAgICAgIHJldHVybiB0cmFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIHRyYWlsLmNvbnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAoXyA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dCA9IF87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0cmFpbDtcbn1cblxuZnVuY3Rpb24gdmFsdWUkMShhLCBiKSB7XG4gIHJldHVybiBhICE9IG51bGwgPyBhIDogYjtcbn1cblxuY29uc3QgeCA9IGl0ZW0gPT4gaXRlbS54IHx8IDAsXG4gICAgICB5ID0gaXRlbSA9PiBpdGVtLnkgfHwgMCxcbiAgICAgIHcgPSBpdGVtID0+IGl0ZW0ud2lkdGggfHwgMCxcbiAgICAgIGggPSBpdGVtID0+IGl0ZW0uaGVpZ2h0IHx8IDAsXG4gICAgICB4dyA9IGl0ZW0gPT4gKGl0ZW0ueCB8fCAwKSArIChpdGVtLndpZHRoIHx8IDApLFxuICAgICAgeWggPSBpdGVtID0+IChpdGVtLnkgfHwgMCkgKyAoaXRlbS5oZWlnaHQgfHwgMCksXG4gICAgICBzYSA9IGl0ZW0gPT4gaXRlbS5zdGFydEFuZ2xlIHx8IDAsXG4gICAgICBlYSA9IGl0ZW0gPT4gaXRlbS5lbmRBbmdsZSB8fCAwLFxuICAgICAgcGEgPSBpdGVtID0+IGl0ZW0ucGFkQW5nbGUgfHwgMCxcbiAgICAgIGlyID0gaXRlbSA9PiBpdGVtLmlubmVyUmFkaXVzIHx8IDAsXG4gICAgICBvciA9IGl0ZW0gPT4gaXRlbS5vdXRlclJhZGl1cyB8fCAwLFxuICAgICAgY3IgPSBpdGVtID0+IGl0ZW0uY29ybmVyUmFkaXVzIHx8IDAsXG4gICAgICB0bCA9IGl0ZW0gPT4gdmFsdWUkMShpdGVtLmNvcm5lclJhZGl1c1RvcExlZnQsIGl0ZW0uY29ybmVyUmFkaXVzKSB8fCAwLFxuICAgICAgdHIgPSBpdGVtID0+IHZhbHVlJDEoaXRlbS5jb3JuZXJSYWRpdXNUb3BSaWdodCwgaXRlbS5jb3JuZXJSYWRpdXMpIHx8IDAsXG4gICAgICBiciA9IGl0ZW0gPT4gdmFsdWUkMShpdGVtLmNvcm5lclJhZGl1c0JvdHRvbVJpZ2h0LCBpdGVtLmNvcm5lclJhZGl1cykgfHwgMCxcbiAgICAgIGJsID0gaXRlbSA9PiB2YWx1ZSQxKGl0ZW0uY29ybmVyUmFkaXVzQm90dG9tTGVmdCwgaXRlbS5jb3JuZXJSYWRpdXMpIHx8IDAsXG4gICAgICBzeiA9IGl0ZW0gPT4gdmFsdWUkMShpdGVtLnNpemUsIDY0KSxcbiAgICAgIHRzID0gaXRlbSA9PiBpdGVtLnNpemUgfHwgMSxcbiAgICAgIGRlZiA9IGl0ZW0gPT4gIShpdGVtLmRlZmluZWQgPT09IGZhbHNlKSxcbiAgICAgIHR5cGUgPSBpdGVtID0+IHN5bWJvbHMoaXRlbS5zaGFwZSB8fCAnY2lyY2xlJyk7XG5cbmNvbnN0IGFyY1NoYXBlID0gYXJjJDIoKS5zdGFydEFuZ2xlKHNhKS5lbmRBbmdsZShlYSkucGFkQW5nbGUocGEpLmlubmVyUmFkaXVzKGlyKS5vdXRlclJhZGl1cyhvcikuY29ybmVyUmFkaXVzKGNyKSxcbiAgICAgIGFyZWF2U2hhcGUgPSBhcmVhJDIoKS54KHgpLnkxKHkpLnkwKHloKS5kZWZpbmVkKGRlZiksXG4gICAgICBhcmVhaFNoYXBlID0gYXJlYSQyKCkueSh5KS54MSh4KS54MCh4dykuZGVmaW5lZChkZWYpLFxuICAgICAgbGluZVNoYXBlID0gbGluZSQyKCkueCh4KS55KHkpLmRlZmluZWQoZGVmKSxcbiAgICAgIHJlY3RTaGFwZSA9IHZnX3JlY3QoKS54KHgpLnkoeSkud2lkdGgodykuaGVpZ2h0KGgpLmNvcm5lclJhZGl1cyh0bCwgdHIsIGJyLCBibCksXG4gICAgICBzeW1ib2xTaGFwZSA9IHN5bWJvbCQyKCkudHlwZSh0eXBlKS5zaXplKHN6KSxcbiAgICAgIHRyYWlsU2hhcGUgPSB2Z190cmFpbCgpLngoeCkueSh5KS5kZWZpbmVkKGRlZikuc2l6ZSh0cyk7XG5mdW5jdGlvbiBoYXNDb3JuZXJSYWRpdXMoaXRlbSkge1xuICByZXR1cm4gaXRlbS5jb3JuZXJSYWRpdXMgfHwgaXRlbS5jb3JuZXJSYWRpdXNUb3BMZWZ0IHx8IGl0ZW0uY29ybmVyUmFkaXVzVG9wUmlnaHQgfHwgaXRlbS5jb3JuZXJSYWRpdXNCb3R0b21SaWdodCB8fCBpdGVtLmNvcm5lclJhZGl1c0JvdHRvbUxlZnQ7XG59XG5mdW5jdGlvbiBhcmMkMShjb250ZXh0LCBpdGVtKSB7XG4gIHJldHVybiBhcmNTaGFwZS5jb250ZXh0KGNvbnRleHQpKGl0ZW0pO1xufVxuZnVuY3Rpb24gYXJlYSQxKGNvbnRleHQsIGl0ZW1zKSB7XG4gIGNvbnN0IGl0ZW0gPSBpdGVtc1swXSxcbiAgICAgICAgaW50ZXJwID0gaXRlbS5pbnRlcnBvbGF0ZSB8fCAnbGluZWFyJztcbiAgcmV0dXJuIChpdGVtLm9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gYXJlYWhTaGFwZSA6IGFyZWF2U2hhcGUpLmN1cnZlKGN1cnZlcyhpbnRlcnAsIGl0ZW0ub3JpZW50LCBpdGVtLnRlbnNpb24pKS5jb250ZXh0KGNvbnRleHQpKGl0ZW1zKTtcbn1cbmZ1bmN0aW9uIGxpbmUkMShjb250ZXh0LCBpdGVtcykge1xuICBjb25zdCBpdGVtID0gaXRlbXNbMF0sXG4gICAgICAgIGludGVycCA9IGl0ZW0uaW50ZXJwb2xhdGUgfHwgJ2xpbmVhcic7XG4gIHJldHVybiBsaW5lU2hhcGUuY3VydmUoY3VydmVzKGludGVycCwgaXRlbS5vcmllbnQsIGl0ZW0udGVuc2lvbikpLmNvbnRleHQoY29udGV4dCkoaXRlbXMpO1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlKGNvbnRleHQsIGl0ZW0sIHgsIHkpIHtcbiAgcmV0dXJuIHJlY3RTaGFwZS5jb250ZXh0KGNvbnRleHQpKGl0ZW0sIHgsIHkpO1xufVxuZnVuY3Rpb24gc2hhcGUkMShjb250ZXh0LCBpdGVtKSB7XG4gIHJldHVybiAoaXRlbS5tYXJrLnNoYXBlIHx8IGl0ZW0uc2hhcGUpLmNvbnRleHQoY29udGV4dCkoaXRlbSk7XG59XG5mdW5jdGlvbiBzeW1ib2wkMShjb250ZXh0LCBpdGVtKSB7XG4gIHJldHVybiBzeW1ib2xTaGFwZS5jb250ZXh0KGNvbnRleHQpKGl0ZW0pO1xufVxuZnVuY3Rpb24gdHJhaWwkMShjb250ZXh0LCBpdGVtcykge1xuICByZXR1cm4gdHJhaWxTaGFwZS5jb250ZXh0KGNvbnRleHQpKGl0ZW1zKTtcbn1cblxudmFyIGNsaXBfaWQgPSAxO1xuZnVuY3Rpb24gcmVzZXRTVkdDbGlwSWQoKSB7XG4gIGNsaXBfaWQgPSAxO1xufVxuZnVuY3Rpb24gY2xpcCQxIChyZW5kZXJlciwgaXRlbSwgc2l6ZSkge1xuICB2YXIgY2xpcCA9IGl0ZW0uY2xpcCxcbiAgICAgIGRlZnMgPSByZW5kZXJlci5fZGVmcyxcbiAgICAgIGlkID0gaXRlbS5jbGlwX2lkIHx8IChpdGVtLmNsaXBfaWQgPSAnY2xpcCcgKyBjbGlwX2lkKyspLFxuICAgICAgYyA9IGRlZnMuY2xpcHBpbmdbaWRdIHx8IChkZWZzLmNsaXBwaW5nW2lkXSA9IHtcbiAgICBpZDogaWRcbiAgfSk7XG5cbiAgaWYgKGlzRnVuY3Rpb24oY2xpcCkpIHtcbiAgICBjLnBhdGggPSBjbGlwKG51bGwpO1xuICB9IGVsc2UgaWYgKGhhc0Nvcm5lclJhZGl1cyhzaXplKSkge1xuICAgIGMucGF0aCA9IHJlY3RhbmdsZShudWxsLCBzaXplLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBjLndpZHRoID0gc2l6ZS53aWR0aCB8fCAwO1xuICAgIGMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQgfHwgMDtcbiAgfVxuXG4gIHJldHVybiAndXJsKCMnICsgaWQgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIEJvdW5kcyhiKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgaWYgKGIpIHRoaXMudW5pb24oYik7XG59XG5Cb3VuZHMucHJvdG90eXBlID0ge1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kcyh0aGlzKTtcbiAgfSxcblxuICBjbGVhcigpIHtcbiAgICB0aGlzLngxID0gK051bWJlci5NQVhfVkFMVUU7XG4gICAgdGhpcy55MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHRoaXMueDIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLnkyID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMueDEgPT09ICtOdW1iZXIuTUFYX1ZBTFVFICYmIHRoaXMueTEgPT09ICtOdW1iZXIuTUFYX1ZBTFVFICYmIHRoaXMueDIgPT09IC1OdW1iZXIuTUFYX1ZBTFVFICYmIHRoaXMueTIgPT09IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICB9LFxuXG4gIGVxdWFscyhiKSB7XG4gICAgcmV0dXJuIHRoaXMueDEgPT09IGIueDEgJiYgdGhpcy55MSA9PT0gYi55MSAmJiB0aGlzLngyID09PSBiLngyICYmIHRoaXMueTIgPT09IGIueTI7XG4gIH0sXG5cbiAgc2V0KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgaWYgKHgyIDwgeDEpIHtcbiAgICAgIHRoaXMueDIgPSB4MTtcbiAgICAgIHRoaXMueDEgPSB4MjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54MSA9IHgxO1xuICAgICAgdGhpcy54MiA9IHgyO1xuICAgIH1cblxuICAgIGlmICh5MiA8IHkxKSB7XG4gICAgICB0aGlzLnkyID0geTE7XG4gICAgICB0aGlzLnkxID0geTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueTEgPSB5MTtcbiAgICAgIHRoaXMueTIgPSB5MjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBhZGQoeCwgeSkge1xuICAgIGlmICh4IDwgdGhpcy54MSkgdGhpcy54MSA9IHg7XG4gICAgaWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcbiAgICBpZiAoeCA+IHRoaXMueDIpIHRoaXMueDIgPSB4O1xuICAgIGlmICh5ID4gdGhpcy55MikgdGhpcy55MiA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZXhwYW5kKGQpIHtcbiAgICB0aGlzLngxIC09IGQ7XG4gICAgdGhpcy55MSAtPSBkO1xuICAgIHRoaXMueDIgKz0gZDtcbiAgICB0aGlzLnkyICs9IGQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcm91bmQoKSB7XG4gICAgdGhpcy54MSA9IE1hdGguZmxvb3IodGhpcy54MSk7XG4gICAgdGhpcy55MSA9IE1hdGguZmxvb3IodGhpcy55MSk7XG4gICAgdGhpcy54MiA9IE1hdGguY2VpbCh0aGlzLngyKTtcbiAgICB0aGlzLnkyID0gTWF0aC5jZWlsKHRoaXMueTIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNjYWxlKHMpIHtcbiAgICB0aGlzLngxICo9IHM7XG4gICAgdGhpcy55MSAqPSBzO1xuICAgIHRoaXMueDIgKj0gcztcbiAgICB0aGlzLnkyICo9IHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdHJhbnNsYXRlKGR4LCBkeSkge1xuICAgIHRoaXMueDEgKz0gZHg7XG4gICAgdGhpcy54MiArPSBkeDtcbiAgICB0aGlzLnkxICs9IGR5O1xuICAgIHRoaXMueTIgKz0gZHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcm90YXRlKGFuZ2xlLCB4LCB5KSB7XG4gICAgY29uc3QgcCA9IHRoaXMucm90YXRlZFBvaW50cyhhbmdsZSwgeCwgeSk7XG4gICAgcmV0dXJuIHRoaXMuY2xlYXIoKS5hZGQocFswXSwgcFsxXSkuYWRkKHBbMl0sIHBbM10pLmFkZChwWzRdLCBwWzVdKS5hZGQocFs2XSwgcFs3XSk7XG4gIH0sXG5cbiAgcm90YXRlZFBvaW50cyhhbmdsZSwgeCwgeSkge1xuICAgIHZhciB7XG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MlxuICAgIH0gPSB0aGlzLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgY3ggPSB4IC0geCAqIGNvcyArIHkgKiBzaW4sXG4gICAgICAgIGN5ID0geSAtIHggKiBzaW4gLSB5ICogY29zO1xuICAgIHJldHVybiBbY29zICogeDEgLSBzaW4gKiB5MSArIGN4LCBzaW4gKiB4MSArIGNvcyAqIHkxICsgY3ksIGNvcyAqIHgxIC0gc2luICogeTIgKyBjeCwgc2luICogeDEgKyBjb3MgKiB5MiArIGN5LCBjb3MgKiB4MiAtIHNpbiAqIHkxICsgY3gsIHNpbiAqIHgyICsgY29zICogeTEgKyBjeSwgY29zICogeDIgLSBzaW4gKiB5MiArIGN4LCBzaW4gKiB4MiArIGNvcyAqIHkyICsgY3ldO1xuICB9LFxuXG4gIHVuaW9uKGIpIHtcbiAgICBpZiAoYi54MSA8IHRoaXMueDEpIHRoaXMueDEgPSBiLngxO1xuICAgIGlmIChiLnkxIDwgdGhpcy55MSkgdGhpcy55MSA9IGIueTE7XG4gICAgaWYgKGIueDIgPiB0aGlzLngyKSB0aGlzLngyID0gYi54MjtcbiAgICBpZiAoYi55MiA+IHRoaXMueTIpIHRoaXMueTIgPSBiLnkyO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGludGVyc2VjdChiKSB7XG4gICAgaWYgKGIueDEgPiB0aGlzLngxKSB0aGlzLngxID0gYi54MTtcbiAgICBpZiAoYi55MSA+IHRoaXMueTEpIHRoaXMueTEgPSBiLnkxO1xuICAgIGlmIChiLngyIDwgdGhpcy54MikgdGhpcy54MiA9IGIueDI7XG4gICAgaWYgKGIueTIgPCB0aGlzLnkyKSB0aGlzLnkyID0gYi55MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBlbmNsb3NlcyhiKSB7XG4gICAgcmV0dXJuIGIgJiYgdGhpcy54MSA8PSBiLngxICYmIHRoaXMueDIgPj0gYi54MiAmJiB0aGlzLnkxIDw9IGIueTEgJiYgdGhpcy55MiA+PSBiLnkyO1xuICB9LFxuXG4gIGFsaWduc1dpdGgoYikge1xuICAgIHJldHVybiBiICYmICh0aGlzLngxID09IGIueDEgfHwgdGhpcy54MiA9PSBiLngyIHx8IHRoaXMueTEgPT0gYi55MSB8fCB0aGlzLnkyID09IGIueTIpO1xuICB9LFxuXG4gIGludGVyc2VjdHMoYikge1xuICAgIHJldHVybiBiICYmICEodGhpcy54MiA8IGIueDEgfHwgdGhpcy54MSA+IGIueDIgfHwgdGhpcy55MiA8IGIueTEgfHwgdGhpcy55MSA+IGIueTIpO1xuICB9LFxuXG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICByZXR1cm4gISh4IDwgdGhpcy54MSB8fCB4ID4gdGhpcy54MiB8fCB5IDwgdGhpcy55MSB8fCB5ID4gdGhpcy55Mik7XG4gIH0sXG5cbiAgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxO1xuICB9LFxuXG4gIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy55MiAtIHRoaXMueTE7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gSXRlbShtYXJrKSB7XG4gIHRoaXMubWFyayA9IG1hcms7XG4gIHRoaXMuYm91bmRzID0gdGhpcy5ib3VuZHMgfHwgbmV3IEJvdW5kcygpO1xufVxuXG5mdW5jdGlvbiBHcm91cEl0ZW0obWFyaykge1xuICBJdGVtLmNhbGwodGhpcywgbWFyayk7XG4gIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zIHx8IFtdO1xufVxuaW5oZXJpdHMoR3JvdXBJdGVtLCBJdGVtKTtcblxuZnVuY3Rpb24gUmVzb3VyY2VMb2FkZXIoY3VzdG9tTG9hZGVyKSB7XG4gIHRoaXMuX3BlbmRpbmcgPSAwO1xuICB0aGlzLl9sb2FkZXIgPSBjdXN0b21Mb2FkZXIgfHwgbG9hZGVyKCk7XG59XG5cbmZ1bmN0aW9uIGluY3JlbWVudChsb2FkZXIpIHtcbiAgbG9hZGVyLl9wZW5kaW5nICs9IDE7XG59XG5cbmZ1bmN0aW9uIGRlY3JlbWVudChsb2FkZXIpIHtcbiAgbG9hZGVyLl9wZW5kaW5nIC09IDE7XG59XG5cblJlc291cmNlTG9hZGVyLnByb3RvdHlwZSA9IHtcbiAgcGVuZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZztcbiAgfSxcblxuICBzYW5pdGl6ZVVSTCh1cmkpIHtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzO1xuICAgIGluY3JlbWVudChsb2FkZXIpO1xuICAgIHJldHVybiBsb2FkZXIuX2xvYWRlci5zYW5pdGl6ZSh1cmksIHtcbiAgICAgIGNvbnRleHQ6ICdocmVmJ1xuICAgIH0pLnRoZW4ob3B0ID0+IHtcbiAgICAgIGRlY3JlbWVudChsb2FkZXIpO1xuICAgICAgcmV0dXJuIG9wdDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICBkZWNyZW1lbnQobG9hZGVyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9LFxuXG4gIGxvYWRJbWFnZSh1cmkpIHtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLFxuICAgICAgICAgIEltYWdlID0gaW1hZ2UkMSgpO1xuICAgIGluY3JlbWVudChsb2FkZXIpO1xuICAgIHJldHVybiBsb2FkZXIuX2xvYWRlci5zYW5pdGl6ZSh1cmksIHtcbiAgICAgIGNvbnRleHQ6ICdpbWFnZSdcbiAgICB9KS50aGVuKG9wdCA9PiB7XG4gICAgICBjb25zdCB1cmwgPSBvcHQuaHJlZjtcbiAgICAgIGlmICghdXJsIHx8ICFJbWFnZSkgdGhyb3cge1xuICAgICAgICB1cmw6IHVybFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpOyAvLyBzZXQgY3Jvc3NPcmlnaW4gb25seSBpZiBjb3JzIGlzIGRlZmluZWQ7IGVtcHR5IHN0cmluZyBzZXRzIGFub255bW91cyBtb2RlXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudC9jcm9zc09yaWdpblxuXG4gICAgICBjb25zdCBjb3JzID0gaGFzT3duUHJvcGVydHkob3B0LCAnY3Jvc3NPcmlnaW4nKSA/IG9wdC5jcm9zc09yaWdpbiA6ICdhbm9ueW1vdXMnO1xuICAgICAgaWYgKGNvcnMgIT0gbnVsbCkgaW1nLmNyb3NzT3JpZ2luID0gY29yczsgLy8gYXR0ZW1wdCB0byBsb2FkIGltYWdlIHJlc291cmNlXG5cbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiBkZWNyZW1lbnQobG9hZGVyKTtcblxuICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiBkZWNyZW1lbnQobG9hZGVyKTtcblxuICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgIHJldHVybiBpbWc7XG4gICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICBkZWNyZW1lbnQobG9hZGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgc3JjOiBlICYmIGUudXJsIHx8ICcnXG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIHJlYWR5KCkge1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFjY2VwdCA9PiB7XG4gICAgICBmdW5jdGlvbiBwb2xsKHZhbHVlKSB7XG4gICAgICAgIGlmICghbG9hZGVyLnBlbmRpbmcoKSkgYWNjZXB0KHZhbHVlKTtlbHNlIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHBvbGwodHJ1ZSk7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgcG9sbChmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gYm91bmRTdHJva2UgKGJvdW5kcywgaXRlbSwgbWl0ZXIpIHtcbiAgaWYgKGl0ZW0uc3Ryb2tlICYmIGl0ZW0ub3BhY2l0eSAhPT0gMCAmJiBpdGVtLnN0cm9rZU9wYWNpdHkgIT09IDApIHtcbiAgICBjb25zdCBzdyA9IGl0ZW0uc3Ryb2tlV2lkdGggIT0gbnVsbCA/ICtpdGVtLnN0cm9rZVdpZHRoIDogMTtcbiAgICBib3VuZHMuZXhwYW5kKHN3ICsgKG1pdGVyID8gbWl0ZXJBZGp1c3RtZW50KGl0ZW0sIHN3KSA6IDApKTtcbiAgfVxuXG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIG1pdGVyQWRqdXN0bWVudChpdGVtLCBzdHJva2VXaWR0aCkge1xuICAvLyBUT0RPOiBtb3JlIHNvcGhpc3RpY2F0ZWQgYWRqdXN0bWVudD8gT3IgbWl0ZXIgc3VwcG9ydCBpbiBib3VuZENvbnRleHQ/XG4gIHJldHVybiBpdGVtLnN0cm9rZUpvaW4gJiYgaXRlbS5zdHJva2VKb2luICE9PSAnbWl0ZXInID8gMCA6IHN0cm9rZVdpZHRoO1xufVxuXG5jb25zdCBjaXJjbGVUaHJlc2hvbGQgPSBUYXUgLSAxZS04O1xubGV0IGJvdW5kcywgbHgsIGx5LCByb3QsIG1hLCBtYiwgbWMsIG1kO1xuXG5jb25zdCBhZGQgPSAoeCwgeSkgPT4gYm91bmRzLmFkZCh4LCB5KTtcblxuY29uc3QgYWRkTCA9ICh4LCB5KSA9PiBhZGQobHggPSB4LCBseSA9IHkpO1xuXG5jb25zdCBhZGRYID0geCA9PiBhZGQoeCwgYm91bmRzLnkxKTtcblxuY29uc3QgYWRkWSA9IHkgPT4gYWRkKGJvdW5kcy54MSwgeSk7XG5cbmNvbnN0IHB4ID0gKHgsIHkpID0+IG1hICogeCArIG1jICogeTtcblxuY29uc3QgcHkgPSAoeCwgeSkgPT4gbWIgKiB4ICsgbWQgKiB5O1xuXG5jb25zdCBhZGRwID0gKHgsIHkpID0+IGFkZChweCh4LCB5KSwgcHkoeCwgeSkpO1xuXG5jb25zdCBhZGRwTCA9ICh4LCB5KSA9PiBhZGRMKHB4KHgsIHkpLCBweSh4LCB5KSk7XG5cbmZ1bmN0aW9uIGJvdW5kQ29udGV4dCAoXywgZGVnKSB7XG4gIGJvdW5kcyA9IF87XG5cbiAgaWYgKGRlZykge1xuICAgIHJvdCA9IGRlZyAqIERlZ1RvUmFkO1xuICAgIG1hID0gbWQgPSBNYXRoLmNvcyhyb3QpO1xuICAgIG1iID0gTWF0aC5zaW4ocm90KTtcbiAgICBtYyA9IC1tYjtcbiAgfSBlbHNlIHtcbiAgICBtYSA9IG1kID0gMTtcbiAgICByb3QgPSBtYiA9IG1jID0gMDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0JDE7XG59XG5jb25zdCBjb250ZXh0JDEgPSB7XG4gIGJlZ2luUGF0aCgpIHt9LFxuXG4gIGNsb3NlUGF0aCgpIHt9LFxuXG4gIG1vdmVUbzogYWRkcEwsXG4gIGxpbmVUbzogYWRkcEwsXG5cbiAgcmVjdCh4LCB5LCB3LCBoKSB7XG4gICAgaWYgKHJvdCkge1xuICAgICAgYWRkcCh4ICsgdywgeSk7XG4gICAgICBhZGRwKHggKyB3LCB5ICsgaCk7XG4gICAgICBhZGRwKHgsIHkgKyBoKTtcbiAgICAgIGFkZHBMKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGQoeCArIHcsIHkgKyBoKTtcbiAgICAgIGFkZEwoeCwgeSk7XG4gICAgfVxuICB9LFxuXG4gIHF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjb25zdCBweDEgPSBweCh4MSwgeTEpLFxuICAgICAgICAgIHB5MSA9IHB5KHgxLCB5MSksXG4gICAgICAgICAgcHgyID0gcHgoeDIsIHkyKSxcbiAgICAgICAgICBweTIgPSBweSh4MiwgeTIpO1xuICAgIHF1YWRFeHRyZW1hKGx4LCBweDEsIHB4MiwgYWRkWCk7XG4gICAgcXVhZEV4dHJlbWEobHksIHB5MSwgcHkyLCBhZGRZKTtcbiAgICBhZGRMKHB4MiwgcHkyKTtcbiAgfSxcblxuICBiZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICBjb25zdCBweDEgPSBweCh4MSwgeTEpLFxuICAgICAgICAgIHB5MSA9IHB5KHgxLCB5MSksXG4gICAgICAgICAgcHgyID0gcHgoeDIsIHkyKSxcbiAgICAgICAgICBweTIgPSBweSh4MiwgeTIpLFxuICAgICAgICAgIHB4MyA9IHB4KHgzLCB5MyksXG4gICAgICAgICAgcHkzID0gcHkoeDMsIHkzKTtcbiAgICBjdWJpY0V4dHJlbWEobHgsIHB4MSwgcHgyLCBweDMsIGFkZFgpO1xuICAgIGN1YmljRXh0cmVtYShseSwgcHkxLCBweTIsIHB5MywgYWRkWSk7XG4gICAgYWRkTChweDMsIHB5Myk7XG4gIH0sXG5cbiAgYXJjKGN4LCBjeSwgciwgc2EsIGVhLCBjY3cpIHtcbiAgICBzYSArPSByb3Q7XG4gICAgZWEgKz0gcm90OyAvLyBzdG9yZSBsYXN0IHBvaW50IG9uIHBhdGhcblxuICAgIGx4ID0gciAqIE1hdGguY29zKGVhKSArIGN4O1xuICAgIGx5ID0gciAqIE1hdGguc2luKGVhKSArIGN5O1xuXG4gICAgaWYgKE1hdGguYWJzKGVhIC0gc2EpID4gY2lyY2xlVGhyZXNob2xkKSB7XG4gICAgICAvLyB0cmVhdCBhcyBmdWxsIGNpcmNsZVxuICAgICAgYWRkKGN4IC0gciwgY3kgLSByKTtcbiAgICAgIGFkZChjeCArIHIsIGN5ICsgcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IGEgPT4gYWRkKHIgKiBNYXRoLmNvcyhhKSArIGN4LCByICogTWF0aC5zaW4oYSkgKyBjeSk7XG5cbiAgICAgIGxldCBzLCBpOyAvLyBzYW1wbGUgZW5kIHBvaW50c1xuXG4gICAgICB1cGRhdGUoc2EpO1xuICAgICAgdXBkYXRlKGVhKTsgLy8gc2FtcGxlIGludGVyaW9yIHBvaW50cyBhbGlnbmVkIHdpdGggOTAgZGVncmVlc1xuXG4gICAgICBpZiAoZWEgIT09IHNhKSB7XG4gICAgICAgIHNhID0gc2EgJSBUYXU7XG4gICAgICAgIGlmIChzYSA8IDApIHNhICs9IFRhdTtcbiAgICAgICAgZWEgPSBlYSAlIFRhdTtcbiAgICAgICAgaWYgKGVhIDwgMCkgZWEgKz0gVGF1O1xuXG4gICAgICAgIGlmIChlYSA8IHNhKSB7XG4gICAgICAgICAgY2N3ID0gIWNjdzsgLy8gZmxpcCBkaXJlY3Rpb25cblxuICAgICAgICAgIHMgPSBzYTtcbiAgICAgICAgICBzYSA9IGVhO1xuICAgICAgICAgIGVhID0gczsgLy8gc3dhcCBlbmQtcG9pbnRzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2N3KSB7XG4gICAgICAgICAgZWEgLT0gVGF1O1xuICAgICAgICAgIHMgPSBzYSAtIHNhICUgSGFsZlBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQgJiYgcyA+IGVhOyArK2ksIHMgLT0gSGFsZlBpKSB1cGRhdGUocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcyA9IHNhIC0gc2EgJSBIYWxmUGkgKyBIYWxmUGk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNCAmJiBzIDwgZWE7ICsraSwgcyA9IHMgKyBIYWxmUGkpIHVwZGF0ZShzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBxdWFkRXh0cmVtYSh4MCwgeDEsIHgyLCBjYikge1xuICBjb25zdCB0ID0gKHgwIC0geDEpIC8gKHgwICsgeDIgLSAyICogeDEpO1xuICBpZiAoMCA8IHQgJiYgdCA8IDEpIGNiKHgwICsgKHgxIC0geDApICogdCk7XG59XG5cbmZ1bmN0aW9uIGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgY2IpIHtcbiAgY29uc3QgYSA9IHgzIC0geDAgKyAzICogeDEgLSAzICogeDIsXG4gICAgICAgIGIgPSB4MCArIHgyIC0gMiAqIHgxLFxuICAgICAgICBjID0geDAgLSB4MTtcbiAgbGV0IHQwID0gMCxcbiAgICAgIHQxID0gMCxcbiAgICAgIHI7IC8vIHNvbHZlIGZvciBwYXJhbWV0ZXIgdFxuXG4gIGlmIChNYXRoLmFicyhhKSA+IEVwc2lsb24pIHtcbiAgICAvLyBxdWFkcmF0aWMgZXF1YXRpb25cbiAgICByID0gYiAqIGIgKyBjICogYTtcblxuICAgIGlmIChyID49IDApIHtcbiAgICAgIHIgPSBNYXRoLnNxcnQocik7XG4gICAgICB0MCA9ICgtYiArIHIpIC8gYTtcbiAgICAgIHQxID0gKC1iIC0gcikgLyBhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBsaW5lYXIgZXF1YXRpb25cbiAgICB0MCA9IDAuNSAqIGMgLyBiO1xuICB9IC8vIGNhbGN1bGF0ZSBwb3NpdGlvblxuXG5cbiAgaWYgKDAgPCB0MCAmJiB0MCA8IDEpIGNiKGN1YmljKHQwLCB4MCwgeDEsIHgyLCB4MykpO1xuICBpZiAoMCA8IHQxICYmIHQxIDwgMSkgY2IoY3ViaWModDEsIHgwLCB4MSwgeDIsIHgzKSk7XG59XG5cbmZ1bmN0aW9uIGN1YmljKHQsIHgwLCB4MSwgeDIsIHgzKSB7XG4gIGNvbnN0IHMgPSAxIC0gdCxcbiAgICAgICAgczIgPSBzICogcyxcbiAgICAgICAgdDIgPSB0ICogdDtcbiAgcmV0dXJuIHMyICogcyAqIHgwICsgMyAqIHMyICogdCAqIHgxICsgMyAqIHMgKiB0MiAqIHgyICsgdDIgKiB0ICogeDM7XG59XG5cbnZhciBjb250ZXh0ID0gKGNvbnRleHQgPSBjYW52YXMoMSwgMSkpID8gY29udGV4dC5nZXRDb250ZXh0KCcyZCcpIDogbnVsbDtcblxuY29uc3QgYiA9IG5ldyBCb3VuZHMoKTtcbmZ1bmN0aW9uIGludGVyc2VjdFBhdGgoZHJhdykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIGJydXNoKSB7XG4gICAgLy8gcmVseSBvbiAoaW5hY2N1cmF0ZSkgYm91bmRzIGludGVyc2VjdGlvbiBpZiBubyBjb250ZXh0XG4gICAgaWYgKCFjb250ZXh0KSByZXR1cm4gdHJ1ZTsgLy8gYWRkIHBhdGggdG8gb2Zmc2NyZWVuIGdyYXBoaWNzIGNvbnRleHRcblxuICAgIGRyYXcoY29udGV4dCwgaXRlbSk7IC8vIGdldCBib3VuZHMgaW50ZXJzZWN0aW9uIHJlZ2lvblxuXG4gICAgYi5jbGVhcigpLnVuaW9uKGl0ZW0uYm91bmRzKS5pbnRlcnNlY3QoYnJ1c2gpLnJvdW5kKCk7XG4gICAgY29uc3Qge1xuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTJcbiAgICB9ID0gYjsgLy8gaXRlcmF0ZSBvdmVyIGludGVyc2VjdGlvbiByZWdpb25cbiAgICAvLyBwZXJmb3JtIGZpbmUgZ3JhaW5lZCBpbmNsdXNpb24gdGVzdFxuXG4gICAgZm9yIChsZXQgeSA9IHkxOyB5IDw9IHkyOyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSB4MTsgeCA8PSB4MjsgKyt4KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmlzUG9pbnRJblBhdGgoeCwgeSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZmFsc2UgaWYgbm8gaGl0cyBpbiBpbnRlcnNlY3Rpb24gcmVnaW9uXG5cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFBvaW50KGl0ZW0sIGJveCkge1xuICByZXR1cm4gYm94LmNvbnRhaW5zKGl0ZW0ueCB8fCAwLCBpdGVtLnkgfHwgMCk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0KGl0ZW0sIGJveCkge1xuICBjb25zdCB4ID0gaXRlbS54IHx8IDAsXG4gICAgICAgIHkgPSBpdGVtLnkgfHwgMCxcbiAgICAgICAgdyA9IGl0ZW0ud2lkdGggfHwgMCxcbiAgICAgICAgaCA9IGl0ZW0uaGVpZ2h0IHx8IDA7XG4gIHJldHVybiBib3guaW50ZXJzZWN0cyhiLnNldCh4LCB5LCB4ICsgdywgeSArIGgpKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFJ1bGUoaXRlbSwgYm94KSB7XG4gIGNvbnN0IHggPSBpdGVtLnggfHwgMCxcbiAgICAgICAgeSA9IGl0ZW0ueSB8fCAwLFxuICAgICAgICB4MiA9IGl0ZW0ueDIgIT0gbnVsbCA/IGl0ZW0ueDIgOiB4LFxuICAgICAgICB5MiA9IGl0ZW0ueTIgIT0gbnVsbCA/IGl0ZW0ueTIgOiB5O1xuICByZXR1cm4gaW50ZXJzZWN0Qm94TGluZShib3gsIHgsIHksIHgyLCB5Mik7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RCb3hMaW5lKGJveCwgeCwgeSwgdSwgdikge1xuICBjb25zdCB7XG4gICAgeDEsXG4gICAgeTEsXG4gICAgeDIsXG4gICAgeTJcbiAgfSA9IGJveCxcbiAgICAgICAgZHggPSB1IC0geCxcbiAgICAgICAgZHkgPSB2IC0geTtcbiAgbGV0IHQwID0gMCxcbiAgICAgIHQxID0gMSxcbiAgICAgIHAsXG4gICAgICBxLFxuICAgICAgcixcbiAgICAgIGU7XG5cbiAgZm9yIChlID0gMDsgZSA8IDQ7ICsrZSkge1xuICAgIGlmIChlID09PSAwKSB7XG4gICAgICBwID0gLWR4O1xuICAgICAgcSA9IC0oeDEgLSB4KTtcbiAgICB9XG5cbiAgICBpZiAoZSA9PT0gMSkge1xuICAgICAgcCA9IGR4O1xuICAgICAgcSA9IHgyIC0geDtcbiAgICB9XG5cbiAgICBpZiAoZSA9PT0gMikge1xuICAgICAgcCA9IC1keTtcbiAgICAgIHEgPSAtKHkxIC0geSk7XG4gICAgfVxuXG4gICAgaWYgKGUgPT09IDMpIHtcbiAgICAgIHAgPSBkeTtcbiAgICAgIHEgPSB5MiAtIHk7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHApIDwgMWUtMTAgJiYgcSA8IDApIHJldHVybiBmYWxzZTtcbiAgICByID0gcSAvIHA7XG5cbiAgICBpZiAocCA8IDApIHtcbiAgICAgIGlmIChyID4gdDEpIHJldHVybiBmYWxzZTtlbHNlIGlmIChyID4gdDApIHQwID0gcjtcbiAgICB9IGVsc2UgaWYgKHAgPiAwKSB7XG4gICAgICBpZiAociA8IHQwKSByZXR1cm4gZmFsc2U7ZWxzZSBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGJsZW5kIChjb250ZXh0LCBpdGVtKSB7XG4gIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gaXRlbS5ibGVuZCB8fCAnc291cmNlLW92ZXInO1xufVxuXG5mdW5jdGlvbiB2YWx1ZSAodmFsdWUsIGRmbHQpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBkZmx0IDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGFkZFN0b3BzKGdyYWRpZW50LCBzdG9wcykge1xuICBjb25zdCBuID0gc3RvcHMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3BzW2ldLm9mZnNldCwgc3RvcHNbaV0uY29sb3IpO1xuICB9XG5cbiAgcmV0dXJuIGdyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBncmFkaWVudCAoY29udGV4dCwgc3BlYywgYm91bmRzKSB7XG4gIGNvbnN0IHcgPSBib3VuZHMud2lkdGgoKSxcbiAgICAgICAgaCA9IGJvdW5kcy5oZWlnaHQoKTtcbiAgbGV0IGdyYWRpZW50O1xuXG4gIGlmIChzcGVjLmdyYWRpZW50ID09PSAncmFkaWFsJykge1xuICAgIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChib3VuZHMueDEgKyB2YWx1ZShzcGVjLngxLCAwLjUpICogdywgYm91bmRzLnkxICsgdmFsdWUoc3BlYy55MSwgMC41KSAqIGgsIE1hdGgubWF4KHcsIGgpICogdmFsdWUoc3BlYy5yMSwgMCksIGJvdW5kcy54MSArIHZhbHVlKHNwZWMueDIsIDAuNSkgKiB3LCBib3VuZHMueTEgKyB2YWx1ZShzcGVjLnkyLCAwLjUpICogaCwgTWF0aC5tYXgodywgaCkgKiB2YWx1ZShzcGVjLnIyLCAwLjUpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBsaW5lYXIgZ3JhZGllbnRcbiAgICBjb25zdCB4MSA9IHZhbHVlKHNwZWMueDEsIDApLFxuICAgICAgICAgIHkxID0gdmFsdWUoc3BlYy55MSwgMCksXG4gICAgICAgICAgeDIgPSB2YWx1ZShzcGVjLngyLCAxKSxcbiAgICAgICAgICB5MiA9IHZhbHVlKHNwZWMueTIsIDApO1xuXG4gICAgaWYgKHgxID09PSB4MiB8fCB5MSA9PT0geTIgfHwgdyA9PT0gaCkge1xuICAgICAgLy8gYXhpcyBhbGlnbmVkOiB1c2Ugbm9ybWFsIGdyYWRpZW50XG4gICAgICBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoYm91bmRzLngxICsgeDEgKiB3LCBib3VuZHMueTEgKyB5MSAqIGgsIGJvdW5kcy54MSArIHgyICogdywgYm91bmRzLnkxICsgeTIgKiBoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90IGF4aXMgYWxpZ25lZDogcmVuZGVyIGdyYWRpZW50IGludG8gYSBwYXR0ZXJuICgjMjM2NSlcbiAgICAgIC8vIHRoaXMgYWxsb3dzIHVzIHRvIHVzZSBub3JtYWxpemVkIGJvdW5kaW5nIGJveCBjb29yZGluYXRlc1xuICAgICAgY29uc3QgaW1hZ2UgPSBjYW52YXMoTWF0aC5jZWlsKHcpLCBNYXRoLmNlaWwoaCkpLFxuICAgICAgICAgICAgaWN0eCA9IGltYWdlLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpY3R4LnNjYWxlKHcsIGgpO1xuICAgICAgaWN0eC5maWxsU3R5bGUgPSBhZGRTdG9wcyhpY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSwgc3BlYy5zdG9wcyk7XG4gICAgICBpY3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgcmV0dXJuIGNvbnRleHQuY3JlYXRlUGF0dGVybihpbWFnZSwgJ25vLXJlcGVhdCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhZGRTdG9wcyhncmFkaWVudCwgc3BlYy5zdG9wcyk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yIChjb250ZXh0LCBpdGVtLCB2YWx1ZSkge1xuICByZXR1cm4gaXNHcmFkaWVudCh2YWx1ZSkgPyBncmFkaWVudChjb250ZXh0LCB2YWx1ZSwgaXRlbS5ib3VuZHMpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGZpbGwgKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpIHtcbiAgb3BhY2l0eSAqPSBpdGVtLmZpbGxPcGFjaXR5ID09IG51bGwgPyAxIDogaXRlbS5maWxsT3BhY2l0eTtcblxuICBpZiAob3BhY2l0eSA+IDApIHtcbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yKGNvbnRleHQsIGl0ZW0sIGl0ZW0uZmlsbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnZhciBFbXB0eSA9IFtdO1xuZnVuY3Rpb24gc3Ryb2tlIChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSB7XG4gIHZhciBsdyA9IChsdyA9IGl0ZW0uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IDE7XG4gIGlmIChsdyA8PSAwKSByZXR1cm4gZmFsc2U7XG4gIG9wYWNpdHkgKj0gaXRlbS5zdHJva2VPcGFjaXR5ID09IG51bGwgPyAxIDogaXRlbS5zdHJva2VPcGFjaXR5O1xuXG4gIGlmIChvcGFjaXR5ID4gMCkge1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcihjb250ZXh0LCBpdGVtLCBpdGVtLnN0cm9rZSk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBsdztcbiAgICBjb250ZXh0LmxpbmVDYXAgPSBpdGVtLnN0cm9rZUNhcCB8fCAnYnV0dCc7XG4gICAgY29udGV4dC5saW5lSm9pbiA9IGl0ZW0uc3Ryb2tlSm9pbiB8fCAnbWl0ZXInO1xuICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IGl0ZW0uc3Ryb2tlTWl0ZXJMaW1pdCB8fCAxMDtcblxuICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICBjb250ZXh0LnNldExpbmVEYXNoKGl0ZW0uc3Ryb2tlRGFzaCB8fCBFbXB0eSk7XG4gICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gaXRlbS5zdHJva2VEYXNoT2Zmc2V0IHx8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYS56aW5kZXggLSBiLnppbmRleCB8fCBhLmluZGV4IC0gYi5pbmRleDtcbn1cblxuZnVuY3Rpb24gem9yZGVyKHNjZW5lKSB7XG4gIGlmICghc2NlbmUuemRpcnR5KSByZXR1cm4gc2NlbmUueml0ZW1zO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG91dHB1dCA9IFtdLFxuICAgICAgaXRlbSxcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgaXRlbS5pbmRleCA9IGk7XG4gICAgaWYgKGl0ZW0uemluZGV4KSBvdXRwdXQucHVzaChpdGVtKTtcbiAgfVxuXG4gIHNjZW5lLnpkaXJ0eSA9IGZhbHNlO1xuICByZXR1cm4gc2NlbmUueml0ZW1zID0gb3V0cHV0LnNvcnQoY29tcGFyZSk7XG59XG5mdW5jdGlvbiB2aXNpdChzY2VuZSwgdmlzaXRvcikge1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIGksXG4gICAgICBuO1xuICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgY29uc3Qgeml0ZW1zID0gem9yZGVyKHNjZW5lKTtcblxuICBpZiAoeml0ZW1zICYmIHppdGVtcy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoIWl0ZW1zW2ldLnppbmRleCkgdmlzaXRvcihpdGVtc1tpXSk7XG4gICAgfVxuXG4gICAgaXRlbXMgPSB6aXRlbXM7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgdmlzaXRvcihpdGVtc1tpXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBpY2tWaXNpdChzY2VuZSwgdmlzaXRvcikge1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIGhpdCxcbiAgICAgIGk7XG4gIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHppdGVtcyA9IHpvcmRlcihzY2VuZSk7XG4gIGlmICh6aXRlbXMgJiYgeml0ZW1zLmxlbmd0aCkgaXRlbXMgPSB6aXRlbXM7XG5cbiAgZm9yIChpID0gaXRlbXMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICBpZiAoaGl0ID0gdmlzaXRvcihpdGVtc1tpXSkpIHJldHVybiBoaXQ7XG4gIH1cblxuICBpZiAoaXRlbXMgPT09IHppdGVtcykge1xuICAgIGZvciAoaXRlbXMgPSBzY2VuZS5pdGVtcywgaSA9IGl0ZW1zLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICBpZiAoIWl0ZW1zW2ldLnppbmRleCkge1xuICAgICAgICBpZiAoaGl0ID0gdmlzaXRvcihpdGVtc1tpXSkpIHJldHVybiBoaXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRyYXdBbGwocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIHNjZW5lLCBib3VuZHMpIHtcbiAgICB2aXNpdChzY2VuZSwgaXRlbSA9PiB7XG4gICAgICBpZiAoIWJvdW5kcyB8fCBib3VuZHMuaW50ZXJzZWN0cyhpdGVtLmJvdW5kcykpIHtcbiAgICAgICAgZHJhd1BhdGgocGF0aCwgY29udGV4dCwgaXRlbSwgaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBkcmF3T25lKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBzY2VuZSwgYm91bmRzKSB7XG4gICAgaWYgKHNjZW5lLml0ZW1zLmxlbmd0aCAmJiAoIWJvdW5kcyB8fCBib3VuZHMuaW50ZXJzZWN0cyhzY2VuZS5ib3VuZHMpKSkge1xuICAgICAgZHJhd1BhdGgocGF0aCwgY29udGV4dCwgc2NlbmUuaXRlbXNbMF0sIHNjZW5lLml0ZW1zKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRyYXdQYXRoKHBhdGgsIGNvbnRleHQsIGl0ZW0sIGl0ZW1zKSB7XG4gIHZhciBvcGFjaXR5ID0gaXRlbS5vcGFjaXR5ID09IG51bGwgPyAxIDogaXRlbS5vcGFjaXR5O1xuICBpZiAob3BhY2l0eSA9PT0gMCkgcmV0dXJuO1xuICBpZiAocGF0aChjb250ZXh0LCBpdGVtcykpIHJldHVybjtcbiAgYmxlbmQoY29udGV4dCwgaXRlbSk7XG5cbiAgaWYgKGl0ZW0uZmlsbCAmJiBmaWxsKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cblxuICBpZiAoaXRlbS5zdHJva2UgJiYgc3Ryb2tlKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwaWNrJDEodGVzdCkge1xuICB0ZXN0ID0gdGVzdCB8fCB0cnV0aHk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICAgIHggKj0gY29udGV4dC5waXhlbFJhdGlvO1xuICAgIHkgKj0gY29udGV4dC5waXhlbFJhdGlvO1xuICAgIHJldHVybiBwaWNrVmlzaXQoc2NlbmUsIGl0ZW0gPT4ge1xuICAgICAgY29uc3QgYiA9IGl0ZW0uYm91bmRzOyAvLyBmaXJzdCBoaXQgdGVzdCBhZ2FpbnN0IGJvdW5kaW5nIGJveFxuXG4gICAgICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpIHx8ICFiKSByZXR1cm47IC8vIGlmIGluIGJvdW5kaW5nIGJveCwgcGVyZm9ybSBtb3JlIGNhcmVmdWwgdGVzdFxuXG4gICAgICBpZiAodGVzdChjb250ZXh0LCBpdGVtLCB4LCB5LCBneCwgZ3kpKSByZXR1cm4gaXRlbTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhpdFBhdGgocGF0aCwgZmlsbGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgbywgeCwgeSkge1xuICAgIHZhciBpdGVtID0gQXJyYXkuaXNBcnJheShvKSA/IG9bMF0gOiBvLFxuICAgICAgICBmaWxsID0gZmlsbGVkID09IG51bGwgPyBpdGVtLmZpbGwgOiBmaWxsZWQsXG4gICAgICAgIHN0cm9rZSA9IGl0ZW0uc3Ryb2tlICYmIGNvbnRleHQuaXNQb2ludEluU3Ryb2tlLFxuICAgICAgICBsdyxcbiAgICAgICAgbGM7XG5cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBsdyA9IGl0ZW0uc3Ryb2tlV2lkdGg7XG4gICAgICBsYyA9IGl0ZW0uc3Ryb2tlQ2FwO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsdyAhPSBudWxsID8gbHcgOiAxO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gbGMgIT0gbnVsbCA/IGxjIDogJ2J1dHQnO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoKGNvbnRleHQsIG8pID8gZmFsc2UgOiBmaWxsICYmIGNvbnRleHQuaXNQb2ludEluUGF0aCh4LCB5KSB8fCBzdHJva2UgJiYgY29udGV4dC5pc1BvaW50SW5TdHJva2UoeCwgeSk7XG4gIH07XG59XG5mdW5jdGlvbiBwaWNrUGF0aChwYXRoKSB7XG4gIHJldHVybiBwaWNrJDEoaGl0UGF0aChwYXRoKSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh4LCB5KSB7XG4gIHJldHVybiAndHJhbnNsYXRlKCcgKyB4ICsgJywnICsgeSArICcpJztcbn1cbmZ1bmN0aW9uIHJvdGF0ZShhKSB7XG4gIHJldHVybiAncm90YXRlKCcgKyBhICsgJyknO1xufVxuZnVuY3Rpb24gc2NhbGUoc2NhbGVYLCBzY2FsZVkpIHtcbiAgcmV0dXJuICdzY2FsZSgnICsgc2NhbGVYICsgJywnICsgc2NhbGVZICsgJyknO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlSXRlbShpdGVtKSB7XG4gIHJldHVybiB0cmFuc2xhdGUoaXRlbS54IHx8IDAsIGl0ZW0ueSB8fCAwKTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZUl0ZW0oaXRlbSkge1xuICByZXR1cm4gdHJhbnNsYXRlKGl0ZW0ueCB8fCAwLCBpdGVtLnkgfHwgMCkgKyAoaXRlbS5hbmdsZSA/ICcgJyArIHJvdGF0ZShpdGVtLmFuZ2xlKSA6ICcnKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUl0ZW0oaXRlbSkge1xuICByZXR1cm4gdHJhbnNsYXRlKGl0ZW0ueCB8fCAwLCBpdGVtLnkgfHwgMCkgKyAoaXRlbS5hbmdsZSA/ICcgJyArIHJvdGF0ZShpdGVtLmFuZ2xlKSA6ICcnKSArIChpdGVtLnNjYWxlWCB8fCBpdGVtLnNjYWxlWSA/ICcgJyArIHNjYWxlKGl0ZW0uc2NhbGVYIHx8IDEsIGl0ZW0uc2NhbGVZIHx8IDEpIDogJycpO1xufVxuXG5mdW5jdGlvbiBtYXJrSXRlbVBhdGggKHR5cGUsIHNoYXBlLCBpc2VjdCkge1xuICBmdW5jdGlvbiBhdHRyKGVtaXQsIGl0ZW0pIHtcbiAgICBlbWl0KCd0cmFuc2Zvcm0nLCByb3RhdGVJdGVtKGl0ZW0pKTtcbiAgICBlbWl0KCdkJywgc2hhcGUobnVsbCwgaXRlbSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYm91bmQoYm91bmRzLCBpdGVtKSB7XG4gICAgc2hhcGUoYm91bmRDb250ZXh0KGJvdW5kcywgaXRlbS5hbmdsZSksIGl0ZW0pO1xuICAgIHJldHVybiBib3VuZFN0cm9rZShib3VuZHMsIGl0ZW0pLnRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBpdGVtKSB7XG4gICAgdmFyIHggPSBpdGVtLnggfHwgMCxcbiAgICAgICAgeSA9IGl0ZW0ueSB8fCAwLFxuICAgICAgICBhID0gaXRlbS5hbmdsZSB8fCAwO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGlmIChhKSBjb250ZXh0LnJvdGF0ZShhICo9IERlZ1RvUmFkKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIHNoYXBlKGNvbnRleHQsIGl0ZW0pO1xuICAgIGlmIChhKSBjb250ZXh0LnJvdGF0ZSgtYSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0YWc6ICdwYXRoJyxcbiAgICBuZXN0ZWQ6IGZhbHNlLFxuICAgIGF0dHI6IGF0dHIsXG4gICAgYm91bmQ6IGJvdW5kLFxuICAgIGRyYXc6IGRyYXdBbGwoZHJhdyksXG4gICAgcGljazogcGlja1BhdGgoZHJhdyksXG4gICAgaXNlY3Q6IGlzZWN0IHx8IGludGVyc2VjdFBhdGgoZHJhdylcbiAgfTtcbn1cblxudmFyIGFyYyA9IG1hcmtJdGVtUGF0aCgnYXJjJywgYXJjJDEpO1xuXG5mdW5jdGlvbiBwaWNrQXJlYShhLCBwKSB7XG4gIHZhciB2ID0gYVswXS5vcmllbnQgPT09ICdob3Jpem9udGFsJyA/IHBbMV0gOiBwWzBdLFxuICAgICAgeiA9IGFbMF0ub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAneScgOiAneCcsXG4gICAgICBpID0gYS5sZW5ndGgsXG4gICAgICBtaW4gPSArSW5maW5pdHksXG4gICAgICBoaXQsXG4gICAgICBkO1xuXG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChhW2ldLmRlZmluZWQgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICBkID0gTWF0aC5hYnMoYVtpXVt6XSAtIHYpO1xuXG4gICAgaWYgKGQgPCBtaW4pIHtcbiAgICAgIG1pbiA9IGQ7XG4gICAgICBoaXQgPSBhW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoaXQ7XG59XG5mdW5jdGlvbiBwaWNrTGluZShhLCBwKSB7XG4gIHZhciB0ID0gTWF0aC5wb3coYVswXS5zdHJva2VXaWR0aCB8fCAxLCAyKSxcbiAgICAgIGkgPSBhLmxlbmd0aCxcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICBkZDtcblxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAoYVtpXS5kZWZpbmVkID09PSBmYWxzZSkgY29udGludWU7XG4gICAgZHggPSBhW2ldLnggLSBwWzBdO1xuICAgIGR5ID0gYVtpXS55IC0gcFsxXTtcbiAgICBkZCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGlmIChkZCA8IHQpIHJldHVybiBhW2ldO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwaWNrVHJhaWwoYSwgcCkge1xuICB2YXIgaSA9IGEubGVuZ3RoLFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIGRkO1xuXG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChhW2ldLmRlZmluZWQgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICBkeCA9IGFbaV0ueCAtIHBbMF07XG4gICAgZHkgPSBhW2ldLnkgLSBwWzFdO1xuICAgIGRkID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgZHggPSBhW2ldLnNpemUgfHwgMTtcbiAgICBpZiAoZGQgPCBkeCAqIGR4KSByZXR1cm4gYVtpXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtYXJrTXVsdGlJdGVtUGF0aCAodHlwZSwgc2hhcGUsIHRpcCkge1xuICBmdW5jdGlvbiBhdHRyKGVtaXQsIGl0ZW0pIHtcbiAgICB2YXIgaXRlbXMgPSBpdGVtLm1hcmsuaXRlbXM7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCkgZW1pdCgnZCcsIHNoYXBlKG51bGwsIGl0ZW1zKSk7XG4gIH1cblxuICBmdW5jdGlvbiBib3VuZChib3VuZHMsIG1hcmspIHtcbiAgICB2YXIgaXRlbXMgPSBtYXJrLml0ZW1zO1xuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcGUoYm91bmRDb250ZXh0KGJvdW5kcyksIGl0ZW1zKTtcbiAgICAgIHJldHVybiBib3VuZFN0cm9rZShib3VuZHMsIGl0ZW1zWzBdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGl0ZW1zKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBzaGFwZShjb250ZXh0LCBpdGVtcyk7XG4gIH1cblxuICBjb25zdCBoaXQgPSBoaXRQYXRoKGRyYXcpO1xuXG4gIGZ1bmN0aW9uIHBpY2soY29udGV4dCwgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICAgIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgICBiID0gc2NlbmUuYm91bmRzO1xuXG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoIHx8IGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgeCAqPSBjb250ZXh0LnBpeGVsUmF0aW87XG4gICAgeSAqPSBjb250ZXh0LnBpeGVsUmF0aW87XG4gICAgcmV0dXJuIGhpdChjb250ZXh0LCBpdGVtcywgeCwgeSkgPyBpdGVtc1swXSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGFnOiAncGF0aCcsXG4gICAgbmVzdGVkOiB0cnVlLFxuICAgIGF0dHI6IGF0dHIsXG4gICAgYm91bmQ6IGJvdW5kLFxuICAgIGRyYXc6IGRyYXdPbmUoZHJhdyksXG4gICAgcGljazogcGljayxcbiAgICBpc2VjdDogaW50ZXJzZWN0UG9pbnQsXG4gICAgdGlwOiB0aXBcbiAgfTtcbn1cblxudmFyIGFyZWEgPSBtYXJrTXVsdGlJdGVtUGF0aCgnYXJlYScsIGFyZWEkMSwgcGlja0FyZWEpO1xuXG5mdW5jdGlvbiBjbGlwIChjb250ZXh0LCBzY2VuZSkge1xuICB2YXIgY2xpcCA9IHNjZW5lLmNsaXA7XG4gIGNvbnRleHQuc2F2ZSgpO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGNsaXApKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjbGlwKGNvbnRleHQpO1xuICAgIGNvbnRleHQuY2xpcCgpO1xuICB9IGVsc2Uge1xuICAgIGNsaXBHcm91cChjb250ZXh0LCBzY2VuZS5ncm91cCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsaXBHcm91cChjb250ZXh0LCBncm91cCkge1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICBoYXNDb3JuZXJSYWRpdXMoZ3JvdXApID8gcmVjdGFuZ2xlKGNvbnRleHQsIGdyb3VwLCAwLCAwKSA6IGNvbnRleHQucmVjdCgwLCAwLCBncm91cC53aWR0aCB8fCAwLCBncm91cC5oZWlnaHQgfHwgMCk7XG4gIGNvbnRleHQuY2xpcCgpO1xufVxuXG5mdW5jdGlvbiBvZmZzZXQkMShpdGVtKSB7XG4gIGNvbnN0IHN3ID0gdmFsdWUoaXRlbS5zdHJva2VXaWR0aCwgMSk7XG4gIHJldHVybiBpdGVtLnN0cm9rZU9mZnNldCAhPSBudWxsID8gaXRlbS5zdHJva2VPZmZzZXQgOiBpdGVtLnN0cm9rZSAmJiBzdyA+IDAuNSAmJiBzdyA8IDEuNSA/IDAuNSAtIE1hdGguYWJzKHN3IC0gMSkgOiAwO1xufVxuXG5mdW5jdGlvbiBhdHRyJDUoZW1pdCwgaXRlbSkge1xuICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVJdGVtKGl0ZW0pKTtcbn1cblxuZnVuY3Rpb24gZW1pdFJlY3RhbmdsZShlbWl0LCBpdGVtKSB7XG4gIGNvbnN0IG9mZiA9IG9mZnNldCQxKGl0ZW0pO1xuICBlbWl0KCdkJywgcmVjdGFuZ2xlKG51bGwsIGl0ZW0sIG9mZiwgb2ZmKSk7XG59XG5cbmZ1bmN0aW9uIGJhY2tncm91bmQoZW1pdCwgaXRlbSkge1xuICBlbWl0KCdjbGFzcycsICdiYWNrZ3JvdW5kJyk7XG4gIGVtaXQoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gIGVtaXRSZWN0YW5nbGUoZW1pdCwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIGZvcmVncm91bmQoZW1pdCwgaXRlbSkge1xuICBlbWl0KCdjbGFzcycsICdmb3JlZ3JvdW5kJyk7XG4gIGVtaXQoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG5cbiAgaWYgKGl0ZW0uc3Ryb2tlRm9yZWdyb3VuZCkge1xuICAgIGVtaXRSZWN0YW5nbGUoZW1pdCwgaXRlbSk7XG4gIH0gZWxzZSB7XG4gICAgZW1pdCgnZCcsICcnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb250ZW50KGVtaXQsIGl0ZW0sIHJlbmRlcmVyKSB7XG4gIGNvbnN0IHVybCA9IGl0ZW0uY2xpcCA/IGNsaXAkMShyZW5kZXJlciwgaXRlbSwgaXRlbSkgOiBudWxsO1xuICBlbWl0KCdjbGlwLXBhdGgnLCB1cmwpO1xufVxuXG5mdW5jdGlvbiBib3VuZCQ1KGJvdW5kcywgZ3JvdXApIHtcbiAgaWYgKCFncm91cC5jbGlwICYmIGdyb3VwLml0ZW1zKSB7XG4gICAgY29uc3QgaXRlbXMgPSBncm91cC5pdGVtcyxcbiAgICAgICAgICBtID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGJvdW5kcy51bmlvbihpdGVtc1tqXS5ib3VuZHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICgoZ3JvdXAuY2xpcCB8fCBncm91cC53aWR0aCB8fCBncm91cC5oZWlnaHQpICYmICFncm91cC5ub0JvdW5kKSB7XG4gICAgYm91bmRzLmFkZCgwLCAwKS5hZGQoZ3JvdXAud2lkdGggfHwgMCwgZ3JvdXAuaGVpZ2h0IHx8IDApO1xuICB9XG5cbiAgYm91bmRTdHJva2UoYm91bmRzLCBncm91cCk7XG4gIHJldHVybiBib3VuZHMudHJhbnNsYXRlKGdyb3VwLnggfHwgMCwgZ3JvdXAueSB8fCAwKTtcbn1cblxuZnVuY3Rpb24gcmVjdGFuZ2xlUGF0aChjb250ZXh0LCBncm91cCwgeCwgeSkge1xuICBjb25zdCBvZmYgPSBvZmZzZXQkMShncm91cCk7XG4gIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHJlY3RhbmdsZShjb250ZXh0LCBncm91cCwgKHggfHwgMCkgKyBvZmYsICh5IHx8IDApICsgb2ZmKTtcbn1cblxuY29uc3QgaGl0QmFja2dyb3VuZCA9IGhpdFBhdGgocmVjdGFuZ2xlUGF0aCk7XG5jb25zdCBoaXRGb3JlZ3JvdW5kID0gaGl0UGF0aChyZWN0YW5nbGVQYXRoLCBmYWxzZSk7XG5jb25zdCBoaXRDb3JuZXIgPSBoaXRQYXRoKHJlY3RhbmdsZVBhdGgsIHRydWUpO1xuXG5mdW5jdGlvbiBkcmF3JDQoY29udGV4dCwgc2NlbmUsIGJvdW5kcykge1xuICB2aXNpdChzY2VuZSwgZ3JvdXAgPT4ge1xuICAgIGNvbnN0IGd4ID0gZ3JvdXAueCB8fCAwLFxuICAgICAgICAgIGd5ID0gZ3JvdXAueSB8fCAwLFxuICAgICAgICAgIGZvcmUgPSBncm91cC5zdHJva2VGb3JlZ3JvdW5kLFxuICAgICAgICAgIG9wYWNpdHkgPSBncm91cC5vcGFjaXR5ID09IG51bGwgPyAxIDogZ3JvdXAub3BhY2l0eTsgLy8gZHJhdyBncm91cCBiYWNrZ3JvdW5kXG5cbiAgICBpZiAoKGdyb3VwLnN0cm9rZSB8fCBncm91cC5maWxsKSAmJiBvcGFjaXR5KSB7XG4gICAgICByZWN0YW5nbGVQYXRoKGNvbnRleHQsIGdyb3VwLCBneCwgZ3kpO1xuICAgICAgYmxlbmQoY29udGV4dCwgZ3JvdXApO1xuXG4gICAgICBpZiAoZ3JvdXAuZmlsbCAmJiBmaWxsKGNvbnRleHQsIGdyb3VwLCBvcGFjaXR5KSkge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwLnN0cm9rZSAmJiAhZm9yZSAmJiBzdHJva2UoY29udGV4dCwgZ3JvdXAsIG9wYWNpdHkpKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSAvLyBzZXR1cCBncmFwaGljcyBjb250ZXh0LCBzZXQgY2xpcCBhbmQgYm91bmRzXG5cblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgaWYgKGdyb3VwLmNsaXApIGNsaXBHcm91cChjb250ZXh0LCBncm91cCk7XG4gICAgaWYgKGJvdW5kcykgYm91bmRzLnRyYW5zbGF0ZSgtZ3gsIC1neSk7IC8vIGRyYXcgZ3JvdXAgY29udGVudHNcblxuICAgIHZpc2l0KGdyb3VwLCBpdGVtID0+IHtcbiAgICAgIHRoaXMuZHJhdyhjb250ZXh0LCBpdGVtLCBib3VuZHMpO1xuICAgIH0pOyAvLyByZXN0b3JlIGdyYXBoaWNzIGNvbnRleHRcblxuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTsgLy8gZHJhdyBncm91cCBmb3JlZ3JvdW5kXG5cbiAgICBpZiAoZm9yZSAmJiBncm91cC5zdHJva2UgJiYgb3BhY2l0eSkge1xuICAgICAgcmVjdGFuZ2xlUGF0aChjb250ZXh0LCBncm91cCwgZ3gsIGd5KTtcbiAgICAgIGJsZW5kKGNvbnRleHQsIGdyb3VwKTtcblxuICAgICAgaWYgKHN0cm9rZShjb250ZXh0LCBncm91cCwgb3BhY2l0eSkpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwaWNrKGNvbnRleHQsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKHNjZW5lLmJvdW5kcyAmJiAhc2NlbmUuYm91bmRzLmNvbnRhaW5zKGd4LCBneSkgfHwgIXNjZW5lLml0ZW1zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBjeCA9IHggKiBjb250ZXh0LnBpeGVsUmF0aW8sXG4gICAgICAgIGN5ID0geSAqIGNvbnRleHQucGl4ZWxSYXRpbztcbiAgcmV0dXJuIHBpY2tWaXNpdChzY2VuZSwgZ3JvdXAgPT4ge1xuICAgIGxldCBoaXQsIGR4LCBkeTsgLy8gZmlyc3QgaGl0IHRlc3QgYm91bmRpbmcgYm94XG5cbiAgICBjb25zdCBiID0gZ3JvdXAuYm91bmRzO1xuICAgIGlmIChiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHJldHVybjsgLy8gcGFzc2VkIGJvdW5kcyBjaGVjaywgdGVzdCByZWN0YW5ndWxhciBjbGlwXG5cbiAgICBkeCA9IGdyb3VwLnggfHwgMDtcbiAgICBkeSA9IGdyb3VwLnkgfHwgMDtcbiAgICBjb25zdCBkdyA9IGR4ICsgKGdyb3VwLndpZHRoIHx8IDApLFxuICAgICAgICAgIGRoID0gZHkgKyAoZ3JvdXAuaGVpZ2h0IHx8IDApLFxuICAgICAgICAgIGMgPSBncm91cC5jbGlwO1xuICAgIGlmIChjICYmIChneCA8IGR4IHx8IGd4ID4gZHcgfHwgZ3kgPCBkeSB8fCBneSA+IGRoKSkgcmV0dXJuOyAvLyBhZGp1c3QgY29vcmRpbmF0ZSBzeXN0ZW1cblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGR4LCBkeSk7XG4gICAgZHggPSBneCAtIGR4O1xuICAgIGR5ID0gZ3kgLSBkeTsgLy8gdGVzdCBiYWNrZ3JvdW5kIGZvciByb3VuZGVkIGNvcm5lciBjbGlwXG5cbiAgICBpZiAoYyAmJiBoYXNDb3JuZXJSYWRpdXMoZ3JvdXApICYmICFoaXRDb3JuZXIoY29udGV4dCwgZ3JvdXAsIGN4LCBjeSkpIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZm9yZSA9IGdyb3VwLnN0cm9rZUZvcmVncm91bmQsXG4gICAgICAgICAgaXggPSBzY2VuZS5pbnRlcmFjdGl2ZSAhPT0gZmFsc2U7IC8vIGhpdCB0ZXN0IGFnYWluc3QgZ3JvdXAgZm9yZWdyb3VuZFxuXG4gICAgaWYgKGl4ICYmIGZvcmUgJiYgZ3JvdXAuc3Ryb2tlICYmIGhpdEZvcmVncm91bmQoY29udGV4dCwgZ3JvdXAsIGN4LCBjeSkpIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0gLy8gaGl0IHRlc3QgYWdhaW5zdCBjb250YWluZWQgbWFya3NcblxuXG4gICAgaGl0ID0gcGlja1Zpc2l0KGdyb3VwLCBtYXJrID0+IHBpY2tNYXJrKG1hcmssIGR4LCBkeSkgPyB0aGlzLnBpY2sobWFyaywgeCwgeSwgZHgsIGR5KSA6IG51bGwpOyAvLyBoaXQgdGVzdCBhZ2FpbnN0IGdyb3VwIGJhY2tncm91bmRcblxuICAgIGlmICghaGl0ICYmIGl4ICYmIChncm91cC5maWxsIHx8ICFmb3JlICYmIGdyb3VwLnN0cm9rZSkgJiYgaGl0QmFja2dyb3VuZChjb250ZXh0LCBncm91cCwgY3gsIGN5KSkge1xuICAgICAgaGl0ID0gZ3JvdXA7XG4gICAgfSAvLyByZXN0b3JlIHN0YXRlIGFuZCByZXR1cm5cblxuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIGhpdCB8fCBudWxsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGlja01hcmsobWFyaywgeCwgeSkge1xuICByZXR1cm4gKG1hcmsuaW50ZXJhY3RpdmUgIT09IGZhbHNlIHx8IG1hcmsubWFya3R5cGUgPT09ICdncm91cCcpICYmIG1hcmsuYm91bmRzICYmIG1hcmsuYm91bmRzLmNvbnRhaW5zKHgsIHkpO1xufVxuXG52YXIgZ3JvdXAgPSB7XG4gIHR5cGU6ICdncm91cCcsXG4gIHRhZzogJ2cnLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBhdHRyOiBhdHRyJDUsXG4gIGJvdW5kOiBib3VuZCQ1LFxuICBkcmF3OiBkcmF3JDQsXG4gIHBpY2s6IHBpY2ssXG4gIGlzZWN0OiBpbnRlcnNlY3RSZWN0LFxuICBjb250ZW50OiBjb250ZW50LFxuICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kLFxuICBmb3JlZ3JvdW5kOiBmb3JlZ3JvdW5kXG59O1xuXG52YXIgbWV0YWRhdGEgPSB7XG4gICd4bWxucyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICd4bWxuczp4bGluayc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgJ3ZlcnNpb24nOiAnMS4xJ1xufTtcblxuZnVuY3Rpb24gZ2V0SW1hZ2UoaXRlbSwgcmVuZGVyZXIpIHtcbiAgdmFyIGltYWdlID0gaXRlbS5pbWFnZTtcblxuICBpZiAoIWltYWdlIHx8IGl0ZW0udXJsICYmIGl0ZW0udXJsICE9PSBpbWFnZS51cmwpIHtcbiAgICBpbWFnZSA9IHtcbiAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICByZW5kZXJlci5sb2FkSW1hZ2UoaXRlbS51cmwpLnRoZW4oaW1hZ2UgPT4ge1xuICAgICAgaXRlbS5pbWFnZSA9IGltYWdlO1xuICAgICAgaXRlbS5pbWFnZS51cmwgPSBpdGVtLnVybDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBpbWFnZTtcbn1cblxuZnVuY3Rpb24gaW1hZ2VXaWR0aChpdGVtLCBpbWFnZSkge1xuICByZXR1cm4gaXRlbS53aWR0aCAhPSBudWxsID8gaXRlbS53aWR0aCA6ICFpbWFnZSB8fCAhaW1hZ2Uud2lkdGggPyAwIDogaXRlbS5hc3BlY3QgIT09IGZhbHNlICYmIGl0ZW0uaGVpZ2h0ID8gaXRlbS5oZWlnaHQgKiBpbWFnZS53aWR0aCAvIGltYWdlLmhlaWdodCA6IGltYWdlLndpZHRoO1xufVxuXG5mdW5jdGlvbiBpbWFnZUhlaWdodChpdGVtLCBpbWFnZSkge1xuICByZXR1cm4gaXRlbS5oZWlnaHQgIT0gbnVsbCA/IGl0ZW0uaGVpZ2h0IDogIWltYWdlIHx8ICFpbWFnZS5oZWlnaHQgPyAwIDogaXRlbS5hc3BlY3QgIT09IGZhbHNlICYmIGl0ZW0ud2lkdGggPyBpdGVtLndpZHRoICogaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGggOiBpbWFnZS5oZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGltYWdlWE9mZnNldChhbGlnbiwgdykge1xuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInID8gdyAvIDIgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/IHcgOiAwO1xufVxuXG5mdW5jdGlvbiBpbWFnZVlPZmZzZXQoYmFzZWxpbmUsIGgpIHtcbiAgcmV0dXJuIGJhc2VsaW5lID09PSAnbWlkZGxlJyA/IGggLyAyIDogYmFzZWxpbmUgPT09ICdib3R0b20nID8gaCA6IDA7XG59XG5cbmZ1bmN0aW9uIGF0dHIkNChlbWl0LCBpdGVtLCByZW5kZXJlcikge1xuICBjb25zdCBpbWcgPSBnZXRJbWFnZShpdGVtLCByZW5kZXJlciksXG4gICAgICAgIHcgPSBpbWFnZVdpZHRoKGl0ZW0sIGltZyksXG4gICAgICAgIGggPSBpbWFnZUhlaWdodChpdGVtLCBpbWcpLFxuICAgICAgICB4ID0gKGl0ZW0ueCB8fCAwKSAtIGltYWdlWE9mZnNldChpdGVtLmFsaWduLCB3KSxcbiAgICAgICAgeSA9IChpdGVtLnkgfHwgMCkgLSBpbWFnZVlPZmZzZXQoaXRlbS5iYXNlbGluZSwgaCksXG4gICAgICAgIGkgPSAhaW1nLnNyYyAmJiBpbWcudG9EYXRhVVJMID8gaW1nLnRvRGF0YVVSTCgpIDogaW1nLnNyYyB8fCAnJztcbiAgZW1pdCgnaHJlZicsIGksIG1ldGFkYXRhWyd4bWxuczp4bGluayddLCAneGxpbms6aHJlZicpO1xuICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGUoeCwgeSkpO1xuICBlbWl0KCd3aWR0aCcsIHcpO1xuICBlbWl0KCdoZWlnaHQnLCBoKTtcbiAgZW1pdCgncHJlc2VydmVBc3BlY3RSYXRpbycsIGl0ZW0uYXNwZWN0ID09PSBmYWxzZSA/ICdub25lJyA6ICd4TWlkWU1pZCcpO1xufVxuXG5mdW5jdGlvbiBib3VuZCQ0KGJvdW5kcywgaXRlbSkge1xuICBjb25zdCBpbWcgPSBpdGVtLmltYWdlLFxuICAgICAgICB3ID0gaW1hZ2VXaWR0aChpdGVtLCBpbWcpLFxuICAgICAgICBoID0gaW1hZ2VIZWlnaHQoaXRlbSwgaW1nKSxcbiAgICAgICAgeCA9IChpdGVtLnggfHwgMCkgLSBpbWFnZVhPZmZzZXQoaXRlbS5hbGlnbiwgdyksXG4gICAgICAgIHkgPSAoaXRlbS55IHx8IDApIC0gaW1hZ2VZT2Zmc2V0KGl0ZW0uYmFzZWxpbmUsIGgpO1xuICByZXR1cm4gYm91bmRzLnNldCh4LCB5LCB4ICsgdywgeSArIGgpO1xufVxuXG5mdW5jdGlvbiBkcmF3JDMoY29udGV4dCwgc2NlbmUsIGJvdW5kcykge1xuICB2aXNpdChzY2VuZSwgaXRlbSA9PiB7XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoaXRlbS5ib3VuZHMpKSByZXR1cm47IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgY29uc3QgaW1nID0gZ2V0SW1hZ2UoaXRlbSwgdGhpcyk7XG4gICAgbGV0IHcgPSBpbWFnZVdpZHRoKGl0ZW0sIGltZyk7XG4gICAgbGV0IGggPSBpbWFnZUhlaWdodChpdGVtLCBpbWcpO1xuICAgIGlmICh3ID09PSAwIHx8IGggPT09IDApIHJldHVybjsgLy8gZWFybHkgZXhpdFxuXG4gICAgbGV0IHggPSAoaXRlbS54IHx8IDApIC0gaW1hZ2VYT2Zmc2V0KGl0ZW0uYWxpZ24sIHcpLFxuICAgICAgICB5ID0gKGl0ZW0ueSB8fCAwKSAtIGltYWdlWU9mZnNldChpdGVtLmJhc2VsaW5lLCBoKSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgYXIwLFxuICAgICAgICBhcjEsXG4gICAgICAgIHQ7XG5cbiAgICBpZiAoaXRlbS5hc3BlY3QgIT09IGZhbHNlKSB7XG4gICAgICBhcjAgPSBpbWcud2lkdGggLyBpbWcuaGVpZ2h0O1xuICAgICAgYXIxID0gaXRlbS53aWR0aCAvIGl0ZW0uaGVpZ2h0O1xuXG4gICAgICBpZiAoYXIwID09PSBhcjAgJiYgYXIxID09PSBhcjEgJiYgYXIwICE9PSBhcjEpIHtcbiAgICAgICAgaWYgKGFyMSA8IGFyMCkge1xuICAgICAgICAgIHQgPSB3IC8gYXIwO1xuICAgICAgICAgIHkgKz0gKGggLSB0KSAvIDI7XG4gICAgICAgICAgaCA9IHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdCA9IGggKiBhcjA7XG4gICAgICAgICAgeCArPSAodyAtIHQpIC8gMjtcbiAgICAgICAgICB3ID0gdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbWcuY29tcGxldGUgfHwgaW1nLnRvRGF0YVVSTCkge1xuICAgICAgYmxlbmQoY29udGV4dCwgaXRlbSk7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gKG9wYWNpdHkgPSBpdGVtLm9wYWNpdHkpICE9IG51bGwgPyBvcGFjaXR5IDogMTtcbiAgICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaXRlbS5zbW9vdGggIT09IGZhbHNlO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCB4LCB5LCB3LCBoKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgaW1hZ2UgPSB7XG4gIHR5cGU6ICdpbWFnZScsXG4gIHRhZzogJ2ltYWdlJyxcbiAgbmVzdGVkOiBmYWxzZSxcbiAgYXR0cjogYXR0ciQ0LFxuICBib3VuZDogYm91bmQkNCxcbiAgZHJhdzogZHJhdyQzLFxuICBwaWNrOiBwaWNrJDEoKSxcbiAgaXNlY3Q6IHRydXRoeSxcbiAgLy8gYm91bmRzIGNoZWNrIGlzIHN1ZmZpY2llbnRcbiAgZ2V0OiBnZXRJbWFnZSxcbiAgeE9mZnNldDogaW1hZ2VYT2Zmc2V0LFxuICB5T2Zmc2V0OiBpbWFnZVlPZmZzZXRcbn07XG5cbnZhciBsaW5lID0gbWFya011bHRpSXRlbVBhdGgoJ2xpbmUnLCBsaW5lJDEsIHBpY2tMaW5lKTtcblxuZnVuY3Rpb24gYXR0ciQzKGVtaXQsIGl0ZW0pIHtcbiAgdmFyIHN4ID0gaXRlbS5zY2FsZVggfHwgMSxcbiAgICAgIHN5ID0gaXRlbS5zY2FsZVkgfHwgMTtcblxuICBpZiAoc3ggIT09IDEgfHwgc3kgIT09IDEpIHtcbiAgICBlbWl0KCd2ZWN0b3ItZWZmZWN0JywgJ25vbi1zY2FsaW5nLXN0cm9rZScpO1xuICB9XG5cbiAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNmb3JtSXRlbShpdGVtKSk7XG4gIGVtaXQoJ2QnLCBpdGVtLnBhdGgpO1xufVxuXG5mdW5jdGlvbiBwYXRoJDEoY29udGV4dCwgaXRlbSkge1xuICB2YXIgcGF0aCA9IGl0ZW0ucGF0aDtcbiAgaWYgKHBhdGggPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHZhciB4ID0gaXRlbS54IHx8IDAsXG4gICAgICB5ID0gaXRlbS55IHx8IDAsXG4gICAgICBzeCA9IGl0ZW0uc2NhbGVYIHx8IDEsXG4gICAgICBzeSA9IGl0ZW0uc2NhbGVZIHx8IDEsXG4gICAgICBhID0gKGl0ZW0uYW5nbGUgfHwgMCkgKiBEZWdUb1JhZCxcbiAgICAgIGNhY2hlID0gaXRlbS5wYXRoQ2FjaGU7XG5cbiAgaWYgKCFjYWNoZSB8fCBjYWNoZS5wYXRoICE9PSBwYXRoKSB7XG4gICAgKGl0ZW0ucGF0aENhY2hlID0gY2FjaGUgPSBwYXRoUGFyc2UocGF0aCkpLnBhdGggPSBwYXRoO1xuICB9XG5cbiAgaWYgKGEgJiYgY29udGV4dC5yb3RhdGUgJiYgY29udGV4dC50cmFuc2xhdGUpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnJvdGF0ZShhKTtcbiAgICBwYXRoUmVuZGVyKGNvbnRleHQsIGNhY2hlLCAwLCAwLCBzeCwgc3kpO1xuICAgIGNvbnRleHQucm90YXRlKC1hKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9IGVsc2Uge1xuICAgIHBhdGhSZW5kZXIoY29udGV4dCwgY2FjaGUsIHgsIHksIHN4LCBzeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmQkMyhib3VuZHMsIGl0ZW0pIHtcbiAgcmV0dXJuIHBhdGgkMShib3VuZENvbnRleHQoYm91bmRzLCBpdGVtLmFuZ2xlKSwgaXRlbSkgPyBib3VuZHMuc2V0KDAsIDAsIDAsIDApIDogYm91bmRTdHJva2UoYm91bmRzLCBpdGVtLCB0cnVlKTtcbn1cblxudmFyIHBhdGgkMiA9IHtcbiAgdHlwZTogJ3BhdGgnLFxuICB0YWc6ICdwYXRoJyxcbiAgbmVzdGVkOiBmYWxzZSxcbiAgYXR0cjogYXR0ciQzLFxuICBib3VuZDogYm91bmQkMyxcbiAgZHJhdzogZHJhd0FsbChwYXRoJDEpLFxuICBwaWNrOiBwaWNrUGF0aChwYXRoJDEpLFxuICBpc2VjdDogaW50ZXJzZWN0UGF0aChwYXRoJDEpXG59O1xuXG5mdW5jdGlvbiBhdHRyJDIoZW1pdCwgaXRlbSkge1xuICBlbWl0KCdkJywgcmVjdGFuZ2xlKG51bGwsIGl0ZW0pKTtcbn1cblxuZnVuY3Rpb24gYm91bmQkMihib3VuZHMsIGl0ZW0pIHtcbiAgdmFyIHgsIHk7XG4gIHJldHVybiBib3VuZFN0cm9rZShib3VuZHMuc2V0KHggPSBpdGVtLnggfHwgMCwgeSA9IGl0ZW0ueSB8fCAwLCB4ICsgaXRlbS53aWR0aCB8fCAwLCB5ICsgaXRlbS5oZWlnaHQgfHwgMCksIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBkcmF3JDIoY29udGV4dCwgaXRlbSkge1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICByZWN0YW5nbGUoY29udGV4dCwgaXRlbSk7XG59XG5cbnZhciByZWN0ID0ge1xuICB0eXBlOiAncmVjdCcsXG4gIHRhZzogJ3BhdGgnLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBhdHRyOiBhdHRyJDIsXG4gIGJvdW5kOiBib3VuZCQyLFxuICBkcmF3OiBkcmF3QWxsKGRyYXckMiksXG4gIHBpY2s6IHBpY2tQYXRoKGRyYXckMiksXG4gIGlzZWN0OiBpbnRlcnNlY3RSZWN0XG59O1xuXG5mdW5jdGlvbiBhdHRyJDEoZW1pdCwgaXRlbSkge1xuICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVJdGVtKGl0ZW0pKTtcbiAgZW1pdCgneDInLCBpdGVtLngyICE9IG51bGwgPyBpdGVtLngyIC0gKGl0ZW0ueCB8fCAwKSA6IDApO1xuICBlbWl0KCd5MicsIGl0ZW0ueTIgIT0gbnVsbCA/IGl0ZW0ueTIgLSAoaXRlbS55IHx8IDApIDogMCk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kJDEoYm91bmRzLCBpdGVtKSB7XG4gIHZhciB4MSwgeTE7XG4gIHJldHVybiBib3VuZFN0cm9rZShib3VuZHMuc2V0KHgxID0gaXRlbS54IHx8IDAsIHkxID0gaXRlbS55IHx8IDAsIGl0ZW0ueDIgIT0gbnVsbCA/IGl0ZW0ueDIgOiB4MSwgaXRlbS55MiAhPSBudWxsID8gaXRlbS55MiA6IHkxKSwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIHBhdGgoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkge1xuICB2YXIgeDEsIHkxLCB4MiwgeTI7XG5cbiAgaWYgKGl0ZW0uc3Ryb2tlICYmIHN0cm9rZShjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgIHgxID0gaXRlbS54IHx8IDA7XG4gICAgeTEgPSBpdGVtLnkgfHwgMDtcbiAgICB4MiA9IGl0ZW0ueDIgIT0gbnVsbCA/IGl0ZW0ueDIgOiB4MTtcbiAgICB5MiA9IGl0ZW0ueTIgIT0gbnVsbCA/IGl0ZW0ueTIgOiB5MTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZHJhdyQxKGNvbnRleHQsIHNjZW5lLCBib3VuZHMpIHtcbiAgdmlzaXQoc2NlbmUsIGl0ZW0gPT4ge1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKGl0ZW0uYm91bmRzKSkgcmV0dXJuOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIHZhciBvcGFjaXR5ID0gaXRlbS5vcGFjaXR5ID09IG51bGwgPyAxIDogaXRlbS5vcGFjaXR5O1xuXG4gICAgaWYgKG9wYWNpdHkgJiYgcGF0aChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgICAgYmxlbmQoY29udGV4dCwgaXRlbSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpdCQxKGNvbnRleHQsIGl0ZW0sIHgsIHkpIHtcbiAgaWYgKCFjb250ZXh0LmlzUG9pbnRJblN0cm9rZSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gcGF0aChjb250ZXh0LCBpdGVtLCAxKSAmJiBjb250ZXh0LmlzUG9pbnRJblN0cm9rZSh4LCB5KTtcbn1cblxudmFyIHJ1bGUgPSB7XG4gIHR5cGU6ICdydWxlJyxcbiAgdGFnOiAnbGluZScsXG4gIG5lc3RlZDogZmFsc2UsXG4gIGF0dHI6IGF0dHIkMSxcbiAgYm91bmQ6IGJvdW5kJDEsXG4gIGRyYXc6IGRyYXckMSxcbiAgcGljazogcGljayQxKGhpdCQxKSxcbiAgaXNlY3Q6IGludGVyc2VjdFJ1bGVcbn07XG5cbnZhciBzaGFwZSA9IG1hcmtJdGVtUGF0aCgnc2hhcGUnLCBzaGFwZSQxKTtcblxudmFyIHN5bWJvbCA9IG1hcmtJdGVtUGF0aCgnc3ltYm9sJywgc3ltYm9sJDEsIGludGVyc2VjdFBvaW50KTtcblxuY29uc3Qgd2lkdGhDYWNoZSA9IGxydUNhY2hlKCk7XG52YXIgdGV4dE1ldHJpY3MgPSB7XG4gIGhlaWdodDogZm9udFNpemUsXG4gIG1lYXN1cmVXaWR0aDogbWVhc3VyZVdpZHRoLFxuICBlc3RpbWF0ZVdpZHRoOiBlc3RpbWF0ZVdpZHRoLFxuICB3aWR0aDogZXN0aW1hdGVXaWR0aCxcbiAgY2FudmFzOiB1c2VDYW52YXNcbn07XG51c2VDYW52YXModHJ1ZSk7XG5cbmZ1bmN0aW9uIHVzZUNhbnZhcyh1c2UpIHtcbiAgdGV4dE1ldHJpY3Mud2lkdGggPSB1c2UgJiYgY29udGV4dCA/IG1lYXN1cmVXaWR0aCA6IGVzdGltYXRlV2lkdGg7XG59IC8vIG1ha2Ugc2ltcGxlIGVzdGltYXRlIGlmIG5vIGNhbnZhcyBpcyBhdmFpbGFibGVcblxuXG5mdW5jdGlvbiBlc3RpbWF0ZVdpZHRoKGl0ZW0sIHRleHQpIHtcbiAgcmV0dXJuIF9lc3RpbWF0ZVdpZHRoKHRleHRWYWx1ZShpdGVtLCB0ZXh0KSwgZm9udFNpemUoaXRlbSkpO1xufVxuXG5mdW5jdGlvbiBfZXN0aW1hdGVXaWR0aCh0ZXh0LCBjdXJyZW50Rm9udEhlaWdodCkge1xuICByZXR1cm4gfn4oMC44ICogdGV4dC5sZW5ndGggKiBjdXJyZW50Rm9udEhlaWdodCk7XG59IC8vIG1lYXN1cmUgdGV4dCB3aWR0aCBpZiBjYW52YXMgaXMgYXZhaWxhYmxlXG5cblxuZnVuY3Rpb24gbWVhc3VyZVdpZHRoKGl0ZW0sIHRleHQpIHtcbiAgcmV0dXJuIGZvbnRTaXplKGl0ZW0pIDw9IDAgfHwgISh0ZXh0ID0gdGV4dFZhbHVlKGl0ZW0sIHRleHQpKSA/IDAgOiBfbWVhc3VyZVdpZHRoKHRleHQsIGZvbnQoaXRlbSkpO1xufVxuXG5mdW5jdGlvbiBfbWVhc3VyZVdpZHRoKHRleHQsIGN1cnJlbnRGb250KSB7XG4gIGNvbnN0IGtleSA9IGAoJHtjdXJyZW50Rm9udH0pICR7dGV4dH1gO1xuICBsZXQgd2lkdGggPSB3aWR0aENhY2hlLmdldChrZXkpO1xuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29udGV4dC5mb250ID0gY3VycmVudEZvbnQ7XG4gICAgd2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIHdpZHRoQ2FjaGUuc2V0KGtleSwgd2lkdGgpO1xuICB9XG5cbiAgcmV0dXJuIHdpZHRoO1xufVxuXG5mdW5jdGlvbiBmb250U2l6ZShpdGVtKSB7XG4gIHJldHVybiBpdGVtLmZvbnRTaXplICE9IG51bGwgPyAraXRlbS5mb250U2l6ZSB8fCAwIDogMTE7XG59XG5mdW5jdGlvbiBsaW5lSGVpZ2h0KGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0ubGluZUhlaWdodCAhPSBudWxsID8gaXRlbS5saW5lSGVpZ2h0IDogZm9udFNpemUoaXRlbSkgKyAyO1xufVxuXG5mdW5jdGlvbiBsaW5lQXJyYXkoXykge1xuICByZXR1cm4gaXNBcnJheShfKSA/IF8ubGVuZ3RoID4gMSA/IF8gOiBfWzBdIDogXztcbn1cblxuZnVuY3Rpb24gdGV4dExpbmVzKGl0ZW0pIHtcbiAgcmV0dXJuIGxpbmVBcnJheShpdGVtLmxpbmVCcmVhayAmJiBpdGVtLnRleHQgJiYgIWlzQXJyYXkoaXRlbS50ZXh0KSA/IGl0ZW0udGV4dC5zcGxpdChpdGVtLmxpbmVCcmVhaykgOiBpdGVtLnRleHQpO1xufVxuZnVuY3Rpb24gbXVsdGlMaW5lT2Zmc2V0KGl0ZW0pIHtcbiAgY29uc3QgdGwgPSB0ZXh0TGluZXMoaXRlbSk7XG4gIHJldHVybiAoaXNBcnJheSh0bCkgPyB0bC5sZW5ndGggLSAxIDogMCkgKiBsaW5lSGVpZ2h0KGl0ZW0pO1xufVxuZnVuY3Rpb24gdGV4dFZhbHVlKGl0ZW0sIGxpbmUpIHtcbiAgY29uc3QgdGV4dCA9IGxpbmUgPT0gbnVsbCA/ICcnIDogKGxpbmUgKyAnJykudHJpbSgpO1xuICByZXR1cm4gaXRlbS5saW1pdCA+IDAgJiYgdGV4dC5sZW5ndGggPyB0cnVuY2F0ZShpdGVtLCB0ZXh0KSA6IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHdpZHRoR2V0dGVyKGl0ZW0pIHtcbiAgaWYgKHRleHRNZXRyaWNzLndpZHRoID09PSBtZWFzdXJlV2lkdGgpIHtcbiAgICAvLyB3ZSBhcmUgdXNpbmcgY2FudmFzXG4gICAgY29uc3QgY3VycmVudEZvbnQgPSBmb250KGl0ZW0pO1xuICAgIHJldHVybiB0ZXh0ID0+IF9tZWFzdXJlV2lkdGgodGV4dCwgY3VycmVudEZvbnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIHdlIGFyZSByZWx5aW5nIG9uIGVzdGltYXRlc1xuICAgIGNvbnN0IGN1cnJlbnRGb250SGVpZ2h0ID0gZm9udFNpemUoaXRlbSk7XG4gICAgcmV0dXJuIHRleHQgPT4gX2VzdGltYXRlV2lkdGgodGV4dCwgY3VycmVudEZvbnRIZWlnaHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKGl0ZW0sIHRleHQpIHtcbiAgdmFyIGxpbWl0ID0gK2l0ZW0ubGltaXQsXG4gICAgICB3aWR0aCA9IHdpZHRoR2V0dGVyKGl0ZW0pO1xuICBpZiAod2lkdGgodGV4dCkgPCBsaW1pdCkgcmV0dXJuIHRleHQ7XG4gIHZhciBlbGxpcHNpcyA9IGl0ZW0uZWxsaXBzaXMgfHwgJ1xcdTIwMjYnLFxuICAgICAgcnRsID0gaXRlbS5kaXIgPT09ICdydGwnLFxuICAgICAgbG8gPSAwLFxuICAgICAgaGkgPSB0ZXh0Lmxlbmd0aCxcbiAgICAgIG1pZDtcbiAgbGltaXQgLT0gd2lkdGgoZWxsaXBzaXMpO1xuXG4gIGlmIChydGwpIHtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgIGlmICh3aWR0aCh0ZXh0LnNsaWNlKG1pZCkpID4gbGltaXQpIGxvID0gbWlkICsgMTtlbHNlIGhpID0gbWlkO1xuICAgIH1cblxuICAgIHJldHVybiBlbGxpcHNpcyArIHRleHQuc2xpY2UobG8pO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSAxICsgKGxvICsgaGkgPj4+IDEpO1xuICAgICAgaWYgKHdpZHRoKHRleHQuc2xpY2UoMCwgbWlkKSkgPCBsaW1pdCkgbG8gPSBtaWQ7ZWxzZSBoaSA9IG1pZCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQuc2xpY2UoMCwgbG8pICsgZWxsaXBzaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9udEZhbWlseShpdGVtLCBxdW90ZSkge1xuICB2YXIgZm9udCA9IGl0ZW0uZm9udDtcbiAgcmV0dXJuIChxdW90ZSAmJiBmb250ID8gU3RyaW5nKGZvbnQpLnJlcGxhY2UoL1wiL2csICdcXCcnKSA6IGZvbnQpIHx8ICdzYW5zLXNlcmlmJztcbn1cbmZ1bmN0aW9uIGZvbnQoaXRlbSwgcXVvdGUpIHtcbiAgcmV0dXJuICcnICsgKGl0ZW0uZm9udFN0eWxlID8gaXRlbS5mb250U3R5bGUgKyAnICcgOiAnJykgKyAoaXRlbS5mb250VmFyaWFudCA/IGl0ZW0uZm9udFZhcmlhbnQgKyAnICcgOiAnJykgKyAoaXRlbS5mb250V2VpZ2h0ID8gaXRlbS5mb250V2VpZ2h0ICsgJyAnIDogJycpICsgZm9udFNpemUoaXRlbSkgKyAncHggJyArIGZvbnRGYW1pbHkoaXRlbSwgcXVvdGUpO1xufVxuZnVuY3Rpb24gb2Zmc2V0KGl0ZW0pIHtcbiAgLy8gcGVyZm9ybSBvdXIgb3duIGZvbnQgYmFzZWxpbmUgY2FsY3VsYXRpb25cbiAgLy8gd2h5PyBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgU1ZHIDEuMSAnYWxpZ25tZW50LWJhc2VsaW5lJyA6KFxuICAvLyB0aGlzIGFsc28gZW5zdXJlcyBjb25zaXN0ZW50IGxheW91dCBhY3Jvc3MgcmVuZGVyZXJzXG4gIHZhciBiYXNlbGluZSA9IGl0ZW0uYmFzZWxpbmUsXG4gICAgICBoID0gZm9udFNpemUoaXRlbSk7XG4gIHJldHVybiBNYXRoLnJvdW5kKGJhc2VsaW5lID09PSAndG9wJyA/IDAuNzkgKiBoIDogYmFzZWxpbmUgPT09ICdtaWRkbGUnID8gMC4zMCAqIGggOiBiYXNlbGluZSA9PT0gJ2JvdHRvbScgPyAtMC4yMSAqIGggOiBiYXNlbGluZSA9PT0gJ2xpbmUtdG9wJyA/IDAuMjkgKiBoICsgMC41ICogbGluZUhlaWdodChpdGVtKSA6IGJhc2VsaW5lID09PSAnbGluZS1ib3R0b20nID8gMC4yOSAqIGggLSAwLjUgKiBsaW5lSGVpZ2h0KGl0ZW0pIDogMCk7XG59XG5cbmNvbnN0IHRleHRBbGlnbiA9IHtcbiAgJ2xlZnQnOiAnc3RhcnQnLFxuICAnY2VudGVyJzogJ21pZGRsZScsXG4gICdyaWdodCc6ICdlbmQnXG59O1xuY29uc3QgdGVtcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblxuZnVuY3Rpb24gYW5jaG9yUG9pbnQoaXRlbSkge1xuICB2YXIgeCA9IGl0ZW0ueCB8fCAwLFxuICAgICAgeSA9IGl0ZW0ueSB8fCAwLFxuICAgICAgciA9IGl0ZW0ucmFkaXVzIHx8IDAsXG4gICAgICB0O1xuXG4gIGlmIChyKSB7XG4gICAgdCA9IChpdGVtLnRoZXRhIHx8IDApIC0gSGFsZlBpO1xuICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICB9XG5cbiAgdGVtcEJvdW5kcy54MSA9IHg7XG4gIHRlbXBCb3VuZHMueTEgPSB5O1xuICByZXR1cm4gdGVtcEJvdW5kcztcbn1cblxuZnVuY3Rpb24gYXR0cihlbWl0LCBpdGVtKSB7XG4gIHZhciBkeCA9IGl0ZW0uZHggfHwgMCxcbiAgICAgIGR5ID0gKGl0ZW0uZHkgfHwgMCkgKyBvZmZzZXQoaXRlbSksXG4gICAgICBwID0gYW5jaG9yUG9pbnQoaXRlbSksXG4gICAgICB4ID0gcC54MSxcbiAgICAgIHkgPSBwLnkxLFxuICAgICAgYSA9IGl0ZW0uYW5nbGUgfHwgMCxcbiAgICAgIHQ7XG4gIGVtaXQoJ3RleHQtYW5jaG9yJywgdGV4dEFsaWduW2l0ZW0uYWxpZ25dIHx8ICdzdGFydCcpO1xuXG4gIGlmIChhKSB7XG4gICAgdCA9IHRyYW5zbGF0ZSh4LCB5KSArICcgJyArIHJvdGF0ZShhKTtcbiAgICBpZiAoZHggfHwgZHkpIHQgKz0gJyAnICsgdHJhbnNsYXRlKGR4LCBkeSk7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHRyYW5zbGF0ZSh4ICsgZHgsIHkgKyBkeSk7XG4gIH1cblxuICBlbWl0KCd0cmFuc2Zvcm0nLCB0KTtcbn1cblxuZnVuY3Rpb24gYm91bmQoYm91bmRzLCBpdGVtLCBtb2RlKSB7XG4gIHZhciBoID0gdGV4dE1ldHJpY3MuaGVpZ2h0KGl0ZW0pLFxuICAgICAgYSA9IGl0ZW0uYWxpZ24sXG4gICAgICBwID0gYW5jaG9yUG9pbnQoaXRlbSksXG4gICAgICB4ID0gcC54MSxcbiAgICAgIHkgPSBwLnkxLFxuICAgICAgZHggPSBpdGVtLmR4IHx8IDAsXG4gICAgICBkeSA9IChpdGVtLmR5IHx8IDApICsgb2Zmc2V0KGl0ZW0pIC0gTWF0aC5yb3VuZCgwLjggKiBoKSxcbiAgICAgIC8vIHVzZSA0LzUgb2Zmc2V0XG4gIHRsID0gdGV4dExpbmVzKGl0ZW0pLFxuICAgICAgdzsgLy8gZ2V0IGRpbWVuc2lvbnNcblxuICBpZiAoaXNBcnJheSh0bCkpIHtcbiAgICAvLyBtdWx0aS1saW5lIHRleHRcbiAgICBoICs9IGxpbmVIZWlnaHQoaXRlbSkgKiAodGwubGVuZ3RoIC0gMSk7XG4gICAgdyA9IHRsLnJlZHVjZSgodywgdCkgPT4gTWF0aC5tYXgodywgdGV4dE1ldHJpY3Mud2lkdGgoaXRlbSwgdCkpLCAwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzaW5nbGUtbGluZSB0ZXh0XG4gICAgdyA9IHRleHRNZXRyaWNzLndpZHRoKGl0ZW0sIHRsKTtcbiAgfSAvLyBob3Jpem9udGFsIGFsaWdubWVudFxuXG5cbiAgaWYgKGEgPT09ICdjZW50ZXInKSB7XG4gICAgZHggLT0gdyAvIDI7XG4gIH0gZWxzZSBpZiAoYSA9PT0gJ3JpZ2h0Jykge1xuICAgIGR4IC09IHc7XG4gIH0gZWxzZSA7XG5cbiAgYm91bmRzLnNldChkeCArPSB4LCBkeSArPSB5LCBkeCArIHcsIGR5ICsgaCk7XG5cbiAgaWYgKGl0ZW0uYW5nbGUgJiYgIW1vZGUpIHtcbiAgICBib3VuZHMucm90YXRlKGl0ZW0uYW5nbGUgKiBEZWdUb1JhZCwgeCwgeSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gMikge1xuICAgIHJldHVybiBib3VuZHMucm90YXRlZFBvaW50cyhpdGVtLmFuZ2xlICogRGVnVG9SYWQsIHgsIHkpO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZpc2l0KHNjZW5lLCBpdGVtID0+IHtcbiAgICB2YXIgb3BhY2l0eSA9IGl0ZW0ub3BhY2l0eSA9PSBudWxsID8gMSA6IGl0ZW0ub3BhY2l0eSxcbiAgICAgICAgcCxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgaSxcbiAgICAgICAgbGgsXG4gICAgICAgIHRsLFxuICAgICAgICBzdHI7XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoaXRlbS5ib3VuZHMpIHx8IC8vIGJvdW5kcyBjaGVja1xuICAgIG9wYWNpdHkgPT09IDAgfHwgaXRlbS5mb250U2l6ZSA8PSAwIHx8IGl0ZW0udGV4dCA9PSBudWxsIHx8IGl0ZW0udGV4dC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb250ZXh0LmZvbnQgPSBmb250KGl0ZW0pO1xuICAgIGNvbnRleHQudGV4dEFsaWduID0gaXRlbS5hbGlnbiB8fCAnbGVmdCc7XG4gICAgcCA9IGFuY2hvclBvaW50KGl0ZW0pO1xuICAgIHggPSBwLngxLCB5ID0gcC55MTtcblxuICAgIGlmIChpdGVtLmFuZ2xlKSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY29udGV4dC5yb3RhdGUoaXRlbS5hbmdsZSAqIERlZ1RvUmFkKTtcbiAgICAgIHggPSB5ID0gMDsgLy8gcmVzZXQgeCwgeVxuICAgIH1cblxuICAgIHggKz0gaXRlbS5keCB8fCAwO1xuICAgIHkgKz0gKGl0ZW0uZHkgfHwgMCkgKyBvZmZzZXQoaXRlbSk7XG4gICAgdGwgPSB0ZXh0TGluZXMoaXRlbSk7XG4gICAgYmxlbmQoY29udGV4dCwgaXRlbSk7XG5cbiAgICBpZiAoaXNBcnJheSh0bCkpIHtcbiAgICAgIGxoID0gbGluZUhlaWdodChpdGVtKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN0ciA9IHRleHRWYWx1ZShpdGVtLCB0bFtpXSk7XG5cbiAgICAgICAgaWYgKGl0ZW0uZmlsbCAmJiBmaWxsKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dChzdHIsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0uc3Ryb2tlICYmIHN0cm9rZShjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChzdHIsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgeSArPSBsaDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gdGV4dFZhbHVlKGl0ZW0sIHRsKTtcblxuICAgICAgaWYgKGl0ZW0uZmlsbCAmJiBmaWxsKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoc3RyLCB4LCB5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW0uc3Ryb2tlICYmIHN0cm9rZShjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoc3RyLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXRlbS5hbmdsZSkgY29udGV4dC5yZXN0b3JlKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaXQoY29udGV4dCwgaXRlbSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmIChpdGVtLmZvbnRTaXplIDw9IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpdGVtLmFuZ2xlKSByZXR1cm4gdHJ1ZTsgLy8gYm91bmRzIHN1ZmZpY2llbnQgaWYgbm8gcm90YXRpb25cbiAgLy8gcHJvamVjdCBwb2ludCBpbnRvIHNwYWNlIG9mIHVucm90YXRlZCBib3VuZHNcblxuICB2YXIgcCA9IGFuY2hvclBvaW50KGl0ZW0pLFxuICAgICAgYXggPSBwLngxLFxuICAgICAgYXkgPSBwLnkxLFxuICAgICAgYiA9IGJvdW5kKHRlbXBCb3VuZHMsIGl0ZW0sIDEpLFxuICAgICAgYSA9IC1pdGVtLmFuZ2xlICogRGVnVG9SYWQsXG4gICAgICBjb3MgPSBNYXRoLmNvcyhhKSxcbiAgICAgIHNpbiA9IE1hdGguc2luKGEpLFxuICAgICAgcHggPSBjb3MgKiBneCAtIHNpbiAqIGd5ICsgKGF4IC0gY29zICogYXggKyBzaW4gKiBheSksXG4gICAgICBweSA9IHNpbiAqIGd4ICsgY29zICogZ3kgKyAoYXkgLSBzaW4gKiBheCAtIGNvcyAqIGF5KTtcbiAgcmV0dXJuIGIuY29udGFpbnMocHgsIHB5KTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0VGV4dChpdGVtLCBib3gpIHtcbiAgY29uc3QgcCA9IGJvdW5kKHRlbXBCb3VuZHMsIGl0ZW0sIDIpO1xuICByZXR1cm4gaW50ZXJzZWN0Qm94TGluZShib3gsIHBbMF0sIHBbMV0sIHBbMl0sIHBbM10pIHx8IGludGVyc2VjdEJveExpbmUoYm94LCBwWzBdLCBwWzFdLCBwWzRdLCBwWzVdKSB8fCBpbnRlcnNlY3RCb3hMaW5lKGJveCwgcFs0XSwgcFs1XSwgcFs2XSwgcFs3XSkgfHwgaW50ZXJzZWN0Qm94TGluZShib3gsIHBbMl0sIHBbM10sIHBbNl0sIHBbN10pO1xufVxuXG52YXIgdGV4dCA9IHtcbiAgdHlwZTogJ3RleHQnLFxuICB0YWc6ICd0ZXh0JyxcbiAgbmVzdGVkOiBmYWxzZSxcbiAgYXR0cjogYXR0cixcbiAgYm91bmQ6IGJvdW5kLFxuICBkcmF3OiBkcmF3LFxuICBwaWNrOiBwaWNrJDEoaGl0KSxcbiAgaXNlY3Q6IGludGVyc2VjdFRleHRcbn07XG5cbnZhciB0cmFpbCA9IG1hcmtNdWx0aUl0ZW1QYXRoKCd0cmFpbCcsIHRyYWlsJDEsIHBpY2tUcmFpbCk7XG5cbnZhciBNYXJrcyA9IHtcbiAgYXJjOiBhcmMsXG4gIGFyZWE6IGFyZWEsXG4gIGdyb3VwOiBncm91cCxcbiAgaW1hZ2U6IGltYWdlLFxuICBsaW5lOiBsaW5lLFxuICBwYXRoOiBwYXRoJDIsXG4gIHJlY3Q6IHJlY3QsXG4gIHJ1bGU6IHJ1bGUsXG4gIHNoYXBlOiBzaGFwZSxcbiAgc3ltYm9sOiBzeW1ib2wsXG4gIHRleHQ6IHRleHQsXG4gIHRyYWlsOiB0cmFpbFxufTtcblxuZnVuY3Rpb24gYm91bmRJdGVtIChpdGVtLCBmdW5jLCBvcHQpIHtcbiAgdmFyIHR5cGUgPSBNYXJrc1tpdGVtLm1hcmsubWFya3R5cGVdLFxuICAgICAgYm91bmQgPSBmdW5jIHx8IHR5cGUuYm91bmQ7XG4gIGlmICh0eXBlLm5lc3RlZCkgaXRlbSA9IGl0ZW0ubWFyaztcbiAgcmV0dXJuIGJvdW5kKGl0ZW0uYm91bmRzIHx8IChpdGVtLmJvdW5kcyA9IG5ldyBCb3VuZHMoKSksIGl0ZW0sIG9wdCk7XG59XG5cbnZhciBEVU1NWSA9IHtcbiAgbWFyazogbnVsbFxufTtcbmZ1bmN0aW9uIGJvdW5kTWFyayAobWFyaywgYm91bmRzLCBvcHQpIHtcbiAgdmFyIHR5cGUgPSBNYXJrc1ttYXJrLm1hcmt0eXBlXSxcbiAgICAgIGJvdW5kID0gdHlwZS5ib3VuZCxcbiAgICAgIGl0ZW1zID0gbWFyay5pdGVtcyxcbiAgICAgIGhhc0l0ZW1zID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBpdGVtLFxuICAgICAgYjtcblxuICBpZiAodHlwZS5uZXN0ZWQpIHtcbiAgICBpZiAoaGFzSXRlbXMpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gaXRlbXMsIGZha2UgaXRcbiAgICAgIERVTU1ZLm1hcmsgPSBtYXJrO1xuICAgICAgaXRlbSA9IERVTU1ZO1xuICAgIH1cblxuICAgIGIgPSBib3VuZEl0ZW0oaXRlbSwgYm91bmQsIG9wdCk7XG4gICAgYm91bmRzID0gYm91bmRzICYmIGJvdW5kcy51bmlvbihiKSB8fCBiO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cblxuICBib3VuZHMgPSBib3VuZHMgfHwgbWFyay5ib3VuZHMgJiYgbWFyay5ib3VuZHMuY2xlYXIoKSB8fCBuZXcgQm91bmRzKCk7XG5cbiAgaWYgKGhhc0l0ZW1zKSB7XG4gICAgZm9yIChpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgYm91bmRzLnVuaW9uKGJvdW5kSXRlbShpdGVtc1tpXSwgYm91bmQsIG9wdCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXJrLmJvdW5kcyA9IGJvdW5kcztcbn1cblxuY29uc3Qga2V5cyA9IFsnbWFya3R5cGUnLCAnbmFtZScsICdyb2xlJywgJ2ludGVyYWN0aXZlJywgJ2NsaXAnLCAnaXRlbXMnLCAnemluZGV4JywgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnYWxpZ24nLCAnYmFzZWxpbmUnLCAvLyBsYXlvdXRcbidmaWxsJywgJ2ZpbGxPcGFjaXR5JywgJ29wYWNpdHknLCAnYmxlbmQnLCAvLyBmaWxsXG4nc3Ryb2tlJywgJ3N0cm9rZU9wYWNpdHknLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlQ2FwJywgLy8gc3Ryb2tlXG4nc3Ryb2tlRGFzaCcsICdzdHJva2VEYXNoT2Zmc2V0JywgLy8gc3Ryb2tlIGRhc2hcbidzdHJva2VGb3JlZ3JvdW5kJywgJ3N0cm9rZU9mZnNldCcsIC8vIGdyb3VwXG4nc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsIC8vIGFyY1xuJ2Nvcm5lclJhZGl1cycsICdwYWRBbmdsZScsIC8vIGFyYywgcmVjdFxuJ2Nvcm5lclJhZGl1c1RvcExlZnQnLCAnY29ybmVyUmFkaXVzVG9wUmlnaHQnLCAvLyByZWN0LCBncm91cFxuJ2Nvcm5lclJhZGl1c0JvdHRvbUxlZnQnLCAnY29ybmVyUmFkaXVzQm90dG9tUmlnaHQnLCAnaW50ZXJwb2xhdGUnLCAndGVuc2lvbicsICdvcmllbnQnLCAnZGVmaW5lZCcsIC8vIGFyZWEsIGxpbmVcbid1cmwnLCAnYXNwZWN0JywgJ3Ntb290aCcsIC8vIGltYWdlXG4ncGF0aCcsICdzY2FsZVgnLCAnc2NhbGVZJywgLy8gcGF0aFxuJ3gyJywgJ3kyJywgLy8gcnVsZVxuJ3NpemUnLCAnc2hhcGUnLCAvLyBzeW1ib2xcbid0ZXh0JywgJ2FuZ2xlJywgJ3RoZXRhJywgJ3JhZGl1cycsICdkaXInLCAnZHgnLCAnZHknLCAvLyB0ZXh0XG4nZWxsaXBzaXMnLCAnbGltaXQnLCAnbGluZUJyZWFrJywgJ2xpbmVIZWlnaHQnLCAnZm9udCcsICdmb250U2l6ZScsICdmb250V2VpZ2h0JywgJ2ZvbnRTdHlsZScsICdmb250VmFyaWFudCcsIC8vIGZvbnRcbidkZXNjcmlwdGlvbicsICdhcmlhJywgJ2FyaWFSb2xlJywgJ2FyaWFSb2xlRGVzY3JpcHRpb24nIC8vIGFyaWFcbl07XG5mdW5jdGlvbiBzY2VuZVRvSlNPTihzY2VuZSwgaW5kZW50KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzY2VuZSwga2V5cywgaW5kZW50KTtcbn1cbmZ1bmN0aW9uIHNjZW5lRnJvbUpTT04oanNvbikge1xuICBjb25zdCBzY2VuZSA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICByZXR1cm4gaW5pdGlhbGl6ZShzY2VuZSk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUoc2NlbmUpIHtcbiAgdmFyIHR5cGUgPSBzY2VuZS5tYXJrdHlwZSxcbiAgICAgIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBwYXJlbnQsXG4gICAgICBpLFxuICAgICAgbjtcblxuICBpZiAoaXRlbXMpIHtcbiAgICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBwYXJlbnQgPSB0eXBlID8gJ21hcmsnIDogJ2dyb3VwJztcbiAgICAgIGl0ZW1zW2ldW3BhcmVudF0gPSBzY2VuZTtcbiAgICAgIGlmIChpdGVtc1tpXS56aW5kZXgpIGl0ZW1zW2ldW3BhcmVudF0uemRpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmICgnZ3JvdXAnID09PSAodHlwZSB8fCBwYXJlbnQpKSBpbml0aWFsaXplKGl0ZW1zW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSkgYm91bmRNYXJrKHNjZW5lKTtcbiAgcmV0dXJuIHNjZW5lO1xufVxuXG5mdW5jdGlvbiBTY2VuZWdyYXBoKHNjZW5lKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5yb290ID0gc2NlbmVGcm9tSlNPTihzY2VuZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yb290ID0gY3JlYXRlTWFyayh7XG4gICAgICBtYXJrdHlwZTogJ2dyb3VwJyxcbiAgICAgIG5hbWU6ICdyb290JyxcbiAgICAgIHJvbGU6ICdmcmFtZSdcbiAgICB9KTtcbiAgICB0aGlzLnJvb3QuaXRlbXMgPSBbbmV3IEdyb3VwSXRlbSh0aGlzLnJvb3QpXTtcbiAgfVxufVxuU2NlbmVncmFwaC5wcm90b3R5cGUgPSB7XG4gIHRvSlNPTihpbmRlbnQpIHtcbiAgICByZXR1cm4gc2NlbmVUb0pTT04odGhpcy5yb290LCBpbmRlbnQgfHwgMCk7XG4gIH0sXG5cbiAgbWFyayhtYXJrZGVmLCBncm91cCwgaW5kZXgpIHtcbiAgICBncm91cCA9IGdyb3VwIHx8IHRoaXMucm9vdC5pdGVtc1swXTtcbiAgICBjb25zdCBtYXJrID0gY3JlYXRlTWFyayhtYXJrZGVmLCBncm91cCk7XG4gICAgZ3JvdXAuaXRlbXNbaW5kZXhdID0gbWFyaztcbiAgICBpZiAobWFyay56aW5kZXgpIG1hcmsuZ3JvdXAuemRpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gbWFyaztcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrKGRlZiwgZ3JvdXApIHtcbiAgY29uc3QgbWFyayA9IHtcbiAgICBib3VuZHM6IG5ldyBCb3VuZHMoKSxcbiAgICBjbGlwOiAhIWRlZi5jbGlwLFxuICAgIGdyb3VwOiBncm91cCxcbiAgICBpbnRlcmFjdGl2ZTogZGVmLmludGVyYWN0aXZlID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSxcbiAgICBpdGVtczogW10sXG4gICAgbWFya3R5cGU6IGRlZi5tYXJrdHlwZSxcbiAgICBuYW1lOiBkZWYubmFtZSB8fCB1bmRlZmluZWQsXG4gICAgcm9sZTogZGVmLnJvbGUgfHwgdW5kZWZpbmVkLFxuICAgIHppbmRleDogZGVmLnppbmRleCB8fCAwXG4gIH07IC8vIGFkZCBhY2Nlc3NpYmlsaXR5IHByb3BlcnRpZXMgaWYgZGVmaW5lZFxuXG4gIGlmIChkZWYuYXJpYSAhPSBudWxsKSB7XG4gICAgbWFyay5hcmlhID0gZGVmLmFyaWE7XG4gIH1cblxuICBpZiAoZGVmLmRlc2NyaXB0aW9uKSB7XG4gICAgbWFyay5kZXNjcmlwdGlvbiA9IGRlZi5kZXNjcmlwdGlvbjtcbiAgfVxuXG4gIHJldHVybiBtYXJrO1xufVxuXG4vLyBjcmVhdGUgYSBuZXcgRE9NIGVsZW1lbnRcbmZ1bmN0aW9uIGRvbUNyZWF0ZShkb2MsIHRhZywgbnMpIHtcbiAgaWYgKCFkb2MgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB7XG4gICAgZG9jID0gZG9jdW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZG9jID8gbnMgPyBkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnKSA6IG51bGw7XG59IC8vIGZpbmQgZmlyc3QgY2hpbGQgZWxlbWVudCB3aXRoIG1hdGNoaW5nIHRhZ1xuXG5mdW5jdGlvbiBkb21GaW5kKGVsLCB0YWcpIHtcbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBub2RlcyA9IGVsLmNoaWxkTm9kZXMsXG4gICAgICBpID0gMCxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIGlmIChub2Rlc1tpXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZykge1xuICAgIHJldHVybiBub2Rlc1tpXTtcbiAgfVxufSAvLyByZXRyaWV2ZSBjaGlsZCBlbGVtZW50IGF0IGdpdmVuIGluZGV4XG4vLyBjcmVhdGUgJiBpbnNlcnQgaWYgZG9lc24ndCBleGlzdCBvciBpZiB0YWdzIGRvIG5vdCBtYXRjaFxuXG5mdW5jdGlvbiBkb21DaGlsZChlbCwgaW5kZXgsIHRhZywgbnMpIHtcbiAgdmFyIGEgPSBlbC5jaGlsZE5vZGVzW2luZGV4XSxcbiAgICAgIGI7XG5cbiAgaWYgKCFhIHx8IGEudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSB0YWcudG9Mb3dlckNhc2UoKSkge1xuICAgIGIgPSBhIHx8IG51bGw7XG4gICAgYSA9IGRvbUNyZWF0ZShlbC5vd25lckRvY3VtZW50LCB0YWcsIG5zKTtcbiAgICBlbC5pbnNlcnRCZWZvcmUoYSwgYik7XG4gIH1cblxuICByZXR1cm4gYTtcbn0gLy8gcmVtb3ZlIGFsbCBjaGlsZCBlbGVtZW50cyBhdCBvciBhYm92ZSB0aGUgZ2l2ZW4gaW5kZXhcblxuZnVuY3Rpb24gZG9tQ2xlYXIoZWwsIGluZGV4KSB7XG4gIHZhciBub2RlcyA9IGVsLmNoaWxkTm9kZXMsXG4gICAgICBjdXJyID0gbm9kZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChjdXJyID4gaW5kZXgpIGVsLnJlbW92ZUNoaWxkKG5vZGVzWy0tY3Vycl0pO1xuXG4gIHJldHVybiBlbDtcbn0gLy8gZ2VuZXJhdGUgY3NzIGNsYXNzIG5hbWUgZm9yIG1hcmtcblxuZnVuY3Rpb24gY3NzQ2xhc3MobWFyaykge1xuICByZXR1cm4gJ21hcmstJyArIG1hcmsubWFya3R5cGUgKyAobWFyay5yb2xlID8gJyByb2xlLScgKyBtYXJrLnJvbGUgOiAnJykgKyAobWFyay5uYW1lID8gJyAnICsgbWFyay5uYW1lIDogJycpO1xufVxuXG5mdW5jdGlvbiBwb2ludCAoZXZlbnQsIGVsKSB7XG4gIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gKGVsLmNsaWVudExlZnQgfHwgMCksIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIChlbC5jbGllbnRUb3AgfHwgMCldO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlSXRlbSAoaXRlbSwgZXZlbnQsIGVsLCBvcmlnaW4pIHtcbiAgdmFyIG1hcmsgPSBpdGVtICYmIGl0ZW0ubWFyayxcbiAgICAgIG1kZWYsXG4gICAgICBwO1xuXG4gIGlmIChtYXJrICYmIChtZGVmID0gTWFya3NbbWFyay5tYXJrdHlwZV0pLnRpcCkge1xuICAgIHAgPSBwb2ludChldmVudCwgZWwpO1xuICAgIHBbMF0gLT0gb3JpZ2luWzBdO1xuICAgIHBbMV0gLT0gb3JpZ2luWzFdO1xuXG4gICAgd2hpbGUgKGl0ZW0gPSBpdGVtLm1hcmsuZ3JvdXApIHtcbiAgICAgIHBbMF0gLT0gaXRlbS54IHx8IDA7XG4gICAgICBwWzFdIC09IGl0ZW0ueSB8fCAwO1xuICAgIH1cblxuICAgIGl0ZW0gPSBtZGVmLnRpcChtYXJrLml0ZW1zLCBwKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBIYW5kbGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtvYmplY3R9IFtjdXN0b21Mb2FkZXJdIC0gT3B0aW9uYWwgbG9hZGVyIGluc3RhbmNlIGZvclxuICogICBocmVmIFVSTCBzYW5pdGl6YXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIGEgc3RhbmRhcmQgbG9hZGVyXG4gKiAgIGluc3RhbmNlIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2N1c3RvbVRvb2x0aXBdIC0gT3B0aW9uYWwgdG9vbHRpcCBoYW5kbGVyXG4gKiAgIGZ1bmN0aW9uIGZvciBjdXN0b20gdG9vbHRpcCBkaXNwbGF5LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gSGFuZGxlcihjdXN0b21Mb2FkZXIsIGN1c3RvbVRvb2x0aXApIHtcbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgdGhpcy5fbG9hZGVyID0gY3VzdG9tTG9hZGVyIHx8IGxvYWRlcigpO1xuICB0aGlzLl90b29sdGlwID0gY3VzdG9tVG9vbHRpcCB8fCBkZWZhdWx0VG9vbHRpcDtcbn0gLy8gVGhlIGRlZmF1bHQgdG9vbHRpcCBkaXNwbGF5IGhhbmRsZXIuXG4vLyBTZXRzIHRoZSBIVE1MIHRpdGxlIGF0dHJpYnV0ZSBvbiB0aGUgdmlzdWFsaXphdGlvbiBjb250YWluZXIuXG5cbmZ1bmN0aW9uIGRlZmF1bHRUb29sdGlwKGhhbmRsZXIsIGV2ZW50LCBpdGVtLCB2YWx1ZSkge1xuICBoYW5kbGVyLmVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdmFsdWUgfHwgJycpO1xufVxuXG5IYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgSGFuZGxlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbCAtIFRoZSBjb250YWluaW5nIERPTSBlbGVtZW50IGZvciB0aGUgZGlzcGxheS5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqICAgVGhlIGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29ial0gLSBPcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHNob3VsZCBzZXJ2ZSBhc1xuICAgKiAgIHRoZSBcInRoaXNcIiBjb250ZXh0IGZvciBldmVudCBjYWxsYmFja3MuXG4gICAqIEByZXR1cm4ge0hhbmRsZXJ9IC0gVGhpcyBoYW5kbGVyIGluc3RhbmNlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShlbCwgb3JpZ2luLCBvYmopIHtcbiAgICB0aGlzLl9lbCA9IGVsO1xuICAgIHRoaXMuX29iaiA9IG9iaiB8fCBudWxsO1xuICAgIHJldHVybiB0aGlzLm9yaWdpbihvcmlnaW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgdmlzdWFsaXphdGlvbi5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gLSBUaGUgY29udGFpbmluZyBET00gZWxlbWVudC5cbiAgICovXG4gIGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY2VuZSBlbGVtZW50IChlLmcuLCBjYW52YXMgb3IgU1ZHKSBvZiB0aGUgdmlzdWFsaXphdGlvblxuICAgKiBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgaWYgdGhlIGZpcnN0IGNoaWxkIGlzIG5vdCB0aGUgc2NlbmUgZWxlbWVudC5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gLSBUaGUgc2NlbmUgKGUuZy4sIGNhbnZhcyBvciBTVkcpIGVsZW1lbnQuXG4gICAqL1xuICBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsICYmIHRoaXMuX2VsLmZpcnN0Q2hpbGQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCAvIHNldCB0aGUgb3JpZ2luIGNvb3JkaW5hdGVzIG9mIHRoZSB2aXN1YWxpemF0aW9uLlxuICAgKi9cbiAgb3JpZ2luKG9yaWdpbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9vcmlnaW4gPSBvcmlnaW4gfHwgWzAsIDBdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcmlnaW4uc2xpY2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCAvIHNldCB0aGUgc2NlbmVncmFwaCByb290LlxuICAgKi9cbiAgc2NlbmUoc2NlbmUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zY2VuZTtcbiAgICB0aGlzLl9zY2VuZSA9IHNjZW5lO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgaGFuZGxlci4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QuXG4gICAqL1xuICBvbigpXG4gIC8qdHlwZSwgaGFuZGxlciovXG4gIHt9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlci4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QuXG4gICAqL1xuICBvZmYoKVxuICAvKnR5cGUsIGhhbmRsZXIqL1xuICB7fSxcblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIGZpbmRpbmcgdGhlIGFycmF5IGluZGV4IG9mIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGggLSBBbiBhcnJheSBvZiByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gVGhlIGV2ZW50IGhhbmRsZXIgaW5zdGFuY2UgdG8gZmluZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBoYW5kbGVyJ3MgYXJyYXkgaW5kZXggb3IgLTEgaWYgbm90IHJlZ2lzdGVyZWQuXG4gICAqL1xuICBfaGFuZGxlckluZGV4KGgsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBmb3IgKGxldCBpID0gaCA/IGgubGVuZ3RoIDogMDsgLS1pID49IDA7KSB7XG4gICAgICBpZiAoaFtpXS50eXBlID09PSB0eXBlICYmICghaGFuZGxlciB8fCBoW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBUaGUgZXZlbnQgdHlwZSB0byBxdWVyeS4gQW55IGFubm90YXRpb25zXG4gICAqICAgYXJlIGlnbm9yZWQ7IGZvciBleGFtcGxlLCBmb3IgdGhlIGFyZ3VtZW50IFwiY2xpY2suZm9vXCIsIFwiLmZvb1wiIHdpbGxcbiAgICogICBiZSBpZ25vcmVkIGFuZCB0aGUgbWV0aG9kIHJldHVybnMgYWxsIFwiY2xpY2tcIiBoYW5kbGVycy4gSWYgdHlwZSBpc1xuICAgKiAgIG51bGwgb3IgdW5zcGVjaWZpZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgaGFuZGxlcnMgZm9yIGFsbCB0eXBlcy5cbiAgICogQHJldHVybiB7QXJyYXl9IC0gQSBuZXcgYXJyYXkgY29udGFpbmluZyBhbGwgcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVycy5cbiAgICovXG4gIGhhbmRsZXJzKHR5cGUpIHtcbiAgICBjb25zdCBoID0gdGhpcy5faGFuZGxlcnMsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGEucHVzaCguLi5oW3RoaXMuZXZlbnROYW1lKHR5cGUpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgayBpbiBoKSB7XG4gICAgICAgIGEucHVzaCguLi5oW2tdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfSxcblxuICAvKipcbiAgICogUGFyc2VzIGFuIGV2ZW50IG5hbWUgc3RyaW5nIHRvIHJldHVybiB0aGUgc3BlY2lmaWMgZXZlbnQgdHlwZS5cbiAgICogRm9yIGV4YW1wbGUsIGdpdmVuIFwiY2xpY2suZm9vXCIgcmV0dXJucyBcImNsaWNrXCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgaW5wdXQgZXZlbnQgdHlwZSBzdHJpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gLSBBIHN0cmluZyB3aXRoIHRoZSBldmVudCB0eXBlIG9ubHkuXG4gICAqL1xuICBldmVudE5hbWUobmFtZSkge1xuICAgIGNvbnN0IGkgPSBuYW1lLmluZGV4T2YoJy4nKTtcbiAgICByZXR1cm4gaSA8IDAgPyBuYW1lIDogbmFtZS5zbGljZSgwLCBpKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlIGh5cGVybGluayBuYXZpZ2F0aW9uIGluIHJlc3BvbnNlIHRvIGFuIGl0ZW0uaHJlZiB2YWx1ZS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdHJpZ2dlcmluZyBoeXBlcmxpbmsgbmF2aWdhdGlvbi5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIHNjZW5lZ3JhcGggaXRlbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgLSBUaGUgVVJMIHRvIG5hdmlnYXRlIHRvLlxuICAgKi9cbiAgaGFuZGxlSHJlZihldmVudCwgaXRlbSwgaHJlZikge1xuICAgIHRoaXMuX2xvYWRlci5zYW5pdGl6ZShocmVmLCB7XG4gICAgICBjb250ZXh0OiAnaHJlZidcbiAgICB9KS50aGVuKG9wdCA9PiB7XG4gICAgICBjb25zdCBlID0gbmV3IE1vdXNlRXZlbnQoZXZlbnQudHlwZSwgZXZlbnQpLFxuICAgICAgICAgICAgYSA9IGRvbUNyZWF0ZShudWxsLCAnYScpO1xuXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3B0KSBhLnNldEF0dHJpYnV0ZShuYW1lLCBvcHRbbmFtZV0pO1xuXG4gICAgICBhLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgLyogZG8gbm90aGluZyAqL1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG9vbHRpcCBkaXNwbGF5IGluIHJlc3BvbnNlIHRvIGFuIGl0ZW0udG9vbHRpcCB2YWx1ZS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdHJpZ2dlcmluZyB0b29sdGlwIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBzY2VuZWdyYXBoIGl0ZW0uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdyAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgd2hldGhlclxuICAgKiAgIHRvIHNob3cgb3IgaGlkZSBhIHRvb2x0aXAgZm9yIHRoZSBnaXZlbiBpdGVtLlxuICAgKi9cbiAgaGFuZGxlVG9vbHRpcChldmVudCwgaXRlbSwgc2hvdykge1xuICAgIGlmIChpdGVtICYmIGl0ZW0udG9vbHRpcCAhPSBudWxsKSB7XG4gICAgICBpdGVtID0gcmVzb2x2ZUl0ZW0oaXRlbSwgZXZlbnQsIHRoaXMuY2FudmFzKCksIHRoaXMuX29yaWdpbik7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNob3cgJiYgaXRlbSAmJiBpdGVtLnRvb2x0aXAgfHwgbnVsbDtcblxuICAgICAgdGhpcy5fdG9vbHRpcC5jYWxsKHRoaXMuX29iaiwgdGhpcywgZXZlbnQsIGl0ZW0sIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgYSBzY2VuZWdyYXBoIGl0ZW0gYW5kIGl0cyBwb3NpdGlvbiByZWxhdGl2ZVxuICAgKiB0byB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBzY2VuZWdyYXBoIGl0ZW0uXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBBIGJvdW5kaW5nIGJveCBvYmplY3QgKGNvbXBhdGlibGUgd2l0aCB0aGVcbiAgICogICBET01SZWN0IHR5cGUpIGNvbnNpc3Rpbmcgb2YgeCwgeSwgd2lkdGgsIGhlaWdoLCB0b3AsIGxlZnQsXG4gICAqICAgcmlnaHQsIGFuZCBib3R0b20gcHJvcGVydGllcy5cbiAgICovXG4gIGdldEl0ZW1Cb3VuZGluZ0NsaWVudFJlY3QoaXRlbSkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5jYW52YXMoKTtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIG9yaWdpbiA9IHRoaXMuX29yaWdpbixcbiAgICAgICAgICBib3VuZHMgPSBpdGVtLmJvdW5kcyxcbiAgICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCgpLFxuICAgICAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQoKTtcbiAgICBsZXQgeCA9IGJvdW5kcy54MSArIG9yaWdpblswXSArIHJlY3QubGVmdCxcbiAgICAgICAgeSA9IGJvdW5kcy55MSArIG9yaWdpblsxXSArIHJlY3QudG9wOyAvLyB0cmFuc2xhdGUgY29vcmRpbmF0ZSBmb3IgZWFjaCBwYXJlbnQgZ3JvdXBcblxuICAgIHdoaWxlIChpdGVtLm1hcmsgJiYgKGl0ZW0gPSBpdGVtLm1hcmsuZ3JvdXApKSB7XG4gICAgICB4ICs9IGl0ZW0ueCB8fCAwO1xuICAgICAgeSArPSBpdGVtLnkgfHwgMDtcbiAgICB9IC8vIHJldHVybiBET01SZWN0LWNvbXBhdGlibGUgYm91bmRpbmcgYm94XG5cblxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgICBib3R0b206IHkgKyBoZWlnaHRcbiAgICB9O1xuICB9XG5cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFJlbmRlcmVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtvYmplY3R9IFtsb2FkZXJdIC0gT3B0aW9uYWwgbG9hZGVyIGluc3RhbmNlIGZvclxuICogICBpbWFnZSBhbmQgaHJlZiBVUkwgc2FuaXRpemF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBhXG4gKiAgIHN0YW5kYXJkIGxvYWRlciBpbnN0YW5jZSB3aWxsIGJlIGdlbmVyYXRlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIFJlbmRlcmVyKGxvYWRlcikge1xuICB0aGlzLl9lbCA9IG51bGw7XG4gIHRoaXMuX2JnY29sb3IgPSBudWxsO1xuICB0aGlzLl9sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXIobG9hZGVyKTtcbn1cblJlbmRlcmVyLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgUmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWwgLSBUaGUgY29udGFpbmluZyBET00gZWxlbWVudCBmb3IgdGhlIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSBjb29yZGluYXRlIHdpZHRoIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgY29vcmRpbmF0ZSBoZWlnaHQgb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqICAgVGhlIGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlRmFjdG9yPTFdIC0gT3B0aW9uYWwgc2NhbGVGYWN0b3IgYnkgd2hpY2ggdG8gbXVsdGlwbHlcbiAgICogICB0aGUgd2lkdGggYW5kIGhlaWdodCB0byBkZXRlcm1pbmUgdGhlIGZpbmFsIHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge1JlbmRlcmVyfSAtIFRoaXMgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBpbml0aWFsaXplKGVsLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKSB7XG4gICAgdGhpcy5fZWwgPSBlbDtcbiAgICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBjb250YWluZXIgZWxlbWVudCBmb3IgYSB2aXN1YWxpemF0aW9uLlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSAtIFRoZSBjb250YWluaW5nIERPTSBlbGVtZW50LlxuICAgKi9cbiAgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjZW5lIGVsZW1lbnQgKGUuZy4sIGNhbnZhcyBvciBTVkcpIG9mIHRoZSB2aXN1YWxpemF0aW9uXG4gICAqIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBpZiB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IHRoZSBzY2VuZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSAtIFRoZSBzY2VuZSAoZS5nLiwgY2FudmFzIG9yIFNWRykgZWxlbWVudC5cbiAgICovXG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZWwgJiYgdGhpcy5fZWwuZmlyc3RDaGlsZDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IC8gc2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgYmFja2dyb3VuZChiZ2NvbG9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9iZ2NvbG9yO1xuICAgIHRoaXMuX2JnY29sb3IgPSBiZ2NvbG9yO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgY29vcmRpbmF0ZSB3aWR0aCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBjb29yZGluYXRlIGhlaWdodCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9yaWdpbiAtIFRoZSBuZXcgb3JpZ2luIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqICAgVGhlIGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlRmFjdG9yPTFdIC0gT3B0aW9uYWwgc2NhbGVGYWN0b3IgYnkgd2hpY2ggdG8gbXVsdGlwbHlcbiAgICogICB0aGUgd2lkdGggYW5kIGhlaWdodCB0byBkZXRlcm1pbmUgdGhlIGZpbmFsIHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge1JlbmRlcmVyfSAtIFRoaXMgcmVuZGVyZXIgaW5zdGFuY2U7XG4gICAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcikge1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29yaWdpbiA9IG9yaWdpbiB8fCBbMCwgMF07XG4gICAgdGhpcy5fc2NhbGUgPSBzY2FsZUZhY3RvciB8fCAxO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBvcnQgYSBkaXJ0eSBpdGVtIHdob3NlIGJvdW5kcyBzaG91bGQgYmUgcmVkcmF3bi5cbiAgICogVGhpcyBiYXNlIGNsYXNzIG1ldGhvZCBkb2VzIG5vdGhpbmcuIFN1YmNsYXNzZXMgdGhhdCBwZXJmb3JtXG4gICAqIGluY3JlbWVudGFsIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBkaXJ0eSBpdGVtIHdob3NlIGJvdW5kcyBzaG91bGQgYmUgcmVkcmF3bi5cbiAgICovXG4gIGRpcnR5KClcbiAgLyppdGVtKi9cbiAge30sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhbiBpbnB1dCBzY2VuZWdyYXBoLCBwb3RlbnRpYWxseSB3aXRoIGEgc2V0IG9mIGRpcnR5IGl0ZW1zLlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHBlcmZvcm0gYW4gaW1tZWRpYXRlIHJlbmRlcmluZyB3aXRoIGF2YWlsYWJsZSByZXNvdXJjZXMuXG4gICAqIFRoZSByZW5kZXJlciBtYXkgYWxzbyBuZWVkIHRvIHBlcmZvcm0gaW1hZ2UgbG9hZGluZyB0byBwZXJmb3JtIGEgY29tcGxldGVcbiAgICogcmVuZGVyLiBUaGlzIHByb2Nlc3MgY2FuIGxlYWQgdG8gYXN5bmNocm9ub3VzIHJlLXJlbmRlcmluZyBvZiB0aGUgc2NlbmVcbiAgICogYWZ0ZXIgdGhpcyBtZXRob2QgcmV0dXJucy4gVG8gcmVjZWl2ZSBub3RpZmljYXRpb24gd2hlbiByZW5kZXJpbmcgaXNcbiAgICogY29tcGxldGUsIHVzZSB0aGUgcmVuZGVyQXN5bmMgbWV0aG9kIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSByb290IG1hcmsgb2YgYSBzY2VuZWdyYXBoIHRvIHJlbmRlci5cbiAgICogQHJldHVybiB7UmVuZGVyZXJ9IC0gVGhpcyByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHJlbmRlcihzY2VuZSkge1xuICAgIGNvbnN0IHIgPSB0aGlzOyAvLyBiaW5kIGFyZ3VtZW50cyBpbnRvIGEgcmVuZGVyIGNhbGwsIGFuZCBjYWNoZSBpdFxuICAgIC8vIHRoaXMgZnVuY3Rpb24gbWF5IGJlIHN1YnNlcXVlbnRseSBjYWxsZWQgZm9yIGFzeW5jIHJlZHJhd1xuXG4gICAgci5fY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHIuX3JlbmRlcihzY2VuZSk7XG4gICAgfTsgLy8gaW52b2tlIHRoZSByZW5kZXJlclxuXG5cbiAgICByLl9jYWxsKCk7IC8vIGNsZWFyIHRoZSBjYWNoZWQgY2FsbCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgLy8gYXN5bmMgcmVkcmF3cyB3aWxsIHN0YXNoIHRoZWlyIG93biBjb3B5XG5cblxuICAgIHIuX2NhbGwgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCByZW5kZXJpbmcgbWV0aG9kLiBSZW5kZXJlciBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzXG4gICAqIG1ldGhvZCB0byBhY3R1YWxseSBwZXJmb3JtIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIHJvb3QgbWFyayBvZiBhIHNjZW5lZ3JhcGggdG8gcmVuZGVyLlxuICAgKi9cbiAgX3JlbmRlcigpXG4gIC8qc2NlbmUqL1xuICB7Ly8gc3ViY2xhc3NlcyB0byBvdmVycmlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXMgcmVuZGVyaW5nIG1ldGhvZC4gU2ltaWxhciB0byByZW5kZXIsIGJ1dCByZXR1cm5zIGEgUHJvbWlzZVxuICAgKiB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHJlbmRlcmluZyBpcyBjb21wbGV0ZWQuIFNvbWV0aW1lcyBhIHJlbmRlcmVyIG11c3RcbiAgICogcGVyZm9ybSBpbWFnZSBsb2FkaW5nIHRvIGdldCBhIGNvbXBsZXRlIHJlbmRlcmluZy4gVGhlIHJldHVybmVkXG4gICAqIFByb21pc2Ugd2lsbCBub3QgcmVzb2x2ZSB1bnRpbCB0aGlzIHByb2Nlc3MgY29tcGxldGVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgcm9vdCBtYXJrIG9mIGEgc2NlbmVncmFwaCB0byByZW5kZXIuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiByZW5kZXJpbmcgaXMgY29tcGxldGUuXG4gICAqL1xuICByZW5kZXJBc3luYyhzY2VuZSkge1xuICAgIGNvbnN0IHIgPSB0aGlzLnJlbmRlcihzY2VuZSk7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5ID8gdGhpcy5fcmVhZHkudGhlbigoKSA9PiByKSA6IFByb21pc2UucmVzb2x2ZShyKTtcbiAgfSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgbWV0aG9kIGZvciBhc3luY2hyb25vdXMgcmVzb3VyY2UgbG9hZGluZy5cbiAgICogUHJveGllcyBtZXRob2QgY2FsbHMgdG8gdGhlIEltYWdlTG9hZGVyLCBhbmQgdHJhY2tzIGxvYWRpbmdcbiAgICogcHJvZ3Jlc3MgdG8gaW52b2tlIGEgcmUtcmVuZGVyIG9uY2UgY29tcGxldGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgLSBUaGUgbWV0aG9kIG5hbWUgdG8gaW52b2tlIG9uIHRoZSBJbWFnZUxvYWRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVyaSAtIFRoZSBVUkkgZm9yIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlcXVlc3RlZCByZXNvdXJjZS5cbiAgICovXG4gIF9sb2FkKG1ldGhvZCwgdXJpKSB7XG4gICAgdmFyIHIgPSB0aGlzLFxuICAgICAgICBwID0gci5fbG9hZGVyW21ldGhvZF0odXJpKTtcblxuICAgIGlmICghci5fcmVhZHkpIHtcbiAgICAgIC8vIHJlLXJlbmRlciB0aGUgc2NlbmUgd2hlbiBsb2FkaW5nIGNvbXBsZXRlc1xuICAgICAgY29uc3QgY2FsbCA9IHIuX2NhbGw7XG4gICAgICByLl9yZWFkeSA9IHIuX2xvYWRlci5yZWFkeSgpLnRoZW4ocmVkcmF3ID0+IHtcbiAgICAgICAgaWYgKHJlZHJhdykgY2FsbCgpO1xuICAgICAgICByLl9yZWFkeSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICAvKipcbiAgICogU2FuaXRpemUgYSBVUkwgdG8gaW5jbHVkZSBhcyBhIGh5cGVybGluayBpbiB0aGUgcmVuZGVyZWQgc2NlbmUuXG4gICAqIFRoaXMgbWV0aG9kIHByb3hpZXMgYSBjYWxsIHRvIEltYWdlTG9hZGVyLnNhbml0aXplVVJMLCBidXQgYWxzbyB0cmFja3NcbiAgICogaW1hZ2UgbG9hZGluZyBwcm9ncmVzcyBhbmQgaW52b2tlcyBhIHJlLXJlbmRlciBvbmNlIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpIC0gVGhlIFVSSSBzdHJpbmcgdG8gc2FuaXRpemUuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNhbml0aXplZCBVUkwuXG4gICAqL1xuICBzYW5pdGl6ZVVSTCh1cmkpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCgnc2FuaXRpemVVUkwnLCB1cmkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbiBpbWFnZSB0byBpbmNsdWRlIGluIHRoZSByZW5kZXJlZCBzY2VuZS5cbiAgICogVGhpcyBtZXRob2QgcHJveGllcyBhIGNhbGwgdG8gSW1hZ2VMb2FkZXIubG9hZEltYWdlLCBidXQgYWxzbyB0cmFja3NcbiAgICogaW1hZ2UgbG9hZGluZyBwcm9ncmVzcyBhbmQgaW52b2tlcyBhIHJlLXJlbmRlciBvbmNlIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpIC0gVGhlIFVSSSBzdHJpbmcgb2YgdGhlIGltYWdlLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsb2FkZWQgSW1hZ2UuXG4gICAqL1xuICBsb2FkSW1hZ2UodXJpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQoJ2xvYWRJbWFnZScsIHVyaSk7XG4gIH1cblxufTtcblxuY29uc3QgS2V5RG93bkV2ZW50ID0gJ2tleWRvd24nO1xuY29uc3QgS2V5UHJlc3NFdmVudCA9ICdrZXlwcmVzcyc7XG5jb25zdCBLZXlVcEV2ZW50ID0gJ2tleXVwJztcbmNvbnN0IERyYWdFbnRlckV2ZW50ID0gJ2RyYWdlbnRlcic7XG5jb25zdCBEcmFnTGVhdmVFdmVudCA9ICdkcmFnbGVhdmUnO1xuY29uc3QgRHJhZ092ZXJFdmVudCA9ICdkcmFnb3Zlcic7XG5jb25zdCBNb3VzZURvd25FdmVudCA9ICdtb3VzZWRvd24nO1xuY29uc3QgTW91c2VVcEV2ZW50ID0gJ21vdXNldXAnO1xuY29uc3QgTW91c2VNb3ZlRXZlbnQgPSAnbW91c2Vtb3ZlJztcbmNvbnN0IE1vdXNlT3V0RXZlbnQgPSAnbW91c2VvdXQnO1xuY29uc3QgTW91c2VPdmVyRXZlbnQgPSAnbW91c2VvdmVyJztcbmNvbnN0IENsaWNrRXZlbnQgPSAnY2xpY2snO1xuY29uc3QgRG91YmxlQ2xpY2tFdmVudCA9ICdkYmxjbGljayc7XG5jb25zdCBXaGVlbEV2ZW50ID0gJ3doZWVsJztcbmNvbnN0IE1vdXNlV2hlZWxFdmVudCA9ICdtb3VzZXdoZWVsJztcbmNvbnN0IFRvdWNoU3RhcnRFdmVudCA9ICd0b3VjaHN0YXJ0JztcbmNvbnN0IFRvdWNoTW92ZUV2ZW50ID0gJ3RvdWNobW92ZSc7XG5jb25zdCBUb3VjaEVuZEV2ZW50ID0gJ3RvdWNoZW5kJztcbmNvbnN0IEV2ZW50cyA9IFtLZXlEb3duRXZlbnQsIEtleVByZXNzRXZlbnQsIEtleVVwRXZlbnQsIERyYWdFbnRlckV2ZW50LCBEcmFnTGVhdmVFdmVudCwgRHJhZ092ZXJFdmVudCwgTW91c2VEb3duRXZlbnQsIE1vdXNlVXBFdmVudCwgTW91c2VNb3ZlRXZlbnQsIE1vdXNlT3V0RXZlbnQsIE1vdXNlT3ZlckV2ZW50LCBDbGlja0V2ZW50LCBEb3VibGVDbGlja0V2ZW50LCBXaGVlbEV2ZW50LCBNb3VzZVdoZWVsRXZlbnQsIFRvdWNoU3RhcnRFdmVudCwgVG91Y2hNb3ZlRXZlbnQsIFRvdWNoRW5kRXZlbnRdO1xuY29uc3QgVG9vbHRpcFNob3dFdmVudCA9IE1vdXNlTW92ZUV2ZW50O1xuY29uc3QgVG9vbHRpcEhpZGVFdmVudCA9IE1vdXNlT3V0RXZlbnQ7XG5jb25zdCBIcmVmRXZlbnQgPSBDbGlja0V2ZW50O1xuXG5mdW5jdGlvbiBDYW52YXNIYW5kbGVyKGxvYWRlciwgdG9vbHRpcCkge1xuICBIYW5kbGVyLmNhbGwodGhpcywgbG9hZGVyLCB0b29sdGlwKTtcbiAgdGhpcy5fZG93biA9IG51bGw7XG4gIHRoaXMuX3RvdWNoID0gbnVsbDtcbiAgdGhpcy5fZmlyc3QgPSB0cnVlO1xuICB0aGlzLl9ldmVudHMgPSB7fTtcbn1cblxuY29uc3QgZXZlbnRCdW5kbGUgPSB0eXBlID0+IHR5cGUgPT09IFRvdWNoU3RhcnRFdmVudCB8fCB0eXBlID09PSBUb3VjaE1vdmVFdmVudCB8fCB0eXBlID09PSBUb3VjaEVuZEV2ZW50ID8gW1RvdWNoU3RhcnRFdmVudCwgVG91Y2hNb3ZlRXZlbnQsIFRvdWNoRW5kRXZlbnRdIDogW3R5cGVdOyAvLyBsYXppbHkgYWRkIGxpc3RlbmVycyB0byB0aGUgY2FudmFzIGFzIG5lZWRlZFxuXG5cbmZ1bmN0aW9uIGV2ZW50TGlzdGVuZXJDaGVjayhoYW5kbGVyLCB0eXBlKSB7XG4gIGV2ZW50QnVuZGxlKHR5cGUpLmZvckVhY2goXyA9PiBhZGRFdmVudExpc3RlbmVyKGhhbmRsZXIsIF8pKTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihoYW5kbGVyLCB0eXBlKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGhhbmRsZXIuY2FudmFzKCk7XG5cbiAgaWYgKGNhbnZhcyAmJiAhaGFuZGxlci5fZXZlbnRzW3R5cGVdKSB7XG4gICAgaGFuZGxlci5fZXZlbnRzW3R5cGVdID0gMTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyW3R5cGVdID8gZXZ0ID0+IGhhbmRsZXJbdHlwZV0oZXZ0KSA6IGV2dCA9PiBoYW5kbGVyLmZpcmUodHlwZSwgZXZ0KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW92ZShtb3ZlRXZlbnQsIG92ZXJFdmVudCwgb3V0RXZlbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldnQpIHtcbiAgICBjb25zdCBhID0gdGhpcy5fYWN0aXZlLFxuICAgICAgICAgIHAgPSB0aGlzLnBpY2tFdmVudChldnQpO1xuXG4gICAgaWYgKHAgPT09IGEpIHtcbiAgICAgIC8vIGFjdGl2ZSBpdGVtIGFuZCBwaWNrZWQgaXRlbSBhcmUgdGhlIHNhbWVcbiAgICAgIHRoaXMuZmlyZShtb3ZlRXZlbnQsIGV2dCk7IC8vIGZpcmUgbW92ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhY3RpdmUgaXRlbSBhbmQgcGlja2VkIGl0ZW0gYXJlIGRpZmZlcmVudFxuICAgICAgaWYgKCFhIHx8ICFhLmV4aXQpIHtcbiAgICAgICAgLy8gZmlyZSBvdXQgZm9yIHByaW9yIGFjdGl2ZSBpdGVtXG4gICAgICAgIC8vIHN1cHByZXNzIGlmIGFjdGl2ZSBpdGVtIHdhcyByZW1vdmVkIGZyb20gc2NlbmVcbiAgICAgICAgdGhpcy5maXJlKG91dEV2ZW50LCBldnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hY3RpdmUgPSBwOyAvLyBzZXQgbmV3IGFjdGl2ZSBpdGVtXG5cbiAgICAgIHRoaXMuZmlyZShvdmVyRXZlbnQsIGV2dCk7IC8vIGZpcmUgb3ZlciBmb3IgbmV3IGFjdGl2ZSBpdGVtXG5cbiAgICAgIHRoaXMuZmlyZShtb3ZlRXZlbnQsIGV2dCk7IC8vIGZpcmUgbW92ZSBmb3IgbmV3IGFjdGl2ZSBpdGVtXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbmFjdGl2ZSh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdGhpcy5maXJlKHR5cGUsIGV2dCk7XG4gICAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgfTtcbn1cblxuaW5oZXJpdHMoQ2FudmFzSGFuZGxlciwgSGFuZGxlciwge1xuICBpbml0aWFsaXplKGVsLCBvcmlnaW4sIG9iaikge1xuICAgIHRoaXMuX2NhbnZhcyA9IGVsICYmIGRvbUZpbmQoZWwsICdjYW52YXMnKTsgLy8gYWRkIG1pbmltYWwgZXZlbnRzIHJlcXVpcmVkIGZvciBwcm9wZXIgc3RhdGUgbWFuYWdlbWVudFxuXG4gICAgW0NsaWNrRXZlbnQsIE1vdXNlRG93bkV2ZW50LCBNb3VzZU1vdmVFdmVudCwgTW91c2VPdXRFdmVudCwgRHJhZ0xlYXZlRXZlbnRdLmZvckVhY2godHlwZSA9PiBldmVudExpc3RlbmVyQ2hlY2sodGhpcywgdHlwZSkpO1xuICAgIHJldHVybiBIYW5kbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIG9yaWdpbiwgb2JqKTtcbiAgfSxcblxuICAvLyByZXR1cm4gdGhlIGJhY2tpbmcgY2FudmFzIGluc3RhbmNlXG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICB9LFxuXG4gIC8vIHJldHJpZXZlIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZXh0XG4gIGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB9LFxuXG4gIC8vIHN1cHBvcnRlZCBldmVudHNcbiAgZXZlbnRzOiBFdmVudHMsXG5cbiAgLy8gdG8ga2VlcCBvbGQgdmVyc2lvbnMgb2YgZmlyZWZveCBoYXBweVxuICBET01Nb3VzZVNjcm9sbChldnQpIHtcbiAgICB0aGlzLmZpcmUoTW91c2VXaGVlbEV2ZW50LCBldnQpO1xuICB9LFxuXG4gIG1vdXNlbW92ZTogbW92ZShNb3VzZU1vdmVFdmVudCwgTW91c2VPdmVyRXZlbnQsIE1vdXNlT3V0RXZlbnQpLFxuICBkcmFnb3ZlcjogbW92ZShEcmFnT3ZlckV2ZW50LCBEcmFnRW50ZXJFdmVudCwgRHJhZ0xlYXZlRXZlbnQpLFxuICBtb3VzZW91dDogaW5hY3RpdmUoTW91c2VPdXRFdmVudCksXG4gIGRyYWdsZWF2ZTogaW5hY3RpdmUoRHJhZ0xlYXZlRXZlbnQpLFxuXG4gIG1vdXNlZG93bihldnQpIHtcbiAgICB0aGlzLl9kb3duID0gdGhpcy5fYWN0aXZlO1xuICAgIHRoaXMuZmlyZShNb3VzZURvd25FdmVudCwgZXZ0KTtcbiAgfSxcblxuICBjbGljayhldnQpIHtcbiAgICBpZiAodGhpcy5fZG93biA9PT0gdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLmZpcmUoQ2xpY2tFdmVudCwgZXZ0KTtcbiAgICAgIHRoaXMuX2Rvd24gPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICB0b3VjaHN0YXJ0KGV2dCkge1xuICAgIHRoaXMuX3RvdWNoID0gdGhpcy5waWNrRXZlbnQoZXZ0LmNoYW5nZWRUb3VjaGVzWzBdKTtcblxuICAgIGlmICh0aGlzLl9maXJzdCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5fdG91Y2g7XG4gICAgICB0aGlzLl9maXJzdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZmlyZShUb3VjaFN0YXJ0RXZlbnQsIGV2dCwgdHJ1ZSk7XG4gIH0sXG5cbiAgdG91Y2htb3ZlKGV2dCkge1xuICAgIHRoaXMuZmlyZShUb3VjaE1vdmVFdmVudCwgZXZ0LCB0cnVlKTtcbiAgfSxcblxuICB0b3VjaGVuZChldnQpIHtcbiAgICB0aGlzLmZpcmUoVG91Y2hFbmRFdmVudCwgZXZ0LCB0cnVlKTtcbiAgICB0aGlzLl90b3VjaCA9IG51bGw7XG4gIH0sXG5cbiAgLy8gZmlyZSBhbiBldmVudFxuICBmaXJlKHR5cGUsIGV2dCwgdG91Y2gpIHtcbiAgICBjb25zdCBhID0gdG91Y2ggPyB0aGlzLl90b3VjaCA6IHRoaXMuX2FjdGl2ZSxcbiAgICAgICAgICBoID0gdGhpcy5faGFuZGxlcnNbdHlwZV07IC8vIHNldCBldmVudCB0eXBlIHJlbGF0aXZlIHRvIHNjZW5lZ3JhcGggaXRlbXNcblxuICAgIGV2dC52ZWdhVHlwZSA9IHR5cGU7IC8vIGhhbmRsZSBoeXBlcmxpbmtzIGFuZCB0b29sdGlwcyBmaXJzdFxuXG4gICAgaWYgKHR5cGUgPT09IEhyZWZFdmVudCAmJiBhICYmIGEuaHJlZikge1xuICAgICAgdGhpcy5oYW5kbGVIcmVmKGV2dCwgYSwgYS5ocmVmKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvb2x0aXBTaG93RXZlbnQgfHwgdHlwZSA9PT0gVG9vbHRpcEhpZGVFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVUb29sdGlwKGV2dCwgYSwgdHlwZSAhPT0gVG9vbHRpcEhpZGVFdmVudCk7XG4gICAgfSAvLyBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgaGFuZGxlcnNcblxuXG4gICAgaWYgKGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGhbaV0uaGFuZGxlci5jYWxsKHRoaXMuX29iaiwgZXZ0LCBhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gYWRkIGFuIGV2ZW50IGhhbmRsZXJcbiAgb24odHlwZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmV2ZW50TmFtZSh0eXBlKSxcbiAgICAgICAgICBoID0gdGhpcy5faGFuZGxlcnMsXG4gICAgICAgICAgaSA9IHRoaXMuX2hhbmRsZXJJbmRleChoW25hbWVdLCB0eXBlLCBoYW5kbGVyKTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgZXZlbnRMaXN0ZW5lckNoZWNrKHRoaXMsIHR5cGUpO1xuICAgICAgKGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSkpLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyByZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxuICBvZmYodHlwZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmV2ZW50TmFtZSh0eXBlKSxcbiAgICAgICAgICBoID0gdGhpcy5faGFuZGxlcnNbbmFtZV0sXG4gICAgICAgICAgaSA9IHRoaXMuX2hhbmRsZXJJbmRleChoLCB0eXBlLCBoYW5kbGVyKTtcblxuICAgIGlmIChpID49IDApIHtcbiAgICAgIGguc3BsaWNlKGksIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHBpY2tFdmVudChldnQpIHtcbiAgICBjb25zdCBwID0gcG9pbnQoZXZ0LCB0aGlzLl9jYW52YXMpLFxuICAgICAgICAgIG8gPSB0aGlzLl9vcmlnaW47XG4gICAgcmV0dXJuIHRoaXMucGljayh0aGlzLl9zY2VuZSwgcFswXSwgcFsxXSwgcFswXSAtIG9bMF0sIHBbMV0gLSBvWzFdKTtcbiAgfSxcblxuICAvLyBmaW5kIHRoZSBzY2VuZWdyYXBoIGl0ZW0gYXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbiAgLy8geCwgeSAtLSB0aGUgYWJzb2x1dGUgeCwgeSBtb3VzZSBjb29yZGluYXRlcyBvbiB0aGUgY2FudmFzIGVsZW1lbnRcbiAgLy8gZ3gsIGd5IC0tIHRoZSByZWxhdGl2ZSBjb29yZGluYXRlcyB3aXRoaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgcGljayhzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gICAgY29uc3QgZyA9IHRoaXMuY29udGV4dCgpLFxuICAgICAgICAgIG1hcmsgPSBNYXJrc1tzY2VuZS5tYXJrdHlwZV07XG4gICAgcmV0dXJuIG1hcmsucGljay5jYWxsKHRoaXMsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBkZXZpY2VQaXhlbFJhdGlvKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxIDogMTtcbn1cblxudmFyIHBpeGVsUmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvKCk7XG5mdW5jdGlvbiByZXNpemUgKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvciwgb3B0KSB7XG4gIGNvbnN0IGluRE9NID0gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBjYW52YXMucGFyZW50Tm9kZSAhPSBudWxsLFxuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgIHJhdGlvID0gaW5ET00gPyBwaXhlbFJhdGlvIDogc2NhbGVGYWN0b3I7XG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoICogcmF0aW87XG4gIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiByYXRpbztcblxuICBmb3IgKGNvbnN0IGtleSBpbiBvcHQpIHtcbiAgICBjb250ZXh0W2tleV0gPSBvcHRba2V5XTtcbiAgfVxuXG4gIGlmIChpbkRPTSAmJiByYXRpbyAhPT0gMSkge1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgfVxuXG4gIGNvbnRleHQucGl4ZWxSYXRpbyA9IHJhdGlvO1xuICBjb250ZXh0LnNldFRyYW5zZm9ybShyYXRpbywgMCwgMCwgcmF0aW8sIHJhdGlvICogb3JpZ2luWzBdLCByYXRpbyAqIG9yaWdpblsxXSk7XG4gIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGxvYWRlcikge1xuICBSZW5kZXJlci5jYWxsKHRoaXMsIGxvYWRlcik7XG4gIHRoaXMuX29wdGlvbnMgPSB7fTtcbiAgdGhpcy5fcmVkcmF3ID0gZmFsc2U7XG4gIHRoaXMuX2RpcnR5ID0gbmV3IEJvdW5kcygpO1xuICB0aGlzLl90ZW1wYiA9IG5ldyBCb3VuZHMoKTtcbn1cbmNvbnN0IGJhc2UkMSA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuY29uc3Qgdmlld0JvdW5kcyA9IChvcmlnaW4sIHdpZHRoLCBoZWlnaHQpID0+IG5ldyBCb3VuZHMoKS5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCkudHJhbnNsYXRlKC1vcmlnaW5bMF0sIC1vcmlnaW5bMV0pO1xuXG5mdW5jdGlvbiBjbGlwVG9Cb3VuZHMoZywgYiwgb3JpZ2luKSB7XG4gIC8vIGV4cGFuZCBib3VuZHMgYnkgMSBwaXhlbCwgdGhlbiByb3VuZCB0byBwaXhlbCBib3VuZGFyaWVzXG4gIGIuZXhwYW5kKDEpLnJvdW5kKCk7IC8vIGFsaWduIHRvIGJhc2UgcGl4ZWwgZ3JpZCBpbiBjYXNlIG9mIG5vbi1pbnRlZ2VyIHNjYWxpbmcgKCMyNDI1KVxuXG4gIGlmIChnLnBpeGVsUmF0aW8gJSAxKSB7XG4gICAgYi5zY2FsZShnLnBpeGVsUmF0aW8pLnJvdW5kKCkuc2NhbGUoMSAvIGcucGl4ZWxSYXRpbyk7XG4gIH0gLy8gdG8gYXZvaWQgYXJ0aWZhY3RzIHRyYW5zbGF0ZSBpZiBvcmlnaW4gaGFzIGZyYWN0aW9uYWwgcGl4ZWxzXG5cblxuICBiLnRyYW5zbGF0ZSgtKG9yaWdpblswXSAlIDEpLCAtKG9yaWdpblsxXSAlIDEpKTsgLy8gc2V0IGNsaXAgcGF0aFxuXG4gIGcuYmVnaW5QYXRoKCk7XG4gIGcucmVjdChiLngxLCBiLnkxLCBiLndpZHRoKCksIGIuaGVpZ2h0KCkpO1xuICBnLmNsaXAoKTtcbiAgcmV0dXJuIGI7XG59XG5cbmluaGVyaXRzKENhbnZhc1JlbmRlcmVyLCBSZW5kZXJlciwge1xuICBpbml0aWFsaXplKGVsLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fY2FudmFzID0gdGhpcy5fb3B0aW9ucy5leHRlcm5hbENvbnRleHQgPyBudWxsIDogY2FudmFzKDEsIDEsIHRoaXMuX29wdGlvbnMudHlwZSk7IC8vIGluc3RhbnRpYXRlIGEgc21hbGwgY2FudmFzXG5cbiAgICBpZiAoZWwgJiYgdGhpcy5fY2FudmFzKSB7XG4gICAgICBkb21DbGVhcihlbCwgMCkuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKTtcblxuICAgICAgdGhpcy5fY2FudmFzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbWFya3MnKTtcbiAgICB9IC8vIHRoaXMgbWV0aG9kIHdpbGwgaW52b2tlIHJlc2l6ZSB0byBzaXplIHRoZSBjYW52YXMgYXBwcm9wcmlhdGVseVxuXG5cbiAgICByZXR1cm4gYmFzZSQxLmluaXRpYWxpemUuY2FsbCh0aGlzLCBlbCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcik7XG4gIH0sXG5cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpIHtcbiAgICBiYXNlJDEucmVzaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcik7XG5cbiAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICAvLyBjb25maWd1cmUgY2FudmFzIHNpemUgYW5kIHRyYW5zZm9ybVxuICAgICAgcmVzaXplKHRoaXMuX2NhbnZhcywgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgdGhpcy5fb3JpZ2luLCB0aGlzLl9zY2FsZSwgdGhpcy5fb3B0aW9ucy5jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXh0ZXJuYWwgY29udGV4dCBuZWVkcyB0byBiZSBzY2FsZWQgYW5kIHBvc2l0aW9uZWQgdG8gb3JpZ2luXG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9vcHRpb25zLmV4dGVybmFsQ29udGV4dDtcbiAgICAgIGlmICghY3R4KSBlcnJvcignQ2FudmFzUmVuZGVyZXIgaXMgbWlzc2luZyBhIHZhbGlkIGNhbnZhcyBvciBjb250ZXh0Jyk7XG4gICAgICBjdHguc2NhbGUodGhpcy5fc2NhbGUsIHRoaXMuX3NjYWxlKTtcbiAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5fb3JpZ2luWzBdLCB0aGlzLl9vcmlnaW5bMV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3JlZHJhdyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gIH0sXG5cbiAgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5leHRlcm5hbENvbnRleHQgfHwgKHRoaXMuX2NhbnZhcyA/IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpIDogbnVsbCk7XG4gIH0sXG5cbiAgZGlydHkoaXRlbSkge1xuICAgIGNvbnN0IGIgPSB0aGlzLl90ZW1wYi5jbGVhcigpLnVuaW9uKGl0ZW0uYm91bmRzKTtcblxuICAgIGxldCBnID0gaXRlbS5tYXJrLmdyb3VwO1xuXG4gICAgd2hpbGUgKGcpIHtcbiAgICAgIGIudHJhbnNsYXRlKGcueCB8fCAwLCBnLnkgfHwgMCk7XG4gICAgICBnID0gZy5tYXJrLmdyb3VwO1xuICAgIH1cblxuICAgIHRoaXMuX2RpcnR5LnVuaW9uKGIpO1xuICB9LFxuXG4gIF9yZW5kZXIoc2NlbmUpIHtcbiAgICBjb25zdCBnID0gdGhpcy5jb250ZXh0KCksXG4gICAgICAgICAgbyA9IHRoaXMuX29yaWdpbixcbiAgICAgICAgICB3ID0gdGhpcy5fd2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuX2hlaWdodCxcbiAgICAgICAgICBkYiA9IHRoaXMuX2RpcnR5LFxuICAgICAgICAgIHZiID0gdmlld0JvdW5kcyhvLCB3LCBoKTsgLy8gc2V0dXBcblxuICAgIGcuc2F2ZSgpO1xuICAgIGNvbnN0IGIgPSB0aGlzLl9yZWRyYXcgfHwgZGIuZW1wdHkoKSA/ICh0aGlzLl9yZWRyYXcgPSBmYWxzZSwgdmIuZXhwYW5kKDEpKSA6IGNsaXBUb0JvdW5kcyhnLCB2Yi5pbnRlcnNlY3QoZGIpLCBvKTtcbiAgICB0aGlzLmNsZWFyKC1vWzBdLCAtb1sxXSwgdywgaCk7IC8vIHJlbmRlclxuXG4gICAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiKTsgLy8gdGFrZWRvd25cblxuICAgIGcucmVzdG9yZSgpO1xuICAgIGRiLmNsZWFyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZHJhdyhjdHgsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBjb25zdCBtYXJrID0gTWFya3Nbc2NlbmUubWFya3R5cGVdO1xuICAgIGlmIChzY2VuZS5jbGlwKSBjbGlwKGN0eCwgc2NlbmUpO1xuICAgIG1hcmsuZHJhdy5jYWxsKHRoaXMsIGN0eCwgc2NlbmUsIGJvdW5kcyk7XG4gICAgaWYgKHNjZW5lLmNsaXApIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgY2xlYXIoeCwgeSwgdywgaCkge1xuICAgIGNvbnN0IG9wdCA9IHRoaXMuX29wdGlvbnMsXG4gICAgICAgICAgZyA9IHRoaXMuY29udGV4dCgpO1xuXG4gICAgaWYgKG9wdC50eXBlICE9PSAncGRmJyAmJiAhb3B0LmV4dGVybmFsQ29udGV4dCkge1xuICAgICAgLy8gY2FsbGluZyBjbGVhciByZWN0IHZvaWRzIHZlY3RvciBvdXRwdXQgaW4gcGRmIG1vZGVcbiAgICAgIC8vIGFuZCBjb3VsZCByZW1vdmUgZXh0ZXJuYWwgY29udGV4dCBjb250ZW50ICgjMjYxNSlcbiAgICAgIGcuY2xlYXJSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9iZ2NvbG9yICE9IG51bGwpIHtcbiAgICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fYmdjb2xvcjtcbiAgICAgIGcuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBTVkdIYW5kbGVyKGxvYWRlciwgdG9vbHRpcCkge1xuICBIYW5kbGVyLmNhbGwodGhpcywgbG9hZGVyLCB0b29sdGlwKTtcbiAgY29uc3QgaCA9IHRoaXM7XG4gIGguX2hyZWZIYW5kbGVyID0gbGlzdGVuZXIoaCwgKGV2dCwgaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtICYmIGl0ZW0uaHJlZikgaC5oYW5kbGVIcmVmKGV2dCwgaXRlbSwgaXRlbS5ocmVmKTtcbiAgfSk7XG4gIGguX3Rvb2x0aXBIYW5kbGVyID0gbGlzdGVuZXIoaCwgKGV2dCwgaXRlbSkgPT4ge1xuICAgIGguaGFuZGxlVG9vbHRpcChldnQsIGl0ZW0sIGV2dC50eXBlICE9PSBUb29sdGlwSGlkZUV2ZW50KTtcbiAgfSk7XG59IC8vIHdyYXAgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBTVkcgRE9NXG5cbmNvbnN0IGxpc3RlbmVyID0gKGNvbnRleHQsIGhhbmRsZXIpID0+IGV2dCA9PiB7XG4gIGxldCBpdGVtID0gZXZ0LnRhcmdldC5fX2RhdGFfXztcbiAgaXRlbSA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtWzBdIDogaXRlbTtcbiAgZXZ0LnZlZ2FUeXBlID0gZXZ0LnR5cGU7XG4gIGhhbmRsZXIuY2FsbChjb250ZXh0Ll9vYmosIGV2dCwgaXRlbSk7XG59O1xuXG5pbmhlcml0cyhTVkdIYW5kbGVyLCBIYW5kbGVyLCB7XG4gIGluaXRpYWxpemUoZWwsIG9yaWdpbiwgb2JqKSB7XG4gICAgbGV0IHN2ZyA9IHRoaXMuX3N2ZztcblxuICAgIGlmIChzdmcpIHtcbiAgICAgIHN2Zy5yZW1vdmVFdmVudExpc3RlbmVyKEhyZWZFdmVudCwgdGhpcy5faHJlZkhhbmRsZXIpO1xuICAgICAgc3ZnLnJlbW92ZUV2ZW50TGlzdGVuZXIoVG9vbHRpcFNob3dFdmVudCwgdGhpcy5fdG9vbHRpcEhhbmRsZXIpO1xuICAgICAgc3ZnLnJlbW92ZUV2ZW50TGlzdGVuZXIoVG9vbHRpcEhpZGVFdmVudCwgdGhpcy5fdG9vbHRpcEhhbmRsZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX3N2ZyA9IHN2ZyA9IGVsICYmIGRvbUZpbmQoZWwsICdzdmcnKTtcblxuICAgIGlmIChzdmcpIHtcbiAgICAgIHN2Zy5hZGRFdmVudExpc3RlbmVyKEhyZWZFdmVudCwgdGhpcy5faHJlZkhhbmRsZXIpO1xuICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoVG9vbHRpcFNob3dFdmVudCwgdGhpcy5fdG9vbHRpcEhhbmRsZXIpO1xuICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoVG9vbHRpcEhpZGVFdmVudCwgdGhpcy5fdG9vbHRpcEhhbmRsZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBIYW5kbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIG9yaWdpbiwgb2JqKTtcbiAgfSxcblxuICBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N2ZztcbiAgfSxcblxuICAvLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxuICBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuZXZlbnROYW1lKHR5cGUpLFxuICAgICAgICAgIGggPSB0aGlzLl9oYW5kbGVycyxcbiAgICAgICAgICBpID0gdGhpcy5faGFuZGxlckluZGV4KGhbbmFtZV0sIHR5cGUsIGhhbmRsZXIpO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBjb25zdCB4ID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBoYW5kbGVyLFxuICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIodGhpcywgaGFuZGxlcilcbiAgICAgIH07XG4gICAgICAoaFtuYW1lXSB8fCAoaFtuYW1lXSA9IFtdKSkucHVzaCh4KTtcblxuICAgICAgaWYgKHRoaXMuX3N2Zykge1xuICAgICAgICB0aGlzLl9zdmcuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCB4Lmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyByZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxuICBvZmYodHlwZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmV2ZW50TmFtZSh0eXBlKSxcbiAgICAgICAgICBoID0gdGhpcy5faGFuZGxlcnNbbmFtZV0sXG4gICAgICAgICAgaSA9IHRoaXMuX2hhbmRsZXJJbmRleChoLCB0eXBlLCBoYW5kbGVyKTtcblxuICAgIGlmIChpID49IDApIHtcbiAgICAgIGlmICh0aGlzLl9zdmcpIHtcbiAgICAgICAgdGhpcy5fc3ZnLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaFtpXS5saXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGguc3BsaWNlKGksIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuXG5jb25zdCBBUklBX0hJRERFTiA9ICdhcmlhLWhpZGRlbic7XG5jb25zdCBBUklBX0xBQkVMID0gJ2FyaWEtbGFiZWwnO1xuY29uc3QgQVJJQV9ST0xFID0gJ3JvbGUnO1xuY29uc3QgQVJJQV9ST0xFREVTQ1JJUFRJT04gPSAnYXJpYS1yb2xlZGVzY3JpcHRpb24nO1xuY29uc3QgR1JBUEhJQ1NfT0JKRUNUID0gJ2dyYXBoaWNzLW9iamVjdCc7XG5jb25zdCBHUkFQSElDU19TWU1CT0wgPSAnZ3JhcGhpY3Mtc3ltYm9sJztcblxuY29uc3QgYnVuZGxlID0gKHJvbGUsIHJvbGVkZXNjLCBsYWJlbCkgPT4gKHtcbiAgW0FSSUFfUk9MRV06IHJvbGUsXG4gIFtBUklBX1JPTEVERVNDUklQVElPTl06IHJvbGVkZXNjLFxuICBbQVJJQV9MQUJFTF06IGxhYmVsIHx8IHVuZGVmaW5lZFxufSk7IC8vIHRoZXNlIHJvbGVzIGFyZSBjb3ZlcmVkIGJ5IHJlbGF0ZWQgcm9sZXNcbi8vIHdlIGNhbiBpZ25vcmUgdGhlbSwgbm8gbmVlZCB0byBnZW5lcmF0ZSBhdHRyaWJ1dGVzXG5cblxuY29uc3QgQXJpYUlnbm9yZSA9IHRvU2V0KFsnYXhpcy1kb21haW4nLCAnYXhpcy1ncmlkJywgJ2F4aXMtbGFiZWwnLCAnYXhpcy10aWNrJywgJ2F4aXMtdGl0bGUnLCAnbGVnZW5kLWJhbmQnLCAnbGVnZW5kLWVudHJ5JywgJ2xlZ2VuZC1ncmFkaWVudCcsICdsZWdlbmQtbGFiZWwnLCAnbGVnZW5kLXRpdGxlJywgJ2xlZ2VuZC1zeW1ib2wnLCAndGl0bGUnXSk7IC8vIGFyaWEgYXR0cmlidXRlIGdlbmVyYXRvcnMgZm9yIGd1aWRlIHJvbGVzXG5cbmNvbnN0IEFyaWFHdWlkZXMgPSB7XG4gICdheGlzJzoge1xuICAgIGRlc2M6ICdheGlzJyxcbiAgICBjYXB0aW9uOiBheGlzQ2FwdGlvblxuICB9LFxuICAnbGVnZW5kJzoge1xuICAgIGRlc2M6ICdsZWdlbmQnLFxuICAgIGNhcHRpb246IGxlZ2VuZENhcHRpb25cbiAgfSxcbiAgJ3RpdGxlLXRleHQnOiB7XG4gICAgZGVzYzogJ3RpdGxlJyxcbiAgICBjYXB0aW9uOiBpdGVtID0+IGBUaXRsZSB0ZXh0ICcke3RpdGxlQ2FwdGlvbihpdGVtKX0nYFxuICB9LFxuICAndGl0bGUtc3VidGl0bGUnOiB7XG4gICAgZGVzYzogJ3N1YnRpdGxlJyxcbiAgICBjYXB0aW9uOiBpdGVtID0+IGBTdWJ0aXRsZSB0ZXh0ICcke3RpdGxlQ2FwdGlvbihpdGVtKX0nYFxuICB9XG59OyAvLyBhcmlhIHByb3BlcnRpZXMgZ2VuZXJhdGVkIGZvciBtYXJrIGl0ZW0gZW5jb2RpbmcgY2hhbm5lbHNcblxuY29uc3QgQXJpYUVuY29kZSA9IHtcbiAgYXJpYVJvbGU6IEFSSUFfUk9MRSxcbiAgYXJpYVJvbGVEZXNjcmlwdGlvbjogQVJJQV9ST0xFREVTQ1JJUFRJT04sXG4gIGRlc2NyaXB0aW9uOiBBUklBX0xBQkVMXG59O1xuZnVuY3Rpb24gYXJpYUl0ZW1BdHRyaWJ1dGVzKGVtaXQsIGl0ZW0pIHtcbiAgY29uc3QgaGlkZSA9IGl0ZW0uYXJpYSA9PT0gZmFsc2U7XG4gIGVtaXQoQVJJQV9ISURERU4sIGhpZGUgfHwgdW5kZWZpbmVkKTtcblxuICBpZiAoaGlkZSB8fCBpdGVtLmRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gQXJpYUVuY29kZSkge1xuICAgICAgZW1pdChBcmlhRW5jb2RlW3Byb3BdLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0eXBlID0gaXRlbS5tYXJrLm1hcmt0eXBlO1xuICAgIGVtaXQoQVJJQV9MQUJFTCwgaXRlbS5kZXNjcmlwdGlvbik7XG4gICAgZW1pdChBUklBX1JPTEUsIGl0ZW0uYXJpYVJvbGUgfHwgKHR5cGUgPT09ICdncm91cCcgPyBHUkFQSElDU19PQkpFQ1QgOiBHUkFQSElDU19TWU1CT0wpKTtcbiAgICBlbWl0KEFSSUFfUk9MRURFU0NSSVBUSU9OLCBpdGVtLmFyaWFSb2xlRGVzY3JpcHRpb24gfHwgYCR7dHlwZX0gbWFya2ApO1xuICB9XG59XG5mdW5jdGlvbiBhcmlhTWFya0F0dHJpYnV0ZXMobWFyaykge1xuICByZXR1cm4gbWFyay5hcmlhID09PSBmYWxzZSA/IHtcbiAgICBbQVJJQV9ISURERU5dOiB0cnVlXG4gIH0gOiBBcmlhSWdub3JlW21hcmsucm9sZV0gPyBudWxsIDogQXJpYUd1aWRlc1ttYXJrLnJvbGVdID8gYXJpYUd1aWRlKG1hcmssIEFyaWFHdWlkZXNbbWFyay5yb2xlXSkgOiBhcmlhTWFyayhtYXJrKTtcbn1cblxuZnVuY3Rpb24gYXJpYU1hcmsobWFyaykge1xuICBjb25zdCB0eXBlID0gbWFyay5tYXJrdHlwZTtcbiAgY29uc3QgcmVjdXJzZSA9IHR5cGUgPT09ICdncm91cCcgfHwgdHlwZSA9PT0gJ3RleHQnIHx8IG1hcmsuaXRlbXMuc29tZShfID0+IF8uZGVzY3JpcHRpb24gIT0gbnVsbCAmJiBfLmFyaWEgIT09IGZhbHNlKTtcbiAgcmV0dXJuIGJ1bmRsZShyZWN1cnNlID8gR1JBUEhJQ1NfT0JKRUNUIDogR1JBUEhJQ1NfU1lNQk9MLCBgJHt0eXBlfSBtYXJrIGNvbnRhaW5lcmAsIG1hcmsuZGVzY3JpcHRpb24pO1xufVxuXG5mdW5jdGlvbiBhcmlhR3VpZGUobWFyaywgb3B0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgaXRlbSA9IG1hcmsuaXRlbXNbMF0sXG4gICAgICAgICAgY2FwdGlvbiA9IG9wdC5jYXB0aW9uIHx8ICgoKSA9PiAnJyk7XG5cbiAgICByZXR1cm4gYnVuZGxlKG9wdC5yb2xlIHx8IEdSQVBISUNTX1NZTUJPTCwgb3B0LmRlc2MsIGl0ZW0uZGVzY3JpcHRpb24gfHwgY2FwdGlvbihpdGVtKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRpdGxlQ2FwdGlvbihpdGVtKSB7XG4gIHJldHVybiBhcnJheShpdGVtLnRleHQpLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gYXhpc0NhcHRpb24oaXRlbSkge1xuICBjb25zdCBkYXR1bSA9IGl0ZW0uZGF0dW0sXG4gICAgICAgIG9yaWVudCA9IGl0ZW0ub3JpZW50LFxuICAgICAgICB0aXRsZSA9IGRhdHVtLnRpdGxlID8gZXh0cmFjdFRpdGxlKGl0ZW0pIDogbnVsbCxcbiAgICAgICAgY3R4ID0gaXRlbS5jb250ZXh0LFxuICAgICAgICBzY2FsZSA9IGN0eC5zY2FsZXNbZGF0dW0uc2NhbGVdLnZhbHVlLFxuICAgICAgICBsb2NhbGUgPSBjdHguZGF0YWZsb3cubG9jYWxlKCksXG4gICAgICAgIHR5cGUgPSBzY2FsZS50eXBlLFxuICAgICAgICB4eSA9IG9yaWVudCA9PT0gJ2xlZnQnIHx8IG9yaWVudCA9PT0gJ3JpZ2h0JyA/ICdZJyA6ICdYJztcbiAgcmV0dXJuIGAke3h5fS1heGlzYCArICh0aXRsZSA/IGAgdGl0bGVkICcke3RpdGxlfSdgIDogJycpICsgYCBmb3IgYSAke2lzRGlzY3JldGUodHlwZSkgPyAnZGlzY3JldGUnIDogdHlwZX0gc2NhbGVgICsgYCB3aXRoICR7ZG9tYWluQ2FwdGlvbihsb2NhbGUsIHNjYWxlLCBpdGVtKX1gO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRDYXB0aW9uKGl0ZW0pIHtcbiAgY29uc3QgZGF0dW0gPSBpdGVtLmRhdHVtLFxuICAgICAgICB0aXRsZSA9IGRhdHVtLnRpdGxlID8gZXh0cmFjdFRpdGxlKGl0ZW0pIDogbnVsbCxcbiAgICAgICAgdHlwZSA9IGAke2RhdHVtLnR5cGUgfHwgJyd9IGxlZ2VuZGAudHJpbSgpLFxuICAgICAgICBzY2FsZXMgPSBkYXR1bS5zY2FsZXMsXG4gICAgICAgIHByb3BzID0gT2JqZWN0LmtleXMoc2NhbGVzKSxcbiAgICAgICAgY3R4ID0gaXRlbS5jb250ZXh0LFxuICAgICAgICBzY2FsZSA9IGN0eC5zY2FsZXNbc2NhbGVzW3Byb3BzWzBdXV0udmFsdWUsXG4gICAgICAgIGxvY2FsZSA9IGN0eC5kYXRhZmxvdy5sb2NhbGUoKTtcbiAgcmV0dXJuIGNhcGl0YWxpemUodHlwZSkgKyAodGl0bGUgPyBgIHRpdGxlZCAnJHt0aXRsZX0nYCA6ICcnKSArIGAgZm9yICR7Y2hhbm5lbENhcHRpb24ocHJvcHMpfWAgKyBgIHdpdGggJHtkb21haW5DYXB0aW9uKGxvY2FsZSwgc2NhbGUsIGl0ZW0pfWA7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUaXRsZShpdGVtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGFycmF5KHBlZWsoaXRlbS5pdGVtcykuaXRlbXNbMF0udGV4dCkuam9pbignICcpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGFubmVsQ2FwdGlvbihwcm9wcykge1xuICBwcm9wcyA9IHByb3BzLm1hcChwID0+IHAgKyAocCA9PT0gJ2ZpbGwnIHx8IHAgPT09ICdzdHJva2UnID8gJyBjb2xvcicgOiAnJykpO1xuICByZXR1cm4gcHJvcHMubGVuZ3RoIDwgMiA/IHByb3BzWzBdIDogcHJvcHMuc2xpY2UoMCwgLTEpLmpvaW4oJywgJykgKyAnIGFuZCAnICsgcGVlayhwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICByZXR1cm4gcy5sZW5ndGggPyBzWzBdLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpIDogcztcbn1cblxuY29uc3QgaW5uZXJUZXh0ID0gdmFsID0+ICh2YWwgKyAnJykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuXG5jb25zdCBhdHRyVGV4dCA9IHZhbCA9PiBpbm5lclRleHQodmFsKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvXFx0L2csICcmI3g5OycpLnJlcGxhY2UoL1xcbi9nLCAnJiN4QTsnKS5yZXBsYWNlKC9cXHIvZywgJyYjeEQ7Jyk7XG5cbmZ1bmN0aW9uIG1hcmt1cCgpIHtcbiAgbGV0IGJ1ZiA9ICcnLFxuICAgICAgb3V0ZXIgPSAnJyxcbiAgICAgIGlubmVyID0gJyc7XG5cbiAgY29uc3Qgc3RhY2sgPSBbXSxcbiAgICAgICAgY2xlYXIgPSAoKSA9PiBvdXRlciA9IGlubmVyID0gJycsXG4gICAgICAgIHB1c2ggPSB0YWcgPT4ge1xuICAgIGlmIChvdXRlcikge1xuICAgICAgYnVmICs9IGAke291dGVyfT4ke2lubmVyfWA7XG4gICAgICBjbGVhcigpO1xuICAgIH1cblxuICAgIHN0YWNrLnB1c2godGFnKTtcbiAgfSxcbiAgICAgICAgYXR0ciA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSBvdXRlciArPSBgICR7bmFtZX09XCIke2F0dHJUZXh0KHZhbHVlKX1cImA7XG4gICAgcmV0dXJuIG07XG4gIH0sXG4gICAgICAgIG0gPSB7XG4gICAgb3Blbih0YWcsIC4uLmF0dHJzKSB7XG4gICAgICBwdXNoKHRhZyk7XG4gICAgICBvdXRlciA9ICc8JyArIHRhZztcblxuICAgICAgZm9yIChjb25zdCBzZXQgb2YgYXR0cnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2V0KSBhdHRyKGtleSwgc2V0W2tleV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgY2xvc2UoKSB7XG4gICAgICBjb25zdCB0YWcgPSBzdGFjay5wb3AoKTtcblxuICAgICAgaWYgKG91dGVyKSB7XG4gICAgICAgIGJ1ZiArPSBvdXRlciArIChpbm5lciA/IGA+JHtpbm5lcn08LyR7dGFnfT5gIDogJy8+Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYgKz0gYDwvJHt0YWd9PmA7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyKCk7XG4gICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgYXR0cixcbiAgICB0ZXh0OiB0ID0+IChpbm5lciArPSBpbm5lclRleHQodCksIG0pLFxuICAgIHRvU3RyaW5nOiAoKSA9PiBidWZcbiAgfTtcblxuICByZXR1cm4gbTtcbn1cbmNvbnN0IHNlcmlhbGl6ZVhNTCA9IG5vZGUgPT4gX3NlcmlhbGl6ZShtYXJrdXAoKSwgbm9kZSkgKyAnJztcblxuZnVuY3Rpb24gX3NlcmlhbGl6ZShtLCBub2RlKSB7XG4gIG0ub3Blbihub2RlLnRhZ05hbWUpO1xuXG4gIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIGNvbnN0IGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIG4gPSBhdHRycy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbS5hdHRyKGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldLnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjaGlsZC5ub2RlVHlwZSA9PT0gMyAvLyB0ZXh0IG5vZGVcbiAgICAgID8gbS50ZXh0KGNoaWxkLm5vZGVWYWx1ZSkgOiBfc2VyaWFsaXplKG0sIGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbS5jbG9zZSgpO1xufVxuXG5jb25zdCBzdHlsZXMgPSB7XG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gIHN0cm9rZUNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgc3Ryb2tlSm9pbjogJ3N0cm9rZS1saW5lam9pbicsXG4gIHN0cm9rZURhc2g6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgc3Ryb2tlRGFzaE9mZnNldDogJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgc3Ryb2tlTWl0ZXJMaW1pdDogJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBibGVuZDogJ21peC1ibGVuZC1tb2RlJ1xufTsgLy8gZW5zdXJlIG1pdGVyIGxpbWl0IGRlZmF1bHQgaXMgY29uc2lzdGVudCB3aXRoIGNhbnZhcyAoIzI0OTgpXG5cbmNvbnN0IHJvb3RBdHRyaWJ1dGVzID0ge1xuICAnZmlsbCc6ICdub25lJyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogMTBcbn07XG5cbmNvbnN0IFJvb3RJbmRleCA9IDAsXG4gICAgICB4bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLycsXG4gICAgICBzdmducyA9IG1ldGFkYXRhLnhtbG5zO1xuZnVuY3Rpb24gU1ZHUmVuZGVyZXIobG9hZGVyKSB7XG4gIFJlbmRlcmVyLmNhbGwodGhpcywgbG9hZGVyKTtcbiAgdGhpcy5fZGlydHlJRCA9IDA7XG4gIHRoaXMuX2RpcnR5ID0gW107XG4gIHRoaXMuX3N2ZyA9IG51bGw7XG4gIHRoaXMuX3Jvb3QgPSBudWxsO1xuICB0aGlzLl9kZWZzID0gbnVsbDtcbn1cbmNvbnN0IGJhc2UgPSBSZW5kZXJlci5wcm90b3R5cGU7XG5pbmhlcml0cyhTVkdSZW5kZXJlciwgUmVuZGVyZXIsIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgU1ZHUmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWwgLSBUaGUgY29udGFpbmluZyBET00gZWxlbWVudCBmb3IgdGhlIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSBjb29yZGluYXRlIHdpZHRoIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgY29vcmRpbmF0ZSBoZWlnaHQgb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqICAgVGhlIGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlRmFjdG9yPTFdIC0gT3B0aW9uYWwgc2NhbGVGYWN0b3IgYnkgd2hpY2ggdG8gbXVsdGlwbHlcbiAgICogICB0aGUgd2lkdGggYW5kIGhlaWdodCB0byBkZXRlcm1pbmUgdGhlIGZpbmFsIHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge1NWR1JlbmRlcmVyfSAtIFRoaXMgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBpbml0aWFsaXplKGVsLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKSB7XG4gICAgLy8gY3JlYXRlIHRoZSBzdmcgZGVmaW5pdGlvbnMgY2FjaGVcbiAgICB0aGlzLl9kZWZzID0ge307XG5cbiAgICB0aGlzLl9jbGVhckRlZnMoKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgdGhpcy5fc3ZnID0gZG9tQ2hpbGQoZWwsIDAsICdzdmcnLCBzdmducyk7XG5cbiAgICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGVOUyh4bWxucywgJ3htbG5zJywgc3ZnbnMpO1xuXG4gICAgICB0aGlzLl9zdmcuc2V0QXR0cmlidXRlTlMoeG1sbnMsICd4bWxuczp4bGluaycsIG1ldGFkYXRhWyd4bWxuczp4bGluayddKTtcblxuICAgICAgdGhpcy5fc3ZnLnNldEF0dHJpYnV0ZSgndmVyc2lvbicsIG1ldGFkYXRhWyd2ZXJzaW9uJ10pO1xuXG4gICAgICB0aGlzLl9zdmcuc2V0QXR0cmlidXRlKCdjbGFzcycsICdtYXJrcycpO1xuXG4gICAgICBkb21DbGVhcihlbCwgMSk7IC8vIHNldCB0aGUgc3ZnIHJvb3QgZ3JvdXBcblxuICAgICAgdGhpcy5fcm9vdCA9IGRvbUNoaWxkKHRoaXMuX3N2ZywgUm9vdEluZGV4LCAnZycsIHN2Z25zKTtcbiAgICAgIHNldEF0dHJpYnV0ZXModGhpcy5fcm9vdCwgcm9vdEF0dHJpYnV0ZXMpOyAvLyBlbnN1cmUgbm8gYWRkaXRpb25hbCBjaGlsZCBlbGVtZW50c1xuXG4gICAgICBkb21DbGVhcih0aGlzLl9zdmcsIFJvb3RJbmRleCArIDEpO1xuICAgIH0gLy8gc2V0IGJhY2tncm91bmQgY29sb3IgaWYgZGVmaW5lZFxuXG5cbiAgICB0aGlzLmJhY2tncm91bmQodGhpcy5fYmdjb2xvcik7XG4gICAgcmV0dXJuIGJhc2UuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVsLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IC8gc2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgYmFja2dyb3VuZChiZ2NvbG9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgdGhpcy5fc3ZnKSB7XG4gICAgICB0aGlzLl9zdmcuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtY29sb3InLCBiZ2NvbG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZS5iYWNrZ3JvdW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgZGlzcGxheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyBjb29yZGluYXRlIHdpZHRoIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGNvb3JkaW5hdGUgaGVpZ2h0IG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb3JpZ2luIC0gVGhlIG5ldyBvcmlnaW4gb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogICBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRoaXMgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVGYWN0b3I9MV0gLSBPcHRpb25hbCBzY2FsZUZhY3RvciBieSB3aGljaCB0byBtdWx0aXBseVxuICAgKiAgIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGRldGVybWluZSB0aGUgZmluYWwgcGl4ZWwgc2l6ZS5cbiAgICogQHJldHVybiB7U1ZHUmVuZGVyZXJ9IC0gVGhpcyByZW5kZXJlciBpbnN0YW5jZTtcbiAgICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKSB7XG4gICAgYmFzZS5yZXNpemUuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKTtcblxuICAgIGlmICh0aGlzLl9zdmcpIHtcbiAgICAgIHNldEF0dHJpYnV0ZXModGhpcy5fc3ZnLCB7XG4gICAgICAgIHdpZHRoOiB0aGlzLl93aWR0aCAqIHRoaXMuX3NjYWxlLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodCAqIHRoaXMuX3NjYWxlLFxuICAgICAgICB2aWV3Qm94OiBgMCAwICR7dGhpcy5fd2lkdGh9ICR7dGhpcy5faGVpZ2h0fWBcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yb290LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMuX29yaWdpbn0pYCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgU1ZHIGVsZW1lbnQgb2YgdGhlIHZpc3VhbGl6YXRpb24uXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IC0gVGhlIFNWRyBlbGVtZW50LlxuICAgKi9cbiAgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdmc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gU1ZHIHRleHQgc3RyaW5nIGZvciB0aGUgcmVuZGVyZWQgY29udGVudCxcbiAgICogb3IgbnVsbCBpZiB0aGlzIHJlbmRlcmVyIGlzIGN1cnJlbnRseSBoZWFkbGVzcy5cbiAgICovXG4gIHN2ZygpIHtcbiAgICBjb25zdCBzdmcgPSB0aGlzLl9zdmcsXG4gICAgICAgICAgYmcgPSB0aGlzLl9iZ2NvbG9yO1xuICAgIGlmICghc3ZnKSByZXR1cm4gbnVsbDtcbiAgICBsZXQgbm9kZTtcblxuICAgIGlmIChiZykge1xuICAgICAgc3ZnLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIG5vZGUgPSBkb21DaGlsZChzdmcsIFJvb3RJbmRleCwgJ3JlY3QnLCBzdmducyk7XG4gICAgICBzZXRBdHRyaWJ1dGVzKG5vZGUsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuX3dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodCxcbiAgICAgICAgZmlsbDogYmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSBzZXJpYWxpemVYTUwoc3ZnKTtcblxuICAgIGlmIChiZykge1xuICAgICAgc3ZnLnJlbW92ZUNoaWxkKG5vZGUpO1xuXG4gICAgICB0aGlzLl9zdmcuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtY29sb3InLCBiZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVybmFsIHJlbmRlcmluZyBtZXRob2QuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSByb290IG1hcmsgb2YgYSBzY2VuZWdyYXBoIHRvIHJlbmRlci5cbiAgICovXG4gIF9yZW5kZXIoc2NlbmUpIHtcbiAgICAvLyBwZXJmb3JtIHNwb3QgdXBkYXRlcyBhbmQgcmUtcmVuZGVyIG1hcmt1cFxuICAgIGlmICh0aGlzLl9kaXJ0eUNoZWNrKCkpIHtcbiAgICAgIGlmICh0aGlzLl9kaXJ0eUFsbCkgdGhpcy5fY2xlYXJEZWZzKCk7XG4gICAgICB0aGlzLm1hcmsodGhpcy5fcm9vdCwgc2NlbmUpO1xuICAgICAgZG9tQ2xlYXIodGhpcy5fcm9vdCwgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZzKCk7XG4gICAgdGhpcy5fZGlydHkgPSBbXTtcbiAgICArK3RoaXMuX2RpcnR5SUQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gLS0gTWFuYWdlIHJlbmRlcmluZyBvZiBpdGVtcyBtYXJrZWQgYXMgZGlydHkgLS1cblxuICAvKipcbiAgICogRmxhZyBhIG1hcmsgaXRlbSBhcyBkaXJ0eS5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIG1hcmsgaXRlbS5cbiAgICovXG4gIGRpcnR5KGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5kaXJ0eSAhPT0gdGhpcy5fZGlydHlJRCkge1xuICAgICAgaXRlbS5kaXJ0eSA9IHRoaXMuX2RpcnR5SUQ7XG5cbiAgICAgIHRoaXMuX2RpcnR5LnB1c2goaXRlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIG1hcmsgaXRlbSBpcyBjb25zaWRlcmVkIGRpcnR5LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKi9cbiAgaXNEaXJ0eShpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5QWxsIHx8ICFpdGVtLl9zdmcgfHwgaXRlbS5kaXJ0eSA9PT0gdGhpcy5fZGlydHlJRDtcbiAgfSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGNoZWNrIGRpcnR5IHN0YXR1cyBhbmQsIGlmIHBvc3NpYmxlLFxuICAgKiBtYWtlIHRhcmdldHRlZCB1cGRhdGVzIHdpdGhvdXQgYSBmdWxsIHJlbmRlcmluZyBwYXNzLlxuICAgKi9cbiAgX2RpcnR5Q2hlY2soKSB7XG4gICAgdGhpcy5fZGlydHlBbGwgPSB0cnVlO1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZGlydHk7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGggfHwgIXRoaXMuX2RpcnR5SUQpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGlkID0gKyt0aGlzLl9kaXJ0eUlEO1xuICAgIGxldCBpdGVtLCBtYXJrLCB0eXBlLCBtZGVmLCBpLCBuLCBvO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgbWFyayA9IGl0ZW0ubWFyaztcblxuICAgICAgaWYgKG1hcmsubWFya3R5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgLy8gbWVtb2l6ZSBtYXJrIGluc3RhbmNlIGxvb2t1cFxuICAgICAgICB0eXBlID0gbWFyay5tYXJrdHlwZTtcbiAgICAgICAgbWRlZiA9IE1hcmtzW3R5cGVdO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFyay56ZGlydHkgJiYgbWFyay5kaXJ0eSAhPT0gaWQpIHtcbiAgICAgICAgdGhpcy5fZGlydHlBbGwgPSBmYWxzZTtcbiAgICAgICAgZGlydHlQYXJlbnRzKGl0ZW0sIGlkKTtcbiAgICAgICAgbWFyay5pdGVtcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgIGkuZGlydHkgPSBpZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrLnpkaXJ0eSkgY29udGludWU7IC8vIGhhbmRsZSBpbiBzdGFuZGFyZCBkcmF3aW5nIHBhc3NcblxuICAgICAgaWYgKGl0ZW0uZXhpdCkge1xuICAgICAgICAvLyBFWElUXG4gICAgICAgIGlmIChtZGVmLm5lc3RlZCAmJiBtYXJrLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGlmIG5lc3RlZCBtYXJrIHdpdGggcmVtYWluaW5nIHBvaW50cywgdXBkYXRlIGluc3RlYWRcbiAgICAgICAgICBvID0gbWFyay5pdGVtc1swXTtcbiAgICAgICAgICBpZiAoby5fc3ZnKSB0aGlzLl91cGRhdGUobWRlZiwgby5fc3ZnLCBvKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLl9zdmcpIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2UgcmVtb3ZlIGZyb20gRE9NXG4gICAgICAgICAgbyA9IGl0ZW0uX3N2Zy5wYXJlbnROb2RlO1xuICAgICAgICAgIGlmIChvKSBvLnJlbW92ZUNoaWxkKGl0ZW0uX3N2Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLl9zdmcgPSBudWxsO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaXRlbSA9IG1kZWYubmVzdGVkID8gbWFyay5pdGVtc1swXSA6IGl0ZW07XG4gICAgICBpZiAoaXRlbS5fdXBkYXRlID09PSBpZCkgY29udGludWU7IC8vIGFscmVhZHkgdmlzaXRlZFxuXG4gICAgICBpZiAoIWl0ZW0uX3N2ZyB8fCAhaXRlbS5fc3ZnLm93bmVyU1ZHRWxlbWVudCkge1xuICAgICAgICAvLyBFTlRFUlxuICAgICAgICB0aGlzLl9kaXJ0eUFsbCA9IGZhbHNlO1xuICAgICAgICBkaXJ0eVBhcmVudHMoaXRlbSwgaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSU4tUExBQ0UgVVBEQVRFXG4gICAgICAgIHRoaXMuX3VwZGF0ZShtZGVmLCBpdGVtLl9zdmcsIGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBpdGVtLl91cGRhdGUgPSBpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXMuX2RpcnR5QWxsO1xuICB9LFxuXG4gIC8vIC0tIENvbnN0cnVjdCAmIG1haW50YWluIHNjZW5lZ3JhcGggdG8gU1ZHIG1hcHBpbmcgLS0tXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHNldCBvZiBtYXJrIGl0ZW1zLlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsIC0gVGhlIHBhcmVudCBlbGVtZW50IGluIHRoZSBTVkcgdHJlZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIG1hcmsgcGFyZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBwcmV2IC0gVGhlIHByZXZpb3VzIHNpYmxpbmcgaW4gdGhlIFNWRyB0cmVlLlxuICAgKi9cbiAgbWFyayhlbCwgc2NlbmUsIHByZXYpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXJ0eShzY2VuZSkpIHJldHVybiBzY2VuZS5fc3ZnO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuX3N2ZyxcbiAgICAgICAgICBtZGVmID0gTWFya3Nbc2NlbmUubWFya3R5cGVdLFxuICAgICAgICAgIGV2ZW50cyA9IHNjZW5lLmludGVyYWN0aXZlID09PSBmYWxzZSA/ICdub25lJyA6IG51bGwsXG4gICAgICAgICAgaXNHcm91cCA9IG1kZWYudGFnID09PSAnZyc7XG4gICAgbGV0IHNpYmxpbmcgPSBudWxsLFxuICAgICAgICBpID0gMDtcbiAgICBjb25zdCBwYXJlbnQgPSBiaW5kKHNjZW5lLCBlbCwgcHJldiwgJ2cnLCBzdmcpO1xuICAgIHBhcmVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3NzQ2xhc3Moc2NlbmUpKTsgLy8gYXBwbHkgYXJpYSBhdHRyaWJ1dGVzIHRvIHBhcmVudCBjb250YWluZXIgZWxlbWVudFxuXG4gICAgY29uc3QgYXJpYSA9IGFyaWFNYXJrQXR0cmlidXRlcyhzY2VuZSk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhcmlhKSBzZXRBdHRyaWJ1dGUocGFyZW50LCBrZXksIGFyaWFba2V5XSk7XG5cbiAgICBpZiAoIWlzR3JvdXApIHtcbiAgICAgIHNldEF0dHJpYnV0ZShwYXJlbnQsICdwb2ludGVyLWV2ZW50cycsIGV2ZW50cyk7XG4gICAgfVxuXG4gICAgc2V0QXR0cmlidXRlKHBhcmVudCwgJ2NsaXAtcGF0aCcsIHNjZW5lLmNsaXAgPyBjbGlwJDEodGhpcywgc2NlbmUsIHNjZW5lLmdyb3VwKSA6IG51bGwpO1xuXG4gICAgY29uc3QgcHJvY2VzcyA9IGl0ZW0gPT4ge1xuICAgICAgY29uc3QgZGlydHkgPSB0aGlzLmlzRGlydHkoaXRlbSksXG4gICAgICAgICAgICBub2RlID0gYmluZChpdGVtLCBwYXJlbnQsIHNpYmxpbmcsIG1kZWYudGFnLCBzdmcpO1xuXG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKG1kZWYsIG5vZGUsIGl0ZW0pO1xuXG4gICAgICAgIGlmIChpc0dyb3VwKSByZWN1cnNlKHRoaXMsIG5vZGUsIGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBzaWJsaW5nID0gbm9kZTtcbiAgICAgICsraTtcbiAgICB9O1xuXG4gICAgaWYgKG1kZWYubmVzdGVkKSB7XG4gICAgICBpZiAoc2NlbmUuaXRlbXMubGVuZ3RoKSBwcm9jZXNzKHNjZW5lLml0ZW1zWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlzaXQoc2NlbmUsIHByb2Nlc3MpO1xuICAgIH1cblxuICAgIGRvbUNsZWFyKHBhcmVudCwgaSk7XG4gICAgcmV0dXJuIHBhcmVudDtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIGFuIFNWRyBlbGVtZW50IGZvciBhIG1hcmsgaXRlbS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1kZWYgLSBUaGUgbWFyayBkZWZpbml0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsIC0gVGhlIFNWRyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKi9cbiAgX3VwZGF0ZShtZGVmLCBlbCwgaXRlbSkge1xuICAgIC8vIHNldCBkb20gZWxlbWVudCBhbmQgdmFsdWVzIGNhY2hlXG4gICAgLy8gcHJvdmlkZXMgYWNjZXNzIHRvIGVtaXQgbWV0aG9kXG4gICAgZWxlbWVudCA9IGVsO1xuICAgIHZhbHVlcyA9IGVsLl9fdmFsdWVzX187IC8vIGFwcGx5IGFyaWEtc3BlY2lmaWMgcHJvcGVydGllc1xuXG4gICAgYXJpYUl0ZW1BdHRyaWJ1dGVzKGVtaXQsIGl0ZW0pOyAvLyBhcHBseSBzdmcgYXR0cmlidXRlc1xuXG4gICAgbWRlZi5hdHRyKGVtaXQsIGl0ZW0sIHRoaXMpOyAvLyBzb21lIG1hcmtzIG5lZWQgc3BlY2lhbCB0cmVhdG1lbnRcblxuICAgIGNvbnN0IGV4dHJhID0gbWFya19leHRyYXNbbWRlZi50eXBlXTtcbiAgICBpZiAoZXh0cmEpIGV4dHJhLmNhbGwodGhpcywgbWRlZiwgZWwsIGl0ZW0pOyAvLyBhcHBseSBzdmcgc3R5bGUgYXR0cmlidXRlc1xuICAgIC8vIG5vdGU6IGVsZW1lbnQgc3RhdGUgbWF5IGhhdmUgYmVlbiBtb2RpZmllZCBieSAnZXh0cmEnIG1ldGhvZFxuXG4gICAgaWYgKGVsZW1lbnQpIHRoaXMuc3R5bGUoZWxlbWVudCwgaXRlbSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcHJlc2VudGF0aW9uIGF0dHJpYnV0ZXMgb2YgYW4gU1ZHIGVsZW1lbnQgZm9yIGEgbWFyayBpdGVtLlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsIC0gVGhlIFNWRyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKi9cbiAgc3R5bGUoZWwsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbSA9PSBudWxsKSByZXR1cm47XG5cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc3R5bGVzKSB7XG4gICAgICBsZXQgdmFsdWUgPSBwcm9wID09PSAnZm9udCcgPyBmb250RmFtaWx5KGl0ZW0pIDogaXRlbVtwcm9wXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdmFsdWVzW3Byb3BdKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IG5hbWUgPSBzdHlsZXNbcHJvcF07XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0dyYWRpZW50KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gZ3JhZGllbnRSZWYodmFsdWUsIHRoaXMuX2RlZnMuZ3JhZGllbnQsIGhyZWYoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgKyAnJyk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIFNWRyBkZWZzLCBhcyBuZWVkZWQuXG4gICAqIE11c3QgYmUgY2FsbGVkICphZnRlciogbWFya3MgaGF2ZSBiZWVuIHByb2Nlc3NlZCB0byBlbnN1cmUgdGhlXG4gICAqIGNvbGxlY3RlZCBzdGF0ZSBpcyBjdXJyZW50IGFuZCBhY2N1cmF0ZS5cbiAgICovXG4gIGRlZnMoKSB7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgICAgIGRlZnMgPSB0aGlzLl9kZWZzO1xuICAgIGxldCBlbCA9IGRlZnMuZWwsXG4gICAgICAgIGluZGV4ID0gMDtcblxuICAgIGZvciAoY29uc3QgaWQgaW4gZGVmcy5ncmFkaWVudCkge1xuICAgICAgaWYgKCFlbCkgZGVmcy5lbCA9IGVsID0gZG9tQ2hpbGQoc3ZnLCBSb290SW5kZXggKyAxLCAnZGVmcycsIHN2Z25zKTtcbiAgICAgIGluZGV4ID0gdXBkYXRlR3JhZGllbnQoZWwsIGRlZnMuZ3JhZGllbnRbaWRdLCBpbmRleCk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpZCBpbiBkZWZzLmNsaXBwaW5nKSB7XG4gICAgICBpZiAoIWVsKSBkZWZzLmVsID0gZWwgPSBkb21DaGlsZChzdmcsIFJvb3RJbmRleCArIDEsICdkZWZzJywgc3ZnbnMpO1xuICAgICAgaW5kZXggPSB1cGRhdGVDbGlwcGluZyhlbCwgZGVmcy5jbGlwcGluZ1tpZF0sIGluZGV4KTtcbiAgICB9IC8vIGNsZWFuLXVwXG5cblxuICAgIGlmIChlbCkge1xuICAgICAgaW5kZXggPT09IDAgPyAoc3ZnLnJlbW92ZUNoaWxkKGVsKSwgZGVmcy5lbCA9IG51bGwpIDogZG9tQ2xlYXIoZWwsIGluZGV4KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFyIGRlZnMgY2FjaGVzLlxuICAgKi9cbiAgX2NsZWFyRGVmcygpIHtcbiAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWZzO1xuICAgIGRlZi5ncmFkaWVudCA9IHt9O1xuICAgIGRlZi5jbGlwcGluZyA9IHt9O1xuICB9XG5cbn0pOyAvLyBtYXJrIGFuY2VzdG9yIGNoYWluIHdpdGggYSBkaXJ0eSBpZFxuXG5mdW5jdGlvbiBkaXJ0eVBhcmVudHMoaXRlbSwgaWQpIHtcbiAgZm9yICg7IGl0ZW0gJiYgaXRlbS5kaXJ0eSAhPT0gaWQ7IGl0ZW0gPSBpdGVtLm1hcmsuZ3JvdXApIHtcbiAgICBpdGVtLmRpcnR5ID0gaWQ7XG5cbiAgICBpZiAoaXRlbS5tYXJrICYmIGl0ZW0ubWFyay5kaXJ0eSAhPT0gaWQpIHtcbiAgICAgIGl0ZW0ubWFyay5kaXJ0eSA9IGlkO1xuICAgIH0gZWxzZSByZXR1cm47XG4gIH1cbn0gLy8gdXBkYXRlIGdyYWRpZW50IGRlZmluaXRpb25zXG5cblxuZnVuY3Rpb24gdXBkYXRlR3JhZGllbnQoZWwsIGdyYWQsIGluZGV4KSB7XG4gIGxldCBpLCBuLCBzdG9wO1xuXG4gIGlmIChncmFkLmdyYWRpZW50ID09PSAncmFkaWFsJykge1xuICAgIC8vIFNWRyByYWRpYWwgZ3JhZGllbnRzIGF1dG9tYXRpY2FsbHkgdHJhbnNmb3JtIHRvIG5vcm1hbGl6ZWQgYmJveFxuICAgIC8vIGNvb3JkaW5hdGVzLCBpbiBhIHdheSB0aGF0IGlzIGN1bWJlcnNvbWUgdG8gcmVwbGljYXRlIGluIGNhbnZhcy5cbiAgICAvLyBXZSB3cmFwIHRoZSByYWRpYWwgZ3JhZGllbnQgaW4gYSBwYXR0ZXJuIGVsZW1lbnQsIGFsbG93aW5nIHVzIHRvXG4gICAgLy8gbWFpbnRhaW4gYSBjaXJjdWxhciBncmFkaWVudCB0aGF0IG1hdGNoZXMgd2hhdCBjYW52YXMgcHJvdmlkZXMuXG4gICAgbGV0IHB0ID0gZG9tQ2hpbGQoZWwsIGluZGV4KyssICdwYXR0ZXJuJywgc3ZnbnMpO1xuICAgIHNldEF0dHJpYnV0ZXMocHQsIHtcbiAgICAgIGlkOiBwYXR0ZXJuUHJlZml4ICsgZ3JhZC5pZCxcbiAgICAgIHZpZXdCb3g6ICcwLDAsMSwxJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICd4TWlkWU1pZCBzbGljZSdcbiAgICB9KTtcbiAgICBwdCA9IGRvbUNoaWxkKHB0LCAwLCAncmVjdCcsIHN2Z25zKTtcbiAgICBzZXRBdHRyaWJ1dGVzKHB0LCB7XG4gICAgICB3aWR0aDogMSxcbiAgICAgIGhlaWdodDogMSxcbiAgICAgIGZpbGw6IGB1cmwoJHtocmVmKCl9IyR7Z3JhZC5pZH0pYFxuICAgIH0pO1xuICAgIGVsID0gZG9tQ2hpbGQoZWwsIGluZGV4KyssICdyYWRpYWxHcmFkaWVudCcsIHN2Z25zKTtcbiAgICBzZXRBdHRyaWJ1dGVzKGVsLCB7XG4gICAgICBpZDogZ3JhZC5pZCxcbiAgICAgIGZ4OiBncmFkLngxLFxuICAgICAgZnk6IGdyYWQueTEsXG4gICAgICBmcjogZ3JhZC5yMSxcbiAgICAgIGN4OiBncmFkLngyLFxuICAgICAgY3k6IGdyYWQueTIsXG4gICAgICByOiBncmFkLnIyXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZWwgPSBkb21DaGlsZChlbCwgaW5kZXgrKywgJ2xpbmVhckdyYWRpZW50Jywgc3ZnbnMpO1xuICAgIHNldEF0dHJpYnV0ZXMoZWwsIHtcbiAgICAgIGlkOiBncmFkLmlkLFxuICAgICAgeDE6IGdyYWQueDEsXG4gICAgICB4MjogZ3JhZC54MixcbiAgICAgIHkxOiBncmFkLnkxLFxuICAgICAgeTI6IGdyYWQueTJcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAoaSA9IDAsIG4gPSBncmFkLnN0b3BzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHN0b3AgPSBkb21DaGlsZChlbCwgaSwgJ3N0b3AnLCBzdmducyk7XG4gICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIGdyYWQuc3RvcHNbaV0ub2Zmc2V0KTtcbiAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsIGdyYWQuc3RvcHNbaV0uY29sb3IpO1xuICB9XG5cbiAgZG9tQ2xlYXIoZWwsIGkpO1xuICByZXR1cm4gaW5kZXg7XG59IC8vIHVwZGF0ZSBjbGlwcGluZyBwYXRoIGRlZmluaXRpb25zXG5cblxuZnVuY3Rpb24gdXBkYXRlQ2xpcHBpbmcoZWwsIGNsaXAsIGluZGV4KSB7XG4gIGxldCBtYXNrO1xuICBlbCA9IGRvbUNoaWxkKGVsLCBpbmRleCwgJ2NsaXBQYXRoJywgc3ZnbnMpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ2lkJywgY2xpcC5pZCk7XG5cbiAgaWYgKGNsaXAucGF0aCkge1xuICAgIG1hc2sgPSBkb21DaGlsZChlbCwgMCwgJ3BhdGgnLCBzdmducyk7XG4gICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2QnLCBjbGlwLnBhdGgpO1xuICB9IGVsc2Uge1xuICAgIG1hc2sgPSBkb21DaGlsZChlbCwgMCwgJ3JlY3QnLCBzdmducyk7XG4gICAgc2V0QXR0cmlidXRlcyhtYXNrLCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBjbGlwLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjbGlwLmhlaWdodFxuICAgIH0pO1xuICB9XG5cbiAgZG9tQ2xlYXIoZWwsIDEpO1xuICByZXR1cm4gaW5kZXggKyAxO1xufSAvLyBSZWN1cnNpdmVseSBwcm9jZXNzIGdyb3VwIGNvbnRlbnRzLlxuXG5cbmZ1bmN0aW9uIHJlY3Vyc2UocmVuZGVyZXIsIGVsLCBncm91cCkge1xuICBlbCA9IGVsLmxhc3RDaGlsZC5wcmV2aW91c1NpYmxpbmc7XG4gIGxldCBwcmV2LFxuICAgICAgaWR4ID0gMDtcbiAgdmlzaXQoZ3JvdXAsIGl0ZW0gPT4ge1xuICAgIHByZXYgPSByZW5kZXJlci5tYXJrKGVsLCBpdGVtLCBwcmV2KTtcbiAgICArK2lkeDtcbiAgfSk7IC8vIHJlbW92ZSBhbnkgZXh0cmFuZW91cyBET00gZWxlbWVudHNcblxuICBkb21DbGVhcihlbCwgMSArIGlkeCk7XG59IC8vIEJpbmQgYSBzY2VuZWdyYXBoIGl0ZW0gdG8gYW4gU1ZHIERPTSBlbGVtZW50LlxuLy8gQ3JlYXRlIG5ldyBTVkcgZWxlbWVudHMgYXMgbmVlZGVkLlxuXG5cbmZ1bmN0aW9uIGJpbmQoaXRlbSwgZWwsIHNpYmxpbmcsIHRhZywgc3ZnKSB7XG4gIGxldCBub2RlID0gaXRlbS5fc3ZnLFxuICAgICAgZG9jOyAvLyBjcmVhdGUgYSBuZXcgZG9tIG5vZGUgaWYgbmVlZGVkXG5cbiAgaWYgKCFub2RlKSB7XG4gICAgZG9jID0gZWwub3duZXJEb2N1bWVudDtcbiAgICBub2RlID0gZG9tQ3JlYXRlKGRvYywgdGFnLCBzdmducyk7XG4gICAgaXRlbS5fc3ZnID0gbm9kZTtcblxuICAgIGlmIChpdGVtLm1hcmspIHtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBpdGVtO1xuICAgICAgbm9kZS5fX3ZhbHVlc19fID0ge1xuICAgICAgICBmaWxsOiAnZGVmYXVsdCdcbiAgICAgIH07IC8vIGlmIGdyb3VwLCBjcmVhdGUgYmFja2dyb3VuZCwgY29udGVudCwgYW5kIGZvcmVncm91bmQgZWxlbWVudHNcblxuICAgICAgaWYgKHRhZyA9PT0gJ2cnKSB7XG4gICAgICAgIGNvbnN0IGJnID0gZG9tQ3JlYXRlKGRvYywgJ3BhdGgnLCBzdmducyk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoYmcpO1xuICAgICAgICBiZy5fX2RhdGFfXyA9IGl0ZW07XG4gICAgICAgIGNvbnN0IGNnID0gZG9tQ3JlYXRlKGRvYywgJ2cnLCBzdmducyk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2cpO1xuICAgICAgICBjZy5fX2RhdGFfXyA9IGl0ZW07XG4gICAgICAgIGNvbnN0IGZnID0gZG9tQ3JlYXRlKGRvYywgJ3BhdGgnLCBzdmducyk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZmcpO1xuICAgICAgICBmZy5fX2RhdGFfXyA9IGl0ZW07XG4gICAgICAgIGZnLl9fdmFsdWVzX18gPSB7XG4gICAgICAgICAgZmlsbDogJ2RlZmF1bHQnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIChyZS0paW5zZXJ0IGlmIChhKSBub3QgY29udGFpbmVkIGluIFNWRyBvciAoYikgc2libGluZyBvcmRlciBoYXMgY2hhbmdlZFxuXG5cbiAgaWYgKG5vZGUub3duZXJTVkdFbGVtZW50ICE9PSBzdmcgfHwgc2libGluZ0NoZWNrKG5vZGUsIHNpYmxpbmcpKSB7XG4gICAgZWwuaW5zZXJ0QmVmb3JlKG5vZGUsIHNpYmxpbmcgPyBzaWJsaW5nLm5leHRTaWJsaW5nIDogZWwuZmlyc3RDaGlsZCk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gY2hlY2sgaWYgdHdvIG5vZGVzIGFyZSBvcmRlcmVkIHNpYmxpbmdzXG5cblxuZnVuY3Rpb24gc2libGluZ0NoZWNrKG5vZGUsIHNpYmxpbmcpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAxICYmIG5vZGUucHJldmlvdXNTaWJsaW5nICE9IHNpYmxpbmc7IC8vIHRyZWF0IG51bGwvdW5kZWZpbmVkIHRoZSBzYW1lXG59IC8vIC0tIFNldCBhdHRyaWJ1dGVzICYgc3R5bGVzIG9uIFNWRyBlbGVtZW50cyAtLS1cblxuXG5sZXQgZWxlbWVudCA9IG51bGwsXG4gICAgLy8gdGVtcCB2YXIgZm9yIGN1cnJlbnQgU1ZHIGVsZW1lbnRcbnZhbHVlcyA9IG51bGw7IC8vIHRlbXAgdmFyIGZvciBjdXJyZW50IHZhbHVlcyBoYXNoXG4vLyBFeHRyYSBjb25maWd1cmF0aW9uIGZvciBjZXJ0YWluIG1hcmsgdHlwZXNcblxuY29uc3QgbWFya19leHRyYXMgPSB7XG4gIGdyb3VwKG1kZWYsIGVsLCBpdGVtKSB7XG4gICAgY29uc3QgZmcgPSBlbGVtZW50ID0gZWwuY2hpbGROb2Rlc1syXTtcbiAgICB2YWx1ZXMgPSBmZy5fX3ZhbHVlc19fO1xuICAgIG1kZWYuZm9yZWdyb3VuZChlbWl0LCBpdGVtLCB0aGlzKTtcbiAgICB2YWx1ZXMgPSBlbC5fX3ZhbHVlc19fOyAvLyB1c2UgcGFyZW50J3MgdmFsdWVzIGhhc2hcblxuICAgIGVsZW1lbnQgPSBlbC5jaGlsZE5vZGVzWzFdO1xuICAgIG1kZWYuY29udGVudChlbWl0LCBpdGVtLCB0aGlzKTtcbiAgICBjb25zdCBiZyA9IGVsZW1lbnQgPSBlbC5jaGlsZE5vZGVzWzBdO1xuICAgIG1kZWYuYmFja2dyb3VuZChlbWl0LCBpdGVtLCB0aGlzKTtcbiAgICBjb25zdCB2YWx1ZSA9IGl0ZW0ubWFyay5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsO1xuXG4gICAgaWYgKHZhbHVlICE9PSB2YWx1ZXMuZXZlbnRzKSB7XG4gICAgICBzZXRBdHRyaWJ1dGUoZmcsICdwb2ludGVyLWV2ZW50cycsIHZhbHVlKTtcbiAgICAgIHNldEF0dHJpYnV0ZShiZywgJ3BvaW50ZXItZXZlbnRzJywgdmFsdWUpO1xuICAgICAgdmFsdWVzLmV2ZW50cyA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpdGVtLnN0cm9rZUZvcmVncm91bmQgJiYgaXRlbS5zdHJva2UpIHtcbiAgICAgIGNvbnN0IGZpbGwgPSBpdGVtLmZpbGw7XG4gICAgICBzZXRBdHRyaWJ1dGUoZmcsICdkaXNwbGF5JywgbnVsbCk7IC8vIHNldCBzdHlsZSBvZiBiYWNrZ3JvdW5kXG5cbiAgICAgIHRoaXMuc3R5bGUoYmcsIGl0ZW0pO1xuICAgICAgc2V0QXR0cmlidXRlKGJnLCAnc3Ryb2tlJywgbnVsbCk7IC8vIHNldCBzdHlsZSBvZiBmb3JlZ3JvdW5kXG5cbiAgICAgIGlmIChmaWxsKSBpdGVtLmZpbGwgPSBudWxsO1xuICAgICAgdmFsdWVzID0gZmcuX192YWx1ZXNfXztcbiAgICAgIHRoaXMuc3R5bGUoZmcsIGl0ZW0pO1xuICAgICAgaWYgKGZpbGwpIGl0ZW0uZmlsbCA9IGZpbGw7IC8vIGxlYXZlIGVsZW1lbnQgbnVsbCB0byBwcmV2ZW50IGRvd25zdHJlYW0gc3R5bGluZ1xuXG4gICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW5zdXJlIGZvcmVncm91bmQgaXMgaWdub3JlZFxuICAgICAgc2V0QXR0cmlidXRlKGZnLCAnZGlzcGxheScsICdub25lJyk7XG4gICAgfVxuICB9LFxuXG4gIGltYWdlKG1kZWYsIGVsLCBpdGVtKSB7XG4gICAgaWYgKGl0ZW0uc21vb3RoID09PSBmYWxzZSkge1xuICAgICAgc2V0U3R5bGUoZWwsICdpbWFnZS1yZW5kZXJpbmcnLCAnb3B0aW1pemVTcGVlZCcpO1xuICAgICAgc2V0U3R5bGUoZWwsICdpbWFnZS1yZW5kZXJpbmcnLCAncGl4ZWxhdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0eWxlKGVsLCAnaW1hZ2UtcmVuZGVyaW5nJywgbnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIHRleHQobWRlZiwgZWwsIGl0ZW0pIHtcbiAgICBjb25zdCB0bCA9IHRleHRMaW5lcyhpdGVtKTtcbiAgICBsZXQga2V5LCB2YWx1ZSwgZG9jLCBsaDtcblxuICAgIGlmIChpc0FycmF5KHRsKSkge1xuICAgICAgLy8gbXVsdGktbGluZSB0ZXh0XG4gICAgICB2YWx1ZSA9IHRsLm1hcChfID0+IHRleHRWYWx1ZShpdGVtLCBfKSk7XG4gICAgICBrZXkgPSB2YWx1ZS5qb2luKCdcXG4nKTsgLy8gY29udGVudCBjYWNoZSBrZXlcblxuICAgICAgaWYgKGtleSAhPT0gdmFsdWVzLnRleHQpIHtcbiAgICAgICAgZG9tQ2xlYXIoZWwsIDApO1xuICAgICAgICBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICAgICAgICBsaCA9IGxpbmVIZWlnaHQoaXRlbSk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKHQsIGkpID0+IHtcbiAgICAgICAgICBjb25zdCB0cyA9IGRvbUNyZWF0ZShkb2MsICd0c3BhbicsIHN2Z25zKTtcbiAgICAgICAgICB0cy5fX2RhdGFfXyA9IGl0ZW07IC8vIGRhdGEgYmluZGluZ1xuXG4gICAgICAgICAgdHMudGV4dENvbnRlbnQgPSB0O1xuXG4gICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgIHRzLnNldEF0dHJpYnV0ZSgneCcsIDApO1xuICAgICAgICAgICAgdHMuc2V0QXR0cmlidXRlKCdkeScsIGxoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZCh0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZXMudGV4dCA9IGtleTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2luZ2xlLWxpbmUgdGV4dFxuICAgICAgdmFsdWUgPSB0ZXh0VmFsdWUoaXRlbSwgdGwpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHZhbHVlcy50ZXh0KSB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgIHZhbHVlcy50ZXh0ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0QXR0cmlidXRlKGVsLCAnZm9udC1mYW1pbHknLCBmb250RmFtaWx5KGl0ZW0pKTtcbiAgICBzZXRBdHRyaWJ1dGUoZWwsICdmb250LXNpemUnLCBmb250U2l6ZShpdGVtKSArICdweCcpO1xuICAgIHNldEF0dHJpYnV0ZShlbCwgJ2ZvbnQtc3R5bGUnLCBpdGVtLmZvbnRTdHlsZSk7XG4gICAgc2V0QXR0cmlidXRlKGVsLCAnZm9udC12YXJpYW50JywgaXRlbS5mb250VmFyaWFudCk7XG4gICAgc2V0QXR0cmlidXRlKGVsLCAnZm9udC13ZWlnaHQnLCBpdGVtLmZvbnRXZWlnaHQpO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIGVtaXQobmFtZSwgdmFsdWUsIG5zKSB7XG4gIC8vIGVhcmx5IGV4aXQgaWYgdmFsdWUgaXMgdW5jaGFuZ2VkXG4gIGlmICh2YWx1ZSA9PT0gdmFsdWVzW25hbWVdKSByZXR1cm47IC8vIHVzZSBhcHByb3ByaWF0ZSBtZXRob2QgZ2l2ZW4gbmFtZXNwYWNlIChucylcblxuICBpZiAobnMpIHtcbiAgICBzZXRBdHRyaWJ1dGVOUyhlbGVtZW50LCBuYW1lLCB2YWx1ZSwgbnMpO1xuICB9IGVsc2Uge1xuICAgIHNldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gIH0gLy8gbm90ZSBjdXJyZW50IHZhbHVlIGZvciBmdXR1cmUgY29tcGFyaXNvblxuXG5cbiAgdmFsdWVzW25hbWVdID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgIT09IHZhbHVlc1tuYW1lXSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUgKyAnJyk7XG4gICAgfVxuXG4gICAgdmFsdWVzW25hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbCwgYXR0cnMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICBzZXRBdHRyaWJ1dGUoZWwsIGtleSwgYXR0cnNba2V5XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIC8vIGlmIHZhbHVlIGlzIHByb3ZpZGVkLCB1cGRhdGUgRE9NIGF0dHJpYnV0ZVxuICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSByZW1vdmUgRE9NIGF0dHJpYnV0ZVxuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVOUyhlbCwgbmFtZSwgdmFsdWUsIG5zKSB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gaWYgdmFsdWUgaXMgcHJvdmlkZWQsIHVwZGF0ZSBET00gYXR0cmlidXRlXG4gICAgZWwuc2V0QXR0cmlidXRlTlMobnMsIG5hbWUsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHJlbW92ZSBET00gYXR0cmlidXRlXG4gICAgZWwucmVtb3ZlQXR0cmlidXRlTlMobnMsIG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhyZWYoKSB7XG4gIGxldCBsb2M7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICcnIDogKGxvYyA9IHdpbmRvdy5sb2NhdGlvbikuaGFzaCA/IGxvYy5ocmVmLnNsaWNlKDAsIC1sb2MuaGFzaC5sZW5ndGgpIDogbG9jLmhyZWY7XG59XG5cbmZ1bmN0aW9uIFNWR1N0cmluZ1JlbmRlcmVyKGxvYWRlcikge1xuICBSZW5kZXJlci5jYWxsKHRoaXMsIGxvYWRlcik7XG4gIHRoaXMuX3RleHQgPSBudWxsO1xuICB0aGlzLl9kZWZzID0ge1xuICAgIGdyYWRpZW50OiB7fSxcbiAgICBjbGlwcGluZzoge31cbiAgfTtcbn1cbmluaGVyaXRzKFNWR1N0cmluZ1JlbmRlcmVyLCBSZW5kZXJlciwge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVuZGVyZWQgU1ZHIHRleHQgc3RyaW5nLFxuICAgKiBvciBudWxsIGlmIHJlbmRlcmluZyBoYXMgbm90IHlldCBvY2N1cnJlZC5cbiAgICovXG4gIHN2ZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgcmVuZGVyaW5nIG1ldGhvZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIHJvb3QgbWFyayBvZiBhIHNjZW5lZ3JhcGggdG8gcmVuZGVyLlxuICAgKi9cbiAgX3JlbmRlcihzY2VuZSkge1xuICAgIGNvbnN0IG0gPSBtYXJrdXAoKTsgLy8gc3ZnIHRhZ1xuXG4gICAgbS5vcGVuKCdzdmcnLCBleHRlbmQoe30sIG1ldGFkYXRhLCB7XG4gICAgICBjbGFzczogJ21hcmtzJyxcbiAgICAgIHdpZHRoOiB0aGlzLl93aWR0aCAqIHRoaXMuX3NjYWxlLFxuICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQgKiB0aGlzLl9zY2FsZSxcbiAgICAgIHZpZXdCb3g6IGAwIDAgJHt0aGlzLl93aWR0aH0gJHt0aGlzLl9oZWlnaHR9YFxuICAgIH0pKTsgLy8gYmFja2dyb3VuZCwgaWYgZGVmaW5lZFxuXG4gICAgY29uc3QgYmcgPSB0aGlzLl9iZ2NvbG9yO1xuXG4gICAgaWYgKGJnICYmIGJnICE9PSAndHJhbnNwYXJlbnQnICYmIGJnICE9PSAnbm9uZScpIHtcbiAgICAgIG0ub3BlbigncmVjdCcsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuX3dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodCxcbiAgICAgICAgZmlsbDogYmdcbiAgICAgIH0pLmNsb3NlKCk7XG4gICAgfSAvLyByb290IGNvbnRlbnQgZ3JvdXBcblxuXG4gICAgbS5vcGVuKCdnJywgcm9vdEF0dHJpYnV0ZXMsIHtcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgdGhpcy5fb3JpZ2luICsgJyknXG4gICAgfSk7XG4gICAgdGhpcy5tYXJrKG0sIHNjZW5lKTtcbiAgICBtLmNsb3NlKCk7IC8vIDwvZz5cbiAgICAvLyBkZWZzXG5cbiAgICB0aGlzLmRlZnMobSk7IC8vIGdldCBTVkcgdGV4dCBzdHJpbmdcblxuICAgIHRoaXMuX3RleHQgPSBtLmNsb3NlKCkgKyAnJztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgc2V0IG9mIG1hcmsgaXRlbXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtIC0gVGhlIG1hcmt1cCBjb250ZXh0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgbWFyayBwYXJlbnQgdG8gcmVuZGVyLlxuICAgKi9cbiAgbWFyayhtLCBzY2VuZSkge1xuICAgIGNvbnN0IG1kZWYgPSBNYXJrc1tzY2VuZS5tYXJrdHlwZV0sXG4gICAgICAgICAgdGFnID0gbWRlZi50YWcsXG4gICAgICAgICAgYXR0ckxpc3QgPSBbYXJpYUl0ZW1BdHRyaWJ1dGVzLCBtZGVmLmF0dHJdOyAvLyByZW5kZXIgb3BlbmluZyBncm91cCB0YWdcblxuICAgIG0ub3BlbignZycsIHtcbiAgICAgICdjbGFzcyc6IGNzc0NsYXNzKHNjZW5lKSxcbiAgICAgICdjbGlwLXBhdGgnOiBzY2VuZS5jbGlwID8gY2xpcCQxKHRoaXMsIHNjZW5lLCBzY2VuZS5ncm91cCkgOiBudWxsXG4gICAgfSwgYXJpYU1hcmtBdHRyaWJ1dGVzKHNjZW5lKSwge1xuICAgICAgJ3BvaW50ZXItZXZlbnRzJzogdGFnICE9PSAnZycgJiYgc2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlID8gJ25vbmUnIDogbnVsbFxuICAgIH0pOyAvLyByZW5kZXIgY29udGFpbmVkIGVsZW1lbnRzXG5cbiAgICBjb25zdCBwcm9jZXNzID0gaXRlbSA9PiB7XG4gICAgICBjb25zdCBocmVmID0gdGhpcy5ocmVmKGl0ZW0pO1xuICAgICAgaWYgKGhyZWYpIG0ub3BlbignYScsIGhyZWYpO1xuICAgICAgbS5vcGVuKHRhZywgdGhpcy5hdHRyKHNjZW5lLCBpdGVtLCBhdHRyTGlzdCwgdGFnICE9PSAnZycgPyB0YWcgOiBudWxsKSk7XG5cbiAgICAgIGlmICh0YWcgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb25zdCB0bCA9IHRleHRMaW5lcyhpdGVtKTtcblxuICAgICAgICBpZiAoaXNBcnJheSh0bCkpIHtcbiAgICAgICAgICAvLyBtdWx0aS1saW5lIHRleHRcbiAgICAgICAgICBjb25zdCBhdHRycyA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICBkeTogbGluZUhlaWdodChpdGVtKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBtLm9wZW4oJ3RzcGFuJywgaSA/IGF0dHJzIDogbnVsbCkudGV4dCh0ZXh0VmFsdWUoaXRlbSwgdGxbaV0pKS5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzaW5nbGUtbGluZSB0ZXh0XG4gICAgICAgICAgbS50ZXh0KHRleHRWYWx1ZShpdGVtLCB0bCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2cnKSB7XG4gICAgICAgIGNvbnN0IGZvcmUgPSBpdGVtLnN0cm9rZUZvcmVncm91bmQsXG4gICAgICAgICAgICAgIGZpbGwgPSBpdGVtLmZpbGwsXG4gICAgICAgICAgICAgIHN0cm9rZSA9IGl0ZW0uc3Ryb2tlO1xuXG4gICAgICAgIGlmIChmb3JlICYmIHN0cm9rZSkge1xuICAgICAgICAgIGl0ZW0uc3Ryb2tlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG0ub3BlbigncGF0aCcsIHRoaXMuYXR0cihzY2VuZSwgaXRlbSwgbWRlZi5iYWNrZ3JvdW5kLCAnYmdyZWN0JykpLmNsb3NlKCk7IC8vIHJlY3Vyc2UgZm9yIGdyb3VwIGNvbnRlbnRcblxuICAgICAgICBtLm9wZW4oJ2cnLCB0aGlzLmF0dHIoc2NlbmUsIGl0ZW0sIG1kZWYuY29udGVudCkpO1xuICAgICAgICB2aXNpdChpdGVtLCBzY2VuZSA9PiB0aGlzLm1hcmsobSwgc2NlbmUpKTtcbiAgICAgICAgbS5jbG9zZSgpO1xuXG4gICAgICAgIGlmIChmb3JlICYmIHN0cm9rZSkge1xuICAgICAgICAgIGlmIChmaWxsKSBpdGVtLmZpbGwgPSBudWxsO1xuICAgICAgICAgIGl0ZW0uc3Ryb2tlID0gc3Ryb2tlO1xuICAgICAgICAgIG0ub3BlbigncGF0aCcsIHRoaXMuYXR0cihzY2VuZSwgaXRlbSwgbWRlZi5mb3JlZ3JvdW5kLCAnYmdyZWN0JykpLmNsb3NlKCk7XG4gICAgICAgICAgaWYgKGZpbGwpIGl0ZW0uZmlsbCA9IGZpbGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbS5vcGVuKCdwYXRoJywgdGhpcy5hdHRyKHNjZW5lLCBpdGVtLCBtZGVmLmZvcmVncm91bmQsICdiZ2ZvcmUnKSkuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtLmNsb3NlKCk7IC8vIDwvdGFnPlxuXG4gICAgICBpZiAoaHJlZikgbS5jbG9zZSgpOyAvLyA8L2E+XG4gICAgfTtcblxuICAgIGlmIChtZGVmLm5lc3RlZCkge1xuICAgICAgaWYgKHNjZW5lLml0ZW1zICYmIHNjZW5lLml0ZW1zLmxlbmd0aCkgcHJvY2VzcyhzY2VuZS5pdGVtc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2l0KHNjZW5lLCBwcm9jZXNzKTtcbiAgICB9IC8vIHJlbmRlciBjbG9zaW5nIGdyb3VwIHRhZ1xuXG5cbiAgICByZXR1cm4gbS5jbG9zZSgpOyAvLyA8L2c+XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBocmVmIGF0dHJpYnV0ZXMgZm9yIGEgaHlwZXJsaW5rZWQgbWFyayBpdGVtLlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKi9cbiAgaHJlZihpdGVtKSB7XG4gICAgY29uc3QgaHJlZiA9IGl0ZW0uaHJlZjtcbiAgICBsZXQgYXR0cjtcblxuICAgIGlmIChocmVmKSB7XG4gICAgICBpZiAoYXR0ciA9IHRoaXMuX2hyZWZzICYmIHRoaXMuX2hyZWZzW2hyZWZdKSB7XG4gICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zYW5pdGl6ZVVSTChocmVmKS50aGVuKGF0dHIgPT4ge1xuICAgICAgICAgIC8vIHJld3JpdGUgdG8gdXNlIHhsaW5rIG5hbWVzcGFjZVxuICAgICAgICAgIGF0dHJbJ3hsaW5rOmhyZWYnXSA9IGF0dHIuaHJlZjtcbiAgICAgICAgICBhdHRyLmhyZWYgPSBudWxsO1xuICAgICAgICAgICh0aGlzLl9ocmVmcyB8fCAodGhpcy5faHJlZnMgPSB7fSkpW2hyZWZdID0gYXR0cjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3Qgb2YgU1ZHIGF0dHJpYnV0ZXMgZm9yIGEgbWFyayBpdGVtLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgbWFyayBwYXJlbnQuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBtYXJrIGl0ZW0uXG4gICAqIEBwYXJhbSB7YXJyYXl8ZnVuY3Rpb259IGF0dHJzIC0gT25lIG9yIG1vcmUgYXR0cmlidXRlIGVtaXR0ZXJzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0gVGhlIHRhZyBiZWluZyByZW5kZXJlZC5cbiAgICovXG4gIGF0dHIoc2NlbmUsIGl0ZW0sIGF0dHJzLCB0YWcpIHtcbiAgICBjb25zdCBvYmplY3QgPSB7fSxcbiAgICAgICAgICBlbWl0ID0gKG5hbWUsIHZhbHVlLCBucywgcHJlZml4ZWQpID0+IHtcbiAgICAgIG9iamVjdFtwcmVmaXhlZCB8fCBuYW1lXSA9IHZhbHVlO1xuICAgIH07IC8vIGFwcGx5IG1hcmsgc3BlY2lmaWMgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICAgIGF0dHJzLmZvckVhY2goZm4gPT4gZm4oZW1pdCwgaXRlbSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRycyhlbWl0LCBpdGVtLCB0aGlzKTtcbiAgICB9IC8vIGFwcGx5IHN0eWxlIGF0dHJpYnV0ZXNcblxuXG4gICAgaWYgKHRhZykge1xuICAgICAgc3R5bGUob2JqZWN0LCBpdGVtLCBzY2VuZSwgdGFnLCB0aGlzLl9kZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgU1ZHIGRlZnMsIGFzIG5lZWRlZC5cbiAgICogTXVzdCBiZSBjYWxsZWQgKmFmdGVyKiBtYXJrcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHRvIGVuc3VyZSB0aGVcbiAgICogY29sbGVjdGVkIHN0YXRlIGlzIGN1cnJlbnQgYW5kIGFjY3VyYXRlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbSAtIFRoZSBtYXJrdXAgY29udGV4dC5cbiAgICovXG4gIGRlZnMobSkge1xuICAgIGNvbnN0IGdyYWRpZW50ID0gdGhpcy5fZGVmcy5ncmFkaWVudCxcbiAgICAgICAgICBjbGlwcGluZyA9IHRoaXMuX2RlZnMuY2xpcHBpbmcsXG4gICAgICAgICAgY291bnQgPSBPYmplY3Qua2V5cyhncmFkaWVudCkubGVuZ3RoICsgT2JqZWN0LmtleXMoY2xpcHBpbmcpLmxlbmd0aDtcbiAgICBpZiAoY291bnQgPT09IDApIHJldHVybjsgLy8gbm90aGluZyB0byBkb1xuXG4gICAgbS5vcGVuKCdkZWZzJyk7XG5cbiAgICBmb3IgKGNvbnN0IGlkIGluIGdyYWRpZW50KSB7XG4gICAgICBjb25zdCBkZWYgPSBncmFkaWVudFtpZF0sXG4gICAgICAgICAgICBzdG9wcyA9IGRlZi5zdG9wcztcblxuICAgICAgaWYgKGRlZi5ncmFkaWVudCA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgLy8gU1ZHIHJhZGlhbCBncmFkaWVudHMgYXV0b21hdGljYWxseSB0cmFuc2Zvcm0gdG8gbm9ybWFsaXplZCBiYm94XG4gICAgICAgIC8vIGNvb3JkaW5hdGVzLCBpbiBhIHdheSB0aGF0IGlzIGN1bWJlcnNvbWUgdG8gcmVwbGljYXRlIGluIGNhbnZhcy5cbiAgICAgICAgLy8gV2Ugd3JhcCB0aGUgcmFkaWFsIGdyYWRpZW50IGluIGEgcGF0dGVybiBlbGVtZW50LCBhbGxvd2luZyB1cyB0b1xuICAgICAgICAvLyBtYWludGFpbiBhIGNpcmN1bGFyIGdyYWRpZW50IHRoYXQgbWF0Y2hlcyB3aGF0IGNhbnZhcyBwcm92aWRlcy5cbiAgICAgICAgbS5vcGVuKCdwYXR0ZXJuJywge1xuICAgICAgICAgIGlkOiBwYXR0ZXJuUHJlZml4ICsgaWQsXG4gICAgICAgICAgdmlld0JveDogJzAsMCwxLDEnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3hNaWRZTWlkIHNsaWNlJ1xuICAgICAgICB9KTtcbiAgICAgICAgbS5vcGVuKCdyZWN0Jywge1xuICAgICAgICAgIHdpZHRoOiAnMScsXG4gICAgICAgICAgaGVpZ2h0OiAnMScsXG4gICAgICAgICAgZmlsbDogJ3VybCgjJyArIGlkICsgJyknXG4gICAgICAgIH0pLmNsb3NlKCk7XG4gICAgICAgIG0uY2xvc2UoKTsgLy8gPC9wYXR0ZXJuPlxuXG4gICAgICAgIG0ub3BlbigncmFkaWFsR3JhZGllbnQnLCB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIGZ4OiBkZWYueDEsXG4gICAgICAgICAgZnk6IGRlZi55MSxcbiAgICAgICAgICBmcjogZGVmLnIxLFxuICAgICAgICAgIGN4OiBkZWYueDIsXG4gICAgICAgICAgY3k6IGRlZi55MixcbiAgICAgICAgICByOiBkZWYucjJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtLm9wZW4oJ2xpbmVhckdyYWRpZW50Jywge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB4MTogZGVmLngxLFxuICAgICAgICAgIHgyOiBkZWYueDIsXG4gICAgICAgICAgeTE6IGRlZi55MSxcbiAgICAgICAgICB5MjogZGVmLnkyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG0ub3Blbignc3RvcCcsIHtcbiAgICAgICAgICBvZmZzZXQ6IHN0b3BzW2ldLm9mZnNldCxcbiAgICAgICAgICAnc3RvcC1jb2xvcic6IHN0b3BzW2ldLmNvbG9yXG4gICAgICAgIH0pLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIG0uY2xvc2UoKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGlkIGluIGNsaXBwaW5nKSB7XG4gICAgICBjb25zdCBkZWYgPSBjbGlwcGluZ1tpZF07XG4gICAgICBtLm9wZW4oJ2NsaXBQYXRoJywge1xuICAgICAgICBpZDogaWRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZGVmLnBhdGgpIHtcbiAgICAgICAgbS5vcGVuKCdwYXRoJywge1xuICAgICAgICAgIGQ6IGRlZi5wYXRoXG4gICAgICAgIH0pLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtLm9wZW4oJ3JlY3QnLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiBkZWYud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBkZWYuaGVpZ2h0XG4gICAgICAgIH0pLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIG0uY2xvc2UoKTtcbiAgICB9XG5cbiAgICBtLmNsb3NlKCk7XG4gIH1cblxufSk7IC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgYXR0ciBmb3Igc3R5bGUgcHJlc2VudGF0aW9uIGF0dHJpYnV0ZXNcblxuZnVuY3Rpb24gc3R5bGUocywgaXRlbSwgc2NlbmUsIHRhZywgZGVmcykge1xuICBpZiAoaXRlbSA9PSBudWxsKSByZXR1cm4gcztcblxuICBpZiAodGFnID09PSAnYmdyZWN0JyAmJiBzY2VuZS5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICBzWydwb2ludGVyLWV2ZW50cyddID0gJ25vbmUnO1xuICB9XG5cbiAgaWYgKHRhZyA9PT0gJ2JnZm9yZScpIHtcbiAgICBpZiAoc2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICBzWydwb2ludGVyLWV2ZW50cyddID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHMuZGlzcGxheSA9ICdub25lJztcbiAgICBpZiAoaXRlbS5maWxsICE9PSBudWxsKSByZXR1cm4gcztcbiAgfVxuXG4gIGlmICh0YWcgPT09ICdpbWFnZScgJiYgaXRlbS5zbW9vdGggPT09IGZhbHNlKSB7XG4gICAgcy5zdHlsZSA9ICdpbWFnZS1yZW5kZXJpbmc6IG9wdGltaXplU3BlZWQ7IGltYWdlLXJlbmRlcmluZzogcGl4ZWxhdGVkOyc7XG4gIH1cblxuICBpZiAodGFnID09PSAndGV4dCcpIHtcbiAgICBzWydmb250LWZhbWlseSddID0gZm9udEZhbWlseShpdGVtKTtcbiAgICBzWydmb250LXNpemUnXSA9IGZvbnRTaXplKGl0ZW0pICsgJ3B4JztcbiAgICBzWydmb250LXN0eWxlJ10gPSBpdGVtLmZvbnRTdHlsZTtcbiAgICBzWydmb250LXZhcmlhbnQnXSA9IGl0ZW0uZm9udFZhcmlhbnQ7XG4gICAgc1snZm9udC13ZWlnaHQnXSA9IGl0ZW0uZm9udFdlaWdodDtcbiAgfVxuXG4gIGZvciAoY29uc3QgcHJvcCBpbiBzdHlsZXMpIHtcbiAgICBsZXQgdmFsdWUgPSBpdGVtW3Byb3BdO1xuICAgIGNvbnN0IG5hbWUgPSBzdHlsZXNbcHJvcF07XG5cbiAgICBpZiAodmFsdWUgPT09ICd0cmFuc3BhcmVudCcgJiYgKG5hbWUgPT09ICdmaWxsJyB8fCBuYW1lID09PSAnc3Ryb2tlJykpIDsgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzR3JhZGllbnQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gZ3JhZGllbnRSZWYodmFsdWUsIGRlZnMuZ3JhZGllbnQsICcnKTtcbiAgICAgIH1cblxuICAgICAgc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzO1xufVxuXG5jb25zdCBDYW52YXMgPSAnY2FudmFzJztcbmNvbnN0IFBORyA9ICdwbmcnO1xuY29uc3QgU1ZHID0gJ3N2Zyc7XG5jb25zdCBOb25lID0gJ25vbmUnO1xuY29uc3QgUmVuZGVyVHlwZSA9IHtcbiAgQ2FudmFzOiBDYW52YXMsXG4gIFBORzogUE5HLFxuICBTVkc6IFNWRyxcbiAgTm9uZTogTm9uZVxufTtcbmNvbnN0IG1vZHVsZXMgPSB7fTtcbm1vZHVsZXNbQ2FudmFzXSA9IG1vZHVsZXNbUE5HXSA9IHtcbiAgcmVuZGVyZXI6IENhbnZhc1JlbmRlcmVyLFxuICBoZWFkbGVzczogQ2FudmFzUmVuZGVyZXIsXG4gIGhhbmRsZXI6IENhbnZhc0hhbmRsZXJcbn07XG5tb2R1bGVzW1NWR10gPSB7XG4gIHJlbmRlcmVyOiBTVkdSZW5kZXJlcixcbiAgaGVhZGxlc3M6IFNWR1N0cmluZ1JlbmRlcmVyLFxuICBoYW5kbGVyOiBTVkdIYW5kbGVyXG59O1xubW9kdWxlc1tOb25lXSA9IHt9O1xuZnVuY3Rpb24gcmVuZGVyTW9kdWxlKG5hbWUsIF8pIHtcbiAgbmFtZSA9IFN0cmluZyhuYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIG1vZHVsZXNbbmFtZV0gPSBfO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtb2R1bGVzW25hbWVdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdChzY2VuZSwgYm91bmRzLCBmaWx0ZXIpIHtcbiAgY29uc3QgaGl0cyA9IFtdLFxuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gcmVzdWx0c1xuICBib3ggPSBuZXcgQm91bmRzKCkudW5pb24oYm91bmRzKSxcbiAgICAgICAgLy8gZGVmZW5zaXZlIGNvcHlcbiAgdHlwZSA9IHNjZW5lLm1hcmt0eXBlO1xuICByZXR1cm4gdHlwZSA/IGludGVyc2VjdE1hcmsoc2NlbmUsIGJveCwgZmlsdGVyLCBoaXRzKSA6IHR5cGUgPT09ICdncm91cCcgPyBpbnRlcnNlY3RHcm91cChzY2VuZSwgYm94LCBmaWx0ZXIsIGhpdHMpIDogZXJyb3IoJ0ludGVyc2VjdCBzY2VuZSBtdXN0IGJlIG1hcmsgbm9kZSBvciBncm91cCBpdGVtLicpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RNYXJrKG1hcmssIGJveCwgZmlsdGVyLCBoaXRzKSB7XG4gIGlmICh2aXNpdE1hcmsobWFyaywgYm94LCBmaWx0ZXIpKSB7XG4gICAgY29uc3QgaXRlbXMgPSBtYXJrLml0ZW1zLFxuICAgICAgICAgIHR5cGUgPSBtYXJrLm1hcmt0eXBlLFxuICAgICAgICAgIG4gPSBpdGVtcy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgaWYgKHR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGludGVyc2VjdEdyb3VwKGl0ZW1zW2ldLCBib3gsIGZpbHRlciwgaGl0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgdGVzdCA9IE1hcmtzW3R5cGVdLmlzZWN0OyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGludGVyc2VjdEl0ZW0oaXRlbSwgYm94LCB0ZXN0KSkgaGl0cy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoaXRzO1xufVxuXG5mdW5jdGlvbiB2aXNpdE1hcmsobWFyaywgYm94LCBmaWx0ZXIpIHtcbiAgLy8gcHJvY2VzcyBpZiBib3VuZHMgaW50ZXJzZWN0IGFuZCBpZlxuICAvLyAoMSkgbWFyayBpcyBhIGdyb3VwIG1hcmsgKHNvIHdlIG11c3QgcmVjdXJzZSksIG9yXG4gIC8vICgyKSBtYXJrIGlzIGludGVyYWN0aXZlIGFuZCBwYXNzZXMgZmlsdGVyXG4gIHJldHVybiBtYXJrLmJvdW5kcyAmJiBib3guaW50ZXJzZWN0cyhtYXJrLmJvdW5kcykgJiYgKG1hcmsubWFya3R5cGUgPT09ICdncm91cCcgfHwgbWFyay5pbnRlcmFjdGl2ZSAhPT0gZmFsc2UgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKG1hcmspKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdEdyb3VwKGdyb3VwLCBib3gsIGZpbHRlciwgaGl0cykge1xuICAvLyB0ZXN0IGludGVyc2VjdCBhZ2FpbnN0IGdyb3VwXG4gIC8vIHNraXAgZ3JvdXBzIGJ5IGRlZmF1bHQgdW5sZXNzIGZpbHRlciBzYXlzIG90aGVyd2lzZVxuICBpZiAoZmlsdGVyICYmIGZpbHRlcihncm91cC5tYXJrKSAmJiBpbnRlcnNlY3RJdGVtKGdyb3VwLCBib3gsIE1hcmtzLmdyb3VwLmlzZWN0KSkge1xuICAgIGhpdHMucHVzaChncm91cCk7XG4gIH0gLy8gcmVjdXJzaXZlbHkgdGVzdCBjaGlsZHJlbiBtYXJrc1xuICAvLyB0cmFuc2xhdGUgYm94IHRvIGdyb3VwIGNvb3JkaW5hdGUgc3BhY2VcblxuXG4gIGNvbnN0IG1hcmtzID0gZ3JvdXAuaXRlbXMsXG4gICAgICAgIG4gPSBtYXJrcyAmJiBtYXJrcy5sZW5ndGg7XG5cbiAgaWYgKG4pIHtcbiAgICBjb25zdCB4ID0gZ3JvdXAueCB8fCAwLFxuICAgICAgICAgIHkgPSBncm91cC55IHx8IDA7XG4gICAgYm94LnRyYW5zbGF0ZSgteCwgLXkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGludGVyc2VjdE1hcmsobWFya3NbaV0sIGJveCwgZmlsdGVyLCBoaXRzKTtcbiAgICB9XG5cbiAgICBib3gudHJhbnNsYXRlKHgsIHkpO1xuICB9XG5cbiAgcmV0dXJuIGhpdHM7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdEl0ZW0oaXRlbSwgYm94LCB0ZXN0KSB7XG4gIC8vIHRlc3QgYm91bmRzIGVuY2xvc3VyZSwgYm91bmRzIGludGVyc2VjdGlvbiwgdGhlbiBkZXRhaWxlZCB0ZXN0XG4gIGNvbnN0IGJvdW5kcyA9IGl0ZW0uYm91bmRzO1xuICByZXR1cm4gYm94LmVuY2xvc2VzKGJvdW5kcykgfHwgYm94LmludGVyc2VjdHMoYm91bmRzKSAmJiB0ZXN0KGl0ZW0sIGJveCk7XG59XG5cbmNvbnN0IGNsaXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5mdW5jdGlvbiBib3VuZENsaXAgKG1hcmspIHtcbiAgY29uc3QgY2xpcCA9IG1hcmsuY2xpcDtcblxuICBpZiAoaXNGdW5jdGlvbihjbGlwKSkge1xuICAgIGNsaXAoYm91bmRDb250ZXh0KGNsaXBCb3VuZHMuY2xlYXIoKSkpO1xuICB9IGVsc2UgaWYgKGNsaXApIHtcbiAgICBjbGlwQm91bmRzLnNldCgwLCAwLCBtYXJrLmdyb3VwLndpZHRoLCBtYXJrLmdyb3VwLmhlaWdodCk7XG4gIH0gZWxzZSByZXR1cm47XG5cbiAgbWFyay5ib3VuZHMuaW50ZXJzZWN0KGNsaXBCb3VuZHMpO1xufVxuXG5jb25zdCBUT0xFUkFOQ0UgPSAxZS05O1xuZnVuY3Rpb24gc2NlbmVFcXVhbChhLCBiLCBrZXkpIHtcbiAgcmV0dXJuIGEgPT09IGIgPyB0cnVlIDoga2V5ID09PSAncGF0aCcgPyBwYXRoRXF1YWwoYSwgYikgOiBhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSA/ICthID09PSArYiA6IGlzTnVtYmVyKGEpICYmIGlzTnVtYmVyKGIpID8gTWF0aC5hYnMoYSAtIGIpIDw9IFRPTEVSQU5DRSA6ICFhIHx8ICFiIHx8ICFpc09iamVjdChhKSAmJiAhaXNPYmplY3QoYikgPyBhID09IGIgOiBvYmplY3RFcXVhbChhLCBiKTtcbn1cbmZ1bmN0aW9uIHBhdGhFcXVhbChhLCBiKSB7XG4gIHJldHVybiBzY2VuZUVxdWFsKHBhdGhQYXJzZShhKSwgcGF0aFBhcnNlKGIpKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0RXF1YWwoYSwgYikge1xuICB2YXIga2EgPSBPYmplY3Qua2V5cyhhKSxcbiAgICAgIGtiID0gT2JqZWN0LmtleXMoYiksXG4gICAgICBrZXksXG4gICAgICBpO1xuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG5cbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFzY2VuZUVxdWFsKGFba2V5XSwgYltrZXldLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG5mdW5jdGlvbiByZXNldFNWR0RlZklkcygpIHtcbiAgcmVzZXRTVkdDbGlwSWQoKTtcbiAgcmVzZXRTVkdHcmFkaWVudElkKCk7XG59XG5cbmV4cG9ydCB7IEJvdW5kcywgQ2FudmFzSGFuZGxlciwgQ2FudmFzUmVuZGVyZXIsIEdyYWRpZW50LCBHcm91cEl0ZW0sIEhhbmRsZXIsIEl0ZW0sIE1hcmtzLCBSZW5kZXJUeXBlLCBSZW5kZXJlciwgUmVzb3VyY2VMb2FkZXIsIFNWR0hhbmRsZXIsIFNWR1JlbmRlcmVyLCBTVkdTdHJpbmdSZW5kZXJlciwgU2NlbmVncmFwaCwgYm91bmRDbGlwLCBib3VuZENvbnRleHQsIGJvdW5kSXRlbSwgYm91bmRNYXJrLCBib3VuZFN0cm9rZSwgZG9tQ2hpbGQsIGRvbUNsZWFyLCBkb21DcmVhdGUsIGRvbUZpbmQsIGZvbnQsIGZvbnRGYW1pbHksIGZvbnRTaXplLCBpbnRlcnNlY3QsIGludGVyc2VjdEJveExpbmUsIGludGVyc2VjdFBhdGgsIGludGVyc2VjdFBvaW50LCBpbnRlcnNlY3RSdWxlLCBsaW5lSGVpZ2h0LCBtYXJrdXAsIG11bHRpTGluZU9mZnNldCwgY3VydmVzIGFzIHBhdGhDdXJ2ZXMsIHBhdGhFcXVhbCwgcGF0aFBhcnNlLCB2Z19yZWN0IGFzIHBhdGhSZWN0YW5nbGUsIHBhdGhSZW5kZXIsIHN5bWJvbHMgYXMgcGF0aFN5bWJvbHMsIHZnX3RyYWlsIGFzIHBhdGhUcmFpbCwgcG9pbnQsIHJlbmRlck1vZHVsZSwgcmVzZXRTVkdDbGlwSWQsIHJlc2V0U1ZHRGVmSWRzLCBzY2VuZUVxdWFsLCBzY2VuZUZyb21KU09OLCBwaWNrVmlzaXQgYXMgc2NlbmVQaWNrVmlzaXQsIHNjZW5lVG9KU09OLCB2aXNpdCBhcyBzY2VuZVZpc2l0LCB6b3JkZXIgYXMgc2NlbmVaT3JkZXIsIHNlcmlhbGl6ZVhNTCwgdGV4dE1ldHJpY3MgfTtcbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHthYnMsIGFjb3MsIGFzaW4sIGF0YW4yLCBjb3MsIGVwc2lsb24sIGhhbGZQaSwgbWF4LCBtaW4sIHBpLCBzaW4sIHNxcnQsIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBhcmNJbm5lclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLmlubmVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNPdXRlclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLm91dGVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNTdGFydEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuc3RhcnRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjRW5kQW5nbGUoZCkge1xuICByZXR1cm4gZC5lbmRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjUGFkQW5nbGUoZCkge1xuICByZXR1cm4gZCAmJiBkLnBhZEFuZ2xlOyAvLyBOb3RlOiBvcHRpb25hbCFcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgeDEwID0geDEgLSB4MCwgeTEwID0geTEgLSB5MCxcbiAgICAgIHgzMiA9IHgzIC0geDIsIHkzMiA9IHkzIC0geTIsXG4gICAgICB0ID0geTMyICogeDEwIC0geDMyICogeTEwO1xuICBpZiAodCAqIHQgPCBlcHNpbG9uKSByZXR1cm47XG4gIHQgPSAoeDMyICogKHkwIC0geTIpIC0geTMyICogKHgwIC0geDIpKSAvIHQ7XG4gIHJldHVybiBbeDAgKyB0ICogeDEwLCB5MCArIHQgKiB5MTBdO1xufVxuXG4vLyBDb21wdXRlIHBlcnBlbmRpY3VsYXIgb2Zmc2V0IGxpbmUgb2YgbGVuZ3RoIHJjLlxuLy8gaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9DaXJjbGUtTGluZUludGVyc2VjdGlvbi5odG1sXG5mdW5jdGlvbiBjb3JuZXJUYW5nZW50cyh4MCwgeTAsIHgxLCB5MSwgcjEsIHJjLCBjdykge1xuICB2YXIgeDAxID0geDAgLSB4MSxcbiAgICAgIHkwMSA9IHkwIC0geTEsXG4gICAgICBsbyA9IChjdyA/IHJjIDogLXJjKSAvIHNxcnQoeDAxICogeDAxICsgeTAxICogeTAxKSxcbiAgICAgIG94ID0gbG8gKiB5MDEsXG4gICAgICBveSA9IC1sbyAqIHgwMSxcbiAgICAgIHgxMSA9IHgwICsgb3gsXG4gICAgICB5MTEgPSB5MCArIG95LFxuICAgICAgeDEwID0geDEgKyBveCxcbiAgICAgIHkxMCA9IHkxICsgb3ksXG4gICAgICB4MDAgPSAoeDExICsgeDEwKSAvIDIsXG4gICAgICB5MDAgPSAoeTExICsgeTEwKSAvIDIsXG4gICAgICBkeCA9IHgxMCAtIHgxMSxcbiAgICAgIGR5ID0geTEwIC0geTExLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgIHIgPSByMSAtIHJjLFxuICAgICAgRCA9IHgxMSAqIHkxMCAtIHgxMCAqIHkxMSxcbiAgICAgIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIHNxcnQobWF4KDAsIHIgKiByICogZDIgLSBEICogRCkpLFxuICAgICAgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLFxuICAgICAgY3gxID0gKEQgKiBkeSArIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLFxuICAgICAgZHgwID0gY3gwIC0geDAwLFxuICAgICAgZHkwID0gY3kwIC0geTAwLFxuICAgICAgZHgxID0gY3gxIC0geDAwLFxuICAgICAgZHkxID0gY3kxIC0geTAwO1xuXG4gIC8vIFBpY2sgdGhlIGNsb3NlciBvZiB0aGUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gIC8vIFRPRE8gSXMgdGhlcmUgYSBmYXN0ZXIgd2F5IHRvIGRldGVybWluZSB3aGljaCBpbnRlcnNlY3Rpb24gdG8gdXNlP1xuICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcblxuICByZXR1cm4ge1xuICAgIGN4OiBjeDAsXG4gICAgY3k6IGN5MCxcbiAgICB4MDE6IC1veCxcbiAgICB5MDE6IC1veSxcbiAgICB4MTE6IGN4MCAqIChyMSAvIHIgLSAxKSxcbiAgICB5MTE6IGN5MCAqIChyMSAvIHIgLSAxKVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGlubmVyUmFkaXVzID0gYXJjSW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IGFyY091dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gY29uc3RhbnQoMCksXG4gICAgICBwYWRSYWRpdXMgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGFyY1N0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IGFyY0VuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBhcmNQYWRBbmdsZSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyYygpIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICByLFxuICAgICAgICByMCA9ICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBkYSA9IGFicyhhMSAtIGEwKSxcbiAgICAgICAgY3cgPSBhMSA+IGEwO1xuXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIG91dGVyIHJhZGl1cyBpcyBhbHdheXMgbGFyZ2VyIHRoYW4gdGhlIGlubmVyIHJhZGl1cy5cbiAgICBpZiAocjEgPCByMCkgciA9IHIxLCByMSA9IHIwLCByMCA9IHI7XG5cbiAgICAvLyBJcyBpdCBhIHBvaW50P1xuICAgIGlmICghKHIxID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKDAsIDApO1xuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjbGUgb3IgYW5udWx1cz9cbiAgICBlbHNlIGlmIChkYSA+IHRhdSAtIGVwc2lsb24pIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHIxICogY29zKGEwKSwgcjEgKiBzaW4oYTApKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMCwgYTEsICFjdyk7XG4gICAgICBpZiAocjAgPiBlcHNpbG9uKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHIwICogY29zKGExKSwgcjAgKiBzaW4oYTEpKTtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExLCBhMCwgY3cpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY3VsYXIgb3IgYW5udWxhciBzZWN0b3I/XG4gICAgZWxzZSB7XG4gICAgICB2YXIgYTAxID0gYTAsXG4gICAgICAgICAgYTExID0gYTEsXG4gICAgICAgICAgYTAwID0gYTAsXG4gICAgICAgICAgYTEwID0gYTEsXG4gICAgICAgICAgZGEwID0gZGEsXG4gICAgICAgICAgZGExID0gZGEsXG4gICAgICAgICAgYXAgPSBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC8gMixcbiAgICAgICAgICBycCA9IChhcCA+IGVwc2lsb24pICYmIChwYWRSYWRpdXMgPyArcGFkUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBzcXJ0KHIwICogcjAgKyByMSAqIHIxKSksXG4gICAgICAgICAgcmMgPSBtaW4oYWJzKHIxIC0gcjApIC8gMiwgK2Nvcm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgICByYzAgPSByYyxcbiAgICAgICAgICByYzEgPSByYyxcbiAgICAgICAgICB0MCxcbiAgICAgICAgICB0MTtcblxuICAgICAgLy8gQXBwbHkgcGFkZGluZz8gTm90ZSB0aGF0IHNpbmNlIHIxIOKJpSByMCwgZGExIOKJpSBkYTAuXG4gICAgICBpZiAocnAgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciBwMCA9IGFzaW4ocnAgLyByMCAqIHNpbihhcCkpLFxuICAgICAgICAgICAgcDEgPSBhc2luKHJwIC8gcjEgKiBzaW4oYXApKTtcbiAgICAgICAgaWYgKChkYTAgLT0gcDAgKiAyKSA+IGVwc2lsb24pIHAwICo9IChjdyA/IDEgOiAtMSksIGEwMCArPSBwMCwgYTEwIC09IHAwO1xuICAgICAgICBlbHNlIGRhMCA9IDAsIGEwMCA9IGExMCA9IChhMCArIGExKSAvIDI7XG4gICAgICAgIGlmICgoZGExIC09IHAxICogMikgPiBlcHNpbG9uKSBwMSAqPSAoY3cgPyAxIDogLTEpLCBhMDEgKz0gcDEsIGExMSAtPSBwMTtcbiAgICAgICAgZWxzZSBkYTEgPSAwLCBhMDEgPSBhMTEgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgeDAxID0gcjEgKiBjb3MoYTAxKSxcbiAgICAgICAgICB5MDEgPSByMSAqIHNpbihhMDEpLFxuICAgICAgICAgIHgxMCA9IHIwICogY29zKGExMCksXG4gICAgICAgICAgeTEwID0gcjAgKiBzaW4oYTEwKTtcblxuICAgICAgLy8gQXBwbHkgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgaWYgKHJjID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgeDExID0gcjEgKiBjb3MoYTExKSxcbiAgICAgICAgICAgIHkxMSA9IHIxICogc2luKGExMSksXG4gICAgICAgICAgICB4MDAgPSByMCAqIGNvcyhhMDApLFxuICAgICAgICAgICAgeTAwID0gcjAgKiBzaW4oYTAwKSxcbiAgICAgICAgICAgIG9jO1xuXG4gICAgICAgIC8vIFJlc3RyaWN0IHRoZSBjb3JuZXIgcmFkaXVzIGFjY29yZGluZyB0byB0aGUgc2VjdG9yIGFuZ2xlLlxuICAgICAgICBpZiAoZGEgPCBwaSAmJiAob2MgPSBpbnRlcnNlY3QoeDAxLCB5MDEsIHgwMCwgeTAwLCB4MTEsIHkxMSwgeDEwLCB5MTApKSkge1xuICAgICAgICAgIHZhciBheCA9IHgwMSAtIG9jWzBdLFxuICAgICAgICAgICAgICBheSA9IHkwMSAtIG9jWzFdLFxuICAgICAgICAgICAgICBieCA9IHgxMSAtIG9jWzBdLFxuICAgICAgICAgICAgICBieSA9IHkxMSAtIG9jWzFdLFxuICAgICAgICAgICAgICBrYyA9IDEgLyBzaW4oYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKHNxcnQoYXggKiBheCArIGF5ICogYXkpICogc3FydChieCAqIGJ4ICsgYnkgKiBieSkpKSAvIDIpLFxuICAgICAgICAgICAgICBsYyA9IHNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgIHJjMCA9IG1pbihyYywgKHIwIC0gbGMpIC8gKGtjIC0gMSkpO1xuICAgICAgICAgIHJjMSA9IG1pbihyYywgKHIxIC0gbGMpIC8gKGtjICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElzIHRoZSBzZWN0b3IgY29sbGFwc2VkIHRvIGEgbGluZT9cbiAgICAgIGlmICghKGRhMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgb3V0ZXIgcmluZyBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMSA+IGVwc2lsb24pIHtcbiAgICAgICAgdDAgPSBjb3JuZXJUYW5nZW50cyh4MDAsIHkwMCwgeDAxLCB5MDEsIHIxLCByYzEsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MTEsIHkxMSwgeDEwLCB5MTAsIHIxLCByYzEsIGN3KTtcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICBpZiAocmMxIDwgcmMpIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMxLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgb3V0ZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSksIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMDEsIGExMSwgIWN3KTtcblxuICAgICAgLy8gSXMgdGhlcmUgbm8gaW5uZXIgcmluZywgYW5kIGl04oCZcyBhIGNpcmN1bGFyIHNlY3Rvcj9cbiAgICAgIC8vIE9yIHBlcmhhcHMgaXTigJlzIGFuIGFubnVsYXIgc2VjdG9yIGNvbGxhcHNlZCBkdWUgdG8gcGFkZGluZz9cbiAgICAgIGlmICghKHIwID4gZXBzaWxvbikgfHwgIShkYTAgPiBlcHNpbG9uKSkgY29udGV4dC5saW5lVG8oeDEwLCB5MTApO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIGlubmVyIHJpbmcgKG9yIHBvaW50KSBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMCA+IGVwc2lsb24pIHtcbiAgICAgICAgdDAgPSBjb3JuZXJUYW5nZW50cyh4MTAsIHkxMCwgeDExLCB5MTEsIHIwLCAtcmMwLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDAxLCB5MDEsIHgwMCwgeTAwLCByMCwgLXJjMCwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzAgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksIGN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMCwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExMCwgYTAwLCBjdyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLFxuICAgICAgICBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkgLyAyO1xuICAgIHJldHVybiBbY29zKGEpICogciwgc2luKGEpICogcl07XG4gIH07XG5cbiAgYXJjLmlubmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlubmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBpbm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3V0ZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IG91dGVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29ybmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBjb3JuZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnBhZFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRSYWRpdXMgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBhcmMuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgYXJjLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIGFyYykgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmM7XG59XG4iLCJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgYXJyYXkgZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2N1cnZlL2xpbmVhci5qc1wiO1xuaW1wb3J0IGxpbmUgZnJvbSBcIi4vbGluZS5qc1wiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuL3BvaW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgwLCB5MCwgeTEpIHtcbiAgdmFyIHgxID0gbnVsbCxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgeDAgPSB0eXBlb2YgeDAgPT09IFwiZnVuY3Rpb25cIiA/IHgwIDogKHgwID09PSB1bmRlZmluZWQpID8gcG9pbnRYIDogY29uc3RhbnQoK3gwKTtcbiAgeTAgPSB0eXBlb2YgeTAgPT09IFwiZnVuY3Rpb25cIiA/IHkwIDogKHkwID09PSB1bmRlZmluZWQpID8gY29uc3RhbnQoMCkgOiBjb25zdGFudCgreTApO1xuICB5MSA9IHR5cGVvZiB5MSA9PT0gXCJmdW5jdGlvblwiID8geTEgOiAoeTEgPT09IHVuZGVmaW5lZCkgPyBwb2ludFkgOiBjb25zdGFudCgreTEpO1xuXG4gIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBuID0gKGRhdGEgPSBhcnJheShkYXRhKSkubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHgweiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgeTB6ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkge1xuICAgICAgICAgIGogPSBpO1xuICAgICAgICAgIG91dHB1dC5hcmVhU3RhcnQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChrID0gaSAtIDE7IGsgPj0gajsgLS1rKSB7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnQoeDB6W2tdLCB5MHpba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5hcmVhRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkge1xuICAgICAgICB4MHpbaV0gPSAreDAoZCwgaSwgZGF0YSksIHkweltpXSA9ICt5MChkLCBpLCBkYXRhKTtcbiAgICAgICAgb3V0cHV0LnBvaW50KHgxID8gK3gxKGQsIGksIGRhdGEpIDogeDB6W2ldLCB5MSA/ICt5MShkLCBpLCBkYXRhKSA6IHkweltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWFsaW5lKCkge1xuICAgIHJldHVybiBsaW5lKCkuZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZSkuY29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB4MSA9IG51bGwsIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDE7XG4gIH07XG5cbiAgYXJlYS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHkxID0gbnVsbCwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMCA9XG4gIGFyZWEubGluZVkwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5saW5lWTEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkxKTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDEpLnkoeTApO1xuICB9O1xuXG4gIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBhcmVhKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgYXJlYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBhcmVhKSA6IGN1cnZlO1xuICB9O1xuXG4gIGFyZWEuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgYXJlYSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmVhO1xufVxuIiwiZXhwb3J0IHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgXCJsZW5ndGhcIiBpbiB4XG4gICAgPyB4IC8vIEFycmF5LCBUeXBlZEFycmF5LCBOb2RlTGlzdCwgYXJyYXktbGlrZVxuICAgIDogQXJyYXkuZnJvbSh4KTsgLy8gTWFwLCBTZXQsIGl0ZXJhYmxlLCBzdHJpbmcsIG9yIGFueXRoaW5nIGVsc2Vcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0YW50KCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgICgyICogdGhhdC5feDAgKyB0aGF0Ll94MSkgLyAzLFxuICAgICgyICogdGhhdC5feTAgKyB0aGF0Ll95MSkgLyAzLFxuICAgICh0aGF0Ll94MCArIDIgKiB0aGF0Ll94MSkgLyAzLFxuICAgICh0aGF0Ll95MCArIDIgKiB0aGF0Ll95MSkgLyAzLFxuICAgICh0aGF0Ll94MCArIDQgKiB0aGF0Ll94MSArIHgpIC8gNixcbiAgICAodGhhdC5feTAgKyA0ICogdGhhdC5feTEgKyB5KSAvIDZcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEJhc2lzKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyAvLyBwcm9jZWVkXG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5fY29udGV4dC5saW5lVG8oKDUgKiB0aGlzLl94MCArIHRoaXMuX3gxKSAvIDYsICg1ICogdGhpcy5feTAgKyB0aGlzLl95MSkgLyA2KTsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXMoY29udGV4dCk7XG59XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZnVuY3Rpb24gQmFzaXNDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDIgKyAyICogdGhpcy5feDMpIC8gMywgKHRoaXMuX3kyICsgMiAqIHRoaXMuX3kzKSAvIDMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbygodGhpcy5feDMgKyAyICogdGhpcy5feDIpIC8gMywgKHRoaXMuX3kzICsgMiAqIHRoaXMuX3kyKSAvIDMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gyID0geCwgdGhpcy5feTIgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHk7IHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIHgpIC8gNiwgKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgeSkgLyA2KTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc0Nsb3NlZChjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5cbmZ1bmN0aW9uIEJhc2lzT3Blbihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpc09wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB2YXIgeDAgPSAodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsIHkwID0gKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgeSkgLyA2OyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeDAsIHkwKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgwLCB5MCk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzT3Blbihjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7QmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5cbmZ1bmN0aW9uIEJ1bmRsZShjb250ZXh0LCBiZXRhKSB7XG4gIHRoaXMuX2Jhc2lzID0gbmV3IEJhc2lzKGNvbnRleHQpO1xuICB0aGlzLl9iZXRhID0gYmV0YTtcbn1cblxuQnVuZGxlLnByb3RvdHlwZSA9IHtcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW107XG4gICAgdGhpcy5feSA9IFtdO1xuICAgIHRoaXMuX2Jhc2lzLmxpbmVTdGFydCgpO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgIHkgPSB0aGlzLl95LFxuICAgICAgICBqID0geC5sZW5ndGggLSAxO1xuXG4gICAgaWYgKGogPiAwKSB7XG4gICAgICB2YXIgeDAgPSB4WzBdLFxuICAgICAgICAgIHkwID0geVswXSxcbiAgICAgICAgICBkeCA9IHhbal0gLSB4MCxcbiAgICAgICAgICBkeSA9IHlbal0gLSB5MCxcbiAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgdDtcblxuICAgICAgd2hpbGUgKCsraSA8PSBqKSB7XG4gICAgICAgIHQgPSBpIC8gajtcbiAgICAgICAgdGhpcy5fYmFzaXMucG9pbnQoXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHhbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHgwICsgdCAqIGR4KSxcbiAgICAgICAgICB0aGlzLl9iZXRhICogeVtpXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoeTAgKyB0ICogZHkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICAgIHRoaXMuX2Jhc2lzLmxpbmVFbmQoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl94LnB1c2goK3gpO1xuICAgIHRoaXMuX3kucHVzaCgreSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYmV0YSkge1xuXG4gIGZ1bmN0aW9uIGJ1bmRsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGJldGEgPT09IDEgPyBuZXcgQmFzaXMoY29udGV4dCkgOiBuZXcgQnVuZGxlKGNvbnRleHQsIGJldGEpO1xuICB9XG5cbiAgYnVuZGxlLmJldGEgPSBmdW5jdGlvbihiZXRhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYmV0YSk7XG4gIH07XG5cbiAgcmV0dXJuIGJ1bmRsZTtcbn0pKDAuODUpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgIHRoYXQuX3gxICsgdGhhdC5fayAqICh0aGF0Ll94MiAtIHRoYXQuX3gwKSxcbiAgICB0aGF0Ll95MSArIHRoYXQuX2sgKiAodGhhdC5feTIgLSB0aGF0Ll95MCksXG4gICAgdGhhdC5feDIgKyB0aGF0Ll9rICogKHRoYXQuX3gxIC0geCksXG4gICAgdGhhdC5feTIgKyB0aGF0Ll9rICogKHRoYXQuX3kxIC0geSksXG4gICAgdGhhdC5feDIsXG4gICAgdGhhdC5feTJcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl94MSA9IHgsIHRoaXMuX3kxID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vY2FyZGluYWwuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHkpOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NSA9IHgsIHRoaXMuX3k1ID0geTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcbiIsImltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhcmRpbmFsLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbE9wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG4iLCJpbXBvcnQge2Vwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge0NhcmRpbmFsfSBmcm9tIFwiLi9jYXJkaW5hbC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnQodGhhdCwgeCwgeSkge1xuICB2YXIgeDEgPSB0aGF0Ll94MSxcbiAgICAgIHkxID0gdGhhdC5feTEsXG4gICAgICB4MiA9IHRoYXQuX3gyLFxuICAgICAgeTIgPSB0aGF0Ll95MjtcblxuICBpZiAodGhhdC5fbDAxX2EgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGEgPSAyICogdGhhdC5fbDAxXzJhICsgMyAqIHRoYXQuX2wwMV9hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXG4gICAgICAgIG4gPSAzICogdGhhdC5fbDAxX2EgKiAodGhhdC5fbDAxX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgeDEgPSAoeDEgKiBhIC0gdGhhdC5feDAgKiB0aGF0Ll9sMTJfMmEgKyB0aGF0Ll94MiAqIHRoYXQuX2wwMV8yYSkgLyBuO1xuICAgIHkxID0gKHkxICogYSAtIHRoYXQuX3kwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feTIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgfVxuXG4gIGlmICh0aGF0Ll9sMjNfYSA+IGVwc2lsb24pIHtcbiAgICB2YXIgYiA9IDIgKiB0aGF0Ll9sMjNfMmEgKyAzICogdGhhdC5fbDIzX2EgKiB0aGF0Ll9sMTJfYSArIHRoYXQuX2wxMl8yYSxcbiAgICAgICAgbSA9IDMgKiB0aGF0Ll9sMjNfYSAqICh0aGF0Ll9sMjNfYSArIHRoYXQuX2wxMl9hKTtcbiAgICB4MiA9ICh4MiAqIGIgKyB0aGF0Ll94MSAqIHRoYXQuX2wyM18yYSAtIHggKiB0aGF0Ll9sMTJfMmEpIC8gbTtcbiAgICB5MiA9ICh5MiAqIGIgKyB0aGF0Ll95MSAqIHRoYXQuX2wyM18yYSAtIHkgKiB0aGF0Ll9sMTJfMmEpIC8gbTtcbiAgfVxuXG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgdGhhdC5feDIsIHRoYXQuX3kyKTtcbn1cblxuZnVuY3Rpb24gQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbS5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYTtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XG5cbiAgZnVuY3Rpb24gY2F0bXVsbFJvbShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkoMC41KTtcbiIsImltcG9ydCB7Q2FyZGluYWxDbG9zZWR9IGZyb20gXCIuL2NhcmRpbmFsQ2xvc2VkLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vY2F0bXVsbFJvbS5qc1wiO1xuXG5mdW5jdGlvbiBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHkpOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NSA9IHgsIHRoaXMuX3k1ID0geTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYTtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XG5cbiAgZnVuY3Rpb24gY2F0bXVsbFJvbShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb21DbG9zZWQoY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkoMC41KTtcbiIsImltcG9ydCB7Q2FyZGluYWxPcGVufSBmcm9tIFwiLi9jYXJkaW5hbE9wZW4uanNcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhdG11bGxSb20uanNcIjtcblxuZnVuY3Rpb24gQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb21PcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYTtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XG5cbiAgZnVuY3Rpb24gY2F0bXVsbFJvbShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuIiwiZnVuY3Rpb24gTGluZWFyKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkxpbmVhci5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhcihjb250ZXh0KTtcbn1cbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbmZ1bmN0aW9uIExpbmVhckNsb3NlZChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXJDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcG9pbnQpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgaWYgKHRoaXMuX3BvaW50KSB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICBlbHNlIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXJDbG9zZWQoY29udGV4dCk7XG59XG4iLCJmdW5jdGlvbiBzaWduKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLTEgOiAxO1xufVxuXG4vLyBDYWxjdWxhdGUgdGhlIHNsb3BlcyBvZiB0aGUgdGFuZ2VudHMgKEhlcm1pdGUtdHlwZSBpbnRlcnBvbGF0aW9uKSBiYXNlZCBvblxuLy8gdGhlIGZvbGxvd2luZyBwYXBlcjogU3RlZmZlbiwgTS4gMTk5MC4gQSBTaW1wbGUgTWV0aG9kIGZvciBNb25vdG9uaWNcbi8vIEludGVycG9sYXRpb24gaW4gT25lIERpbWVuc2lvbi4gQXN0cm9ub215IGFuZCBBc3Ryb3BoeXNpY3MsIFZvbC4gMjM5LCBOTy5cbi8vIE5PVihJSSksIFAuIDQ0MywgMTk5MC5cbmZ1bmN0aW9uIHNsb3BlMyh0aGF0LCB4MiwgeTIpIHtcbiAgdmFyIGgwID0gdGhhdC5feDEgLSB0aGF0Ll94MCxcbiAgICAgIGgxID0geDIgLSB0aGF0Ll94MSxcbiAgICAgIHMwID0gKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gKGgwIHx8IGgxIDwgMCAmJiAtMCksXG4gICAgICBzMSA9ICh5MiAtIHRoYXQuX3kxKSAvIChoMSB8fCBoMCA8IDAgJiYgLTApLFxuICAgICAgcCA9IChzMCAqIGgxICsgczEgKiBoMCkgLyAoaDAgKyBoMSk7XG4gIHJldHVybiAoc2lnbihzMCkgKyBzaWduKHMxKSkgKiBNYXRoLm1pbihNYXRoLmFicyhzMCksIE1hdGguYWJzKHMxKSwgMC41ICogTWF0aC5hYnMocCkpIHx8IDA7XG59XG5cbi8vIENhbGN1bGF0ZSBhIG9uZS1zaWRlZCBzbG9wZS5cbmZ1bmN0aW9uIHNsb3BlMih0aGF0LCB0KSB7XG4gIHZhciBoID0gdGhhdC5feDEgLSB0aGF0Ll94MDtcbiAgcmV0dXJuIGggPyAoMyAqICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIGggLSB0KSAvIDIgOiB0O1xufVxuXG4vLyBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfSGVybWl0ZV9zcGxpbmUjUmVwcmVzZW50YXRpb25zXG4vLyBcInlvdSBjYW4gZXhwcmVzcyBjdWJpYyBIZXJtaXRlIGludGVycG9sYXRpb24gaW4gdGVybXMgb2YgY3ViaWMgQsOpemllciBjdXJ2ZXNcbi8vIHdpdGggcmVzcGVjdCB0byB0aGUgZm91ciB2YWx1ZXMgcDAsIHAwICsgbTAgLyAzLCBwMSAtIG0xIC8gMywgcDFcIi5cbmZ1bmN0aW9uIHBvaW50KHRoYXQsIHQwLCB0MSkge1xuICB2YXIgeDAgPSB0aGF0Ll94MCxcbiAgICAgIHkwID0gdGhhdC5feTAsXG4gICAgICB4MSA9IHRoYXQuX3gxLFxuICAgICAgeTEgPSB0aGF0Ll95MSxcbiAgICAgIGR4ID0gKHgxIC0geDApIC8gMztcbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgwICsgZHgsIHkwICsgZHggKiB0MCwgeDEgLSBkeCwgeTEgLSBkeCAqIHQxLCB4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBNb25vdG9uZVgoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTW9ub3RvbmVYLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID1cbiAgICB0aGlzLl90MCA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3QwLCBzbG9wZTIodGhpcywgdGhpcy5fdDApKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHQxID0gTmFOO1xuXG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgaWYgKHggPT09IHRoaXMuX3gxICYmIHkgPT09IHRoaXMuX3kxKSByZXR1cm47IC8vIElnbm9yZSBjb2luY2lkZW50IHBvaW50cy5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHBvaW50KHRoaXMsIHNsb3BlMih0aGlzLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSksIHQxKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB0aGlzLl90MCwgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICAgIHRoaXMuX3QwID0gdDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gTW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IG5ldyBSZWZsZWN0Q29udGV4dChjb250ZXh0KTtcbn1cblxuKE1vbm90b25lWS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vbm90b25lWC5wcm90b3R5cGUpKS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgTW9ub3RvbmVYLnByb3RvdHlwZS5wb2ludC5jYWxsKHRoaXMsIHksIHgpO1xufTtcblxuZnVuY3Rpb24gUmVmbGVjdENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUmVmbGVjdENvbnRleHQucHJvdG90eXBlID0ge1xuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5tb3ZlVG8oeSwgeCk7IH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7IHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7IH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLl9jb250ZXh0LmxpbmVUbyh5LCB4KTsgfSxcbiAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHsgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHkxLCB4MSwgeTIsIHgyLCB5LCB4KTsgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vbm90b25lWChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVYKGNvbnRleHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBNb25vdG9uZVkoY29udGV4dCk7XG59XG4iLCJmdW5jdGlvbiBOYXR1cmFsKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk5hdHVyYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSBbXTtcbiAgICB0aGlzLl95ID0gW107XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgIG4gPSB4Lmxlbmd0aDtcblxuICAgIGlmIChuKSB7XG4gICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeFswXSwgeVswXSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4WzBdLCB5WzBdKTtcbiAgICAgIGlmIChuID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHhbMV0sIHlbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB4ID0gY29udHJvbFBvaW50cyh4KSxcbiAgICAgICAgICAgIHB5ID0gY29udHJvbFBvaW50cyh5KTtcbiAgICAgICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDE7IGkxIDwgbjsgKytpMCwgKytpMSkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhweFswXVtpMF0sIHB5WzBdW2kwXSwgcHhbMV1baTBdLCBweVsxXVtpMF0sIHhbaTFdLCB5W2kxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiBuID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgfVxufTtcblxuLy8gU2VlIGh0dHBzOi8vd3d3LnBhcnRpY2xlaW5jZWxsLmNvbS8yMDEyL2Jlemllci1zcGxpbmVzLyBmb3IgZGVyaXZhdGlvbi5cbmZ1bmN0aW9uIGNvbnRyb2xQb2ludHMoeCkge1xuICB2YXIgaSxcbiAgICAgIG4gPSB4Lmxlbmd0aCAtIDEsXG4gICAgICBtLFxuICAgICAgYSA9IG5ldyBBcnJheShuKSxcbiAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICByID0gbmV3IEFycmF5KG4pO1xuICBhWzBdID0gMCwgYlswXSA9IDIsIHJbMF0gPSB4WzBdICsgMiAqIHhbMV07XG4gIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgKytpKSBhW2ldID0gMSwgYltpXSA9IDQsIHJbaV0gPSA0ICogeFtpXSArIDIgKiB4W2kgKyAxXTtcbiAgYVtuIC0gMV0gPSAyLCBiW24gLSAxXSA9IDcsIHJbbiAtIDFdID0gOCAqIHhbbiAtIDFdICsgeFtuXTtcbiAgZm9yIChpID0gMTsgaSA8IG47ICsraSkgbSA9IGFbaV0gLyBiW2kgLSAxXSwgYltpXSAtPSBtLCByW2ldIC09IG0gKiByW2kgLSAxXTtcbiAgYVtuIC0gMV0gPSByW24gLSAxXSAvIGJbbiAtIDFdO1xuICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIGFbaV0gPSAocltpXSAtIGFbaSArIDFdKSAvIGJbaV07XG4gIGJbbiAtIDFdID0gKHhbbl0gKyBhW24gLSAxXSkgLyAyO1xuICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7ICsraSkgYltpXSA9IDIgKiB4W2kgKyAxXSAtIGFbaSArIDFdO1xuICByZXR1cm4gW2EsIGJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTmF0dXJhbChjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIFN0ZXAoY29udGV4dCwgdCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fdCA9IHQ7XG59XG5cblN0ZXAucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKDAgPCB0aGlzLl90ICYmIHRoaXMuX3QgPCAxICYmIHRoaXMuX3BvaW50ID09PSAyKSB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB0aGlzLl95KTtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgaWYgKHRoaXMuX2xpbmUgPj0gMCkgdGhpcy5fdCA9IDEgLSB0aGlzLl90LCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0aGlzLl90IDw9IDApIHtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB5KTtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgeDEgPSB0aGlzLl94ICogKDEgLSB0aGlzLl90KSArIHggKiB0aGlzLl90O1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB0aGlzLl95KTtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3ggPSB4LCB0aGlzLl95ID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMC41KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBCZWZvcmUoY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwQWZ0ZXIoY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMSk7XG59XG4iLCJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgYXJyYXkgZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2N1cnZlL2xpbmVhci5qc1wiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuL3BvaW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgeCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogKHggPT09IHVuZGVmaW5lZCkgPyBwb2ludFggOiBjb25zdGFudCh4KTtcbiAgeSA9IHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5IDogKHkgPT09IHVuZGVmaW5lZCkgPyBwb2ludFkgOiBjb25zdGFudCh5KTtcblxuICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IChkYXRhID0gYXJyYXkoZGF0YSkpLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICBlbHNlIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIG91dHB1dC5wb2ludCgreChkLCBpLCBkYXRhKSwgK3koZCwgaSwgZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBsaW5lLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHg7XG4gIH07XG5cbiAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB5O1xuICB9O1xuXG4gIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBsaW5lKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgbGluZS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xuICB9O1xuXG4gIGxpbmUuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluZSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5lO1xufVxuIiwiZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciBzaW4gPSBNYXRoLnNpbjtcbmV4cG9ydCB2YXIgc3FydCA9IE1hdGguc3FydDtcblxuZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciB0YXUgPSAyICogcGk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID49IDEgPyBoYWxmUGkgOiB4IDw9IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge31cbiIsImV4cG9ydCBmdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG4iLCJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgY2lyY2xlIGZyb20gXCIuL3N5bWJvbC9jaXJjbGUuanNcIjtcbmltcG9ydCBjcm9zcyBmcm9tIFwiLi9zeW1ib2wvY3Jvc3MuanNcIjtcbmltcG9ydCBkaWFtb25kIGZyb20gXCIuL3N5bWJvbC9kaWFtb25kLmpzXCI7XG5pbXBvcnQgc3RhciBmcm9tIFwiLi9zeW1ib2wvc3Rhci5qc1wiO1xuaW1wb3J0IHNxdWFyZSBmcm9tIFwiLi9zeW1ib2wvc3F1YXJlLmpzXCI7XG5pbXBvcnQgdHJpYW5nbGUgZnJvbSBcIi4vc3ltYm9sL3RyaWFuZ2xlLmpzXCI7XG5pbXBvcnQgd3llIGZyb20gXCIuL3N5bWJvbC93eWUuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgdmFyIHN5bWJvbHMgPSBbXG4gIGNpcmNsZSxcbiAgY3Jvc3MsXG4gIGRpYW1vbmQsXG4gIHNxdWFyZSxcbiAgc3RhcixcbiAgdHJpYW5nbGUsXG4gIHd5ZVxuXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICB2YXIgY29udGV4dCA9IG51bGw7XG4gIHR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiID8gdHlwZSA6IGNvbnN0YW50KHR5cGUgfHwgY2lyY2xlKTtcbiAgc2l6ZSA9IHR5cGVvZiBzaXplID09PSBcImZ1bmN0aW9uXCIgPyBzaXplIDogY29uc3RhbnQoc2l6ZSA9PT0gdW5kZWZpbmVkID8gNjQgOiArc2l6ZSk7XG5cbiAgZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCgpO1xuICAgIHR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKS5kcmF3KGNvbnRleHQsICtzaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHlwZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIHN5bWJvbCkgOiB0eXBlO1xuICB9O1xuXG4gIHN5bWJvbC5zaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNpemUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3ltYm9sKSA6IHNpemU7XG4gIH07XG5cbiAgc3ltYm9sLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfLCBzeW1ib2wpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gc3ltYm9sO1xufVxuIiwiaW1wb3J0IHtwaSwgdGF1fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gcGkpO1xuICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIHIsIDAsIHRhdSk7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsInZhciB0YW4zMCA9IE1hdGguc3FydCgxIC8gMyksXG4gICAgdGFuMzBfMiA9IHRhbjMwICogMjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSBNYXRoLnNxcnQoc2l6ZSAvIHRhbjMwXzIpLFxuICAgICAgICB4ID0geSAqIHRhbjMwO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcbiAgICBjb250ZXh0LmxpbmVUbygteCwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB3ID0gTWF0aC5zcXJ0KHNpemUpLFxuICAgICAgICB4ID0gLXcgLyAyO1xuICAgIGNvbnRleHQucmVjdCh4LCB4LCB3LCB3KTtcbiAgfVxufTtcbiIsImltcG9ydCB7cGksIHRhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcblxudmFyIGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMCxcbiAgICBrciA9IE1hdGguc2luKHBpIC8gMTApIC8gTWF0aC5zaW4oNyAqIHBpIC8gMTApLFxuICAgIGt4ID0gTWF0aC5zaW4odGF1IC8gMTApICoga3IsXG4gICAga3kgPSAtTWF0aC5jb3ModGF1IC8gMTApICoga3I7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXG4gICAgICAgIHggPSBreCAqIHIsXG4gICAgICAgIHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgYSA9IHRhdSAqIGkgLyA1LFxuICAgICAgICAgIGMgPSBNYXRoLmNvcyhhKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwidmFyIHNxcnQzID0gTWF0aC5zcXJ0KDMpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCB5ICogMik7XG4gICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJ2YXIgYyA9IC0wLjUsXG4gICAgcyA9IE1hdGguc3FydCgzKSAvIDIsXG4gICAgayA9IDEgLyBNYXRoLnNxcnQoMTIpLFxuICAgIGEgPSAoayAvIDIgKyAxKSAqIDM7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBhKSxcbiAgICAgICAgeDAgPSByIC8gMixcbiAgICAgICAgeTAgPSByICogayxcbiAgICAgICAgeDEgPSB4MCxcbiAgICAgICAgeTEgPSByICogayArIHIsXG4gICAgICAgIHgyID0gLXgxLFxuICAgICAgICB5MiA9IHkxO1xuICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCAtIHMgKiB5MCwgcyAqIHgwICsgYyAqIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgLSBzICogeTEsIHMgKiB4MSArIGMgKiB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyIC0gcyAqIHkyLCBzICogeDIgKyBjICogeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCArIHMgKiB5MCwgYyAqIHkwIC0gcyAqIHgwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgKyBzICogeTEsIGMgKiB5MSAtIHMgKiB4MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyICsgcyAqIHkyLCBjICogeTIgLSBzICogeDIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBmaWVsZCwgaXNEYXRlLCB0b051bWJlciwgaXNBcnJheSwgaW5yYW5nZSwgZXh0ZW5kLCBhcnJheSwgZXJyb3IsIHBlZWssIGhhc093blByb3BlcnR5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IExpdGVyYWwgfSBmcm9tICd2ZWdhLWV4cHJlc3Npb24nO1xuXG5mdW5jdGlvbiBhc2NlbmRpbmcgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBiaXNlY3RvciAoZikge1xuICBsZXQgZGVsdGEgPSBmO1xuICBsZXQgY29tcGFyZSA9IGY7XG5cbiAgaWYgKGYubGVuZ3RoID09PSAxKSB7XG4gICAgZGVsdGEgPSAoZCwgeCkgPT4gZihkKSAtIHg7XG5cbiAgICBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlZnQoYSwgeCwgbG8sIGhpKSB7XG4gICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcblxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBjb25zdCBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtlbHNlIGhpID0gbWlkO1xuICAgIH1cblxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJpZ2h0KGEsIHgsIGxvLCBoaSkge1xuICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKSBoaSA9IG1pZDtlbHNlIGxvID0gbWlkICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiBjZW50ZXIoYSwgeCwgbG8sIGhpKSB7XG4gICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICBjb25zdCBpID0gbGVmdChhLCB4LCBsbywgaGkgLSAxKTtcbiAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVmdCxcbiAgICBjZW50ZXIsXG4gICAgcmlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gIHJldHVybiAoZCwgeCkgPT4gYXNjZW5kaW5nKGYoZCksIHgpO1xufVxuXG5jb25zdCBJbnRlcnNlY3QgPSAnaW50ZXJzZWN0JztcbmNvbnN0IFVuaW9uID0gJ3VuaW9uJztcbmNvbnN0IFZsTXVsdGkgPSAndmxNdWx0aSc7XG5jb25zdCBWbFBvaW50ID0gJ3ZsUG9pbnQnO1xuY29uc3QgT3IgPSAnb3InO1xuY29uc3QgQW5kID0gJ2FuZCc7XG5cbmNvbnN0IFNFTEVDVElPTl9JRCA9ICdfdmdzaWRfJyxcbiAgICAgIFRZUEVfRU5VTSA9ICdFJyxcbiAgICAgIFRZUEVfUkFOR0VfSU5DID0gJ1InLFxuICAgICAgVFlQRV9SQU5HRV9FWEMgPSAnUi1FJyxcbiAgICAgIFRZUEVfUkFOR0VfTEUgPSAnUi1MRScsXG4gICAgICBUWVBFX1JBTkdFX1JFID0gJ1ItUkUnLFxuICAgICAgVU5JVF9JTkRFWCA9ICdpbmRleDp1bml0JzsgLy8gVE9ETzogcmV2aXNpdCBkYXRlIGNvZXJjaW9uP1xuXG5mdW5jdGlvbiB0ZXN0UG9pbnQoZGF0dW0sIGVudHJ5KSB7XG4gIHZhciBmaWVsZHMgPSBlbnRyeS5maWVsZHMsXG4gICAgICB2YWx1ZXMgPSBlbnRyeS52YWx1ZXMsXG4gICAgICBuID0gZmllbGRzLmxlbmd0aCxcbiAgICAgIGkgPSAwLFxuICAgICAgZHZhbCxcbiAgICAgIGY7XG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBmID0gZmllbGRzW2ldO1xuICAgIGYuZ2V0dGVyID0gZmllbGQuZ2V0dGVyIHx8IGZpZWxkKGYuZmllbGQpO1xuICAgIGR2YWwgPSBmLmdldHRlcihkYXR1bSk7XG4gICAgaWYgKGlzRGF0ZShkdmFsKSkgZHZhbCA9IHRvTnVtYmVyKGR2YWwpO1xuICAgIGlmIChpc0RhdGUodmFsdWVzW2ldKSkgdmFsdWVzW2ldID0gdG9OdW1iZXIodmFsdWVzW2ldKTtcbiAgICBpZiAoaXNEYXRlKHZhbHVlc1tpXVswXSkpIHZhbHVlc1tpXSA9IHZhbHVlc1tpXS5tYXAodG9OdW1iZXIpO1xuXG4gICAgaWYgKGYudHlwZSA9PT0gVFlQRV9FTlVNKSB7XG4gICAgICAvLyBFbnVtZXJhdGVkIGZpZWxkcyBjYW4gZWl0aGVyIHNwZWNpZnkgaW5kaXZpZHVhbCB2YWx1ZXMgKHNpbmdsZS9tdWx0aSBzZWxlY3Rpb25zKVxuICAgICAgLy8gb3IgYW4gYXJyYXkgb2YgdmFsdWVzIChpbnRlcnZhbCBzZWxlY3Rpb25zKS5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlc1tpXSkgPyB2YWx1ZXNbaV0uaW5kZXhPZihkdmFsKSA8IDAgOiBkdmFsICE9PSB2YWx1ZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZi50eXBlID09PSBUWVBFX1JBTkdFX0lOQykge1xuICAgICAgICBpZiAoIWlucmFuZ2UoZHZhbCwgdmFsdWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09IFRZUEVfUkFOR0VfUkUpIHtcbiAgICAgICAgLy8gRGlzY3JldGUgc2VsZWN0aW9uIG9mIGJpbnMgdGVzdCB3aXRoaW4gdGhlIHJhbmdlIFtiaW5fc3RhcnQsIGJpbl9lbmQpLlxuICAgICAgICBpZiAoIWlucmFuZ2UoZHZhbCwgdmFsdWVzW2ldLCB0cnVlLCBmYWxzZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSBUWVBFX1JBTkdFX0VYQykge1xuICAgICAgICAvLyAnUi1FJy8nUi1MRScgaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcy5cbiAgICAgICAgaWYgKCFpbnJhbmdlKGR2YWwsIHZhbHVlc1tpXSwgZmFsc2UsIGZhbHNlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09IFRZUEVfUkFOR0VfTEUpIHtcbiAgICAgICAgaWYgKCFpbnJhbmdlKGR2YWwsIHZhbHVlc1tpXSwgZmFsc2UsIHRydWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFRlc3RzIGlmIGEgdHVwbGUgaXMgY29udGFpbmVkIHdpdGhpbiBhbiBpbnRlcmFjdGl2ZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhIHNldCByZXByZXNlbnRpbmcgdGhlIHNlbGVjdGlvbi5cbiAqICBUdXBsZXMgaW4gdGhlIGRhdGFzZXQgYXJlIG9mIHRoZSBmb3JtXG4gKiAge3VuaXQ6IHN0cmluZywgZmllbGRzOiBhcnJheTxmaWVsZGRlZj4sIHZhbHVlczogYXJyYXk8Kj59LlxuICogIEZpZWxkZGVmIGlzIG9mIHRoZSBmb3JtXG4gKiAge2ZpZWxkOiBzdHJpbmcsIGNoYW5uZWw6IHN0cmluZywgdHlwZTogJ0UnIHwgJ1InfSB3aGVyZVxuICogICd0eXBlJyBpZGVudGlmaWVzIHdoZXRoZXIgdHVwbGVzIGluIHRoZSBkYXRhc2V0IGVudW1lcmF0ZVxuICogIHZhbHVlcyBmb3IgdGhlIGZpZWxkLCBvciBzcGVjaWZ5IGEgY29udGludW91cyByYW5nZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXR1bSAtIFRoZSB0dXBsZSB0byB0ZXN0IGZvciBpbmNsdXNpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3AgLSBUaGUgc2V0IG9wZXJhdGlvbiBmb3IgY29tYmluaW5nIHNlbGVjdGlvbnMuXG4gKiAgIE9uZSBvZiAnaW50ZXJzZWN0JyBvciAndW5pb24nIChkZWZhdWx0KS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgZGF0dW0gaXMgaW4gdGhlIHNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gc2VsZWN0aW9uVGVzdChuYW1lLCBkYXR1bSwgb3ApIHtcbiAgdmFyIGRhdGEgPSB0aGlzLmNvbnRleHQuZGF0YVtuYW1lXSxcbiAgICAgIGVudHJpZXMgPSBkYXRhID8gZGF0YS52YWx1ZXMudmFsdWUgOiBbXSxcbiAgICAgIHVuaXRJZHggPSBkYXRhID8gZGF0YVtVTklUX0lOREVYXSAmJiBkYXRhW1VOSVRfSU5ERVhdLnZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJzZWN0ID0gb3AgPT09IEludGVyc2VjdCxcbiAgICAgIG4gPSBlbnRyaWVzLmxlbmd0aCxcbiAgICAgIGkgPSAwLFxuICAgICAgZW50cnksXG4gICAgICBtaXNzLFxuICAgICAgY291bnQsXG4gICAgICB1bml0LFxuICAgICAgYjtcblxuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIGVudHJ5ID0gZW50cmllc1tpXTtcblxuICAgIGlmICh1bml0SWR4ICYmIGludGVyc2VjdCkge1xuICAgICAgLy8gbXVsdGkgc2VsZWN0aW9ucyB1bmlvbiB3aXRoaW4gdGhlIHNhbWUgdW5pdCBhbmQgaW50ZXJzZWN0IGFjcm9zcyB1bml0cy5cbiAgICAgIG1pc3MgPSBtaXNzIHx8IHt9O1xuICAgICAgY291bnQgPSBtaXNzW3VuaXQgPSBlbnRyeS51bml0XSB8fCAwOyAvLyBpZiB3ZSd2ZSBhbHJlYWR5IG1hdGNoZWQgdGhpcyB1bml0LCBza2lwLlxuXG4gICAgICBpZiAoY291bnQgPT09IC0xKSBjb250aW51ZTtcbiAgICAgIGIgPSB0ZXN0UG9pbnQoZGF0dW0sIGVudHJ5KTtcbiAgICAgIG1pc3NbdW5pdF0gPSBiID8gLTEgOiArK2NvdW50OyAvLyBpZiB3ZSBtYXRjaCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIHVuaXRzIHJldHVybiB0cnVlXG4gICAgICAvLyBpZiB3ZSd2ZSBtaXNzZWQgYWdhaW5zdCBhbGwgdHVwbGVzIGluIHRoaXMgdW5pdCByZXR1cm4gZmFsc2VcblxuICAgICAgaWYgKGIgJiYgdW5pdElkeC5zaXplID09PSAxKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICghYiAmJiBjb3VudCA9PT0gdW5pdElkeC5nZXQodW5pdCkuY291bnQpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRlc3RQb2ludChkYXR1bSwgZW50cnkpOyAvLyBpZiB3ZSBmaW5kIGEgbWlzcyBhbmQgd2UgZG8gcmVxdWlyZSBpbnRlcnNlY3Rpb24gcmV0dXJuIGZhbHNlXG4gICAgICAvLyBpZiB3ZSBmaW5kIGEgbWF0Y2ggYW5kIHdlIGRvbid0IHJlcXVpcmUgaW50ZXJzZWN0aW9uIHJldHVybiB0cnVlXG5cbiAgICAgIGlmIChpbnRlcnNlY3QgXiBiKSByZXR1cm4gYjtcbiAgICB9XG4gIH0gLy8gaWYgaW50ZXJzZWN0aW5nIGFuZCB3ZSBtYWRlIGl0IGhlcmUsIHRoZW4gd2Ugc2F3IG5vIG1pc3Nlc1xuICAvLyBpZiBub3QgaW50ZXJzZWN0aW5nLCB0aGVuIHdlIHNhdyBubyBtYXRjaGVzXG4gIC8vIGlmIG5vIGFjdGl2ZSBzZWxlY3Rpb25zLCByZXR1cm4gZmFsc2VcblxuXG4gIHJldHVybiBuICYmIGludGVyc2VjdDtcbn1cbmNvbnN0IHNlbGVjdGlvbklkID0gZmllbGQoU0VMRUNUSU9OX0lEKSxcbiAgICAgIGJpc2VjdCA9IGJpc2VjdG9yKHNlbGVjdGlvbklkKSxcbiAgICAgIGJpc2VjdExlZnQgPSBiaXNlY3QubGVmdCxcbiAgICAgIGJpc2VjdFJpZ2h0ID0gYmlzZWN0LnJpZ2h0O1xuZnVuY3Rpb24gc2VsZWN0aW9uSWRUZXN0KG5hbWUsIGRhdHVtLCBvcCkge1xuICBjb25zdCBkYXRhID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV0sXG4gICAgICAgIGVudHJpZXMgPSBkYXRhID8gZGF0YS52YWx1ZXMudmFsdWUgOiBbXSxcbiAgICAgICAgdW5pdElkeCA9IGRhdGEgPyBkYXRhW1VOSVRfSU5ERVhdICYmIGRhdGFbVU5JVF9JTkRFWF0udmFsdWUgOiB1bmRlZmluZWQsXG4gICAgICAgIGludGVyc2VjdCA9IG9wID09PSBJbnRlcnNlY3QsXG4gICAgICAgIHZhbHVlID0gc2VsZWN0aW9uSWQoZGF0dW0pLFxuICAgICAgICBpbmRleCA9IGJpc2VjdExlZnQoZW50cmllcywgdmFsdWUpO1xuICBpZiAoaW5kZXggPT09IGVudHJpZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGlmIChzZWxlY3Rpb25JZChlbnRyaWVzW2luZGV4XSkgIT09IHZhbHVlKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHVuaXRJZHggJiYgaW50ZXJzZWN0KSB7XG4gICAgaWYgKHVuaXRJZHguc2l6ZSA9PT0gMSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGJpc2VjdFJpZ2h0KGVudHJpZXMsIHZhbHVlKSAtIGluZGV4IDwgdW5pdElkeC5zaXplKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBNYXBzIGFuIGFycmF5IG9mIHNjZW5lIGdyYXBoIGl0ZW1zIHRvIGFuIGFycmF5IG9mIHNlbGVjdGlvbiB0dXBsZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgLSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCByZXByZXNlbnRpbmcgdGhlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0ICAtIFRoZSBuYW1lIG9mIHRoZSB1bml0IHZpZXcuXG4gKlxuICogQHJldHVybnMge2FycmF5fSBBbiBhcnJheSBvZiBzZWxlY3Rpb24gZW50cmllcyBmb3IgdGhlIGdpdmVuIHVuaXQuXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0aW9uVHVwbGVzKGFycmF5LCBiYXNlKSB7XG4gIHJldHVybiBhcnJheS5tYXAoeCA9PiBleHRlbmQoe1xuICAgIHZhbHVlczogYmFzZS5maWVsZHMubWFwKGYgPT4gKGYuZ2V0dGVyIHx8IChmLmdldHRlciA9IGZpZWxkKGYuZmllbGQpKSkoeC5kYXR1bSkpXG4gIH0sIGJhc2UpKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBzZWxlY3Rpb24gZm9yIHVzZSBhcyBhIHNjYWxlIGRvbWFpbiBvciByZWFkcyB2aWEgdGhlIEFQSS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgcmVwcmVzZW50aW5nIHRoZSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3A9J3VuaW9uJ10gLSBUaGUgc2V0IG9wZXJhdGlvbiBmb3IgY29tYmluaW5nIHNlbGVjdGlvbnMuXG4gKiAgICAgICAgICAgICAgICAgT25lIG9mICdpbnRlcnNlY3QnIG9yICd1bmlvbicgKGRlZmF1bHQpLlxuICogQHBhcmFtIHtib29sZWFufSBpc011bHRpIC0gSWRlbnRpZmllcyBhIFwibXVsdGlcIiBzZWxlY3Rpb24gdG8gcGVyZm9ybSBtb3JlXG4gKiAgICAgICAgICAgICAgICAgZXhwZW5zaXZlIHJlc29sdXRpb24gY29tcHV0YXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZsNSAtIFdpdGggVmVnYS1MaXRlIHY1LCBcIm11bHRpXCIgc2VsZWN0aW9ucyBhcmUgbm93IGNhbGxlZCBcInBvaW50XCJcbiAqICAgICAgICAgICAgICAgICBzZWxlY3Rpb25zLCBhbmQgdGh1cyB0aGUgcmVzb2x2ZWQgdHVwbGUgc2hvdWxkIHJlZmxlY3QgdGhpcyBuYW1lLlxuICogICAgICAgICAgICAgICAgIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB1cyB0byByZWZsZWN0IHRoaXMgY2hhbmdlIHdpdGhvdXQgdHJpZ2dlcmluZ1xuICogICAgICAgICAgICAgICAgIGEgbWFqb3IgdmVyc2lvbiBidW1wIGZvciBWZWdhLlxuICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IG9mIHNlbGVjdGVkIGZpZWxkcyBhbmQgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdGlvblJlc29sdmUobmFtZSwgb3AsIGlzTXVsdGksIHZsNSkge1xuICB2YXIgZGF0YSA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdLFxuICAgICAgZW50cmllcyA9IGRhdGEgPyBkYXRhLnZhbHVlcy52YWx1ZSA6IFtdLFxuICAgICAgcmVzb2x2ZWQgPSB7fSxcbiAgICAgIG11bHRpUmVzID0ge30sXG4gICAgICB0eXBlcyA9IHt9LFxuICAgICAgZW50cnksXG4gICAgICBmaWVsZHMsXG4gICAgICB2YWx1ZXMsXG4gICAgICB1bml0LFxuICAgICAgZmllbGQsXG4gICAgICByZXMsXG4gICAgICByZXNVbml0LFxuICAgICAgdHlwZSxcbiAgICAgIHVuaW9uLFxuICAgICAgbiA9IGVudHJpZXMubGVuZ3RoLFxuICAgICAgaSA9IDAsXG4gICAgICBqLFxuICAgICAgbTsgLy8gRmlyc3QgdW5pb24gYWxsIGVudHJpZXMgd2l0aGluIHRoZSBzYW1lIHVuaXQuXG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBlbnRyeSA9IGVudHJpZXNbaV07XG4gICAgdW5pdCA9IGVudHJ5LnVuaXQ7XG4gICAgZmllbGRzID0gZW50cnkuZmllbGRzO1xuICAgIHZhbHVlcyA9IGVudHJ5LnZhbHVlcztcblxuICAgIGZvciAoaiA9IDAsIG0gPSBmaWVsZHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBmaWVsZCA9IGZpZWxkc1tqXTtcbiAgICAgIHJlcyA9IHJlc29sdmVkW2ZpZWxkLmZpZWxkXSB8fCAocmVzb2x2ZWRbZmllbGQuZmllbGRdID0ge30pO1xuICAgICAgcmVzVW5pdCA9IHJlc1t1bml0XSB8fCAocmVzW3VuaXRdID0gW10pO1xuICAgICAgdHlwZXNbZmllbGQuZmllbGRdID0gdHlwZSA9IGZpZWxkLnR5cGUuY2hhckF0KDApO1xuICAgICAgdW5pb24gPSBvcHNbdHlwZSArICdfdW5pb24nXTtcbiAgICAgIHJlc1t1bml0XSA9IHVuaW9uKHJlc1VuaXQsIGFycmF5KHZhbHVlc1tqXSkpO1xuICAgIH0gLy8gSWYgdGhlIHNhbWUgbXVsdGktc2VsZWN0aW9uIGlzIHJlcGVhdGVkIG92ZXIgdmlld3MgYW5kIHByb2plY3RlZCBvdmVyXG4gICAgLy8gYW4gZW5jb2RpbmcsIGl0IG1heSBvcGVyYXRlIG92ZXIgZGlmZmVyZW50IGZpZWxkcyBtYWtpbmcgaXQgZXNwZWNpYWxseVxuICAgIC8vIHRyaWNreSB0byByZWxpYWJseSByZXNvbHZlIGl0LiBBdCBiZXN0LCB3ZSBjYW4gZGUtZHVwZSBpZGVudGljYWwgZW50cmllc1xuICAgIC8vIGJ1dCBkb2luZyBzbyBtYXkgYmUgbW9yZSBjb21wdXRhdGlvbmFsbHkgZXhwZW5zaXZlIHRoYW4gaXQgaXMgd29ydGguXG4gICAgLy8gSW5zdGVhZCwgZm9yIG5vdywgd2Ugc2ltcGx5IHRyYW5zZm9ybSBvdXIgc3RvcmUgcmVwcmVzZW50YXRpb24gaW50b1xuICAgIC8vIGEgbW9yZSBodW1hbi1mcmllbmRseSBvbmUuXG5cblxuICAgIGlmIChpc011bHRpKSB7XG4gICAgICByZXNVbml0ID0gbXVsdGlSZXNbdW5pdF0gfHwgKG11bHRpUmVzW3VuaXRdID0gW10pO1xuICAgICAgcmVzVW5pdC5wdXNoKGFycmF5KHZhbHVlcykucmVkdWNlKChvYmosIGN1cnIsIGopID0+IChvYmpbZmllbGRzW2pdLmZpZWxkXSA9IGN1cnIsIG9iaiksIHt9KSk7XG4gICAgfVxuICB9IC8vIFRoZW4gcmVzb2x2ZSBmaWVsZHMgYWNyb3NzIHVuaXRzIGFzIHBlciB0aGUgb3AuXG5cblxuICBvcCA9IG9wIHx8IFVuaW9uO1xuICBPYmplY3Qua2V5cyhyZXNvbHZlZCkuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgcmVzb2x2ZWRbZmllbGRdID0gT2JqZWN0LmtleXMocmVzb2x2ZWRbZmllbGRdKS5tYXAodW5pdCA9PiByZXNvbHZlZFtmaWVsZF1bdW5pdF0pLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgPT09IHVuZGVmaW5lZCA/IGN1cnIgOiBvcHNbdHlwZXNbZmllbGRdICsgJ18nICsgb3BdKGFjYywgY3VycikpO1xuICB9KTtcbiAgZW50cmllcyA9IE9iamVjdC5rZXlzKG11bHRpUmVzKTtcblxuICBpZiAoaXNNdWx0aSAmJiBlbnRyaWVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGtleSA9IHZsNSA/IFZsUG9pbnQgOiBWbE11bHRpO1xuICAgIHJlc29sdmVkW2tleV0gPSBvcCA9PT0gVW5pb24gPyB7XG4gICAgICBbT3JdOiBlbnRyaWVzLnJlZHVjZSgoYWNjLCBrKSA9PiAoYWNjLnB1c2goLi4ubXVsdGlSZXNba10pLCBhY2MpLCBbXSlcbiAgICB9IDoge1xuICAgICAgW0FuZF06IGVudHJpZXMubWFwKGsgPT4gKHtcbiAgICAgICAgW09yXTogbXVsdGlSZXNba11cbiAgICAgIH0pKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG52YXIgb3BzID0ge1xuICBFX3VuaW9uOiBmdW5jdGlvbiAoYmFzZSwgdmFsdWUpIHtcbiAgICBpZiAoIWJhc2UubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBuID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBuOyArK2kpIGlmIChiYXNlLmluZGV4T2YodmFsdWVbaV0pIDwgMCkgYmFzZS5wdXNoKHZhbHVlW2ldKTtcblxuICAgIHJldHVybiBiYXNlO1xuICB9LFxuICBFX2ludGVyc2VjdDogZnVuY3Rpb24gKGJhc2UsIHZhbHVlKSB7XG4gICAgcmV0dXJuICFiYXNlLmxlbmd0aCA/IHZhbHVlIDogYmFzZS5maWx0ZXIodiA9PiB2YWx1ZS5pbmRleE9mKHYpID49IDApO1xuICB9LFxuICBSX3VuaW9uOiBmdW5jdGlvbiAoYmFzZSwgdmFsdWUpIHtcbiAgICB2YXIgbG8gPSB0b051bWJlcih2YWx1ZVswXSksXG4gICAgICAgIGhpID0gdG9OdW1iZXIodmFsdWVbMV0pO1xuXG4gICAgaWYgKGxvID4gaGkpIHtcbiAgICAgIGxvID0gdmFsdWVbMV07XG4gICAgICBoaSA9IHZhbHVlWzBdO1xuICAgIH1cblxuICAgIGlmICghYmFzZS5sZW5ndGgpIHJldHVybiBbbG8sIGhpXTtcbiAgICBpZiAoYmFzZVswXSA+IGxvKSBiYXNlWzBdID0gbG87XG4gICAgaWYgKGJhc2VbMV0gPCBoaSkgYmFzZVsxXSA9IGhpO1xuICAgIHJldHVybiBiYXNlO1xuICB9LFxuICBSX2ludGVyc2VjdDogZnVuY3Rpb24gKGJhc2UsIHZhbHVlKSB7XG4gICAgdmFyIGxvID0gdG9OdW1iZXIodmFsdWVbMF0pLFxuICAgICAgICBoaSA9IHRvTnVtYmVyKHZhbHVlWzFdKTtcblxuICAgIGlmIChsbyA+IGhpKSB7XG4gICAgICBsbyA9IHZhbHVlWzFdO1xuICAgICAgaGkgPSB2YWx1ZVswXTtcbiAgICB9XG5cbiAgICBpZiAoIWJhc2UubGVuZ3RoKSByZXR1cm4gW2xvLCBoaV07XG5cbiAgICBpZiAoaGkgPCBiYXNlWzBdIHx8IGJhc2VbMV0gPCBsbykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYmFzZVswXSA8IGxvKSBiYXNlWzBdID0gbG87XG4gICAgICBpZiAoYmFzZVsxXSA+IGhpKSBiYXNlWzFdID0gaGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn07XG5cbmNvbnN0IERhdGFQcmVmaXggPSAnOicsXG4gICAgICBJbmRleFByZWZpeCA9ICdAJztcbmZ1bmN0aW9uIHNlbGVjdGlvblZpc2l0b3IobmFtZSwgYXJncywgc2NvcGUsIHBhcmFtcykge1xuICBpZiAoYXJnc1swXS50eXBlICE9PSBMaXRlcmFsKSBlcnJvcignRmlyc3QgYXJndW1lbnQgdG8gc2VsZWN0aW9uIGZ1bmN0aW9ucyBtdXN0IGJlIGEgc3RyaW5nIGxpdGVyYWwuJyk7XG4gIGNvbnN0IGRhdGEgPSBhcmdzWzBdLnZhbHVlLFxuICAgICAgICBvcCA9IGFyZ3MubGVuZ3RoID49IDIgJiYgcGVlayhhcmdzKS52YWx1ZSxcbiAgICAgICAgZmllbGQgPSAndW5pdCcsXG4gICAgICAgIGluZGV4TmFtZSA9IEluZGV4UHJlZml4ICsgZmllbGQsXG4gICAgICAgIGRhdGFOYW1lID0gRGF0YVByZWZpeCArIGRhdGE7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblxuICBpZiAob3AgPT09IEludGVyc2VjdCAmJiAhaGFzT3duUHJvcGVydHkocGFyYW1zLCBpbmRleE5hbWUpKSB7XG4gICAgcGFyYW1zW2luZGV4TmFtZV0gPSBzY29wZS5nZXREYXRhKGRhdGEpLmluZGF0YVJlZihzY29wZSwgZmllbGQpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblxuXG4gIGlmICghaGFzT3duUHJvcGVydHkocGFyYW1zLCBkYXRhTmFtZSkpIHtcbiAgICBwYXJhbXNbZGF0YU5hbWVdID0gc2NvcGUuZ2V0RGF0YShkYXRhKS50dXBsZXNSZWYoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBzZWxlY3Rpb25JZFRlc3QsIHNlbGVjdGlvblJlc29sdmUsIHNlbGVjdGlvblRlc3QsIHNlbGVjdGlvblR1cGxlcywgc2VsZWN0aW9uVmlzaXRvciB9O1xuIiwiaW1wb3J0IHsgYXNjZW5kaW5nLCBxdWFudGlsZVNvcnRlZCwgZGV2aWF0aW9uLCBxdWFudGlsZSwgbWVkaWFuIH0gZnJvbSAnZDMtYXJyYXknO1xuXG5mdW5jdGlvbiogbnVtYmVycyAodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJyAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcblxuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgdmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpO1xuXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVhbnRpbGVzIChhcnJheSwgcCwgZikge1xuICBjb25zdCB2YWx1ZXMgPSBGbG9hdDY0QXJyYXkuZnJvbShudW1iZXJzKGFycmF5LCBmKSk7IC8vIGRvbid0IGRlcGVuZCBvbiByZXR1cm4gdmFsdWUgZnJvbSB0eXBlZCBhcnJheSBzb3J0IGNhbGxcbiAgLy8gcHJvdGVjdHMgYWdhaW5zdCB1bmRlZmluZWQgc29ydCByZXN1bHRzIGluIFNhZmFyaSAodmVnYS92ZWdhLWxpdGUjNDk2NClcblxuICB2YWx1ZXMuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gcC5tYXAoXyA9PiBxdWFudGlsZVNvcnRlZCh2YWx1ZXMsIF8pKTtcbn1cblxuZnVuY3Rpb24gcXVhcnRpbGVzIChhcnJheSwgZikge1xuICByZXR1cm4gcXVhbnRpbGVzKGFycmF5LCBbMC4yNSwgMC41MCwgMC43NV0sIGYpO1xufVxuXG4vLyBUaGVvcnksIFByYWN0aWNlLCBhbmQgVmlzdWFsaXphdGlvbi4gV2lsZXkuXG5cbmZ1bmN0aW9uIGVzdGltYXRlQmFuZHdpZHRoIChhcnJheSwgZikge1xuICBjb25zdCBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBkID0gZGV2aWF0aW9uKGFycmF5LCBmKSxcbiAgICAgICAgcSA9IHF1YXJ0aWxlcyhhcnJheSwgZiksXG4gICAgICAgIGggPSAocVsyXSAtIHFbMF0pIC8gMS4zNCxcbiAgICAgICAgdiA9IE1hdGgubWluKGQsIGgpIHx8IGQgfHwgTWF0aC5hYnMocVswXSkgfHwgMTtcbiAgcmV0dXJuIDEuMDYgKiB2ICogTWF0aC5wb3cobiwgLTAuMik7XG59XG5cbmZ1bmN0aW9uIGJpbiAoXykge1xuICAvLyBkZXRlcm1pbmUgcmFuZ2VcbiAgY29uc3QgbWF4YiA9IF8ubWF4YmlucyB8fCAyMCxcbiAgICAgICAgYmFzZSA9IF8uYmFzZSB8fCAxMCxcbiAgICAgICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgICAgICBkaXYgPSBfLmRpdmlkZSB8fCBbNSwgMl07XG4gIGxldCBtaW4gPSBfLmV4dGVudFswXSxcbiAgICAgIG1heCA9IF8uZXh0ZW50WzFdLFxuICAgICAgc3RlcCxcbiAgICAgIGxldmVsLFxuICAgICAgbWluc3RlcCxcbiAgICAgIHYsXG4gICAgICBpLFxuICAgICAgbjtcbiAgY29uc3Qgc3BhbiA9IF8uc3BhbiB8fCBtYXggLSBtaW4gfHwgTWF0aC5hYnMobWluKSB8fCAxO1xuXG4gIGlmIChfLnN0ZXApIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gXy5zdGVwO1xuICB9IGVsc2UgaWYgKF8uc3RlcHMpIHtcbiAgICAvLyBpZiBwcm92aWRlZCwgbGltaXQgY2hvaWNlIHRvIGFjY2VwdGFibGUgc3RlcCBzaXplc1xuICAgIHYgPSBzcGFuIC8gbWF4YjtcblxuICAgIGZvciAoaSA9IDAsIG4gPSBfLnN0ZXBzLmxlbmd0aDsgaSA8IG4gJiYgXy5zdGVwc1tpXSA8IHY7ICsraSk7XG5cbiAgICBzdGVwID0gXy5zdGVwc1tNYXRoLm1heCgwLCBpIC0gMSldO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgdXNlIHNwYW4gdG8gZGV0ZXJtaW5lIHN0ZXAgc2l6ZVxuICAgIGxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heGIpIC8gbG9nYik7XG4gICAgbWluc3RlcCA9IF8ubWluc3RlcCB8fCAwO1xuICAgIHN0ZXAgPSBNYXRoLm1heChtaW5zdGVwLCBNYXRoLnBvdyhiYXNlLCBNYXRoLnJvdW5kKE1hdGgubG9nKHNwYW4pIC8gbG9nYikgLSBsZXZlbCkpOyAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuXG4gICAgd2hpbGUgKE1hdGguY2VpbChzcGFuIC8gc3RlcCkgPiBtYXhiKSB7XG4gICAgICBzdGVwICo9IGJhc2U7XG4gICAgfSAvLyBkZWNyZWFzZSBzdGVwIHNpemUgaWYgYWxsb3dlZFxuXG5cbiAgICBmb3IgKGkgPSAwLCBuID0gZGl2Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdiA9IHN0ZXAgLyBkaXZbaV07XG4gICAgICBpZiAodiA+PSBtaW5zdGVwICYmIHNwYW4gLyB2IDw9IG1heGIpIHN0ZXAgPSB2O1xuICAgIH1cbiAgfSAvLyB1cGRhdGUgcHJlY2lzaW9uLCBtaW4gYW5kIG1heFxuXG5cbiAgdiA9IE1hdGgubG9nKHN0ZXApO1xuICBjb25zdCBwcmVjaXNpb24gPSB2ID49IDAgPyAwIDogfn4oLXYgLyBsb2diKSArIDEsXG4gICAgICAgIGVwcyA9IE1hdGgucG93KGJhc2UsIC1wcmVjaXNpb24gLSAxKTtcblxuICBpZiAoXy5uaWNlIHx8IF8ubmljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdiA9IE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwO1xuICAgIG1pbiA9IG1pbiA8IHYgPyB2IC0gc3RlcCA6IHY7XG4gICAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG1pbixcbiAgICBzdG9wOiBtYXggPT09IG1pbiA/IG1pbiArIHN0ZXAgOiBtYXgsXG4gICAgc3RlcDogc3RlcFxuICB9O1xufVxuXG52YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG5mdW5jdGlvbiBzZXRSYW5kb20ocikge1xuICByYW5kb20gPSByO1xufVxuXG5mdW5jdGlvbiBib290c3RyYXBDSSAoYXJyYXksIHNhbXBsZXMsIGFscGhhLCBmKSB7XG4gIGlmICghYXJyYXkubGVuZ3RoKSByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbiAgY29uc3QgdmFsdWVzID0gRmxvYXQ2NEFycmF5LmZyb20obnVtYmVycyhhcnJheSwgZikpLFxuICAgICAgICBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgbSA9IHNhbXBsZXM7XG4gIGxldCBhLCBpLCBqLCBtdTtcblxuICBmb3IgKGogPSAwLCBtdSA9IEFycmF5KG0pOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yIChhID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGEgKz0gdmFsdWVzW35+KHJhbmRvbSgpICogbildO1xuICAgIH1cblxuICAgIG11W2pdID0gYSAvIG47XG4gIH1cblxuICBtdS5zb3J0KGFzY2VuZGluZyk7XG4gIHJldHVybiBbcXVhbnRpbGUobXUsIGFscGhhIC8gMiksIHF1YW50aWxlKG11LCAxIC0gYWxwaGEgLyAyKV07XG59XG5cbi8vIERvdCBkZW5zaXR5IGJpbm5pbmcgZm9yIGRvdCBwbG90IGNvbnN0cnVjdGlvbi5cbi8vIEJhc2VkIG9uIExlbGFuZCBXaWxraW5zb24sIERvdCBQbG90cywgVGhlIEFtZXJpY2FuIFN0YXRpc3RpY2lhbiwgMTk5OS5cbi8vIGh0dHBzOi8vd3d3LmNzLnVpYy5lZHUvfndpbGtpbnNvbi9QdWJsaWNhdGlvbnMvZG90cGxvdHMucGRmXG5mdW5jdGlvbiBkb3RiaW4gKGFycmF5LCBzdGVwLCBzbW9vdGgsIGYpIHtcbiAgZiA9IGYgfHwgKF8gPT4gXyk7XG5cbiAgY29uc3QgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgdiA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gIGxldCBpID0gMCxcbiAgICAgIGogPSAxLFxuICAgICAgYSA9IGYoYXJyYXlbMF0pLFxuICAgICAgYiA9IGEsXG4gICAgICB3ID0gYSArIHN0ZXAsXG4gICAgICB4O1xuXG4gIGZvciAoOyBqIDwgbjsgKytqKSB7XG4gICAgeCA9IGYoYXJyYXlbal0pO1xuXG4gICAgaWYgKHggPj0gdykge1xuICAgICAgYiA9IChhICsgYikgLyAyO1xuXG4gICAgICBmb3IgKDsgaSA8IGo7ICsraSkgdltpXSA9IGI7XG5cbiAgICAgIHcgPSB4ICsgc3RlcDtcbiAgICAgIGEgPSB4O1xuICAgIH1cblxuICAgIGIgPSB4O1xuICB9XG5cbiAgYiA9IChhICsgYikgLyAyO1xuXG4gIGZvciAoOyBpIDwgajsgKytpKSB2W2ldID0gYjtcblxuICByZXR1cm4gc21vb3RoID8gc21vb3RoaW5nKHYsIHN0ZXAgKyBzdGVwIC8gNCkgOiB2O1xufSAvLyBwZXJmb3JtIHNtb290aGluZyB0byByZWR1Y2UgdmFyaWFuY2Vcbi8vIHN3YXAgcG9pbnRzIGJldHdlZW4gXCJhZGphY2VudFwiIHN0YWNrc1xuLy8gV2lsa2luc29uIGRlZmluZXMgYWRqYWNlbnQgYXMgd2l0aGluIHN0ZXAvNCB1bml0c1xuXG5mdW5jdGlvbiBzbW9vdGhpbmcodiwgdGhyZXNoKSB7XG4gIGNvbnN0IG4gPSB2Lmxlbmd0aDtcbiAgbGV0IGEgPSAwLFxuICAgICAgYiA9IDEsXG4gICAgICBjLFxuICAgICAgZDsgLy8gZ2V0IGxlZnQgc3RhY2tcblxuICB3aGlsZSAodlthXSA9PT0gdltiXSkgKytiO1xuXG4gIHdoaWxlIChiIDwgbikge1xuICAgIC8vIGdldCByaWdodCBzdGFja1xuICAgIGMgPSBiICsgMTtcblxuICAgIHdoaWxlICh2W2JdID09PSB2W2NdKSArK2M7IC8vIGFyZSBzdGFja3MgYWRqYWNlbnQ/XG4gICAgLy8gaWYgc28sIGNvbXBhcmUgc2l6ZXMgYW5kIHN3YXAgYXMgbmVlZGVkXG5cblxuICAgIGlmICh2W2JdIC0gdltiIC0gMV0gPCB0aHJlc2gpIHtcbiAgICAgIGQgPSBiICsgKGEgKyBjIC0gYiAtIGIgPj4gMSk7XG5cbiAgICAgIHdoaWxlIChkIDwgYikgdltkKytdID0gdltiXTtcblxuICAgICAgd2hpbGUgKGQgPiBiKSB2W2QtLV0gPSB2W2FdO1xuICAgIH0gLy8gdXBkYXRlIGxlZnQgc3RhY2sgaW5kaWNlc1xuXG5cbiAgICBhID0gYjtcbiAgICBiID0gYztcbiAgfVxuXG4gIHJldHVybiB2O1xufVxuXG5mdW5jdGlvbiBsY2cgKHNlZWQpIHtcbiAgLy8gUmFuZG9tIG51bWJlcnMgdXNpbmcgYSBMaW5lYXIgQ29uZ3J1ZW50aWFsIEdlbmVyYXRvciB3aXRoIHNlZWQgdmFsdWVcbiAgLy8gVXNlcyBnbGliYyB2YWx1ZXMgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfY29uZ3J1ZW50aWFsX2dlbmVyYXRvclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHNlZWQgPSAoMTEwMzUxNTI0NSAqIHNlZWQgKyAxMjM0NSkgJSAyMTQ3NDgzNjQ3O1xuICAgIHJldHVybiBzZWVkIC8gMjE0NzQ4MzY0NztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZWdlciAobWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cblxuICBsZXQgYSwgYiwgZDtcbiAgY29uc3QgZGlzdCA9IHtcbiAgICBtaW4oXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYSA9IF8gfHwgMDtcbiAgICAgICAgZCA9IGIgLSBhO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBtYXgoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYiA9IF8gfHwgMDtcbiAgICAgICAgZCA9IGIgLSBhO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzYW1wbGUoKSB7XG4gICAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIHJhbmRvbSgpKTtcbiAgICB9LFxuXG4gICAgcGRmKHgpIHtcbiAgICAgIHJldHVybiB4ID09PSBNYXRoLmZsb29yKHgpICYmIHggPj0gYSAmJiB4IDwgYiA/IDEgLyBkIDogMDtcbiAgICB9LFxuXG4gICAgY2RmKHgpIHtcbiAgICAgIGNvbnN0IHYgPSBNYXRoLmZsb29yKHgpO1xuICAgICAgcmV0dXJuIHYgPCBhID8gMCA6IHYgPj0gYiA/IDEgOiAodiAtIGEgKyAxKSAvIGQ7XG4gICAgfSxcblxuICAgIGljZGYocCkge1xuICAgICAgcmV0dXJuIHAgPj0gMCAmJiBwIDw9IDEgPyBhIC0gMSArIE1hdGguZmxvb3IocCAqIGQpIDogTmFOO1xuICAgIH1cblxuICB9O1xuICByZXR1cm4gZGlzdC5taW4obWluKS5tYXgobWF4KTtcbn1cblxuY29uc3QgU1FSVDJQSSA9IE1hdGguc3FydCgyICogTWF0aC5QSSk7XG5jb25zdCBTUVJUMiA9IE1hdGguU1FSVDI7XG5cbmxldCBuZXh0U2FtcGxlID0gTmFOO1xuZnVuY3Rpb24gc2FtcGxlTm9ybWFsKG1lYW4sIHN0ZGV2KSB7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgbGV0IHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICByZHMsXG4gICAgICBjO1xuXG4gIGlmIChuZXh0U2FtcGxlID09PSBuZXh0U2FtcGxlKSB7XG4gICAgeCA9IG5leHRTYW1wbGU7XG4gICAgbmV4dFNhbXBsZSA9IE5hTjtcbiAgfSBlbHNlIHtcbiAgICBkbyB7XG4gICAgICB4ID0gcmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgIHkgPSByYW5kb20oKSAqIDIgLSAxO1xuICAgICAgcmRzID0geCAqIHggKyB5ICogeTtcbiAgICB9IHdoaWxlIChyZHMgPT09IDAgfHwgcmRzID4gMSk7XG5cbiAgICBjID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocmRzKSAvIHJkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG5cbiAgICB4ICo9IGM7XG4gICAgbmV4dFNhbXBsZSA9IHkgKiBjO1xuICB9XG5cbiAgcmV0dXJuIG1lYW4gKyB4ICogc3RkZXY7XG59XG5mdW5jdGlvbiBkZW5zaXR5Tm9ybWFsKHZhbHVlLCBtZWFuLCBzdGRldikge1xuICBzdGRldiA9IHN0ZGV2ID09IG51bGwgPyAxIDogc3RkZXY7XG4gIGNvbnN0IHogPSAodmFsdWUgLSAobWVhbiB8fCAwKSkgLyBzdGRldjtcbiAgcmV0dXJuIE1hdGguZXhwKC0wLjUgKiB6ICogeikgLyAoc3RkZXYgKiBTUVJUMlBJKTtcbn0gLy8gQXBwcm94aW1hdGlvbiBmcm9tIFdlc3QgKDIwMDkpXG4vLyBCZXR0ZXIgQXBwcm94aW1hdGlvbnMgdG8gQ3VtdWxhdGl2ZSBOb3JtYWwgRnVuY3Rpb25zXG5cbmZ1bmN0aW9uIGN1bXVsYXRpdmVOb3JtYWwodmFsdWUsIG1lYW4sIHN0ZGV2KSB7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgY29uc3QgeiA9ICh2YWx1ZSAtIG1lYW4pIC8gc3RkZXYsXG4gICAgICAgIFogPSBNYXRoLmFicyh6KTtcbiAgbGV0IGNkO1xuXG4gIGlmIChaID4gMzcpIHtcbiAgICBjZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXhwID0gTWF0aC5leHAoLVogKiBaIC8gMik7XG4gICAgbGV0IHN1bTtcblxuICAgIGlmIChaIDwgNy4wNzEwNjc4MTE4NjU0Nykge1xuICAgICAgc3VtID0gMy41MjYyNDk2NTk5ODkxMWUtMDIgKiBaICsgMC43MDAzODMwNjQ0NDM2ODg7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgNi4zNzM5NjIyMDM1MzE2NTtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyAzMy45MTI4NjYwNzgzODM7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMTEyLjA3OTI5MTQ5Nzg3MTtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyAyMjEuMjEzNTk2MTY5OTMxO1xuICAgICAgc3VtID0gc3VtICogWiArIDIyMC4yMDY4Njc5MTIzNzY7XG4gICAgICBjZCA9IGV4cCAqIHN1bTtcbiAgICAgIHN1bSA9IDguODM4ODM0NzY0ODMxODRlLTAyICogWiArIDEuNzU1NjY3MTYzMTgyNjQ7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMTYuMDY0MTc3NTc5MjA3O1xuICAgICAgc3VtID0gc3VtICogWiArIDg2Ljc4MDczMjIwMjk0NjE7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMjk2LjU2NDI0ODc3OTY3NDtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyA2MzcuMzMzNjMzMzc4ODMxO1xuICAgICAgc3VtID0gc3VtICogWiArIDc5My44MjY1MTI1MTk5NDg7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgNDQwLjQxMzczNTgyNDc1MjtcbiAgICAgIGNkID0gY2QgLyBzdW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bSA9IFogKyAwLjY1O1xuICAgICAgc3VtID0gWiArIDQgLyBzdW07XG4gICAgICBzdW0gPSBaICsgMyAvIHN1bTtcbiAgICAgIHN1bSA9IFogKyAyIC8gc3VtO1xuICAgICAgc3VtID0gWiArIDEgLyBzdW07XG4gICAgICBjZCA9IGV4cCAvIHN1bSAvIDIuNTA2NjI4Mjc0NjMxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB6ID4gMCA/IDEgLSBjZCA6IGNkO1xufSAvLyBBcHByb3hpbWF0aW9uIG9mIFByb2JpdCBmdW5jdGlvbiB1c2luZyBpbnZlcnNlIGVycm9yIGZ1bmN0aW9uLlxuXG5mdW5jdGlvbiBxdWFudGlsZU5vcm1hbChwLCBtZWFuLCBzdGRldikge1xuICBpZiAocCA8IDAgfHwgcCA+IDEpIHJldHVybiBOYU47XG4gIHJldHVybiAobWVhbiB8fCAwKSArIChzdGRldiA9PSBudWxsID8gMSA6IHN0ZGV2KSAqIFNRUlQyICogZXJmaW52KDIgKiBwIC0gMSk7XG59IC8vIEFwcHJveGltYXRlIGludmVyc2UgZXJyb3IgZnVuY3Rpb24uIEltcGxlbWVudGF0aW9uIGZyb20gXCJBcHByb3hpbWF0aW5nXG4vLyB0aGUgZXJmaW52IGZ1bmN0aW9uXCIgYnkgTWlrZSBHaWxlcywgR1BVIENvbXB1dGluZyBHZW1zLCB2b2x1bWUgMiwgMjAxMC5cbi8vIFBvcnRlZCBmcm9tIEFwYWNoZSBDb21tb25zIE1hdGgsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5mdW5jdGlvbiBlcmZpbnYoeCkge1xuICAvLyBiZXdhcmUgdGhhdCB0aGUgbG9nYXJpdGhtIGFyZ3VtZW50IG11c3QgYmVcbiAgLy8gY29tbXB1dGVkIGFzICgxLjAgLSB4KSAqICgxLjAgKyB4KSxcbiAgLy8gaXQgbXVzdCBOT1QgYmUgc2ltcGxpZmllZCBhcyAxLjAgLSB4ICogeCBhcyB0aGlzXG4gIC8vIHdvdWxkIGluZHVjZSByb3VuZGluZyBlcnJvcnMgbmVhciB0aGUgYm91bmRhcmllcyArLy0xXG4gIGxldCB3ID0gLU1hdGgubG9nKCgxIC0geCkgKiAoMSArIHgpKSxcbiAgICAgIHA7XG5cbiAgaWYgKHcgPCA2LjI1KSB7XG4gICAgdyAtPSAzLjEyNTtcbiAgICBwID0gLTMuNjQ0NDEyMDY0MDE3ODE5Njk5NmUtMjE7XG4gICAgcCA9IC0xLjY4NTA1OTEzODE4MjAxNjU4OWUtMTkgKyBwICogdztcbiAgICBwID0gMS4yODU4NDgwNzE1MjU2NDAwMTY3ZS0xOCArIHAgKiB3O1xuICAgIHAgPSAxLjExNTc4Nzc2NzgwMjUxODA5NmUtMTcgKyBwICogdztcbiAgICBwID0gLTEuMzMzMTcxNjYyODU0NjIwOTA2ZS0xNiArIHAgKiB3O1xuICAgIHAgPSAyLjA5NzI3Njc4NzU5Njg1NjE2MzdlLTE3ICsgcCAqIHc7XG4gICAgcCA9IDYuNjM3NjM4MTM0MzU4MzIzODMyNWUtMTUgKyBwICogdztcbiAgICBwID0gLTQuMDU0NTY2MjcyOTc1MjA2ODYzOWUtMTQgKyBwICogdztcbiAgICBwID0gLTguMTUxOTM0MTk3NjA1NDcyMTUyMmUtMTQgKyBwICogdztcbiAgICBwID0gMi42MzM1MDkzMTUzMDgyMzIyOTc3ZS0xMiArIHAgKiB3O1xuICAgIHAgPSAtMS4yOTc1MTMzMjUzNDUzNTMyNDk4ZS0xMSArIHAgKiB3O1xuICAgIHAgPSAtNS40MTU0MTIwNTQyOTQ2Mjc5MzE3ZS0xMSArIHAgKiB3O1xuICAgIHAgPSAxLjA1MTIxMjI3MzMyMTUzMjI4NWUtMDkgKyBwICogdztcbiAgICBwID0gLTQuMTEyNjMzOTgwMzQ2OTgzNjk3NmUtMDkgKyBwICogdztcbiAgICBwID0gLTIuOTA3MDM2OTk1Nzg4MjAwNTA4NmUtMDggKyBwICogdztcbiAgICBwID0gNC4yMzQ3ODc3ODI3OTMyNDAzNTE4ZS0wNyArIHAgKiB3O1xuICAgIHAgPSAtMS4zNjU0NjkyMDAwODM0Njc4NjQ1ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAtMS4zODgyNTIzMzYyNzg2NDY4NzE5ZS0wNSArIHAgKiB3O1xuICAgIHAgPSAwLjAwMDE4NjczNDIwODAzNDA1NzEzNTIgKyBwICogdztcbiAgICBwID0gLTAuMDAwNzQwNzAyNTM0MTY2MjY2OTc1MTIgKyBwICogdztcbiAgICBwID0gLTAuMDA2MDMzNjcwODcxNDMwMTQ5MDUzMyArIHAgKiB3O1xuICAgIHAgPSAwLjI0MDE1ODE4MjQyNTU4OTYxNjkzICsgcCAqIHc7XG4gICAgcCA9IDEuNjUzNjU0NTYyNjgzMTAyNzM1NiArIHAgKiB3O1xuICB9IGVsc2UgaWYgKHcgPCAxNi4wKSB7XG4gICAgdyA9IE1hdGguc3FydCh3KSAtIDMuMjU7XG4gICAgcCA9IDIuMjEzNzM3NjkyMTc3NTc4NzA0OWUtMDk7XG4gICAgcCA9IDkuMDc1NjU2MTkzODg4NTM5MDk3OWUtMDggKyBwICogdztcbiAgICBwID0gLTIuNzUxNzQwNjI5NzA2NDU0NTQyOGUtMDcgKyBwICogdztcbiAgICBwID0gMS44MjM5NjI5MjE0Mzg5MjI3NzU1ZS0wOCArIHAgKiB3O1xuICAgIHAgPSAxLjUwMjc0MDM5Njg5MDk4Mjc2MjdlLTA2ICsgcCAqIHc7XG4gICAgcCA9IC00LjAxMzg2NzUyNjk4MTU0NTk2OWUtMDYgKyBwICogdztcbiAgICBwID0gMi45MjM0NDQ5MDg5OTU1NDQ2MDQ0ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAxLjI0NzUzMDQ0ODE2NzE3Nzg3MjNlLTA1ICsgcCAqIHc7XG4gICAgcCA9IC00LjczMTgyMjkwMDkwNTU3MzM5ODFlLTA1ICsgcCAqIHc7XG4gICAgcCA9IDYuODI4NDg1MTQ1OTU3MzE3NTQ0OGUtMDUgKyBwICogdztcbiAgICBwID0gMi40MDMxMTEwMzg3MDk3ODkzOTk5ZS0wNSArIHAgKiB3O1xuICAgIHAgPSAtMC4wMDAzNTUwMzc1MjAzNjI4NDc0Nzk2ICsgcCAqIHc7XG4gICAgcCA9IDAuMDAwOTUzMjg5Mzc5NzM3MzgwNDk3MDMgKyBwICogdztcbiAgICBwID0gLTAuMDAxNjg4Mjc1NTU2MDIzNTA0NzMxMyArIHAgKiB3O1xuICAgIHAgPSAwLjAwMjQ5MTQ0MjA5NjEwNzg1MDgwNjYgKyBwICogdztcbiAgICBwID0gLTAuMDAzNzUxMjA4NTA3NTY5MjQxMjEwNyArIHAgKiB3O1xuICAgIHAgPSAwLjAwNTM3MDkxNDU1MzU5MDA2MzYxNyArIHAgKiB3O1xuICAgIHAgPSAxLjAwNTI1ODk2NzY5NDE1OTIzMzQgKyBwICogdztcbiAgICBwID0gMy4wODM4ODU2MTA0OTIyMjA3NjM1ICsgcCAqIHc7XG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKHcpKSB7XG4gICAgdyA9IE1hdGguc3FydCh3KSAtIDUuMDtcbiAgICBwID0gLTIuNzEwOTkyMDYxNjQzODU3MzI0M2UtMTE7XG4gICAgcCA9IC0yLjU1NTY0MTgxNjk5NjUyNTIwNTVlLTEwICsgcCAqIHc7XG4gICAgcCA9IDEuNTA3NjU3MjY5MzUwMDU0ODA4M2UtMDkgKyBwICogdztcbiAgICBwID0gLTMuNzg5NDY1NDQwMTI2NzM2OTkzN2UtMDkgKyBwICogdztcbiAgICBwID0gNy42MTU3MDEyMDgwNzgzMzkzODA0ZS0wOSArIHAgKiB3O1xuICAgIHAgPSAtMS40OTYwMDI2NjI3MTQ5MjQwNDc4ZS0wOCArIHAgKiB3O1xuICAgIHAgPSAyLjkxNDc5NTM0NTA5MDEwODA4MjZlLTA4ICsgcCAqIHc7XG4gICAgcCA9IC02Ljc3MTE5OTc3NTg0NTIzMzk0OThlLTA4ICsgcCAqIHc7XG4gICAgcCA9IDIuMjkwMDQ4MjIyODAyNjY1NDcxN2UtMDcgKyBwICogdztcbiAgICBwID0gLTkuOTI5ODI3Mjk0MjMxNzAwMjUzOWUtMDcgKyBwICogdztcbiAgICBwID0gNC41MjYwNjI1OTcyMjMxNTM3MDM5ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAtMS45NjgxNzc4MTA1NTMxNjcwNTY3ZS0wNSArIHAgKiB3O1xuICAgIHAgPSA3LjU5OTUyNzcwMzAwMTc3NjExMzllLTA1ICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwMDIxNTAzMDExOTMwMDQ0NDc3MzQ3ICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwMDEzODcxOTMxODMzNjIzMTIyMDI2ICsgcCAqIHc7XG4gICAgcCA9IDEuMDEwMzAwNDY0ODY0NTM0Mzk3NyArIHAgKiB3O1xuICAgIHAgPSA0Ljg0OTkwNjQwMTQwODU4NDQyMjEgKyBwICogdztcbiAgfSBlbHNlIHtcbiAgICBwID0gSW5maW5pdHk7XG4gIH1cblxuICByZXR1cm4gcCAqIHg7XG59XG5cbmZ1bmN0aW9uIGdhdXNzaWFuIChtZWFuLCBzdGRldikge1xuICBsZXQgbXUsIHNpZ21hO1xuICBjb25zdCBkaXN0ID0ge1xuICAgIG1lYW4oXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgbXUgPSBfIHx8IDA7XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG11O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGRldihfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBzaWdtYSA9IF8gPT0gbnVsbCA/IDEgOiBfO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWdtYTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2FtcGxlOiAoKSA9PiBzYW1wbGVOb3JtYWwobXUsIHNpZ21hKSxcbiAgICBwZGY6IHZhbHVlID0+IGRlbnNpdHlOb3JtYWwodmFsdWUsIG11LCBzaWdtYSksXG4gICAgY2RmOiB2YWx1ZSA9PiBjdW11bGF0aXZlTm9ybWFsKHZhbHVlLCBtdSwgc2lnbWEpLFxuICAgIGljZGY6IHAgPT4gcXVhbnRpbGVOb3JtYWwocCwgbXUsIHNpZ21hKVxuICB9O1xuICByZXR1cm4gZGlzdC5tZWFuKG1lYW4pLnN0ZGV2KHN0ZGV2KTtcbn1cblxuZnVuY3Rpb24ga2RlIChzdXBwb3J0LCBiYW5kd2lkdGgpIHtcbiAgY29uc3Qga2VybmVsID0gZ2F1c3NpYW4oKTtcbiAgbGV0IG4gPSAwO1xuICBjb25zdCBkaXN0ID0ge1xuICAgIGRhdGEoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgc3VwcG9ydCA9IF87XG4gICAgICAgIG4gPSBfID8gXy5sZW5ndGggOiAwO1xuICAgICAgICByZXR1cm4gZGlzdC5iYW5kd2lkdGgoYmFuZHdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBiYW5kd2lkdGgoXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYmFuZHdpZHRoO1xuICAgICAgYmFuZHdpZHRoID0gXztcbiAgICAgIGlmICghYmFuZHdpZHRoICYmIHN1cHBvcnQpIGJhbmR3aWR0aCA9IGVzdGltYXRlQmFuZHdpZHRoKHN1cHBvcnQpO1xuICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgfSxcblxuICAgIHNhbXBsZSgpIHtcbiAgICAgIHJldHVybiBzdXBwb3J0W35+KHJhbmRvbSgpICogbildICsgYmFuZHdpZHRoICoga2VybmVsLnNhbXBsZSgpO1xuICAgIH0sXG5cbiAgICBwZGYoeCkge1xuICAgICAgbGV0IHkgPSAwLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICB5ICs9IGtlcm5lbC5wZGYoKHggLSBzdXBwb3J0W2ldKSAvIGJhbmR3aWR0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB5IC8gYmFuZHdpZHRoIC8gbjtcbiAgICB9LFxuXG4gICAgY2RmKHgpIHtcbiAgICAgIGxldCB5ID0gMCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgeSArPSBrZXJuZWwuY2RmKCh4IC0gc3VwcG9ydFtpXSkgLyBiYW5kd2lkdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geSAvIG47XG4gICAgfSxcblxuICAgIGljZGYoKSB7XG4gICAgICB0aHJvdyBFcnJvcignS0RFIGljZGYgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgfTtcbiAgcmV0dXJuIGRpc3QuZGF0YShzdXBwb3J0KTtcbn1cblxuZnVuY3Rpb24gc2FtcGxlTG9nTm9ybWFsKG1lYW4sIHN0ZGV2KSB7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgcmV0dXJuIE1hdGguZXhwKG1lYW4gKyBzYW1wbGVOb3JtYWwoKSAqIHN0ZGV2KTtcbn1cbmZ1bmN0aW9uIGRlbnNpdHlMb2dOb3JtYWwodmFsdWUsIG1lYW4sIHN0ZGV2KSB7XG4gIGlmICh2YWx1ZSA8PSAwKSByZXR1cm4gMDtcbiAgbWVhbiA9IG1lYW4gfHwgMDtcbiAgc3RkZXYgPSBzdGRldiA9PSBudWxsID8gMSA6IHN0ZGV2O1xuICBjb25zdCB6ID0gKE1hdGgubG9nKHZhbHVlKSAtIG1lYW4pIC8gc3RkZXY7XG4gIHJldHVybiBNYXRoLmV4cCgtMC41ICogeiAqIHopIC8gKHN0ZGV2ICogU1FSVDJQSSAqIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGN1bXVsYXRpdmVMb2dOb3JtYWwodmFsdWUsIG1lYW4sIHN0ZGV2KSB7XG4gIHJldHVybiBjdW11bGF0aXZlTm9ybWFsKE1hdGgubG9nKHZhbHVlKSwgbWVhbiwgc3RkZXYpO1xufVxuZnVuY3Rpb24gcXVhbnRpbGVMb2dOb3JtYWwocCwgbWVhbiwgc3RkZXYpIHtcbiAgcmV0dXJuIE1hdGguZXhwKHF1YW50aWxlTm9ybWFsKHAsIG1lYW4sIHN0ZGV2KSk7XG59XG5mdW5jdGlvbiBsb2dub3JtYWwgKG1lYW4sIHN0ZGV2KSB7XG4gIGxldCBtdSwgc2lnbWE7XG4gIGNvbnN0IGRpc3QgPSB7XG4gICAgbWVhbihfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBtdSA9IF8gfHwgMDtcbiAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbXU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0ZGV2KF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHNpZ21hID0gXyA9PSBudWxsID8gMSA6IF87XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZ21hO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzYW1wbGU6ICgpID0+IHNhbXBsZUxvZ05vcm1hbChtdSwgc2lnbWEpLFxuICAgIHBkZjogdmFsdWUgPT4gZGVuc2l0eUxvZ05vcm1hbCh2YWx1ZSwgbXUsIHNpZ21hKSxcbiAgICBjZGY6IHZhbHVlID0+IGN1bXVsYXRpdmVMb2dOb3JtYWwodmFsdWUsIG11LCBzaWdtYSksXG4gICAgaWNkZjogcCA9PiBxdWFudGlsZUxvZ05vcm1hbChwLCBtdSwgc2lnbWEpXG4gIH07XG4gIHJldHVybiBkaXN0Lm1lYW4obWVhbikuc3RkZXYoc3RkZXYpO1xufVxuXG5mdW5jdGlvbiBtaXh0dXJlIChkaXN0cywgd2VpZ2h0cykge1xuICBsZXQgbSA9IDAsXG4gICAgICB3O1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZSh4KSB7XG4gICAgY29uc3QgdyA9IFtdO1xuICAgIGxldCBzdW0gPSAwLFxuICAgICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgc3VtICs9IHdbaV0gPSB4W2ldID09IG51bGwgPyAxIDogK3hbaV07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgd1tpXSAvPSBzdW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICBjb25zdCBkaXN0ID0ge1xuICAgIHdlaWdodHMoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdyA9IG5vcm1hbGl6ZSh3ZWlnaHRzID0gXyB8fCBbXSk7XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2VpZ2h0cztcbiAgICB9LFxuXG4gICAgZGlzdHJpYnV0aW9ucyhfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoXykge1xuICAgICAgICAgIG0gPSBfLmxlbmd0aDtcbiAgICAgICAgICBkaXN0cyA9IF87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgZGlzdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0LndlaWdodHMod2VpZ2h0cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXN0cztcbiAgICB9LFxuXG4gICAgc2FtcGxlKCkge1xuICAgICAgY29uc3QgciA9IHJhbmRvbSgpO1xuICAgICAgbGV0IGQgPSBkaXN0c1ttIC0gMV0sXG4gICAgICAgICAgdiA9IHdbMF0sXG4gICAgICAgICAgaSA9IDA7IC8vIGZpcnN0IHNlbGVjdCBkaXN0cmlidXRpb25cblxuICAgICAgZm9yICg7IGkgPCBtIC0gMTsgdiArPSB3WysraV0pIHtcbiAgICAgICAgaWYgKHIgPCB2KSB7XG4gICAgICAgICAgZCA9IGRpc3RzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIHRoZW4gc2FtcGxlIGZyb20gaXRcblxuXG4gICAgICByZXR1cm4gZC5zYW1wbGUoKTtcbiAgICB9LFxuXG4gICAgcGRmKHgpIHtcbiAgICAgIGxldCBwID0gMCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgcCArPSB3W2ldICogZGlzdHNbaV0ucGRmKHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgY2RmKHgpIHtcbiAgICAgIGxldCBwID0gMCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgcCArPSB3W2ldICogZGlzdHNbaV0uY2RmKHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgaWNkZigpIHtcbiAgICAgIHRocm93IEVycm9yKCdNaXh0dXJlIGljZGYgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgfTtcbiAgcmV0dXJuIGRpc3QuZGlzdHJpYnV0aW9ucyhkaXN0cykud2VpZ2h0cyh3ZWlnaHRzKTtcbn1cblxuZnVuY3Rpb24gc2FtcGxlVW5pZm9ybShtaW4sIG1heCkge1xuICBpZiAobWF4ID09IG51bGwpIHtcbiAgICBtYXggPSBtaW4gPT0gbnVsbCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuXG4gIHJldHVybiBtaW4gKyAobWF4IC0gbWluKSAqIHJhbmRvbSgpO1xufVxuZnVuY3Rpb24gZGVuc2l0eVVuaWZvcm0odmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT0gbnVsbCkge1xuICAgIG1heCA9IG1pbiA9PSBudWxsID8gMSA6IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXggPyAxIC8gKG1heCAtIG1pbikgOiAwO1xufVxuZnVuY3Rpb24gY3VtdWxhdGl2ZVVuaWZvcm0odmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT0gbnVsbCkge1xuICAgIG1heCA9IG1pbiA9PSBudWxsID8gMSA6IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gMCA6IHZhbHVlID4gbWF4ID8gMSA6ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbn1cbmZ1bmN0aW9uIHF1YW50aWxlVW5pZm9ybShwLCBtaW4sIG1heCkge1xuICBpZiAobWF4ID09IG51bGwpIHtcbiAgICBtYXggPSBtaW4gPT0gbnVsbCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuXG4gIHJldHVybiBwID49IDAgJiYgcCA8PSAxID8gbWluICsgcCAqIChtYXggLSBtaW4pIDogTmFOO1xufVxuZnVuY3Rpb24gdW5pZm9ybSAobWluLCBtYXgpIHtcbiAgbGV0IGEsIGI7XG4gIGNvbnN0IGRpc3QgPSB7XG4gICAgbWluKF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGEgPSBfIHx8IDA7XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1heChfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBiID0gXyA9PSBudWxsID8gMSA6IF87XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNhbXBsZTogKCkgPT4gc2FtcGxlVW5pZm9ybShhLCBiKSxcbiAgICBwZGY6IHZhbHVlID0+IGRlbnNpdHlVbmlmb3JtKHZhbHVlLCBhLCBiKSxcbiAgICBjZGY6IHZhbHVlID0+IGN1bXVsYXRpdmVVbmlmb3JtKHZhbHVlLCBhLCBiKSxcbiAgICBpY2RmOiBwID0+IHF1YW50aWxlVW5pZm9ybShwLCBhLCBiKVxuICB9O1xuXG4gIGlmIChtYXggPT0gbnVsbCkge1xuICAgIG1heCA9IG1pbiA9PSBudWxsID8gMSA6IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG5cbiAgcmV0dXJuIGRpc3QubWluKG1pbikubWF4KG1heCk7XG59XG5cbi8vIE9yZGluYXJ5IExlYXN0IFNxdWFyZXNcbmZ1bmN0aW9uIG9scyAodVgsIHVZLCB1WFksIHVYMikge1xuICBjb25zdCBkZWx0YSA9IHVYMiAtIHVYICogdVgsXG4gICAgICAgIHNsb3BlID0gTWF0aC5hYnMoZGVsdGEpIDwgMWUtMjQgPyAwIDogKHVYWSAtIHVYICogdVkpIC8gZGVsdGEsXG4gICAgICAgIGludGVyY2VwdCA9IHVZIC0gc2xvcGUgKiB1WDtcbiAgcmV0dXJuIFtpbnRlcmNlcHQsIHNsb3BlXTtcbn1cblxuZnVuY3Rpb24gcG9pbnRzKGRhdGEsIHgsIHksIHNvcnQpIHtcbiAgZGF0YSA9IGRhdGEuZmlsdGVyKGQgPT4ge1xuICAgIGxldCB1ID0geChkKSxcbiAgICAgICAgdiA9IHkoZCk7XG4gICAgcmV0dXJuIHUgIT0gbnVsbCAmJiAodSA9ICt1KSA+PSB1ICYmIHYgIT0gbnVsbCAmJiAodiA9ICt2KSA+PSB2O1xuICB9KTtcblxuICBpZiAoc29ydCkge1xuICAgIGRhdGEuc29ydCgoYSwgYikgPT4geChhKSAtIHgoYikpO1xuICB9XG5cbiAgY29uc3QgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBYID0gbmV3IEZsb2F0NjRBcnJheShuKSxcbiAgICAgICAgWSA9IG5ldyBGbG9hdDY0QXJyYXkobik7IC8vIGV4dHJhY3QgdmFsdWVzLCBjYWxjdWxhdGUgbWVhbnNcblxuICBsZXQgaSA9IDAsXG4gICAgICB1eCA9IDAsXG4gICAgICB1eSA9IDAsXG4gICAgICB4dixcbiAgICAgIHl2LFxuICAgICAgZDtcblxuICBmb3IgKGQgb2YgZGF0YSkge1xuICAgIFhbaV0gPSB4diA9ICt4KGQpO1xuICAgIFlbaV0gPSB5diA9ICt5KGQpO1xuICAgICsraTtcbiAgICB1eCArPSAoeHYgLSB1eCkgLyBpO1xuICAgIHV5ICs9ICh5diAtIHV5KSAvIGk7XG4gIH0gLy8gbWVhbiBjZW50ZXIgdGhlIGRhdGFcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBYW2ldIC09IHV4O1xuICAgIFlbaV0gLT0gdXk7XG4gIH1cblxuICByZXR1cm4gW1gsIFksIHV4LCB1eV07XG59XG5mdW5jdGlvbiB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCBjYWxsYmFjaykge1xuICBsZXQgaSA9IC0xLFxuICAgICAgdSxcbiAgICAgIHY7XG5cbiAgZm9yIChjb25zdCBkIG9mIGRhdGEpIHtcbiAgICB1ID0geChkKTtcbiAgICB2ID0geShkKTtcblxuICAgIGlmICh1ICE9IG51bGwgJiYgKHUgPSArdSkgPj0gdSAmJiB2ICE9IG51bGwgJiYgKHYgPSArdikgPj0gdikge1xuICAgICAgY2FsbGJhY2sodSwgdiwgKytpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL0hhcnJ5U3RldmVucy9kMy1yZWdyZXNzaW9uL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuZnVuY3Rpb24gclNxdWFyZWQgKGRhdGEsIHgsIHksIHVZLCBwcmVkaWN0KSB7XG4gIGxldCBTU0UgPSAwLFxuICAgICAgU1NUID0gMDtcbiAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgKGR4LCBkeSkgPT4ge1xuICAgIGNvbnN0IHNzZSA9IGR5IC0gcHJlZGljdChkeCksXG4gICAgICAgICAgc3N0ID0gZHkgLSB1WTtcbiAgICBTU0UgKz0gc3NlICogc3NlO1xuICAgIFNTVCArPSBzc3QgKiBzc3Q7XG4gIH0pO1xuICByZXR1cm4gMSAtIFNTRSAvIFNTVDtcbn1cblxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL0hhcnJ5U3RldmVucy9kMy1yZWdyZXNzaW9uL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuZnVuY3Rpb24gbGluZWFyIChkYXRhLCB4LCB5KSB7XG4gIGxldCBYID0gMCxcbiAgICAgIFkgPSAwLFxuICAgICAgWFkgPSAwLFxuICAgICAgWDIgPSAwLFxuICAgICAgbiA9IDA7XG4gIHZpc2l0UG9pbnRzKGRhdGEsIHgsIHksIChkeCwgZHkpID0+IHtcbiAgICArK247XG4gICAgWCArPSAoZHggLSBYKSAvIG47XG4gICAgWSArPSAoZHkgLSBZKSAvIG47XG4gICAgWFkgKz0gKGR4ICogZHkgLSBYWSkgLyBuO1xuICAgIFgyICs9IChkeCAqIGR4IC0gWDIpIC8gbjtcbiAgfSk7XG5cbiAgY29uc3QgY29lZiA9IG9scyhYLCBZLCBYWSwgWDIpLFxuICAgICAgICBwcmVkaWN0ID0geCA9PiBjb2VmWzBdICsgY29lZlsxXSAqIHg7XG5cbiAgcmV0dXJuIHtcbiAgICBjb2VmOiBjb2VmLFxuICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgclNxdWFyZWQ6IHJTcXVhcmVkKGRhdGEsIHgsIHksIFksIHByZWRpY3QpXG4gIH07XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9IYXJyeVN0ZXZlbnMvZDMtcmVncmVzc2lvbi9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmZ1bmN0aW9uIGxvZyAoZGF0YSwgeCwgeSkge1xuICBsZXQgWCA9IDAsXG4gICAgICBZID0gMCxcbiAgICAgIFhZID0gMCxcbiAgICAgIFgyID0gMCxcbiAgICAgIG4gPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCAoZHgsIGR5KSA9PiB7XG4gICAgKytuO1xuICAgIGR4ID0gTWF0aC5sb2coZHgpO1xuICAgIFggKz0gKGR4IC0gWCkgLyBuO1xuICAgIFkgKz0gKGR5IC0gWSkgLyBuO1xuICAgIFhZICs9IChkeCAqIGR5IC0gWFkpIC8gbjtcbiAgICBYMiArPSAoZHggKiBkeCAtIFgyKSAvIG47XG4gIH0pO1xuXG4gIGNvbnN0IGNvZWYgPSBvbHMoWCwgWSwgWFksIFgyKSxcbiAgICAgICAgcHJlZGljdCA9IHggPT4gY29lZlswXSArIGNvZWZbMV0gKiBNYXRoLmxvZyh4KTtcblxuICByZXR1cm4ge1xuICAgIGNvZWY6IGNvZWYsXG4gICAgcHJlZGljdDogcHJlZGljdCxcbiAgICByU3F1YXJlZDogclNxdWFyZWQoZGF0YSwgeCwgeSwgWSwgcHJlZGljdClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwIChkYXRhLCB4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25zdCBbeHYsIHl2LCB1eCwgdXldID0gcG9pbnRzKGRhdGEsIHgsIHkpO1xuICBsZXQgWUwgPSAwLFxuICAgICAgWFkgPSAwLFxuICAgICAgWFlMID0gMCxcbiAgICAgIFgyWSA9IDAsXG4gICAgICBuID0gMCxcbiAgICAgIGR4LFxuICAgICAgbHksXG4gICAgICB4eTtcbiAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgKF8sIGR5KSA9PiB7XG4gICAgZHggPSB4dltuKytdO1xuICAgIGx5ID0gTWF0aC5sb2coZHkpO1xuICAgIHh5ID0gZHggKiBkeTtcbiAgICBZTCArPSAoZHkgKiBseSAtIFlMKSAvIG47XG4gICAgWFkgKz0gKHh5IC0gWFkpIC8gbjtcbiAgICBYWUwgKz0gKHh5ICogbHkgLSBYWUwpIC8gbjtcbiAgICBYMlkgKz0gKGR4ICogeHkgLSBYMlkpIC8gbjtcbiAgfSk7XG5cbiAgY29uc3QgW2MwLCBjMV0gPSBvbHMoWFkgLyB1eSwgWUwgLyB1eSwgWFlMIC8gdXksIFgyWSAvIHV5KSxcbiAgICAgICAgcHJlZGljdCA9IHggPT4gTWF0aC5leHAoYzAgKyBjMSAqICh4IC0gdXgpKTtcblxuICByZXR1cm4ge1xuICAgIGNvZWY6IFtNYXRoLmV4cChjMCAtIGMxICogdXgpLCBjMV0sXG4gICAgcHJlZGljdDogcHJlZGljdCxcbiAgICByU3F1YXJlZDogclNxdWFyZWQoZGF0YSwgeCwgeSwgdXksIHByZWRpY3QpXG4gIH07XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9IYXJyeVN0ZXZlbnMvZDMtcmVncmVzc2lvbi9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmZ1bmN0aW9uIHBvdyAoZGF0YSwgeCwgeSkge1xuICBsZXQgWCA9IDAsXG4gICAgICBZID0gMCxcbiAgICAgIFhZID0gMCxcbiAgICAgIFgyID0gMCxcbiAgICAgIFlTID0gMCxcbiAgICAgIG4gPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCAoZHgsIGR5KSA9PiB7XG4gICAgY29uc3QgbHggPSBNYXRoLmxvZyhkeCksXG4gICAgICAgICAgbHkgPSBNYXRoLmxvZyhkeSk7XG4gICAgKytuO1xuICAgIFggKz0gKGx4IC0gWCkgLyBuO1xuICAgIFkgKz0gKGx5IC0gWSkgLyBuO1xuICAgIFhZICs9IChseCAqIGx5IC0gWFkpIC8gbjtcbiAgICBYMiArPSAobHggKiBseCAtIFgyKSAvIG47XG4gICAgWVMgKz0gKGR5IC0gWVMpIC8gbjtcbiAgfSk7XG5cbiAgY29uc3QgY29lZiA9IG9scyhYLCBZLCBYWSwgWDIpLFxuICAgICAgICBwcmVkaWN0ID0geCA9PiBjb2VmWzBdICogTWF0aC5wb3coeCwgY29lZlsxXSk7XG5cbiAgY29lZlswXSA9IE1hdGguZXhwKGNvZWZbMF0pO1xuICByZXR1cm4ge1xuICAgIGNvZWY6IGNvZWYsXG4gICAgcHJlZGljdDogcHJlZGljdCxcbiAgICByU3F1YXJlZDogclNxdWFyZWQoZGF0YSwgeCwgeSwgWVMsIHByZWRpY3QpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHF1YWQgKGRhdGEsIHgsIHkpIHtcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5KSxcbiAgICAgICAgbiA9IHh2Lmxlbmd0aDtcbiAgbGV0IFgyID0gMCxcbiAgICAgIFgzID0gMCxcbiAgICAgIFg0ID0gMCxcbiAgICAgIFhZID0gMCxcbiAgICAgIFgyWSA9IDAsXG4gICAgICBpLFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIHgyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOykge1xuICAgIGR4ID0geHZbaV07XG4gICAgZHkgPSB5dltpKytdO1xuICAgIHgyID0gZHggKiBkeDtcbiAgICBYMiArPSAoeDIgLSBYMikgLyBpO1xuICAgIFgzICs9ICh4MiAqIGR4IC0gWDMpIC8gaTtcbiAgICBYNCArPSAoeDIgKiB4MiAtIFg0KSAvIGk7XG4gICAgWFkgKz0gKGR4ICogZHkgLSBYWSkgLyBpO1xuICAgIFgyWSArPSAoeDIgKiBkeSAtIFgyWSkgLyBpO1xuICB9XG5cbiAgY29uc3QgWDJYMiA9IFg0IC0gWDIgKiBYMixcbiAgICAgICAgZCA9IFgyICogWDJYMiAtIFgzICogWDMsXG4gICAgICAgIGEgPSAoWDJZICogWDIgLSBYWSAqIFgzKSAvIGQsXG4gICAgICAgIGIgPSAoWFkgKiBYMlgyIC0gWDJZICogWDMpIC8gZCxcbiAgICAgICAgYyA9IC1hICogWDIsXG4gICAgICAgIHByZWRpY3QgPSB4ID0+IHtcbiAgICB4ID0geCAtIHV4O1xuICAgIHJldHVybiBhICogeCAqIHggKyBiICogeCArIGMgKyB1eTtcbiAgfTsgLy8gdHJhbnNmb3JtIGNvZWZmaWNpZW50cyBiYWNrIGZyb20gbWVhbi1jZW50ZXJlZCBzcGFjZVxuXG5cbiAgcmV0dXJuIHtcbiAgICBjb2VmOiBbYyAtIGIgKiB1eCArIGEgKiB1eCAqIHV4ICsgdXksIGIgLSAyICogYSAqIHV4LCBhXSxcbiAgICBwcmVkaWN0OiBwcmVkaWN0LFxuICAgIHJTcXVhcmVkOiByU3F1YXJlZChkYXRhLCB4LCB5LCB1eSwgcHJlZGljdClcbiAgfTtcbn1cblxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL0hhcnJ5U3RldmVucy9kMy1yZWdyZXNzaW9uL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbi8vIC4uLiB3aGljaCB3YXMgYWRhcHRlZCBmcm9tIHJlZ3Jlc3Npb24tanMgYnkgVG9tIEFsZXhhbmRlclxuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vVG9tLUFsZXhhbmRlci9yZWdyZXNzaW9uLWpzL2Jsb2IvbWFzdGVyL3NyYy9yZWdyZXNzaW9uLmpzI0wyNDZcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9Ub20tQWxleGFuZGVyL3JlZ3Jlc3Npb24tanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG5mdW5jdGlvbiBwb2x5IChkYXRhLCB4LCB5LCBvcmRlcikge1xuICAvLyB1c2UgbW9yZSBlZmZpY2llbnQgbWV0aG9kcyBmb3IgbG93ZXIgb3JkZXJzXG4gIGlmIChvcmRlciA9PT0gMSkgcmV0dXJuIGxpbmVhcihkYXRhLCB4LCB5KTtcbiAgaWYgKG9yZGVyID09PSAyKSByZXR1cm4gcXVhZChkYXRhLCB4LCB5KTtcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5KSxcbiAgICAgICAgbiA9IHh2Lmxlbmd0aCxcbiAgICAgICAgbGhzID0gW10sXG4gICAgICAgIHJocyA9IFtdLFxuICAgICAgICBrID0gb3JkZXIgKyAxO1xuICBsZXQgaSwgaiwgbCwgdiwgYztcblxuICBmb3IgKGkgPSAwOyBpIDwgazsgKytpKSB7XG4gICAgZm9yIChsID0gMCwgdiA9IDA7IGwgPCBuOyArK2wpIHtcbiAgICAgIHYgKz0gTWF0aC5wb3coeHZbbF0sIGkpICogeXZbbF07XG4gICAgfVxuXG4gICAgbGhzLnB1c2godik7XG4gICAgYyA9IG5ldyBGbG9hdDY0QXJyYXkoayk7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICBmb3IgKGwgPSAwLCB2ID0gMDsgbCA8IG47ICsrbCkge1xuICAgICAgICB2ICs9IE1hdGgucG93KHh2W2xdLCBpICsgaik7XG4gICAgICB9XG5cbiAgICAgIGNbal0gPSB2O1xuICAgIH1cblxuICAgIHJocy5wdXNoKGMpO1xuICB9XG5cbiAgcmhzLnB1c2gobGhzKTtcblxuICBjb25zdCBjb2VmID0gZ2F1c3NpYW5FbGltaW5hdGlvbihyaHMpLFxuICAgICAgICBwcmVkaWN0ID0geCA9PiB7XG4gICAgeCAtPSB1eDtcbiAgICBsZXQgeSA9IHV5ICsgY29lZlswXSArIGNvZWZbMV0gKiB4ICsgY29lZlsyXSAqIHggKiB4O1xuXG4gICAgZm9yIChpID0gMzsgaSA8IGs7ICsraSkgeSArPSBjb2VmW2ldICogTWF0aC5wb3coeCwgaSk7XG5cbiAgICByZXR1cm4geTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNvZWY6IHVuY2VudGVyKGssIGNvZWYsIC11eCwgdXkpLFxuICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgclNxdWFyZWQ6IHJTcXVhcmVkKGRhdGEsIHgsIHksIHV5LCBwcmVkaWN0KVxuICB9O1xufVxuXG5mdW5jdGlvbiB1bmNlbnRlcihrLCBhLCB4LCB5KSB7XG4gIGNvbnN0IHogPSBBcnJheShrKTtcbiAgbGV0IGksIGosIHYsIGM7IC8vIGluaXRpYWxpemUgdG8gemVyb1xuXG4gIGZvciAoaSA9IDA7IGkgPCBrOyArK2kpIHpbaV0gPSAwOyAvLyBwb2x5bm9taWFsIGV4cGFuc2lvblxuXG5cbiAgZm9yIChpID0gayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdiA9IGFbaV07XG4gICAgYyA9IDE7XG4gICAgeltpXSArPSB2O1xuXG4gICAgZm9yIChqID0gMTsgaiA8PSBpOyArK2opIHtcbiAgICAgIGMgKj0gKGkgKyAxIC0gaikgLyBqOyAvLyBiaW5vbWlhbCBjb2VmZmljZW50XG5cbiAgICAgIHpbaSAtIGpdICs9IHYgKiBNYXRoLnBvdyh4LCBqKSAqIGM7XG4gICAgfVxuICB9IC8vIGJpYXMgdGVybVxuXG5cbiAgelswXSArPSB5O1xuICByZXR1cm4gejtcbn0gLy8gR2l2ZW4gYW4gYXJyYXkgZm9yIGEgdHdvLWRpbWVuc2lvbmFsIG1hdHJpeCBhbmQgdGhlIHBvbHlub21pYWwgb3JkZXIsXG4vLyBzb2x2ZSBBICogeCA9IGIgdXNpbmcgR2F1c3NpYW4gZWxpbWluYXRpb24uXG5cblxuZnVuY3Rpb24gZ2F1c3NpYW5FbGltaW5hdGlvbihtYXRyaXgpIHtcbiAgY29uc3QgbiA9IG1hdHJpeC5sZW5ndGggLSAxLFxuICAgICAgICBjb2VmID0gW107XG4gIGxldCBpLCBqLCBrLCByLCB0O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICByID0gaTsgLy8gbWF4IHJvd1xuXG4gICAgZm9yIChqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgIGlmIChNYXRoLmFicyhtYXRyaXhbaV1bal0pID4gTWF0aC5hYnMobWF0cml4W2ldW3JdKSkge1xuICAgICAgICByID0gajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGsgPSBpOyBrIDwgbiArIDE7ICsraykge1xuICAgICAgdCA9IG1hdHJpeFtrXVtpXTtcbiAgICAgIG1hdHJpeFtrXVtpXSA9IG1hdHJpeFtrXVtyXTtcbiAgICAgIG1hdHJpeFtrXVtyXSA9IHQ7XG4gICAgfVxuXG4gICAgZm9yIChqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgIGZvciAoayA9IG47IGsgPj0gaTsgay0tKSB7XG4gICAgICAgIG1hdHJpeFtrXVtqXSAtPSBtYXRyaXhba11baV0gKiBtYXRyaXhbaV1bal0gLyBtYXRyaXhbaV1baV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChqID0gbiAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgdCA9IDA7XG5cbiAgICBmb3IgKGsgPSBqICsgMTsgayA8IG47ICsraykge1xuICAgICAgdCArPSBtYXRyaXhba11bal0gKiBjb2VmW2tdO1xuICAgIH1cblxuICAgIGNvZWZbal0gPSAobWF0cml4W25dW2pdIC0gdCkgLyBtYXRyaXhbal1bal07XG4gIH1cblxuICByZXR1cm4gY29lZjtcbn1cblxuY29uc3QgbWF4aXRlcnMgPSAyLFxuICAgICAgZXBzaWxvbiA9IDFlLTEyOyAvLyBBZGFwdGVkIGZyb20gc2NpZW5jZS5qcyBieSBKYXNvbiBEYXZpZXNcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2phc29uZGF2aWVzL3NjaWVuY2UuanMvYmxvYi9tYXN0ZXIvc3JjL3N0YXRzL2xvZXNzLmpzXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vamFzb25kYXZpZXMvc2NpZW5jZS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmZ1bmN0aW9uIGxvZXNzIChkYXRhLCB4LCB5LCBiYW5kd2lkdGgpIHtcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5LCB0cnVlKSxcbiAgICAgICAgbiA9IHh2Lmxlbmd0aCxcbiAgICAgICAgYncgPSBNYXRoLm1heCgyLCB+fihiYW5kd2lkdGggKiBuKSksXG4gICAgICAgIC8vICMgbmVhcmVzdCBuZWlnaGJvcnNcbiAgeWhhdCA9IG5ldyBGbG9hdDY0QXJyYXkobiksXG4gICAgICAgIHJlc2lkdWFscyA9IG5ldyBGbG9hdDY0QXJyYXkobiksXG4gICAgICAgIHJvYnVzdFdlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLmZpbGwoMSk7XG5cbiAgZm9yIChsZXQgaXRlciA9IC0xOyArK2l0ZXIgPD0gbWF4aXRlcnM7KSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBbMCwgYncgLSAxXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBkeCA9IHh2W2ldLFxuICAgICAgICAgICAgaTAgPSBpbnRlcnZhbFswXSxcbiAgICAgICAgICAgIGkxID0gaW50ZXJ2YWxbMV0sXG4gICAgICAgICAgICBlZGdlID0gZHggLSB4dltpMF0gPiB4dltpMV0gLSBkeCA/IGkwIDogaTE7XG4gICAgICBsZXQgVyA9IDAsXG4gICAgICAgICAgWCA9IDAsXG4gICAgICAgICAgWSA9IDAsXG4gICAgICAgICAgWFkgPSAwLFxuICAgICAgICAgIFgyID0gMDtcbiAgICAgIGNvbnN0IGRlbm9tID0gMSAvIE1hdGguYWJzKHh2W2VkZ2VdIC0gZHggfHwgMSk7IC8vIGF2b2lkIHNpbmd1bGFyaXR5IVxuXG4gICAgICBmb3IgKGxldCBrID0gaTA7IGsgPD0gaTE7ICsraykge1xuICAgICAgICBjb25zdCB4ayA9IHh2W2tdLFxuICAgICAgICAgICAgICB5ayA9IHl2W2tdLFxuICAgICAgICAgICAgICB3ID0gdHJpY3ViZShNYXRoLmFicyhkeCAtIHhrKSAqIGRlbm9tKSAqIHJvYnVzdFdlaWdodHNba10sXG4gICAgICAgICAgICAgIHhrdyA9IHhrICogdztcbiAgICAgICAgVyArPSB3O1xuICAgICAgICBYICs9IHhrdztcbiAgICAgICAgWSArPSB5ayAqIHc7XG4gICAgICAgIFhZICs9IHlrICogeGt3O1xuICAgICAgICBYMiArPSB4ayAqIHhrdztcbiAgICAgIH0gLy8gbGluZWFyIHJlZ3Jlc3Npb24gZml0XG5cblxuICAgICAgY29uc3QgW2EsIGJdID0gb2xzKFggLyBXLCBZIC8gVywgWFkgLyBXLCBYMiAvIFcpO1xuICAgICAgeWhhdFtpXSA9IGEgKyBiICogZHg7XG4gICAgICByZXNpZHVhbHNbaV0gPSBNYXRoLmFicyh5dltpXSAtIHloYXRbaV0pO1xuICAgICAgdXBkYXRlSW50ZXJ2YWwoeHYsIGkgKyAxLCBpbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZXIgPT09IG1heGl0ZXJzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBtZWRpYW5SZXNpZHVhbCA9IG1lZGlhbihyZXNpZHVhbHMpO1xuICAgIGlmIChNYXRoLmFicyhtZWRpYW5SZXNpZHVhbCkgPCBlcHNpbG9uKSBicmVhaztcblxuICAgIGZvciAobGV0IGkgPSAwLCBhcmcsIHc7IGkgPCBuOyArK2kpIHtcbiAgICAgIGFyZyA9IHJlc2lkdWFsc1tpXSAvICg2ICogbWVkaWFuUmVzaWR1YWwpOyAvLyBkZWZhdWx0IHRvIGVwc2lsb24gKHJhdGhlciB0aGFuIHplcm8pIGZvciBsYXJnZSBkZXZpYXRpb25zXG4gICAgICAvLyBrZWVwaW5nIHdlaWdodHMgdGlueSBidXQgbm9uLXplcm8gcHJldmVudHMgc2luZ3VsYXJpdGVzXG5cbiAgICAgIHJvYnVzdFdlaWdodHNbaV0gPSBhcmcgPj0gMSA/IGVwc2lsb24gOiAodyA9IDEgLSBhcmcgKiBhcmcpICogdztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0KHh2LCB5aGF0LCB1eCwgdXkpO1xufSAvLyB3ZWlnaHRpbmcga2VybmVsIGZvciBsb2NhbCByZWdyZXNzaW9uXG5cbmZ1bmN0aW9uIHRyaWN1YmUoeCkge1xuICByZXR1cm4gKHggPSAxIC0geCAqIHggKiB4KSAqIHggKiB4O1xufSAvLyBhZHZhbmNlIHNsaWRpbmcgd2luZG93IGludGVydmFsIG9mIG5lYXJlc3QgbmVpZ2hib3JzXG5cblxuZnVuY3Rpb24gdXBkYXRlSW50ZXJ2YWwoeHYsIGksIGludGVydmFsKSB7XG4gIGNvbnN0IHZhbCA9IHh2W2ldO1xuICBsZXQgbGVmdCA9IGludGVydmFsWzBdLFxuICAgICAgcmlnaHQgPSBpbnRlcnZhbFsxXSArIDE7XG4gIGlmIChyaWdodCA+PSB4di5sZW5ndGgpIHJldHVybjsgLy8gc3RlcCByaWdodCBpZiBkaXN0YW5jZSB0byBuZXcgcmlnaHQgZWRnZSBpcyA8PSBkaXN0YW5jZSB0byBvbGQgbGVmdCBlZGdlXG4gIC8vIHN0ZXAgd2hlbiBkaXN0YW5jZSBpcyBlcXVhbCB0byBlbnN1cmUgbW92ZW1lbnQgb3ZlciBkdXBsaWNhdGUgeCB2YWx1ZXNcblxuICB3aGlsZSAoaSA+IGxlZnQgJiYgeHZbcmlnaHRdIC0gdmFsIDw9IHZhbCAtIHh2W2xlZnRdKSB7XG4gICAgaW50ZXJ2YWxbMF0gPSArK2xlZnQ7XG4gICAgaW50ZXJ2YWxbMV0gPSByaWdodDtcbiAgICArK3JpZ2h0O1xuICB9XG59IC8vIGdlbmVyYXRlIHNtb290aGVkIG91dHB1dCBwb2ludHNcbi8vIGF2ZXJhZ2UgcG9pbnRzIHdpdGggcmVwZWF0ZWQgeCB2YWx1ZXNcblxuXG5mdW5jdGlvbiBvdXRwdXQoeHYsIHloYXQsIHV4LCB1eSkge1xuICBjb25zdCBuID0geHYubGVuZ3RoLFxuICAgICAgICBvdXQgPSBbXTtcbiAgbGV0IGkgPSAwLFxuICAgICAgY250ID0gMCxcbiAgICAgIHByZXYgPSBbXSxcbiAgICAgIHY7XG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICB2ID0geHZbaV0gKyB1eDtcblxuICAgIGlmIChwcmV2WzBdID09PSB2KSB7XG4gICAgICAvLyBhdmVyYWdlIG91dHB1dCB2YWx1ZXMgdmlhIG9ubGluZSB1cGRhdGVcbiAgICAgIHByZXZbMV0gKz0gKHloYXRbaV0gLSBwcmV2WzFdKSAvICsrY250O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgbmV3IG91dHB1dCBwb2ludFxuICAgICAgY250ID0gMDtcbiAgICAgIHByZXZbMV0gKz0gdXk7XG4gICAgICBwcmV2ID0gW3YsIHloYXRbaV1dO1xuICAgICAgb3V0LnB1c2gocHJldik7XG4gICAgfVxuICB9XG5cbiAgcHJldlsxXSArPSB1eTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gc3ViZGl2aWRlIHVwIHRvIGFjY3VyYWN5IG9mIDAuNSBkZWdyZWVzXG5jb25zdCBNSU5fUkFESUFOUyA9IDAuNSAqIE1hdGguUEkgLyAxODA7IC8vIEFkYXB0aXZlbHkgc2FtcGxlIGFuIGludGVycG9sYXRlZCBmdW5jdGlvbiBvdmVyIGEgZG9tYWluIGV4dGVudFxuXG5mdW5jdGlvbiBzYW1wbGVDdXJ2ZSAoZiwgZXh0ZW50LCBtaW5TdGVwcywgbWF4U3RlcHMpIHtcbiAgbWluU3RlcHMgPSBtaW5TdGVwcyB8fCAyNTtcbiAgbWF4U3RlcHMgPSBNYXRoLm1heChtaW5TdGVwcywgbWF4U3RlcHMgfHwgMjAwKTtcblxuICBjb25zdCBwb2ludCA9IHggPT4gW3gsIGYoeCldLFxuICAgICAgICBtaW5YID0gZXh0ZW50WzBdLFxuICAgICAgICBtYXhYID0gZXh0ZW50WzFdLFxuICAgICAgICBzcGFuID0gbWF4WCAtIG1pblgsXG4gICAgICAgIHN0b3AgPSBzcGFuIC8gbWF4U3RlcHMsXG4gICAgICAgIHByZXYgPSBbcG9pbnQobWluWCldLFxuICAgICAgICBuZXh0ID0gW107XG5cbiAgaWYgKG1pblN0ZXBzID09PSBtYXhTdGVwcykge1xuICAgIC8vIG5vIGFkYXB0YXRpb24sIHNhbXBsZSB1bmlmb3JtIGdyaWQgZGlyZWN0bHkgYW5kIHJldHVyblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWF4U3RlcHM7ICsraSkge1xuICAgICAgcHJldi5wdXNoKHBvaW50KG1pblggKyBpIC8gbWluU3RlcHMgKiBzcGFuKSk7XG4gICAgfVxuXG4gICAgcHJldi5wdXNoKHBvaW50KG1heFgpKTtcbiAgICByZXR1cm4gcHJldjtcbiAgfSBlbHNlIHtcbiAgICAvLyBzYW1wbGUgbWluaW11bSBwb2ludHMgb24gdW5pZm9ybSBncmlkXG4gICAgLy8gdGhlbiBtb3ZlIG9uIHRvIHBlcmZvcm0gYWRhcHRpdmUgcmVmaW5lbWVudFxuICAgIG5leHQucHVzaChwb2ludChtYXhYKSk7XG5cbiAgICBmb3IgKGxldCBpID0gbWluU3RlcHM7IC0taSA+IDA7KSB7XG4gICAgICBuZXh0LnB1c2gocG9pbnQobWluWCArIGkgLyBtaW5TdGVwcyAqIHNwYW4pKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcDAgPSBwcmV2WzBdO1xuICBsZXQgcDEgPSBuZXh0W25leHQubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHN4ID0gMSAvIHNwYW47XG4gIGNvbnN0IHN5ID0gc2NhbGVZKHAwWzFdLCBuZXh0KTtcblxuICB3aGlsZSAocDEpIHtcbiAgICAvLyBtaWRwb2ludCBmb3IgcG90ZW50aWFsIGN1cnZlIHN1YmRpdmlzaW9uXG4gICAgY29uc3QgcG0gPSBwb2ludCgocDBbMF0gKyBwMVswXSkgLyAyKTtcbiAgICBjb25zdCBkeCA9IHBtWzBdIC0gcDBbMF0gPj0gc3RvcDtcblxuICAgIGlmIChkeCAmJiBhbmdsZURlbHRhKHAwLCBwbSwgcDEsIHN4LCBzeSkgPiBNSU5fUkFESUFOUykge1xuICAgICAgLy8gbWF4aW11bSByZXNvbHV0aW9uIGhhcyBub3QgeWV0IGJlZW4gbWV0LCBhbmRcbiAgICAgIC8vIHN1YmRpdmlzaW9uIG1pZHBvaW50IGlzIHN1ZmZpY2llbnRseSBkaWZmZXJlbnQgZnJvbSBlbmRwb2ludFxuICAgICAgLy8gc2F2ZSBzdWJkaXZpc2lvbiwgcHVzaCBtaWRwb2ludCBvbnRvIHRoZSB2aXNpdGF0aW9uIHN0YWNrXG4gICAgICBuZXh0LnB1c2gocG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdWJkaXZpc2lvbiBtaWRwb2ludCBzdWZmaWNpZW50bHkgc2ltaWxhciB0byBlbmRwb2ludFxuICAgICAgLy8gc2tpcCBzdWJkaXZpc2lvbiwgc3RvcmUgZW5kcG9pbnQsIG1vdmUgdG8gbmV4dCBwb2ludCBvbiB0aGUgc3RhY2tcbiAgICAgIHAwID0gcDE7XG4gICAgICBwcmV2LnB1c2gocDEpO1xuICAgICAgbmV4dC5wb3AoKTtcbiAgICB9XG5cbiAgICBwMSA9IG5leHRbbmV4dC5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHJldHVybiBwcmV2O1xufVxuXG5mdW5jdGlvbiBzY2FsZVkoaW5pdCwgcG9pbnRzKSB7XG4gIGxldCB5bWluID0gaW5pdDtcbiAgbGV0IHltYXggPSBpbml0O1xuICBjb25zdCBuID0gcG9pbnRzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IHkgPSBwb2ludHNbaV1bMV07XG4gICAgaWYgKHkgPCB5bWluKSB5bWluID0geTtcbiAgICBpZiAoeSA+IHltYXgpIHltYXggPSB5O1xuICB9XG5cbiAgcmV0dXJuIDEgLyAoeW1heCAtIHltaW4pO1xufVxuXG5mdW5jdGlvbiBhbmdsZURlbHRhKHAsIHEsIHIsIHN4LCBzeSkge1xuICBjb25zdCBhMCA9IE1hdGguYXRhbjIoc3kgKiAoclsxXSAtIHBbMV0pLCBzeCAqIChyWzBdIC0gcFswXSkpLFxuICAgICAgICBhMSA9IE1hdGguYXRhbjIoc3kgKiAocVsxXSAtIHBbMV0pLCBzeCAqIChxWzBdIC0gcFswXSkpO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBhMSk7XG59XG5cbmV4cG9ydCB7IGVzdGltYXRlQmFuZHdpZHRoIGFzIGJhbmR3aWR0aE5SRCwgYmluLCBib290c3RyYXBDSSwgY3VtdWxhdGl2ZUxvZ05vcm1hbCwgY3VtdWxhdGl2ZU5vcm1hbCwgY3VtdWxhdGl2ZVVuaWZvcm0sIGRlbnNpdHlMb2dOb3JtYWwsIGRlbnNpdHlOb3JtYWwsIGRlbnNpdHlVbmlmb3JtLCBkb3RiaW4sIHF1YW50aWxlTG9nTm9ybWFsLCBxdWFudGlsZU5vcm1hbCwgcXVhbnRpbGVVbmlmb3JtLCBxdWFudGlsZXMsIHF1YXJ0aWxlcywgcmFuZG9tLCBpbnRlZ2VyIGFzIHJhbmRvbUludGVnZXIsIGtkZSBhcyByYW5kb21LREUsIGxjZyBhcyByYW5kb21MQ0csIGxvZ25vcm1hbCBhcyByYW5kb21Mb2dOb3JtYWwsIG1peHR1cmUgYXMgcmFuZG9tTWl4dHVyZSwgZ2F1c3NpYW4gYXMgcmFuZG9tTm9ybWFsLCB1bmlmb3JtIGFzIHJhbmRvbVVuaWZvcm0sIGV4cCBhcyByZWdyZXNzaW9uRXhwLCBsaW5lYXIgYXMgcmVncmVzc2lvbkxpbmVhciwgbG9lc3MgYXMgcmVncmVzc2lvbkxvZXNzLCBsb2cgYXMgcmVncmVzc2lvbkxvZywgcG9seSBhcyByZWdyZXNzaW9uUG9seSwgcG93IGFzIHJlZ3Jlc3Npb25Qb3csIHF1YWQgYXMgcmVncmVzc2lvblF1YWQsIHNhbXBsZUN1cnZlLCBzYW1wbGVMb2dOb3JtYWwsIHNhbXBsZU5vcm1hbCwgc2FtcGxlVW5pZm9ybSwgc2V0UmFuZG9tIH07XG4iLCJpbXBvcnQgeyBhcnJheSwgZXJyb3IsIGhhc093blByb3BlcnR5LCBleHRlbmQsIHBlZWssIHRvU2V0LCBjb25zdGFudCwgemVybywgb25lLCBzcGFuIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHRpbWVEYXksIHRpbWVXZWVrLCB1dGNEYXksIHV0Y1dlZWssIHRpbWVZZWFyLCB0aW1lTW9udGgsIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lTWlsbGlzZWNvbmQsIHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNIb3VyLCB1dGNNaW51dGUsIHV0Y1NlY29uZCwgdXRjTWlsbGlzZWNvbmQgfSBmcm9tICdkMy10aW1lJztcbmltcG9ydCB7IGJpc2VjdG9yLCB0aWNrU3RlcCB9IGZyb20gJ2QzLWFycmF5JztcblxuY29uc3QgWUVBUiA9ICd5ZWFyJztcbmNvbnN0IFFVQVJURVIgPSAncXVhcnRlcic7XG5jb25zdCBNT05USCA9ICdtb250aCc7XG5jb25zdCBXRUVLID0gJ3dlZWsnO1xuY29uc3QgREFURSA9ICdkYXRlJztcbmNvbnN0IERBWSA9ICdkYXknO1xuY29uc3QgREFZT0ZZRUFSID0gJ2RheW9meWVhcic7XG5jb25zdCBIT1VSUyA9ICdob3Vycyc7XG5jb25zdCBNSU5VVEVTID0gJ21pbnV0ZXMnO1xuY29uc3QgU0VDT05EUyA9ICdzZWNvbmRzJztcbmNvbnN0IE1JTExJU0VDT05EUyA9ICdtaWxsaXNlY29uZHMnO1xuY29uc3QgVElNRV9VTklUUyA9IFtZRUFSLCBRVUFSVEVSLCBNT05USCwgV0VFSywgREFURSwgREFZLCBEQVlPRllFQVIsIEhPVVJTLCBNSU5VVEVTLCBTRUNPTkRTLCBNSUxMSVNFQ09ORFNdO1xuY29uc3QgVU5JVFMgPSBUSU1FX1VOSVRTLnJlZHVjZSgobywgdSwgaSkgPT4gKG9bdV0gPSAxICsgaSwgbyksIHt9KTtcbmZ1bmN0aW9uIHRpbWVVbml0cyh1bml0cykge1xuICBjb25zdCB1ID0gYXJyYXkodW5pdHMpLnNsaWNlKCksXG4gICAgICAgIG0gPSB7fTsgLy8gY2hlY2sgdmFsaWRpdHlcblxuICBpZiAoIXUubGVuZ3RoKSBlcnJvcignTWlzc2luZyB0aW1lIHVuaXQuJyk7XG4gIHUuZm9yRWFjaCh1bml0ID0+IHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkoVU5JVFMsIHVuaXQpKSB7XG4gICAgICBtW3VuaXRdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoXCJJbnZhbGlkIHRpbWUgdW5pdDogXCIuY29uY2F0KHVuaXQsIFwiLlwiKSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbnVtVHlwZXMgPSAobVtXRUVLXSB8fCBtW0RBWV0gPyAxIDogMCkgKyAobVtRVUFSVEVSXSB8fCBtW01PTlRIXSB8fCBtW0RBVEVdID8gMSA6IDApICsgKG1bREFZT0ZZRUFSXSA/IDEgOiAwKTtcblxuICBpZiAobnVtVHlwZXMgPiAxKSB7XG4gICAgZXJyb3IoXCJJbmNvbXBhdGlibGUgdGltZSB1bml0czogXCIuY29uY2F0KHVuaXRzKSk7XG4gIH0gLy8gZW5zdXJlIHByb3BlciBzb3J0IG9yZGVyXG5cblxuICB1LnNvcnQoKGEsIGIpID0+IFVOSVRTW2FdIC0gVU5JVFNbYl0pO1xuICByZXR1cm4gdTtcbn1cbmNvbnN0IGRlZmF1bHRTcGVjaWZpZXJzID0ge1xuICBbWUVBUl06ICclWSAnLFxuICBbUVVBUlRFUl06ICdRJXEgJyxcbiAgW01PTlRIXTogJyViICcsXG4gIFtEQVRFXTogJyVkICcsXG4gIFtXRUVLXTogJ1clVSAnLFxuICBbREFZXTogJyVhICcsXG4gIFtEQVlPRllFQVJdOiAnJWogJyxcbiAgW0hPVVJTXTogJyVIOjAwJyxcbiAgW01JTlVURVNdOiAnMDA6JU0nLFxuICBbU0VDT05EU106ICc6JVMnLFxuICBbTUlMTElTRUNPTkRTXTogJy4lTCcsXG4gIFtcIlwiLmNvbmNhdChZRUFSLCBcIi1cIikuY29uY2F0KE1PTlRIKV06ICclWS0lbSAnLFxuICBbXCJcIi5jb25jYXQoWUVBUiwgXCItXCIpLmNvbmNhdChNT05USCwgXCItXCIpLmNvbmNhdChEQVRFKV06ICclWS0lbS0lZCAnLFxuICBbXCJcIi5jb25jYXQoSE9VUlMsIFwiLVwiKS5jb25jYXQoTUlOVVRFUyldOiAnJUg6JU0nXG59O1xuZnVuY3Rpb24gdGltZVVuaXRTcGVjaWZpZXIodW5pdHMsIHNwZWNpZmllcnMpIHtcbiAgY29uc3QgcyA9IGV4dGVuZCh7fSwgZGVmYXVsdFNwZWNpZmllcnMsIHNwZWNpZmllcnMpLFxuICAgICAgICB1ID0gdGltZVVuaXRzKHVuaXRzKSxcbiAgICAgICAgbiA9IHUubGVuZ3RoO1xuICBsZXQgZm10ID0gJycsXG4gICAgICBzdGFydCA9IDAsXG4gICAgICBlbmQsXG4gICAgICBrZXk7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgbjspIHtcbiAgICBmb3IgKGVuZCA9IHUubGVuZ3RoOyBlbmQgPiBzdGFydDsgLS1lbmQpIHtcbiAgICAgIGtleSA9IHUuc2xpY2Uoc3RhcnQsIGVuZCkuam9pbignLScpO1xuXG4gICAgICBpZiAoc1trZXldICE9IG51bGwpIHtcbiAgICAgICAgZm10ICs9IHNba2V5XTtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmbXQudHJpbSgpO1xufVxuXG5jb25zdCB0MCA9IG5ldyBEYXRlKCk7XG5cbmZ1bmN0aW9uIGxvY2FsWWVhcih5KSB7XG4gIHQwLnNldEZ1bGxZZWFyKHkpO1xuICB0MC5zZXRNb250aCgwKTtcbiAgdDAuc2V0RGF0ZSgxKTtcbiAgdDAuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiB0MDtcbn1cblxuZnVuY3Rpb24gZGF5b2Z5ZWFyKGQpIHtcbiAgcmV0dXJuIGxvY2FsRGF5T2ZZZWFyKG5ldyBEYXRlKGQpKTtcbn1cbmZ1bmN0aW9uIHdlZWsoZCkge1xuICByZXR1cm4gbG9jYWxXZWVrTnVtKG5ldyBEYXRlKGQpKTtcbn1cbmZ1bmN0aW9uIGxvY2FsRGF5T2ZZZWFyKGQpIHtcbiAgcmV0dXJuIHRpbWVEYXkuY291bnQobG9jYWxZZWFyKGQuZ2V0RnVsbFllYXIoKSkgLSAxLCBkKTtcbn1cbmZ1bmN0aW9uIGxvY2FsV2Vla051bShkKSB7XG4gIHJldHVybiB0aW1lV2Vlay5jb3VudChsb2NhbFllYXIoZC5nZXRGdWxsWWVhcigpKSAtIDEsIGQpO1xufVxuZnVuY3Rpb24gbG9jYWxGaXJzdCh5KSB7XG4gIHJldHVybiBsb2NhbFllYXIoeSkuZ2V0RGF5KCk7XG59XG5mdW5jdGlvbiBsb2NhbERhdGUoeSwgbSwgZCwgSCwgTSwgUywgTCkge1xuICBpZiAoMCA8PSB5ICYmIHkgPCAxMDApIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoLTEsIG0sIGQsIEgsIE0sIFMsIEwpO1xuICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCwgSCwgTSwgUywgTCk7XG59XG5mdW5jdGlvbiB1dGNkYXlvZnllYXIoZCkge1xuICByZXR1cm4gdXRjRGF5T2ZZZWFyKG5ldyBEYXRlKGQpKTtcbn1cbmZ1bmN0aW9uIHV0Y3dlZWsoZCkge1xuICByZXR1cm4gdXRjV2Vla051bShuZXcgRGF0ZShkKSk7XG59XG5mdW5jdGlvbiB1dGNEYXlPZlllYXIoZCkge1xuICBjb25zdCB5ID0gRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKTtcbiAgcmV0dXJuIHV0Y0RheS5jb3VudCh5IC0gMSwgZCk7XG59XG5mdW5jdGlvbiB1dGNXZWVrTnVtKGQpIHtcbiAgY29uc3QgeSA9IERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSk7XG4gIHJldHVybiB1dGNXZWVrLmNvdW50KHkgLSAxLCBkKTtcbn1cbmZ1bmN0aW9uIHV0Y0ZpcnN0KHkpIHtcbiAgdDAuc2V0VGltZShEYXRlLlVUQyh5LCAwLCAxKSk7XG4gIHJldHVybiB0MC5nZXRVVENEYXkoKTtcbn1cbmZ1bmN0aW9uIHV0Y0RhdGUoeSwgbSwgZCwgSCwgTSwgUywgTCkge1xuICBpZiAoMCA8PSB5ICYmIHkgPCAxMDApIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIG0sIGQsIEgsIE0sIFMsIEwpKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeSwgbSwgZCwgSCwgTSwgUywgTCkpO1xufVxuXG5mdW5jdGlvbiBmbG9vcih1bml0cywgc3RlcCwgZ2V0LCBpbnYsIG5ld0RhdGUpIHtcbiAgY29uc3QgcyA9IHN0ZXAgfHwgMSxcbiAgICAgICAgYiA9IHBlZWsodW5pdHMpLFxuICAgICAgICBfID0gKHVuaXQsIHAsIGtleSkgPT4ge1xuICAgIGtleSA9IGtleSB8fCB1bml0O1xuICAgIHJldHVybiBnZXRVbml0KGdldFtrZXldLCBpbnZba2V5XSwgdW5pdCA9PT0gYiAmJiBzLCBwKTtcbiAgfTtcblxuICBjb25zdCB0ID0gbmV3IERhdGUoKSxcbiAgICAgICAgdSA9IHRvU2V0KHVuaXRzKSxcbiAgICAgICAgeSA9IHVbWUVBUl0gPyBfKFlFQVIpIDogY29uc3RhbnQoMjAxMiksXG4gICAgICAgIG0gPSB1W01PTlRIXSA/IF8oTU9OVEgpIDogdVtRVUFSVEVSXSA/IF8oUVVBUlRFUikgOiB6ZXJvLFxuICAgICAgICBkID0gdVtXRUVLXSAmJiB1W0RBWV0gPyBfKERBWSwgMSwgV0VFSyArIERBWSkgOiB1W1dFRUtdID8gXyhXRUVLLCAxKSA6IHVbREFZXSA/IF8oREFZLCAxKSA6IHVbREFURV0gPyBfKERBVEUsIDEpIDogdVtEQVlPRllFQVJdID8gXyhEQVlPRllFQVIsIDEpIDogb25lLFxuICAgICAgICBIID0gdVtIT1VSU10gPyBfKEhPVVJTKSA6IHplcm8sXG4gICAgICAgIE0gPSB1W01JTlVURVNdID8gXyhNSU5VVEVTKSA6IHplcm8sXG4gICAgICAgIFMgPSB1W1NFQ09ORFNdID8gXyhTRUNPTkRTKSA6IHplcm8sXG4gICAgICAgIEwgPSB1W01JTExJU0VDT05EU10gPyBfKE1JTExJU0VDT05EUykgOiB6ZXJvO1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICB0LnNldFRpbWUoK3YpO1xuICAgIGNvbnN0IHllYXIgPSB5KHQpO1xuICAgIHJldHVybiBuZXdEYXRlKHllYXIsIG0odCksIGQodCwgeWVhciksIEgodCksIE0odCksIFModCksIEwodCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRVbml0KGYsIGludiwgc3RlcCwgcGhhc2UpIHtcbiAgY29uc3QgdSA9IHN0ZXAgPD0gMSA/IGYgOiBwaGFzZSA/IChkLCB5KSA9PiBwaGFzZSArIHN0ZXAgKiBNYXRoLmZsb29yKChmKGQsIHkpIC0gcGhhc2UpIC8gc3RlcCkgOiAoZCwgeSkgPT4gc3RlcCAqIE1hdGguZmxvb3IoZihkLCB5KSAvIHN0ZXApO1xuICByZXR1cm4gaW52ID8gKGQsIHkpID0+IGludih1KGQsIHkpLCB5KSA6IHU7XG59IC8vIHJldHVybnMgdGhlIGRheSBvZiB0aGUgeWVhciBiYXNlZCBvbiB3ZWVrIG51bWJlciwgZGF5IG9mIHdlZWssXG4vLyBhbmQgdGhlIGRheSBvZiB0aGUgd2VlayBmb3IgdGhlIGZpcnN0IGRheSBvZiB0aGUgeWVhclxuXG5cbmZ1bmN0aW9uIHdlZWtkYXkod2VlaywgZGF5LCBmaXJzdERheSkge1xuICByZXR1cm4gZGF5ICsgd2VlayAqIDcgLSAoZmlyc3REYXkgKyA2KSAlIDc7XG59IC8vIC0tIExPQ0FMIFRJTUUgLS1cblxuXG5jb25zdCBsb2NhbEdldCA9IHtcbiAgW1lFQVJdOiBkID0+IGQuZ2V0RnVsbFllYXIoKSxcbiAgW1FVQVJURVJdOiBkID0+IE1hdGguZmxvb3IoZC5nZXRNb250aCgpIC8gMyksXG4gIFtNT05USF06IGQgPT4gZC5nZXRNb250aCgpLFxuICBbREFURV06IGQgPT4gZC5nZXREYXRlKCksXG4gIFtIT1VSU106IGQgPT4gZC5nZXRIb3VycygpLFxuICBbTUlOVVRFU106IGQgPT4gZC5nZXRNaW51dGVzKCksXG4gIFtTRUNPTkRTXTogZCA9PiBkLmdldFNlY29uZHMoKSxcbiAgW01JTExJU0VDT05EU106IGQgPT4gZC5nZXRNaWxsaXNlY29uZHMoKSxcbiAgW0RBWU9GWUVBUl06IGQgPT4gbG9jYWxEYXlPZlllYXIoZCksXG4gIFtXRUVLXTogZCA9PiBsb2NhbFdlZWtOdW0oZCksXG4gIFtXRUVLICsgREFZXTogKGQsIHkpID0+IHdlZWtkYXkobG9jYWxXZWVrTnVtKGQpLCBkLmdldERheSgpLCBsb2NhbEZpcnN0KHkpKSxcbiAgW0RBWV06IChkLCB5KSA9PiB3ZWVrZGF5KDEsIGQuZ2V0RGF5KCksIGxvY2FsRmlyc3QoeSkpXG59O1xuY29uc3QgbG9jYWxJbnYgPSB7XG4gIFtRVUFSVEVSXTogcSA9PiAzICogcSxcbiAgW1dFRUtdOiAodywgeSkgPT4gd2Vla2RheSh3LCAwLCBsb2NhbEZpcnN0KHkpKVxufTtcbmZ1bmN0aW9uIHRpbWVGbG9vcih1bml0cywgc3RlcCkge1xuICByZXR1cm4gZmxvb3IodW5pdHMsIHN0ZXAgfHwgMSwgbG9jYWxHZXQsIGxvY2FsSW52LCBsb2NhbERhdGUpO1xufSAvLyAtLSBVVEMgVElNRSAtLVxuXG5jb25zdCB1dGNHZXQgPSB7XG4gIFtZRUFSXTogZCA9PiBkLmdldFVUQ0Z1bGxZZWFyKCksXG4gIFtRVUFSVEVSXTogZCA9PiBNYXRoLmZsb29yKGQuZ2V0VVRDTW9udGgoKSAvIDMpLFxuICBbTU9OVEhdOiBkID0+IGQuZ2V0VVRDTW9udGgoKSxcbiAgW0RBVEVdOiBkID0+IGQuZ2V0VVRDRGF0ZSgpLFxuICBbSE9VUlNdOiBkID0+IGQuZ2V0VVRDSG91cnMoKSxcbiAgW01JTlVURVNdOiBkID0+IGQuZ2V0VVRDTWludXRlcygpLFxuICBbU0VDT05EU106IGQgPT4gZC5nZXRVVENTZWNvbmRzKCksXG4gIFtNSUxMSVNFQ09ORFNdOiBkID0+IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gIFtEQVlPRllFQVJdOiBkID0+IHV0Y0RheU9mWWVhcihkKSxcbiAgW1dFRUtdOiBkID0+IHV0Y1dlZWtOdW0oZCksXG4gIFtEQVldOiAoZCwgeSkgPT4gd2Vla2RheSgxLCBkLmdldFVUQ0RheSgpLCB1dGNGaXJzdCh5KSksXG4gIFtXRUVLICsgREFZXTogKGQsIHkpID0+IHdlZWtkYXkodXRjV2Vla051bShkKSwgZC5nZXRVVENEYXkoKSwgdXRjRmlyc3QoeSkpXG59O1xuY29uc3QgdXRjSW52ID0ge1xuICBbUVVBUlRFUl06IHEgPT4gMyAqIHEsXG4gIFtXRUVLXTogKHcsIHkpID0+IHdlZWtkYXkodywgMCwgdXRjRmlyc3QoeSkpXG59O1xuZnVuY3Rpb24gdXRjRmxvb3IodW5pdHMsIHN0ZXApIHtcbiAgcmV0dXJuIGZsb29yKHVuaXRzLCBzdGVwIHx8IDEsIHV0Y0dldCwgdXRjSW52LCB1dGNEYXRlKTtcbn1cblxuY29uc3QgdGltZUludGVydmFscyA9IHtcbiAgW1lFQVJdOiB0aW1lWWVhcixcbiAgW1FVQVJURVJdOiB0aW1lTW9udGguZXZlcnkoMyksXG4gIFtNT05USF06IHRpbWVNb250aCxcbiAgW1dFRUtdOiB0aW1lV2VlayxcbiAgW0RBVEVdOiB0aW1lRGF5LFxuICBbREFZXTogdGltZURheSxcbiAgW0RBWU9GWUVBUl06IHRpbWVEYXksXG4gIFtIT1VSU106IHRpbWVIb3VyLFxuICBbTUlOVVRFU106IHRpbWVNaW51dGUsXG4gIFtTRUNPTkRTXTogdGltZVNlY29uZCxcbiAgW01JTExJU0VDT05EU106IHRpbWVNaWxsaXNlY29uZFxufTtcbmNvbnN0IHV0Y0ludGVydmFscyA9IHtcbiAgW1lFQVJdOiB1dGNZZWFyLFxuICBbUVVBUlRFUl06IHV0Y01vbnRoLmV2ZXJ5KDMpLFxuICBbTU9OVEhdOiB1dGNNb250aCxcbiAgW1dFRUtdOiB1dGNXZWVrLFxuICBbREFURV06IHV0Y0RheSxcbiAgW0RBWV06IHV0Y0RheSxcbiAgW0RBWU9GWUVBUl06IHV0Y0RheSxcbiAgW0hPVVJTXTogdXRjSG91cixcbiAgW01JTlVURVNdOiB1dGNNaW51dGUsXG4gIFtTRUNPTkRTXTogdXRjU2Vjb25kLFxuICBbTUlMTElTRUNPTkRTXTogdXRjTWlsbGlzZWNvbmRcbn07XG5mdW5jdGlvbiB0aW1lSW50ZXJ2YWwodW5pdCkge1xuICByZXR1cm4gdGltZUludGVydmFsc1t1bml0XTtcbn1cbmZ1bmN0aW9uIHV0Y0ludGVydmFsKHVuaXQpIHtcbiAgcmV0dXJuIHV0Y0ludGVydmFsc1t1bml0XTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KGl2YWwsIGRhdGUsIHN0ZXApIHtcbiAgcmV0dXJuIGl2YWwgPyBpdmFsLm9mZnNldChkYXRlLCBzdGVwKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gdGltZU9mZnNldCh1bml0LCBkYXRlLCBzdGVwKSB7XG4gIHJldHVybiBvZmZzZXQodGltZUludGVydmFsKHVuaXQpLCBkYXRlLCBzdGVwKTtcbn1cbmZ1bmN0aW9uIHV0Y09mZnNldCh1bml0LCBkYXRlLCBzdGVwKSB7XG4gIHJldHVybiBvZmZzZXQodXRjSW50ZXJ2YWwodW5pdCksIGRhdGUsIHN0ZXApO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW5jZShpdmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICByZXR1cm4gaXZhbCA/IGl2YWwucmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB0aW1lU2VxdWVuY2UodW5pdCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgcmV0dXJuIHNlcXVlbmNlKHRpbWVJbnRlcnZhbCh1bml0KSwgc3RhcnQsIHN0b3AsIHN0ZXApO1xufVxuZnVuY3Rpb24gdXRjU2VxdWVuY2UodW5pdCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgcmV0dXJuIHNlcXVlbmNlKHV0Y0ludGVydmFsKHVuaXQpLCBzdGFydCwgc3RvcCwgc3RlcCk7XG59XG5cbmNvbnN0IGR1cmF0aW9uU2Vjb25kID0gMTAwMCxcbiAgICAgIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MCxcbiAgICAgIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjAsXG4gICAgICBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0LFxuICAgICAgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3LFxuICAgICAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzAsXG4gICAgICBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcbmNvbnN0IE1pbGxpID0gW1lFQVIsIE1PTlRILCBEQVRFLCBIT1VSUywgTUlOVVRFUywgU0VDT05EUywgTUlMTElTRUNPTkRTXSxcbiAgICAgIFNlY29uZHMgPSBNaWxsaS5zbGljZSgwLCAtMSksXG4gICAgICBNaW51dGVzID0gU2Vjb25kcy5zbGljZSgwLCAtMSksXG4gICAgICBIb3VycyA9IE1pbnV0ZXMuc2xpY2UoMCwgLTEpLFxuICAgICAgRGF5ID0gSG91cnMuc2xpY2UoMCwgLTEpLFxuICAgICAgV2VlayA9IFtZRUFSLCBXRUVLXSxcbiAgICAgIE1vbnRoID0gW1lFQVIsIE1PTlRIXSxcbiAgICAgIFllYXIgPSBbWUVBUl07XG5jb25zdCBpbnRlcnZhbHMgPSBbW1NlY29uZHMsIDEsIGR1cmF0aW9uU2Vjb25kXSwgW1NlY29uZHMsIDUsIDUgKiBkdXJhdGlvblNlY29uZF0sIFtTZWNvbmRzLCAxNSwgMTUgKiBkdXJhdGlvblNlY29uZF0sIFtTZWNvbmRzLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sIFtNaW51dGVzLCAxLCBkdXJhdGlvbk1pbnV0ZV0sIFtNaW51dGVzLCA1LCA1ICogZHVyYXRpb25NaW51dGVdLCBbTWludXRlcywgMTUsIDE1ICogZHVyYXRpb25NaW51dGVdLCBbTWludXRlcywgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLCBbSG91cnMsIDEsIGR1cmF0aW9uSG91cl0sIFtIb3VycywgMywgMyAqIGR1cmF0aW9uSG91cl0sIFtIb3VycywgNiwgNiAqIGR1cmF0aW9uSG91cl0sIFtIb3VycywgMTIsIDEyICogZHVyYXRpb25Ib3VyXSwgW0RheSwgMSwgZHVyYXRpb25EYXldLCBbV2VlaywgMSwgZHVyYXRpb25XZWVrXSwgW01vbnRoLCAxLCBkdXJhdGlvbk1vbnRoXSwgW01vbnRoLCAzLCAzICogZHVyYXRpb25Nb250aF0sIFtZZWFyLCAxLCBkdXJhdGlvblllYXJdXTtcbmZ1bmN0aW9uIGJpbiAob3B0KSB7XG4gIGNvbnN0IGV4dCA9IG9wdC5leHRlbnQsXG4gICAgICAgIG1heCA9IG9wdC5tYXhiaW5zIHx8IDQwLFxuICAgICAgICB0YXJnZXQgPSBNYXRoLmFicyhzcGFuKGV4dCkpIC8gbWF4O1xuICBsZXQgaSA9IGJpc2VjdG9yKGkgPT4gaVsyXSkucmlnaHQoaW50ZXJ2YWxzLCB0YXJnZXQpLFxuICAgICAgdW5pdHMsXG4gICAgICBzdGVwO1xuXG4gIGlmIChpID09PSBpbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgdW5pdHMgPSBZZWFyLCBzdGVwID0gdGlja1N0ZXAoZXh0WzBdIC8gZHVyYXRpb25ZZWFyLCBleHRbMV0gLyBkdXJhdGlvblllYXIsIG1heCk7XG4gIH0gZWxzZSBpZiAoaSkge1xuICAgIGkgPSBpbnRlcnZhbHNbdGFyZ2V0IC8gaW50ZXJ2YWxzW2kgLSAxXVsyXSA8IGludGVydmFsc1tpXVsyXSAvIHRhcmdldCA/IGkgLSAxIDogaV07XG4gICAgdW5pdHMgPSBpWzBdO1xuICAgIHN0ZXAgPSBpWzFdO1xuICB9IGVsc2Uge1xuICAgIHVuaXRzID0gTWlsbGk7XG4gICAgc3RlcCA9IE1hdGgubWF4KHRpY2tTdGVwKGV4dFswXSwgZXh0WzFdLCBtYXgpLCAxKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdW5pdHMsXG4gICAgc3RlcFxuICB9O1xufVxuXG5leHBvcnQgeyBEQVRFLCBEQVksIERBWU9GWUVBUiwgSE9VUlMsIE1JTExJU0VDT05EUywgTUlOVVRFUywgTU9OVEgsIFFVQVJURVIsIFNFQ09ORFMsIFRJTUVfVU5JVFMsIFdFRUssIFlFQVIsIGRheW9meWVhciwgYmluIGFzIHRpbWVCaW4sIHRpbWVGbG9vciwgdGltZUludGVydmFsLCB0aW1lT2Zmc2V0LCB0aW1lU2VxdWVuY2UsIHRpbWVVbml0U3BlY2lmaWVyLCB0aW1lVW5pdHMsIHV0Y0Zsb29yLCB1dGNJbnRlcnZhbCwgdXRjT2Zmc2V0LCB1dGNTZXF1ZW5jZSwgdXRjZGF5b2Z5ZWFyLCB1dGN3ZWVrLCB3ZWVrIH07XG4iLCJpbXBvcnQgeyBleHRlbmQsIGlkZW50aXR5LCBmaWVsZCwgaGFzT3duUHJvcGVydHksIGV4dGVudEluZGV4LCBpbmhlcml0cywgYXJyYXksIGFjY2Vzc29yTmFtZSwgZXJyb3IsIGFjY2Vzc29yRmllbGRzLCBhY2Nlc3NvciwgdG9OdW1iZXIsIG1lcmdlLCBjb21wYXJlLCB0cnV0aHksIGV4dGVudCwgc3BhbiwgZmFzdG1hcCwgaXNBcnJheSwga2V5LCBhc2NlbmRpbmcsIHBlZWssIHplcm8sIGNvbnN0YW50IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHR1cGxlaWQsIFRyYW5zZm9ybSwgcmVwbGFjZSwgaW5nZXN0LCBzdGFibGVDb21wYXJlLCBPcGVyYXRvciwgZGVyaXZlLCByZWRlcml2ZSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgcXVhcnRpbGVzLCBib290c3RyYXBDSSwgYmluLCByYW5kb21LREUsIHJhbmRvbU1peHR1cmUsIHJhbmRvbU5vcm1hbCwgcmFuZG9tTG9nTm9ybWFsLCByYW5kb21Vbmlmb3JtLCBzYW1wbGVDdXJ2ZSwgZG90YmluLCBxdWFudGlsZXMsIHJhbmRvbSB9IGZyb20gJ3ZlZ2Etc3RhdGlzdGljcyc7XG5pbXBvcnQgeyBtZWRpYW4sIG1lYW4sIG1pbiwgbWF4LCByYW5nZSwgYmlzZWN0b3IgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBUSU1FX1VOSVRTLCB1dGNJbnRlcnZhbCwgdGltZUludGVydmFsLCB0aW1lQmluLCB0aW1lVW5pdHMsIHV0Y0Zsb29yLCB0aW1lRmxvb3IgfSBmcm9tICd2ZWdhLXRpbWUnO1xuXG5mdW5jdGlvbiBtdWx0aWtleShmKSB7XG4gIHJldHVybiB4ID0+IHtcbiAgICBjb25zdCBuID0gZi5sZW5ndGg7XG4gICAgbGV0IGkgPSAxLFxuICAgICAgICBrID0gU3RyaW5nKGZbMF0oeCkpO1xuXG4gICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGsgKz0gJ3wnICsgZltpXSh4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaztcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyb3Vwa2V5KGZpZWxkcykge1xuICByZXR1cm4gIWZpZWxkcyB8fCAhZmllbGRzLmxlbmd0aCA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gOiBmaWVsZHMubGVuZ3RoID09PSAxID8gZmllbGRzWzBdIDogbXVsdGlrZXkoZmllbGRzKTtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZU5hbWUob3AsIGZpZWxkLCBhcykge1xuICByZXR1cm4gYXMgfHwgb3AgKyAoIWZpZWxkID8gJycgOiAnXycgKyBmaWVsZCk7XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuY29uc3QgYmFzZV9vcCA9IHtcbiAgaW5pdDogbm9vcCxcbiAgYWRkOiBub29wLFxuICByZW06IG5vb3AsXG4gIGlkeDogMFxufTtcbmNvbnN0IEFnZ3JlZ2F0ZU9wcyA9IHtcbiAgdmFsdWVzOiB7XG4gICAgaW5pdDogbSA9PiBtLmNlbGwuc3RvcmUgPSB0cnVlLFxuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLnZhbHVlcygpLFxuICAgIGlkeDogLTFcbiAgfSxcbiAgY291bnQ6IHtcbiAgICB2YWx1ZTogbSA9PiBtLmNlbGwubnVtXG4gIH0sXG4gIF9fY291bnRfXzoge1xuICAgIHZhbHVlOiBtID0+IG0ubWlzc2luZyArIG0udmFsaWRcbiAgfSxcbiAgbWlzc2luZzoge1xuICAgIHZhbHVlOiBtID0+IG0ubWlzc2luZ1xuICB9LFxuICB2YWxpZDoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWRcbiAgfSxcbiAgc3VtOiB7XG4gICAgaW5pdDogbSA9PiBtLnN1bSA9IDAsXG4gICAgdmFsdWU6IG0gPT4gbS5zdW0sXG4gICAgYWRkOiAobSwgdikgPT4gbS5zdW0gKz0gK3YsXG4gICAgcmVtOiAobSwgdikgPT4gbS5zdW0gLT0gdlxuICB9LFxuICBwcm9kdWN0OiB7XG4gICAgaW5pdDogbSA9PiBtLnByb2R1Y3QgPSAxLFxuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPyBtLnByb2R1Y3QgOiB1bmRlZmluZWQsXG4gICAgYWRkOiAobSwgdikgPT4gbS5wcm9kdWN0ICo9IHYsXG4gICAgcmVtOiAobSwgdikgPT4gbS5wcm9kdWN0IC89IHZcbiAgfSxcbiAgbWVhbjoge1xuICAgIGluaXQ6IG0gPT4gbS5tZWFuID0gMCxcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID8gbS5tZWFuIDogdW5kZWZpbmVkLFxuICAgIGFkZDogKG0sIHYpID0+IChtLm1lYW5fZCA9IHYgLSBtLm1lYW4sIG0ubWVhbiArPSBtLm1lYW5fZCAvIG0udmFsaWQpLFxuICAgIHJlbTogKG0sIHYpID0+IChtLm1lYW5fZCA9IHYgLSBtLm1lYW4sIG0ubWVhbiAtPSBtLnZhbGlkID8gbS5tZWFuX2QgLyBtLnZhbGlkIDogbS5tZWFuKVxuICB9LFxuICBhdmVyYWdlOiB7XG4gICAgdmFsdWU6IG0gPT4gbS52YWxpZCA/IG0ubWVhbiA6IHVuZGVmaW5lZCxcbiAgICByZXE6IFsnbWVhbiddLFxuICAgIGlkeDogMVxuICB9LFxuICB2YXJpYW5jZToge1xuICAgIGluaXQ6IG0gPT4gbS5kZXYgPSAwLFxuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gbS5kZXYgLyAobS52YWxpZCAtIDEpIDogdW5kZWZpbmVkLFxuICAgIGFkZDogKG0sIHYpID0+IG0uZGV2ICs9IG0ubWVhbl9kICogKHYgLSBtLm1lYW4pLFxuICAgIHJlbTogKG0sIHYpID0+IG0uZGV2IC09IG0ubWVhbl9kICogKHYgLSBtLm1lYW4pLFxuICAgIHJlcTogWydtZWFuJ10sXG4gICAgaWR4OiAxXG4gIH0sXG4gIHZhcmlhbmNlcDoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gbS5kZXYgLyBtLnZhbGlkIDogdW5kZWZpbmVkLFxuICAgIHJlcTogWyd2YXJpYW5jZSddLFxuICAgIGlkeDogMlxuICB9LFxuICBzdGRldjoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gTWF0aC5zcXJ0KG0uZGV2IC8gKG0udmFsaWQgLSAxKSkgOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ3ZhcmlhbmNlJ10sXG4gICAgaWR4OiAyXG4gIH0sXG4gIHN0ZGV2cDoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gTWF0aC5zcXJ0KG0uZGV2IC8gbS52YWxpZCkgOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ3ZhcmlhbmNlJ10sXG4gICAgaWR4OiAyXG4gIH0sXG4gIHN0ZGVycjoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gTWF0aC5zcXJ0KG0uZGV2IC8gKG0udmFsaWQgKiAobS52YWxpZCAtIDEpKSkgOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ3ZhcmlhbmNlJ10sXG4gICAgaWR4OiAyXG4gIH0sXG4gIGRpc3RpbmN0OiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEuZGlzdGluY3QobS5nZXQpLFxuICAgIHJlcTogWyd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgY2kwOiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEuY2kwKG0uZ2V0KSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIGNpMToge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLmNpMShtLmdldCksXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogM1xuICB9LFxuICBtZWRpYW46IHtcbiAgICB2YWx1ZTogbSA9PiBtLmNlbGwuZGF0YS5xMihtLmdldCksXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogM1xuICB9LFxuICBxMToge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLnExKG0uZ2V0KSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIHEzOiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEucTMobS5nZXQpLFxuICAgIHJlcTogWyd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgbWluOiB7XG4gICAgaW5pdDogbSA9PiBtLm1pbiA9IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbSA9PiBtLm1pbiA9IE51bWJlci5pc05hTihtLm1pbikgPyBtLmNlbGwuZGF0YS5taW4obS5nZXQpIDogbS5taW4sXG4gICAgYWRkOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPCBtLm1pbiB8fCBtLm1pbiA9PT0gdW5kZWZpbmVkKSBtLm1pbiA9IHY7XG4gICAgfSxcbiAgICByZW06IChtLCB2KSA9PiB7XG4gICAgICBpZiAodiA8PSBtLm1pbikgbS5taW4gPSBOYU47XG4gICAgfSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiA0XG4gIH0sXG4gIG1heDoge1xuICAgIGluaXQ6IG0gPT4gbS5tYXggPSB1bmRlZmluZWQsXG4gICAgdmFsdWU6IG0gPT4gbS5tYXggPSBOdW1iZXIuaXNOYU4obS5tYXgpID8gbS5jZWxsLmRhdGEubWF4KG0uZ2V0KSA6IG0ubWF4LFxuICAgIGFkZDogKG0sIHYpID0+IHtcbiAgICAgIGlmICh2ID4gbS5tYXggfHwgbS5tYXggPT09IHVuZGVmaW5lZCkgbS5tYXggPSB2O1xuICAgIH0sXG4gICAgcmVtOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPj0gbS5tYXgpIG0ubWF4ID0gTmFOO1xuICAgIH0sXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogNFxuICB9LFxuICBhcmdtaW46IHtcbiAgICBpbml0OiBtID0+IG0uYXJnbWluID0gdW5kZWZpbmVkLFxuICAgIHZhbHVlOiBtID0+IG0uYXJnbWluIHx8IG0uY2VsbC5kYXRhLmFyZ21pbihtLmdldCksXG4gICAgYWRkOiAobSwgdiwgdCkgPT4ge1xuICAgICAgaWYgKHYgPCBtLm1pbikgbS5hcmdtaW4gPSB0O1xuICAgIH0sXG4gICAgcmVtOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPD0gbS5taW4pIG0uYXJnbWluID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgcmVxOiBbJ21pbicsICd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgYXJnbWF4OiB7XG4gICAgaW5pdDogbSA9PiBtLmFyZ21heCA9IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbSA9PiBtLmFyZ21heCB8fCBtLmNlbGwuZGF0YS5hcmdtYXgobS5nZXQpLFxuICAgIGFkZDogKG0sIHYsIHQpID0+IHtcbiAgICAgIGlmICh2ID4gbS5tYXgpIG0uYXJnbWF4ID0gdDtcbiAgICB9LFxuICAgIHJlbTogKG0sIHYpID0+IHtcbiAgICAgIGlmICh2ID49IG0ubWF4KSBtLmFyZ21heCA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHJlcTogWydtYXgnLCAndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH1cbn07XG5jb25zdCBWYWxpZEFnZ3JlZ2F0ZU9wcyA9IE9iamVjdC5rZXlzKEFnZ3JlZ2F0ZU9wcyk7XG5cbmZ1bmN0aW9uIG1lYXN1cmUoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gb3V0ID0+IGV4dGVuZCh7XG4gICAgbmFtZToga2V5LFxuICAgIG91dDogb3V0IHx8IGtleVxuICB9LCBiYXNlX29wLCB2YWx1ZSk7XG59XG5cblZhbGlkQWdncmVnYXRlT3BzLmZvckVhY2goa2V5ID0+IHtcbiAgQWdncmVnYXRlT3BzW2tleV0gPSBtZWFzdXJlKGtleSwgQWdncmVnYXRlT3BzW2tleV0pO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVNZWFzdXJlKG9wLCBuYW1lKSB7XG4gIHJldHVybiBBZ2dyZWdhdGVPcHNbb3BdKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW5kZXgoYSwgYikge1xuICByZXR1cm4gYS5pZHggLSBiLmlkeDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShhZ2cpIHtcbiAgY29uc3QgbWFwID0ge307XG4gIGFnZy5mb3JFYWNoKGEgPT4gbWFwW2EubmFtZV0gPSBhKTtcblxuICBjb25zdCBnZXRyZXFzID0gYSA9PiB7XG4gICAgaWYgKCFhLnJlcSkgcmV0dXJuO1xuICAgIGEucmVxLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghbWFwW2tleV0pIGdldHJlcXMobWFwW2tleV0gPSBBZ2dyZWdhdGVPcHNba2V5XSgpKTtcbiAgICB9KTtcbiAgfTtcblxuICBhZ2cuZm9yRWFjaChnZXRyZXFzKTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWFwKS5zb3J0KGNvbXBhcmVJbmRleCk7XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIHRoaXMudmFsaWQgPSAwO1xuICB0aGlzLm1pc3NpbmcgPSAwO1xuXG4gIHRoaXMuX29wcy5mb3JFYWNoKG9wID0+IG9wLmluaXQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBhZGQodiwgdCkge1xuICBpZiAodiA9PSBudWxsIHx8IHYgPT09ICcnKSB7XG4gICAgKyt0aGlzLm1pc3Npbmc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHYgIT09IHYpIHJldHVybjtcbiAgKyt0aGlzLnZhbGlkO1xuXG4gIHRoaXMuX29wcy5mb3JFYWNoKG9wID0+IG9wLmFkZCh0aGlzLCB2LCB0KSk7XG59XG5cbmZ1bmN0aW9uIHJlbSh2LCB0KSB7XG4gIGlmICh2ID09IG51bGwgfHwgdiA9PT0gJycpIHtcbiAgICAtLXRoaXMubWlzc2luZztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodiAhPT0gdikgcmV0dXJuO1xuICAtLXRoaXMudmFsaWQ7XG5cbiAgdGhpcy5fb3BzLmZvckVhY2gob3AgPT4gb3AucmVtKHRoaXMsIHYsIHQpKTtcbn1cblxuZnVuY3Rpb24gc2V0KHQpIHtcbiAgdGhpcy5fb3V0LmZvckVhY2gob3AgPT4gdFtvcC5vdXRdID0gb3AudmFsdWUodGhpcykpO1xuXG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBjb21waWxlTWVhc3VyZXMoYWdnLCBmaWVsZCkge1xuICBjb25zdCBnZXQgPSBmaWVsZCB8fCBpZGVudGl0eSxcbiAgICAgICAgb3BzID0gcmVzb2x2ZShhZ2cpLFxuICAgICAgICBvdXQgPSBhZ2cuc2xpY2UoKS5zb3J0KGNvbXBhcmVJbmRleCk7XG5cbiAgZnVuY3Rpb24gY3RyKGNlbGwpIHtcbiAgICB0aGlzLl9vcHMgPSBvcHM7XG4gICAgdGhpcy5fb3V0ID0gb3V0O1xuICAgIHRoaXMuY2VsbCA9IGNlbGw7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBjdHIucHJvdG90eXBlLmluaXQgPSBpbml0O1xuICBjdHIucHJvdG90eXBlLmFkZCA9IGFkZDtcbiAgY3RyLnByb3RvdHlwZS5yZW0gPSByZW07XG4gIGN0ci5wcm90b3R5cGUuc2V0ID0gc2V0O1xuICBjdHIucHJvdG90eXBlLmdldCA9IGdldDtcbiAgY3RyLmZpZWxkcyA9IGFnZy5tYXAob3AgPT4gb3Aub3V0KTtcbiAgcmV0dXJuIGN0cjtcbn1cblxuZnVuY3Rpb24gVHVwbGVTdG9yZShrZXkpIHtcbiAgdGhpcy5fa2V5ID0ga2V5ID8gZmllbGQoa2V5KSA6IHR1cGxlaWQ7XG4gIHRoaXMucmVzZXQoKTtcbn1cbmNvbnN0IHByb3RvdHlwZSQxID0gVHVwbGVTdG9yZS5wcm90b3R5cGU7XG5cbnByb3RvdHlwZSQxLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hZGQgPSBbXTtcbiAgdGhpcy5fcmVtID0gW107XG4gIHRoaXMuX2V4dCA9IG51bGw7XG4gIHRoaXMuX2dldCA9IG51bGw7XG4gIHRoaXMuX3EgPSBudWxsO1xufTtcblxucHJvdG90eXBlJDEuYWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5fYWRkLnB1c2godik7XG59O1xuXG5wcm90b3R5cGUkMS5yZW0gPSBmdW5jdGlvbiAodikge1xuICB0aGlzLl9yZW0ucHVzaCh2KTtcbn07XG5cbnByb3RvdHlwZSQxLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZ2V0ID0gbnVsbDtcbiAgaWYgKHRoaXMuX3JlbS5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9hZGQ7XG4gIGNvbnN0IGEgPSB0aGlzLl9hZGQsXG4gICAgICAgIHIgPSB0aGlzLl9yZW0sXG4gICAgICAgIGsgPSB0aGlzLl9rZXksXG4gICAgICAgIG4gPSBhLmxlbmd0aCxcbiAgICAgICAgbSA9IHIubGVuZ3RoLFxuICAgICAgICB4ID0gQXJyYXkobiAtIG0pLFxuICAgICAgICBtYXAgPSB7fTtcbiAgbGV0IGksIGosIHY7IC8vIHVzZSB1bmlxdWUga2V5IGZpZWxkIHRvIGNsZWFyIHJlbW92ZWQgdmFsdWVzXG5cbiAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgIG1hcFtrKHJbaV0pXSA9IDE7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChtYXBbayh2ID0gYVtpXSldKSB7XG4gICAgICBtYXBbayh2KV0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB4W2orK10gPSB2O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3JlbSA9IFtdO1xuICByZXR1cm4gdGhpcy5fYWRkID0geDtcbn07IC8vIG1lbW9pemluZyBzdGF0aXN0aWNzIG1ldGhvZHNcblxuXG5wcm90b3R5cGUkMS5kaXN0aW5jdCA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgY29uc3QgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICAgIG1hcCA9IHt9O1xuICBsZXQgbiA9IHYubGVuZ3RoLFxuICAgICAgY291bnQgPSAwLFxuICAgICAgcztcblxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICBzID0gZ2V0KHZbbl0pICsgJyc7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG1hcCwgcykpIHtcbiAgICAgIG1hcFtzXSA9IDE7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn07XG5cbnByb3RvdHlwZSQxLmV4dGVudCA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9leHQpIHtcbiAgICBjb25zdCB2ID0gdGhpcy52YWx1ZXMoKSxcbiAgICAgICAgICBpID0gZXh0ZW50SW5kZXgodiwgZ2V0KTtcbiAgICB0aGlzLl9leHQgPSBbdltpWzBdXSwgdltpWzFdXV07XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2V4dDtcbn07XG5cbnByb3RvdHlwZSQxLmFyZ21pbiA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW50KGdldClbMF0gfHwge307XG59O1xuXG5wcm90b3R5cGUkMS5hcmdtYXggPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzFdIHx8IHt9O1xufTtcblxucHJvdG90eXBlJDEubWluID0gZnVuY3Rpb24gKGdldCkge1xuICBjb25zdCBtID0gdGhpcy5leHRlbnQoZ2V0KVswXTtcbiAgcmV0dXJuIG0gIT0gbnVsbCA/IGdldChtKSA6IHVuZGVmaW5lZDtcbn07XG5cbnByb3RvdHlwZSQxLm1heCA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgY29uc3QgbSA9IHRoaXMuZXh0ZW50KGdldClbMV07XG4gIHJldHVybiBtICE9IG51bGwgPyBnZXQobSkgOiB1bmRlZmluZWQ7XG59O1xuXG5wcm90b3R5cGUkMS5xdWFydGlsZSA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9xKSB7XG4gICAgdGhpcy5fcSA9IHF1YXJ0aWxlcyh0aGlzLnZhbHVlcygpLCBnZXQpO1xuICAgIHRoaXMuX2dldCA9IGdldDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9xO1xufTtcblxucHJvdG90eXBlJDEucTEgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiB0aGlzLnF1YXJ0aWxlKGdldClbMF07XG59O1xuXG5wcm90b3R5cGUkMS5xMiA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVsxXTtcbn07XG5cbnByb3RvdHlwZSQxLnEzID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShnZXQpWzJdO1xufTtcblxucHJvdG90eXBlJDEuY2kgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIGlmICh0aGlzLl9nZXQgIT09IGdldCB8fCAhdGhpcy5fY2kpIHtcbiAgICB0aGlzLl9jaSA9IGJvb3RzdHJhcENJKHRoaXMudmFsdWVzKCksIDEwMDAsIDAuMDUsIGdldCk7XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NpO1xufTtcblxucHJvdG90eXBlJDEuY2kwID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gdGhpcy5jaShnZXQpWzBdO1xufTtcblxucHJvdG90eXBlJDEuY2kxID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gdGhpcy5jaShnZXQpWzFdO1xufTtcblxuLyoqXG4gKiBHcm91cC1ieSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29ycyB0byBncm91cGJ5LlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5maWVsZHNdIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIHRvIGFnZ3JlZ2F0ZS5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5vcHNdIC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyBpbmRpY2F0aW5nIGFnZ3JlZ2F0aW9uIG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gQW4gYXJyYXkgb2Ygb3V0cHV0IGZpZWxkIG5hbWVzIGZvciBhZ2dyZWdhdGVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5jcm9zcz1mYWxzZV0gLSBBIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZSBmdWxsXG4gKiAgIGNyb3NzLXByb2R1Y3Qgb2YgZ3JvdXBieSB2YWx1ZXMgc2hvdWxkIGJlIGdlbmVyYXRlZCwgaW5jbHVkaW5nIGVtcHR5IGNlbGxzLlxuICogICBJZiB0cnVlLCB0aGUgZHJvcCBwYXJhbWV0ZXIgaXMgaWdub3JlZCBhbmQgZW1wdHkgY2VsbHMgYXJlIHJldGFpbmVkLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmRyb3A9dHJ1ZV0gLSBBIGZsYWcgaW5kaWNhdGluZyBpZiBlbXB0eSBjZWxscyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAqL1xuXG5mdW5jdGlvbiBBZ2dyZWdhdGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG4gIHRoaXMuX2FkZHMgPSBbXTsgLy8gYXJyYXkgb2YgYWRkZWQgb3V0cHV0IHR1cGxlc1xuXG4gIHRoaXMuX21vZHMgPSBbXTsgLy8gYXJyYXkgb2YgbW9kaWZpZWQgb3V0cHV0IHR1cGxlc1xuXG4gIHRoaXMuX2FsZW4gPSAwOyAvLyBudW1iZXIgb2YgYWN0aXZlIGFkZGVkIHR1cGxlc1xuXG4gIHRoaXMuX21sZW4gPSAwOyAvLyBudW1iZXIgb2YgYWN0aXZlIG1vZGlmaWVkIHR1cGxlc1xuXG4gIHRoaXMuX2Ryb3AgPSB0cnVlOyAvLyBzaG91bGQgZW1wdHkgYWdncmVnYXRpb24gY2VsbHMgYmUgcmVtb3ZlZFxuXG4gIHRoaXMuX2Nyb3NzID0gZmFsc2U7IC8vIHByb2R1Y2UgZnVsbCBjcm9zcy1wcm9kdWN0IG9mIGdyb3VwLWJ5IHZhbHVlc1xuXG4gIHRoaXMuX2RpbXMgPSBbXTsgLy8gZ3JvdXAtYnkgZGltZW5zaW9uIGFjY2Vzc29yc1xuXG4gIHRoaXMuX2RuYW1lcyA9IFtdOyAvLyBncm91cC1ieSBkaW1lbnNpb24gbmFtZXNcblxuICB0aGlzLl9tZWFzdXJlcyA9IFtdOyAvLyBjb2xsZWN0aW9uIG9mIGFnZ3JlZ2F0aW9uIG1vbm9pZHNcblxuICB0aGlzLl9jb3VudE9ubHkgPSBmYWxzZTsgLy8gZmxhZyBpbmRpY2F0aW5nIG9ubHkgY291bnQgYWdncmVnYXRpb25cblxuICB0aGlzLl9jb3VudHMgPSBudWxsOyAvLyBjb2xsZWN0aW9uIG9mIGNvdW50IGZpZWxkc1xuXG4gIHRoaXMuX3ByZXYgPSBudWxsOyAvLyBwcmV2aW91cyBhZ2dyZWdhdGlvbiBjZWxsc1xuXG4gIHRoaXMuX2lucHV0cyA9IG51bGw7IC8vIGFycmF5IG9mIGRlcGVuZGVudCBpbnB1dCB0dXBsZSBmaWVsZCBuYW1lc1xuXG4gIHRoaXMuX291dHB1dHMgPSBudWxsOyAvLyBhcnJheSBvZiBvdXRwdXQgdHVwbGUgZmllbGQgbmFtZXNcbn1cbkFnZ3JlZ2F0ZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdBZ2dyZWdhdGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcHMnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3ZhbHVlcyc6IFZhbGlkQWdncmVnYXRlT3BzXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2Ryb3AnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnY3Jvc3MnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2tleScsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH1dXG59O1xuaW5oZXJpdHMoQWdncmVnYXRlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgYWdnciA9IHRoaXMsXG4gICAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICAgIG1vZCA9IF8ubW9kaWZpZWQoKTtcblxuICAgIGFnZ3Iuc3RhbXAgPSBvdXQuc3RhbXA7XG5cbiAgICBpZiAoYWdnci52YWx1ZSAmJiAobW9kIHx8IHB1bHNlLm1vZGlmaWVkKGFnZ3IuX2lucHV0cywgdHJ1ZSkpKSB7XG4gICAgICBhZ2dyLl9wcmV2ID0gYWdnci52YWx1ZTtcbiAgICAgIGFnZ3IudmFsdWUgPSBtb2QgPyBhZ2dyLmluaXQoXykgOiB7fTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiBhZ2dyLmFkZCh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFnZ3IudmFsdWUgPSBhZ2dyLnZhbHVlIHx8IGFnZ3IuaW5pdChfKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiBhZ2dyLnJlbSh0KSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gYWdnci5hZGQodCkpO1xuICAgIH0gLy8gSW5kaWNhdGUgb3V0cHV0IGZpZWxkcyBhbmQgcmV0dXJuIGFnZ3JlZ2F0ZSB0dXBsZXMuXG5cblxuICAgIG91dC5tb2RpZmllcyhhZ2dyLl9vdXRwdXRzKTsgLy8gU2hvdWxkIGVtcHR5IGNlbGxzIGJlIGRyb3BwZWQ/XG5cbiAgICBhZ2dyLl9kcm9wID0gXy5kcm9wICE9PSBmYWxzZTsgLy8gSWYgZG9tYWluIGNyb3NzLXByb2R1Y3QgcmVxdWVzdGVkLCBnZW5lcmF0ZSBlbXB0eSBjZWxscyBhcyBuZWVkZWRcbiAgICAvLyBhbmQgZW5zdXJlIHRoYXQgZW1wdHkgY2VsbHMgYXJlIG5vdCBkcm9wcGVkXG5cbiAgICBpZiAoXy5jcm9zcyAmJiBhZ2dyLl9kaW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGFnZ3IuX2Ryb3AgPSBmYWxzZTtcbiAgICAgIGFnZ3IuY3Jvc3MoKTtcbiAgICB9XG5cbiAgICBpZiAocHVsc2UuY2xlYW4oKSAmJiBhZ2dyLl9kcm9wKSB7XG4gICAgICBvdXQuY2xlYW4odHJ1ZSkucnVuQWZ0ZXIoKCkgPT4gdGhpcy5jbGVhbigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWdnci5jaGFuZ2VzKG91dCk7XG4gIH0sXG5cbiAgY3Jvc3MoKSB7XG4gICAgY29uc3QgYWdnciA9IHRoaXMsXG4gICAgICAgICAgY3VyciA9IGFnZ3IudmFsdWUsXG4gICAgICAgICAgZGltcyA9IGFnZ3IuX2RuYW1lcyxcbiAgICAgICAgICB2YWxzID0gZGltcy5tYXAoKCkgPT4gKHt9KSksXG4gICAgICAgICAgbiA9IGRpbXMubGVuZ3RoOyAvLyBjb2xsZWN0IGFsbCBncm91cC1ieSBkb21haW4gdmFsdWVzXG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0KGNlbGxzKSB7XG4gICAgICBsZXQga2V5LCBpLCB0LCB2O1xuXG4gICAgICBmb3IgKGtleSBpbiBjZWxscykge1xuICAgICAgICB0ID0gY2VsbHNba2V5XS50dXBsZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgdmFsc1tpXVt2ID0gdFtkaW1zW2ldXV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29sbGVjdChhZ2dyLl9wcmV2KTtcbiAgICBjb2xsZWN0KGN1cnIpOyAvLyBpdGVyYXRlIG92ZXIga2V5IGNyb3NzLXByb2R1Y3QsIGNyZWF0ZSBjZWxscyBhcyBuZWVkZWRcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGJhc2UsIHR1cGxlLCBpbmRleCkge1xuICAgICAgY29uc3QgbmFtZSA9IGRpbXNbaW5kZXhdLFxuICAgICAgICAgICAgdiA9IHZhbHNbaW5kZXgrK107XG5cbiAgICAgIGZvciAoY29uc3QgayBpbiB2KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGJhc2UgPyBiYXNlICsgJ3wnICsgayA6IGs7XG4gICAgICAgIHR1cGxlW25hbWVdID0gdltrXTtcbiAgICAgICAgaWYgKGluZGV4IDwgbikgZ2VuZXJhdGUoa2V5LCB0dXBsZSwgaW5kZXgpO2Vsc2UgaWYgKCFjdXJyW2tleV0pIGFnZ3IuY2VsbChrZXksIHR1cGxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZW5lcmF0ZSgnJywge30sIDApO1xuICB9LFxuXG4gIGluaXQoXykge1xuICAgIC8vIGluaXRpYWxpemUgaW5wdXQgYW5kIG91dHB1dCBmaWVsZHNcbiAgICBjb25zdCBpbnB1dHMgPSB0aGlzLl9pbnB1dHMgPSBbXSxcbiAgICAgICAgICBvdXRwdXRzID0gdGhpcy5fb3V0cHV0cyA9IFtdLFxuICAgICAgICAgIGlucHV0TWFwID0ge307XG5cbiAgICBmdW5jdGlvbiBpbnB1dFZpc2l0KGdldCkge1xuICAgICAgY29uc3QgZmllbGRzID0gYXJyYXkoYWNjZXNzb3JGaWVsZHMoZ2V0KSksXG4gICAgICAgICAgICBuID0gZmllbGRzLmxlbmd0aDtcbiAgICAgIGxldCBpID0gMCxcbiAgICAgICAgICBmO1xuXG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoIWlucHV0TWFwW2YgPSBmaWVsZHNbaV1dKSB7XG4gICAgICAgICAgaW5wdXRNYXBbZl0gPSAxO1xuICAgICAgICAgIGlucHV0cy5wdXNoKGYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBpbml0aWFsaXplIGdyb3VwLWJ5IGRpbWVuc2lvbnNcblxuXG4gICAgdGhpcy5fZGltcyA9IGFycmF5KF8uZ3JvdXBieSk7XG4gICAgdGhpcy5fZG5hbWVzID0gdGhpcy5fZGltcy5tYXAoZCA9PiB7XG4gICAgICBjb25zdCBkbmFtZSA9IGFjY2Vzc29yTmFtZShkKTtcbiAgICAgIGlucHV0VmlzaXQoZCk7XG4gICAgICBvdXRwdXRzLnB1c2goZG5hbWUpO1xuICAgICAgcmV0dXJuIGRuYW1lO1xuICAgIH0pO1xuICAgIHRoaXMuY2VsbGtleSA9IF8ua2V5ID8gXy5rZXkgOiBncm91cGtleSh0aGlzLl9kaW1zKTsgLy8gaW5pdGlhbGl6ZSBhZ2dyZWdhdGUgbWVhc3VyZXNcblxuICAgIHRoaXMuX2NvdW50T25seSA9IHRydWU7XG4gICAgdGhpcy5fY291bnRzID0gW107XG4gICAgdGhpcy5fbWVhc3VyZXMgPSBbXTtcbiAgICBjb25zdCBmaWVsZHMgPSBfLmZpZWxkcyB8fCBbbnVsbF0sXG4gICAgICAgICAgb3BzID0gXy5vcHMgfHwgWydjb3VudCddLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBbXSxcbiAgICAgICAgICBuID0gZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBtYXAgPSB7fTtcbiAgICBsZXQgZmllbGQsIG9wLCBtLCBtbmFtZSwgb3V0bmFtZSwgaTtcblxuICAgIGlmIChuICE9PSBvcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVW5tYXRjaGVkIG51bWJlciBvZiBmaWVsZHMgYW5kIGFnZ3JlZ2F0ZSBvcHMuJyk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICBvcCA9IG9wc1tpXTtcblxuICAgICAgaWYgKGZpZWxkID09IG51bGwgJiYgb3AgIT09ICdjb3VudCcpIHtcbiAgICAgICAgZXJyb3IoJ051bGwgYWdncmVnYXRlIGZpZWxkIHNwZWNpZmllZC4nKTtcbiAgICAgIH1cblxuICAgICAgbW5hbWUgPSBhY2Nlc3Nvck5hbWUoZmllbGQpO1xuICAgICAgb3V0bmFtZSA9IG1lYXN1cmVOYW1lKG9wLCBtbmFtZSwgYXNbaV0pO1xuICAgICAgb3V0cHV0cy5wdXNoKG91dG5hbWUpO1xuXG4gICAgICBpZiAob3AgPT09ICdjb3VudCcpIHtcbiAgICAgICAgdGhpcy5fY291bnRzLnB1c2gob3V0bmFtZSk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG0gPSBtYXBbbW5hbWVdO1xuXG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgaW5wdXRWaXNpdChmaWVsZCk7XG4gICAgICAgIG0gPSBtYXBbbW5hbWVdID0gW107XG4gICAgICAgIG0uZmllbGQgPSBmaWVsZDtcblxuICAgICAgICB0aGlzLl9tZWFzdXJlcy5wdXNoKG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAob3AgIT09ICdjb3VudCcpIHRoaXMuX2NvdW50T25seSA9IGZhbHNlO1xuICAgICAgbS5wdXNoKGNyZWF0ZU1lYXN1cmUob3AsIG91dG5hbWUpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tZWFzdXJlcyA9IHRoaXMuX21lYXN1cmVzLm1hcChtID0+IGNvbXBpbGVNZWFzdXJlcyhtLCBtLmZpZWxkKSk7XG4gICAgcmV0dXJuIHt9OyAvLyBhZ2dyZWdhdGlvbiBjZWxscyAodGhpcy52YWx1ZSlcbiAgfSxcblxuICAvLyAtLSBDZWxsIE1hbmFnZW1lbnQgLS0tLS1cbiAgY2VsbGtleTogZ3JvdXBrZXkoKSxcblxuICBjZWxsKGtleSwgdCkge1xuICAgIGxldCBjZWxsID0gdGhpcy52YWx1ZVtrZXldO1xuXG4gICAgaWYgKCFjZWxsKSB7XG4gICAgICBjZWxsID0gdGhpcy52YWx1ZVtrZXldID0gdGhpcy5uZXdjZWxsKGtleSwgdCk7XG4gICAgICB0aGlzLl9hZGRzW3RoaXMuX2FsZW4rK10gPSBjZWxsO1xuICAgIH0gZWxzZSBpZiAoY2VsbC5udW0gPT09IDAgJiYgdGhpcy5fZHJvcCAmJiBjZWxsLnN0YW1wIDwgdGhpcy5zdGFtcCkge1xuICAgICAgY2VsbC5zdGFtcCA9IHRoaXMuc3RhbXA7XG4gICAgICB0aGlzLl9hZGRzW3RoaXMuX2FsZW4rK10gPSBjZWxsO1xuICAgIH0gZWxzZSBpZiAoY2VsbC5zdGFtcCA8IHRoaXMuc3RhbXApIHtcbiAgICAgIGNlbGwuc3RhbXAgPSB0aGlzLnN0YW1wO1xuICAgICAgdGhpcy5fbW9kc1t0aGlzLl9tbGVuKytdID0gY2VsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VsbDtcbiAgfSxcblxuICBuZXdjZWxsKGtleSwgdCkge1xuICAgIGNvbnN0IGNlbGwgPSB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIG51bTogMCxcbiAgICAgIGFnZzogbnVsbCxcbiAgICAgIHR1cGxlOiB0aGlzLm5ld3R1cGxlKHQsIHRoaXMuX3ByZXYgJiYgdGhpcy5fcHJldltrZXldKSxcbiAgICAgIHN0YW1wOiB0aGlzLnN0YW1wLFxuICAgICAgc3RvcmU6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fY291bnRPbmx5KSB7XG4gICAgICBjb25zdCBtZWFzdXJlcyA9IHRoaXMuX21lYXN1cmVzLFxuICAgICAgICAgICAgbiA9IG1lYXN1cmVzLmxlbmd0aDtcbiAgICAgIGNlbGwuYWdnID0gQXJyYXkobik7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNlbGwuYWdnW2ldID0gbmV3IG1lYXN1cmVzW2ldKGNlbGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjZWxsLnN0b3JlKSB7XG4gICAgICBjZWxsLmRhdGEgPSBuZXcgVHVwbGVTdG9yZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBjZWxsO1xuICB9LFxuXG4gIG5ld3R1cGxlKHQsIHApIHtcbiAgICBjb25zdCBuYW1lcyA9IHRoaXMuX2RuYW1lcyxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgICAgICBuID0gZGltcy5sZW5ndGgsXG4gICAgICAgICAgeCA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHhbbmFtZXNbaV1dID0gZGltc1tpXSh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcCA/IHJlcGxhY2UocC50dXBsZSwgeCkgOiBpbmdlc3QoeCk7XG4gIH0sXG5cbiAgY2xlYW4oKSB7XG4gICAgY29uc3QgY2VsbHMgPSB0aGlzLnZhbHVlO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2VsbHMpIHtcbiAgICAgIGlmIChjZWxsc1trZXldLm51bSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgY2VsbHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gLS0gUHJvY2VzcyBUdXBsZXMgLS0tLS1cbiAgYWRkKHQpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmNlbGxrZXkodCksXG4gICAgICAgICAgY2VsbCA9IHRoaXMuY2VsbChrZXksIHQpO1xuICAgIGNlbGwubnVtICs9IDE7XG4gICAgaWYgKHRoaXMuX2NvdW50T25seSkgcmV0dXJuO1xuICAgIGlmIChjZWxsLnN0b3JlKSBjZWxsLmRhdGEuYWRkKHQpO1xuICAgIGNvbnN0IGFnZyA9IGNlbGwuYWdnO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhZ2cubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBhZ2dbaV0uYWRkKGFnZ1tpXS5nZXQodCksIHQpO1xuICAgIH1cbiAgfSxcblxuICByZW0odCkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuY2VsbGtleSh0KSxcbiAgICAgICAgICBjZWxsID0gdGhpcy5jZWxsKGtleSwgdCk7XG4gICAgY2VsbC5udW0gLT0gMTtcbiAgICBpZiAodGhpcy5fY291bnRPbmx5KSByZXR1cm47XG4gICAgaWYgKGNlbGwuc3RvcmUpIGNlbGwuZGF0YS5yZW0odCk7XG4gICAgY29uc3QgYWdnID0gY2VsbC5hZ2c7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGFnZy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGFnZ1tpXS5yZW0oYWdnW2ldLmdldCh0KSwgdCk7XG4gICAgfVxuICB9LFxuXG4gIGNlbGx0dXBsZShjZWxsKSB7XG4gICAgY29uc3QgdHVwbGUgPSBjZWxsLnR1cGxlLFxuICAgICAgICAgIGNvdW50cyA9IHRoaXMuX2NvdW50czsgLy8gY29uc29saWRhdGUgc3RvcmVkIHZhbHVlc1xuXG4gICAgaWYgKGNlbGwuc3RvcmUpIHtcbiAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICB9IC8vIHVwZGF0ZSB0dXBsZSBwcm9wZXJ0aWVzXG5cblxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gY291bnRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdHVwbGVbY291bnRzW2ldXSA9IGNlbGwubnVtO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fY291bnRPbmx5KSB7XG4gICAgICBjb25zdCBhZ2cgPSBjZWxsLmFnZztcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhZ2cubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGFnZ1tpXS5zZXQodHVwbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0dXBsZTtcbiAgfSxcblxuICBjaGFuZ2VzKG91dCkge1xuICAgIGNvbnN0IGFkZHMgPSB0aGlzLl9hZGRzLFxuICAgICAgICAgIG1vZHMgPSB0aGlzLl9tb2RzLFxuICAgICAgICAgIHByZXYgPSB0aGlzLl9wcmV2LFxuICAgICAgICAgIGRyb3AgPSB0aGlzLl9kcm9wLFxuICAgICAgICAgIGFkZCA9IG91dC5hZGQsXG4gICAgICAgICAgcmVtID0gb3V0LnJlbSxcbiAgICAgICAgICBtb2QgPSBvdXQubW9kO1xuICAgIGxldCBjZWxsLCBrZXksIGksIG47XG4gICAgaWYgKHByZXYpIGZvciAoa2V5IGluIHByZXYpIHtcbiAgICAgIGNlbGwgPSBwcmV2W2tleV07XG4gICAgICBpZiAoIWRyb3AgfHwgY2VsbC5udW0pIHJlbS5wdXNoKGNlbGwudHVwbGUpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG4gPSB0aGlzLl9hbGVuOyBpIDwgbjsgKytpKSB7XG4gICAgICBhZGQucHVzaCh0aGlzLmNlbGx0dXBsZShhZGRzW2ldKSk7XG4gICAgICBhZGRzW2ldID0gbnVsbDsgLy8gZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG4gPSB0aGlzLl9tbGVuOyBpIDwgbjsgKytpKSB7XG4gICAgICBjZWxsID0gbW9kc1tpXTtcbiAgICAgIChjZWxsLm51bSA9PT0gMCAmJiBkcm9wID8gcmVtIDogbW9kKS5wdXNoKHRoaXMuY2VsbHR1cGxlKGNlbGwpKTtcbiAgICAgIG1vZHNbaV0gPSBudWxsOyAvLyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgfVxuXG4gICAgdGhpcy5fYWxlbiA9IHRoaXMuX21sZW4gPSAwOyAvLyByZXNldCBsaXN0IG9mIGFjdGl2ZSBjZWxsc1xuXG4gICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuY29uc3QgRVBTSUxPTiQxID0gMWUtMTQ7XG4vKipcbiAqIEdlbmVyYXRlcyBhIGJpbm5pbmcgZnVuY3Rpb24gZm9yIGRpc2NyZXRpemluZyBkYXRhLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuIFRoZVxuICogICBwcm92aWRlZCB2YWx1ZXMgc2hvdWxkIGJlIHZhbGlkIG9wdGlvbnMgZm9yIHRoZSB7QGxpbmsgYmlufSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIGRhdGEgZmllbGQgdG8gYmluLlxuICovXG5cbmZ1bmN0aW9uIEJpbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkJpbi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdCaW4nLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ludGVydmFsJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FuY2hvcicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnbWF4YmlucycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDIwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdiYXNlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMTBcbiAgfSwge1xuICAgICduYW1lJzogJ2RpdmlkZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdkZWZhdWx0JzogWzUsIDJdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdleHRlbnQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzcGFuJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtaW5zdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnbmljZScsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICduYW1lJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWydiaW4wJywgJ2JpbjEnXVxuICB9XVxufTtcbmluaGVyaXRzKEJpbiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGJhbmQgPSBfLmludGVydmFsICE9PSBmYWxzZSxcbiAgICAgICAgICBiaW5zID0gdGhpcy5fYmlucyhfKSxcbiAgICAgICAgICBzdGFydCA9IGJpbnMuc3RhcnQsXG4gICAgICAgICAgc3RlcCA9IGJpbnMuc3RlcCxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgWydiaW4wJywgJ2JpbjEnXSxcbiAgICAgICAgICBiMCA9IGFzWzBdLFxuICAgICAgICAgIGIxID0gYXNbMV07XG5cbiAgICBsZXQgZmxhZztcblxuICAgIGlmIChfLm1vZGlmaWVkKCkpIHtcbiAgICAgIHB1bHNlID0gcHVsc2UucmVmbG93KHRydWUpO1xuICAgICAgZmxhZyA9IHB1bHNlLlNPVVJDRTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhZyA9IHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKF8uZmllbGQpKSA/IHB1bHNlLkFERF9NT0QgOiBwdWxzZS5BREQ7XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQoZmxhZywgYmFuZCA/IHQgPT4ge1xuICAgICAgY29uc3QgdiA9IGJpbnModCk7IC8vIG1pbmltdW0gYmluIHZhbHVlIChpbmNsdXNpdmUpXG5cbiAgICAgIHRbYjBdID0gdjsgLy8gbWF4aW11bSBiaW4gdmFsdWUgKGV4Y2x1c2l2ZSlcbiAgICAgIC8vIHVzZSBjb252b2x1dGVkIG1hdGggZm9yIGJldHRlciBmbG9hdGluZyBwb2ludCBhZ3JlZW1lbnRcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhL2lzc3Vlcy84MzBcbiAgICAgIC8vIGluZmluaXRlIHZhbHVlcyBwcm9wYWdhdGUgdGhyb3VnaCB0aGlzIGZvcm11bGEhICMyMjI3XG5cbiAgICAgIHRbYjFdID0gdiA9PSBudWxsID8gbnVsbCA6IHN0YXJ0ICsgc3RlcCAqICgxICsgKHYgLSBzdGFydCkgLyBzdGVwKTtcbiAgICB9IDogdCA9PiB0W2IwXSA9IGJpbnModCkpO1xuICAgIHJldHVybiBwdWxzZS5tb2RpZmllcyhiYW5kID8gYXMgOiBiMCk7XG4gIH0sXG5cbiAgX2JpbnMoXykge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkID0gXy5maWVsZCxcbiAgICAgICAgICBiaW5zID0gYmluKF8pLFxuICAgICAgICAgIHN0ZXAgPSBiaW5zLnN0ZXA7XG4gICAgbGV0IHN0YXJ0ID0gYmlucy5zdGFydCxcbiAgICAgICAgc3RvcCA9IHN0YXJ0ICsgTWF0aC5jZWlsKChiaW5zLnN0b3AgLSBzdGFydCkgLyBzdGVwKSAqIHN0ZXAsXG4gICAgICAgIGEsXG4gICAgICAgIGQ7XG5cbiAgICBpZiAoKGEgPSBfLmFuY2hvcikgIT0gbnVsbCkge1xuICAgICAgZCA9IGEgLSAoc3RhcnQgKyBzdGVwICogTWF0aC5mbG9vcigoYSAtIHN0YXJ0KSAvIHN0ZXApKTtcbiAgICAgIHN0YXJ0ICs9IGQ7XG4gICAgICBzdG9wICs9IGQ7XG4gICAgfVxuXG4gICAgY29uc3QgZiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBsZXQgdiA9IHRvTnVtYmVyKGZpZWxkKHQpKTtcbiAgICAgIHJldHVybiB2ID09IG51bGwgPyBudWxsIDogdiA8IHN0YXJ0ID8gLUluZmluaXR5IDogdiA+IHN0b3AgPyArSW5maW5pdHkgOiAodiA9IE1hdGgubWF4KHN0YXJ0LCBNYXRoLm1pbih2LCBzdG9wIC0gc3RlcCkpLCBzdGFydCArIHN0ZXAgKiBNYXRoLmZsb29yKEVQU0lMT04kMSArICh2IC0gc3RhcnQpIC8gc3RlcCkpO1xuICAgIH07XG5cbiAgICBmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgZi5zdG9wID0gYmlucy5zdG9wO1xuICAgIGYuc3RlcCA9IHN0ZXA7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPSBhY2Nlc3NvcihmLCBhY2Nlc3NvckZpZWxkcyhmaWVsZCksIF8ubmFtZSB8fCAnYmluXycgKyBhY2Nlc3Nvck5hbWUoZmllbGQpKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gU29ydGVkTGlzdCAoaWRGdW5jLCBzb3VyY2UsIGlucHV0KSB7XG4gIGNvbnN0ICQgPSBpZEZ1bmM7XG4gIGxldCBkYXRhID0gc291cmNlIHx8IFtdLFxuICAgICAgYWRkID0gaW5wdXQgfHwgW10sXG4gICAgICByZW0gPSB7fSxcbiAgICAgIGNudCA9IDA7XG4gIHJldHVybiB7XG4gICAgYWRkOiB0ID0+IGFkZC5wdXNoKHQpLFxuICAgIHJlbW92ZTogdCA9PiByZW1bJCh0KV0gPSArK2NudCxcbiAgICBzaXplOiAoKSA9PiBkYXRhLmxlbmd0aCxcbiAgICBkYXRhOiAoY29tcGFyZSwgcmVzb3J0KSA9PiB7XG4gICAgICBpZiAoY250KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcih0ID0+ICFyZW1bJCh0KV0pO1xuICAgICAgICByZW0gPSB7fTtcbiAgICAgICAgY250ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc29ydCAmJiBjb21wYXJlKSB7XG4gICAgICAgIGRhdGEuc29ydChjb21wYXJlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZC5sZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IGNvbXBhcmUgPyBtZXJnZShjb21wYXJlLCBkYXRhLCBhZGQuc29ydChjb21wYXJlKSkgOiBkYXRhLmNvbmNhdChhZGQpO1xuICAgICAgICBhZGQgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENvbGxlY3RzIGFsbCBkYXRhIHR1cGxlcyB0aGF0IHBhc3MgdGhyb3VnaCB0aGlzIG9wZXJhdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEFuIG9wdGlvbmFsXG4gKiAgIGNvbXBhcmF0b3IgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWxseSBzb3J0aW5nIHRoZSBjb2xsZWN0ZWQgdHVwbGVzLlxuICovXG5cbmZ1bmN0aW9uIENvbGxlY3QocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuQ29sbGVjdC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdDb2xsZWN0JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdzb3VyY2UnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3NvcnQnLFxuICAgICd0eXBlJzogJ2NvbXBhcmUnXG4gIH1dXG59O1xuaW5oZXJpdHMoQ29sbGVjdCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUxMKSxcbiAgICAgICAgICBsaXN0ID0gU29ydGVkTGlzdCh0dXBsZWlkLCB0aGlzLnZhbHVlLCBvdXQubWF0ZXJpYWxpemUob3V0LkFERCkuYWRkKSxcbiAgICAgICAgICBzb3J0ID0gXy5zb3J0LFxuICAgICAgICAgIG1vZCA9IHB1bHNlLmNoYW5nZWQoKSB8fCBzb3J0ICYmIChfLm1vZGlmaWVkKCdzb3J0JykgfHwgcHVsc2UubW9kaWZpZWQoc29ydC5maWVsZHMpKTtcbiAgICBvdXQudmlzaXQob3V0LlJFTSwgbGlzdC5yZW1vdmUpO1xuICAgIHRoaXMubW9kaWZpZWQobW9kKTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IGxpc3QuZGF0YShzdGFibGVDb21wYXJlKHNvcnQpLCBtb2QpOyAvLyBwcm9wYWdhdGUgdHJlZSByb290IGlmIGRlZmluZWRcblxuICAgIGlmIChwdWxzZS5zb3VyY2UgJiYgcHVsc2Uuc291cmNlLnJvb3QpIHtcbiAgICAgIHRoaXMudmFsdWUucm9vdCA9IHB1bHNlLnNvdXJjZS5yb290O1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8ZnVuY3Rpb24+fSBwYXJhbXMuZmllbGRzIC0gVGhlIGZpZWxkcyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbcGFyYW1zLm9yZGVyc10gLSBUaGUgc29ydCBvcmRlcnMuXG4gKiAgIEVhY2ggZW50cnkgc2hvdWxkIGJlIG9uZSBvZiBcImFzY2VuZGluZ1wiIChkZWZhdWx0KSBvciBcImRlc2NlbmRpbmdcIi5cbiAqL1xuXG5mdW5jdGlvbiBDb21wYXJlKHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIG51bGwsIHVwZGF0ZSQ1LCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoQ29tcGFyZSwgT3BlcmF0b3IpO1xuXG5mdW5jdGlvbiB1cGRhdGUkNShfKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkgPyB0aGlzLnZhbHVlIDogY29tcGFyZShfLmZpZWxkcywgXy5vcmRlcnMpO1xufVxuXG4vKipcbiAqIENvdW50IHJlZ2V4cC1kZWZpbmVkIHBhdHRlcm4gb2NjdXJyZW5jZXMgaW4gYSB0ZXh0IGZpZWxkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIEFuIGFjY2Vzc29yIGZvciB0aGUgdGV4dCBmaWVsZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnBhdHRlcm5dIC0gUmVnRXhwIHN0cmluZyBkZWZpbmluZyB0aGUgdGV4dCBwYXR0ZXJuLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY2FzZV0gLSBPbmUgb2YgJ2xvd2VyJywgJ3VwcGVyJyBvciBudWxsIChtaXhlZCkgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnN0b3B3b3Jkc10gLSBSZWdFeHAgc3RyaW5nIG9mIHdvcmRzIHRvIGlnbm9yZS5cbiAqL1xuXG5mdW5jdGlvbiBDb3VudFBhdHRlcm4ocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Db3VudFBhdHRlcm4uRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnQ291bnRQYXR0ZXJuJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlLFxuICAgICdjaGFuZ2VzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2Nhc2UnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBbJ3VwcGVyJywgJ2xvd2VyJywgJ21peGVkJ10sXG4gICAgJ2RlZmF1bHQnOiAnbWl4ZWQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYXR0ZXJuJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ1tcXFxcd1wiXSsnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdG9wd29yZHMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAnJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsndGV4dCcsICdjb3VudCddXG4gIH1dXG59O1xuXG5mdW5jdGlvbiB0b2tlbml6ZSh0ZXh0LCB0Y2FzZSwgbWF0Y2gpIHtcbiAgc3dpdGNoICh0Y2FzZSkge1xuICAgIGNhc2UgJ3VwcGVyJzpcbiAgICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xvd2VyJzpcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0ZXh0Lm1hdGNoKG1hdGNoKTtcbn1cblxuaW5oZXJpdHMoQ291bnRQYXR0ZXJuLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgcHJvY2VzcyA9IHVwZGF0ZSA9PiB0dXBsZSA9PiB7XG4gICAgICB2YXIgdG9rZW5zID0gdG9rZW5pemUoZ2V0KHR1cGxlKSwgXy5jYXNlLCBtYXRjaCkgfHwgW10sXG4gICAgICAgICAgdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICghc3RvcC50ZXN0KHQgPSB0b2tlbnNbaV0pKSB1cGRhdGUodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGluaXQgPSB0aGlzLl9wYXJhbWV0ZXJDaGVjayhfLCBwdWxzZSksXG4gICAgICAgICAgY291bnRzID0gdGhpcy5fY291bnRzLFxuICAgICAgICAgIG1hdGNoID0gdGhpcy5fbWF0Y2gsXG4gICAgICAgICAgc3RvcCA9IHRoaXMuX3N0b3AsXG4gICAgICAgICAgZ2V0ID0gXy5maWVsZCxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgWyd0ZXh0JywgJ2NvdW50J10sXG4gICAgICAgICAgYWRkID0gcHJvY2Vzcyh0ID0+IGNvdW50c1t0XSA9IDEgKyAoY291bnRzW3RdIHx8IDApKSxcbiAgICAgICAgICByZW0gPSBwcm9jZXNzKHQgPT4gY291bnRzW3RdIC09IDEpO1xuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgYWRkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCBhZGQpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCByZW0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9maW5pc2gocHVsc2UsIGFzKTsgLy8gZ2VuZXJhdGUgb3V0cHV0IHR1cGxlc1xuICB9LFxuXG4gIF9wYXJhbWV0ZXJDaGVjayhfLCBwdWxzZSkge1xuICAgIGxldCBpbml0ID0gZmFsc2U7XG5cbiAgICBpZiAoXy5tb2RpZmllZCgnc3RvcHdvcmRzJykgfHwgIXRoaXMuX3N0b3ApIHtcbiAgICAgIHRoaXMuX3N0b3AgPSBuZXcgUmVnRXhwKCdeJyArIChfLnN0b3B3b3JkcyB8fCAnJykgKyAnJCcsICdpJyk7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXy5tb2RpZmllZCgncGF0dGVybicpIHx8ICF0aGlzLl9tYXRjaCkge1xuICAgICAgdGhpcy5fbWF0Y2ggPSBuZXcgUmVnRXhwKF8ucGF0dGVybiB8fCAnW1xcXFx3XFwnXSsnLCAnZycpO1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKF8ubW9kaWZpZWQoJ2ZpZWxkJykgfHwgcHVsc2UubW9kaWZpZWQoXy5maWVsZC5maWVsZHMpKSB7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdCkgdGhpcy5fY291bnRzID0ge307XG4gICAgcmV0dXJuIGluaXQ7XG4gIH0sXG5cbiAgX2ZpbmlzaChwdWxzZSwgYXMpIHtcbiAgICBjb25zdCBjb3VudHMgPSB0aGlzLl9jb3VudHMsXG4gICAgICAgICAgdHVwbGVzID0gdGhpcy5fdHVwbGVzIHx8ICh0aGlzLl90dXBsZXMgPSB7fSksXG4gICAgICAgICAgdGV4dCA9IGFzWzBdLFxuICAgICAgICAgIGNvdW50ID0gYXNbMV0sXG4gICAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpO1xuICAgIGxldCB3LCB0LCBjO1xuXG4gICAgZm9yICh3IGluIGNvdW50cykge1xuICAgICAgdCA9IHR1cGxlc1t3XTtcbiAgICAgIGMgPSBjb3VudHNbd10gfHwgMDtcblxuICAgICAgaWYgKCF0ICYmIGMpIHtcbiAgICAgICAgdHVwbGVzW3ddID0gdCA9IGluZ2VzdCh7fSk7XG4gICAgICAgIHRbdGV4dF0gPSB3O1xuICAgICAgICB0W2NvdW50XSA9IGM7XG4gICAgICAgIG91dC5hZGQucHVzaCh0KTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMCkge1xuICAgICAgICBpZiAodCkgb3V0LnJlbS5wdXNoKHQpO1xuICAgICAgICBjb3VudHNbd10gPSBudWxsO1xuICAgICAgICB0dXBsZXNbd10gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0W2NvdW50XSAhPT0gYykge1xuICAgICAgICB0W2NvdW50XSA9IGM7XG4gICAgICAgIG91dC5tb2QucHVzaCh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgY3Jvc3MtcHJvZHVjdCBvZiBhIHR1cGxlIHN0cmVhbSB3aXRoIGl0c2VsZi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOmJvb2xlYW59IFtwYXJhbXMuZmlsdGVyXSAtIEFuIG9wdGlvbmFsIGZpbHRlclxuICogICBmdW5jdGlvbiBmb3Igc2VsZWN0aXZlbHkgaW5jbHVkaW5nIHR1cGxlcyBpbiB0aGUgY3Jvc3MgcHJvZHVjdC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBUaGUgbmFtZXMgb2YgdGhlIG91dHB1dCBmaWVsZHMuXG4gKi9cblxuZnVuY3Rpb24gQ3Jvc3MocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Dcm9zcy5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdDcm9zcycsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWx0ZXInLFxuICAgICd0eXBlJzogJ2V4cHInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWydhJywgJ2InXVxuICB9XVxufTtcbmluaGVyaXRzKENyb3NzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBbJ2EnLCAnYiddLFxuICAgICAgICAgIGEgPSBhc1swXSxcbiAgICAgICAgICBiID0gYXNbMV0sXG4gICAgICAgICAgcmVzZXQgPSAhdGhpcy52YWx1ZSB8fCBwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERF9SRU0pIHx8IF8ubW9kaWZpZWQoJ2FzJykgfHwgXy5tb2RpZmllZCgnZmlsdGVyJyk7XG5cbiAgICBsZXQgZGF0YSA9IHRoaXMudmFsdWU7XG5cbiAgICBpZiAocmVzZXQpIHtcbiAgICAgIGlmIChkYXRhKSBvdXQucmVtID0gZGF0YTtcbiAgICAgIGRhdGEgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZTtcbiAgICAgIG91dC5hZGQgPSB0aGlzLnZhbHVlID0gY3Jvc3MoZGF0YSwgYSwgYiwgXy5maWx0ZXIgfHwgdHJ1dGh5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lm1vZCA9IGRhdGE7XG4gICAgfVxuXG4gICAgb3V0LnNvdXJjZSA9IHRoaXMudmFsdWU7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIGNyb3NzKGlucHV0LCBhLCBiLCBmaWx0ZXIpIHtcbiAgdmFyIGRhdGEgPSBbXSxcbiAgICAgIHQgPSB7fSxcbiAgICAgIG4gPSBpbnB1dC5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGosXG4gICAgICBsZWZ0O1xuXG4gIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgdFthXSA9IGxlZnQgPSBpbnB1dFtpXTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgIHRbYl0gPSBpbnB1dFtqXTtcblxuICAgICAgaWYgKGZpbHRlcih0KSkge1xuICAgICAgICBkYXRhLnB1c2goaW5nZXN0KHQpKTtcbiAgICAgICAgdCA9IHt9O1xuICAgICAgICB0W2FdID0gbGVmdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuY29uc3QgRGlzdHJpYnV0aW9ucyA9IHtcbiAga2RlOiByYW5kb21LREUsXG4gIG1peHR1cmU6IHJhbmRvbU1peHR1cmUsXG4gIG5vcm1hbDogcmFuZG9tTm9ybWFsLFxuICBsb2dub3JtYWw6IHJhbmRvbUxvZ05vcm1hbCxcbiAgdW5pZm9ybTogcmFuZG9tVW5pZm9ybVxufTtcbmNvbnN0IERJU1RSSUJVVElPTlMgPSAnZGlzdHJpYnV0aW9ucycsXG4gICAgICBGVU5DVElPTiA9ICdmdW5jdGlvbicsXG4gICAgICBGSUVMRCA9ICdmaWVsZCc7XG4vKipcbiAqIFBhcnNlIGEgcGFyYW1ldGVyIG9iamVjdCBmb3IgYSBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gZGVmIC0gVGhlIGRpc3RyaWJ1dGlvbiBwYXJhbWV0ZXIgb2JqZWN0LlxuICogQHBhcmFtIHtmdW5jdGlvbigpOkFycmF5PG9iamVjdD59IC0gQSBtZXRob2QgZm9yIHJlcXVlc3RpbmdcbiAqICAgc291cmNlIGRhdGEuIFVzZWQgZm9yIGRpc3RyaWJ1dGlvbnMgKHN1Y2ggYXMgS0RFKSB0aGF0XG4gKiAgIHJlcXVpcmUgc2FtcGxlIGRhdGEgcG9pbnRzLiBUaGlzIG1ldGhvZCB3aWxsIG9ubHkgYmVcbiAqICAgaW52b2tlZCBpZiB0aGUgJ2Zyb20nIHBhcmFtZXRlciBmb3IgYSB0YXJnZXQgZGF0YSBzb3VyY2VcbiAqICAgaXMgbm90IHByb3ZpZGVkLiBUeXBpY2FsbHkgdGhpcyBtZXRob2QgcmV0dXJucyBiYWNraW5nXG4gKiAgIHNvdXJjZSBkYXRhIGZvciBhIFB1bHNlIG9iamVjdC5cbiAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgb3V0cHV0IGRpc3RyaWJ1dGlvbiBvYmplY3QuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UoZGVmLCBkYXRhKSB7XG4gIGNvbnN0IGZ1bmMgPSBkZWZbRlVOQ1RJT05dO1xuXG4gIGlmICghaGFzT3duUHJvcGVydHkoRGlzdHJpYnV0aW9ucywgZnVuYykpIHtcbiAgICBlcnJvcignVW5rbm93biBkaXN0cmlidXRpb24gZnVuY3Rpb246ICcgKyBmdW5jKTtcbiAgfVxuXG4gIGNvbnN0IGQgPSBEaXN0cmlidXRpb25zW2Z1bmNdKCk7XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGRlZikge1xuICAgIC8vIGlmIGRhdGEgZmllbGQsIGV4dHJhY3QgdmFsdWVzXG4gICAgaWYgKG5hbWUgPT09IEZJRUxEKSB7XG4gICAgICBkLmRhdGEoKGRlZi5mcm9tIHx8IGRhdGEoKSkubWFwKGRlZltuYW1lXSkpO1xuICAgIH0gLy8gaWYgZGlzdHJpYnV0aW9uIG1peHR1cmUsIHJlY3Vyc2UgdG8gcGFyc2UgZWFjaCBkZWZpbml0aW9uXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gRElTVFJJQlVUSU9OUykge1xuICAgICAgICBkW25hbWVdKGRlZltuYW1lXS5tYXAoXyA9PiBwYXJzZShfLCBkYXRhKSkpO1xuICAgICAgfSAvLyBvdGhlcndpc2UsIHNpbXBseSBzZXQgdGhlIHBhcmFtZXRlclxuICAgICAgZWxzZSBpZiAodHlwZW9mIGRbbmFtZV0gPT09IEZVTkNUSU9OKSB7XG4gICAgICAgICAgZFtuYW1lXShkZWZbbmFtZV0pO1xuICAgICAgICB9XG4gIH1cblxuICByZXR1cm4gZDtcbn1cblxuLyoqXG4gKiBHcmlkIHNhbXBsZSBwb2ludHMgZm9yIGEgcHJvYmFiaWxpdHkgZGVuc2l0eS4gR2l2ZW4gYSBkaXN0cmlidXRpb24gYW5kXG4gKiBhIHNhbXBsaW5nIGV4dGVudCwgd2lsbCBnZW5lcmF0ZSBwb2ludHMgc3VpdGFibGUgZm9yIHBsb3R0aW5nIGVpdGhlclxuICogUERGIChwcm9iYWJpbGl0eSBkZW5zaXR5IGZ1bmN0aW9uKSBvciBDREYgKGN1bXVsYXRpdmUgZGlzdHJpYnV0aW9uXG4gKiBmdW5jdGlvbikgY3VydmVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmRpc3RyaWJ1dGlvbiAtIFRoZSBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24uIFRoaXNcbiAqICAgaXMgYW4gb2JqZWN0IHBhcmFtZXRlciBkZXBlbmRlbnQgb24gdGhlIGRpc3RyaWJ1dGlvbiB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMubWV0aG9kPSdwZGYnXSAtIFRoZSBkaXN0cmlidXRpb24gbWV0aG9kIHRvIHNhbXBsZS5cbiAqICAgT25lIG9mICdwZGYnIG9yICdjZGYnLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLmV4dGVudF0gLSBUaGUgW21pbiwgbWF4XSBleHRlbnQgb3ZlciB3aGljaFxuICogICB0byBzYW1wbGUgdGhlIGRpc3RyaWJ1dGlvbi4gVGhpcyBhcmd1bWVudCBpcyByZXF1aXJlZCBpbiBtb3N0IGNhc2VzLCBidXRcbiAqICAgY2FuIGJlIG9taXR0ZWQgaWYgdGhlIGRpc3RyaWJ1dGlvbiAoZS5nLiwgJ2tkZScpIHN1cHBvcnRzIGEgJ2RhdGEnIG1ldGhvZFxuICogICB0aGF0IHJldHVybnMgbnVtZXJpY2FsIHNhbXBsZSBwb2ludHMgZnJvbSB3aGljaCB0aGUgZXh0ZW50IGNhbiBiZSBkZWR1Y2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWluc3RlcHM9MjVdIC0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIGN1cnZlIHNhbXBsZXNcbiAqICAgZm9yIHBsb3R0aW5nIHRoZSBkZW5zaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWF4c3RlcHM9MjAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVzXG4gKiAgIGZvciBwbG90dGluZyB0aGUgZGVuc2l0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXBzXSAtIFRoZSBleGFjdCBudW1iZXIgb2YgY3VydmUgc2FtcGxlcyBmb3JcbiAqICAgcGxvdHRpbmcgdGhlIGRlbnNpdHkuIElmIHNwZWNpZmllZCwgb3ZlcnJpZGVzIGJvdGggbWluc3RlcHMgYW5kIG1heHN0ZXBzXG4gKiAgIHRvIHNldCBhbiBleGFjdCBudW1iZXIgb2YgdW5pZm9ybSBzYW1wbGVzLiBVc2VmdWwgaW4gY29uanVuY3Rpb24gd2l0aFxuICogICBhIGZpeGVkIGV4dGVudCB0byBlbnN1cmUgY29uc2lzdGVudCBzYW1wbGUgcG9pbnRzIGZvciBzdGFja2VkIGRlbnNpdGllcy5cbiAqL1xuXG5mdW5jdGlvbiBEZW5zaXR5KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuY29uc3QgZGlzdHJpYnV0aW9ucyA9IFt7XG4gICdrZXknOiB7XG4gICAgJ2Z1bmN0aW9uJzogJ25vcm1hbCdcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnbWVhbicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZGV2JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMVxuICB9XVxufSwge1xuICAna2V5Jzoge1xuICAgICdmdW5jdGlvbic6ICdsb2dub3JtYWwnXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ21lYW4nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGRldicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDFcbiAgfV1cbn0sIHtcbiAgJ2tleSc6IHtcbiAgICAnZnVuY3Rpb24nOiAndW5pZm9ybSdcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnbWluJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWF4JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMVxuICB9XVxufSwge1xuICAna2V5Jzoge1xuICAgICdmdW5jdGlvbic6ICdrZGUnXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZnJvbScsXG4gICAgJ3R5cGUnOiAnZGF0YSdcbiAgfSwge1xuICAgICduYW1lJzogJ2JhbmR3aWR0aCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfV1cbn1dO1xuY29uc3QgbWl4dHVyZSA9IHtcbiAgJ2tleSc6IHtcbiAgICAnZnVuY3Rpb24nOiAnbWl4dHVyZSdcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZGlzdHJpYnV0aW9ucycsXG4gICAgJ3R5cGUnOiAncGFyYW0nLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3BhcmFtcyc6IGRpc3RyaWJ1dGlvbnNcbiAgfSwge1xuICAgICduYW1lJzogJ3dlaWdodHMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9XVxufTtcbkRlbnNpdHkuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnRGVuc2l0eScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdleHRlbnQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcHMnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ21pbnN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjVcbiAgfSwge1xuICAgICduYW1lJzogJ21heHN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtZXRob2QnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAncGRmJyxcbiAgICAndmFsdWVzJzogWydwZGYnLCAnY2RmJ11cbiAgfSwge1xuICAgICduYW1lJzogJ2Rpc3RyaWJ1dGlvbicsXG4gICAgJ3R5cGUnOiAncGFyYW0nLFxuICAgICdwYXJhbXMnOiBkaXN0cmlidXRpb25zLmNvbmNhdChtaXh0dXJlKVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6IFsndmFsdWUnLCAnZGVuc2l0eSddXG4gIH1dXG59O1xuaW5oZXJpdHMoRGVuc2l0eSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcblxuICAgIGlmICghdGhpcy52YWx1ZSB8fCBwdWxzZS5jaGFuZ2VkKCkgfHwgXy5tb2RpZmllZCgpKSB7XG4gICAgICBjb25zdCBkaXN0ID0gcGFyc2UoXy5kaXN0cmlidXRpb24sIHNvdXJjZShwdWxzZSkpLFxuICAgICAgICAgICAgbWluc3RlcHMgPSBfLnN0ZXBzIHx8IF8ubWluc3RlcHMgfHwgMjUsXG4gICAgICAgICAgICBtYXhzdGVwcyA9IF8uc3RlcHMgfHwgXy5tYXhzdGVwcyB8fCAyMDA7XG4gICAgICBsZXQgbWV0aG9kID0gXy5tZXRob2QgfHwgJ3BkZic7XG5cbiAgICAgIGlmIChtZXRob2QgIT09ICdwZGYnICYmIG1ldGhvZCAhPT0gJ2NkZicpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZGVuc2l0eSBtZXRob2Q6ICcgKyBtZXRob2QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uZXh0ZW50ICYmICFkaXN0LmRhdGEpIHtcbiAgICAgICAgZXJyb3IoJ01pc3NpbmcgZGVuc2l0eSBleHRlbnQgcGFyYW1ldGVyLicpO1xuICAgICAgfVxuXG4gICAgICBtZXRob2QgPSBkaXN0W21ldGhvZF07XG4gICAgICBjb25zdCBhcyA9IF8uYXMgfHwgWyd2YWx1ZScsICdkZW5zaXR5J10sXG4gICAgICAgICAgICBkb21haW4gPSBfLmV4dGVudCB8fCBleHRlbnQoZGlzdC5kYXRhKCkpLFxuICAgICAgICAgICAgdmFsdWVzID0gc2FtcGxlQ3VydmUobWV0aG9kLCBkb21haW4sIG1pbnN0ZXBzLCBtYXhzdGVwcykubWFwKHYgPT4ge1xuICAgICAgICBjb25zdCB0dXBsZSA9IHt9O1xuICAgICAgICB0dXBsZVthc1swXV0gPSB2WzBdO1xuICAgICAgICB0dXBsZVthc1sxXV0gPSB2WzFdO1xuICAgICAgICByZXR1cm4gaW5nZXN0KHR1cGxlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IG91dC5hZGQgPSBvdXQuc291cmNlID0gdmFsdWVzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHNvdXJjZShwdWxzZSkge1xuICByZXR1cm4gKCkgPT4gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGZpZWxkTmFtZXMoZmllbGRzLCBhcykge1xuICBpZiAoIWZpZWxkcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBmaWVsZHMubWFwKChmLCBpKSA9PiBhc1tpXSB8fCBhY2Nlc3Nvck5hbWUoZikpO1xufVxuZnVuY3Rpb24gcGFydGl0aW9uJDEoZGF0YSwgZ3JvdXBieSwgZmllbGQpIHtcbiAgY29uc3QgZ3JvdXBzID0gW10sXG4gICAgICAgIGdldCA9IGYgPT4gZih0KTtcblxuICBsZXQgbWFwLCBpLCBuLCB0LCBrLCBnOyAvLyBwYXJ0aXRpb24gZGF0YSBwb2ludHMgaW50byBncm91cHNcblxuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YS5tYXAoZmllbGQpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcCA9IHt9LCBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gZGF0YVtpXTtcbiAgICAgIGsgPSBncm91cGJ5Lm1hcChnZXQpO1xuICAgICAgZyA9IG1hcFtrXTtcblxuICAgICAgaWYgKCFnKSB7XG4gICAgICAgIG1hcFtrXSA9IGcgPSBbXTtcbiAgICAgICAgZy5kaW1zID0gaztcbiAgICAgICAgZ3JvdXBzLnB1c2goZyk7XG4gICAgICB9XG5cbiAgICAgIGcucHVzaChmaWVsZCh0KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxuY29uc3QgT3V0cHV0ID0gJ2Jpbic7XG4vKipcbiAqIERvdCBkZW5zaXR5IGJpbm5pbmcgZm9yIGRvdCBwbG90IGNvbnN0cnVjdGlvbi5cbiAqIEJhc2VkIG9uIExlbGFuZCBXaWxraW5zb24sIERvdCBQbG90cywgVGhlIEFtZXJpY2FuIFN0YXRpc3RpY2lhbiwgMTk5OS5cbiAqIGh0dHBzOi8vd3d3LmNzLnVpYy5lZHUvfndpbGtpbnNvbi9QdWJsaWNhdGlvbnMvZG90cGxvdHMucGRmXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIGJpbi5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnMgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXBdIC0gVGhlIHN0ZXAgc2l6ZSAoYmluIHdpZHRoKSB3aXRoaW4gd2hpY2ggZG90cyBzaG91bGQgYmVcbiAqICAgc3RhY2tlZC4gRGVmYXVsdHMgdG8gMS8zMCBvZiB0aGUgZXh0ZW50IG9mIHRoZSBkYXRhICpmaWVsZCouXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc21vb3RoPWZhbHNlXSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgZG90IGRlbnNpdHlcbiAqICAgc3RhY2tzIHNob3VsZCBiZSBzbW9vdGhlZCB0byByZWR1Y2UgdmFyaWFuY2UuXG4gKi9cblxuZnVuY3Rpb24gRG90QmluKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuRG90QmluLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0RvdEJpbicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXAnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ3Ntb290aCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiBPdXRwdXRcbiAgfV1cbn07XG5cbmNvbnN0IGF1dG9zdGVwID0gKGRhdGEsIGZpZWxkKSA9PiBzcGFuKGV4dGVudChkYXRhLCBmaWVsZCkpIC8gMzA7XG5cbmluaGVyaXRzKERvdEJpbiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICEoXy5tb2RpZmllZCgpIHx8IHB1bHNlLmNoYW5nZWQoKSkpIHtcbiAgICAgIHJldHVybiBwdWxzZTsgLy8gZWFybHkgZXhpdFxuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbiQxKHB1bHNlLnNvdXJjZSwgXy5ncm91cGJ5LCBpZGVudGl0eSksXG4gICAgICAgICAgc21vb3RoID0gXy5zbW9vdGggfHwgZmFsc2UsXG4gICAgICAgICAgZmllbGQgPSBfLmZpZWxkLFxuICAgICAgICAgIHN0ZXAgPSBfLnN0ZXAgfHwgYXV0b3N0ZXAoc291cmNlLCBmaWVsZCksXG4gICAgICAgICAgc29ydCA9IHN0YWJsZUNvbXBhcmUoKGEsIGIpID0+IGZpZWxkKGEpIC0gZmllbGQoYikpLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBPdXRwdXQsXG4gICAgICAgICAgbiA9IGdyb3Vwcy5sZW5ndGg7IC8vIGNvbXB1dGUgZG90cGxvdCBiaW5zIHBlciBncm91cFxuXG4gICAgbGV0IG1pbiA9IEluZmluaXR5LFxuICAgICAgICBtYXggPSAtSW5maW5pdHksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBqO1xuXG4gICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGcgPSBncm91cHNbaV0uc29ydChzb3J0KTtcbiAgICAgIGogPSAtMTtcblxuICAgICAgZm9yIChjb25zdCB2IG9mIGRvdGJpbihnLCBzdGVwLCBzbW9vdGgsIGZpZWxkKSkge1xuICAgICAgICBpZiAodiA8IG1pbikgbWluID0gdjtcbiAgICAgICAgaWYgKHYgPiBtYXgpIG1heCA9IHY7XG4gICAgICAgIGdbKytqXVthc10gPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICBzdGFydDogbWluLFxuICAgICAgc3RvcDogbWF4LFxuICAgICAgc3RlcDogc3RlcFxuICAgIH07XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyh0cnVlKS5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogV3JhcHMgYW4gZXhwcmVzc2lvbiBmdW5jdGlvbiB3aXRoIGFjY2VzcyB0byBleHRlcm5hbCBwYXJhbWV0ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXJhbXMuZXhwciAtIFRoZSBleHByZXNzaW9uIGZ1bmN0aW9uLiBUaGVcbiAqICBmdW5jdGlvbiBzaG91bGQgYWNjZXB0IGJvdGggYSBkYXR1bSBhbmQgYSBwYXJhbWV0ZXIgb2JqZWN0LlxuICogIFRoaXMgb3BlcmF0b3IncyB2YWx1ZSB3aWxsIGJlIGEgbmV3IGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlXG4gKiAgZXhwcmVzc2lvbiBmdW5jdGlvbiB3aXRoIGFjY2VzcyB0byB0aGlzIG9wZXJhdG9yJ3MgcGFyYW1ldGVycy5cbiAqL1xuXG5mdW5jdGlvbiBFeHByZXNzaW9uKHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIG51bGwsIHVwZGF0ZSQ0LCBwYXJhbXMpO1xuICB0aGlzLm1vZGlmaWVkKHRydWUpO1xufVxuaW5oZXJpdHMoRXhwcmVzc2lvbiwgT3BlcmF0b3IpO1xuXG5mdW5jdGlvbiB1cGRhdGUkNChfKSB7XG4gIGNvbnN0IGV4cHIgPSBfLmV4cHI7XG4gIHJldHVybiB0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCdleHByJykgPyB0aGlzLnZhbHVlIDogYWNjZXNzb3IoZGF0dW0gPT4gZXhwcihkYXR1bSwgXyksIGFjY2Vzc29yRmllbGRzKGV4cHIpLCBhY2Nlc3Nvck5hbWUoZXhwcikpO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGV4dGVudHMgKG1pbi9tYXgpIGZvciBhIGRhdGEgZmllbGQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIGZpZWxkIG92ZXIgd2hpY2ggdG8gY29tcHV0ZSBleHRlbmRzLlxuICovXG5cbmZ1bmN0aW9uIEV4dGVudChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW3VuZGVmaW5lZCwgdW5kZWZpbmVkXSwgcGFyYW1zKTtcbn1cbkV4dGVudC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdFeHRlbnQnLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoRXh0ZW50LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBmaWVsZCA9IF8uZmllbGQsXG4gICAgICAgICAgbW9kID0gcHVsc2UuY2hhbmdlZCgpIHx8IHB1bHNlLm1vZGlmaWVkKGZpZWxkLmZpZWxkcykgfHwgXy5tb2RpZmllZCgnZmllbGQnKTtcblxuICAgIGxldCBtaW4gPSBleHRlbnRbMF0sXG4gICAgICAgIG1heCA9IGV4dGVudFsxXTtcblxuICAgIGlmIChtb2QgfHwgbWluID09IG51bGwpIHtcbiAgICAgIG1pbiA9ICtJbmZpbml0eTtcbiAgICAgIG1heCA9IC1JbmZpbml0eTtcbiAgICB9XG5cbiAgICBwdWxzZS52aXNpdChtb2QgPyBwdWxzZS5TT1VSQ0UgOiBwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgY29uc3QgdiA9IHRvTnVtYmVyKGZpZWxkKHQpKTtcblxuICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAvLyBOYU5zIHdpbGwgZmFpbCBhbGwgY29tcGFyaXNvbnMhXG4gICAgICAgIGlmICh2IDwgbWluKSBtaW4gPSB2O1xuICAgICAgICBpZiAodiA+IG1heCkgbWF4ID0gdjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1pbikgfHwgIU51bWJlci5pc0Zpbml0ZShtYXgpKSB7XG4gICAgICBsZXQgbmFtZSA9IGFjY2Vzc29yTmFtZShmaWVsZCk7XG4gICAgICBpZiAobmFtZSkgbmFtZSA9IGAgZm9yIGZpZWxkIFwiJHtuYW1lfVwiYDtcbiAgICAgIHB1bHNlLmRhdGFmbG93Lndhcm4oYEluZmluaXRlIGV4dGVudCR7bmFtZX06IFske21pbn0sICR7bWF4fV1gKTtcbiAgICAgIG1pbiA9IG1heCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gW21pbiwgbWF4XTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIGJyaWRnZSBiZXR3ZWVuIGEgcGFyZW50IHRyYW5zZm9ybSBhbmQgYSB0YXJnZXQgc3ViZmxvdyB0aGF0XG4gKiBjb25zdW1lcyBvbmx5IGEgc3Vic2V0IG9mIHRoZSB0dXBsZXMgdGhhdCBwYXNzIHRocm91Z2ggdGhlIHBhcmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQdWxzZX0gcHVsc2UgLSBBIHB1bHNlIHRvIHVzZSBhcyB0aGUgdmFsdWUgb2YgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBwYXJlbnQgLSBUaGUgcGFyZW50IHRyYW5zZm9ybSAodHlwaWNhbGx5IGEgRmFjZXQgaW5zdGFuY2UpLlxuICovXG5cbmZ1bmN0aW9uIFN1YmZsb3cocHVsc2UsIHBhcmVudCkge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIHB1bHNlKTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuaW5oZXJpdHMoU3ViZmxvdywgT3BlcmF0b3IsIHtcbiAgLyoqXG4gICAqIFJvdXRlcyBwdWxzZXMgZnJvbSB0aGlzIHN1YmZsb3cgdG8gYSB0YXJnZXQgdHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge1RyYW5zZm9ybX0gdGFyZ2V0IC0gQSB0cmFuc2Zvcm0gdGhhdCByZWNlaXZlcyB0aGUgc3ViZmxvdyBvZiB0dXBsZXMuXG4gICAqL1xuICBjb25uZWN0KHRhcmdldCkge1xuICAgIHRoaXMuZGV0YWNoU3ViZmxvdyA9IHRhcmdldC5kZXRhY2hTdWJmbG93O1xuICAgIHRoaXMudGFyZ2V0cygpLmFkZCh0YXJnZXQpO1xuICAgIHJldHVybiB0YXJnZXQuc291cmNlID0gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGFuICdhZGQnIHR1cGxlIHRvIHRoZSBzdWJmbG93IHB1bHNlLlxuICAgKiBAcGFyYW0ge1R1cGxlfSB0IC0gVGhlIHR1cGxlIGJlaW5nIGFkZGVkLlxuICAgKi9cbiAgYWRkKHQpIHtcbiAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgdGhpcy52YWx1ZS5hZGQucHVzaCh0KTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGEgJ3JlbScgdHVwbGUgdG8gdGhlIHN1YmZsb3cgcHVsc2UuXG4gICAqIEBwYXJhbSB7VHVwbGV9IHQgLSBUaGUgdHVwbGUgYmVpbmcgcmVtb3ZlZC5cbiAgICovXG4gIHJlbSh0KSB7XG4gICAgdGhpcy5jb3VudCAtPSAxO1xuICAgIHRoaXMudmFsdWUucmVtLnB1c2godCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhICdtb2QnIHR1cGxlIHRvIHRoZSBzdWJmbG93IHB1bHNlLlxuICAgKiBAcGFyYW0ge1R1cGxlfSB0IC0gVGhlIHR1cGxlIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cbiAgbW9kKHQpIHtcbiAgICB0aGlzLnZhbHVlLm1vZC5wdXNoKHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZS1pbml0aWFsaXplIHRoaXMgb3BlcmF0b3IncyBwdWxzZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtQdWxzZX0gcHVsc2UgLSBUaGUgcHVsc2UgdG8gY29weSBmcm9tLlxuICAgKiBAc2VlIFB1bHNlLmluaXRcbiAgICovXG4gIGluaXQocHVsc2UpIHtcbiAgICB0aGlzLnZhbHVlLmluaXQocHVsc2UsIHB1bHNlLk5PX1NPVVJDRSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoaXMgb3BlcmF0b3IuIFRoaXMgbWV0aG9kIG92ZXJyaWRlcyB0aGVcbiAgICogZGVmYXVsdCBiZWhhdmlvciB0byBzaW1wbHkgcmV0dXJuIHRoZSBjb250YWluZWQgcHVsc2UgdmFsdWUuXG4gICAqIEByZXR1cm4ge1B1bHNlfVxuICAgKi9cbiAgZXZhbHVhdGUoKSB7XG4gICAgLy8gYXNzZXJ0OiB0aGlzLnZhbHVlLnN0YW1wID09PSBwdWxzZS5zdGFtcFxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEZhY2V0cyBhIGRhdGFmbG93IGludG8gYSBzZXQgb2Ygc3ViZmxvd3MgYmFzZWQgb24gYSBrZXkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRGF0YWZsb3csIHN0cmluZyk6IE9wZXJhdG9yfSBwYXJhbXMuc3ViZmxvdyAtIEEgZnVuY3Rpb25cbiAqICAgdGhhdCBnZW5lcmF0ZXMgYSBzdWJmbG93IG9mIG9wZXJhdG9ycyBhbmQgcmV0dXJucyBpdHMgcm9vdCBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmtleSAtIFRoZSBrZXkgZmllbGQgdG8gZmFjZXQgYnkuXG4gKi9cblxuZnVuY3Rpb24gRmFjZXQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIHt9LCBwYXJhbXMpO1xuICB0aGlzLl9rZXlzID0gZmFzdG1hcCgpOyAvLyBjYWNoZSBwcmV2aW91c2x5IGNhbGN1bGF0ZWQga2V5IHZhbHVlc1xuICAvLyBrZWVwIHRyYWNrIG9mIGFjdGl2ZSBzdWJmbG93cywgdXNlIGFzIHRhcmdldHMgYXJyYXkgZm9yIGxpc3RlbmVyc1xuICAvLyB0aGlzIGFsbG93cyB1cyB0byBsaW1pdCBwcm9wYWdhdGlvbiB0byBvbmx5IHVwZGF0ZWQgc3ViZmxvd3NcblxuICBjb25zdCBhID0gdGhpcy5fdGFyZ2V0cyA9IFtdO1xuICBhLmFjdGl2ZSA9IDA7XG5cbiAgYS5mb3JFYWNoID0gZiA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhLmFjdGl2ZTsgaSA8IG47ICsraSkge1xuICAgICAgZihhW2ldLCBpLCBhKTtcbiAgICB9XG4gIH07XG59XG5pbmhlcml0cyhGYWNldCwgVHJhbnNmb3JtLCB7XG4gIGFjdGl2YXRlKGZsb3cpIHtcbiAgICB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMuYWN0aXZlKytdID0gZmxvdztcbiAgfSxcblxuICAvLyBwYXJlbnQgYXJndW1lbnQgcHJvdmlkZWQgYnkgUHJlRmFjZXQgc3ViY2xhc3NcbiAgc3ViZmxvdyhrZXksIGZsb3csIHB1bHNlLCBwYXJlbnQpIHtcbiAgICBjb25zdCBmbG93cyA9IHRoaXMudmFsdWU7XG4gICAgbGV0IHNmID0gaGFzT3duUHJvcGVydHkoZmxvd3MsIGtleSkgJiYgZmxvd3Nba2V5XSxcbiAgICAgICAgZGYsXG4gICAgICAgIHA7XG5cbiAgICBpZiAoIXNmKSB7XG4gICAgICBwID0gcGFyZW50IHx8IChwID0gdGhpcy5fZ3JvdXBba2V5XSkgJiYgcC50dXBsZTtcbiAgICAgIGRmID0gcHVsc2UuZGF0YWZsb3c7XG4gICAgICBzZiA9IG5ldyBTdWJmbG93KHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKSwgdGhpcyk7XG4gICAgICBkZi5hZGQoc2YpLmNvbm5lY3QoZmxvdyhkZiwga2V5LCBwKSk7XG4gICAgICBmbG93c1trZXldID0gc2Y7XG4gICAgICB0aGlzLmFjdGl2YXRlKHNmKTtcbiAgICB9IGVsc2UgaWYgKHNmLnZhbHVlLnN0YW1wIDwgcHVsc2Uuc3RhbXApIHtcbiAgICAgIHNmLmluaXQocHVsc2UpO1xuICAgICAgdGhpcy5hY3RpdmF0ZShzZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNmO1xuICB9LFxuXG4gIGNsZWFuKCkge1xuICAgIGNvbnN0IGZsb3dzID0gdGhpcy52YWx1ZTtcbiAgICBsZXQgZGV0YWNoZWQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmxvd3MpIHtcbiAgICAgIGlmIChmbG93c1trZXldLmNvdW50ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGRldGFjaCA9IGZsb3dzW2tleV0uZGV0YWNoU3ViZmxvdztcbiAgICAgICAgaWYgKGRldGFjaCkgZGV0YWNoKCk7XG4gICAgICAgIGRlbGV0ZSBmbG93c1trZXldO1xuICAgICAgICArK2RldGFjaGVkO1xuICAgICAgfVxuICAgIH0gLy8gcmVtb3ZlIGluYWN0aXZlIHRhcmdldHMgZnJvbSB0aGUgYWN0aXZlIHRhcmdldHMgYXJyYXlcblxuXG4gICAgaWYgKGRldGFjaGVkKSB7XG4gICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl90YXJnZXRzLmZpbHRlcihzZiA9PiBzZiAmJiBzZi5jb3VudCA+IDApO1xuXG4gICAgICB0aGlzLmluaXRUYXJnZXRzKGFjdGl2ZSk7XG4gICAgfVxuICB9LFxuXG4gIGluaXRUYXJnZXRzKGFjdCkge1xuICAgIGNvbnN0IGEgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICAgIG4gPSBhLmxlbmd0aCxcbiAgICAgICAgICBtID0gYWN0ID8gYWN0Lmxlbmd0aCA6IDA7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBtOyArK2kpIHtcbiAgICAgIGFbaV0gPSBhY3RbaV07XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBuICYmIGFbaV0gIT0gbnVsbDsgKytpKSB7XG4gICAgICBhW2ldID0gbnVsbDsgLy8gZW5zdXJlIG9sZCBmbG93cyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICB9XG5cbiAgICBhLmFjdGl2ZSA9IG07XG4gIH0sXG5cbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZGYgPSBwdWxzZS5kYXRhZmxvdyxcbiAgICAgICAgICBrZXkgPSBfLmtleSxcbiAgICAgICAgICBmbG93ID0gXy5zdWJmbG93LFxuICAgICAgICAgIGNhY2hlID0gdGhpcy5fa2V5cyxcbiAgICAgICAgICByZWtleSA9IF8ubW9kaWZpZWQoJ2tleScpLFxuICAgICAgICAgIHN1YmZsb3cgPSBrZXkgPT4gdGhpcy5zdWJmbG93KGtleSwgZmxvdywgcHVsc2UpO1xuXG4gICAgdGhpcy5fZ3JvdXAgPSBfLmdyb3VwIHx8IHt9O1xuICAgIHRoaXMuaW5pdFRhcmdldHMoKTsgLy8gcmVzZXQgbGlzdCBvZiBhY3RpdmUgc3ViZmxvd3NcblxuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCksXG4gICAgICAgICAgICBrID0gY2FjaGUuZ2V0KGlkKTtcblxuICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWNoZS5kZWxldGUoaWQpO1xuICAgICAgICBzdWJmbG93KGspLnJlbSh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgY29uc3QgayA9IGtleSh0KTtcbiAgICAgIGNhY2hlLnNldCh0dXBsZWlkKHQpLCBrKTtcbiAgICAgIHN1YmZsb3coaykuYWRkKHQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHJla2V5IHx8IHB1bHNlLm1vZGlmaWVkKGtleS5maWVsZHMpKSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCksXG4gICAgICAgICAgICAgIGswID0gY2FjaGUuZ2V0KGlkKSxcbiAgICAgICAgICAgICAgazEgPSBrZXkodCk7XG5cbiAgICAgICAgaWYgKGswID09PSBrMSkge1xuICAgICAgICAgIHN1YmZsb3coazEpLm1vZCh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZS5zZXQoaWQsIGsxKTtcbiAgICAgICAgICBzdWJmbG93KGswKS5yZW0odCk7XG4gICAgICAgICAgc3ViZmxvdyhrMSkuYWRkKHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHB1bHNlLmNoYW5nZWQocHVsc2UuTU9EKSkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHtcbiAgICAgICAgc3ViZmxvdyhjYWNoZS5nZXQodHVwbGVpZCh0KSkpLm1vZCh0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZWtleSkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVGTE9XLCB0ID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpLFxuICAgICAgICAgICAgICBrMCA9IGNhY2hlLmdldChpZCksXG4gICAgICAgICAgICAgIGsxID0ga2V5KHQpO1xuXG4gICAgICAgIGlmIChrMCAhPT0gazEpIHtcbiAgICAgICAgICBjYWNoZS5zZXQoaWQsIGsxKTtcbiAgICAgICAgICBzdWJmbG93KGswKS5yZW0odCk7XG4gICAgICAgICAgc3ViZmxvdyhrMSkuYWRkKHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocHVsc2UuY2xlYW4oKSkge1xuICAgICAgZGYucnVuQWZ0ZXIoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgIGNhY2hlLmNsZWFuKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLmVtcHR5ID4gZGYuY2xlYW5UaHJlc2hvbGQpIHtcbiAgICAgIGRmLnJ1bkFmdGVyKGNhY2hlLmNsZWFuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIG9uZSBvciBtb3JlIGZpZWxkIGFjY2Vzc29yIGZ1bmN0aW9ucy5cbiAqIElmIHRoZSAnbmFtZScgcGFyYW1ldGVyIGlzIGFuIGFycmF5LCBhbiBhcnJheSBvZiBmaWVsZCBhY2Nlc3NvcnNcbiAqIHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlICdhcycgcGFyYW1ldGVyIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lIC0gVGhlIGZpZWxkIG5hbWUocykgdG8gYWNjZXNzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hcyAtIFRoZSBhY2Nlc3NvciBmdW5jdGlvbiBuYW1lLlxuICovXG5cbmZ1bmN0aW9uIEZpZWxkKHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIG51bGwsIHVwZGF0ZSQzLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoRmllbGQsIE9wZXJhdG9yKTtcblxuZnVuY3Rpb24gdXBkYXRlJDMoXykge1xuICByZXR1cm4gdGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpID8gdGhpcy52YWx1ZSA6IGlzQXJyYXkoXy5uYW1lKSA/IGFycmF5KF8ubmFtZSkubWFwKGYgPT4gZmllbGQoZikpIDogZmllbGQoXy5uYW1lLCBfLmFzKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXJzIGRhdGEgdHVwbGVzIGFjY29yZGluZyB0byBhIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZXhwciAtIFRoZSBwcmVkaWNhdGUgZXhwcmVzc2lvbiBmdW5jdGlvblxuICogICB0aGF0IGRldGVybWluZXMgYSB0dXBsZSdzIGZpbHRlciBzdGF0dXMuIFRydXRoeSB2YWx1ZXMgcGFzcyB0aGUgZmlsdGVyLlxuICovXG5cbmZ1bmN0aW9uIEZpbHRlcihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgZmFzdG1hcCgpLCBwYXJhbXMpO1xufVxuRmlsdGVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0ZpbHRlcicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZXhwcicsXG4gICAgJ3R5cGUnOiAnZXhwcicsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKEZpbHRlciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGRmID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICAgICAgY2FjaGUgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIC8vIGNhY2hlIGlkcyBvZiBmaWx0ZXJlZCB0dXBsZXNcbiAgICBvdXRwdXQgPSBwdWxzZS5mb3JrKCksXG4gICAgICAgICAgYWRkID0gb3V0cHV0LmFkZCxcbiAgICAgICAgICByZW0gPSBvdXRwdXQucmVtLFxuICAgICAgICAgIG1vZCA9IG91dHB1dC5tb2QsXG4gICAgICAgICAgdGVzdCA9IF8uZXhwcjtcbiAgICBsZXQgaXNNb2QgPSB0cnVlO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCk7XG4gICAgICBpZiAoIWNhY2hlLmhhcyhpZCkpIHJlbS5wdXNoKHQpO2Vsc2UgY2FjaGUuZGVsZXRlKGlkKTtcbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgaWYgKHRlc3QodCwgXykpIGFkZC5wdXNoKHQpO2Vsc2UgY2FjaGUuc2V0KHR1cGxlaWQodCksIDEpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmV2aXNpdCh0KSB7XG4gICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCksXG4gICAgICAgICAgICBiID0gdGVzdCh0LCBfKSxcbiAgICAgICAgICAgIHMgPSBjYWNoZS5nZXQoaWQpO1xuXG4gICAgICBpZiAoYiAmJiBzKSB7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShpZCk7XG4gICAgICAgIGFkZC5wdXNoKHQpO1xuICAgICAgfSBlbHNlIGlmICghYiAmJiAhcykge1xuICAgICAgICBjYWNoZS5zZXQoaWQsIDEpO1xuICAgICAgICByZW0ucHVzaCh0KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNb2QgJiYgYiAmJiAhcykge1xuICAgICAgICBtb2QucHVzaCh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHJldmlzaXQpO1xuXG4gICAgaWYgKF8ubW9kaWZpZWQoKSkge1xuICAgICAgaXNNb2QgPSBmYWxzZTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFRkxPVywgcmV2aXNpdCk7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlLmVtcHR5ID4gZGYuY2xlYW5UaHJlc2hvbGQpIGRmLnJ1bkFmdGVyKGNhY2hlLmNsZWFuKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGFycmF5LXR5cGVkIGZpZWxkIHZhbHVlcyBpbnRvIG5ldyBkYXRhIG9iamVjdHMuXG4gKiBJZiBtdWx0aXBsZSBmaWVsZHMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgdHJlYXRlZCBhcyBwYXJhbGxlbCBhcnJheXMsXG4gKiB3aXRoIG91dHB1dCB2YWx1ZXMgaW5jbHVkZWQgZm9yIGVhY2ggbWF0Y2hpbmcgaW5kZXggKG9yIG51bGwgaWYgbWlzc2luZykuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IHBhcmFtcy5maWVsZHMgLSBBbiBhcnJheSBvZiBmaWVsZFxuICogICBhY2Nlc3NvcnMgZm9yIHRoZSB0dXBsZSBmaWVsZHMgdGhhdCBzaG91bGQgYmUgZmxhdHRlbmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuaW5kZXhdIC0gT3B0aW9uYWwgb3V0cHV0IGZpZWxkIG5hbWUgZm9yIGluZGV4XG4gKiAgIHZhbHVlLiBJZiB1bnNwZWNpZmllZCwgbm8gaW5kZXggZmllbGQgaXMgaW5jbHVkZWQgaW4gdGhlIG91dHB1dC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBPdXRwdXQgZmllbGQgbmFtZXMgZm9yIGZsYXR0ZW5lZFxuICogICBhcnJheSBmaWVsZHMuIEFueSB1bnNwZWNpZmllZCBmaWVsZHMgd2lsbCB1c2UgdGhlIGZpZWxkIG5hbWUgcHJvdmlkZWRcbiAqICAgYnkgdGhlIGZpZWxkcyBhY2Nlc3NvcnMuXG4gKi9cblxuZnVuY3Rpb24gRmxhdHRlbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG59XG5GbGF0dGVuLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0ZsYXR0ZW4nLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdpbmRleCcsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKEZsYXR0ZW4sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksXG4gICAgICAgICAgZmllbGRzID0gXy5maWVsZHMsXG4gICAgICAgICAgYXMgPSBmaWVsZE5hbWVzKGZpZWxkcywgXy5hcyB8fCBbXSksXG4gICAgICAgICAgaW5kZXggPSBfLmluZGV4IHx8IG51bGwsXG4gICAgICAgICAgbSA9IGFzLmxlbmd0aDsgLy8gcmVtb3ZlIGFueSBwcmV2aW91cyByZXN1bHRzXG5cbiAgICBvdXQucmVtID0gdGhpcy52YWx1ZTsgLy8gZ2VuZXJhdGUgZmxhdHRlbmVkIHR1cGxlc1xuXG4gICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IHtcbiAgICAgIGNvbnN0IGFycmF5cyA9IGZpZWxkcy5tYXAoZiA9PiBmKHQpKSxcbiAgICAgICAgICAgIG1heGxlbiA9IGFycmF5cy5yZWR1Y2UoKGwsIGEpID0+IE1hdGgubWF4KGwsIGEubGVuZ3RoKSwgMCk7XG4gICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgaixcbiAgICAgICAgICBkLFxuICAgICAgICAgIHY7XG5cbiAgICAgIGZvciAoOyBpIDwgbWF4bGVuOyArK2kpIHtcbiAgICAgICAgZCA9IGRlcml2ZSh0KTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgZFthc1tqXV0gPSAodiA9IGFycmF5c1tqXVtpXSkgPT0gbnVsbCA/IG51bGwgOiB2O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgZFtpbmRleF0gPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0LmFkZC5wdXNoKGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZDtcbiAgICBpZiAoaW5kZXgpIG91dC5tb2RpZmllcyhpbmRleCk7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogRm9sZHMgb25lIG1vcmUgdHVwbGUgZmllbGRzIGludG8gbXVsdGlwbGUgdHVwbGVzIGluIHdoaWNoIHRoZSBmaWVsZFxuICogbmFtZSBhbmQgdmFsdWVzIGFyZSBhdmFpbGFibGUgdW5kZXIgbmV3ICdrZXknIGFuZCAndmFsdWUnIGZpZWxkcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGRzIC0gQW4gYXJyYXkgb2YgZmllbGQgYWNjZXNzb3JzXG4gKiAgIGZvciB0aGUgdHVwbGUgZmllbGRzIHRoYXQgc2hvdWxkIGJlIGZvbGRlZC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBPdXRwdXQgZmllbGQgbmFtZXMgZm9yIGZvbGRlZCBrZXlcbiAqICAgYW5kIHZhbHVlIGZpZWxkcywgZGVmYXVsdHMgdG8gWydrZXknLCAndmFsdWUnXS5cbiAqL1xuXG5mdW5jdGlvbiBGb2xkKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbn1cbkZvbGQuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnRm9sZCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBbJ2tleScsICd2YWx1ZSddXG4gIH1dXG59O1xuaW5oZXJpdHMoRm9sZCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKSxcbiAgICAgICAgICBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgICAgICBmbmFtZXMgPSBmaWVsZHMubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgICAgYXMgPSBfLmFzIHx8IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgICAgayA9IGFzWzBdLFxuICAgICAgICAgIHYgPSBhc1sxXSxcbiAgICAgICAgICBuID0gZmllbGRzLmxlbmd0aDtcbiAgICBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGQ7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgZCA9IGRlcml2ZSh0KTtcbiAgICAgICAgZFtrXSA9IGZuYW1lc1tpXTtcbiAgICAgICAgZFt2XSA9IGZpZWxkc1tpXSh0KTtcbiAgICAgICAgb3V0LmFkZC5wdXNoKGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZDtcbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBJbnZva2VzIGEgZnVuY3Rpb24gZm9yIGVhY2ggZGF0YSB0dXBsZSBhbmQgc2F2ZXMgdGhlIHJlc3VsdHMgYXMgYSBuZXcgZmllbGQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmV4cHIgLSBUaGUgZm9ybXVsYSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggdHVwbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFzIC0gVGhlIGZpZWxkIG5hbWUgdW5kZXIgd2hpY2ggdG8gc2F2ZSB0aGUgcmVzdWx0LlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmluaXRvbmx5PWZhbHNlXSAtIElmIHRydWUsIHRoZSBmb3JtdWxhIGlzIGFwcGxpZWQgdG9cbiAqICAgYWRkZWQgdHVwbGVzIG9ubHksIGFuZCBkb2VzIG5vdCB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gbW9kaWZpY2F0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBGb3JtdWxhKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuRm9ybXVsYS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdGb3JtdWxhJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZXhwcicsXG4gICAgJ3R5cGUnOiAnZXhwcicsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaW5pdG9ubHknLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nXG4gIH1dXG59O1xuaW5oZXJpdHMoRm9ybXVsYSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGZ1bmMgPSBfLmV4cHIsXG4gICAgICAgICAgYXMgPSBfLmFzLFxuICAgICAgICAgIG1vZCA9IF8ubW9kaWZpZWQoKSxcbiAgICAgICAgICBmbGFnID0gXy5pbml0b25seSA/IHB1bHNlLkFERCA6IG1vZCA/IHB1bHNlLlNPVVJDRSA6IHB1bHNlLm1vZGlmaWVkKGZ1bmMuZmllbGRzKSB8fCBwdWxzZS5tb2RpZmllZChhcykgPyBwdWxzZS5BRERfTU9EIDogcHVsc2UuQUREO1xuXG4gICAgaWYgKG1vZCkge1xuICAgICAgLy8gcGFyYW1ldGVycyB1cGRhdGVkLCBuZWVkIHRvIHJlZmxvd1xuICAgICAgcHVsc2UgPSBwdWxzZS5tYXRlcmlhbGl6ZSgpLnJlZmxvdyh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaW5pdG9ubHkpIHtcbiAgICAgIHB1bHNlLm1vZGlmaWVzKGFzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2UudmlzaXQoZmxhZywgdCA9PiB0W2FzXSA9IGZ1bmModCwgXykpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBkYXRhIHR1cGxlcyB1c2luZyBhIHByb3ZpZGVkIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihQYXJhbWV0ZXJzKTogb2JqZWN0fSBwYXJhbXMuZ2VuZXJhdG9yIC0gQSB0dXBsZSBnZW5lcmF0b3JcbiAqICAgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgZ2l2ZW4gdGhlIG9wZXJhdG9yIHBhcmFtZXRlcnMgYXMgaW5wdXQuXG4gKiAgIENoYW5nZXMgdG8gYW55IGFkZGl0aW9uYWwgcGFyYW1ldGVycyB3aWxsIG5vdCB0cmlnZ2VyIHJlLWNhbGN1bGF0aW9uXG4gKiAgIG9mIHByZXZpb3VzbHkgZ2VuZXJhdGVkIHR1cGxlcy4gT25seSBmdXR1cmUgdHVwbGVzIGFyZSBhZmZlY3RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc2l6ZSAtIFRoZSBudW1iZXIgb2YgdHVwbGVzIHRvIHByb2R1Y2UuXG4gKi9cblxuZnVuY3Rpb24gR2VuZXJhdGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoR2VuZXJhdGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFMTCksXG4gICAgICAgICAgZ2VuID0gXy5nZW5lcmF0b3I7XG4gICAgbGV0IGRhdGEgPSB0aGlzLnZhbHVlLFxuICAgICAgICBudW0gPSBfLnNpemUgLSBkYXRhLmxlbmd0aCxcbiAgICAgICAgYWRkLFxuICAgICAgICByZW0sXG4gICAgICAgIHQ7XG5cbiAgICBpZiAobnVtID4gMCkge1xuICAgICAgLy8gbmVlZCBtb3JlIHR1cGxlcywgZ2VuZXJhdGUgYW5kIGFkZFxuICAgICAgZm9yIChhZGQgPSBbXTsgLS1udW0gPj0gMDspIHtcbiAgICAgICAgYWRkLnB1c2godCA9IGluZ2VzdChnZW4oXykpKTtcbiAgICAgICAgZGF0YS5wdXNoKHQpO1xuICAgICAgfVxuXG4gICAgICBvdXQuYWRkID0gb3V0LmFkZC5sZW5ndGggPyBvdXQubWF0ZXJpYWxpemUob3V0LkFERCkuYWRkLmNvbmNhdChhZGQpIDogYWRkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZWVkIGZld2VyIHR1cGxlcywgcmVtb3ZlXG4gICAgICByZW0gPSBkYXRhLnNsaWNlKDAsIC1udW0pO1xuICAgICAgb3V0LnJlbSA9IG91dC5yZW0ubGVuZ3RoID8gb3V0Lm1hdGVyaWFsaXplKG91dC5SRU0pLnJlbS5jb25jYXQocmVtKSA6IHJlbTtcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKC1udW0pO1xuICAgIH1cblxuICAgIG91dC5zb3VyY2UgPSB0aGlzLnZhbHVlID0gZGF0YTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5jb25zdCBNZXRob2RzID0ge1xuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgbWVkaWFuOiBtZWRpYW4sXG4gIG1lYW46IG1lYW4sXG4gIG1pbjogbWluLFxuICBtYXg6IG1heFxufTtcbmNvbnN0IEVtcHR5ID0gW107XG4vKipcbiAqIEltcHV0ZSBtaXNzaW5nIHZhbHVlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgdmFsdWUgZmllbGQgdG8gaW1wdXRlLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mXG4gKiAgIGFjY2Vzc29ycyB0byBkZXRlcm1pbmUgc2VyaWVzIHdpdGhpbiB3aGljaCB0byBwZXJmb3JtIGltcHV0YXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5rZXkgLSBBbiBhY2Nlc3NvciBmb3IgYSBrZXkgdmFsdWUuXG4gKiAgIEVhY2gga2V5IHZhbHVlIHNob3VsZCBiZSB1bmlxdWUgd2l0aGluIGEgZ3JvdXAuIE5ldyB0dXBsZXMgd2lsbCBiZVxuICogICBpbXB1dGVkIGZvciBhbnkga2V5IHZhbHVlcyB0aGF0IGFyZSBub3QgZm91bmQgd2l0aGluIGEgZ3JvdXAuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBbcGFyYW1zLmtleXZhbHNdIC0gT3B0aW9uYWwgYXJyYXkgb2YgcmVxdWlyZWQga2V5XG4gKiAgIHZhbHVlcy4gTmV3IHR1cGxlcyB3aWxsIGJlIGltcHV0ZWQgZm9yIGFueSBrZXkgdmFsdWVzIHRoYXQgYXJlIG5vdFxuICogICBmb3VuZCB3aXRoaW4gYSBncm91cC4gSW4gYWRkaXRpb24sIHRoZXNlIHZhbHVlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHlcbiAqICAgYXVnbWVudGVkIHdpdGggdGhlIGtleSB2YWx1ZXMgb2JzZXJ2ZWQgaW4gdGhlIGlucHV0IGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZD0ndmFsdWUnXSAtIFRoZSBpbXB1dGF0aW9uIG1ldGhvZCB0byB1c2UuIE9uZSBvZlxuICogICAndmFsdWUnLCAnbWVhbicsICdtZWRpYW4nLCAnbWF4JywgJ21pbicuXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT0wXSAtIFRoZSBjb25zdGFudCB2YWx1ZSB0byB1c2UgZm9yIGltcHV0YXRpb25cbiAqICAgd2hlbiB1c2luZyBtZXRob2QgJ3ZhbHVlJy5cbiAqL1xuXG5mdW5jdGlvbiBJbXB1dGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuSW1wdXRlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0ltcHV0ZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdrZXknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdrZXl2YWxzJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICd2YWx1ZScsXG4gICAgJ3ZhbHVlcyc6IFsndmFsdWUnLCAnbWVhbicsICdtZWRpYW4nLCAnbWF4JywgJ21pbiddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd2YWx1ZScsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH1dXG59O1xuXG5mdW5jdGlvbiBnZXRWYWx1ZShfKSB7XG4gIHZhciBtID0gXy5tZXRob2QgfHwgTWV0aG9kcy52YWx1ZSxcbiAgICAgIHY7XG5cbiAgaWYgKE1ldGhvZHNbbV0gPT0gbnVsbCkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgaW1wdXRhdGlvbiBtZXRob2Q6ICcgKyBtKTtcbiAgfSBlbHNlIGlmIChtID09PSBNZXRob2RzLnZhbHVlKSB7XG4gICAgdiA9IF8udmFsdWUgIT09IHVuZGVmaW5lZCA/IF8udmFsdWUgOiAwO1xuICAgIHJldHVybiAoKSA9PiB2O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNZXRob2RzW21dO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpZWxkKF8pIHtcbiAgY29uc3QgZiA9IF8uZmllbGQ7XG4gIHJldHVybiB0ID0+IHQgPyBmKHQpIDogTmFOO1xufVxuXG5pbmhlcml0cyhJbXB1dGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLFxuICAgICAgICBpbXB1dGUgPSBnZXRWYWx1ZShfKSxcbiAgICAgICAgZmllbGQgPSBnZXRGaWVsZChfKSxcbiAgICAgICAgZk5hbWUgPSBhY2Nlc3Nvck5hbWUoXy5maWVsZCksXG4gICAgICAgIGtOYW1lID0gYWNjZXNzb3JOYW1lKF8ua2V5KSxcbiAgICAgICAgZ05hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbihwdWxzZS5zb3VyY2UsIF8uZ3JvdXBieSwgXy5rZXksIF8ua2V5dmFscyksXG4gICAgICAgIGN1cnIgPSBbXSxcbiAgICAgICAgcHJldiA9IHRoaXMudmFsdWUsXG4gICAgICAgIG0gPSBncm91cHMuZG9tYWluLmxlbmd0aCxcbiAgICAgICAgZ3JvdXAsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBnVmFscyxcbiAgICAgICAga1ZhbCxcbiAgICAgICAgZyxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgbCxcbiAgICAgICAgbixcbiAgICAgICAgdDtcblxuICAgIGZvciAoZyA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBnIDwgbDsgKytnKSB7XG4gICAgICBncm91cCA9IGdyb3Vwc1tnXTtcbiAgICAgIGdWYWxzID0gZ3JvdXAudmFsdWVzO1xuICAgICAgdmFsdWUgPSBOYU47IC8vIGFkZCB0dXBsZXMgZm9yIG1pc3NpbmcgdmFsdWVzXG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgaWYgKGdyb3VwW2pdICE9IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICBrVmFsID0gZ3JvdXBzLmRvbWFpbltqXTtcbiAgICAgICAgdCA9IHtcbiAgICAgICAgICBfaW1wdXRlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGdWYWxzLmxlbmd0aDsgaSA8IG47ICsraSkgdFtnTmFtZXNbaV1dID0gZ1ZhbHNbaV07XG5cbiAgICAgICAgdFtrTmFtZV0gPSBrVmFsO1xuICAgICAgICB0W2ZOYW1lXSA9IE51bWJlci5pc05hTih2YWx1ZSkgPyB2YWx1ZSA9IGltcHV0ZShncm91cCwgZmllbGQpIDogdmFsdWU7XG4gICAgICAgIGN1cnIucHVzaChpbmdlc3QodCkpO1xuICAgICAgfVxuICAgIH0gLy8gdXBkYXRlIHB1bHNlIHdpdGggaW1wdXRlZCB0dXBsZXNcblxuXG4gICAgaWYgKGN1cnIubGVuZ3RoKSBvdXQuYWRkID0gb3V0Lm1hdGVyaWFsaXplKG91dC5BREQpLmFkZC5jb25jYXQoY3Vycik7XG4gICAgaWYgKHByZXYubGVuZ3RoKSBvdXQucmVtID0gb3V0Lm1hdGVyaWFsaXplKG91dC5SRU0pLnJlbS5jb25jYXQocHJldik7XG4gICAgdGhpcy52YWx1ZSA9IGN1cnI7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIGtleSwga2V5dmFscykge1xuICB2YXIgZ2V0ID0gZiA9PiBmKHQpLFxuICAgICAgZ3JvdXBzID0gW10sXG4gICAgICBkb21haW4gPSBrZXl2YWxzID8ga2V5dmFscy5zbGljZSgpIDogW10sXG4gICAgICBrTWFwID0ge30sXG4gICAgICBnTWFwID0ge30sXG4gICAgICBnVmFscyxcbiAgICAgIGdLZXksXG4gICAgICBncm91cCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgayxcbiAgICAgIG4sXG4gICAgICB0O1xuXG4gIGRvbWFpbi5mb3JFYWNoKChrLCBpKSA9PiBrTWFwW2tdID0gaSArIDEpO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHQgPSBkYXRhW2ldO1xuICAgIGsgPSBrZXkodCk7XG4gICAgaiA9IGtNYXBba10gfHwgKGtNYXBba10gPSBkb21haW4ucHVzaChrKSk7XG4gICAgZ0tleSA9IChnVmFscyA9IGdyb3VwYnkgPyBncm91cGJ5Lm1hcChnZXQpIDogRW1wdHkpICsgJyc7XG5cbiAgICBpZiAoIShncm91cCA9IGdNYXBbZ0tleV0pKSB7XG4gICAgICBncm91cCA9IGdNYXBbZ0tleV0gPSBbXTtcbiAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICAgIGdyb3VwLnZhbHVlcyA9IGdWYWxzO1xuICAgIH1cblxuICAgIGdyb3VwW2ogLSAxXSA9IHQ7XG4gIH1cblxuICBncm91cHMuZG9tYWluID0gZG9tYWluO1xuICByZXR1cm4gZ3JvdXBzO1xufVxuXG4vKipcbiAqIEV4dGVuZCBpbnB1dCB0dXBsZXMgd2l0aCBhZ2dyZWdhdGUgdmFsdWVzLlxuICogQ2FsY3VhdGVzIGFnZ3JlZ2F0ZSB2YWx1ZXMgYW5kIGpvaW5zIHRoZW0gd2l0aCB0aGUgaW5wdXQgc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gSm9pbkFnZ3JlZ2F0ZShwYXJhbXMpIHtcbiAgQWdncmVnYXRlLmNhbGwodGhpcywgcGFyYW1zKTtcbn1cbkpvaW5BZ2dyZWdhdGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnSm9pbkFnZ3JlZ2F0ZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3BzJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICd2YWx1ZXMnOiBWYWxpZEFnZ3JlZ2F0ZU9wc1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2tleScsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH1dXG59O1xuaW5oZXJpdHMoSm9pbkFnZ3JlZ2F0ZSwgQWdncmVnYXRlLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGFnZ3IgPSB0aGlzLFxuICAgICAgICAgIG1vZCA9IF8ubW9kaWZpZWQoKTtcblxuICAgIGxldCBjZWxsczsgLy8gcHJvY2VzcyBhbGwgaW5wdXQgdHVwbGVzIHRvIGNhbGN1bGF0ZSBhZ2dyZWdhdGVzXG5cbiAgICBpZiAoYWdnci52YWx1ZSAmJiAobW9kIHx8IHB1bHNlLm1vZGlmaWVkKGFnZ3IuX2lucHV0cywgdHJ1ZSkpKSB7XG4gICAgICBjZWxscyA9IGFnZ3IudmFsdWUgPSBtb2QgPyBhZ2dyLmluaXQoXykgOiB7fTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiBhZ2dyLmFkZCh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxzID0gYWdnci52YWx1ZSA9IGFnZ3IudmFsdWUgfHwgdGhpcy5pbml0KF8pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IGFnZ3IucmVtKHQpKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiBhZ2dyLmFkZCh0KSk7XG4gICAgfSAvLyB1cGRhdGUgYWdncmVnYXRpb24gY2VsbHNcblxuXG4gICAgYWdnci5jaGFuZ2VzKCk7IC8vIHdyaXRlIGFnZ3JlZ2F0ZSB2YWx1ZXMgdG8gaW5wdXQgdHVwbGVzXG5cbiAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgICAgZXh0ZW5kKHQsIGNlbGxzW2FnZ3IuY2VsbGtleSh0KV0udHVwbGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3cobW9kKS5tb2RpZmllcyh0aGlzLl9vdXRwdXRzKTtcbiAgfSxcblxuICBjaGFuZ2VzKCkge1xuICAgIGNvbnN0IGFkZHMgPSB0aGlzLl9hZGRzLFxuICAgICAgICAgIG1vZHMgPSB0aGlzLl9tb2RzO1xuICAgIGxldCBpLCBuO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IHRoaXMuX2FsZW47IGkgPCBuOyArK2kpIHtcbiAgICAgIHRoaXMuY2VsbHR1cGxlKGFkZHNbaV0pO1xuICAgICAgYWRkc1tpXSA9IG51bGw7IC8vIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gdGhpcy5fbWxlbjsgaSA8IG47ICsraSkge1xuICAgICAgdGhpcy5jZWxsdHVwbGUobW9kc1tpXSk7XG4gICAgICBtb2RzW2ldID0gbnVsbDsgLy8gZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIH1cblxuICAgIHRoaXMuX2FsZW4gPSB0aGlzLl9tbGVuID0gMDsgLy8gcmVzZXQgbGlzdCBvZiBhY3RpdmUgY2VsbHNcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBDb21wdXRlIGtlcm5lbCBkZW5zaXR5IGVzdGltYXRlcyAoS0RFKSBmb3Igb25lIG9yIG1vcmUgZGF0YSBncm91cHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnNcbiAqICAgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gQW4gYWNjZXNzb3IgZm9yIHRoZSBkYXRhIGZpZWxkXG4gKiAgIHRvIGVzdGltYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuYmFuZHdpZHRoPTBdIC0gVGhlIEtERSBrZXJuZWwgYmFuZHdpZHRoLlxuICogICBJZiB6ZXJvIG9yIHVuc3BlY2lmaWVkLCB0aGUgYmFuZHdpZHRoIGlzIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5jb3VudHM9ZmFsc2VdIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGVcbiAqICAgb3V0cHV0IHZhbHVlcyBzaG91bGQgYmUgcHJvYmFiaWxpdHkgZXN0aW1hdGVzIChmYWxzZSwgZGVmYXVsdCkgb3JcbiAqICAgc21vb3RoZWQgY291bnRzICh0cnVlKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmN1bXVsYXRpdmU9ZmFsc2VdIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiBhXG4gKiAgIGRlbnNpdHkgKGZhbHNlKSBvciBjdW11bGF0aXZlIGRpc3RyaWJ1dGlvbiAodHJ1ZSkgc2hvdWxkIGJlIGdlbmVyYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5leHRlbnRdIC0gVGhlIGRvbWFpbiBleHRlbnQgb3ZlciB3aGljaCB0b1xuICogICBwbG90IHRoZSBkZW5zaXR5LiBJZiB1bnNwZWNpZmllZCwgdGhlIFttaW4sIG1heF0gZGF0YSBleHRlbnQgaXMgdXNlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnJlc29sdmU9J2luZGVwZW5kZW50J10gLSBJbmRpY2F0ZXMgaG93IHBhcmFtZXRlcnMgZm9yXG4gKiAgIG11bHRpcGxlIGRlbnNpdGllcyBzaG91bGQgYmUgcmVzb2x2ZWQuIElmIFwiaW5kZXBlbmRlbnRcIiAodGhlIGRlZmF1bHQpLCBlYWNoXG4gKiAgIGRlbnNpdHkgbWF5IGhhdmUgaXRzIG93biBkb21haW4gZXh0ZW50IGFuZCBkeW5hbWljIG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVcbiAqICAgc3RlcHMuIElmIFwic2hhcmVkXCIsIHRoZSBLREUgdHJhbnNmb3JtIHdpbGwgZW5zdXJlIHRoYXQgYWxsIGRlbnNpdGllcyBhcmVcbiAqICAgZGVmaW5lZCBvdmVyIGEgc2hhcmVkIGRvbWFpbiBhbmQgY3VydmUgc3RlcHMsIGVuYWJsaW5nIHN0YWNraW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWluc3RlcHM9MjVdIC0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIGN1cnZlIHNhbXBsZXNcbiAqICAgZm9yIHBsb3R0aW5nIHRoZSBkZW5zaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWF4c3RlcHM9MjAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVzXG4gKiAgIGZvciBwbG90dGluZyB0aGUgZGVuc2l0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXBzXSAtIFRoZSBleGFjdCBudW1iZXIgb2YgY3VydmUgc2FtcGxlcyBmb3JcbiAqICAgcGxvdHRpbmcgdGhlIGRlbnNpdHkuIElmIHNwZWNpZmllZCwgb3ZlcnJpZGVzIGJvdGggbWluc3RlcHMgYW5kIG1heHN0ZXBzXG4gKiAgIHRvIHNldCBhbiBleGFjdCBudW1iZXIgb2YgdW5pZm9ybSBzYW1wbGVzLiBVc2VmdWwgaW4gY29uanVuY3Rpb24gd2l0aFxuICogICBhIGZpeGVkIGV4dGVudCB0byBlbnN1cmUgY29uc2lzdGVudCBzYW1wbGUgcG9pbnRzIGZvciBzdGFja2VkIGRlbnNpdGllcy5cbiAqL1xuXG5mdW5jdGlvbiBLREUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5LREUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnS0RFJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2N1bXVsYXRpdmUnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2NvdW50cycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYmFuZHdpZHRoJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ3Jlc29sdmUnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBbJ3NoYXJlZCcsICdpbmRlcGVuZGVudCddLFxuICAgICdkZWZhdWx0JzogJ2luZGVwZW5kZW50J1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcHMnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ21pbnN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjVcbiAgfSwge1xuICAgICduYW1lJzogJ21heHN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdkZWZhdWx0JzogWyd2YWx1ZScsICdkZW5zaXR5J11cbiAgfV1cbn07XG5pbmhlcml0cyhLREUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG5cbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgcHVsc2UuY2hhbmdlZCgpIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgICAgICBncm91cHMgPSBwYXJ0aXRpb24kMShzb3VyY2UsIF8uZ3JvdXBieSwgXy5maWVsZCksXG4gICAgICAgICAgICBuYW1lcyA9IChfLmdyb3VwYnkgfHwgW10pLm1hcChhY2Nlc3Nvck5hbWUpLFxuICAgICAgICAgICAgYmFuZHdpZHRoID0gXy5iYW5kd2lkdGgsXG4gICAgICAgICAgICBtZXRob2QgPSBfLmN1bXVsYXRpdmUgPyAnY2RmJyA6ICdwZGYnLFxuICAgICAgICAgICAgYXMgPSBfLmFzIHx8IFsndmFsdWUnLCAnZGVuc2l0eSddLFxuICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICBsZXQgZG9tYWluID0gXy5leHRlbnQsXG4gICAgICAgICAgbWluc3RlcHMgPSBfLnN0ZXBzIHx8IF8ubWluc3RlcHMgfHwgMjUsXG4gICAgICAgICAgbWF4c3RlcHMgPSBfLnN0ZXBzIHx8IF8ubWF4c3RlcHMgfHwgMjAwO1xuXG4gICAgICBpZiAobWV0aG9kICE9PSAncGRmJyAmJiBtZXRob2QgIT09ICdjZGYnKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGRlbnNpdHkgbWV0aG9kOiAnICsgbWV0aG9kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8ucmVzb2x2ZSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgaWYgKCFkb21haW4pIGRvbWFpbiA9IGV4dGVudChzb3VyY2UsIF8uZmllbGQpO1xuICAgICAgICBtaW5zdGVwcyA9IG1heHN0ZXBzID0gXy5zdGVwcyB8fCBtYXhzdGVwcztcbiAgICAgIH1cblxuICAgICAgZ3JvdXBzLmZvckVhY2goZyA9PiB7XG4gICAgICAgIGNvbnN0IGRlbnNpdHkgPSByYW5kb21LREUoZywgYmFuZHdpZHRoKVttZXRob2RdLFxuICAgICAgICAgICAgICBzY2FsZSA9IF8uY291bnRzID8gZy5sZW5ndGggOiAxLFxuICAgICAgICAgICAgICBsb2NhbCA9IGRvbWFpbiB8fCBleHRlbnQoZyk7XG4gICAgICAgIHNhbXBsZUN1cnZlKGRlbnNpdHksIGxvY2FsLCBtaW5zdGVwcywgbWF4c3RlcHMpLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IHt9O1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdFtuYW1lc1tpXV0gPSBnLmRpbXNbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFthc1swXV0gPSB2WzBdO1xuICAgICAgICAgIHRbYXNbMV1dID0gdlsxXSAqIHNjYWxlO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gb3V0LmFkZCA9IG91dC5zb3VyY2UgPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBrZXkgZnVuY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcGFyYW1zLmZpZWxkcyAtIFRoZSBmaWVsZCBuYW1lKHMpIGZvciB0aGUga2V5IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuZmxhdCAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGZpZWxkIG5hbWVzXG4gKiAgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgZmxhdCBwcm9wZXJ0eSBuYW1lcywgc2lkZS1zdGVwcGluZyBuZXN0ZWQgZmllbGRcbiAqICBsb29rdXBzIG5vcm1hbGx5IGluZGljYXRlZCBieSBkb3Qgb3IgYnJhY2tldCBub3RhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBLZXkocGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlJDIsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhLZXksIE9wZXJhdG9yKTtcblxuZnVuY3Rpb24gdXBkYXRlJDIoXykge1xuICByZXR1cm4gdGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpID8gdGhpcy52YWx1ZSA6IGtleShfLmZpZWxkcywgXy5mbGF0KTtcbn1cblxuLyoqXG4gKiBMb2FkIGFuZCBwYXJzZSBkYXRhIGZyb20gYW4gZXh0ZXJuYWwgc291cmNlLiBNYXJzaGFsbHMgcGFyYW1ldGVyXG4gKiB2YWx1ZXMgYW5kIHRoZW4gaW52b2tlcyB0aGUgRGF0YWZsb3cgcmVxdWVzdCBtZXRob2QuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXJsIC0gVGhlIFVSTCB0byBsb2FkIGZyb20uXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmZvcm1hdCAtIFRoZSBkYXRhIGZvcm1hdCBvcHRpb25zLlxuICovXG5cbmZ1bmN0aW9uIExvYWQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xuICB0aGlzLl9wZW5kaW5nID0gbnVsbDtcbn1cbmluaGVyaXRzKExvYWQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBkZiA9IHB1bHNlLmRhdGFmbG93O1xuXG4gICAgaWYgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuIHB1bHNlXG4gICAgICByZXR1cm4gb3V0cHV0KHRoaXMsIHB1bHNlLCB0aGlzLl9wZW5kaW5nKTtcbiAgICB9XG5cbiAgICBpZiAoc3RvcChfKSkgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcblxuICAgIGlmIChfLnZhbHVlcykge1xuICAgICAgLy8gcGFyc2UgYW5kIGluZ2VzdCB2YWx1ZXMsIHJldHVybiBvdXRwdXQgcHVsc2VcbiAgICAgIHJldHVybiBvdXRwdXQodGhpcywgcHVsc2UsIGRmLnBhcnNlKF8udmFsdWVzLCBfLmZvcm1hdCkpO1xuICAgIH0gZWxzZSBpZiAoXy5hc3luYykge1xuICAgICAgLy8gcmV0dXJuIHByb21pc2UgZm9yIG5vbi1ibG9ja2luZyBhc3luYyBsb2FkaW5nXG4gICAgICBjb25zdCBwID0gZGYucmVxdWVzdChfLnVybCwgXy5mb3JtYXQpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgdGhpcy5fcGVuZGluZyA9IGFycmF5KHJlcy5kYXRhKTtcbiAgICAgICAgcmV0dXJuIGRmID0+IGRmLnRvdWNoKHRoaXMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3luYzogcFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIHByb21pc2UgZm9yIHN5bmNocm9ub3VzIGxvYWRpbmdcbiAgICAgIHJldHVybiBkZi5yZXF1ZXN0KF8udXJsLCBfLmZvcm1hdCkudGhlbihyZXMgPT4gb3V0cHV0KHRoaXMsIHB1bHNlLCBhcnJheShyZXMuZGF0YSkpKTtcbiAgICB9XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHN0b3AoXykge1xuICByZXR1cm4gXy5tb2RpZmllZCgnYXN5bmMnKSAmJiAhKF8ubW9kaWZpZWQoJ3ZhbHVlcycpIHx8IF8ubW9kaWZpZWQoJ3VybCcpIHx8IF8ubW9kaWZpZWQoJ2Zvcm1hdCcpKTtcbn1cblxuZnVuY3Rpb24gb3V0cHV0KG9wLCBwdWxzZSwgZGF0YSkge1xuICBkYXRhLmZvckVhY2goaW5nZXN0KTtcbiAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19GSUVMRFMgJiBwdWxzZS5OT19TT1VSQ0UpO1xuICBvdXQucmVtID0gb3AudmFsdWU7XG4gIG9wLnZhbHVlID0gb3V0LnNvdXJjZSA9IG91dC5hZGQgPSBkYXRhO1xuICBvcC5fcGVuZGluZyA9IG51bGw7XG4gIGlmIChvdXQucmVtLmxlbmd0aCkgb3V0LmNsZWFuKHRydWUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEV4dGVuZCB0dXBsZXMgYnkgam9pbmluZyB0aGVtIHdpdGggdmFsdWVzIGZyb20gYSBsb29rdXAgdGFibGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7TWFwfSBwYXJhbXMuaW5kZXggLSBUaGUgbG9va3VwIHRhYmxlIG1hcC5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkcyAtIFRoZSBmaWVsZHMgdG8gbG9va3VwLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwYXJhbXMuYXMgLSBPdXRwdXQgZmllbGQgbmFtZXMgZm9yIGVhY2ggbG9va3VwIHZhbHVlLlxuICogQHBhcmFtIHsqfSBbcGFyYW1zLmRlZmF1bHRdIC0gQSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiBsb29rdXAgZmFpbHMuXG4gKi9cblxuZnVuY3Rpb24gTG9va3VwKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7fSwgcGFyYW1zKTtcbn1cbkxvb2t1cC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdMb29rdXAnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdpbmRleCcsXG4gICAgJ3R5cGUnOiAnaW5kZXgnLFxuICAgICdwYXJhbXMnOiBbe1xuICAgICAgJ25hbWUnOiAnZnJvbScsXG4gICAgICAndHlwZSc6ICdkYXRhJyxcbiAgICAgICdyZXF1aXJlZCc6IHRydWVcbiAgICB9LCB7XG4gICAgICAnbmFtZSc6ICdrZXknLFxuICAgICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICAgIH1dXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd2YWx1ZXMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2RlZmF1bHQnLFxuICAgICdkZWZhdWx0JzogbnVsbFxuICB9XVxufTtcbmluaGVyaXRzKExvb2t1cCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGtleXMgPSBfLmZpZWxkcyxcbiAgICAgICAgICBpbmRleCA9IF8uaW5kZXgsXG4gICAgICAgICAgdmFsdWVzID0gXy52YWx1ZXMsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gXy5kZWZhdWx0ID09IG51bGwgPyBudWxsIDogXy5kZWZhdWx0LFxuICAgICAgICAgIHJlc2V0ID0gXy5tb2RpZmllZCgpLFxuICAgICAgICAgIG4gPSBrZXlzLmxlbmd0aDtcblxuICAgIGxldCBmbGFnID0gcmVzZXQgPyBwdWxzZS5TT1VSQ0UgOiBwdWxzZS5BREQsXG4gICAgICAgIG91dCA9IHB1bHNlLFxuICAgICAgICBhcyA9IF8uYXMsXG4gICAgICAgIHNldCxcbiAgICAgICAgbSxcbiAgICAgICAgbW9kcztcblxuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIG0gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICBpZiAobiA+IDEgJiYgIWFzKSB7XG4gICAgICAgIGVycm9yKCdNdWx0aS1maWVsZCBsb29rdXAgcmVxdWlyZXMgZXhwbGljaXQgXCJhc1wiIHBhcmFtZXRlci4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFzICYmIGFzLmxlbmd0aCAhPT0gbiAqIG0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBcImFzXCIgcGFyYW1ldGVyIGhhcyB0b28gZmV3IG91dHB1dCBmaWVsZCBuYW1lcy4nKTtcbiAgICAgIH1cblxuICAgICAgYXMgPSBhcyB8fCB2YWx1ZXMubWFwKGFjY2Vzc29yTmFtZSk7XG5cbiAgICAgIHNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrID0gMCwgaiwgdjsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHYgPSBpbmRleC5nZXQoa2V5c1tpXSh0KSk7XG4gICAgICAgICAgaWYgKHYgPT0gbnVsbCkgZm9yIChqID0gMDsgaiA8IG07ICsraiwgKytrKSB0W2FzW2tdXSA9IGRlZmF1bHRWYWx1ZTtlbHNlIGZvciAoaiA9IDA7IGogPCBtOyArK2osICsraykgdFthc1trXV0gPSB2YWx1ZXNbal0odik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYXMpIHtcbiAgICAgICAgZXJyb3IoJ01pc3Npbmcgb3V0cHV0IGZpZWxkIG5hbWVzLicpO1xuICAgICAgfVxuXG4gICAgICBzZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgdjsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHYgPSBpbmRleC5nZXQoa2V5c1tpXSh0KSk7XG4gICAgICAgICAgdFthc1tpXV0gPSB2ID09IG51bGwgPyBkZWZhdWx0VmFsdWUgOiB2O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChyZXNldCkge1xuICAgICAgb3V0ID0gcHVsc2UucmVmbG93KHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RzID0ga2V5cy5zb21lKGsgPT4gcHVsc2UubW9kaWZpZWQoay5maWVsZHMpKTtcbiAgICAgIGZsYWcgfD0gbW9kcyA/IHB1bHNlLk1PRCA6IDA7XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQoZmxhZywgc2V0KTtcbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBDb21wdXRlcyBnbG9iYWwgbWluL21heCBleHRlbnRzIG92ZXIgYSBjb2xsZWN0aW9uIG9mIGV4dGVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBhcmFtcy5leHRlbnRzIC0gVGhlIGlucHV0IGV4dGVudHMuXG4gKi9cblxuZnVuY3Rpb24gTXVsdGlFeHRlbnQocGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlJDEsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhNdWx0aUV4dGVudCwgT3BlcmF0b3IpO1xuXG5mdW5jdGlvbiB1cGRhdGUkMShfKSB7XG4gIGlmICh0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IGV4dCA9IF8uZXh0ZW50cyxcbiAgICAgICAgbiA9IGV4dC5sZW5ndGg7XG4gIGxldCBtaW4gPSArSW5maW5pdHksXG4gICAgICBtYXggPSAtSW5maW5pdHksXG4gICAgICBpLFxuICAgICAgZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZSA9IGV4dFtpXTtcbiAgICBpZiAoZVswXSA8IG1pbikgbWluID0gZVswXTtcbiAgICBpZiAoZVsxXSA+IG1heCkgbWF4ID0gZVsxXTtcbiAgfVxuXG4gIHJldHVybiBbbWluLCBtYXhdO1xufVxuXG4vKipcbiAqIE1lcmdlIGEgY29sbGVjdGlvbiBvZiB2YWx1ZSBhcnJheXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8Kj4+fSBwYXJhbXMudmFsdWVzIC0gVGhlIGlucHV0IHZhbHVlIGFycnJheXMuXG4gKi9cblxuZnVuY3Rpb24gTXVsdGlWYWx1ZXMocGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoTXVsdGlWYWx1ZXMsIE9wZXJhdG9yKTtcblxuZnVuY3Rpb24gdXBkYXRlKF8pIHtcbiAgcmV0dXJuIHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSA/IHRoaXMudmFsdWUgOiBfLnZhbHVlcy5yZWR1Y2UoKGRhdGEsIF8pID0+IGRhdGEuY29uY2F0KF8pLCBbXSk7XG59XG5cbi8qKlxuICogT3BlcmF0b3Igd2hvc2UgdmFsdWUgaXMgc2ltcGx5IGl0cyBwYXJhbWV0ZXIgaGFzaC4gVGhpcyBvcGVyYXRvciBpc1xuICogdXNlZnVsIGZvciBlbmFibGluZyByZWFjdGl2ZSB1cGRhdGVzIHRvIHZhbHVlcyBvZiBuZXN0ZWQgb2JqZWN0cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIFBhcmFtcyhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFBhcmFtcywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHRoaXMubW9kaWZpZWQoXy5tb2RpZmllZCgpKTtcbiAgICB0aGlzLnZhbHVlID0gXztcbiAgICByZXR1cm4gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpOyAvLyBkbyBub3QgcGFzcyB0dXBsZXNcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBBZ2dyZWdhdGUgYW5kIHBpdm90IHNlbGVjdGVkIGZpZWxkIHZhbHVlcyB0byBiZWNvbWUgbmV3IGZpZWxkcy5cbiAqIFRoaXMgb3BlcmF0b3IgaXMgdXNlZnVsIHRvIGNvbnN0cnVjdGlvbiBjcm9zcy10YWJ1bGF0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29yc1xuICogIHRvIGdyb3VwYnkuIFRoZXNlIGZpZWxkcyBhY3QganVzdCBsaWtlIGdyb3VwYnkgZmllbGRzIG9mIGFuIEFnZ3JlZ2F0ZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSBmaWVsZCB0byBwaXZvdCBvbi4gVGhlIHVuaXF1ZVxuICogIHZhbHVlcyBvZiB0aGlzIGZpZWxkIGJlY29tZSBuZXcgZmllbGQgbmFtZXMgaW4gdGhlIG91dHB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy52YWx1ZSAtIFRoZSBmaWVsZCB0byBwb3B1bGF0ZSBwaXZvdGVkIGZpZWxkcy5cbiAqICBUaGUgYWdncmVnYXRlIHZhbHVlcyBvZiB0aGlzIGZpZWxkIGJlY29tZSB0aGUgdmFsdWVzIG9mIHRoZSBuZXcgcGl2b3RlZCBmaWVsZHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5vcF0gLSBUaGUgYWdncmVnYXRpb24gb3BlcmF0aW9uIGZvciB0aGUgdmFsdWUgZmllbGQsXG4gKiAgYXBwbGllZCBwZXIgY2VsbCBpbiB0aGUgb3V0cHV0IHN0cmVhbS4gVGhlIGRlZmF1bHQgaXMgXCJzdW1cIi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmxpbWl0XSAtIEFuIG9wdGlvbmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIHRoZSBtYXhpbXVtXG4gKiAgbnVtYmVyIG9mIHBpdm90ZWQgZmllbGRzIHRvIGdlbmVyYXRlLiBUaGUgcGl2b3RlZCBmaWVsZCBuYW1lcyBhcmUgc29ydGVkIGluXG4gKiAgYXNjZW5kaW5nIG9yZGVyIHByaW9yIHRvIGVuZm9yY2luZyB0aGUgbGltaXQuXG4gKi9cblxuZnVuY3Rpb24gUGl2b3QocGFyYW1zKSB7XG4gIEFnZ3JlZ2F0ZS5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5QaXZvdC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdQaXZvdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAndmFsdWUnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ3ZhbHVlcyc6IFZhbGlkQWdncmVnYXRlT3BzLFxuICAgICdkZWZhdWx0JzogJ3N1bSdcbiAgfSwge1xuICAgICduYW1lJzogJ2xpbWl0JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAna2V5JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfV1cbn07XG5pbmhlcml0cyhQaXZvdCwgQWdncmVnYXRlLCB7XG4gIF90cmFuc2Zvcm06IEFnZ3JlZ2F0ZS5wcm90b3R5cGUudHJhbnNmb3JtLFxuXG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0oYWdncmVnYXRlUGFyYW1zKF8sIHB1bHNlKSwgcHVsc2UpO1xuICB9XG5cbn0pOyAvLyBTaG9laG9ybiBhIHBpdm90IHRyYW5zZm9ybSBpbnRvIGFuIGFnZ3JlZ2F0ZSB0cmFuc2Zvcm0hXG4vLyBGaXJzdCBjb2xsZWN0IGFsbCB1bmlxdWUgcGl2b3QgZmllbGQgdmFsdWVzLlxuLy8gVGhlbiBnZW5lcmF0ZSBhZ2dyZWdhdGUgZmllbGRzIGZvciBlYWNoIG91dHB1dCBwaXZvdCBmaWVsZC5cblxuZnVuY3Rpb24gYWdncmVnYXRlUGFyYW1zKF8sIHB1bHNlKSB7XG4gIGNvbnN0IGtleSA9IF8uZmllbGQsXG4gICAgICAgIHZhbHVlID0gXy52YWx1ZSxcbiAgICAgICAgb3AgPSAoXy5vcCA9PT0gJ2NvdW50JyA/ICdfX2NvdW50X18nIDogXy5vcCkgfHwgJ3N1bScsXG4gICAgICAgIGZpZWxkcyA9IGFjY2Vzc29yRmllbGRzKGtleSkuY29uY2F0KGFjY2Vzc29yRmllbGRzKHZhbHVlKSksXG4gICAgICAgIGtleXMgPSBwaXZvdEtleXMoa2V5LCBfLmxpbWl0IHx8IDAsIHB1bHNlKTsgLy8gaWYgZGF0YSBzdHJlYW0gY29udGVudCBjaGFuZ2VzLCBwaXZvdCBmaWVsZHMgbWF5IGNoYW5nZVxuICAvLyBmbGFnIHBhcmFtZXRlciBtb2RpZmljYXRpb24gdG8gZW5zdXJlIHJlLWluaXRpYWxpemF0aW9uXG5cbiAgaWYgKHB1bHNlLmNoYW5nZWQoKSkgXy5zZXQoJ19fcGl2b3RfXycsIG51bGwsIG51bGwsIHRydWUpO1xuICByZXR1cm4ge1xuICAgIGtleTogXy5rZXksXG4gICAgZ3JvdXBieTogXy5ncm91cGJ5LFxuICAgIG9wczoga2V5cy5tYXAoKCkgPT4gb3ApLFxuICAgIGZpZWxkczoga2V5cy5tYXAoayA9PiBnZXQoaywga2V5LCB2YWx1ZSwgZmllbGRzKSksXG4gICAgYXM6IGtleXMubWFwKGsgPT4gayArICcnKSxcbiAgICBtb2RpZmllZDogXy5tb2RpZmllZC5iaW5kKF8pXG4gIH07XG59IC8vIEdlbmVyYXRlIGFnZ3JlZ2F0ZSBmaWVsZCBhY2Nlc3Nvci5cbi8vIE91dHB1dCBOYU4gZm9yIG5vbi1leGlzdGVudCB2YWx1ZXM7IGFnZ3JlZ2F0b3Igd2lsbCBpZ25vcmUhXG5cblxuZnVuY3Rpb24gZ2V0KGssIGtleSwgdmFsdWUsIGZpZWxkcykge1xuICByZXR1cm4gYWNjZXNzb3IoZCA9PiBrZXkoZCkgPT09IGsgPyB2YWx1ZShkKSA6IE5hTiwgZmllbGRzLCBrICsgJycpO1xufSAvLyBDb2xsZWN0IChhbmQgb3B0aW9uYWxseSBsaW1pdCkgYWxsIHVuaXF1ZSBwaXZvdCB2YWx1ZXMuXG5cblxuZnVuY3Rpb24gcGl2b3RLZXlzKGtleSwgbGltaXQsIHB1bHNlKSB7XG4gIGNvbnN0IG1hcCA9IHt9LFxuICAgICAgICBsaXN0ID0gW107XG4gIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiB7XG4gICAgY29uc3QgayA9IGtleSh0KTtcblxuICAgIGlmICghbWFwW2tdKSB7XG4gICAgICBtYXBba10gPSAxO1xuICAgICAgbGlzdC5wdXNoKGspO1xuICAgIH1cbiAgfSk7XG4gIGxpc3Quc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gbGltaXQgPyBsaXN0LnNsaWNlKDAsIGxpbWl0KSA6IGxpc3Q7XG59XG5cbi8qKlxuICogUGFydGl0aW9ucyBwcmUtZmFjZXRlZCBkYXRhIGludG8gdHVwbGUgc3ViZmxvd3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRGF0YWZsb3csIHN0cmluZyk6IE9wZXJhdG9yfSBwYXJhbXMuc3ViZmxvdyAtIEEgZnVuY3Rpb25cbiAqICAgdGhhdCBnZW5lcmF0ZXMgYSBzdWJmbG93IG9mIG9wZXJhdG9ycyBhbmQgcmV0dXJucyBpdHMgcm9vdCBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogQXJyYXk8b2JqZWN0Pn0gcGFyYW1zLmZpZWxkIC0gVGhlIGZpZWxkXG4gKiAgIGFjY2Vzc29yIGZvciBhbiBhcnJheSBvZiBzdWJmbG93IHR1cGxlIG9iamVjdHMuXG4gKi9cblxuZnVuY3Rpb24gUHJlRmFjZXQocGFyYW1zKSB7XG4gIEZhY2V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFByZUZhY2V0LCBGYWNldCwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBmbG93ID0gXy5zdWJmbG93LFxuICAgICAgICAgIGZpZWxkID0gXy5maWVsZCxcbiAgICAgICAgICBzdWJmbG93ID0gdCA9PiB0aGlzLnN1YmZsb3codHVwbGVpZCh0KSwgZmxvdywgcHVsc2UsIHQpO1xuXG4gICAgaWYgKF8ubW9kaWZpZWQoJ2ZpZWxkJykgfHwgZmllbGQgJiYgcHVsc2UubW9kaWZpZWQoYWNjZXNzb3JGaWVsZHMoZmllbGQpKSkge1xuICAgICAgZXJyb3IoJ1ByZUZhY2V0IGRvZXMgbm90IHN1cHBvcnQgZmllbGQgbW9kaWZpY2F0aW9uLicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFRhcmdldHMoKTsgLy8gcmVzZXQgbGlzdCBvZiBhY3RpdmUgc3ViZmxvd3NcblxuICAgIGlmIChmaWVsZCkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHtcbiAgICAgICAgY29uc3Qgc2YgPSBzdWJmbG93KHQpO1xuICAgICAgICBmaWVsZCh0KS5mb3JFYWNoKF8gPT4gc2YubW9kKF8pKTtcbiAgICAgIH0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgICAgY29uc3Qgc2YgPSBzdWJmbG93KHQpO1xuICAgICAgICBmaWVsZCh0KS5mb3JFYWNoKF8gPT4gc2YuYWRkKGluZ2VzdChfKSkpO1xuICAgICAgfSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgICBjb25zdCBzZiA9IHN1YmZsb3codCk7XG4gICAgICAgIGZpZWxkKHQpLmZvckVhY2goXyA9PiBzZi5yZW0oXykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiBzdWJmbG93KHQpLm1vZCh0KSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gc3ViZmxvdyh0KS5hZGQodCkpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHN1YmZsb3codCkucmVtKHQpKTtcbiAgICB9XG5cbiAgICBpZiAocHVsc2UuY2xlYW4oKSkge1xuICAgICAgcHVsc2UucnVuQWZ0ZXIoKCkgPT4gdGhpcy5jbGVhbigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbi8qKlxuICogUGVyZm9ybXMgYSByZWxhdGlvbmFsIHByb2plY3Rpb24sIGNvcHlpbmcgc2VsZWN0ZWQgZmllbGRzIGZyb20gc291cmNlXG4gKiB0dXBsZXMgdG8gYSBuZXcgc2V0IG9mIGRlcml2ZWQgdHVwbGVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZHMgLSBUaGUgZmllbGRzIHRvIHByb2plY3QsXG4gKiAgIGFzIGFuIGFycmF5IG9mIGZpZWxkIGFjY2Vzc29ycy4gSWYgdW5zcGVjaWZpZWQsIGFsbCBmaWVsZHMgd2lsbCBiZVxuICogICBjb3BpZWQgd2l0aCBuYW1lcyB1bmNoYW5nZWQuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gT3V0cHV0IGZpZWxkIG5hbWVzIGZvciBlYWNoIHByb2plY3RlZFxuICogICBmaWVsZC4gQW55IHVuc3BlY2lmaWVkIGZpZWxkcyB3aWxsIHVzZSB0aGUgZmllbGQgbmFtZSBwcm92aWRlZCBieVxuICogICB0aGUgZmllbGQgYWNjZXNzb3IuXG4gKi9cblxuZnVuY3Rpb24gUHJvamVjdChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblByb2plY3QuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUHJvamVjdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhQcm9qZWN0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpLFxuICAgICAgICAgIGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgICAgIGFzID0gZmllbGROYW1lcyhfLmZpZWxkcywgXy5hcyB8fCBbXSksXG4gICAgICAgICAgZGVyaXZlID0gZmllbGRzID8gKHMsIHQpID0+IHByb2plY3QocywgdCwgZmllbGRzLCBhcykgOiByZWRlcml2ZTtcbiAgICBsZXQgbHV0O1xuXG4gICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgIGx1dCA9IHRoaXMudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bHNlID0gcHVsc2UuYWRkQWxsKCk7XG4gICAgICBsdXQgPSB0aGlzLnZhbHVlID0ge307XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHtcbiAgICAgIGNvbnN0IGlkID0gdHVwbGVpZCh0KTtcbiAgICAgIG91dC5yZW0ucHVzaChsdXRbaWRdKTtcbiAgICAgIGx1dFtpZF0gPSBudWxsO1xuICAgIH0pO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiB7XG4gICAgICBjb25zdCBkdCA9IGRlcml2ZSh0LCBpbmdlc3Qoe30pKTtcbiAgICAgIGx1dFt0dXBsZWlkKHQpXSA9IGR0O1xuICAgICAgb3V0LmFkZC5wdXNoKGR0KTtcbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgb3V0Lm1vZC5wdXNoKGRlcml2ZSh0LCBsdXRbdHVwbGVpZCh0KV0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBwcm9qZWN0KHMsIHQsIGZpZWxkcywgYXMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgdFthc1tpXV0gPSBmaWVsZHNbaV0ocyk7XG4gIH1cblxuICByZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBQcm94eSB0aGUgdmFsdWUgb2YgYW5vdGhlciBvcGVyYXRvciBhcyBhIHB1cmUgc2lnbmFsIHZhbHVlLlxuICogRW5zdXJlcyBubyB0dXBsZXMgYXJlIHByb3BhZ2F0ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7Kn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRvIHByb3h5LCBiZWNvbWVzIHRoZSB2YWx1ZSBvZiB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIFByb3h5KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoUHJveHksIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB0aGlzLnZhbHVlID0gXy52YWx1ZTtcbiAgICByZXR1cm4gXy5tb2RpZmllZCgndmFsdWUnKSA/IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSA6IHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgc2FtcGxlIHF1YW50aWxlIHZhbHVlcyBmcm9tIGFuIGlucHV0IGRhdGEgc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIEFuIGFjY2Vzc29yIGZvciB0aGUgZGF0YSBmaWVsZFxuICogICBvdmVyIHdoaWNoIHRvIGNhbGN1bGF0ZSBxdWFudGlsZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzXG4gKiAgIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMucHJvYnNdIC0gQW4gYXJyYXkgb2YgcHJvYmFiaWxpdGllcyBpblxuICogICB0aGUgcmFuZ2UgKDAsIDEpIGZvciB3aGljaCB0byBjb21wdXRlIHF1YW50aWxlIHZhbHVlcy4gSWYgbm90IHNwZWNpZmllZCxcbiAqICAgdGhlICpzdGVwKiBwYXJhbWV0ZXIgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLnN0ZXA9MC4wMV0gLSBBIHByb2JhYmlsaXR5IHN0ZXAgc2l6ZSBmb3JcbiAqICAgc2FtcGxpbmcgcXVhbnRpbGUgdmFsdWVzLiBBbGwgdmFsdWVzIGZyb20gb25lLWhhbGYgdGhlIHN0ZXAgc2l6ZSB1cCB0b1xuICogICAxIChleGNsdXNpdmUpIHdpbGwgYmUgc2FtcGxlZC4gVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIGlmIHRoZVxuICogICAqcXVhbnRpbGVzKiBwYXJhbWV0ZXIgaXMgbm90IHByb3ZpZGVkLlxuICovXG5cbmZ1bmN0aW9uIFF1YW50aWxlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuUXVhbnRpbGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUXVhbnRpbGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3Byb2JzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXAnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwLjAxXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdkZWZhdWx0JzogWydwcm9iJywgJ3ZhbHVlJ11cbiAgfV1cbn07XG5jb25zdCBFUFNJTE9OID0gMWUtMTQ7XG5pbmhlcml0cyhRdWFudGlsZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgWydwcm9iJywgJ3ZhbHVlJ107XG5cbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpICYmICFwdWxzZS5jaGFuZ2VkKCkpIHtcbiAgICAgIG91dC5zb3VyY2UgPSB0aGlzLnZhbHVlO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgICAgICBncm91cHMgPSBwYXJ0aXRpb24kMShzb3VyY2UsIF8uZ3JvdXBieSwgXy5maWVsZCksXG4gICAgICAgICAgbmFtZXMgPSAoXy5ncm91cGJ5IHx8IFtdKS5tYXAoYWNjZXNzb3JOYW1lKSxcbiAgICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgICBzdGVwID0gXy5zdGVwIHx8IDAuMDEsXG4gICAgICAgICAgcCA9IF8ucHJvYnMgfHwgcmFuZ2Uoc3RlcCAvIDIsIDEgLSBFUFNJTE9OLCBzdGVwKSxcbiAgICAgICAgICBuID0gcC5sZW5ndGg7XG4gICAgZ3JvdXBzLmZvckVhY2goZyA9PiB7XG4gICAgICBjb25zdCBxID0gcXVhbnRpbGVzKGcsIHApO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB0ID0ge307XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRbbmFtZXNbaV1dID0gZy5kaW1zW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgdFthc1swXV0gPSBwW2ldO1xuICAgICAgICB0W2FzWzFdXSA9IHFbaV07XG4gICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuYWRkID0gb3V0LnNvdXJjZSA9IHZhbHVlcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFJlbGF5cyBhIGRhdGEgc3RyZWFtIGJldHdlZW4gZGF0YSBwcm9jZXNzaW5nIHBpcGVsaW5lcy5cbiAqIElmIHRoZSBkZXJpdmUgcGFyYW1ldGVyIGlzIHNldCwgdGhpcyB0cmFuc2Zvcm0gd2lsbCBjcmVhdGUgZGVyaXZlZFxuICogY29waWVzIG9mIG9ic2VydmVkIHR1cGxlcy4gVGhpcyBwcm92aWRlcyBkZXJpdmVkIGRhdGEgc3RyZWFtcyBpbiB3aGljaFxuICogbW9kaWZpY2F0aW9ucyB0byB0aGUgdHVwbGVzIGRvIG5vdCBwb2xsdXRlIGFuIHVwc3RyZWFtIGRhdGEgc291cmNlLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuZGVyaXZlPWZhbHNlXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmXG4gKiAgIHRoZSB0cmFuc2Zvcm0gc2hvdWxkIG1ha2UgZGVyaXZlZCBjb3BpZXMgb2YgaW5jb21pbmcgdHVwbGVzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gUmVsYXkocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhSZWxheSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGxldCBvdXQsIGx1dDtcblxuICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICBsdXQgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBwdWxzZSA9IHB1bHNlLmFkZEFsbCgpO1xuICAgICAgbHV0ID0gdGhpcy52YWx1ZSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChfLmRlcml2ZSkge1xuICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpO1xuICAgICAgICBvdXQucmVtLnB1c2gobHV0W2lkXSk7XG4gICAgICAgIGx1dFtpZF0gPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgICBjb25zdCBkdCA9IGRlcml2ZSh0KTtcbiAgICAgICAgbHV0W3R1cGxlaWQodCldID0gZHQ7XG4gICAgICAgIG91dC5hZGQucHVzaChkdCk7XG4gICAgICB9KTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiB7XG4gICAgICAgIGNvbnN0IGR0ID0gbHV0W3R1cGxlaWQodCldO1xuXG4gICAgICAgIGZvciAoY29uc3QgayBpbiB0KSB7XG4gICAgICAgICAgZHRba10gPSB0W2tdOyAvLyBkb3duIHN0cmVhbSB3cml0ZXMgbWF5IG92ZXJ3cml0ZSByZS1kZXJpdmVkIHR1cGxlc1xuICAgICAgICAgIC8vIGNvbnNlcnZhdGl2ZWx5IG1hcmsgYWxsIHNvdXJjZSBmaWVsZHMgYXMgbW9kaWZpZWRcblxuICAgICAgICAgIG91dC5tb2RpZmllcyhrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5tb2QucHVzaChkdCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFNhbXBsZXMgdHVwbGVzIHBhc3NpbmcgdGhyb3VnaCB0aGlzIG9wZXJhdG9yLlxuICogVXNlcyByZXNlcnZvaXIgc2FtcGxpbmcgdG8gbWFpbnRhaW4gYSByZXByZXNlbnRhdGl2ZSBzYW1wbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnNpemU9MTAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2FtcGxlcy5cbiAqL1xuXG5mdW5jdGlvbiBTYW1wbGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xuICB0aGlzLmNvdW50ID0gMDtcbn1cblNhbXBsZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdTYW1wbGUnLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDEwMDBcbiAgfV1cbn07XG5pbmhlcml0cyhTYW1wbGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksXG4gICAgICAgICAgbW9kID0gXy5tb2RpZmllZCgnc2l6ZScpLFxuICAgICAgICAgIG51bSA9IF8uc2l6ZSxcbiAgICAgICAgICBtYXAgPSB0aGlzLnZhbHVlLnJlZHVjZSgobSwgdCkgPT4gKG1bdHVwbGVpZCh0KV0gPSAxLCBtKSwge30pO1xuXG4gICAgbGV0IHJlcyA9IHRoaXMudmFsdWUsXG4gICAgICAgIGNudCA9IHRoaXMuY291bnQsXG4gICAgICAgIGNhcCA9IDA7IC8vIHNhbXBsZSByZXNlcnZvaXIgdXBkYXRlIGZ1bmN0aW9uXG5cbiAgICBmdW5jdGlvbiB1cGRhdGUodCkge1xuICAgICAgbGV0IHAsIGlkeDtcblxuICAgICAgaWYgKHJlcy5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgcmVzLnB1c2godCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHggPSB+figoY250ICsgMSkgKiByYW5kb20oKSk7XG5cbiAgICAgICAgaWYgKGlkeCA8IHJlcy5sZW5ndGggJiYgaWR4ID49IGNhcCkge1xuICAgICAgICAgIHAgPSByZXNbaWR4XTtcbiAgICAgICAgICBpZiAobWFwW3R1cGxlaWQocCldKSBvdXQucmVtLnB1c2gocCk7IC8vIGV2aWN0aW9uXG5cbiAgICAgICAgICByZXNbaWR4XSA9IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgKytjbnQ7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLnJlbS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpbmQgYWxsIHR1cGxlcyB0aGF0IHNob3VsZCBiZSByZW1vdmVkLCBhZGQgdG8gb3V0cHV0XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCk7XG5cbiAgICAgICAgaWYgKG1hcFtpZF0pIHtcbiAgICAgICAgICBtYXBbaWRdID0gLTE7XG4gICAgICAgICAgb3V0LnJlbS5wdXNoKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLS1jbnQ7XG4gICAgICB9KTsgLy8gZmlsdGVyIHJlbW92ZWQgdHVwbGVzIG91dCBvZiB0aGUgc2FtcGxlIHJlc2Vydm9pclxuXG4gICAgICByZXMgPSByZXMuZmlsdGVyKHQgPT4gbWFwW3R1cGxlaWQodCldICE9PSAtMSk7XG4gICAgfVxuXG4gICAgaWYgKChwdWxzZS5yZW0ubGVuZ3RoIHx8IG1vZCkgJiYgcmVzLmxlbmd0aCA8IG51bSAmJiBwdWxzZS5zb3VyY2UpIHtcbiAgICAgIC8vIHJlcGxlbmlzaCBzYW1wbGUgaWYgYmFja2luZyBkYXRhIHNvdXJjZSBpcyBhdmFpbGFibGVcbiAgICAgIGNhcCA9IGNudCA9IHJlcy5sZW5ndGg7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgICAgICAvLyB1cGRhdGUsIGJ1dCBza2lwIHByZXZpb3VzbHkgc2FtcGxlZCB0dXBsZXNcbiAgICAgICAgaWYgKCFtYXBbdHVwbGVpZCh0KV0pIHVwZGF0ZSh0KTtcbiAgICAgIH0pO1xuICAgICAgY2FwID0gLTE7XG4gICAgfVxuXG4gICAgaWYgKG1vZCAmJiByZXMubGVuZ3RoID4gbnVtKSB7XG4gICAgICBjb25zdCBuID0gcmVzLmxlbmd0aCAtIG51bTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbWFwW3R1cGxlaWQocmVzW2ldKV0gPSAtMTtcbiAgICAgICAgb3V0LnJlbS5wdXNoKHJlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJlcyA9IHJlcy5zbGljZShuKTtcbiAgICB9XG5cbiAgICBpZiAocHVsc2UubW9kLmxlbmd0aCkge1xuICAgICAgLy8gcHJvcGFnYXRlIG1vZGlmaWVkIHR1cGxlcyBpbiB0aGUgc2FtcGxlIHJlc2Vydm9pclxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHtcbiAgICAgICAgaWYgKG1hcFt0dXBsZWlkKHQpXSkgb3V0Lm1vZC5wdXNoKHQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLmFkZC5sZW5ndGgpIHtcbiAgICAgIC8vIHVwZGF0ZSBzYW1wbGUgcmVzZXJ2b2lyXG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHVwZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLmFkZC5sZW5ndGggfHwgY2FwIDwgMCkge1xuICAgICAgLy8gb3V0cHV0IG5ld2x5IGFkZGVkIHR1cGxlc1xuICAgICAgb3V0LmFkZCA9IHJlcy5maWx0ZXIodCA9PiAhbWFwW3R1cGxlaWQodCldKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvdW50ID0gY250O1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gcmVzO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGRhdGEgdHVwbGVzIGZvciBhIHNwZWNpZmllZCBzZXF1ZW5jZSByYW5nZSBvZiBudW1iZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gVGhlIGZpcnN0IG51bWJlciBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0b3AgLSBUaGUgbGFzdCBudW1iZXIgKGV4Y2x1c2l2ZSkgaW4gdGhlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuc3RlcD0xXSAtIFRoZSBzdGVwIHNpemUgYmV0d2VlbiBudW1iZXJzIGluIHRoZSBzZXF1ZW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBTZXF1ZW5jZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblNlcXVlbmNlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1NlcXVlbmNlJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlLFxuICAgICdjaGFuZ2VzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzdGFydCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdG9wJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXAnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdkYXRhJ1xuICB9XVxufTtcbmluaGVyaXRzKFNlcXVlbmNlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSkgcmV0dXJuO1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLm1hdGVyaWFsaXplKCkuZm9yayhwdWxzZS5NT0QpLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCAnZGF0YSc7XG4gICAgb3V0LnJlbSA9IHRoaXMudmFsdWUgPyBwdWxzZS5yZW0uY29uY2F0KHRoaXMudmFsdWUpIDogcHVsc2UucmVtO1xuICAgIHRoaXMudmFsdWUgPSByYW5nZShfLnN0YXJ0LCBfLnN0b3AsIF8uc3RlcCB8fCAxKS5tYXAodiA9PiB7XG4gICAgICBjb25zdCB0ID0ge307XG4gICAgICB0W2FzXSA9IHY7XG4gICAgICByZXR1cm4gaW5nZXN0KHQpO1xuICAgIH0pO1xuICAgIG91dC5hZGQgPSBwdWxzZS5hZGQuY29uY2F0KHRoaXMudmFsdWUpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbi8qKlxuICogUHJvcGFnYXRlcyBhIG5ldyBwdWxzZSB3aXRob3V0IGFueSB0dXBsZXMgc28gbG9uZyBhcyB0aGUgaW5wdXRcbiAqIHB1bHNlIGNvbnRhaW5zIHNvbWUgYWRkZWQsIHJlbW92ZWQgb3IgbW9kaWZpZWQgdHVwbGVzLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gU2lldmUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG4gIHRoaXMubW9kaWZpZWQodHJ1ZSk7IC8vIGFsd2F5cyB0cmVhdCBhcyBtb2RpZmllZFxufVxuaW5oZXJpdHMoU2lldmUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB0aGlzLnZhbHVlID0gcHVsc2Uuc291cmNlO1xuICAgIHJldHVybiBwdWxzZS5jaGFuZ2VkKCkgPyBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUykgOiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gIH1cblxufSk7XG5cbi8qKlxuICogRGlzY3JldGl6ZSBkYXRlcyB0byBzcGVjaWZpYyB0aW1lIHVuaXRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSBkYXRhIGZpZWxkIGNvbnRhaW5pbmcgZGF0ZS90aW1lIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBUaW1lVW5pdChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmNvbnN0IE9VVFBVVCA9IFsndW5pdDAnLCAndW5pdDEnXTtcblRpbWVVbml0LkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1RpbWVVbml0JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdpbnRlcnZhbCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd1bml0cycsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ3ZhbHVlcyc6IFRJTUVfVU5JVFMsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDFcbiAgfSwge1xuICAgICduYW1lJzogJ21heGJpbnMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiA0MFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdkYXRlJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0aW1lem9uZScsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAnbG9jYWwnLFxuICAgICd2YWx1ZXMnOiBbJ2xvY2FsJywgJ3V0YyddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogT1VUUFVUXG4gIH1dXG59O1xuaW5oZXJpdHMoVGltZVVuaXQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBmaWVsZCA9IF8uZmllbGQsXG4gICAgICAgICAgYmFuZCA9IF8uaW50ZXJ2YWwgIT09IGZhbHNlLFxuICAgICAgICAgIHV0YyA9IF8udGltZXpvbmUgPT09ICd1dGMnLFxuICAgICAgICAgIGZsb29yID0gdGhpcy5fZmxvb3IoXywgcHVsc2UpLFxuICAgICAgICAgIG9mZnNldCA9ICh1dGMgPyB1dGNJbnRlcnZhbCA6IHRpbWVJbnRlcnZhbCkoZmxvb3IudW5pdCkub2Zmc2V0LFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBPVVRQVVQsXG4gICAgICAgICAgdTAgPSBhc1swXSxcbiAgICAgICAgICB1MSA9IGFzWzFdLFxuICAgICAgICAgIHN0ZXAgPSBmbG9vci5zdGVwO1xuXG4gICAgbGV0IG1pbiA9IGZsb29yLnN0YXJ0IHx8IEluZmluaXR5LFxuICAgICAgICBtYXggPSBmbG9vci5zdG9wIHx8IC1JbmZpbml0eSxcbiAgICAgICAgZmxhZyA9IHB1bHNlLkFERDtcblxuICAgIGlmIChfLm1vZGlmaWVkKCkgfHwgcHVsc2UubW9kaWZpZWQoYWNjZXNzb3JGaWVsZHMoZmllbGQpKSkge1xuICAgICAgcHVsc2UgPSBwdWxzZS5yZWZsb3codHJ1ZSk7XG4gICAgICBmbGFnID0gcHVsc2UuU09VUkNFO1xuICAgICAgbWluID0gSW5maW5pdHk7XG4gICAgICBtYXggPSAtSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQoZmxhZywgdCA9PiB7XG4gICAgICBjb25zdCB2ID0gZmllbGQodCk7XG4gICAgICBsZXQgYSwgYjtcblxuICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICB0W3UwXSA9IG51bGw7XG4gICAgICAgIGlmIChiYW5kKSB0W3UxXSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0W3UwXSA9IGEgPSBiID0gZmxvb3Iodik7XG4gICAgICAgIGlmIChiYW5kKSB0W3UxXSA9IGIgPSBvZmZzZXQoYSwgc3RlcCk7XG4gICAgICAgIGlmIChhIDwgbWluKSBtaW4gPSBhO1xuICAgICAgICBpZiAoYiA+IG1heCkgbWF4ID0gYjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmbG9vci5zdGFydCA9IG1pbjtcbiAgICBmbG9vci5zdG9wID0gbWF4O1xuICAgIHJldHVybiBwdWxzZS5tb2RpZmllcyhiYW5kID8gYXMgOiB1MCk7XG4gIH0sXG5cbiAgX2Zsb29yKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgdXRjID0gXy50aW1lem9uZSA9PT0gJ3V0Yyc7IC8vIGdldCBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB7XG4gICAgICB1bml0cyxcbiAgICAgIHN0ZXBcbiAgICB9ID0gXy51bml0cyA/IHtcbiAgICAgIHVuaXRzOiBfLnVuaXRzLFxuICAgICAgc3RlcDogXy5zdGVwIHx8IDFcbiAgICB9IDogdGltZUJpbih7XG4gICAgICBleHRlbnQ6IF8uZXh0ZW50IHx8IGV4dGVudChwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSwgXy5maWVsZCksXG4gICAgICBtYXhiaW5zOiBfLm1heGJpbnNcbiAgICB9KTsgLy8gY2hlY2sgLyBzdGFuZGFyZGl6ZSB0aW1lIHVuaXRzXG5cbiAgICBjb25zdCB0dW5pdHMgPSB0aW1lVW5pdHModW5pdHMpLFxuICAgICAgICAgIHByZXYgPSB0aGlzLnZhbHVlIHx8IHt9LFxuICAgICAgICAgIGZsb29yID0gKHV0YyA/IHV0Y0Zsb29yIDogdGltZUZsb29yKSh0dW5pdHMsIHN0ZXApO1xuICAgIGZsb29yLnVuaXQgPSBwZWVrKHR1bml0cyk7XG4gICAgZmxvb3IudW5pdHMgPSB0dW5pdHM7XG4gICAgZmxvb3Iuc3RlcCA9IHN0ZXA7XG4gICAgZmxvb3Iuc3RhcnQgPSBwcmV2LnN0YXJ0O1xuICAgIGZsb29yLnN0b3AgPSBwcmV2LnN0b3A7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPSBmbG9vcjtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBBbiBpbmRleCB0aGF0IG1hcHMgZnJvbSB1bmlxdWUsIHN0cmluZy1jb2VyY2VkLCBmaWVsZCB2YWx1ZXMgdG8gdHVwbGVzLlxuICogQXNzdW1lcyB0aGF0IHRoZSBmaWVsZCBzZXJ2ZXMgYXMgYSB1bmlxdWUga2V5IHdpdGggbm8gZHVwbGljYXRlIHZhbHVlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgZmllbGQgYWNjZXNzb3IgdG8gaW5kZXguXG4gKi9cblxuZnVuY3Rpb24gVHVwbGVJbmRleChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgZmFzdG1hcCgpLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoVHVwbGVJbmRleCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGRmID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICAgICAgZmllbGQgPSBfLmZpZWxkLFxuICAgICAgICAgIGluZGV4ID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBzZXQgPSB0ID0+IGluZGV4LnNldChmaWVsZCh0KSwgdCk7XG5cbiAgICBsZXQgbW9kID0gdHJ1ZTtcblxuICAgIGlmIChfLm1vZGlmaWVkKCdmaWVsZCcpIHx8IHB1bHNlLm1vZGlmaWVkKGZpZWxkLmZpZWxkcykpIHtcbiAgICAgIGluZGV4LmNsZWFyKCk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHNldCk7XG4gICAgfSBlbHNlIGlmIChwdWxzZS5jaGFuZ2VkKCkpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiBpbmRleC5kZWxldGUoZmllbGQodCkpKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5tb2RpZmllZChtb2QpO1xuICAgIGlmIChpbmRleC5lbXB0eSA+IGRmLmNsZWFuVGhyZXNob2xkKSBkZi5ydW5BZnRlcihpbmRleC5jbGVhbik7XG4gICAgcmV0dXJuIHB1bHNlLmZvcmsoKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBFeHRyYWN0cyBhbiBhcnJheSBvZiB2YWx1ZXMuIEFzc3VtZXMgdGhlIHNvdXJjZSBkYXRhIGhhcyBhbHJlYWR5IGJlZW5cbiAqIHJlZHVjZWQgYXMgbmVlZGVkIChlLmcuLCBieSBhbiB1cHN0cmVhbSBBZ2dyZWdhdGUgdHJhbnNmb3JtKS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgZG9tYWluIGZpZWxkIHRvIGV4dHJhY3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEFuIG9wdGlvbmFsXG4gKiAgIGNvbXBhcmF0b3IgZnVuY3Rpb24gZm9yIHNvcnRpbmcgdGhlIHZhbHVlcy4gVGhlIGNvbXBhcmF0b3Igd2lsbCBiZVxuICogICBhcHBsaWVkIHRvIGJhY2tpbmcgdHVwbGVzIHByaW9yIHRvIHZhbHVlIGV4dHJhY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gVmFsdWVzKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoVmFsdWVzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgcnVuID0gIXRoaXMudmFsdWUgfHwgXy5tb2RpZmllZCgnZmllbGQnKSB8fCBfLm1vZGlmaWVkKCdzb3J0JykgfHwgcHVsc2UuY2hhbmdlZCgpIHx8IF8uc29ydCAmJiBwdWxzZS5tb2RpZmllZChfLnNvcnQuZmllbGRzKTtcblxuICAgIGlmIChydW4pIHtcbiAgICAgIHRoaXMudmFsdWUgPSAoXy5zb3J0ID8gcHVsc2Uuc291cmNlLnNsaWNlKCkuc29ydChzdGFibGVDb21wYXJlKF8uc29ydCkpIDogcHVsc2Uuc291cmNlKS5tYXAoXy5maWVsZCk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBXaW5kb3dPcChvcCwgZmllbGQsIHBhcmFtLCBhcykge1xuICBjb25zdCBmbiA9IFdpbmRvd09wc1tvcF0oZmllbGQsIHBhcmFtKTtcbiAgcmV0dXJuIHtcbiAgICBpbml0OiBmbi5pbml0IHx8IHplcm8sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAodywgdCkge1xuICAgICAgdFthc10gPSBmbi5uZXh0KHcpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IFdpbmRvd09wcyA9IHtcbiAgcm93X251bWJlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IHcuaW5kZXggKyAxXG4gICAgfTtcbiAgfSxcbiAgcmFuazogZnVuY3Rpb24gKCkge1xuICAgIGxldCByYW5rO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiAoKSA9PiByYW5rID0gMSxcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCBpID0gdy5pbmRleCxcbiAgICAgICAgICAgICAgZGF0YSA9IHcuZGF0YTtcbiAgICAgICAgcmV0dXJuIGkgJiYgdy5jb21wYXJlKGRhdGFbaSAtIDFdLCBkYXRhW2ldKSA/IHJhbmsgPSBpICsgMSA6IHJhbms7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZGVuc2VfcmFuazogZnVuY3Rpb24gKCkge1xuICAgIGxldCBkcmFuaztcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogKCkgPT4gZHJhbmsgPSAxLFxuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSB3LmluZGV4LFxuICAgICAgICAgICAgICBkID0gdy5kYXRhO1xuICAgICAgICByZXR1cm4gaSAmJiB3LmNvbXBhcmUoZFtpIC0gMV0sIGRbaV0pID8gKytkcmFuayA6IGRyYW5rO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBlcmNlbnRfcmFuazogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHJhbmsgPSBXaW5kb3dPcHMucmFuaygpLFxuICAgICAgICAgIG5leHQgPSByYW5rLm5leHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6IHJhbmsuaW5pdCxcbiAgICAgIG5leHQ6IHcgPT4gKG5leHQodykgLSAxKSAvICh3LmRhdGEubGVuZ3RoIC0gMSlcbiAgICB9O1xuICB9LFxuICBjdW1lX2Rpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgY3VtZTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogKCkgPT4gY3VtZSA9IDAsXG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgZCA9IHcuZGF0YSxcbiAgICAgICAgICAgICAgYyA9IHcuY29tcGFyZTtcbiAgICAgICAgbGV0IGkgPSB3LmluZGV4O1xuXG4gICAgICAgIGlmIChjdW1lIDwgaSkge1xuICAgICAgICAgIHdoaWxlIChpICsgMSA8IGQubGVuZ3RoICYmICFjKGRbaV0sIGRbaSArIDFdKSkgKytpO1xuXG4gICAgICAgICAgY3VtZSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKDEgKyBjdW1lKSAvIGQubGVuZ3RoO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIG50aWxlOiBmdW5jdGlvbiAoZmllbGQsIG51bSkge1xuICAgIG51bSA9ICtudW07XG4gICAgaWYgKCEobnVtID4gMCkpIGVycm9yKCdudGlsZSBudW0gbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4nKTtcbiAgICBjb25zdCBjdW1lID0gV2luZG93T3BzLmN1bWVfZGlzdCgpLFxuICAgICAgICAgIG5leHQgPSBjdW1lLm5leHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6IGN1bWUuaW5pdCxcbiAgICAgIG5leHQ6IHcgPT4gTWF0aC5jZWlsKG51bSAqIG5leHQodykpXG4gICAgfTtcbiAgfSxcbiAgbGFnOiBmdW5jdGlvbiAoZmllbGQsIG9mZnNldCkge1xuICAgIG9mZnNldCA9ICtvZmZzZXQgfHwgMTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSB3LmluZGV4IC0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gaSA+PSAwID8gZmllbGQody5kYXRhW2ldKSA6IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgbGVhZDogZnVuY3Rpb24gKGZpZWxkLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSArb2Zmc2V0IHx8IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCBpID0gdy5pbmRleCArIG9mZnNldCxcbiAgICAgICAgICAgICAgZCA9IHcuZGF0YTtcbiAgICAgICAgcmV0dXJuIGkgPCBkLmxlbmd0aCA/IGZpZWxkKGRbaV0pIDogbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBmaXJzdF92YWx1ZTogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IHcgPT4gZmllbGQody5kYXRhW3cuaTBdKVxuICAgIH07XG4gIH0sXG4gIGxhc3RfdmFsdWU6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IGZpZWxkKHcuZGF0YVt3LmkxIC0gMV0pXG4gICAgfTtcbiAgfSxcbiAgbnRoX3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQsIG50aCkge1xuICAgIG50aCA9ICtudGg7XG4gICAgaWYgKCEobnRoID4gMCkpIGVycm9yKCdudGhfdmFsdWUgbnRoIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCBpID0gdy5pMCArIChudGggLSAxKTtcbiAgICAgICAgcmV0dXJuIGkgPCB3LmkxID8gZmllbGQody5kYXRhW2ldKSA6IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcHJldl92YWx1ZTogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgbGV0IHByZXY7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6ICgpID0+IHByZXYgPSBudWxsLFxuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBmaWVsZCh3LmRhdGFbdy5pbmRleF0pO1xuICAgICAgICByZXR1cm4gdiAhPSBudWxsID8gcHJldiA9IHYgOiBwcmV2O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIG5leHRfdmFsdWU6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGxldCB2LCBpO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiAoKSA9PiAodiA9IG51bGwsIGkgPSAtMSksXG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgZCA9IHcuZGF0YTtcbiAgICAgICAgcmV0dXJuIHcuaW5kZXggPD0gaSA/IHYgOiAoaSA9IGZpbmQoZmllbGQsIGQsIHcuaW5kZXgpKSA8IDAgPyAoaSA9IGQubGVuZ3RoLCB2ID0gbnVsbCkgOiB2ID0gZmllbGQoZFtpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZChmaWVsZCwgZGF0YSwgaW5kZXgpIHtcbiAgZm9yIChsZXQgbiA9IGRhdGEubGVuZ3RoOyBpbmRleCA8IG47ICsraW5kZXgpIHtcbiAgICBjb25zdCB2ID0gZmllbGQoZGF0YVtpbmRleF0pO1xuICAgIGlmICh2ICE9IG51bGwpIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuY29uc3QgVmFsaWRXaW5kb3dPcHMgPSBPYmplY3Qua2V5cyhXaW5kb3dPcHMpO1xuXG5mdW5jdGlvbiBXaW5kb3dTdGF0ZShfKSB7XG4gIGNvbnN0IG9wcyA9IGFycmF5KF8ub3BzKSxcbiAgICAgICAgZmllbGRzID0gYXJyYXkoXy5maWVsZHMpLFxuICAgICAgICBwYXJhbXMgPSBhcnJheShfLnBhcmFtcyksXG4gICAgICAgIGFzID0gYXJyYXkoXy5hcyksXG4gICAgICAgIG91dHB1dHMgPSB0aGlzLm91dHB1dHMgPSBbXSxcbiAgICAgICAgd2luZG93cyA9IHRoaXMud2luZG93cyA9IFtdLFxuICAgICAgICBpbnB1dHMgPSB7fSxcbiAgICAgICAgbWFwID0ge30sXG4gICAgICAgIGNvdW50cyA9IFtdLFxuICAgICAgICBtZWFzdXJlcyA9IFtdO1xuICBsZXQgY291bnRPbmx5ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiB2aXNpdElucHV0cyhmKSB7XG4gICAgYXJyYXkoYWNjZXNzb3JGaWVsZHMoZikpLmZvckVhY2goXyA9PiBpbnB1dHNbX10gPSAxKTtcbiAgfVxuXG4gIHZpc2l0SW5wdXRzKF8uc29ydCk7XG4gIG9wcy5mb3JFYWNoKChvcCwgaSkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2ldLFxuICAgICAgICAgIG1uYW1lID0gYWNjZXNzb3JOYW1lKGZpZWxkKSxcbiAgICAgICAgICBuYW1lID0gbWVhc3VyZU5hbWUob3AsIG1uYW1lLCBhc1tpXSk7XG4gICAgdmlzaXRJbnB1dHMoZmllbGQpO1xuICAgIG91dHB1dHMucHVzaChuYW1lKTsgLy8gV2luZG93IG9wZXJhdGlvblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5KFdpbmRvd09wcywgb3ApKSB7XG4gICAgICB3aW5kb3dzLnB1c2goV2luZG93T3Aob3AsIGZpZWxkc1tpXSwgcGFyYW1zW2ldLCBuYW1lKSk7XG4gICAgfSAvLyBBZ2dyZWdhdGUgb3BlcmF0aW9uXG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChmaWVsZCA9PSBudWxsICYmIG9wICE9PSAnY291bnQnKSB7XG4gICAgICAgICAgZXJyb3IoJ051bGwgYWdncmVnYXRlIGZpZWxkIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcCA9PT0gJ2NvdW50Jykge1xuICAgICAgICAgIGNvdW50cy5wdXNoKG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50T25seSA9IGZhbHNlO1xuICAgICAgICBsZXQgbSA9IG1hcFttbmFtZV07XG5cbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgbSA9IG1hcFttbmFtZV0gPSBbXTtcbiAgICAgICAgICBtLmZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgbWVhc3VyZXMucHVzaChtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG0ucHVzaChjcmVhdGVNZWFzdXJlKG9wLCBuYW1lKSk7XG4gICAgICB9XG4gIH0pO1xuXG4gIGlmIChjb3VudHMubGVuZ3RoIHx8IG1lYXN1cmVzLmxlbmd0aCkge1xuICAgIHRoaXMuY2VsbCA9IGNlbGwobWVhc3VyZXMsIGNvdW50cywgY291bnRPbmx5KTtcbiAgfVxuXG4gIHRoaXMuaW5wdXRzID0gT2JqZWN0LmtleXMoaW5wdXRzKTtcbn1cbmNvbnN0IHByb3RvdHlwZSA9IFdpbmRvd1N0YXRlLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMud2luZG93cy5mb3JFYWNoKF8gPT4gXy5pbml0KCkpO1xuICBpZiAodGhpcy5jZWxsKSB0aGlzLmNlbGwuaW5pdCgpO1xufTtcblxucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh3LCB0KSB7XG4gIGNvbnN0IGNlbGwgPSB0aGlzLmNlbGwsXG4gICAgICAgIHdpbmQgPSB0aGlzLndpbmRvd3MsXG4gICAgICAgIGRhdGEgPSB3LmRhdGEsXG4gICAgICAgIG0gPSB3aW5kICYmIHdpbmQubGVuZ3RoO1xuICBsZXQgajtcblxuICBpZiAoY2VsbCkge1xuICAgIGZvciAoaiA9IHcucDA7IGogPCB3LmkwOyArK2opIGNlbGwucmVtKGRhdGFbal0pO1xuXG4gICAgZm9yIChqID0gdy5wMTsgaiA8IHcuaTE7ICsraikgY2VsbC5hZGQoZGF0YVtqXSk7XG5cbiAgICBjZWxsLnNldCh0KTtcbiAgfVxuXG4gIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHdpbmRbal0udXBkYXRlKHcsIHQpO1xufTtcblxuZnVuY3Rpb24gY2VsbChtZWFzdXJlcywgY291bnRzLCBjb3VudE9ubHkpIHtcbiAgbWVhc3VyZXMgPSBtZWFzdXJlcy5tYXAobSA9PiBjb21waWxlTWVhc3VyZXMobSwgbS5maWVsZCkpO1xuICBjb25zdCBjZWxsID0ge1xuICAgIG51bTogMCxcbiAgICBhZ2c6IG51bGwsXG4gICAgc3RvcmU6IGZhbHNlLFxuICAgIGNvdW50OiBjb3VudHNcbiAgfTtcblxuICBpZiAoIWNvdW50T25seSkge1xuICAgIHZhciBuID0gbWVhc3VyZXMubGVuZ3RoLFxuICAgICAgICBhID0gY2VsbC5hZ2cgPSBBcnJheShuKSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IG47ICsraSkgYVtpXSA9IG5ldyBtZWFzdXJlc1tpXShjZWxsKTtcbiAgfVxuXG4gIGlmIChjZWxsLnN0b3JlKSB7XG4gICAgdmFyIHN0b3JlID0gY2VsbC5kYXRhID0gbmV3IFR1cGxlU3RvcmUoKTtcbiAgfVxuXG4gIGNlbGwuYWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICBjZWxsLm51bSArPSAxO1xuICAgIGlmIChjb3VudE9ubHkpIHJldHVybjtcbiAgICBpZiAoc3RvcmUpIHN0b3JlLmFkZCh0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBhW2ldLmFkZChhW2ldLmdldCh0KSwgdCk7XG4gICAgfVxuICB9O1xuXG4gIGNlbGwucmVtID0gZnVuY3Rpb24gKHQpIHtcbiAgICBjZWxsLm51bSAtPSAxO1xuICAgIGlmIChjb3VudE9ubHkpIHJldHVybjtcbiAgICBpZiAoc3RvcmUpIHN0b3JlLnJlbSh0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBhW2ldLnJlbShhW2ldLmdldCh0KSwgdCk7XG4gICAgfVxuICB9O1xuXG4gIGNlbGwuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBsZXQgaSwgbjsgLy8gY29uc29saWRhdGUgc3RvcmVkIHZhbHVlc1xuXG4gICAgaWYgKHN0b3JlKSBzdG9yZS52YWx1ZXMoKTsgLy8gdXBkYXRlIHR1cGxlIHByb3BlcnRpZXNcblxuICAgIGZvciAoaSA9IDAsIG4gPSBjb3VudHMubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2NvdW50c1tpXV0gPSBjZWxsLm51bTtcblxuICAgIGlmICghY291bnRPbmx5KSBmb3IgKGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyArK2kpIGFbaV0uc2V0KHQpO1xuICB9O1xuXG4gIGNlbGwuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjZWxsLm51bSA9IDA7XG4gICAgaWYgKHN0b3JlKSBzdG9yZS5yZXNldCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIGFbaV0uaW5pdCgpO1xuICB9O1xuXG4gIHJldHVybiBjZWxsO1xufVxuXG4vKipcbiAqIFBlcmZvcm0gd2luZG93IGNhbGN1bGF0aW9ucyBhbmQgd3JpdGUgcmVzdWx0cyB0byB0aGUgaW5wdXQgc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEEgY29tcGFyYXRvciBmdW5jdGlvbiBmb3Igc29ydGluZyB0dXBsZXMgd2l0aGluIGEgd2luZG93LlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29ycyBieSB3aGljaCB0byBwYXJ0aXRpb24gdHVwbGVzIGludG8gc2VwYXJhdGUgd2luZG93cy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcGFyYW1zLm9wcyAtIEFuIGFycmF5IG9mIHN0cmluZ3MgaW5kaWNhdGluZyB3aW5kb3cgb3BlcmF0aW9ucyB0byBwZXJmb3JtLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5maWVsZHNdIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzXG4gKiAgIGZvciBkYXRhIGZpZWxkcyB0byB1c2UgYXMgaW5wdXRzIHRvIHdpbmRvdyBvcGVyYXRpb25zLlxuICogQHBhcmFtIHtBcnJheTwqPn0gW3BhcmFtcy5wYXJhbXNdIC0gQW4gYXJyYXkgb2YgcGFyYW1ldGVyIHZhbHVlcyBmb3Igd2luZG93IG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gQW4gYXJyYXkgb2Ygb3V0cHV0IGZpZWxkIG5hbWVzIGZvciB3aW5kb3cgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5mcmFtZV0gLSBXaW5kb3cgZnJhbWUgZGVmaW5pdGlvbiBhcyB0d28tZWxlbWVudCBhcnJheS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5pZ25vcmVQZWVycz1mYWxzZV0gLSBJZiB0cnVlLCBiYXNlIHdpbmRvdyBmcmFtZSBib3VuZGFyaWVzIG9uIHJvd1xuICogICBudW1iZXIgYWxvbmUsIGlnbm9yaW5nIHBlZXJzIHdpdGggaWRlbnRpY2FsIHNvcnQgdmFsdWVzLiBJZiBmYWxzZSAoZGVmYXVsdCksXG4gKiAgIHRoZSB3aW5kb3cgYm91bmRhcmllcyB3aWxsIGJlIGFkanVzdGVkIHRvIGluY2x1ZGUgcGVlciB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gV2luZG93KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7fSwgcGFyYW1zKTtcbiAgdGhpcy5fbWxlbiA9IDA7XG4gIHRoaXMuX21vZHMgPSBbXTtcbn1cbldpbmRvdy5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdXaW5kb3cnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ29wcycsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAndmFsdWVzJzogVmFsaWRXaW5kb3dPcHMuY29uY2F0KFZhbGlkQWdncmVnYXRlT3BzKVxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFyYW1zJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ZyYW1lJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogW251bGwsIDBdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdpZ25vcmVQZWVycycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9XVxufTtcbmluaGVyaXRzKFdpbmRvdywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHRoaXMuc3RhbXAgPSBwdWxzZS5zdGFtcDtcblxuICAgIGNvbnN0IG1vZCA9IF8ubW9kaWZpZWQoKSxcbiAgICAgICAgICBjbXAgPSBzdGFibGVDb21wYXJlKF8uc29ydCksXG4gICAgICAgICAga2V5ID0gZ3JvdXBrZXkoXy5ncm91cGJ5KSxcbiAgICAgICAgICBncm91cCA9IHQgPT4gdGhpcy5ncm91cChrZXkodCkpOyAvLyBpbml0aWFsaXplIHdpbmRvdyBzdGF0ZVxuXG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKCFzdGF0ZSB8fCBtb2QpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZSA9IG5ldyBXaW5kb3dTdGF0ZShfKTtcbiAgICB9IC8vIHBhcnRpdGlvbiBpbnB1dCB0dXBsZXNcblxuXG4gICAgaWYgKG1vZCB8fCBwdWxzZS5tb2RpZmllZChzdGF0ZS5pbnB1dHMpKSB7XG4gICAgICB0aGlzLnZhbHVlID0ge307XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4gZ3JvdXAodCkuYWRkKHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IGdyb3VwKHQpLnJlbW92ZSh0KSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gZ3JvdXAodCkuYWRkKHQpKTtcbiAgICB9IC8vIHBlcmZvcm0gd2luZG93IGNhbGN1bGF0aW9ucyBmb3IgZWFjaCBtb2RpZmllZCBwYXJ0aXRpb25cblxuXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9tbGVuOyBpIDwgbjsgKytpKSB7XG4gICAgICBwcm9jZXNzUGFydGl0aW9uKHRoaXMuX21vZHNbaV0sIHN0YXRlLCBjbXAsIF8pO1xuICAgIH1cblxuICAgIHRoaXMuX21sZW4gPSAwO1xuICAgIHRoaXMuX21vZHMgPSBbXTsgLy8gVE9ETyBkb24ndCByZWZsb3cgZXZlcnl0aGluZz9cblxuICAgIHJldHVybiBwdWxzZS5yZWZsb3cobW9kKS5tb2RpZmllcyhzdGF0ZS5vdXRwdXRzKTtcbiAgfSxcblxuICBncm91cChrZXkpIHtcbiAgICBsZXQgZ3JvdXAgPSB0aGlzLnZhbHVlW2tleV07XG5cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICBncm91cCA9IHRoaXMudmFsdWVba2V5XSA9IFNvcnRlZExpc3QodHVwbGVpZCk7XG4gICAgICBncm91cC5zdGFtcCA9IC0xO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zdGFtcCA8IHRoaXMuc3RhbXApIHtcbiAgICAgIGdyb3VwLnN0YW1wID0gdGhpcy5zdGFtcDtcbiAgICAgIHRoaXMuX21vZHNbdGhpcy5fbWxlbisrXSA9IGdyb3VwO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cDtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gcHJvY2Vzc1BhcnRpdGlvbihsaXN0LCBzdGF0ZSwgY21wLCBfKSB7XG4gIGNvbnN0IHNvcnQgPSBfLnNvcnQsXG4gICAgICAgIHJhbmdlID0gc29ydCAmJiAhXy5pZ25vcmVQZWVycyxcbiAgICAgICAgZnJhbWUgPSBfLmZyYW1lIHx8IFtudWxsLCAwXSxcbiAgICAgICAgZGF0YSA9IGxpc3QuZGF0YShjbXApLFxuICAgICAgICAvLyB1c2UgY21wIGZvciBzdGFibGUgc29ydFxuICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGIgPSByYW5nZSA/IGJpc2VjdG9yKHNvcnQpIDogbnVsbCxcbiAgICAgICAgdyA9IHtcbiAgICBpMDogMCxcbiAgICBpMTogMCxcbiAgICBwMDogMCxcbiAgICBwMTogMCxcbiAgICBpbmRleDogMCxcbiAgICBkYXRhOiBkYXRhLFxuICAgIGNvbXBhcmU6IHNvcnQgfHwgY29uc3RhbnQoLTEpXG4gIH07XG4gIHN0YXRlLmluaXQoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHNldFdpbmRvdyh3LCBmcmFtZSwgaSwgbik7XG4gICAgaWYgKHJhbmdlKSBhZGp1c3RSYW5nZSh3LCBiKTtcbiAgICBzdGF0ZS51cGRhdGUodywgZGF0YVtpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0V2luZG93KHcsIGYsIGksIG4pIHtcbiAgdy5wMCA9IHcuaTA7XG4gIHcucDEgPSB3LmkxO1xuICB3LmkwID0gZlswXSA9PSBudWxsID8gMCA6IE1hdGgubWF4KDAsIGkgLSBNYXRoLmFicyhmWzBdKSk7XG4gIHcuaTEgPSBmWzFdID09IG51bGwgPyBuIDogTWF0aC5taW4obiwgaSArIE1hdGguYWJzKGZbMV0pICsgMSk7XG4gIHcuaW5kZXggPSBpO1xufSAvLyBpZiBmcmFtZSB0eXBlIGlzICdyYW5nZScsIGFkanVzdCB3aW5kb3cgZm9yIHBlZXIgdmFsdWVzXG5cblxuZnVuY3Rpb24gYWRqdXN0UmFuZ2UodywgYmlzZWN0KSB7XG4gIGNvbnN0IHIwID0gdy5pMCxcbiAgICAgICAgcjEgPSB3LmkxIC0gMSxcbiAgICAgICAgYyA9IHcuY29tcGFyZSxcbiAgICAgICAgZCA9IHcuZGF0YSxcbiAgICAgICAgbiA9IGQubGVuZ3RoIC0gMTtcbiAgaWYgKHIwID4gMCAmJiAhYyhkW3IwXSwgZFtyMCAtIDFdKSkgdy5pMCA9IGJpc2VjdC5sZWZ0KGQsIGRbcjBdKTtcbiAgaWYgKHIxIDwgbiAmJiAhYyhkW3IxXSwgZFtyMSArIDFdKSkgdy5pMSA9IGJpc2VjdC5yaWdodChkLCBkW3IxXSk7XG59XG5cbmV4cG9ydCB7IEFnZ3JlZ2F0ZSBhcyBhZ2dyZWdhdGUsIEJpbiBhcyBiaW4sIENvbGxlY3QgYXMgY29sbGVjdCwgQ29tcGFyZSBhcyBjb21wYXJlLCBDb3VudFBhdHRlcm4gYXMgY291bnRwYXR0ZXJuLCBDcm9zcyBhcyBjcm9zcywgRGVuc2l0eSBhcyBkZW5zaXR5LCBEb3RCaW4gYXMgZG90YmluLCBFeHByZXNzaW9uIGFzIGV4cHJlc3Npb24sIEV4dGVudCBhcyBleHRlbnQsIEZhY2V0IGFzIGZhY2V0LCBGaWVsZCBhcyBmaWVsZCwgRmlsdGVyIGFzIGZpbHRlciwgRmxhdHRlbiBhcyBmbGF0dGVuLCBGb2xkIGFzIGZvbGQsIEZvcm11bGEgYXMgZm9ybXVsYSwgR2VuZXJhdGUgYXMgZ2VuZXJhdGUsIEltcHV0ZSBhcyBpbXB1dGUsIEpvaW5BZ2dyZWdhdGUgYXMgam9pbmFnZ3JlZ2F0ZSwgS0RFIGFzIGtkZSwgS2V5IGFzIGtleSwgTG9hZCBhcyBsb2FkLCBMb29rdXAgYXMgbG9va3VwLCBNdWx0aUV4dGVudCBhcyBtdWx0aWV4dGVudCwgTXVsdGlWYWx1ZXMgYXMgbXVsdGl2YWx1ZXMsIFBhcmFtcyBhcyBwYXJhbXMsIFBpdm90IGFzIHBpdm90LCBQcmVGYWNldCBhcyBwcmVmYWNldCwgUHJvamVjdCBhcyBwcm9qZWN0LCBQcm94eSBhcyBwcm94eSwgUXVhbnRpbGUgYXMgcXVhbnRpbGUsIFJlbGF5IGFzIHJlbGF5LCBTYW1wbGUgYXMgc2FtcGxlLCBTZXF1ZW5jZSBhcyBzZXF1ZW5jZSwgU2lldmUgYXMgc2lldmUsIFN1YmZsb3cgYXMgc3ViZmxvdywgVGltZVVuaXQgYXMgdGltZXVuaXQsIFR1cGxlSW5kZXggYXMgdHVwbGVpbmRleCwgVmFsdWVzIGFzIHZhbHVlcywgV2luZG93IGFzIHdpbmRvdyB9O1xuIiwiaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBNYXJrcywgYm91bmRDbGlwLCBHcm91cEl0ZW0sIEl0ZW0sIEJvdW5kcywgbXVsdGlMaW5lT2Zmc2V0LCBib3VuZFN0cm9rZSB9IGZyb20gJ3ZlZ2Etc2NlbmVncmFwaCc7XG5pbXBvcnQgeyBpbmhlcml0cywgcGVlaywgaXNPYmplY3QgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5jb25zdCBUb3AgPSAndG9wJztcbmNvbnN0IExlZnQgPSAnbGVmdCc7XG5jb25zdCBSaWdodCA9ICdyaWdodCc7XG5jb25zdCBCb3R0b20gPSAnYm90dG9tJztcbmNvbnN0IFRvcExlZnQgPSAndG9wLWxlZnQnO1xuY29uc3QgVG9wUmlnaHQgPSAndG9wLXJpZ2h0JztcbmNvbnN0IEJvdHRvbUxlZnQgPSAnYm90dG9tLWxlZnQnO1xuY29uc3QgQm90dG9tUmlnaHQgPSAnYm90dG9tLXJpZ2h0JztcbmNvbnN0IFN0YXJ0ID0gJ3N0YXJ0JztcbmNvbnN0IE1pZGRsZSA9ICdtaWRkbGUnO1xuY29uc3QgRW5kID0gJ2VuZCc7XG5jb25zdCBYID0gJ3gnO1xuY29uc3QgWSA9ICd5JztcbmNvbnN0IEdyb3VwID0gJ2dyb3VwJztcbmNvbnN0IEF4aXNSb2xlID0gJ2F4aXMnO1xuY29uc3QgVGl0bGVSb2xlID0gJ3RpdGxlJztcbmNvbnN0IEZyYW1lUm9sZSA9ICdmcmFtZSc7XG5jb25zdCBTY29wZVJvbGUgPSAnc2NvcGUnO1xuY29uc3QgTGVnZW5kUm9sZSA9ICdsZWdlbmQnO1xuY29uc3QgUm93SGVhZGVyID0gJ3Jvdy1oZWFkZXInO1xuY29uc3QgUm93Rm9vdGVyID0gJ3Jvdy1mb290ZXInO1xuY29uc3QgUm93VGl0bGUgPSAncm93LXRpdGxlJztcbmNvbnN0IENvbEhlYWRlciA9ICdjb2x1bW4taGVhZGVyJztcbmNvbnN0IENvbEZvb3RlciA9ICdjb2x1bW4tZm9vdGVyJztcbmNvbnN0IENvbFRpdGxlID0gJ2NvbHVtbi10aXRsZSc7XG5jb25zdCBQYWRkaW5nID0gJ3BhZGRpbmcnO1xuY29uc3QgU3ltYm9scyA9ICdzeW1ib2wnO1xuY29uc3QgRml0ID0gJ2ZpdCc7XG5jb25zdCBGaXRYID0gJ2ZpdC14JztcbmNvbnN0IEZpdFkgPSAnZml0LXknO1xuY29uc3QgUGFkID0gJ3BhZCc7XG5jb25zdCBOb25lID0gJ25vbmUnO1xuY29uc3QgQWxsID0gJ2FsbCc7XG5jb25zdCBFYWNoID0gJ2VhY2gnO1xuY29uc3QgRmx1c2ggPSAnZmx1c2gnO1xuY29uc3QgQ29sdW1uID0gJ2NvbHVtbic7XG5jb25zdCBSb3cgPSAncm93JztcblxuLyoqXG4gKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94ZXMgZm9yIHNjZW5lZ3JhcGggaXRlbXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubWFyayAtIFRoZSBzY2VuZWdyYXBoIG1hcmsgaW5zdGFuY2UgdG8gYm91bmQuXG4gKi9cblxuZnVuY3Rpb24gQm91bmQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhCb3VuZCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IHZpZXcgPSBwdWxzZS5kYXRhZmxvdyxcbiAgICAgICAgICBtYXJrID0gXy5tYXJrLFxuICAgICAgICAgIHR5cGUgPSBtYXJrLm1hcmt0eXBlLFxuICAgICAgICAgIGVudHJ5ID0gTWFya3NbdHlwZV0sXG4gICAgICAgICAgYm91bmQgPSBlbnRyeS5ib3VuZDtcbiAgICBsZXQgbWFya0JvdW5kcyA9IG1hcmsuYm91bmRzLFxuICAgICAgICByZWJvdW5kO1xuXG4gICAgaWYgKGVudHJ5Lm5lc3RlZCkge1xuICAgICAgLy8gbXVsdGktaXRlbSBtYXJrcyBoYXZlIGEgc2luZ2xlIGJvdW5kcyBpbnN0YW5jZVxuICAgICAgaWYgKG1hcmsuaXRlbXMubGVuZ3RoKSB2aWV3LmRpcnR5KG1hcmsuaXRlbXNbMF0pO1xuICAgICAgbWFya0JvdW5kcyA9IGJvdW5kSXRlbShtYXJrLCBib3VuZCk7XG4gICAgICBtYXJrLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGl0ZW0uYm91bmRzLmNsZWFyKCkudW5pb24obWFya0JvdW5kcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdyb3VwIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgLy8gb3BlcmF0b3IgcGFyYW1ldGVycyBtb2RpZmllZCAtPiByZS1ib3VuZCBhbGwgaXRlbXNcbiAgICAgIC8vIHVwZGF0ZXMgZ3JvdXAgYm91bmRzIGluIHJlc3BvbnNlIHRvIG1vZGlmaWVkIGdyb3VwIGNvbnRlbnRcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgaXRlbSA9PiB2aWV3LmRpcnR5KGl0ZW0pKTtcbiAgICAgIG1hcmtCb3VuZHMuY2xlYXIoKTtcbiAgICAgIG1hcmsuaXRlbXMuZm9yRWFjaChpdGVtID0+IG1hcmtCb3VuZHMudW5pb24oYm91bmRJdGVtKGl0ZW0sIGJvdW5kKSkpOyAvLyBmb3JjZSByZWZsb3cgZm9yIGF4ZXMvbGVnZW5kcy90aXRsZXMgdG8gcHJvcGFnYXRlIGFueSBsYXlvdXQgY2hhbmdlc1xuXG4gICAgICBzd2l0Y2ggKG1hcmsucm9sZSkge1xuICAgICAgICBjYXNlIEF4aXNSb2xlOlxuICAgICAgICBjYXNlIExlZ2VuZFJvbGU6XG4gICAgICAgIGNhc2UgVGl0bGVSb2xlOlxuICAgICAgICAgIHB1bHNlLnJlZmxvdygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmNyZW1lbnRhbGx5IHVwZGF0ZSBib3VuZHMsIHJlLWJvdW5kIG1hcmsgYXMgbmVlZGVkXG4gICAgICByZWJvdW5kID0gcHVsc2UuY2hhbmdlZChwdWxzZS5SRU0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCBpdGVtID0+IHtcbiAgICAgICAgbWFya0JvdW5kcy51bmlvbihib3VuZEl0ZW0oaXRlbSwgYm91bmQpKTtcbiAgICAgIH0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCBpdGVtID0+IHtcbiAgICAgICAgcmVib3VuZCA9IHJlYm91bmQgfHwgbWFya0JvdW5kcy5hbGlnbnNXaXRoKGl0ZW0uYm91bmRzKTtcbiAgICAgICAgdmlldy5kaXJ0eShpdGVtKTtcbiAgICAgICAgbWFya0JvdW5kcy51bmlvbihib3VuZEl0ZW0oaXRlbSwgYm91bmQpKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVib3VuZCkge1xuICAgICAgICBtYXJrQm91bmRzLmNsZWFyKCk7XG4gICAgICAgIG1hcmsuaXRlbXMuZm9yRWFjaChpdGVtID0+IG1hcmtCb3VuZHMudW5pb24oaXRlbS5ib3VuZHMpKTtcbiAgICAgIH1cbiAgICB9IC8vIGVuc3VyZSBtYXJrIGJvdW5kcyBkbyBub3QgZXhjZWVkIGFueSBjbGlwcGluZyByZWdpb25cblxuXG4gICAgYm91bmRDbGlwKG1hcmspO1xuICAgIHJldHVybiBwdWxzZS5tb2RpZmllcygnYm91bmRzJyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIGJvdW5kSXRlbShpdGVtLCBib3VuZCwgb3B0KSB7XG4gIHJldHVybiBib3VuZChpdGVtLmJvdW5kcy5jbGVhcigpLCBpdGVtLCBvcHQpO1xufVxuXG5jb25zdCBDT1VOVEVSX05BTUUgPSAnOnZlZ2FfaWRlbnRpZmllcjonO1xuLyoqXG4gKiBBZGRzIGEgdW5pcXVlIGlkZW50aWZpZXIgdG8gYWxsIGFkZGVkIHR1cGxlcy5cbiAqIFRoaXMgdHJhbnNmb3JtIGNyZWF0ZXMgYSBuZXcgc2lnbmFsIHRoYXQgc2VydmVzIGFzIGFuIGlkIGNvdW50ZXIuXG4gKiBBcyBhIHJlc3VsdCwgdGhlIGlkIGNvdW50ZXIgaXMgc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHRyYW5zZm9ybSwgZ2VuZXJhdGluZyB1bmlxdWUgaWRzIGFjcm9zcyBtdWx0aXBsZSBkYXRhIHN0cmVhbXMuIEluXG4gKiBhZGRpdGlvbiwgdGhpcyBzaWduYWwgdmFsdWUgY2FuIGJlIGluY2x1ZGVkIGluIGEgc25hcHNob3Qgb2YgdGhlXG4gKiBkYXRhZmxvdyBzdGF0ZSwgZW5hYmxpbmcgY29ycmVjdCByZXN1bXB0aW9uIG9mIGlkIGFsbG9jYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYXMgLSBUaGUgZmllbGQgbmFtZSBmb3IgdGhlIGdlbmVyYXRlZCBpZGVudGlmaWVyLlxuICovXG5cbmZ1bmN0aW9uIElkZW50aWZpZXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIDAsIHBhcmFtcyk7XG59XG5JZGVudGlmaWVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0lkZW50aWZpZXInLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoSWRlbnRpZmllciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGNvdW50ZXIgPSBnZXRDb3VudGVyKHB1bHNlLmRhdGFmbG93KSxcbiAgICAgICAgICBhcyA9IF8uYXM7XG4gICAgbGV0IGlkID0gY291bnRlci52YWx1ZTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gdFthc10gPSB0W2FzXSB8fCArK2lkKTtcbiAgICBjb3VudGVyLnNldCh0aGlzLnZhbHVlID0gaWQpO1xuICAgIHJldHVybiBwdWxzZTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gZ2V0Q291bnRlcih2aWV3KSB7XG4gIHJldHVybiB2aWV3Ll9zaWduYWxzW0NPVU5URVJfTkFNRV0gfHwgKHZpZXcuX3NpZ25hbHNbQ09VTlRFUl9OQU1FXSA9IHZpZXcuYWRkKDApKTtcbn1cblxuLyoqXG4gKiBCaW5kIHNjZW5lZ3JhcGggaXRlbXMgdG8gYSBzY2VuZWdyYXBoIG1hcmsgaW5zdGFuY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubWFya2RlZiAtIFRoZSBtYXJrIGRlZmluaXRpb24gZm9yIGNyZWF0aW5nIHRoZSBtYXJrLlxuICogICBUaGlzIGlzIGFuIG9iamVjdCBvZiBsZWdhbCBzY2VuZWdyYXBoIG1hcmsgcHJvcGVydGllcyB3aGljaCAqbXVzdCogaW5jbHVkZVxuICogICB0aGUgJ21hcmt0eXBlJyBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBNYXJrKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoTWFyaywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGxldCBtYXJrID0gdGhpcy52YWx1ZTsgLy8gYWNxdWlyZSBtYXJrIG9uIGZpcnN0IGludm9jYXRpb24sIGJpbmQgY29udGV4dCBhbmQgZ3JvdXBcblxuICAgIGlmICghbWFyaykge1xuICAgICAgbWFyayA9IHB1bHNlLmRhdGFmbG93LnNjZW5lZ3JhcGgoKS5tYXJrKF8ubWFya2RlZiwgbG9va3VwKF8pLCBfLmluZGV4KTtcbiAgICAgIG1hcmsuZ3JvdXAuY29udGV4dCA9IF8uY29udGV4dDtcbiAgICAgIGlmICghXy5jb250ZXh0Lmdyb3VwKSBfLmNvbnRleHQuZ3JvdXAgPSBtYXJrLmdyb3VwO1xuICAgICAgbWFyay5zb3VyY2UgPSB0aGlzLnNvdXJjZTsgLy8gcG9pbnQgdG8gdXBzdHJlYW0gY29sbGVjdG9yXG5cbiAgICAgIG1hcmsuY2xpcCA9IF8uY2xpcDtcbiAgICAgIG1hcmsuaW50ZXJhY3RpdmUgPSBfLmludGVyYWN0aXZlO1xuICAgICAgdGhpcy52YWx1ZSA9IG1hcms7XG4gICAgfSAvLyBpbml0aWFsaXplIGVudGVyaW5nIGl0ZW1zXG5cblxuICAgIGNvbnN0IEluaXQgPSBtYXJrLm1hcmt0eXBlID09PSBHcm91cCA/IEdyb3VwSXRlbSA6IEl0ZW07XG4gICAgcHVsc2UudmlzaXQocHVsc2UuQURELCBpdGVtID0+IEluaXQuY2FsbChpdGVtLCBtYXJrKSk7IC8vIHVwZGF0ZSBjbGlwcGluZyBhbmQvb3IgaW50ZXJhY3RpdmUgc3RhdHVzXG5cbiAgICBpZiAoXy5tb2RpZmllZCgnY2xpcCcpIHx8IF8ubW9kaWZpZWQoJ2ludGVyYWN0aXZlJykpIHtcbiAgICAgIG1hcmsuY2xpcCA9IF8uY2xpcDtcbiAgICAgIG1hcmsuaW50ZXJhY3RpdmUgPSAhIV8uaW50ZXJhY3RpdmU7XG4gICAgICBtYXJrLnpkaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHNjZW5lZ3JhcGggcmUtZXZhbFxuXG4gICAgICBwdWxzZS5yZWZsb3coKTtcbiAgICB9IC8vIGJpbmQgaXRlbXMgYXJyYXkgdG8gc2NlbmVncmFwaCBtYXJrXG5cblxuICAgIG1hcmsuaXRlbXMgPSBwdWxzZS5zb3VyY2U7XG4gICAgcmV0dXJuIHB1bHNlO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBsb29rdXAoXykge1xuICBjb25zdCBnID0gXy5ncm91cHMsXG4gICAgICAgIHAgPSBfLnBhcmVudDtcbiAgcmV0dXJuIGcgJiYgZy5zaXplID09PSAxID8gZy5nZXQoT2JqZWN0LmtleXMoZy5vYmplY3QpWzBdKSA6IGcgJiYgcCA/IGcubG9va3VwKHApIDogbnVsbDtcbn1cblxuLyoqXG4gKiBBbmFseXplIGl0ZW1zIGZvciBvdmVybGFwLCBjaGFuZ2luZyBvcGFjaXR5IHRvIGhpZGUgaXRlbXMgd2l0aFxuICogb3ZlcmxhcHBpbmcgYm91bmRpbmcgYm94ZXMuIFRoaXMgdHJhbnNmb3JtIHdpbGwgcHJlc2VydmUgYXQgbGVhc3RcbiAqIHR3byBpdGVtcyAoZS5nLiwgZmlyc3QgYW5kIGxhc3QpIGV2ZW4gaWYgb3ZlcmxhcCBwZXJzaXN0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwqKTogbnVtYmVyfSBbcGFyYW1zLnNvcnRdIC0gQSBjb21wYXJhdG9yXG4gKiAgIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGl0ZW1zLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXMubWV0aG9kXSAtIFRoZSBvdmVybGFwIHJlbW92YWwgbWV0aG9kIHRvIGFwcGx5LlxuICogICBPbmUgb2YgJ3Bhcml0eScgKGRlZmF1bHQsIGhpZGUgZXZlcnkgb3RoZXIgaXRlbSB1bnRpbCB0aGVyZSBpcyBub1xuICogICBtb3JlIG92ZXJsYXApIG9yICdncmVlZHknIChzZXF1ZW50aWFsbHkgc2NhbiBhbmQgaGlkZSBhbmQgaXRlbXMgdGhhdFxuICogICBvdmVybGFwIHdpdGggdGhlIGxhc3QgdmlzaWJsZSBpdGVtKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLmJvdW5kU2NhbGVdIC0gQSBzY2FsZSB3aG9zZSByYW5nZSBzaG91bGQgYmUgdXNlZFxuICogICB0byBib3VuZCB0aGUgaXRlbXMuIEl0ZW1zIGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIHRoZSBzY2FsZSByYW5nZVxuICogICB3aWxsIGJlIHRyZWF0ZWQgYXMgb3ZlcmxhcHBpbmcuIElmIG51bGwgb3IgdW5kZWZpbmVkLCBubyBib3VuZHMgY2hlY2tcbiAqICAgd2lsbCBiZSBhcHBsaWVkLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXMuYm91bmRPcmllbnRdIC0gVGhlIG9yaWVudGF0aW9uIG9mIHRoZSBzY2FsZVxuICogICAodG9wLCBib3R0b20sIGxlZnQsIG9yIHJpZ2h0KSB1c2VkIHRvIGJvdW5kIGl0ZW1zLiBUaGlzIHBhcmFtZXRlciBpc1xuICogICBpZ25vcmVkIGlmIGJvdW5kU2NhbGUgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcy5ib3VuZFRvbGVyYW5jZV0gLSBUaGUgdG9sZXJhbmNlIGluIHBpeGVscyBmb3JcbiAqICAgYm91bmQgaW5jbHVzaW9uIHRlc3RpbmcgKGRlZmF1bHQgMSkuIFRoaXMgc3BlY2lmaWVzIGJ5IGhvdyBtYW55IHBpeGVsc1xuICogICBhbiBpdGVtJ3MgYm91bmRzIG1heSBleGNlZWQgdGhlIHNjYWxlIHJhbmdlIGJvdW5kcyBhbmQgbm90IGJlIGN1bGxlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIE92ZXJsYXAocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5jb25zdCBtZXRob2RzID0ge1xuICBwYXJpdHk6IGl0ZW1zID0+IGl0ZW1zLmZpbHRlcigoaXRlbSwgaSkgPT4gaSAlIDIgPyBpdGVtLm9wYWNpdHkgPSAwIDogMSksXG4gIGdyZWVkeTogKGl0ZW1zLCBzZXApID0+IHtcbiAgICBsZXQgYTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChiLCBpKSA9PiAhaSB8fCAhaW50ZXJzZWN0KGEuYm91bmRzLCBiLmJvdW5kcywgc2VwKSA/IChhID0gYiwgMSkgOiBiLm9wYWNpdHkgPSAwKTtcbiAgfVxufTsgLy8gY29tcHV0ZSBib3VuZGluZyBib3ggaW50ZXJzZWN0aW9uXG4vLyBpbmNsdWRpbmcgcGFkZGluZyBwaXhlbHMgb2Ygc2VwYXJhdGlvblxuXG5jb25zdCBpbnRlcnNlY3QgPSAoYSwgYiwgc2VwKSA9PiBzZXAgPiBNYXRoLm1heChiLngxIC0gYS54MiwgYS54MSAtIGIueDIsIGIueTEgLSBhLnkyLCBhLnkxIC0gYi55Mik7XG5cbmNvbnN0IGhhc092ZXJsYXAgPSAoaXRlbXMsIHBhZCkgPT4ge1xuICBmb3IgKHZhciBpID0gMSwgbiA9IGl0ZW1zLmxlbmd0aCwgYSA9IGl0ZW1zWzBdLmJvdW5kcywgYjsgaSA8IG47IGEgPSBiLCArK2kpIHtcbiAgICBpZiAoaW50ZXJzZWN0KGEsIGIgPSBpdGVtc1tpXS5ib3VuZHMsIHBhZCkpIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5jb25zdCBoYXNCb3VuZHMgPSBpdGVtID0+IHtcbiAgY29uc3QgYiA9IGl0ZW0uYm91bmRzO1xuICByZXR1cm4gYi53aWR0aCgpID4gMSAmJiBiLmhlaWdodCgpID4gMTtcbn07XG5cbmNvbnN0IGJvdW5kVGVzdCA9IChzY2FsZSwgb3JpZW50LCB0b2xlcmFuY2UpID0+IHtcbiAgdmFyIHJhbmdlID0gc2NhbGUucmFuZ2UoKSxcbiAgICAgIGIgPSBuZXcgQm91bmRzKCk7XG5cbiAgaWYgKG9yaWVudCA9PT0gVG9wIHx8IG9yaWVudCA9PT0gQm90dG9tKSB7XG4gICAgYi5zZXQocmFuZ2VbMF0sIC1JbmZpbml0eSwgcmFuZ2VbMV0sICtJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgYi5zZXQoLUluZmluaXR5LCByYW5nZVswXSwgK0luZmluaXR5LCByYW5nZVsxXSk7XG4gIH1cblxuICBiLmV4cGFuZCh0b2xlcmFuY2UgfHwgMSk7XG4gIHJldHVybiBpdGVtID0+IGIuZW5jbG9zZXMoaXRlbS5ib3VuZHMpO1xufTsgLy8gcmVzZXQgYWxsIGl0ZW1zIHRvIGJlIGZ1bGx5IG9wYXF1ZVxuXG5cbmNvbnN0IHJlc2V0ID0gc291cmNlID0+IHtcbiAgc291cmNlLmZvckVhY2goaXRlbSA9PiBpdGVtLm9wYWNpdHkgPSAxKTtcbiAgcmV0dXJuIHNvdXJjZTtcbn07IC8vIGFkZCBhbGwgdHVwbGVzIHRvIG1vZCwgZm9yayBwdWxzZSBpZiBwYXJhbWV0ZXJzIHdlcmUgbW9kaWZpZWRcbi8vIGZvcmsgcHJldmVudHMgY3Jvc3Mtc3RyZWFtIHR1cGxlIHBvbGx1dGlvbiAoZS5nLiwgcHVsc2UgZnJvbSBzY2FsZSlcblxuXG5jb25zdCByZWZsb3cgPSAocHVsc2UsIF8pID0+IHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKCdvcGFjaXR5Jyk7XG5cbmluaGVyaXRzKE92ZXJsYXAsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCByZWR1Y2UgPSBtZXRob2RzW18ubWV0aG9kXSB8fCBtZXRob2RzLnBhcml0eSxcbiAgICAgICAgICBzZXAgPSBfLnNlcGFyYXRpb24gfHwgMDtcbiAgICBsZXQgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICB0ZXN0O1xuICAgIGlmICghc291cmNlIHx8ICFzb3VyY2UubGVuZ3RoKSByZXR1cm47XG5cbiAgICBpZiAoIV8ubWV0aG9kKSB7XG4gICAgICAvLyBlYXJseSBleGl0IGlmIG1ldGhvZCBpcyBmYWxzeVxuICAgICAgaWYgKF8ubW9kaWZpZWQoJ21ldGhvZCcpKSB7XG4gICAgICAgIHJlc2V0KHNvdXJjZSk7XG4gICAgICAgIHB1bHNlID0gcmVmbG93KHB1bHNlLCBfKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB1bHNlO1xuICAgIH0gLy8gc2tpcCBsYWJlbHMgd2l0aCBubyBjb250ZW50XG5cblxuICAgIHNvdXJjZSA9IHNvdXJjZS5maWx0ZXIoaGFzQm91bmRzKTsgLy8gZWFybHkgZXhpdCwgbm90aGluZyB0byBkb1xuXG4gICAgaWYgKCFzb3VyY2UubGVuZ3RoKSByZXR1cm47XG5cbiAgICBpZiAoXy5zb3J0KSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2Uuc2xpY2UoKS5zb3J0KF8uc29ydCk7XG4gICAgfVxuXG4gICAgaXRlbXMgPSByZXNldChzb3VyY2UpO1xuICAgIHB1bHNlID0gcmVmbG93KHB1bHNlLCBfKTtcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPj0gMyAmJiBoYXNPdmVybGFwKGl0ZW1zLCBzZXApKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGl0ZW1zID0gcmVkdWNlKGl0ZW1zLCBzZXApO1xuICAgICAgfSB3aGlsZSAoaXRlbXMubGVuZ3RoID49IDMgJiYgaGFzT3ZlcmxhcChpdGVtcywgc2VwKSk7XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAzICYmICFwZWVrKHNvdXJjZSkub3BhY2l0eSkge1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSkgcGVlayhpdGVtcykub3BhY2l0eSA9IDA7XG4gICAgICAgIHBlZWsoc291cmNlKS5vcGFjaXR5ID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXy5ib3VuZFNjYWxlICYmIF8uYm91bmRUb2xlcmFuY2UgPj0gMCkge1xuICAgICAgdGVzdCA9IGJvdW5kVGVzdChfLmJvdW5kU2NhbGUsIF8uYm91bmRPcmllbnQsICtfLmJvdW5kVG9sZXJhbmNlKTtcbiAgICAgIHNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAoIXRlc3QoaXRlbSkpIGl0ZW0ub3BhY2l0eSA9IDA7XG4gICAgICB9KTtcbiAgICB9IC8vIHJlLWNhbGN1bGF0ZSBtYXJrIGJvdW5kc1xuXG5cbiAgICBjb25zdCBib3VuZHMgPSBpdGVtc1swXS5tYXJrLmJvdW5kcy5jbGVhcigpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKGl0ZW0ub3BhY2l0eSkgYm91bmRzLnVuaW9uKGl0ZW0uYm91bmRzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbi8qKlxuICogUXVldWUgbW9kaWZpZWQgc2NlbmVncmFwaCBpdGVtcyBmb3IgcmVuZGVyaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoUmVuZGVyLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgdmlldyA9IHB1bHNlLmRhdGFmbG93O1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFMTCwgaXRlbSA9PiB2aWV3LmRpcnR5KGl0ZW0pKTsgLy8gc2V0IHotaW5kZXggZGlydHkgZmxhZyBhcyBuZWVkZWRcblxuICAgIGlmIChwdWxzZS5maWVsZHMgJiYgcHVsc2UuZmllbGRzWyd6aW5kZXgnXSkge1xuICAgICAgY29uc3QgaXRlbSA9IHB1bHNlLnNvdXJjZSAmJiBwdWxzZS5zb3VyY2VbMF07XG4gICAgICBpZiAoaXRlbSkgaXRlbS5tYXJrLnpkaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5jb25zdCB0ZW1wQm91bmRzID0gbmV3IEJvdW5kcygpO1xuZnVuY3Rpb24gc2V0KGl0ZW0sIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gaXRlbVtwcm9wZXJ0eV0gPT09IHZhbHVlID8gMCA6IChpdGVtW3Byb3BlcnR5XSA9IHZhbHVlLCAxKTtcbn1cblxuZnVuY3Rpb24gaXNZQXhpcyhtYXJrKSB7XG4gIHZhciBvcmllbnQgPSBtYXJrLml0ZW1zWzBdLm9yaWVudDtcbiAgcmV0dXJuIG9yaWVudCA9PT0gTGVmdCB8fCBvcmllbnQgPT09IFJpZ2h0O1xufVxuXG5mdW5jdGlvbiBheGlzSW5kaWNlcyhkYXR1bSkge1xuICBsZXQgaW5kZXggPSArZGF0dW0uZ3JpZDtcbiAgcmV0dXJuIFtkYXR1bS50aWNrcyA/IGluZGV4KysgOiAtMSwgLy8gdGlja3MgaW5kZXhcbiAgZGF0dW0ubGFiZWxzID8gaW5kZXgrKyA6IC0xLCAvLyBsYWJlbHMgaW5kZXhcbiAgaW5kZXggKyArZGF0dW0uZG9tYWluIC8vIHRpdGxlIGluZGV4XG4gIF07XG59XG5cbmZ1bmN0aW9uIGF4aXNMYXlvdXQodmlldywgYXhpcywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaXRlbSA9IGF4aXMuaXRlbXNbMF0sXG4gICAgICBkYXR1bSA9IGl0ZW0uZGF0dW0sXG4gICAgICBkZWx0YSA9IGl0ZW0udHJhbnNsYXRlICE9IG51bGwgPyBpdGVtLnRyYW5zbGF0ZSA6IDAuNSxcbiAgICAgIG9yaWVudCA9IGl0ZW0ub3JpZW50LFxuICAgICAgaW5kaWNlcyA9IGF4aXNJbmRpY2VzKGRhdHVtKSxcbiAgICAgIHJhbmdlID0gaXRlbS5yYW5nZSxcbiAgICAgIG9mZnNldCA9IGl0ZW0ub2Zmc2V0LFxuICAgICAgcG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uLFxuICAgICAgbWluRXh0ZW50ID0gaXRlbS5taW5FeHRlbnQsXG4gICAgICBtYXhFeHRlbnQgPSBpdGVtLm1heEV4dGVudCxcbiAgICAgIHRpdGxlID0gZGF0dW0udGl0bGUgJiYgaXRlbS5pdGVtc1tpbmRpY2VzWzJdXS5pdGVtc1swXSxcbiAgICAgIHRpdGxlUGFkZGluZyA9IGl0ZW0udGl0bGVQYWRkaW5nLFxuICAgICAgYm91bmRzID0gaXRlbS5ib3VuZHMsXG4gICAgICBkbCA9IHRpdGxlICYmIG11bHRpTGluZU9mZnNldCh0aXRsZSksXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgaSxcbiAgICAgIHM7XG4gIHRlbXBCb3VuZHMuY2xlYXIoKS51bmlvbihib3VuZHMpO1xuICBib3VuZHMuY2xlYXIoKTtcbiAgaWYgKChpID0gaW5kaWNlc1swXSkgPiAtMSkgYm91bmRzLnVuaW9uKGl0ZW0uaXRlbXNbaV0uYm91bmRzKTtcbiAgaWYgKChpID0gaW5kaWNlc1sxXSkgPiAtMSkgYm91bmRzLnVuaW9uKGl0ZW0uaXRlbXNbaV0uYm91bmRzKTsgLy8gcG9zaXRpb24gYXhpcyBncm91cCBhbmQgdGl0bGVcblxuICBzd2l0Y2ggKG9yaWVudCkge1xuICAgIGNhc2UgVG9wOlxuICAgICAgeCA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICB5ID0gLW9mZnNldDtcbiAgICAgIHMgPSBNYXRoLm1heChtaW5FeHRlbnQsIE1hdGgubWluKG1heEV4dGVudCwgLWJvdW5kcy55MSkpO1xuICAgICAgYm91bmRzLmFkZCgwLCAtcykuYWRkKHJhbmdlLCAwKTtcbiAgICAgIGlmICh0aXRsZSkgYXhpc1RpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCBzLCB0aXRsZVBhZGRpbmcsIGRsLCAwLCAtMSwgYm91bmRzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMZWZ0OlxuICAgICAgeCA9IC1vZmZzZXQ7XG4gICAgICB5ID0gcG9zaXRpb24gfHwgMDtcbiAgICAgIHMgPSBNYXRoLm1heChtaW5FeHRlbnQsIE1hdGgubWluKG1heEV4dGVudCwgLWJvdW5kcy54MSkpO1xuICAgICAgYm91bmRzLmFkZCgtcywgMCkuYWRkKDAsIHJhbmdlKTtcbiAgICAgIGlmICh0aXRsZSkgYXhpc1RpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCBzLCB0aXRsZVBhZGRpbmcsIGRsLCAxLCAtMSwgYm91bmRzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSaWdodDpcbiAgICAgIHggPSB3aWR0aCArIG9mZnNldDtcbiAgICAgIHkgPSBwb3NpdGlvbiB8fCAwO1xuICAgICAgcyA9IE1hdGgubWF4KG1pbkV4dGVudCwgTWF0aC5taW4obWF4RXh0ZW50LCBib3VuZHMueDIpKTtcbiAgICAgIGJvdW5kcy5hZGQoMCwgMCkuYWRkKHMsIHJhbmdlKTtcbiAgICAgIGlmICh0aXRsZSkgYXhpc1RpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCBzLCB0aXRsZVBhZGRpbmcsIGRsLCAxLCAxLCBib3VuZHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEJvdHRvbTpcbiAgICAgIHggPSBwb3NpdGlvbiB8fCAwO1xuICAgICAgeSA9IGhlaWdodCArIG9mZnNldDtcbiAgICAgIHMgPSBNYXRoLm1heChtaW5FeHRlbnQsIE1hdGgubWluKG1heEV4dGVudCwgYm91bmRzLnkyKSk7XG4gICAgICBib3VuZHMuYWRkKDAsIDApLmFkZChyYW5nZSwgcyk7XG4gICAgICBpZiAodGl0bGUpIGF4aXNUaXRsZUxheW91dCh2aWV3LCB0aXRsZSwgcywgdGl0bGVQYWRkaW5nLCAwLCAwLCAxLCBib3VuZHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgeCA9IGl0ZW0ueDtcbiAgICAgIHkgPSBpdGVtLnk7XG4gIH0gLy8gdXBkYXRlIGJvdW5kc1xuXG5cbiAgYm91bmRTdHJva2UoYm91bmRzLnRyYW5zbGF0ZSh4LCB5KSwgaXRlbSk7XG5cbiAgaWYgKHNldChpdGVtLCAneCcsIHggKyBkZWx0YSkgfCBzZXQoaXRlbSwgJ3knLCB5ICsgZGVsdGEpKSB7XG4gICAgaXRlbS5ib3VuZHMgPSB0ZW1wQm91bmRzO1xuICAgIHZpZXcuZGlydHkoaXRlbSk7XG4gICAgaXRlbS5ib3VuZHMgPSBib3VuZHM7XG4gICAgdmlldy5kaXJ0eShpdGVtKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtLm1hcmsuYm91bmRzLmNsZWFyKCkudW5pb24oYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gYXhpc1RpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCBvZmZzZXQsIHBhZCwgZGwsIGlzWUF4aXMsIHNpZ24sIGJvdW5kcykge1xuICBjb25zdCBiID0gdGl0bGUuYm91bmRzO1xuXG4gIGlmICh0aXRsZS5hdXRvKSB7XG4gICAgY29uc3QgdiA9IHNpZ24gKiAob2Zmc2V0ICsgZGwgKyBwYWQpO1xuICAgIGxldCBkeCA9IDAsXG4gICAgICAgIGR5ID0gMDtcbiAgICB2aWV3LmRpcnR5KHRpdGxlKTtcbiAgICBpc1lBeGlzID8gZHggPSAodGl0bGUueCB8fCAwKSAtICh0aXRsZS54ID0gdikgOiBkeSA9ICh0aXRsZS55IHx8IDApIC0gKHRpdGxlLnkgPSB2KTtcbiAgICB0aXRsZS5tYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKGIudHJhbnNsYXRlKC1keCwgLWR5KSk7XG4gICAgdmlldy5kaXJ0eSh0aXRsZSk7XG4gIH1cblxuICBib3VuZHMudW5pb24oYik7XG59XG5cbmNvbnN0IG1pbiA9IChhLCBiKSA9PiBNYXRoLmZsb29yKE1hdGgubWluKGEsIGIpKTtcblxuY29uc3QgbWF4ID0gKGEsIGIpID0+IE1hdGguY2VpbChNYXRoLm1heChhLCBiKSk7XG5cbmZ1bmN0aW9uIGdyaWRMYXlvdXRHcm91cHMoZ3JvdXApIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwLml0ZW1zLFxuICAgICAgbiA9IGdyb3Vwcy5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIG1hcmssXG4gICAgICBpdGVtcztcbiAgY29uc3Qgdmlld3MgPSB7XG4gICAgbWFya3M6IFtdLFxuICAgIHJvd2hlYWRlcnM6IFtdLFxuICAgIHJvd2Zvb3RlcnM6IFtdLFxuICAgIGNvbGhlYWRlcnM6IFtdLFxuICAgIGNvbGZvb3RlcnM6IFtdLFxuICAgIHJvd3RpdGxlOiBudWxsLFxuICAgIGNvbHRpdGxlOiBudWxsXG4gIH07IC8vIGxheW91dCBheGVzLCBnYXRoZXIgbGVnZW5kcywgY29sbGVjdCBib3VuZHNcblxuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIG1hcmsgPSBncm91cHNbaV07XG4gICAgaXRlbXMgPSBtYXJrLml0ZW1zO1xuXG4gICAgaWYgKG1hcmsubWFya3R5cGUgPT09IEdyb3VwKSB7XG4gICAgICBzd2l0Y2ggKG1hcmsucm9sZSkge1xuICAgICAgICBjYXNlIEF4aXNSb2xlOlxuICAgICAgICBjYXNlIExlZ2VuZFJvbGU6XG4gICAgICAgIGNhc2UgVGl0bGVSb2xlOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUm93SGVhZGVyOlxuICAgICAgICAgIHZpZXdzLnJvd2hlYWRlcnMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSb3dGb290ZXI6XG4gICAgICAgICAgdmlld3Mucm93Zm9vdGVycy5wdXNoKC4uLml0ZW1zKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENvbEhlYWRlcjpcbiAgICAgICAgICB2aWV3cy5jb2xoZWFkZXJzLnB1c2goLi4uaXRlbXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ29sRm9vdGVyOlxuICAgICAgICAgIHZpZXdzLmNvbGZvb3RlcnMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSb3dUaXRsZTpcbiAgICAgICAgICB2aWV3cy5yb3d0aXRsZSA9IGl0ZW1zWzBdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ29sVGl0bGU6XG4gICAgICAgICAgdmlld3MuY29sdGl0bGUgPSBpdGVtc1swXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZpZXdzLm1hcmtzLnB1c2goLi4uaXRlbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2aWV3cztcbn1cblxuZnVuY3Rpb24gYmJveEZsdXNoKGl0ZW0pIHtcbiAgcmV0dXJuIG5ldyBCb3VuZHMoKS5zZXQoMCwgMCwgaXRlbS53aWR0aCB8fCAwLCBpdGVtLmhlaWdodCB8fCAwKTtcbn1cblxuZnVuY3Rpb24gYmJveEZ1bGwoaXRlbSkge1xuICBjb25zdCBiID0gaXRlbS5ib3VuZHMuY2xvbmUoKTtcbiAgcmV0dXJuIGIuZW1wdHkoKSA/IGIuc2V0KDAsIDAsIDAsIDApIDogYi50cmFuc2xhdGUoLShpdGVtLnggfHwgMCksIC0oaXRlbS55IHx8IDApKTtcbn1cblxuZnVuY3Rpb24gZ2V0KG9wdCwga2V5LCBkKSB7XG4gIGNvbnN0IHYgPSBpc09iamVjdChvcHQpID8gb3B0W2tleV0gOiBvcHQ7XG4gIHJldHVybiB2ICE9IG51bGwgPyB2IDogZCAhPT0gdW5kZWZpbmVkID8gZCA6IDA7XG59XG5cbmZ1bmN0aW9uIG9mZnNldFZhbHVlKHYpIHtcbiAgcmV0dXJuIHYgPCAwID8gTWF0aC5jZWlsKC12KSA6IDA7XG59XG5cbmZ1bmN0aW9uIGdyaWRMYXlvdXQodmlldywgZ3JvdXBzLCBvcHQpIHtcbiAgdmFyIGRpcnR5ID0gIW9wdC5ub2RpcnR5LFxuICAgICAgYmJveCA9IG9wdC5ib3VuZHMgPT09IEZsdXNoID8gYmJveEZsdXNoIDogYmJveEZ1bGwsXG4gICAgICBib3VuZHMgPSB0ZW1wQm91bmRzLnNldCgwLCAwLCAwLCAwKSxcbiAgICAgIGFsaWduQ29sID0gZ2V0KG9wdC5hbGlnbiwgQ29sdW1uKSxcbiAgICAgIGFsaWduUm93ID0gZ2V0KG9wdC5hbGlnbiwgUm93KSxcbiAgICAgIHBhZENvbCA9IGdldChvcHQucGFkZGluZywgQ29sdW1uKSxcbiAgICAgIHBhZFJvdyA9IGdldChvcHQucGFkZGluZywgUm93KSxcbiAgICAgIG5jb2xzID0gb3B0LmNvbHVtbnMgfHwgZ3JvdXBzLmxlbmd0aCxcbiAgICAgIG5yb3dzID0gbmNvbHMgPD0gMCA/IDEgOiBNYXRoLmNlaWwoZ3JvdXBzLmxlbmd0aCAvIG5jb2xzKSxcbiAgICAgIG4gPSBncm91cHMubGVuZ3RoLFxuICAgICAgeE9mZnNldCA9IEFycmF5KG4pLFxuICAgICAgeEV4dGVudCA9IEFycmF5KG5jb2xzKSxcbiAgICAgIHhNYXggPSAwLFxuICAgICAgeU9mZnNldCA9IEFycmF5KG4pLFxuICAgICAgeUV4dGVudCA9IEFycmF5KG5yb3dzKSxcbiAgICAgIHlNYXggPSAwLFxuICAgICAgZHggPSBBcnJheShuKSxcbiAgICAgIGR5ID0gQXJyYXkobiksXG4gICAgICBib3hlcyA9IEFycmF5KG4pLFxuICAgICAgbSxcbiAgICAgIGksXG4gICAgICBjLFxuICAgICAgcixcbiAgICAgIGIsXG4gICAgICBnLFxuICAgICAgcHgsXG4gICAgICBweSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgb2Zmc2V0O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuY29sczsgKytpKSB4RXh0ZW50W2ldID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbnJvd3M7ICsraSkgeUV4dGVudFtpXSA9IDA7IC8vIGRldGVybWluZSBvZmZzZXRzIGZvciBlYWNoIGdyb3VwXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZyA9IGdyb3Vwc1tpXTtcbiAgICBiID0gYm94ZXNbaV0gPSBiYm94KGcpO1xuICAgIGcueCA9IGcueCB8fCAwO1xuICAgIGR4W2ldID0gMDtcbiAgICBnLnkgPSBnLnkgfHwgMDtcbiAgICBkeVtpXSA9IDA7XG4gICAgYyA9IGkgJSBuY29scztcbiAgICByID0gfn4oaSAvIG5jb2xzKTtcbiAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCwgcHggPSBNYXRoLmNlaWwoYi54MikpO1xuICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCBweSA9IE1hdGguY2VpbChiLnkyKSk7XG4gICAgeEV4dGVudFtjXSA9IE1hdGgubWF4KHhFeHRlbnRbY10sIHB4KTtcbiAgICB5RXh0ZW50W3JdID0gTWF0aC5tYXgoeUV4dGVudFtyXSwgcHkpO1xuICAgIHhPZmZzZXRbaV0gPSBwYWRDb2wgKyBvZmZzZXRWYWx1ZShiLngxKTtcbiAgICB5T2Zmc2V0W2ldID0gcGFkUm93ICsgb2Zmc2V0VmFsdWUoYi55MSk7XG4gICAgaWYgKGRpcnR5KSB2aWV3LmRpcnR5KGdyb3Vwc1tpXSk7XG4gIH0gLy8gc2V0IGluaXRpYWwgYWxpZ25tZW50IG9mZnNldHNcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoaSAlIG5jb2xzID09PSAwKSB4T2Zmc2V0W2ldID0gMDtcbiAgICBpZiAoaSA8IG5jb2xzKSB5T2Zmc2V0W2ldID0gMDtcbiAgfSAvLyBlbmZvcmNlIGNvbHVtbiBhbGlnbm1lbnQgY29uc3RyYWludHNcblxuXG4gIGlmIChhbGlnbkNvbCA9PT0gRWFjaCkge1xuICAgIGZvciAoYyA9IDE7IGMgPCBuY29sczsgKytjKSB7XG4gICAgICBmb3IgKG9mZnNldCA9IDAsIGkgPSBjOyBpIDwgbjsgaSArPSBuY29scykge1xuICAgICAgICBpZiAob2Zmc2V0IDwgeE9mZnNldFtpXSkgb2Zmc2V0ID0geE9mZnNldFtpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gYzsgaSA8IG47IGkgKz0gbmNvbHMpIHtcbiAgICAgICAgeE9mZnNldFtpXSA9IG9mZnNldCArIHhFeHRlbnRbYyAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhbGlnbkNvbCA9PT0gQWxsKSB7XG4gICAgZm9yIChvZmZzZXQgPSAwLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGkgJSBuY29scyAmJiBvZmZzZXQgPCB4T2Zmc2V0W2ldKSBvZmZzZXQgPSB4T2Zmc2V0W2ldO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChpICUgbmNvbHMpIHhPZmZzZXRbaV0gPSBvZmZzZXQgKyB4TWF4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGFsaWduQ29sID0gZmFsc2UsIGMgPSAxOyBjIDwgbmNvbHM7ICsrYykge1xuICAgICAgZm9yIChpID0gYzsgaSA8IG47IGkgKz0gbmNvbHMpIHtcbiAgICAgICAgeE9mZnNldFtpXSArPSB4RXh0ZW50W2MgLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gZW5mb3JjZSByb3cgYWxpZ25tZW50IGNvbnN0cmFpbnRzXG5cblxuICBpZiAoYWxpZ25Sb3cgPT09IEVhY2gpIHtcbiAgICBmb3IgKHIgPSAxOyByIDwgbnJvd3M7ICsrcikge1xuICAgICAgZm9yIChvZmZzZXQgPSAwLCBpID0gciAqIG5jb2xzLCBtID0gaSArIG5jb2xzOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCB5T2Zmc2V0W2ldKSBvZmZzZXQgPSB5T2Zmc2V0W2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSByICogbmNvbHM7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgeU9mZnNldFtpXSA9IG9mZnNldCArIHlFeHRlbnRbciAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhbGlnblJvdyA9PT0gQWxsKSB7XG4gICAgZm9yIChvZmZzZXQgPSAwLCBpID0gbmNvbHM7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvZmZzZXQgPCB5T2Zmc2V0W2ldKSBvZmZzZXQgPSB5T2Zmc2V0W2ldO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG5jb2xzOyBpIDwgbjsgKytpKSB7XG4gICAgICB5T2Zmc2V0W2ldID0gb2Zmc2V0ICsgeU1heDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChhbGlnblJvdyA9IGZhbHNlLCByID0gMTsgciA8IG5yb3dzOyArK3IpIHtcbiAgICAgIGZvciAoaSA9IHIgKiBuY29scywgbSA9IGkgKyBuY29sczsgaSA8IG07ICsraSkge1xuICAgICAgICB5T2Zmc2V0W2ldICs9IHlFeHRlbnRbciAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBwZXJmb3JtIGhvcml6b250YWwgZ3JpZCBsYXlvdXRcblxuXG4gIGZvciAoeCA9IDAsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgeCA9IHhPZmZzZXRbaV0gKyAoaSAlIG5jb2xzID8geCA6IDApO1xuICAgIGR4W2ldICs9IHggLSBncm91cHNbaV0ueDtcbiAgfSAvLyBwZXJmb3JtIHZlcnRpY2FsIGdyaWQgbGF5b3V0XG5cblxuICBmb3IgKGMgPSAwOyBjIDwgbmNvbHM7ICsrYykge1xuICAgIGZvciAoeSA9IDAsIGkgPSBjOyBpIDwgbjsgaSArPSBuY29scykge1xuICAgICAgeSArPSB5T2Zmc2V0W2ldO1xuICAgICAgZHlbaV0gKz0geSAtIGdyb3Vwc1tpXS55O1xuICAgIH1cbiAgfSAvLyBwZXJmb3JtIGhvcml6b250YWwgY2VudGVyaW5nXG5cblxuICBpZiAoYWxpZ25Db2wgJiYgZ2V0KG9wdC5jZW50ZXIsIENvbHVtbikgJiYgbnJvd3MgPiAxKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgYiA9IGFsaWduQ29sID09PSBBbGwgPyB4TWF4IDogeEV4dGVudFtpICUgbmNvbHNdO1xuICAgICAgeCA9IGIgLSBib3hlc1tpXS54MiAtIGdyb3Vwc1tpXS54IC0gZHhbaV07XG4gICAgICBpZiAoeCA+IDApIGR4W2ldICs9IHggLyAyO1xuICAgIH1cbiAgfSAvLyBwZXJmb3JtIHZlcnRpY2FsIGNlbnRlcmluZ1xuXG5cbiAgaWYgKGFsaWduUm93ICYmIGdldChvcHQuY2VudGVyLCBSb3cpICYmIG5jb2xzICE9PSAxKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgYiA9IGFsaWduUm93ID09PSBBbGwgPyB5TWF4IDogeUV4dGVudFt+fihpIC8gbmNvbHMpXTtcbiAgICAgIHkgPSBiIC0gYm94ZXNbaV0ueTIgLSBncm91cHNbaV0ueSAtIGR5W2ldO1xuICAgICAgaWYgKHkgPiAwKSBkeVtpXSArPSB5IC8gMjtcbiAgICB9XG4gIH0gLy8gcG9zaXRpb24gZ3JpZCByZWxhdGl2ZSB0byBhbmNob3JcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBib3VuZHMudW5pb24oYm94ZXNbaV0udHJhbnNsYXRlKGR4W2ldLCBkeVtpXSkpO1xuICB9XG5cbiAgeCA9IGdldChvcHQuYW5jaG9yLCBYKTtcbiAgeSA9IGdldChvcHQuYW5jaG9yLCBZKTtcblxuICBzd2l0Y2ggKGdldChvcHQuYW5jaG9yLCBDb2x1bW4pKSB7XG4gICAgY2FzZSBFbmQ6XG4gICAgICB4IC09IGJvdW5kcy53aWR0aCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE1pZGRsZTpcbiAgICAgIHggLT0gYm91bmRzLndpZHRoKCkgLyAyO1xuICB9XG5cbiAgc3dpdGNoIChnZXQob3B0LmFuY2hvciwgUm93KSkge1xuICAgIGNhc2UgRW5kOlxuICAgICAgeSAtPSBib3VuZHMuaGVpZ2h0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTWlkZGxlOlxuICAgICAgeSAtPSBib3VuZHMuaGVpZ2h0KCkgLyAyO1xuICB9XG5cbiAgeCA9IE1hdGgucm91bmQoeCk7XG4gIHkgPSBNYXRoLnJvdW5kKHkpOyAvLyB1cGRhdGUgbWFyayBwb3NpdGlvbnMsIGJvdW5kcywgZGlydHlcblxuICBib3VuZHMuY2xlYXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZ3JvdXBzW2ldLm1hcmsuYm91bmRzLmNsZWFyKCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZyA9IGdyb3Vwc1tpXTtcbiAgICBnLnggKz0gZHhbaV0gKz0geDtcbiAgICBnLnkgKz0gZHlbaV0gKz0geTtcbiAgICBib3VuZHMudW5pb24oZy5tYXJrLmJvdW5kcy51bmlvbihnLmJvdW5kcy50cmFuc2xhdGUoZHhbaV0sIGR5W2ldKSkpO1xuICAgIGlmIChkaXJ0eSkgdmlldy5kaXJ0eShnKTtcbiAgfVxuXG4gIHJldHVybiBib3VuZHM7XG59XG5mdW5jdGlvbiB0cmVsbGlzTGF5b3V0KHZpZXcsIGdyb3VwLCBvcHQpIHtcbiAgdmFyIHZpZXdzID0gZ3JpZExheW91dEdyb3Vwcyhncm91cCksXG4gICAgICBncm91cHMgPSB2aWV3cy5tYXJrcyxcbiAgICAgIGJib3ggPSBvcHQuYm91bmRzID09PSBGbHVzaCA/IGJvdW5kRmx1c2ggOiBib3VuZEZ1bGwsXG4gICAgICBvZmYgPSBvcHQub2Zmc2V0LFxuICAgICAgbmNvbHMgPSBvcHQuY29sdW1ucyB8fCBncm91cHMubGVuZ3RoLFxuICAgICAgbnJvd3MgPSBuY29scyA8PSAwID8gMSA6IE1hdGguY2VpbChncm91cHMubGVuZ3RoIC8gbmNvbHMpLFxuICAgICAgY2VsbHMgPSBucm93cyAqIG5jb2xzLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgYW5jaG9yLFxuICAgICAgYmFuZCxcbiAgICAgIG9mZnNldDsgLy8gLS0gaW5pdGlhbCBncmlkIGxheW91dFxuXG4gIGNvbnN0IGJvdW5kcyA9IGdyaWRMYXlvdXQodmlldywgZ3JvdXBzLCBvcHQpO1xuICBpZiAoYm91bmRzLmVtcHR5KCkpIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7IC8vIGVtcHR5IGdyaWRcbiAgLy8gLS0gbGF5b3V0IGdyaWQgaGVhZGVycyBhbmQgZm9vdGVycyAtLVxuICAvLyBwZXJmb3JtIHJvdyBoZWFkZXIgbGF5b3V0XG5cbiAgaWYgKHZpZXdzLnJvd2hlYWRlcnMpIHtcbiAgICBiYW5kID0gZ2V0KG9wdC5oZWFkZXJCYW5kLCBSb3csIG51bGwpO1xuICAgIHggPSBsYXlvdXRIZWFkZXJzKHZpZXcsIHZpZXdzLnJvd2hlYWRlcnMsIGdyb3VwcywgbmNvbHMsIG5yb3dzLCAtZ2V0KG9mZiwgJ3Jvd0hlYWRlcicpLCBtaW4sIDAsIGJib3gsICd4MScsIDAsIG5jb2xzLCAxLCBiYW5kKTtcbiAgfSAvLyBwZXJmb3JtIGNvbHVtbiBoZWFkZXIgbGF5b3V0XG5cblxuICBpZiAodmlld3MuY29saGVhZGVycykge1xuICAgIGJhbmQgPSBnZXQob3B0LmhlYWRlckJhbmQsIENvbHVtbiwgbnVsbCk7XG4gICAgeSA9IGxheW91dEhlYWRlcnModmlldywgdmlld3MuY29saGVhZGVycywgZ3JvdXBzLCBuY29scywgbmNvbHMsIC1nZXQob2ZmLCAnY29sdW1uSGVhZGVyJyksIG1pbiwgMSwgYmJveCwgJ3kxJywgMCwgMSwgbmNvbHMsIGJhbmQpO1xuICB9IC8vIHBlcmZvcm0gcm93IGZvb3RlciBsYXlvdXRcblxuXG4gIGlmICh2aWV3cy5yb3dmb290ZXJzKSB7XG4gICAgYmFuZCA9IGdldChvcHQuZm9vdGVyQmFuZCwgUm93LCBudWxsKTtcbiAgICB4MiA9IGxheW91dEhlYWRlcnModmlldywgdmlld3Mucm93Zm9vdGVycywgZ3JvdXBzLCBuY29scywgbnJvd3MsIGdldChvZmYsICdyb3dGb290ZXInKSwgbWF4LCAwLCBiYm94LCAneDInLCBuY29scyAtIDEsIG5jb2xzLCAxLCBiYW5kKTtcbiAgfSAvLyBwZXJmb3JtIGNvbHVtbiBmb290ZXIgbGF5b3V0XG5cblxuICBpZiAodmlld3MuY29sZm9vdGVycykge1xuICAgIGJhbmQgPSBnZXQob3B0LmZvb3RlckJhbmQsIENvbHVtbiwgbnVsbCk7XG4gICAgeTIgPSBsYXlvdXRIZWFkZXJzKHZpZXcsIHZpZXdzLmNvbGZvb3RlcnMsIGdyb3VwcywgbmNvbHMsIG5jb2xzLCBnZXQob2ZmLCAnY29sdW1uRm9vdGVyJyksIG1heCwgMSwgYmJveCwgJ3kyJywgY2VsbHMgLSBuY29scywgMSwgbmNvbHMsIGJhbmQpO1xuICB9IC8vIHBlcmZvcm0gcm93IHRpdGxlIGxheW91dFxuXG5cbiAgaWYgKHZpZXdzLnJvd3RpdGxlKSB7XG4gICAgYW5jaG9yID0gZ2V0KG9wdC50aXRsZUFuY2hvciwgUm93KTtcbiAgICBvZmZzZXQgPSBnZXQob2ZmLCAncm93VGl0bGUnKTtcbiAgICBvZmZzZXQgPSBhbmNob3IgPT09IEVuZCA/IHgyICsgb2Zmc2V0IDogeCAtIG9mZnNldDtcbiAgICBiYW5kID0gZ2V0KG9wdC50aXRsZUJhbmQsIFJvdywgMC41KTtcbiAgICBsYXlvdXRUaXRsZSh2aWV3LCB2aWV3cy5yb3d0aXRsZSwgb2Zmc2V0LCAwLCBib3VuZHMsIGJhbmQpO1xuICB9IC8vIHBlcmZvcm0gY29sdW1uIHRpdGxlIGxheW91dFxuXG5cbiAgaWYgKHZpZXdzLmNvbHRpdGxlKSB7XG4gICAgYW5jaG9yID0gZ2V0KG9wdC50aXRsZUFuY2hvciwgQ29sdW1uKTtcbiAgICBvZmZzZXQgPSBnZXQob2ZmLCAnY29sdW1uVGl0bGUnKTtcbiAgICBvZmZzZXQgPSBhbmNob3IgPT09IEVuZCA/IHkyICsgb2Zmc2V0IDogeSAtIG9mZnNldDtcbiAgICBiYW5kID0gZ2V0KG9wdC50aXRsZUJhbmQsIENvbHVtbiwgMC41KTtcbiAgICBsYXlvdXRUaXRsZSh2aWV3LCB2aWV3cy5jb2x0aXRsZSwgb2Zmc2V0LCAxLCBib3VuZHMsIGJhbmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kRmx1c2goaXRlbSwgZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkID09PSAneDEnID8gaXRlbS54IHx8IDAgOiBmaWVsZCA9PT0gJ3kxJyA/IGl0ZW0ueSB8fCAwIDogZmllbGQgPT09ICd4MicgPyAoaXRlbS54IHx8IDApICsgKGl0ZW0ud2lkdGggfHwgMCkgOiBmaWVsZCA9PT0gJ3kyJyA/IChpdGVtLnkgfHwgMCkgKyAoaXRlbS5oZWlnaHQgfHwgMCkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJvdW5kRnVsbChpdGVtLCBmaWVsZCkge1xuICByZXR1cm4gaXRlbS5ib3VuZHNbZmllbGRdO1xufVxuXG5mdW5jdGlvbiBsYXlvdXRIZWFkZXJzKHZpZXcsIGhlYWRlcnMsIGdyb3VwcywgbmNvbHMsIGxpbWl0LCBvZmZzZXQsIGFnZywgaXNYLCBib3VuZCwgYmYsIHN0YXJ0LCBzdHJpZGUsIGJhY2ssIGJhbmQpIHtcbiAgdmFyIG4gPSBncm91cHMubGVuZ3RoLFxuICAgICAgaW5pdCA9IDAsXG4gICAgICBlZGdlID0gMCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgayxcbiAgICAgIG0sXG4gICAgICBiLFxuICAgICAgaCxcbiAgICAgIGcsXG4gICAgICB4LFxuICAgICAgeTsgLy8gaWYgbm8gZ3JvdXBzLCBlYXJseSBleGl0IGFuZCByZXR1cm4gMFxuXG4gIGlmICghbikgcmV0dXJuIGluaXQ7IC8vIGNvbXB1dGUgbWFyZ2luXG5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBuOyBpICs9IHN0cmlkZSkge1xuICAgIGlmIChncm91cHNbaV0pIGluaXQgPSBhZ2coaW5pdCwgYm91bmQoZ3JvdXBzW2ldLCBiZikpO1xuICB9IC8vIGlmIG5vIGhlYWRlcnMsIHJldHVybiBtYXJnaW4gY2FsY3VsYXRpb25cblxuXG4gIGlmICghaGVhZGVycy5sZW5ndGgpIHJldHVybiBpbml0OyAvLyBjaGVjayBpZiBudW1iZXIgb2YgaGVhZGVycyBleGNlZWRzIG51bWJlciBvZiByb3dzIG9yIGNvbHVtbnNcblxuICBpZiAoaGVhZGVycy5sZW5ndGggPiBsaW1pdCkge1xuICAgIHZpZXcud2FybignR3JpZCBoZWFkZXJzIGV4Y2VlZCBsaW1pdDogJyArIGxpbWl0KTtcbiAgICBoZWFkZXJzID0gaGVhZGVycy5zbGljZSgwLCBsaW1pdCk7XG4gIH0gLy8gYXBwbHkgb2Zmc2V0XG5cblxuICBpbml0ICs9IG9mZnNldDsgLy8gY2xlYXIgbWFyayBib3VuZHMgZm9yIGFsbCBoZWFkZXJzXG5cbiAgZm9yIChqID0gMCwgbSA9IGhlYWRlcnMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgdmlldy5kaXJ0eShoZWFkZXJzW2pdKTtcbiAgICBoZWFkZXJzW2pdLm1hcmsuYm91bmRzLmNsZWFyKCk7XG4gIH0gLy8gbGF5b3V0IGVhY2ggaGVhZGVyXG5cblxuICBmb3IgKGkgPSBzdGFydCwgaiA9IDAsIG0gPSBoZWFkZXJzLmxlbmd0aDsgaiA8IG07ICsraiwgaSArPSBzdHJpZGUpIHtcbiAgICBoID0gaGVhZGVyc1tqXTtcbiAgICBiID0gaC5tYXJrLmJvdW5kczsgLy8gc2VhcmNoIGZvciBuZWFyZXN0IGdyb3VwIHRvIGFsaWduIHRvXG4gICAgLy8gbmVjZXNzYXJ5IGlmIHRhYmxlIGhhcyBlbXB0eSBjZWxsc1xuXG4gICAgZm9yIChrID0gaTsgayA+PSAwICYmIChnID0gZ3JvdXBzW2tdKSA9PSBudWxsOyBrIC09IGJhY2spOyAvLyBhc3NpZ24gY29vcmRpbmF0ZXMgYW5kIHVwZGF0ZSBib3VuZHNcblxuXG4gICAgaWYgKGlzWCkge1xuICAgICAgeCA9IGJhbmQgPT0gbnVsbCA/IGcueCA6IE1hdGgucm91bmQoZy5ib3VuZHMueDEgKyBiYW5kICogZy5ib3VuZHMud2lkdGgoKSk7XG4gICAgICB5ID0gaW5pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IGluaXQ7XG4gICAgICB5ID0gYmFuZCA9PSBudWxsID8gZy55IDogTWF0aC5yb3VuZChnLmJvdW5kcy55MSArIGJhbmQgKiBnLmJvdW5kcy5oZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgYi51bmlvbihoLmJvdW5kcy50cmFuc2xhdGUoeCAtIChoLnggfHwgMCksIHkgLSAoaC55IHx8IDApKSk7XG4gICAgaC54ID0geDtcbiAgICBoLnkgPSB5O1xuICAgIHZpZXcuZGlydHkoaCk7IC8vIHVwZGF0ZSBjdXJyZW50IGVkZ2Ugb2YgbGF5b3V0IGJvdW5kc1xuXG4gICAgZWRnZSA9IGFnZyhlZGdlLCBiW2JmXSk7XG4gIH1cblxuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gbGF5b3V0VGl0bGUodmlldywgZywgb2Zmc2V0LCBpc1gsIGJvdW5kcywgYmFuZCkge1xuICBpZiAoIWcpIHJldHVybjtcbiAgdmlldy5kaXJ0eShnKTsgLy8gY29tcHV0ZSB0aXRsZSBjb29yZGluYXRlc1xuXG4gIHZhciB4ID0gb2Zmc2V0LFxuICAgICAgeSA9IG9mZnNldDtcbiAgaXNYID8geCA9IE1hdGgucm91bmQoYm91bmRzLngxICsgYmFuZCAqIGJvdW5kcy53aWR0aCgpKSA6IHkgPSBNYXRoLnJvdW5kKGJvdW5kcy55MSArIGJhbmQgKiBib3VuZHMuaGVpZ2h0KCkpOyAvLyBhc3NpZ24gY29vcmRpbmF0ZXMgYW5kIHVwZGF0ZSBib3VuZHNcblxuICBnLmJvdW5kcy50cmFuc2xhdGUoeCAtIChnLnggfHwgMCksIHkgLSAoZy55IHx8IDApKTtcbiAgZy5tYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKGcuYm91bmRzKTtcbiAgZy54ID0geDtcbiAgZy55ID0geTsgLy8gcXVldWUgdGl0bGUgZm9yIHJlZHJhd1xuXG4gIHZpZXcuZGlydHkoZyk7XG59XG5cbmZ1bmN0aW9uIGxvb2t1cCQxKGNvbmZpZywgb3JpZW50KSB7XG4gIGNvbnN0IG9wdCA9IGNvbmZpZ1tvcmllbnRdIHx8IHt9O1xuICByZXR1cm4gKGtleSwgZCkgPT4gb3B0W2tleV0gIT0gbnVsbCA/IG9wdFtrZXldIDogY29uZmlnW2tleV0gIT0gbnVsbCA/IGNvbmZpZ1trZXldIDogZDtcbn0gLy8gaWYgbGVnZW5kcyBzcGVjaWZ5IG9mZnNldCBkaXJlY3RseSwgdXNlIHRoZSBtYXhpbXVtIHNwZWNpZmllZCB2YWx1ZVxuXG5cbmZ1bmN0aW9uIG9mZnNldHMobGVnZW5kcywgdmFsdWUpIHtcbiAgbGV0IG1heCA9IC1JbmZpbml0eTtcbiAgbGVnZW5kcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtLm9mZnNldCAhPSBudWxsKSBtYXggPSBNYXRoLm1heChtYXgsIGl0ZW0ub2Zmc2V0KTtcbiAgfSk7XG4gIHJldHVybiBtYXggPiAtSW5maW5pdHkgPyBtYXggOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbGVnZW5kUGFyYW1zKGcsIG9yaWVudCwgY29uZmlnLCB4YiwgeWIsIHcsIGgpIHtcbiAgY29uc3QgXyA9IGxvb2t1cCQxKGNvbmZpZywgb3JpZW50KSxcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0cyhnLCBfKCdvZmZzZXQnLCAwKSksXG4gICAgICAgIGFuY2hvciA9IF8oJ2FuY2hvcicsIFN0YXJ0KSxcbiAgICAgICAgbXVsdCA9IGFuY2hvciA9PT0gRW5kID8gMSA6IGFuY2hvciA9PT0gTWlkZGxlID8gMC41IDogMDtcblxuICBjb25zdCBwID0ge1xuICAgIGFsaWduOiBFYWNoLFxuICAgIGJvdW5kczogXygnYm91bmRzJywgRmx1c2gpLFxuICAgIGNvbHVtbnM6IF8oJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnID8gMSA6IGcubGVuZ3RoLFxuICAgIHBhZGRpbmc6IF8oJ21hcmdpbicsIDgpLFxuICAgIGNlbnRlcjogXygnY2VudGVyJyksXG4gICAgbm9kaXJ0eTogdHJ1ZVxuICB9O1xuXG4gIHN3aXRjaCAob3JpZW50KSB7XG4gICAgY2FzZSBMZWZ0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IoeGIueDEpIC0gb2Zmc2V0LFxuICAgICAgICBjb2x1bW46IEVuZCxcbiAgICAgICAgeTogbXVsdCAqIChoIHx8IHhiLmhlaWdodCgpICsgMiAqIHhiLnkxKSxcbiAgICAgICAgcm93OiBhbmNob3JcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUmlnaHQ6XG4gICAgICBwLmFuY2hvciA9IHtcbiAgICAgICAgeDogTWF0aC5jZWlsKHhiLngyKSArIG9mZnNldCxcbiAgICAgICAgeTogbXVsdCAqIChoIHx8IHhiLmhlaWdodCgpICsgMiAqIHhiLnkxKSxcbiAgICAgICAgcm93OiBhbmNob3JcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVG9wOlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHk6IE1hdGguZmxvb3IoeWIueTEpIC0gb2Zmc2V0LFxuICAgICAgICByb3c6IEVuZCxcbiAgICAgICAgeDogbXVsdCAqICh3IHx8IHliLndpZHRoKCkgKyAyICogeWIueDEpLFxuICAgICAgICBjb2x1bW46IGFuY2hvclxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBCb3R0b206XG4gICAgICBwLmFuY2hvciA9IHtcbiAgICAgICAgeTogTWF0aC5jZWlsKHliLnkyKSArIG9mZnNldCxcbiAgICAgICAgeDogbXVsdCAqICh3IHx8IHliLndpZHRoKCkgKyAyICogeWIueDEpLFxuICAgICAgICBjb2x1bW46IGFuY2hvclxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUb3BMZWZ0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IG9mZnNldCxcbiAgICAgICAgeTogb2Zmc2V0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRvcFJpZ2h0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IHcgLSBvZmZzZXQsXG4gICAgICAgIHk6IG9mZnNldCxcbiAgICAgICAgY29sdW1uOiBFbmRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQm90dG9tTGVmdDpcbiAgICAgIHAuYW5jaG9yID0ge1xuICAgICAgICB4OiBvZmZzZXQsXG4gICAgICAgIHk6IGggLSBvZmZzZXQsXG4gICAgICAgIHJvdzogRW5kXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEJvdHRvbVJpZ2h0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IHcgLSBvZmZzZXQsXG4gICAgICAgIHk6IGggLSBvZmZzZXQsXG4gICAgICAgIGNvbHVtbjogRW5kLFxuICAgICAgICByb3c6IEVuZFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBsZWdlbmRMYXlvdXQodmlldywgbGVnZW5kKSB7XG4gIHZhciBpdGVtID0gbGVnZW5kLml0ZW1zWzBdLFxuICAgICAgZGF0dW0gPSBpdGVtLmRhdHVtLFxuICAgICAgb3JpZW50ID0gaXRlbS5vcmllbnQsXG4gICAgICBib3VuZHMgPSBpdGVtLmJvdW5kcyxcbiAgICAgIHggPSBpdGVtLngsXG4gICAgICB5ID0gaXRlbS55LFxuICAgICAgdyxcbiAgICAgIGg7IC8vIGNhY2hlIGN1cnJlbnQgYm91bmRzIGZvciBsYXRlciBjb21wYXJpc29uXG5cbiAgaXRlbS5fYm91bmRzID8gaXRlbS5fYm91bmRzLmNsZWFyKCkudW5pb24oYm91bmRzKSA6IGl0ZW0uX2JvdW5kcyA9IGJvdW5kcy5jbG9uZSgpO1xuICBib3VuZHMuY2xlYXIoKTsgLy8gYWRqdXN0IGxlZ2VuZCB0byBhY2NvbW1vZGF0ZSBwYWRkaW5nIGFuZCB0aXRsZVxuXG4gIGxlZ2VuZEdyb3VwTGF5b3V0KHZpZXcsIGl0ZW0sIGl0ZW0uaXRlbXNbMF0uaXRlbXNbMF0pOyAvLyBhZ2dyZWdhdGUgYm91bmRzIHRvIGRldGVybWluZSBzaXplLCBhbmQgaW5jbHVkZSBvcmlnaW5cblxuICBib3VuZHMgPSBsZWdlbmRCb3VuZHMoaXRlbSwgYm91bmRzKTtcbiAgdyA9IDIgKiBpdGVtLnBhZGRpbmc7XG4gIGggPSAyICogaXRlbS5wYWRkaW5nO1xuXG4gIGlmICghYm91bmRzLmVtcHR5KCkpIHtcbiAgICB3ID0gTWF0aC5jZWlsKGJvdW5kcy53aWR0aCgpICsgdyk7XG4gICAgaCA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0KCkgKyBoKTtcbiAgfVxuXG4gIGlmIChkYXR1bS50eXBlID09PSBTeW1ib2xzKSB7XG4gICAgbGVnZW5kRW50cnlMYXlvdXQoaXRlbS5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5pdGVtcyk7XG4gIH1cblxuICBpZiAob3JpZW50ICE9PSBOb25lKSB7XG4gICAgaXRlbS54ID0geCA9IDA7XG4gICAgaXRlbS55ID0geSA9IDA7XG4gIH1cblxuICBpdGVtLndpZHRoID0gdztcbiAgaXRlbS5oZWlnaHQgPSBoO1xuICBib3VuZFN0cm9rZShib3VuZHMuc2V0KHgsIHksIHggKyB3LCB5ICsgaCksIGl0ZW0pO1xuICBpdGVtLm1hcmsuYm91bmRzLmNsZWFyKCkudW5pb24oYm91bmRzKTtcbiAgcmV0dXJuIGl0ZW07XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEJvdW5kcyhpdGVtLCBiKSB7XG4gIC8vIGFnZ3JlZ2F0ZSBpdGVtIGJvdW5kc1xuICBpdGVtLml0ZW1zLmZvckVhY2goXyA9PiBiLnVuaW9uKF8uYm91bmRzKSk7IC8vIGFuY2hvciB0byBsZWdlbmQgb3JpZ2luXG5cbiAgYi54MSA9IGl0ZW0ucGFkZGluZztcbiAgYi55MSA9IGl0ZW0ucGFkZGluZztcbiAgcmV0dXJuIGI7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEdyb3VwTGF5b3V0KHZpZXcsIGl0ZW0sIGVudHJ5KSB7XG4gIHZhciBwYWQgPSBpdGVtLnBhZGRpbmcsXG4gICAgICBleCA9IHBhZCAtIGVudHJ5LngsXG4gICAgICBleSA9IHBhZCAtIGVudHJ5Lnk7XG5cbiAgaWYgKCFpdGVtLmRhdHVtLnRpdGxlKSB7XG4gICAgaWYgKGV4IHx8IGV5KSB0cmFuc2xhdGUodmlldywgZW50cnksIGV4LCBleSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRpdGxlID0gaXRlbS5pdGVtc1sxXS5pdGVtc1swXSxcbiAgICAgICAgYW5jaG9yID0gdGl0bGUuYW5jaG9yLFxuICAgICAgICB0cGFkID0gaXRlbS50aXRsZVBhZGRpbmcgfHwgMCxcbiAgICAgICAgdHggPSBwYWQgLSB0aXRsZS54LFxuICAgICAgICB0eSA9IHBhZCAtIHRpdGxlLnk7XG5cbiAgICBzd2l0Y2ggKHRpdGxlLm9yaWVudCkge1xuICAgICAgY2FzZSBMZWZ0OlxuICAgICAgICBleCArPSBNYXRoLmNlaWwodGl0bGUuYm91bmRzLndpZHRoKCkpICsgdHBhZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUmlnaHQ6XG4gICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGV5ICs9IHRpdGxlLmJvdW5kcy5oZWlnaHQoKSArIHRwYWQ7XG4gICAgfVxuXG4gICAgaWYgKGV4IHx8IGV5KSB0cmFuc2xhdGUodmlldywgZW50cnksIGV4LCBleSk7XG5cbiAgICBzd2l0Y2ggKHRpdGxlLm9yaWVudCkge1xuICAgICAgY2FzZSBMZWZ0OlxuICAgICAgICB0eSArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIGFuY2hvciwgMSwgMSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJpZ2h0OlxuICAgICAgICB0eCArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIEVuZCwgMCwgMCkgKyB0cGFkO1xuICAgICAgICB0eSArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIGFuY2hvciwgMSwgMSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgdHggKz0gbGVnZW5kVGl0bGVPZmZzZXQoaXRlbSwgZW50cnksIHRpdGxlLCBhbmNob3IsIDAsIDApO1xuICAgICAgICB0eSArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIEVuZCwgLTEsIDAsIDEpICsgdHBhZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHR4ICs9IGxlZ2VuZFRpdGxlT2Zmc2V0KGl0ZW0sIGVudHJ5LCB0aXRsZSwgYW5jaG9yLCAwLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodHggfHwgdHkpIHRyYW5zbGF0ZSh2aWV3LCB0aXRsZSwgdHgsIHR5KTsgLy8gdHJhbnNsYXRlIGxlZ2VuZCBpZiB0aXRsZSBwdXNoZXMgaW50byBuZWdhdGl2ZSBjb29yZGluYXRlc1xuXG4gICAgaWYgKCh0eCA9IE1hdGgucm91bmQodGl0bGUuYm91bmRzLngxIC0gcGFkKSkgPCAwKSB7XG4gICAgICB0cmFuc2xhdGUodmlldywgZW50cnksIC10eCwgMCk7XG4gICAgICB0cmFuc2xhdGUodmlldywgdGl0bGUsIC10eCwgMCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZFRpdGxlT2Zmc2V0KGl0ZW0sIGVudHJ5LCB0aXRsZSwgYW5jaG9yLCB5LCBsciwgbm9CYXIpIHtcbiAgY29uc3QgZ3JhZCA9IGl0ZW0uZGF0dW0udHlwZSAhPT0gJ3N5bWJvbCcsXG4gICAgICAgIHZncmFkID0gdGl0bGUuZGF0dW0udmdyYWQsXG4gICAgICAgIGUgPSBncmFkICYmIChsciB8fCAhdmdyYWQpICYmICFub0JhciA/IGVudHJ5Lml0ZW1zWzBdIDogZW50cnksXG4gICAgICAgIHMgPSBlLmJvdW5kc1t5ID8gJ3kyJyA6ICd4MiddIC0gaXRlbS5wYWRkaW5nLFxuICAgICAgICB1ID0gdmdyYWQgJiYgbHIgPyBzIDogMCxcbiAgICAgICAgdiA9IHZncmFkICYmIGxyID8gMCA6IHMsXG4gICAgICAgIG8gPSB5IDw9IDAgPyAwIDogbXVsdGlMaW5lT2Zmc2V0KHRpdGxlKTtcbiAgcmV0dXJuIE1hdGgucm91bmQoYW5jaG9yID09PSBTdGFydCA/IHUgOiBhbmNob3IgPT09IEVuZCA/IHYgLSBvIDogMC41ICogKHMgLSBvKSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2aWV3LCBpdGVtLCBkeCwgZHkpIHtcbiAgaXRlbS54ICs9IGR4O1xuICBpdGVtLnkgKz0gZHk7XG4gIGl0ZW0uYm91bmRzLnRyYW5zbGF0ZShkeCwgZHkpO1xuICBpdGVtLm1hcmsuYm91bmRzLnRyYW5zbGF0ZShkeCwgZHkpO1xuICB2aWV3LmRpcnR5KGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRFbnRyeUxheW91dChlbnRyaWVzKSB7XG4gIC8vIGdldCBtYXggd2lkdGhzIGZvciBlYWNoIGNvbHVtblxuICBjb25zdCB3aWR0aHMgPSBlbnRyaWVzLnJlZHVjZSgodywgZykgPT4ge1xuICAgIHdbZy5jb2x1bW5dID0gTWF0aC5tYXgoZy5ib3VuZHMueDIgLSBnLngsIHdbZy5jb2x1bW5dIHx8IDApO1xuICAgIHJldHVybiB3O1xuICB9LCB7fSk7IC8vIHNldCBkaW1lbnNpb25zIG9mIGxlZ2VuZCBlbnRyeSBncm91cHNcblxuICBlbnRyaWVzLmZvckVhY2goZyA9PiB7XG4gICAgZy53aWR0aCA9IHdpZHRoc1tnLmNvbHVtbl07XG4gICAgZy5oZWlnaHQgPSBnLmJvdW5kcy55MiAtIGcueTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlTGF5b3V0KHZpZXcsIG1hcmssIHdpZHRoLCBoZWlnaHQsIHZpZXdCb3VuZHMpIHtcbiAgdmFyIGdyb3VwID0gbWFyay5pdGVtc1swXSxcbiAgICAgIGZyYW1lID0gZ3JvdXAuZnJhbWUsXG4gICAgICBvcmllbnQgPSBncm91cC5vcmllbnQsXG4gICAgICBhbmNob3IgPSBncm91cC5hbmNob3IsXG4gICAgICBvZmZzZXQgPSBncm91cC5vZmZzZXQsXG4gICAgICBwYWRkaW5nID0gZ3JvdXAucGFkZGluZyxcbiAgICAgIHRpdGxlID0gZ3JvdXAuaXRlbXNbMF0uaXRlbXNbMF0sXG4gICAgICBzdWJ0aXRsZSA9IGdyb3VwLml0ZW1zWzFdICYmIGdyb3VwLml0ZW1zWzFdLml0ZW1zWzBdLFxuICAgICAgZW5kID0gb3JpZW50ID09PSBMZWZ0IHx8IG9yaWVudCA9PT0gUmlnaHQgPyBoZWlnaHQgOiB3aWR0aCxcbiAgICAgIHN0YXJ0ID0gMCxcbiAgICAgIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBzeCA9IDAsXG4gICAgICBzeSA9IDAsXG4gICAgICBwb3M7XG5cbiAgaWYgKGZyYW1lICE9PSBHcm91cCkge1xuICAgIG9yaWVudCA9PT0gTGVmdCA/IChzdGFydCA9IHZpZXdCb3VuZHMueTIsIGVuZCA9IHZpZXdCb3VuZHMueTEpIDogb3JpZW50ID09PSBSaWdodCA/IChzdGFydCA9IHZpZXdCb3VuZHMueTEsIGVuZCA9IHZpZXdCb3VuZHMueTIpIDogKHN0YXJ0ID0gdmlld0JvdW5kcy54MSwgZW5kID0gdmlld0JvdW5kcy54Mik7XG4gIH0gZWxzZSBpZiAob3JpZW50ID09PSBMZWZ0KSB7XG4gICAgc3RhcnQgPSBoZWlnaHQsIGVuZCA9IDA7XG4gIH1cblxuICBwb3MgPSBhbmNob3IgPT09IFN0YXJ0ID8gc3RhcnQgOiBhbmNob3IgPT09IEVuZCA/IGVuZCA6IChzdGFydCArIGVuZCkgLyAyO1xuXG4gIGlmIChzdWJ0aXRsZSAmJiBzdWJ0aXRsZS50ZXh0KSB7XG4gICAgLy8gcG9zaXRpb24gc3VidGl0bGVcbiAgICBzd2l0Y2ggKG9yaWVudCkge1xuICAgICAgY2FzZSBUb3A6XG4gICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgc3kgPSB0aXRsZS5ib3VuZHMuaGVpZ2h0KCkgKyBwYWRkaW5nO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMZWZ0OlxuICAgICAgICBzeCA9IHRpdGxlLmJvdW5kcy53aWR0aCgpICsgcGFkZGluZztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUmlnaHQ6XG4gICAgICAgIHN4ID0gLXRpdGxlLmJvdW5kcy53aWR0aCgpIC0gcGFkZGluZztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGVtcEJvdW5kcy5jbGVhcigpLnVuaW9uKHN1YnRpdGxlLmJvdW5kcyk7XG4gICAgdGVtcEJvdW5kcy50cmFuc2xhdGUoc3ggLSAoc3VidGl0bGUueCB8fCAwKSwgc3kgLSAoc3VidGl0bGUueSB8fCAwKSk7XG5cbiAgICBpZiAoc2V0KHN1YnRpdGxlLCAneCcsIHN4KSB8IHNldChzdWJ0aXRsZSwgJ3knLCBzeSkpIHtcbiAgICAgIHZpZXcuZGlydHkoc3VidGl0bGUpO1xuICAgICAgc3VidGl0bGUuYm91bmRzLmNsZWFyKCkudW5pb24odGVtcEJvdW5kcyk7XG4gICAgICBzdWJ0aXRsZS5tYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKHRlbXBCb3VuZHMpO1xuICAgICAgdmlldy5kaXJ0eShzdWJ0aXRsZSk7XG4gICAgfVxuXG4gICAgdGVtcEJvdW5kcy5jbGVhcigpLnVuaW9uKHN1YnRpdGxlLmJvdW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgdGVtcEJvdW5kcy5jbGVhcigpO1xuICB9XG5cbiAgdGVtcEJvdW5kcy51bmlvbih0aXRsZS5ib3VuZHMpOyAvLyBwb3NpdGlvbiB0aXRsZSBncm91cFxuXG4gIHN3aXRjaCAob3JpZW50KSB7XG4gICAgY2FzZSBUb3A6XG4gICAgICB4ID0gcG9zO1xuICAgICAgeSA9IHZpZXdCb3VuZHMueTEgLSB0ZW1wQm91bmRzLmhlaWdodCgpIC0gb2Zmc2V0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExlZnQ6XG4gICAgICB4ID0gdmlld0JvdW5kcy54MSAtIHRlbXBCb3VuZHMud2lkdGgoKSAtIG9mZnNldDtcbiAgICAgIHkgPSBwb3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUmlnaHQ6XG4gICAgICB4ID0gdmlld0JvdW5kcy54MiArIHRlbXBCb3VuZHMud2lkdGgoKSArIG9mZnNldDtcbiAgICAgIHkgPSBwb3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQm90dG9tOlxuICAgICAgeCA9IHBvcztcbiAgICAgIHkgPSB2aWV3Qm91bmRzLnkyICsgb2Zmc2V0O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgeCA9IGdyb3VwLng7XG4gICAgICB5ID0gZ3JvdXAueTtcbiAgfVxuXG4gIGlmIChzZXQoZ3JvdXAsICd4JywgeCkgfCBzZXQoZ3JvdXAsICd5JywgeSkpIHtcbiAgICB0ZW1wQm91bmRzLnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB2aWV3LmRpcnR5KGdyb3VwKTtcbiAgICBncm91cC5ib3VuZHMuY2xlYXIoKS51bmlvbih0ZW1wQm91bmRzKTtcbiAgICBtYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKHRlbXBCb3VuZHMpO1xuICAgIHZpZXcuZGlydHkoZ3JvdXApO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwLmJvdW5kcztcbn1cblxuLyoqXG4gKiBMYXlvdXQgdmlldyBlbGVtZW50cyBzdWNoIGFzIGF4ZXMgYW5kIGxlZ2VuZHMuXG4gKiBBbHNvIHBlcmZvcm1zIHNpemUgYWRqdXN0bWVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubWFyayAtIFNjZW5lZ3JhcGggbWFyayBvZiBncm91cHMgdG8gbGF5b3V0LlxuICovXG5cbmZ1bmN0aW9uIFZpZXdMYXlvdXQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhWaWV3TGF5b3V0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgdmlldyA9IHB1bHNlLmRhdGFmbG93O1xuXG4gICAgXy5tYXJrLml0ZW1zLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgaWYgKF8ubGF5b3V0KSB0cmVsbGlzTGF5b3V0KHZpZXcsIGdyb3VwLCBfLmxheW91dCk7XG4gICAgICBsYXlvdXRHcm91cCh2aWV3LCBncm91cCwgXyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2hvdWxkUmVmbG93KF8ubWFyay5ncm91cCkgPyBwdWxzZS5yZWZsb3coKSA6IHB1bHNlO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzaG91bGRSZWZsb3coZ3JvdXApIHtcbiAgLy8gV2UgdHlwaWNhbGx5IHNob3VsZCByZWZsb3cgaWYgbGF5b3V0IGlzIGludm9rZWQgKCMyNTY4KSwgYXMgY2hpbGQgaXRlbXNcbiAgLy8gbWF5IGhhdmUgcmVzaXplZCBhbmQgcmVmbG93IGVuc3VyZXMgZ3JvdXAgYm91bmRzIGFyZSByZS1jYWxjdWxhdGVkLlxuICAvLyBIb3dldmVyLCBsZWdlbmQgZW50cmllcyBoYXZlIGEgc3BlY2lhbCBleGNlcHRpb24gdG8gYXZvaWQgaW5zdGFiaWxpdHkuXG4gIC8vIEZvciBleGFtcGxlLCBpZiBhIHNlbGVjdGVkIGxlZ2VuZCBzeW1ib2wgZ2FpbnMgYSBzdHJva2Ugb24gaG92ZXIsXG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gcmUtcG9zaXRpb24gc3Vic2VxdWVudCBlbGVtZW50cyBpbiB0aGUgbGVnZW5kLlxuICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAubWFyay5yb2xlICE9PSAnbGVnZW5kLWVudHJ5Jztcbn1cblxuZnVuY3Rpb24gbGF5b3V0R3JvdXAodmlldywgZ3JvdXAsIF8pIHtcbiAgdmFyIGl0ZW1zID0gZ3JvdXAuaXRlbXMsXG4gICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIGdyb3VwLndpZHRoIHx8IDApLFxuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgZ3JvdXAuaGVpZ2h0IHx8IDApLFxuICAgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoKS5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCksXG4gICAgICB4Qm91bmRzID0gdmlld0JvdW5kcy5jbG9uZSgpLFxuICAgICAgeUJvdW5kcyA9IHZpZXdCb3VuZHMuY2xvbmUoKSxcbiAgICAgIGxlZ2VuZHMgPSBbXSxcbiAgICAgIHRpdGxlLFxuICAgICAgbWFyayxcbiAgICAgIG9yaWVudCxcbiAgICAgIGIsXG4gICAgICBpLFxuICAgICAgbjsgLy8gbGF5b3V0IGF4ZXMsIGdhdGhlciBsZWdlbmRzLCBjb2xsZWN0IGJvdW5kc1xuXG4gIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBtYXJrID0gaXRlbXNbaV07XG5cbiAgICBzd2l0Y2ggKG1hcmsucm9sZSkge1xuICAgICAgY2FzZSBBeGlzUm9sZTpcbiAgICAgICAgYiA9IGlzWUF4aXMobWFyaykgPyB4Qm91bmRzIDogeUJvdW5kcztcbiAgICAgICAgYi51bmlvbihheGlzTGF5b3V0KHZpZXcsIG1hcmssIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVGl0bGVSb2xlOlxuICAgICAgICB0aXRsZSA9IG1hcms7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIExlZ2VuZFJvbGU6XG4gICAgICAgIGxlZ2VuZHMucHVzaChsZWdlbmRMYXlvdXQodmlldywgbWFyaykpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGcmFtZVJvbGU6XG4gICAgICBjYXNlIFNjb3BlUm9sZTpcbiAgICAgIGNhc2UgUm93SGVhZGVyOlxuICAgICAgY2FzZSBSb3dGb290ZXI6XG4gICAgICBjYXNlIFJvd1RpdGxlOlxuICAgICAgY2FzZSBDb2xIZWFkZXI6XG4gICAgICBjYXNlIENvbEZvb3RlcjpcbiAgICAgIGNhc2UgQ29sVGl0bGU6XG4gICAgICAgIHhCb3VuZHMudW5pb24obWFyay5ib3VuZHMpO1xuICAgICAgICB5Qm91bmRzLnVuaW9uKG1hcmsuYm91bmRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZpZXdCb3VuZHMudW5pb24obWFyay5ib3VuZHMpO1xuICAgIH1cbiAgfSAvLyBsYXlvdXQgbGVnZW5kcywgYWRqdXN0IHZpZXdCb3VuZHNcblxuXG4gIGlmIChsZWdlbmRzLmxlbmd0aCkge1xuICAgIC8vIGdyb3VwIGxlZ2VuZHMgYnkgb3JpZW50XG4gICAgY29uc3QgbCA9IHt9O1xuICAgIGxlZ2VuZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIG9yaWVudCA9IGl0ZW0ub3JpZW50IHx8IFJpZ2h0O1xuICAgICAgaWYgKG9yaWVudCAhPT0gTm9uZSkgKGxbb3JpZW50XSB8fCAobFtvcmllbnRdID0gW10pKS5wdXNoKGl0ZW0pO1xuICAgIH0pOyAvLyBwZXJmb3JtIGdyaWQgbGF5b3V0IGZvciBlYWNoIG9yaWVudCBncm91cFxuXG4gICAgZm9yIChjb25zdCBvcmllbnQgaW4gbCkge1xuICAgICAgY29uc3QgZyA9IGxbb3JpZW50XTtcbiAgICAgIGdyaWRMYXlvdXQodmlldywgZywgbGVnZW5kUGFyYW1zKGcsIG9yaWVudCwgXy5sZWdlbmRzLCB4Qm91bmRzLCB5Qm91bmRzLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgfSAvLyB1cGRhdGUgdmlldyBib3VuZHNcblxuXG4gICAgbGVnZW5kcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgYiA9IGl0ZW0uYm91bmRzO1xuXG4gICAgICBpZiAoIWIuZXF1YWxzKGl0ZW0uX2JvdW5kcykpIHtcbiAgICAgICAgaXRlbS5ib3VuZHMgPSBpdGVtLl9ib3VuZHM7XG4gICAgICAgIHZpZXcuZGlydHkoaXRlbSk7IC8vIGRpcnR5IHByZXZpb3VzIGxvY2F0aW9uXG5cbiAgICAgICAgaXRlbS5ib3VuZHMgPSBiO1xuICAgICAgICB2aWV3LmRpcnR5KGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5hdXRvc2l6ZSAmJiBfLmF1dG9zaXplLnR5cGUgPT09IEZpdCkge1xuICAgICAgICAvLyBGb3IgYXV0b3NpemUgZml0LCBpbmNvcnBvcmF0ZSB0aGUgb3J0aG9nb25hbCBkaW1lbnNpb24gb25seS5cbiAgICAgICAgLy8gTGVnZW5kcyB0aGF0IG92ZXJydW4gdGhlIGNoYXJ0IGFyZWEgd2lsbCB0aGVuIGJlIGNsaXBwZWQ7XG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGUgY2hhcnQgYXJlYSBnZXRzIHJlZHVjZWQgdG8gbm90aGluZyFcbiAgICAgICAgc3dpdGNoIChpdGVtLm9yaWVudCkge1xuICAgICAgICAgIGNhc2UgTGVmdDpcbiAgICAgICAgICBjYXNlIFJpZ2h0OlxuICAgICAgICAgICAgdmlld0JvdW5kcy5hZGQoYi54MSwgMCkuYWRkKGIueDIsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFRvcDpcbiAgICAgICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgICAgIHZpZXdCb3VuZHMuYWRkKDAsIGIueTEpLmFkZCgwLCBiLnkyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlld0JvdW5kcy51bmlvbihiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBjb21iaW5lIGJvdW5kaW5nIGJveGVzXG5cblxuICB2aWV3Qm91bmRzLnVuaW9uKHhCb3VuZHMpLnVuaW9uKHlCb3VuZHMpOyAvLyBsYXlvdXQgdGl0bGUsIGFkanVzdCBib3VuZHNcblxuICBpZiAodGl0bGUpIHtcbiAgICB2aWV3Qm91bmRzLnVuaW9uKHRpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCB3aWR0aCwgaGVpZ2h0LCB2aWV3Qm91bmRzKSk7XG4gIH0gLy8gb3ZlcnJpZGUgYWdncmVnYXRlZCB2aWV3IGJvdW5kcyBpZiBjb250ZW50IGlzIGNsaXBwZWRcblxuXG4gIGlmIChncm91cC5jbGlwKSB7XG4gICAgdmlld0JvdW5kcy5zZXQoMCwgMCwgZ3JvdXAud2lkdGggfHwgMCwgZ3JvdXAuaGVpZ2h0IHx8IDApO1xuICB9IC8vIHBlcmZvcm0gc2l6ZSBhZGp1c3RtZW50XG5cblxuICB2aWV3U2l6ZUxheW91dCh2aWV3LCBncm91cCwgdmlld0JvdW5kcywgXyk7XG59XG5cbmZ1bmN0aW9uIHZpZXdTaXplTGF5b3V0KHZpZXcsIGdyb3VwLCB2aWV3Qm91bmRzLCBfKSB7XG4gIGNvbnN0IGF1dG8gPSBfLmF1dG9zaXplIHx8IHt9LFxuICAgICAgICB0eXBlID0gYXV0by50eXBlO1xuICBpZiAodmlldy5fYXV0b3NpemUgPCAxIHx8ICF0eXBlKSByZXR1cm47XG4gIGxldCB2aWV3V2lkdGggPSB2aWV3Ll93aWR0aCxcbiAgICAgIHZpZXdIZWlnaHQgPSB2aWV3Ll9oZWlnaHQsXG4gICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIGdyb3VwLndpZHRoIHx8IDApLFxuICAgICAgbGVmdCA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgtdmlld0JvdW5kcy54MSkpLFxuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgZ3JvdXAuaGVpZ2h0IHx8IDApLFxuICAgICAgdG9wID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKC12aWV3Qm91bmRzLnkxKSk7XG4gIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHZpZXdCb3VuZHMueDIgLSB3aWR0aCkpLFxuICAgICAgICBib3R0b20gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwodmlld0JvdW5kcy55MiAtIGhlaWdodCkpO1xuXG4gIGlmIChhdXRvLmNvbnRhaW5zID09PSBQYWRkaW5nKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHZpZXcucGFkZGluZygpO1xuICAgIHZpZXdXaWR0aCAtPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICAgIHZpZXdIZWlnaHQgLT0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBOb25lKSB7XG4gICAgbGVmdCA9IDA7XG4gICAgdG9wID0gMDtcbiAgICB3aWR0aCA9IHZpZXdXaWR0aDtcbiAgICBoZWlnaHQgPSB2aWV3SGVpZ2h0O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEZpdCkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgdmlld1dpZHRoIC0gbGVmdCAtIHJpZ2h0KTtcbiAgICBoZWlnaHQgPSBNYXRoLm1heCgwLCB2aWV3SGVpZ2h0IC0gdG9wIC0gYm90dG9tKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBGaXRYKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB2aWV3V2lkdGggLSBsZWZ0IC0gcmlnaHQpO1xuICAgIHZpZXdIZWlnaHQgPSBoZWlnaHQgKyB0b3AgKyBib3R0b207XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRml0WSkge1xuICAgIHZpZXdXaWR0aCA9IHdpZHRoICsgbGVmdCArIHJpZ2h0O1xuICAgIGhlaWdodCA9IE1hdGgubWF4KDAsIHZpZXdIZWlnaHQgLSB0b3AgLSBib3R0b20pO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFBhZCkge1xuICAgIHZpZXdXaWR0aCA9IHdpZHRoICsgbGVmdCArIHJpZ2h0O1xuICAgIHZpZXdIZWlnaHQgPSBoZWlnaHQgKyB0b3AgKyBib3R0b207XG4gIH1cblxuICB2aWV3Ll9yZXNpemVWaWV3KHZpZXdXaWR0aCwgdmlld0hlaWdodCwgd2lkdGgsIGhlaWdodCwgW2xlZnQsIHRvcF0sIGF1dG8ucmVzaXplKTtcbn1cblxuZXhwb3J0IHsgQm91bmQgYXMgYm91bmQsIElkZW50aWZpZXIgYXMgaWRlbnRpZmllciwgTWFyayBhcyBtYXJrLCBPdmVybGFwIGFzIG92ZXJsYXAsIFJlbmRlciBhcyByZW5kZXIsIFZpZXdMYXlvdXQgYXMgdmlld2xheW91dCB9O1xuIiwiaW1wb3J0IHsgaXNTdHJpbmcsIGhhc093blByb3BlcnR5LCBlcnJvciwgdHJ1dGh5LCBjb25zdGFudCwgZXh0ZW5kLCBpc0FycmF5LCB0b1NldCwgYXJyYXksIGlzT2JqZWN0LCBkZWJvdW5jZSwgaXNEYXRlLCBpbmhlcml0cywgc3RyaW5nVmFsdWUgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgY2hhbmdlc2V0LCBpc0NoYW5nZVNldCwgRXZlbnRTdHJlYW0sIHRyYW5zZm9ybXMsIERhdGFmbG93LCBhc3luY0NhbGxiYWNrIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBwb2ludCwgcmVuZGVyTW9kdWxlLCBDYW52YXNIYW5kbGVyLCBSZW5kZXJUeXBlLCBTY2VuZWdyYXBoIH0gZnJvbSAndmVnYS1zY2VuZWdyYXBoJztcbmltcG9ydCB7IHRpY2tTdGVwIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgZnVuY3Rpb25Db250ZXh0IH0gZnJvbSAndmVnYS1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgY29udGV4dCB9IGZyb20gJ3ZlZ2EtcnVudGltZSc7XG5pbXBvcnQgeyBpbnRlcnZhbCB9IGZyb20gJ2QzLXRpbWVyJztcbmltcG9ydCB7IGxvY2FsZSB9IGZyb20gJ3ZlZ2EtZm9ybWF0JztcblxuLy8gaW5pdGlhbGl6ZSBhcmlhIHJvbGUgYW5kIGxhYmVsIGF0dHJpYnV0ZXNcbmZ1bmN0aW9uIGluaXRpYWxpemVBcmlhKHZpZXcpIHtcbiAgY29uc3QgZWwgPSB2aWV3LmNvbnRhaW5lcigpO1xuXG4gIGlmIChlbCkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdncmFwaGljcy1kb2N1bWVudCcpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1yb2xlRGVzY3JpcHRpb24nLCAndmlzdWFsaXphdGlvbicpO1xuICAgIGFyaWFMYWJlbChlbCwgdmlldy5kZXNjcmlwdGlvbigpKTtcbiAgfVxufSAvLyB1cGRhdGUgYXJpYS1sYWJlbCBpZiB3ZSBoYXZlIGEgRE9NIGNvbnRhaW5lciBlbGVtZW50XG5cbmZ1bmN0aW9uIGFyaWFMYWJlbChlbCwgZGVzYykge1xuICBpZiAoZWwpIGRlc2MgPT0gbnVsbCA/IGVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpIDogZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgZGVzYyk7XG59XG5cbmZ1bmN0aW9uIGJhY2tncm91bmQgKHZpZXcpIHtcbiAgLy8gcmVzcG9uZCB0byBiYWNrZ3JvdW5kIHNpZ25hbFxuICB2aWV3LmFkZChudWxsLCBfID0+IHtcbiAgICB2aWV3Ll9iYWNrZ3JvdW5kID0gXy5iZztcbiAgICB2aWV3Ll9yZXNpemUgPSAxO1xuICAgIHJldHVybiBfLmJnO1xuICB9LCB7XG4gICAgYmc6IHZpZXcuX3NpZ25hbHMuYmFja2dyb3VuZFxuICB9KTtcbn1cblxuY29uc3QgRGVmYXVsdCA9ICdkZWZhdWx0JztcbmZ1bmN0aW9uIGN1cnNvciAodmlldykge1xuICAvLyBnZXQgY3Vyc29yIHNpZ25hbCwgYWRkIHRvIGRhdGFmbG93IGlmIG5lZWRlZFxuICBjb25zdCBjdXJzb3IgPSB2aWV3Ll9zaWduYWxzLmN1cnNvciB8fCAodmlldy5fc2lnbmFscy5jdXJzb3IgPSB2aWV3LmFkZCh7XG4gICAgdXNlcjogRGVmYXVsdCxcbiAgICBpdGVtOiBudWxsXG4gIH0pKTsgLy8gZXZhbHVhdGUgY3Vyc29yIG9uIGVhY2ggbW91c2Vtb3ZlIGV2ZW50XG5cbiAgdmlldy5vbih2aWV3LmV2ZW50cygndmlldycsICdtb3VzZW1vdmUnKSwgY3Vyc29yLCAoXywgZXZlbnQpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGN1cnNvci52YWx1ZSxcbiAgICAgICAgICB1c2VyID0gdmFsdWUgPyBpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZSA6IHZhbHVlLnVzZXIgOiBEZWZhdWx0LFxuICAgICAgICAgIGl0ZW0gPSBldmVudC5pdGVtICYmIGV2ZW50Lml0ZW0uY3Vyc29yIHx8IG51bGw7XG4gICAgcmV0dXJuIHZhbHVlICYmIHVzZXIgPT09IHZhbHVlLnVzZXIgJiYgaXRlbSA9PSB2YWx1ZS5pdGVtID8gdmFsdWUgOiB7XG4gICAgICB1c2VyOiB1c2VyLFxuICAgICAgaXRlbTogaXRlbVxuICAgIH07XG4gIH0pOyAvLyB3aGVuIGN1cnNvciBzaWduYWwgdXBkYXRlcywgc2V0IHZpc2libGUgY3Vyc29yXG5cbiAgdmlldy5hZGQobnVsbCwgZnVuY3Rpb24gKF8pIHtcbiAgICBsZXQgdXNlciA9IF8uY3Vyc29yLFxuICAgICAgICBpdGVtID0gdGhpcy52YWx1ZTtcblxuICAgIGlmICghaXNTdHJpbmcodXNlcikpIHtcbiAgICAgIGl0ZW0gPSB1c2VyLml0ZW07XG4gICAgICB1c2VyID0gdXNlci51c2VyO1xuICAgIH1cblxuICAgIHNldEN1cnNvcih2aWV3LCB1c2VyICYmIHVzZXIgIT09IERlZmF1bHQgPyB1c2VyIDogaXRlbSB8fCB1c2VyKTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSwge1xuICAgIGN1cnNvcjogY3Vyc29yXG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0Q3Vyc29yKHZpZXcsIGN1cnNvcikge1xuICBjb25zdCBlbCA9IHZpZXcuZ2xvYmFsQ3Vyc29yKCkgPyB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmJvZHkgOiB2aWV3LmNvbnRhaW5lcigpO1xuXG4gIGlmIChlbCkge1xuICAgIHJldHVybiBjdXJzb3IgPT0gbnVsbCA/IGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdjdXJzb3InKSA6IGVsLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRhcmVmKHZpZXcsIG5hbWUpIHtcbiAgdmFyIGRhdGEgPSB2aWV3Ll9ydW50aW1lLmRhdGE7XG5cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShkYXRhLCBuYW1lKSkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgZGF0YSBzZXQ6ICcgKyBuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhW25hbWVdO1xufVxuZnVuY3Rpb24gZGF0YShuYW1lLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZGF0YXJlZih0aGlzLCBuYW1lKS52YWx1ZXMudmFsdWUgOiBjaGFuZ2UuY2FsbCh0aGlzLCBuYW1lLCBjaGFuZ2VzZXQoKS5yZW1vdmUodHJ1dGh5KS5pbnNlcnQodmFsdWVzKSk7XG59XG5mdW5jdGlvbiBjaGFuZ2UobmFtZSwgY2hhbmdlcykge1xuICBpZiAoIWlzQ2hhbmdlU2V0KGNoYW5nZXMpKSB7XG4gICAgZXJyb3IoJ1NlY29uZCBhcmd1bWVudCB0byBjaGFuZ2VzIG11c3QgYmUgYSBjaGFuZ2VzZXQuJyk7XG4gIH1cblxuICBjb25zdCBkYXRhc2V0ID0gZGF0YXJlZih0aGlzLCBuYW1lKTtcbiAgZGF0YXNldC5tb2RpZmllZCA9IHRydWU7XG4gIHJldHVybiB0aGlzLnB1bHNlKGRhdGFzZXQuaW5wdXQsIGNoYW5nZXMpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KG5hbWUsIF8pIHtcbiAgcmV0dXJuIGNoYW5nZS5jYWxsKHRoaXMsIG5hbWUsIGNoYW5nZXNldCgpLmluc2VydChfKSk7XG59XG5mdW5jdGlvbiByZW1vdmUobmFtZSwgXykge1xuICByZXR1cm4gY2hhbmdlLmNhbGwodGhpcywgbmFtZSwgY2hhbmdlc2V0KCkucmVtb3ZlKF8pKTtcbn1cblxuZnVuY3Rpb24gd2lkdGgodmlldykge1xuICB2YXIgcGFkZGluZyA9IHZpZXcucGFkZGluZygpO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgdmlldy5fdmlld1dpZHRoICsgcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodCk7XG59XG5mdW5jdGlvbiBoZWlnaHQodmlldykge1xuICB2YXIgcGFkZGluZyA9IHZpZXcucGFkZGluZygpO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgdmlldy5fdmlld0hlaWdodCArIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b20pO1xufVxuZnVuY3Rpb24gb2Zmc2V0KHZpZXcpIHtcbiAgdmFyIHBhZGRpbmcgPSB2aWV3LnBhZGRpbmcoKSxcbiAgICAgIG9yaWdpbiA9IHZpZXcuX29yaWdpbjtcbiAgcmV0dXJuIFtwYWRkaW5nLmxlZnQgKyBvcmlnaW5bMF0sIHBhZGRpbmcudG9wICsgb3JpZ2luWzFdXTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZVJlbmRlcmVyKHZpZXcpIHtcbiAgdmFyIG9yaWdpbiA9IG9mZnNldCh2aWV3KSxcbiAgICAgIHcgPSB3aWR0aCh2aWV3KSxcbiAgICAgIGggPSBoZWlnaHQodmlldyk7XG5cbiAgdmlldy5fcmVuZGVyZXIuYmFja2dyb3VuZCh2aWV3LmJhY2tncm91bmQoKSk7XG5cbiAgdmlldy5fcmVuZGVyZXIucmVzaXplKHcsIGgsIG9yaWdpbik7XG5cbiAgdmlldy5faGFuZGxlci5vcmlnaW4ob3JpZ2luKTtcblxuICB2aWV3Ll9yZXNpemVMaXN0ZW5lcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICB0cnkge1xuICAgICAgaGFuZGxlcih3LCBoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdmlldy5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBFeHRlbmQgYW4gZXZlbnQgd2l0aCBhZGRpdGlvbmFsIHZpZXctc3BlY2lmaWMgbWV0aG9kcy5cbiAqIEFkZHMgYSBuZXcgcHJvcGVydHkgKCd2ZWdhJykgdG8gYW4gZXZlbnQgdGhhdCBwcm92aWRlcyBhIG51bWJlclxuICogb2YgbWV0aG9kcyBmb3IgcXVlcnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24uXG4gKiBUaGUgdmVnYSBvYmplY3QgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICogICB2aWV3IC0gUmV0dXJucyB0aGUgYmFja2luZyBWaWV3IGluc3RhbmNlLlxuICogICBpdGVtIC0gUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBzY2VuZWdyYXBoIGl0ZW0gKGlmIGFueSkuXG4gKiAgIGdyb3VwIC0gUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBzY2VuZWdyYXBoIGdyb3VwIChpZiBhbnkpLlxuICogICAgIFRoaXMgbWV0aG9kIGFjY2VwdHMgYSBzaW5nbGUgc3RyaW5nLXR5cGVkIGFyZ3VtZW50IGluZGljYXRpbmcgdGhlIG5hbWVcbiAqICAgICBvZiB0aGUgZGVzaXJlZCBwYXJlbnQgZ3JvdXAuIFRoZSBzY2VuZWdyYXBoIHdpbGwgYmUgdHJhdmVyc2VkIGZyb21cbiAqICAgICB0aGUgaXRlbSB1cCB0b3dhcmRzIHRoZSByb290IHRvIHNlYXJjaCBmb3IgYSBtYXRjaGluZyBncm91cC4gSWYgbm9cbiAqICAgICBhcmd1bWVudCBpcyBwcm92aWRlZCB0aGUgZW5jbG9zaW5nIGdyb3VwIGZvciB0aGUgYWN0aXZlIGl0ZW0gaXNcbiAqICAgICByZXR1cm5lZCwgdW5sZXNzIHRoZSBpdGVtIGl0IGl0c2VsZiBhIGdyb3VwLCBpbiB3aGljaCBjYXNlIGl0IGlzXG4gKiAgICAgcmV0dXJuZWQgZGlyZWN0bHkuXG4gKiAgIHh5IC0gUmV0dXJucyBhIHR3by1lbGVtZW50IGFycmF5IGNvbnRhaW5pbmcgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZm9yXG4gKiAgICAgbW91c2Ugb3IgdG91Y2ggZXZlbnRzLiBGb3IgdG91Y2ggZXZlbnRzLCB0aGlzIGlzIGJhc2VkIG9uIHRoZSBmaXJzdFxuICogICAgIGVsZW1lbnRzIGluIHRoZSBjaGFuZ2VkVG91Y2hlcyBhcnJheS4gVGhpcyBtZXRob2QgYWNjZXB0cyBhIHNpbmdsZVxuICogICAgIGFyZ3VtZW50OiBlaXRoZXIgYW4gaXRlbSBpbnN0YW5jZSBvciBtYXJrIG5hbWUgdGhhdCBzaG91bGQgc2VydmUgYXNcbiAqICAgICB0aGUgcmVmZXJlbmNlIGNvb3JkaW5hdGUgc3lzdGVtLiBJZiBubyBhcmd1bWVudCBpcyBwcm92aWRlZCB0aGVcbiAqICAgICB0b3AtbGV2ZWwgdmlldyBjb29yZGluYXRlIHN5c3RlbSBpcyBhc3N1bWVkLlxuICogICB4IC0gUmV0dXJucyB0aGUgY3VycmVudCB4LWNvb3JkaW5hdGUsIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHh5LlxuICogICB5IC0gUmV0dXJucyB0aGUgY3VycmVudCB5LWNvb3JkaW5hdGUsIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHh5LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgaW5wdXQgZXZlbnQgdG8gZXh0ZW5kLlxuICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIGN1cnJlbnRseSBhY3RpdmUgc2NlbmVncmFwaCBpdGVtIChpZiBhbnkpLlxuICogQHJldHVybiB7RXZlbnR9IC0gVGhlIGV4dGVuZGVkIGlucHV0IGV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIGV2ZW50RXh0ZW5kICh2aWV3LCBldmVudCwgaXRlbSkge1xuICB2YXIgciA9IHZpZXcuX3JlbmRlcmVyLFxuICAgICAgZWwgPSByICYmIHIuY2FudmFzKCksXG4gICAgICBwLFxuICAgICAgZSxcbiAgICAgIHRyYW5zbGF0ZTtcblxuICBpZiAoZWwpIHtcbiAgICB0cmFuc2xhdGUgPSBvZmZzZXQodmlldyk7XG4gICAgZSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICBwID0gcG9pbnQoZSwgZWwpO1xuICAgIHBbMF0gLT0gdHJhbnNsYXRlWzBdO1xuICAgIHBbMV0gLT0gdHJhbnNsYXRlWzFdO1xuICB9XG5cbiAgZXZlbnQuZGF0YWZsb3cgPSB2aWV3O1xuICBldmVudC5pdGVtID0gaXRlbTtcbiAgZXZlbnQudmVnYSA9IGV4dGVuc2lvbih2aWV3LCBpdGVtLCBwKTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG5mdW5jdGlvbiBleHRlbnNpb24odmlldywgaXRlbSwgcG9pbnQpIHtcbiAgY29uc3QgaXRlbUdyb3VwID0gaXRlbSA/IGl0ZW0ubWFyay5tYXJrdHlwZSA9PT0gJ2dyb3VwJyA/IGl0ZW0gOiBpdGVtLm1hcmsuZ3JvdXAgOiBudWxsO1xuXG4gIGZ1bmN0aW9uIGdyb3VwKG5hbWUpIHtcbiAgICB2YXIgZyA9IGl0ZW1Hcm91cCxcbiAgICAgICAgaTtcbiAgICBpZiAobmFtZSkgZm9yIChpID0gaXRlbTsgaTsgaSA9IGkubWFyay5ncm91cCkge1xuICAgICAgaWYgKGkubWFyay5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGcgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGcgJiYgZy5tYXJrICYmIGcubWFyay5pbnRlcmFjdGl2ZSA/IGcgOiB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHh5KGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0pIHJldHVybiBwb2ludDtcbiAgICBpZiAoaXNTdHJpbmcoaXRlbSkpIGl0ZW0gPSBncm91cChpdGVtKTtcbiAgICBjb25zdCBwID0gcG9pbnQuc2xpY2UoKTtcblxuICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICBwWzBdIC09IGl0ZW0ueCB8fCAwO1xuICAgICAgcFsxXSAtPSBpdGVtLnkgfHwgMDtcbiAgICAgIGl0ZW0gPSBpdGVtLm1hcmsgJiYgaXRlbS5tYXJrLmdyb3VwO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2aWV3OiBjb25zdGFudCh2aWV3KSxcbiAgICBpdGVtOiBjb25zdGFudChpdGVtIHx8IHt9KSxcbiAgICBncm91cDogZ3JvdXAsXG4gICAgeHk6IHh5LFxuICAgIHg6IGl0ZW0gPT4geHkoaXRlbSlbMF0sXG4gICAgeTogaXRlbSA9PiB4eShpdGVtKVsxXVxuICB9O1xufVxuXG5jb25zdCBWSUVXID0gJ3ZpZXcnLFxuICAgICAgVElNRVIgPSAndGltZXInLFxuICAgICAgV0lORE9XID0gJ3dpbmRvdycsXG4gICAgICBOT19UUkFQID0ge1xuICB0cmFwOiBmYWxzZVxufTtcbi8qKlxuICogSW5pdGlhbGl6ZSBldmVudCBoYW5kbGluZyBjb25maWd1cmF0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIHNldHRpbmdzLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVFdmVudENvbmZpZyhjb25maWcpIHtcbiAgY29uc3QgZXZlbnRzID0gZXh0ZW5kKHtcbiAgICBkZWZhdWx0czoge31cbiAgfSwgY29uZmlnKTtcblxuICBjb25zdCB1bnBhY2sgPSAob2JqLCBrZXlzKSA9PiB7XG4gICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkgb2JqW2tdID0gdG9TZXQob2JqW2tdKTtcbiAgICB9KTtcbiAgfTtcblxuICB1bnBhY2soZXZlbnRzLmRlZmF1bHRzLCBbJ3ByZXZlbnQnLCAnYWxsb3cnXSk7XG4gIHVucGFjayhldmVudHMsIFsndmlldycsICd3aW5kb3cnLCAnc2VsZWN0b3InXSk7XG4gIHJldHVybiBldmVudHM7XG59XG5mdW5jdGlvbiB0cmFja0V2ZW50TGlzdGVuZXIodmlldywgc291cmNlcywgdHlwZSwgaGFuZGxlcikge1xuICB2aWV3Ll9ldmVudExpc3RlbmVycy5wdXNoKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNvdXJjZXM6IGFycmF5KHNvdXJjZXMpLFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnQodmlldywgdHlwZSkge1xuICB2YXIgZGVmID0gdmlldy5fZXZlbnRDb25maWcuZGVmYXVsdHMsXG4gICAgICBwcmV2ZW50ID0gZGVmLnByZXZlbnQsXG4gICAgICBhbGxvdyA9IGRlZi5hbGxvdztcbiAgcmV0dXJuIHByZXZlbnQgPT09IGZhbHNlIHx8IGFsbG93ID09PSB0cnVlID8gZmFsc2UgOiBwcmV2ZW50ID09PSB0cnVlIHx8IGFsbG93ID09PSBmYWxzZSA/IHRydWUgOiBwcmV2ZW50ID8gcHJldmVudFt0eXBlXSA6IGFsbG93ID8gIWFsbG93W3R5cGVdIDogdmlldy5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBwZXJtaXQodmlldywga2V5LCB0eXBlKSB7XG4gIGNvbnN0IHJ1bGUgPSB2aWV3Ll9ldmVudENvbmZpZyAmJiB2aWV3Ll9ldmVudENvbmZpZ1trZXldO1xuXG4gIGlmIChydWxlID09PSBmYWxzZSB8fCBpc09iamVjdChydWxlKSAmJiAhcnVsZVt0eXBlXSkge1xuICAgIHZpZXcud2FybihgQmxvY2tlZCAke2tleX0gJHt0eXBlfSBldmVudCBsaXN0ZW5lci5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV2ZW50IHN0cmVhbSBmcm9tIGFuIGV2ZW50IHNvdXJjZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBUaGUgZXZlbnQgc291cmNlIHRvIG1vbml0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBib29sZWFufSBbZmlsdGVyXSAtIEV2ZW50IGZpbHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0V2ZW50U3RyZWFtfVxuICovXG5cblxuZnVuY3Rpb24gZXZlbnRzKHNvdXJjZSwgdHlwZSwgZmlsdGVyKSB7XG4gIHZhciB2aWV3ID0gdGhpcyxcbiAgICAgIHMgPSBuZXcgRXZlbnRTdHJlYW0oZmlsdGVyKSxcbiAgICAgIHNlbmQgPSBmdW5jdGlvbiAoZSwgaXRlbSkge1xuICAgIHZpZXcucnVuQXN5bmMobnVsbCwgKCkgPT4ge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gVklFVyAmJiBwcmV2ZW50KHZpZXcsIHR5cGUpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgcy5yZWNlaXZlKGV2ZW50RXh0ZW5kKHZpZXcsIGUsIGl0ZW0pKTtcbiAgICB9KTtcbiAgfSxcbiAgICAgIHNvdXJjZXM7XG5cbiAgaWYgKHNvdXJjZSA9PT0gVElNRVIpIHtcbiAgICBpZiAocGVybWl0KHZpZXcsICd0aW1lcicsIHR5cGUpKSB7XG4gICAgICB2aWV3LnRpbWVyKHNlbmQsIHR5cGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2UgPT09IFZJRVcpIHtcbiAgICBpZiAocGVybWl0KHZpZXcsICd2aWV3JywgdHlwZSkpIHtcbiAgICAgIC8vIHNlbmQgdHJhcHMgZXJyb3JzLCBzbyB1c2Uge3RyYXA6IGZhbHNlfSBvcHRpb25cbiAgICAgIHZpZXcuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzZW5kLCBOT19UUkFQKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gV0lORE9XKSB7XG4gICAgICBpZiAocGVybWl0KHZpZXcsICd3aW5kb3cnLCB0eXBlKSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzb3VyY2VzID0gW3dpbmRvd107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAocGVybWl0KHZpZXcsICdzZWxlY3RvcicsIHR5cGUpKSB7XG4gICAgICAgIHNvdXJjZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzb3VyY2VzKSB7XG4gICAgICB2aWV3Lndhcm4oJ0NhbiBub3QgcmVzb2x2ZSBldmVudCBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHNvdXJjZXNbaV0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzZW5kKTtcbiAgICAgIH1cblxuICAgICAgdHJhY2tFdmVudExpc3RlbmVyKHZpZXcsIHNvdXJjZXMsIHR5cGUsIHNlbmQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBpdGVtRmlsdGVyKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5pdGVtO1xufVxuXG5mdW5jdGlvbiBtYXJrVGFyZ2V0KGV2ZW50KSB7XG4gIC8vIGdyYWIgdXBzdHJlYW0gY29sbGVjdG9yIGZlZWRpbmcgdGhlIG1hcmsgb3BlcmF0b3JcbiAgcmV0dXJuIGV2ZW50Lml0ZW0ubWFyay5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGludm9rZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoXywgZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudmVnYS52aWV3KCkuY2hhbmdlc2V0KCkuZW5jb2RlKGV2ZW50Lml0ZW0sIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBob3ZlciAoaG92ZXJTZXQsIGxlYXZlU2V0KSB7XG4gIGhvdmVyU2V0ID0gW2hvdmVyU2V0IHx8ICdob3ZlciddO1xuICBsZWF2ZVNldCA9IFtsZWF2ZVNldCB8fCAndXBkYXRlJywgaG92ZXJTZXRbMF1dOyAvLyBpbnZva2UgaG92ZXIgc2V0IHVwb24gbW91c2VvdmVyXG5cbiAgdGhpcy5vbih0aGlzLmV2ZW50cygndmlldycsICdtb3VzZW92ZXInLCBpdGVtRmlsdGVyKSwgbWFya1RhcmdldCwgaW52b2tlKGhvdmVyU2V0KSk7IC8vIGludm9rZSBsZWF2ZSBzZXQgdXBvbiBtb3VzZW91dFxuXG4gIHRoaXMub24odGhpcy5ldmVudHMoJ3ZpZXcnLCAnbW91c2VvdXQnLCBpdGVtRmlsdGVyKSwgbWFya1RhcmdldCwgaW52b2tlKGxlYXZlU2V0KSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEZpbmFsaXplIGEgVmlldyBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHJlbW92ZWQuXG4gKiBDYW5jZWwgYW55IHJ1bm5pbmcgdGltZXJzLlxuICogUmVtb3ZlIGFsbCBleHRlcm5hbCBldmVudCBsaXN0ZW5lcnMuXG4gKiBSZW1vdmUgYW55IGN1cnJlbnRseSBkaXNwbGF5ZWQgdG9vbHRpcC5cbiAqL1xuZnVuY3Rpb24gZmluYWxpemUgKCkge1xuICB2YXIgdG9vbHRpcCA9IHRoaXMuX3Rvb2x0aXAsXG4gICAgICB0aW1lcnMgPSB0aGlzLl90aW1lcnMsXG4gICAgICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVycyxcbiAgICAgIG4sXG4gICAgICBtLFxuICAgICAgZTtcbiAgbiA9IHRpbWVycy5sZW5ndGg7XG5cbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgdGltZXJzW25dLnN0b3AoKTtcbiAgfVxuXG4gIG4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIGUgPSBsaXN0ZW5lcnNbbl07XG4gICAgbSA9IGUuc291cmNlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgIGUuc291cmNlc1ttXS5yZW1vdmVFdmVudExpc3RlbmVyKGUudHlwZSwgZS5oYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9vbHRpcCkge1xuICAgIHRvb2x0aXAuY2FsbCh0aGlzLCB0aGlzLl9oYW5kbGVyLCBudWxsLCBudWxsLCBudWxsKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50ICh0YWcsIGF0dHIsIHRleHQpIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cikgZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cltrZXldKTtcblxuICBpZiAodGV4dCAhPSBudWxsKSBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIHJldHVybiBlbDtcbn1cblxuY29uc3QgQmluZENsYXNzID0gJ3ZlZ2EtYmluZCcsXG4gICAgICBOYW1lQ2xhc3MgPSAndmVnYS1iaW5kLW5hbWUnLFxuICAgICAgUmFkaW9DbGFzcyA9ICd2ZWdhLWJpbmQtcmFkaW8nO1xuLyoqXG4gKiBCaW5kIGEgc2lnbmFsIHRvIGFuIGV4dGVybmFsIEhUTUwgaW5wdXQgZWxlbWVudC4gVGhlIHJlc3VsdGluZyB0d28td2F5XG4gKiBiaW5kaW5nIHdpbGwgcHJvcGFnYXRlIGlucHV0IGNoYW5nZXMgdG8gc2lnbmFscywgYW5kIHByb3BhZ2F0ZSBzaWduYWxcbiAqIGNoYW5nZXMgdG8gdGhlIGlucHV0IGVsZW1lbnQgc3RhdGUuIElmIHRoaXMgdmlldyBpbnN0YW5jZSBoYXMgbm8gcGFyZW50XG4gKiBlbGVtZW50LCB3ZSBhc3N1bWUgdGhlIHZpZXcgaXMgaGVhZGxlc3MgYW5kIG5vIGJpbmRpbmdzIGFyZSBjcmVhdGVkLlxuICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWwgLSBUaGUgcGFyZW50IERPTSBlbGVtZW50IHRvIHdoaWNoIHRoZSBpbnB1dFxuICogICBlbGVtZW50IHNob3VsZCBiZSBhcHBlbmRlZCBhcyBhIGNoaWxkLiBJZiBzdHJpbmctdmFsdWVkLCB0aGlzIGFyZ3VtZW50XG4gKiAgIHdpbGwgYmUgdHJlYXRlZCBhcyBhIENTUyBzZWxlY3Rvci4gSWYgbnVsbCBvciB1bmRlZmluZWQsIHRoZSBwYXJlbnRcbiAqICAgZWxlbWVudCBvZiB0aGlzIHZpZXcgd2lsbCBiZSB1c2VkIGFzIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtIC0gVGhlIGJpbmRpbmcgcGFyYW1ldGVycyB3aGljaCBzcGVjaWZ5IHRoZSBzaWduYWxcbiAqICAgdG8gYmluZCB0bywgdGhlIGlucHV0IGVsZW1lbnQgdHlwZSwgYW5kIHR5cGUtc3BlY2lmaWMgY29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm4ge1ZpZXd9IC0gVGhpcyB2aWV3IGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGJpbmQgKHZpZXcsIGVsLCBiaW5kaW5nKSB7XG4gIGlmICghZWwpIHJldHVybjtcbiAgY29uc3QgcGFyYW0gPSBiaW5kaW5nLnBhcmFtO1xuICBsZXQgYmluZCA9IGJpbmRpbmcuc3RhdGU7XG5cbiAgaWYgKCFiaW5kKSB7XG4gICAgYmluZCA9IGJpbmRpbmcuc3RhdGUgPSB7XG4gICAgICBlbGVtZW50czogbnVsbCxcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBzZXQ6IG51bGwsXG4gICAgICB1cGRhdGU6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9IHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCkpIHtcbiAgICAgICAgICB2aWV3LnJ1bkFzeW5jKG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIGJpbmQuc291cmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChwYXJhbS5kZWJvdW5jZSkge1xuICAgICAgYmluZC51cGRhdGUgPSBkZWJvdW5jZShwYXJhbS5kZWJvdW5jZSwgYmluZC51cGRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZSA9IHBhcmFtLmlucHV0ID09IG51bGwgJiYgcGFyYW0uZWxlbWVudCA/IHRhcmdldCA6IGdlbmVyYXRlO1xuICBjcmVhdGUoYmluZCwgZWwsIHBhcmFtLCB2aWV3KTtcblxuICBpZiAoIWJpbmQuYWN0aXZlKSB7XG4gICAgdmlldy5vbih2aWV3Ll9zaWduYWxzW3BhcmFtLnNpZ25hbF0sIG51bGwsICgpID0+IHtcbiAgICAgIGJpbmQuc291cmNlID8gYmluZC5zb3VyY2UgPSBmYWxzZSA6IGJpbmQuc2V0KHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCkpO1xuICAgIH0pO1xuICAgIGJpbmQuYWN0aXZlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBiaW5kO1xufVxuLyoqXG4gKiBCaW5kIHRoZSBzaWduYWwgdG8gYW4gZXh0ZXJuYWwgRXZlbnRUYXJnZXQuXG4gKi9cblxuZnVuY3Rpb24gdGFyZ2V0KGJpbmQsIG5vZGUsIHBhcmFtLCB2aWV3KSB7XG4gIGNvbnN0IHR5cGUgPSBwYXJhbS5ldmVudCB8fCAnaW5wdXQnO1xuXG4gIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiBiaW5kLnVwZGF0ZShub2RlLnZhbHVlKTsgLy8gaW5pdGlhbGl6ZSBzaWduYWwgdmFsdWUgdG8gZXh0ZXJuYWwgaW5wdXQgdmFsdWVcblxuXG4gIHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCwgbm9kZS52YWx1ZSk7IC8vIGxpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGUgZWxlbWVudFxuXG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTsgLy8gcmVnaXN0ZXIgd2l0aCB2aWV3LCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IHVwb24gZmluYWxpemF0aW9uXG5cbiAgdHJhY2tFdmVudExpc3RlbmVyKHZpZXcsIG5vZGUsIHR5cGUsIGhhbmRsZXIpOyAvLyBwcm9wYWdhdGUgY2hhbmdlIHRvIGVsZW1lbnRcblxuICBiaW5kLnNldCA9IHZhbHVlID0+IHtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KHR5cGUpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZlbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBFdmVudCh0eXBlKSA6IHtcbiAgICB0eXBlXG4gIH07XG59XG4vKipcbiAqIEdlbmVyYXRlIGFuIEhUTUwgaW5wdXQgZm9ybSBlbGVtZW50IGFuZCBiaW5kIGl0IHRvIGEgc2lnbmFsLlxuICovXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUoYmluZCwgZWwsIHBhcmFtLCB2aWV3KSB7XG4gIGNvbnN0IHZhbHVlID0gdmlldy5zaWduYWwocGFyYW0uc2lnbmFsKTtcbiAgY29uc3QgZGl2ID0gZWxlbWVudCgnZGl2Jywge1xuICAgICdjbGFzcyc6IEJpbmRDbGFzc1xuICB9KTtcbiAgY29uc3Qgd3JhcHBlciA9IHBhcmFtLmlucHV0ID09PSAncmFkaW8nID8gZGl2IDogZGl2LmFwcGVuZENoaWxkKGVsZW1lbnQoJ2xhYmVsJykpO1xuICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQoJ3NwYW4nLCB7XG4gICAgJ2NsYXNzJzogTmFtZUNsYXNzXG4gIH0sIHBhcmFtLm5hbWUgfHwgcGFyYW0uc2lnbmFsKSk7XG4gIGVsLmFwcGVuZENoaWxkKGRpdik7XG4gIGxldCBpbnB1dCA9IGZvcm07XG5cbiAgc3dpdGNoIChwYXJhbS5pbnB1dCkge1xuICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgIGlucHV0ID0gY2hlY2tib3g7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbnB1dCA9IHNlbGVjdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmFkaW8nOlxuICAgICAgaW5wdXQgPSByYWRpbztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmFuZ2UnOlxuICAgICAgaW5wdXQgPSByYW5nZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaW5wdXQoYmluZCwgd3JhcHBlciwgcGFyYW0sIHZhbHVlKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFyYml0cmFyeSBpbnB1dCBmb3JtIGVsZW1lbnQuXG4gKiBUaGUgaW5wdXQgdHlwZSBpcyBjb250cm9sbGVkIHZpYSB1c2VyLXByb3ZpZGVkIHBhcmFtZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtKGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IGVsZW1lbnQoJ2lucHV0Jyk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW0pIHtcbiAgICBpZiAoa2V5ICE9PSAnc2lnbmFsJyAmJiBrZXkgIT09ICdlbGVtZW50Jykge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5ID09PSAnaW5wdXQnID8gJ3R5cGUnIDoga2V5LCBwYXJhbVtrZXldKTtcbiAgICB9XG4gIH1cblxuICBub2RlLnNldEF0dHJpYnV0ZSgnbmFtZScsIHBhcmFtLnNpZ25hbCk7XG4gIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiBiaW5kLnVwZGF0ZShub2RlLnZhbHVlKSk7XG4gIGJpbmQuZWxlbWVudHMgPSBbbm9kZV07XG5cbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiBub2RlLnZhbHVlID0gdmFsdWU7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGNoZWNrYm94IGlucHV0IGVsZW1lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBjaGVja2JveChiaW5kLCBlbCwgcGFyYW0sIHZhbHVlKSB7XG4gIGNvbnN0IGF0dHIgPSB7XG4gICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICBuYW1lOiBwYXJhbS5zaWduYWxcbiAgfTtcbiAgaWYgKHZhbHVlKSBhdHRyLmNoZWNrZWQgPSB0cnVlO1xuICBjb25zdCBub2RlID0gZWxlbWVudCgnaW5wdXQnLCBhdHRyKTtcbiAgZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4gYmluZC51cGRhdGUobm9kZS5jaGVja2VkKSk7XG4gIGJpbmQuZWxlbWVudHMgPSBbbm9kZV07XG5cbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiBub2RlLmNoZWNrZWQgPSAhIXZhbHVlIHx8IG51bGw7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHNlbGVjdGlvbiBsaXN0IGlucHV0IGVsZW1lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBzZWxlY3QoYmluZCwgZWwsIHBhcmFtLCB2YWx1ZSkge1xuICBjb25zdCBub2RlID0gZWxlbWVudCgnc2VsZWN0Jywge1xuICAgIG5hbWU6IHBhcmFtLnNpZ25hbFxuICB9KSxcbiAgICAgICAgbGFiZWxzID0gcGFyYW0ubGFiZWxzIHx8IFtdO1xuICBwYXJhbS5vcHRpb25zLmZvckVhY2goKG9wdGlvbiwgaSkgPT4ge1xuICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICB2YWx1ZTogb3B0aW9uXG4gICAgfTtcbiAgICBpZiAodmFsdWVzRXF1YWwob3B0aW9uLCB2YWx1ZSkpIGF0dHIuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudCgnb3B0aW9uJywgYXR0ciwgKGxhYmVsc1tpXSB8fCBvcHRpb24pICsgJycpKTtcbiAgfSk7XG4gIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICBiaW5kLnVwZGF0ZShwYXJhbS5vcHRpb25zW25vZGUuc2VsZWN0ZWRJbmRleF0pO1xuICB9KTtcbiAgYmluZC5lbGVtZW50cyA9IFtub2RlXTtcblxuICBiaW5kLnNldCA9IHZhbHVlID0+IHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHBhcmFtLm9wdGlvbnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAodmFsdWVzRXF1YWwocGFyYW0ub3B0aW9uc1tpXSwgdmFsdWUpKSB7XG4gICAgICAgIG5vZGUuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhZGlvIGJ1dHRvbiBncm91cC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJhZGlvKGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgY29uc3QgZ3JvdXAgPSBlbGVtZW50KCdzcGFuJywge1xuICAgICdjbGFzcyc6IFJhZGlvQ2xhc3NcbiAgfSksXG4gICAgICAgIGxhYmVscyA9IHBhcmFtLmxhYmVscyB8fCBbXTtcbiAgZWwuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICBiaW5kLmVsZW1lbnRzID0gcGFyYW0ub3B0aW9ucy5tYXAoKG9wdGlvbiwgaSkgPT4ge1xuICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICB0eXBlOiAncmFkaW8nLFxuICAgICAgbmFtZTogcGFyYW0uc2lnbmFsLFxuICAgICAgdmFsdWU6IG9wdGlvblxuICAgIH07XG4gICAgaWYgKHZhbHVlc0VxdWFsKG9wdGlvbiwgdmFsdWUpKSBhdHRyLmNoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlucHV0ID0gZWxlbWVudCgnaW5wdXQnLCBhdHRyKTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiBiaW5kLnVwZGF0ZShvcHRpb24pKTtcbiAgICBjb25zdCBsYWJlbCA9IGVsZW1lbnQoJ2xhYmVsJywge30sIChsYWJlbHNbaV0gfHwgb3B0aW9uKSArICcnKTtcbiAgICBsYWJlbC5wcmVwZW5kKGlucHV0KTtcbiAgICBncm91cC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9KTtcblxuICBiaW5kLnNldCA9IHZhbHVlID0+IHtcbiAgICBjb25zdCBub2RlcyA9IGJpbmQuZWxlbWVudHMsXG4gICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAodmFsdWVzRXF1YWwobm9kZXNbaV0udmFsdWUsIHZhbHVlKSkgbm9kZXNbaV0uY2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzbGlkZXIgaW5wdXQgZWxlbWVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJhbmdlKGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgdmFsdWUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiAoK3BhcmFtLm1heCArICtwYXJhbS5taW4pIC8gMjtcbiAgY29uc3QgbWF4ID0gcGFyYW0ubWF4ICE9IG51bGwgPyBwYXJhbS5tYXggOiBNYXRoLm1heCgxMDAsICt2YWx1ZSkgfHwgMTAwLFxuICAgICAgICBtaW4gPSBwYXJhbS5taW4gfHwgTWF0aC5taW4oMCwgbWF4LCArdmFsdWUpIHx8IDAsXG4gICAgICAgIHN0ZXAgPSBwYXJhbS5zdGVwIHx8IHRpY2tTdGVwKG1pbiwgbWF4LCAxMDApO1xuICBjb25zdCBub2RlID0gZWxlbWVudCgnaW5wdXQnLCB7XG4gICAgdHlwZTogJ3JhbmdlJyxcbiAgICBuYW1lOiBwYXJhbS5zaWduYWwsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXgsXG4gICAgc3RlcDogc3RlcFxuICB9KTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBjb25zdCBzcGFuID0gZWxlbWVudCgnc3BhbicsIHt9LCArdmFsdWUpO1xuICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgZWwuYXBwZW5kQ2hpbGQoc3Bhbik7XG5cbiAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgIHNwYW4udGV4dENvbnRlbnQgPSBub2RlLnZhbHVlO1xuICAgIGJpbmQudXBkYXRlKCtub2RlLnZhbHVlKTtcbiAgfTsgLy8gc3Vic2NyaWJlIHRvIGJvdGggaW5wdXQgYW5kIGNoYW5nZVxuXG5cbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZSk7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlKTtcbiAgYmluZC5lbGVtZW50cyA9IFtub2RlXTtcblxuICBiaW5kLnNldCA9IHZhbHVlID0+IHtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgc3Bhbi50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB2YWx1ZXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IGEgKyAnJyA9PT0gYiArICcnO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUmVuZGVyZXIgKHZpZXcsIHIsIGVsLCBjb25zdHJ1Y3Rvciwgc2NhbGVGYWN0b3IsIG9wdCkge1xuICByID0gciB8fCBuZXcgY29uc3RydWN0b3Iodmlldy5sb2FkZXIoKSk7XG4gIHJldHVybiByLmluaXRpYWxpemUoZWwsIHdpZHRoKHZpZXcpLCBoZWlnaHQodmlldyksIG9mZnNldCh2aWV3KSwgc2NhbGVGYWN0b3IsIG9wdCkuYmFja2dyb3VuZCh2aWV3LmJhY2tncm91bmQoKSk7XG59XG5cbmZ1bmN0aW9uIHRyYXAgKHZpZXcsIGZuKSB7XG4gIHJldHVybiAhZm4gPyBudWxsIDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB2aWV3LmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVIYW5kbGVyICh2aWV3LCBwcmV2SGFuZGxlciwgZWwsIGNvbnN0cnVjdG9yKSB7XG4gIC8vIGluc3RhbnRpYXRlIHNjZW5lZ3JhcGggaGFuZGxlclxuICBjb25zdCBoYW5kbGVyID0gbmV3IGNvbnN0cnVjdG9yKHZpZXcubG9hZGVyKCksIHRyYXAodmlldywgdmlldy50b29sdGlwKCkpKS5zY2VuZSh2aWV3LnNjZW5lZ3JhcGgoKS5yb290KS5pbml0aWFsaXplKGVsLCBvZmZzZXQodmlldyksIHZpZXcpOyAvLyB0cmFuc2ZlciBldmVudCBoYW5kbGVyc1xuXG4gIGlmIChwcmV2SGFuZGxlcikge1xuICAgIHByZXZIYW5kbGVyLmhhbmRsZXJzKCkuZm9yRWFjaChoID0+IHtcbiAgICAgIGhhbmRsZXIub24oaC50eXBlLCBoLmhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXI7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUgKGVsLCBlbEJpbmQpIHtcbiAgY29uc3QgdmlldyA9IHRoaXMsXG4gICAgICAgIHR5cGUgPSB2aWV3Ll9yZW5kZXJUeXBlLFxuICAgICAgICBjb25maWcgPSB2aWV3Ll9ldmVudENvbmZpZy5iaW5kLFxuICAgICAgICBtb2R1bGUgPSByZW5kZXJNb2R1bGUodHlwZSk7IC8vIGNvbnRhaW5pbmcgZG9tIGVsZW1lbnRcblxuICBlbCA9IHZpZXcuX2VsID0gZWwgPyBsb29rdXAodmlldywgZWwsIHRydWUpIDogbnVsbDsgLy8gaW5pdGlhbGl6ZSBhcmlhIGF0dHJpYnV0ZXNcblxuICBpbml0aWFsaXplQXJpYSh2aWV3KTsgLy8gc2VsZWN0IGFwcHJvcHJpYXRlIHJlbmRlcmVyICYgaGFuZGxlclxuXG4gIGlmICghbW9kdWxlKSB2aWV3LmVycm9yKCdVbnJlY29nbml6ZWQgcmVuZGVyZXIgdHlwZTogJyArIHR5cGUpO1xuICBjb25zdCBIYW5kbGVyID0gbW9kdWxlLmhhbmRsZXIgfHwgQ2FudmFzSGFuZGxlcixcbiAgICAgICAgUmVuZGVyZXIgPSBlbCA/IG1vZHVsZS5yZW5kZXJlciA6IG1vZHVsZS5oZWFkbGVzczsgLy8gaW5pdGlhbGl6ZSByZW5kZXJlciBhbmQgaW5wdXQgaGFuZGxlclxuXG4gIHZpZXcuX3JlbmRlcmVyID0gIVJlbmRlcmVyID8gbnVsbCA6IGluaXRpYWxpemVSZW5kZXJlcih2aWV3LCB2aWV3Ll9yZW5kZXJlciwgZWwsIFJlbmRlcmVyKTtcbiAgdmlldy5faGFuZGxlciA9IGluaXRpYWxpemVIYW5kbGVyKHZpZXcsIHZpZXcuX2hhbmRsZXIsIGVsLCBIYW5kbGVyKTtcbiAgdmlldy5fcmVkcmF3ID0gdHJ1ZTsgLy8gaW5pdGlhbGl6ZSBzaWduYWwgYmluZGluZ3NcblxuICBpZiAoZWwgJiYgY29uZmlnICE9PSAnbm9uZScpIHtcbiAgICBlbEJpbmQgPSBlbEJpbmQgPyB2aWV3Ll9lbEJpbmQgPSBsb29rdXAodmlldywgZWxCaW5kLCB0cnVlKSA6IGVsLmFwcGVuZENoaWxkKGVsZW1lbnQoJ2Zvcm0nLCB7XG4gICAgICAnY2xhc3MnOiAndmVnYS1iaW5kaW5ncydcbiAgICB9KSk7XG5cbiAgICB2aWV3Ll9iaW5kLmZvckVhY2goXyA9PiB7XG4gICAgICBpZiAoXy5wYXJhbS5lbGVtZW50ICYmIGNvbmZpZyAhPT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgXy5lbGVtZW50ID0gbG9va3VwKHZpZXcsIF8ucGFyYW0uZWxlbWVudCwgISFfLnBhcmFtLmlucHV0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZpZXcuX2JpbmQuZm9yRWFjaChfID0+IHtcbiAgICAgIGJpbmQodmlldywgXy5lbGVtZW50IHx8IGVsQmluZCwgXyk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmlldztcbn1cblxuZnVuY3Rpb24gbG9va3VwKHZpZXcsIGVsLCBjbGVhcikge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIHZpZXcuZXJyb3IoJ1NpZ25hbCBiaW5kIGVsZW1lbnQgbm90IGZvdW5kOiAnICsgZWwpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5lcnJvcignRE9NIGRvY3VtZW50IGluc3RhbmNlIG5vdCBmb3VuZC4nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbCAmJiBjbGVhcikge1xuICAgIHRyeSB7XG4gICAgICBlbC5pbm5lckhUTUwgPSAnJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlbCA9IG51bGw7XG4gICAgICB2aWV3LmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuY29uc3QgbnVtYmVyID0gXyA9PiArXyB8fCAwO1xuXG5jb25zdCBwYWRkaW5nT2JqZWN0ID0gXyA9PiAoe1xuICB0b3A6IF8sXG4gIGJvdHRvbTogXyxcbiAgbGVmdDogXyxcbiAgcmlnaHQ6IF9cbn0pO1xuXG5mdW5jdGlvbiBwYWRkaW5nIChfKSB7XG4gIHJldHVybiBpc09iamVjdChfKSA/IHtcbiAgICB0b3A6IG51bWJlcihfLnRvcCksXG4gICAgYm90dG9tOiBudW1iZXIoXy5ib3R0b20pLFxuICAgIGxlZnQ6IG51bWJlcihfLmxlZnQpLFxuICAgIHJpZ2h0OiBudW1iZXIoXy5yaWdodClcbiAgfSA6IHBhZGRpbmdPYmplY3QobnVtYmVyKF8pKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIGN1cnJlbnQgc2NlbmUgaW4gYSBoZWFkbGVzcyBmYXNoaW9uLlxuICogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCByZXR1cm5pbmcgYSBQcm9taXNlIGluc3RhbmNlLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHJlbmRlcmVyLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlckhlYWRsZXNzICh2aWV3LCB0eXBlLCBzY2FsZUZhY3Rvciwgb3B0KSB7XG4gIGNvbnN0IG1vZHVsZSA9IHJlbmRlck1vZHVsZSh0eXBlKSxcbiAgICAgICAgY3RyID0gbW9kdWxlICYmIG1vZHVsZS5oZWFkbGVzcztcbiAgaWYgKCFjdHIpIGVycm9yKCdVbnJlY29nbml6ZWQgcmVuZGVyZXIgdHlwZTogJyArIHR5cGUpO1xuICBhd2FpdCB2aWV3LnJ1bkFzeW5jKCk7XG4gIHJldHVybiBpbml0aWFsaXplUmVuZGVyZXIodmlldywgbnVsbCwgbnVsbCwgY3RyLCBzY2FsZUZhY3Rvciwgb3B0KS5yZW5kZXJBc3luYyh2aWV3Ll9zY2VuZWdyYXBoLnJvb3QpO1xufVxuXG4vKipcbiAqIFByb2R1Y2UgYW4gaW1hZ2UgVVJMIGZvciB0aGUgdmlzdWFsaXphdGlvbi4gRGVwZW5kaW5nIG9uIHRoZSB0eXBlXG4gKiBwYXJhbWV0ZXIsIHRoZSBnZW5lcmF0ZWQgVVJMIGNvbnRhaW5zIGRhdGEgZm9yIGVpdGhlciBhIFBORyBvciBTVkcgaW1hZ2UuXG4gKiBUaGUgVVJMIGNhbiBiZSB1c2VkIChmb3IgZXhhbXBsZSkgdG8gZG93bmxvYWQgaW1hZ2VzIG9mIHRoZSB2aXN1YWxpemF0aW9uLlxuICogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCByZXR1cm5pbmcgYSBQcm9taXNlIGluc3RhbmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgaW1hZ2UgdHlwZS4gT25lIG9mICdzdmcnLCAncG5nJyBvciAnY2FudmFzJy5cbiAqICAgVGhlICdjYW52YXMnIGFuZCAncG5nJyB0eXBlcyBhcmUgc3lub255bXMgZm9yIGEgUE5HIGltYWdlLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBpbWFnZSBVUkwuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyVG9JbWFnZVVSTCAodHlwZSwgc2NhbGVGYWN0b3IpIHtcbiAgaWYgKHR5cGUgIT09IFJlbmRlclR5cGUuQ2FudmFzICYmIHR5cGUgIT09IFJlbmRlclR5cGUuU1ZHICYmIHR5cGUgIT09IFJlbmRlclR5cGUuUE5HKSB7XG4gICAgZXJyb3IoJ1VucmVjb2duaXplZCBpbWFnZSB0eXBlOiAnICsgdHlwZSk7XG4gIH1cblxuICBjb25zdCByID0gYXdhaXQgcmVuZGVySGVhZGxlc3ModGhpcywgdHlwZSwgc2NhbGVGYWN0b3IpO1xuICByZXR1cm4gdHlwZSA9PT0gUmVuZGVyVHlwZS5TVkcgPyB0b0Jsb2JVUkwoci5zdmcoKSwgJ2ltYWdlL3N2Zyt4bWwnKSA6IHIuY2FudmFzKCkudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbn1cblxuZnVuY3Rpb24gdG9CbG9iVVJMKGRhdGEsIG1pbWUpIHtcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgIHR5cGU6IG1pbWVcbiAgfSk7XG4gIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgQ2FudmFzIGluc3RhbmNlIGNvbnRhaW5pbmcgYSByZW5kZXJlZCB2aXN1YWxpemF0aW9uLlxuICogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCByZXR1cm5pbmcgYSBQcm9taXNlIGluc3RhbmNlLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIENhbnZhcyBpbnN0YW5jZS5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiByZW5kZXJUb0NhbnZhcyAoc2NhbGVGYWN0b3IsIG9wdCkge1xuICBjb25zdCByID0gYXdhaXQgcmVuZGVySGVhZGxlc3ModGhpcywgUmVuZGVyVHlwZS5DYW52YXMsIHNjYWxlRmFjdG9yLCBvcHQpO1xuICByZXR1cm4gci5jYW52YXMoKTtcbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgcmVuZGVyZWQgU1ZHIHN0cmluZyBvZiB0aGUgdmlzdWFsaXphdGlvbi5cbiAqIFRoaXMgbWV0aG9kIGlzIGFzeW5jaHJvbm91cywgcmV0dXJuaW5nIGEgUHJvbWlzZSBpbnN0YW5jZS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gU1ZHIHN0cmluZy5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiByZW5kZXJUb1NWRyAoc2NhbGVGYWN0b3IpIHtcbiAgY29uc3QgciA9IGF3YWl0IHJlbmRlckhlYWRsZXNzKHRoaXMsIFJlbmRlclR5cGUuU1ZHLCBzY2FsZUZhY3Rvcik7XG4gIHJldHVybiByLnN2ZygpO1xufVxuXG5mdW5jdGlvbiBydW50aW1lICh2aWV3LCBzcGVjLCBleHByKSB7XG4gIHJldHVybiBjb250ZXh0KHZpZXcsIHRyYW5zZm9ybXMsIGZ1bmN0aW9uQ29udGV4dCwgZXhwcikucGFyc2Uoc3BlYyk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlKG5hbWUpIHtcbiAgdmFyIHNjYWxlcyA9IHRoaXMuX3J1bnRpbWUuc2NhbGVzO1xuXG4gIGlmICghaGFzT3duUHJvcGVydHkoc2NhbGVzLCBuYW1lKSkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgc2NhbGUgb3IgcHJvamVjdGlvbjogJyArIG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHNjYWxlc1tuYW1lXS52YWx1ZTtcbn1cblxudmFyIFdpZHRoID0gJ3dpZHRoJyxcbiAgICBIZWlnaHQgPSAnaGVpZ2h0JyxcbiAgICBQYWRkaW5nID0gJ3BhZGRpbmcnLFxuICAgIFNraXAgPSB7XG4gIHNraXA6IHRydWVcbn07XG5mdW5jdGlvbiB2aWV3V2lkdGgodmlldywgd2lkdGgpIHtcbiAgdmFyIGEgPSB2aWV3LmF1dG9zaXplKCksXG4gICAgICBwID0gdmlldy5wYWRkaW5nKCk7XG4gIHJldHVybiB3aWR0aCAtIChhICYmIGEuY29udGFpbnMgPT09IFBhZGRpbmcgPyBwLmxlZnQgKyBwLnJpZ2h0IDogMCk7XG59XG5mdW5jdGlvbiB2aWV3SGVpZ2h0KHZpZXcsIGhlaWdodCkge1xuICB2YXIgYSA9IHZpZXcuYXV0b3NpemUoKSxcbiAgICAgIHAgPSB2aWV3LnBhZGRpbmcoKTtcbiAgcmV0dXJuIGhlaWdodCAtIChhICYmIGEuY29udGFpbnMgPT09IFBhZGRpbmcgPyBwLnRvcCArIHAuYm90dG9tIDogMCk7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplUmVzaXplKHZpZXcpIHtcbiAgdmFyIHMgPSB2aWV3Ll9zaWduYWxzLFxuICAgICAgdyA9IHNbV2lkdGhdLFxuICAgICAgaCA9IHNbSGVpZ2h0XSxcbiAgICAgIHAgPSBzW1BhZGRpbmddO1xuXG4gIGZ1bmN0aW9uIHJlc2V0U2l6ZSgpIHtcbiAgICB2aWV3Ll9hdXRvc2l6ZSA9IHZpZXcuX3Jlc2l6ZSA9IDE7XG4gIH0gLy8gcmVzcG9uZCB0byB3aWR0aCBzaWduYWxcblxuXG4gIHZpZXcuX3Jlc2l6ZVdpZHRoID0gdmlldy5hZGQobnVsbCwgXyA9PiB7XG4gICAgdmlldy5fd2lkdGggPSBfLnNpemU7XG4gICAgdmlldy5fdmlld1dpZHRoID0gdmlld1dpZHRoKHZpZXcsIF8uc2l6ZSk7XG4gICAgcmVzZXRTaXplKCk7XG4gIH0sIHtcbiAgICBzaXplOiB3XG4gIH0pOyAvLyByZXNwb25kIHRvIGhlaWdodCBzaWduYWxcblxuICB2aWV3Ll9yZXNpemVIZWlnaHQgPSB2aWV3LmFkZChudWxsLCBfID0+IHtcbiAgICB2aWV3Ll9oZWlnaHQgPSBfLnNpemU7XG4gICAgdmlldy5fdmlld0hlaWdodCA9IHZpZXdIZWlnaHQodmlldywgXy5zaXplKTtcbiAgICByZXNldFNpemUoKTtcbiAgfSwge1xuICAgIHNpemU6IGhcbiAgfSk7IC8vIHJlc3BvbmQgdG8gcGFkZGluZyBzaWduYWxcblxuICBjb25zdCByZXNpemVQYWRkaW5nID0gdmlldy5hZGQobnVsbCwgcmVzZXRTaXplLCB7XG4gICAgcGFkOiBwXG4gIH0pOyAvLyBzZXQgcmFuayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgc291cmNlIHNpZ25hbFxuXG4gIHZpZXcuX3Jlc2l6ZVdpZHRoLnJhbmsgPSB3LnJhbmsgKyAxO1xuICB2aWV3Ll9yZXNpemVIZWlnaHQucmFuayA9IGgucmFuayArIDE7XG4gIHJlc2l6ZVBhZGRpbmcucmFuayA9IHAucmFuayArIDE7XG59XG5mdW5jdGlvbiByZXNpemVWaWV3KHZpZXdXaWR0aCwgdmlld0hlaWdodCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBhdXRvKSB7XG4gIHRoaXMucnVuQWZ0ZXIodmlldyA9PiB7XG4gICAgbGV0IHJlcnVuID0gMDsgLy8gcmVzZXQgYXV0b3NpemUgZmxhZ1xuXG4gICAgdmlldy5fYXV0b3NpemUgPSAwOyAvLyB3aWR0aCB2YWx1ZSBjaGFuZ2VkOiB1cGRhdGUgc2lnbmFsLCBza2lwIHJlc2l6ZSBvcFxuXG4gICAgaWYgKHZpZXcud2lkdGgoKSAhPT0gd2lkdGgpIHtcbiAgICAgIHJlcnVuID0gMTtcbiAgICAgIHZpZXcuc2lnbmFsKFdpZHRoLCB3aWR0aCwgU2tpcCk7IC8vIHNldCB3aWR0aCwgc2tpcCB1cGRhdGUgY2FsY1xuXG4gICAgICB2aWV3Ll9yZXNpemVXaWR0aC5za2lwKHRydWUpOyAvLyBza2lwIHdpZHRoIHJlc2l6ZSBoYW5kbGVyXG5cbiAgICB9IC8vIGhlaWdodCB2YWx1ZSBjaGFuZ2VkOiB1cGRhdGUgc2lnbmFsLCBza2lwIHJlc2l6ZSBvcFxuXG5cbiAgICBpZiAodmlldy5oZWlnaHQoKSAhPT0gaGVpZ2h0KSB7XG4gICAgICByZXJ1biA9IDE7XG4gICAgICB2aWV3LnNpZ25hbChIZWlnaHQsIGhlaWdodCwgU2tpcCk7IC8vIHNldCBoZWlnaHQsIHNraXAgdXBkYXRlIGNhbGNcblxuICAgICAgdmlldy5fcmVzaXplSGVpZ2h0LnNraXAodHJ1ZSk7IC8vIHNraXAgaGVpZ2h0IHJlc2l6ZSBoYW5kbGVyXG5cbiAgICB9IC8vIHZpZXcgd2lkdGggY2hhbmdlZDogdXBkYXRlIHZpZXcgcHJvcGVydHksIHNldCByZXNpemUgZmxhZ1xuXG5cbiAgICBpZiAodmlldy5fdmlld1dpZHRoICE9PSB2aWV3V2lkdGgpIHtcbiAgICAgIHZpZXcuX3Jlc2l6ZSA9IDE7XG4gICAgICB2aWV3Ll92aWV3V2lkdGggPSB2aWV3V2lkdGg7XG4gICAgfSAvLyB2aWV3IGhlaWdodCBjaGFuZ2VkOiB1cGRhdGUgdmlldyBwcm9wZXJ0eSwgc2V0IHJlc2l6ZSBmbGFnXG5cblxuICAgIGlmICh2aWV3Ll92aWV3SGVpZ2h0ICE9PSB2aWV3SGVpZ2h0KSB7XG4gICAgICB2aWV3Ll9yZXNpemUgPSAxO1xuICAgICAgdmlldy5fdmlld0hlaWdodCA9IHZpZXdIZWlnaHQ7XG4gICAgfSAvLyBvcmlnaW4gY2hhbmdlZDogdXBkYXRlIHZpZXcgcHJvcGVydHksIHNldCByZXNpemUgZmxhZ1xuXG5cbiAgICBpZiAodmlldy5fb3JpZ2luWzBdICE9PSBvcmlnaW5bMF0gfHwgdmlldy5fb3JpZ2luWzFdICE9PSBvcmlnaW5bMV0pIHtcbiAgICAgIHZpZXcuX3Jlc2l6ZSA9IDE7XG4gICAgICB2aWV3Ll9vcmlnaW4gPSBvcmlnaW47XG4gICAgfSAvLyBydW4gZGF0YWZsb3cgb24gd2lkdGgvaGVpZ2h0IHNpZ25hbCBjaGFuZ2VcblxuXG4gICAgaWYgKHJlcnVuKSB2aWV3LnJ1bignZW50ZXInKTtcbiAgICBpZiAoYXV0bykgdmlldy5ydW5BZnRlcih2ID0+IHYucmVzaXplKCkpO1xuICB9LCBmYWxzZSwgMSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZpZXcgc3RhdGUsIGNvbnNpc3Rpbmcgb2Ygc2lnbmFsIHZhbHVlcyBhbmQvb3IgZGF0YSBzZXRzLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZmxhZ3MgaW5kaWNhdGluZyB3aGljaCBzdGF0ZSB0byBleHBvcnQuXG4gKiAgIElmIHVuc3BlY2lmaWVkLCBhbGwgc2lnbmFscyBhbmQgZGF0YSBzZXRzIHdpbGwgYmUgZXhwb3J0ZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgT3BlcmF0b3IpOmJvb2xlYW59IFtvcHRpb25zLnNpZ25hbHNdIC0gT3B0aW9uYWxcbiAqICAgcHJlZGljYXRlIGZ1bmN0aW9uIGZvciB0ZXN0aW5nIGlmIGEgc2lnbmFsIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGVcbiAqICAgZXhwb3J0ZWQgc3RhdGUuIElmIHVuc3BlY2lmaWVkLCBhbGwgc2lnbmFscyB3aWxsIGJlIGluY2x1ZGVkLCBleGNlcHQgZm9yXG4gKiAgIHRob3NlIG5hbWVkICdwYXJlbnQnIG9yIHRob3NlIHdoaWNoIHJlZmVyIHRvIGEgVHJhbnNmb3JtIHZhbHVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCk6Ym9vbGVhbn0gW29wdGlvbnMuZGF0YV0gLSBPcHRpb25hbFxuICogICBwcmVkaWNhdGUgZnVuY3Rpb24gZm9yIHRlc3RpbmcgaWYgYSBkYXRhIHNldCdzIGlucHV0IHNob3VsZCBiZSBpbmNsdWRlZFxuICogICBpbiB0aGUgZXhwb3J0ZWQgc3RhdGUuIElmIHVuc3BlY2lmaWVkLCBhbGwgZGF0YSBzZXRzIHRoYXQgaGF2ZSBiZWVuXG4gKiAgIGV4cGxpY2l0bHkgbW9kaWZpZWQgd2lsbCBiZSBpbmNsdWRlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVjdXJzZT10cnVlXSAtIEZsYWcgaW5kaWNhdGluZyBpZiB0aGUgZXhwb3J0ZWRcbiAqICAgc3RhdGUgc2hvdWxkIHJlY3Vyc2l2ZWx5IGluY2x1ZGUgc3RhdGUgZnJvbSBncm91cCBtYXJrIHN1Yi1jb250ZXh0cy5cbiAqIEByZXR1cm4ge29iamVjdH0gLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXhwb3J0ZWQgc3RhdGUgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIGdldFN0YXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuX3J1bnRpbWUuZ2V0U3RhdGUob3B0aW9ucyB8fCB7XG4gICAgZGF0YTogZGF0YVRlc3QsXG4gICAgc2lnbmFsczogc2lnbmFsVGVzdCxcbiAgICByZWN1cnNlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkYXRhVGVzdChuYW1lLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLm1vZGlmaWVkICYmIGlzQXJyYXkoZGF0YS5pbnB1dC52YWx1ZSkgJiYgbmFtZS5pbmRleE9mKCdfOnZlZ2E6XycpO1xufVxuXG5mdW5jdGlvbiBzaWduYWxUZXN0KG5hbWUsIG9wKSB7XG4gIHJldHVybiAhKG5hbWUgPT09ICdwYXJlbnQnIHx8IG9wIGluc3RhbmNlb2YgdHJhbnNmb3Jtcy5wcm94eSk7XG59XG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdmlldyBzdGF0ZSBhbmQgdXBkYXRlcyB0aGUgdmlldyBieSBpbnZva2luZyBydW4uXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBBIHN0YXRlIG9iamVjdCBjb250YWluaW5nIHNpZ25hbCBhbmQvb3JcbiAqICAgZGF0YSBzZXQgdmFsdWVzLCBmb2xsb3dpbmcgdGhlIGZvcm1hdCB1c2VkIGJ5IHRoZSBnZXRTdGF0ZSBtZXRob2QuXG4gKiBAcmV0dXJuIHtWaWV3fSAtIFRoaXMgdmlldyBpbnN0YW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gIHRoaXMucnVuQXN5bmMobnVsbCwgdiA9PiB7XG4gICAgdi5fdHJpZ2dlciA9IGZhbHNlO1xuXG4gICAgdi5fcnVudGltZS5zZXRTdGF0ZShzdGF0ZSk7XG4gIH0sIHYgPT4ge1xuICAgIHYuX3RyaWdnZXIgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRpbWVyIChjYWxsYmFjaywgZGVsYXkpIHtcbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgY2FsbGJhY2soe1xuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgZWxhcHNlZDogZWxhcHNlZFxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5fdGltZXJzLnB1c2goaW50ZXJ2YWwodGljaywgZGVsYXkpKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvb2x0aXAgKGhhbmRsZXIsIGV2ZW50LCBpdGVtLCB2YWx1ZSkge1xuICBjb25zdCBlbCA9IGhhbmRsZXIuZWxlbWVudCgpO1xuICBpZiAoZWwpIGVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBmb3JtYXRUb29sdGlwKHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRvb2x0aXAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGlzQXJyYXkodmFsdWUpID8gZm9ybWF0QXJyYXkodmFsdWUpIDogaXNPYmplY3QodmFsdWUpICYmICFpc0RhdGUodmFsdWUpID8gZm9ybWF0T2JqZWN0KHZhbHVlKSA6IHZhbHVlICsgJyc7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGtleSA9PiB7XG4gICAgY29uc3QgdiA9IG9ialtrZXldO1xuICAgIHJldHVybiBrZXkgKyAnOiAnICsgKGlzQXJyYXkodikgPyBmb3JtYXRBcnJheSh2KSA6IGZvcm1hdFZhbHVlKHYpKTtcbiAgfSkuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyB2YWx1ZS5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oJywgJykgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/ICdbXFx1MjAyNl0nIDogaXNPYmplY3QodmFsdWUpICYmICFpc0RhdGUodmFsdWUpID8gJ3tcXHUyMDI2fScgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVmlldyBpbnN0YW5jZSBmcm9tIGEgVmVnYSBkYXRhZmxvdyBydW50aW1lIHNwZWNpZmljYXRpb24uXG4gKiBUaGUgZ2VuZXJhdGVkIFZpZXcgd2lsbCBub3QgaW1tZWRpYXRlbHkgYmUgcmVhZHkgZm9yIGRpc3BsYXkuIENhbGxlcnNcbiAqIHNob3VsZCBhbHNvIGludm9rZSB0aGUgaW5pdGlhbGl6ZSBtZXRob2QgKGUuZy4sIHRvIHNldCB0aGUgcGFyZW50XG4gKiBET00gZWxlbWVudCBpbiBicm93c2VyLWJhc2VkIGRlcGxveW1lbnQpIGFuZCB0aGVuIGludm9rZSB0aGUgcnVuXG4gKiBtZXRob2QgdG8gZXZhbHVhdGUgdGhlIGRhdGFmbG93IGdyYXBoLiBSZW5kZXJpbmcgd2lsbCBhdXRvbWF0aWNhbGx5XG4gKiBiZSBwZXJmb3JtZWQgdXBvbiBkYXRhZmxvdyBydW5zLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gc3BlYyAtIFRoZSBWZWdhIGRhdGFmbG93IHJ1bnRpbWUgc3BlY2lmaWNhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBWaWV3KHNwZWMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdmlldyA9IHRoaXM7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBEYXRhZmxvdy5jYWxsKHZpZXcpO1xuICBpZiAob3B0aW9ucy5sb2FkZXIpIHZpZXcubG9hZGVyKG9wdGlvbnMubG9hZGVyKTtcbiAgaWYgKG9wdGlvbnMubG9nZ2VyKSB2aWV3LmxvZ2dlcihvcHRpb25zLmxvZ2dlcik7XG4gIGlmIChvcHRpb25zLmxvZ0xldmVsICE9IG51bGwpIHZpZXcubG9nTGV2ZWwob3B0aW9ucy5sb2dMZXZlbCk7XG5cbiAgaWYgKG9wdGlvbnMubG9jYWxlIHx8IHNwZWMubG9jYWxlKSB7XG4gICAgY29uc3QgbG9jID0gZXh0ZW5kKHt9LCBzcGVjLmxvY2FsZSwgb3B0aW9ucy5sb2NhbGUpO1xuICAgIHZpZXcubG9jYWxlKGxvY2FsZShsb2MubnVtYmVyLCBsb2MudGltZSkpO1xuICB9XG5cbiAgdmlldy5fZWwgPSBudWxsO1xuICB2aWV3Ll9lbEJpbmQgPSBudWxsO1xuICB2aWV3Ll9yZW5kZXJUeXBlID0gb3B0aW9ucy5yZW5kZXJlciB8fCBSZW5kZXJUeXBlLkNhbnZhcztcbiAgdmlldy5fc2NlbmVncmFwaCA9IG5ldyBTY2VuZWdyYXBoKCk7XG4gIGNvbnN0IHJvb3QgPSB2aWV3Ll9zY2VuZWdyYXBoLnJvb3Q7IC8vIGluaXRpYWxpemUgcmVuZGVyZXIsIGhhbmRsZXIgYW5kIGV2ZW50IG1hbmFnZW1lbnRcblxuICB2aWV3Ll9yZW5kZXJlciA9IG51bGw7XG4gIHZpZXcuX3Rvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXAgfHwgZGVmYXVsdFRvb2x0aXAsIHZpZXcuX3JlZHJhdyA9IHRydWU7XG4gIHZpZXcuX2hhbmRsZXIgPSBuZXcgQ2FudmFzSGFuZGxlcigpLnNjZW5lKHJvb3QpO1xuICB2aWV3Ll9nbG9iYWxDdXJzb3IgPSBmYWxzZTtcbiAgdmlldy5fcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgdmlldy5fdGltZXJzID0gW107XG4gIHZpZXcuX2V2ZW50TGlzdGVuZXJzID0gW107XG4gIHZpZXcuX3Jlc2l6ZUxpc3RlbmVycyA9IFtdOyAvLyBpbml0aWFsaXplIGV2ZW50IGNvbmZpZ3VyYXRpb25cblxuICB2aWV3Ll9ldmVudENvbmZpZyA9IGluaXRpYWxpemVFdmVudENvbmZpZyhzcGVjLmV2ZW50Q29uZmlnKTtcbiAgdmlldy5nbG9iYWxDdXJzb3Iodmlldy5fZXZlbnRDb25maWcuZ2xvYmFsQ3Vyc29yKTsgLy8gaW5pdGlhbGl6ZSBkYXRhZmxvdyBncmFwaFxuXG4gIGNvbnN0IGN0eCA9IHJ1bnRpbWUodmlldywgc3BlYywgb3B0aW9ucy5leHByKTtcbiAgdmlldy5fcnVudGltZSA9IGN0eDtcbiAgdmlldy5fc2lnbmFscyA9IGN0eC5zaWduYWxzO1xuICB2aWV3Ll9iaW5kID0gKHNwZWMuYmluZGluZ3MgfHwgW10pLm1hcChfID0+ICh7XG4gICAgc3RhdGU6IG51bGwsXG4gICAgcGFyYW06IGV4dGVuZCh7fSwgXylcbiAgfSkpOyAvLyBpbml0aWFsaXplIHNjZW5lZ3JhcGhcblxuICBpZiAoY3R4LnJvb3QpIGN0eC5yb290LnNldChyb290KTtcbiAgcm9vdC5zb3VyY2UgPSBjdHguZGF0YS5yb290LmlucHV0O1xuICB2aWV3LnB1bHNlKGN0eC5kYXRhLnJvb3QuaW5wdXQsIHZpZXcuY2hhbmdlc2V0KCkuaW5zZXJ0KHJvb3QuaXRlbXMpKTsgLy8gaW5pdGlhbGl6ZSB2aWV3IHNpemVcblxuICB2aWV3Ll93aWR0aCA9IHZpZXcud2lkdGgoKTtcbiAgdmlldy5faGVpZ2h0ID0gdmlldy5oZWlnaHQoKTtcbiAgdmlldy5fdmlld1dpZHRoID0gdmlld1dpZHRoKHZpZXcsIHZpZXcuX3dpZHRoKTtcbiAgdmlldy5fdmlld0hlaWdodCA9IHZpZXdIZWlnaHQodmlldywgdmlldy5faGVpZ2h0KTtcbiAgdmlldy5fb3JpZ2luID0gWzAsIDBdO1xuICB2aWV3Ll9yZXNpemUgPSAwO1xuICB2aWV3Ll9hdXRvc2l6ZSA9IDE7XG4gIGluaXRpYWxpemVSZXNpemUodmlldyk7IC8vIGluaXRpYWxpemUgYmFja2dyb3VuZCBjb2xvclxuXG4gIGJhY2tncm91bmQodmlldyk7IC8vIGluaXRpYWxpemUgY3Vyc29yXG5cbiAgY3Vyc29yKHZpZXcpOyAvLyBpbml0aWFsaXplIHZpZXcgZGVzY3JpcHRpb25cblxuICB2aWV3LmRlc2NyaXB0aW9uKHNwZWMuZGVzY3JpcHRpb24pOyAvLyBpbml0aWFsaXplIGhvdmVyIHByb2Vzc2luZywgaWYgcmVxdWVzdGVkXG5cbiAgaWYgKG9wdGlvbnMuaG92ZXIpIHZpZXcuaG92ZXIoKTsgLy8gaW5pdGlhbGl6ZSBET00gY29udGFpbmVyKHMpIGFuZCByZW5kZXJlclxuXG4gIGlmIChvcHRpb25zLmNvbnRhaW5lcikgdmlldy5pbml0aWFsaXplKG9wdGlvbnMuY29udGFpbmVyLCBvcHRpb25zLmJpbmQpO1xufVxuXG5mdW5jdGlvbiBsb29rdXBTaWduYWwodmlldywgbmFtZSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodmlldy5fc2lnbmFscywgbmFtZSkgPyB2aWV3Ll9zaWduYWxzW25hbWVdIDogZXJyb3IoJ1VucmVjb2duaXplZCBzaWduYWwgbmFtZTogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbn1cblxuZnVuY3Rpb24gZmluZE9wZXJhdG9ySGFuZGxlcihvcCwgaGFuZGxlcikge1xuICBjb25zdCBoID0gKG9wLl90YXJnZXRzIHx8IFtdKS5maWx0ZXIob3AgPT4gb3AuX3VwZGF0ZSAmJiBvcC5fdXBkYXRlLmhhbmRsZXIgPT09IGhhbmRsZXIpO1xuICByZXR1cm4gaC5sZW5ndGggPyBoWzBdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gYWRkT3BlcmF0b3JMaXN0ZW5lcih2aWV3LCBuYW1lLCBvcCwgaGFuZGxlcikge1xuICBsZXQgaCA9IGZpbmRPcGVyYXRvckhhbmRsZXIob3AsIGhhbmRsZXIpO1xuXG4gIGlmICghaCkge1xuICAgIGggPSB0cmFwKHZpZXcsICgpID0+IGhhbmRsZXIobmFtZSwgb3AudmFsdWUpKTtcbiAgICBoLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZpZXcub24ob3AsIG51bGwsIGgpO1xuICB9XG5cbiAgcmV0dXJuIHZpZXc7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9wZXJhdG9yTGlzdGVuZXIodmlldywgb3AsIGhhbmRsZXIpIHtcbiAgY29uc3QgaCA9IGZpbmRPcGVyYXRvckhhbmRsZXIob3AsIGhhbmRsZXIpO1xuICBpZiAoaCkgb3AuX3RhcmdldHMucmVtb3ZlKGgpO1xuICByZXR1cm4gdmlldztcbn1cblxuaW5oZXJpdHMoVmlldywgRGF0YWZsb3csIHtcbiAgLy8gLS0gREFUQUZMT1cgLyBSRU5ERVJJTkcgLS0tLVxuICBhc3luYyBldmFsdWF0ZShlbmNvZGUsIHByZXJ1biwgcG9zdHJ1bikge1xuICAgIC8vIGV2YWx1YXRlIGRhdGFmbG93IGFuZCBwcmVydW5cbiAgICBhd2FpdCBEYXRhZmxvdy5wcm90b3R5cGUuZXZhbHVhdGUuY2FsbCh0aGlzLCBlbmNvZGUsIHByZXJ1bik7IC8vIHJlbmRlciBhcyBuZWVkZWRcblxuICAgIGlmICh0aGlzLl9yZWRyYXcgfHwgdGhpcy5fcmVzaXplKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemUgPSAwO1xuICAgICAgICAgICAgcmVzaXplUmVuZGVyZXIodGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVuZGVyZXIucmVuZGVyQXN5bmModGhpcy5fc2NlbmVncmFwaC5yb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZHJhdyA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH0gLy8gZXZhbHVhdGUgcG9zdHJ1blxuXG5cbiAgICBpZiAocG9zdHJ1bikgYXN5bmNDYWxsYmFjayh0aGlzLCBwb3N0cnVuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBkaXJ0eShpdGVtKSB7XG4gICAgdGhpcy5fcmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLl9yZW5kZXJlciAmJiB0aGlzLl9yZW5kZXJlci5kaXJ0eShpdGVtKTtcbiAgfSxcblxuICAvLyAtLSBHRVQgLyBTRVQgLS0tLVxuICBkZXNjcmlwdGlvbih0ZXh0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRlc2MgPSB0ZXh0ICE9IG51bGwgPyB0ZXh0ICsgJycgOiBudWxsO1xuICAgICAgaWYgKGRlc2MgIT09IHRoaXMuX2Rlc2MpIGFyaWFMYWJlbCh0aGlzLl9lbCwgdGhpcy5fZGVzYyA9IGRlc2MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Rlc2M7XG4gIH0sXG5cbiAgY29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbDtcbiAgfSxcblxuICBzY2VuZWdyYXBoKCkge1xuICAgIHJldHVybiB0aGlzLl9zY2VuZWdyYXBoO1xuICB9LFxuXG4gIG9yaWdpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luLnNsaWNlKCk7XG4gIH0sXG5cbiAgc2lnbmFsKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3AgPSBsb29rdXBTaWduYWwodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBvcC52YWx1ZSA6IHRoaXMudXBkYXRlKG9wLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgd2lkdGgoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ3dpZHRoJywgXykgOiB0aGlzLnNpZ25hbCgnd2lkdGgnKTtcbiAgfSxcblxuICBoZWlnaHQoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ2hlaWdodCcsIF8pIDogdGhpcy5zaWduYWwoJ2hlaWdodCcpO1xuICB9LFxuXG4gIHBhZGRpbmcoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ3BhZGRpbmcnLCBwYWRkaW5nKF8pKSA6IHBhZGRpbmcodGhpcy5zaWduYWwoJ3BhZGRpbmcnKSk7XG4gIH0sXG5cbiAgYXV0b3NpemUoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ2F1dG9zaXplJywgXykgOiB0aGlzLnNpZ25hbCgnYXV0b3NpemUnKTtcbiAgfSxcblxuICBiYWNrZ3JvdW5kKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2lnbmFsKCdiYWNrZ3JvdW5kJywgXykgOiB0aGlzLnNpZ25hbCgnYmFja2dyb3VuZCcpO1xuICB9LFxuXG4gIHJlbmRlcmVyKHR5cGUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZW5kZXJUeXBlO1xuICAgIGlmICghcmVuZGVyTW9kdWxlKHR5cGUpKSBlcnJvcignVW5yZWNvZ25pemVkIHJlbmRlcmVyIHR5cGU6ICcgKyB0eXBlKTtcblxuICAgIGlmICh0eXBlICE9PSB0aGlzLl9yZW5kZXJUeXBlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJUeXBlID0gdHlwZTtcblxuICAgICAgdGhpcy5fcmVzZXRSZW5kZXJlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHRvb2x0aXAoaGFuZGxlcikge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cbiAgICBpZiAoaGFuZGxlciAhPT0gdGhpcy5fdG9vbHRpcCkge1xuICAgICAgdGhpcy5fdG9vbHRpcCA9IGhhbmRsZXI7XG5cbiAgICAgIHRoaXMuX3Jlc2V0UmVuZGVyZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBsb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbG9hZGVyO1xuXG4gICAgaWYgKGxvYWRlciAhPT0gdGhpcy5fbG9hZGVyKSB7XG4gICAgICBEYXRhZmxvdy5wcm90b3R5cGUubG9hZGVyLmNhbGwodGhpcywgbG9hZGVyKTtcblxuICAgICAgdGhpcy5fcmVzZXRSZW5kZXJlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlc2l6ZSgpIHtcbiAgICAvLyBzZXQgZmxhZyB0byBwZXJmb3JtIGF1dG9zaXplXG4gICAgdGhpcy5fYXV0b3NpemUgPSAxOyAvLyB0b3VjaCBhdXRvc2l6ZSBzaWduYWwgdG8gZW5zdXJlIHRvcC1sZXZlbCBWaWV3TGF5b3V0IHJ1bnNcblxuICAgIHJldHVybiB0aGlzLnRvdWNoKGxvb2t1cFNpZ25hbCh0aGlzLCAnYXV0b3NpemUnKSk7XG4gIH0sXG5cbiAgX3Jlc2V0UmVuZGVyZXIoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgICB0aGlzLmluaXRpYWxpemUodGhpcy5fZWwsIHRoaXMuX2VsQmluZCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIC0tIFNJWklORyAtLS0tXG4gIF9yZXNpemVWaWV3OiByZXNpemVWaWV3LFxuXG4gIC8vIC0tIEVWRU5UIEhBTkRMSU5HIC0tLS1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGNhbGxiYWNrID0gaGFuZGxlcjtcblxuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy50cmFwID09PSBmYWxzZSkpIHtcbiAgICAgIC8vIHdyYXAgY2FsbGJhY2sgaW4gZXJyb3IgaGFuZGxlclxuICAgICAgY2FsbGJhY2sgPSB0cmFwKHRoaXMsIGhhbmRsZXIpO1xuICAgICAgY2FsbGJhY2sucmF3ID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVyLm9uKHR5cGUsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXIuaGFuZGxlcnModHlwZSksXG4gICAgICAgIGkgPSBoYW5kbGVycy5sZW5ndGgsXG4gICAgICAgIGgsXG4gICAgICAgIHQ7IC8vIHNlYXJjaCByZWdpc3RlcmVkIGhhbmRsZXJzLCByZW1vdmUgaWYgbWF0Y2ggZm91bmRcblxuXG4gICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICB0ID0gaGFuZGxlcnNbaV0udHlwZTtcbiAgICAgIGggPSBoYW5kbGVyc1tpXS5oYW5kbGVyO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdCAmJiAoaGFuZGxlciA9PT0gaCB8fCBoYW5kbGVyID09PSBoLnJhdykpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlci5vZmYodCwgaCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYWRkUmVzaXplTGlzdGVuZXIoaGFuZGxlcikge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9yZXNpemVMaXN0ZW5lcnM7XG5cbiAgICBpZiAobC5pbmRleE9mKGhhbmRsZXIpIDwgMCkge1xuICAgICAgLy8gYWRkIGhhbmRsZXIgaWYgaXQgaXNuJ3QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICAvLyBub3RlOiBlcnJvciB0cmFwcGluZyBoYW5kbGVkIGVsc2V3aGVyZSwgc29cbiAgICAgIC8vIG5vIG5lZWQgdG8gd3JhcCBoYW5kbGVycyBoZXJlXG4gICAgICBsLnB1c2goaGFuZGxlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVtb3ZlUmVzaXplTGlzdGVuZXIoaGFuZGxlcikge1xuICAgIHZhciBsID0gdGhpcy5fcmVzaXplTGlzdGVuZXJzLFxuICAgICAgICBpID0gbC5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgbC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYWRkU2lnbmFsTGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgIHJldHVybiBhZGRPcGVyYXRvckxpc3RlbmVyKHRoaXMsIG5hbWUsIGxvb2t1cFNpZ25hbCh0aGlzLCBuYW1lKSwgaGFuZGxlcik7XG4gIH0sXG5cbiAgcmVtb3ZlU2lnbmFsTGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgIHJldHVybiByZW1vdmVPcGVyYXRvckxpc3RlbmVyKHRoaXMsIGxvb2t1cFNpZ25hbCh0aGlzLCBuYW1lKSwgaGFuZGxlcik7XG4gIH0sXG5cbiAgYWRkRGF0YUxpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gYWRkT3BlcmF0b3JMaXN0ZW5lcih0aGlzLCBuYW1lLCBkYXRhcmVmKHRoaXMsIG5hbWUpLnZhbHVlcywgaGFuZGxlcik7XG4gIH0sXG5cbiAgcmVtb3ZlRGF0YUxpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVtb3ZlT3BlcmF0b3JMaXN0ZW5lcih0aGlzLCBkYXRhcmVmKHRoaXMsIG5hbWUpLnZhbHVlcywgaGFuZGxlcik7XG4gIH0sXG5cbiAgZ2xvYmFsQ3Vyc29yKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2dsb2JhbEN1cnNvciAhPT0gISFfKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBzZXRDdXJzb3IodGhpcywgbnVsbCk7IC8vIGNsZWFyIHByZXZpb3VzIGN1cnNvclxuXG4gICAgICAgIHRoaXMuX2dsb2JhbEN1cnNvciA9ICEhXztcbiAgICAgICAgaWYgKHByZXYpIHNldEN1cnNvcih0aGlzLCBwcmV2KTsgLy8gc3dhcCBjdXJzb3JcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9nbG9iYWxDdXJzb3I7XG4gICAgfVxuICB9LFxuXG4gIHByZXZlbnREZWZhdWx0KF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcHJldmVudERlZmF1bHQgPSBfO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2ZW50RGVmYXVsdDtcbiAgICB9XG4gIH0sXG5cbiAgdGltZXIsXG4gIGV2ZW50cyxcbiAgZmluYWxpemUsXG4gIGhvdmVyLFxuICAvLyAtLSBEQVRBIC0tLS1cbiAgZGF0YSxcbiAgY2hhbmdlLFxuICBpbnNlcnQsXG4gIHJlbW92ZSxcbiAgLy8gLS0gU0NBTEVTIC0tXG4gIHNjYWxlLFxuICAvLyAtLSBJTklUSUFMSVpBVElPTiAtLS0tXG4gIGluaXRpYWxpemUsXG4gIC8vIC0tIEhFQURMRVNTIFJFTkRFUklORyAtLS0tXG4gIHRvSW1hZ2VVUkw6IHJlbmRlclRvSW1hZ2VVUkwsXG4gIHRvQ2FudmFzOiByZW5kZXJUb0NhbnZhcyxcbiAgdG9TVkc6IHJlbmRlclRvU1ZHLFxuICAvLyAtLSBTQVZFIC8gUkVTVE9SRSBTVEFURSAtLS0tXG4gIGdldFN0YXRlLFxuICBzZXRTdGF0ZVxufSk7XG5cbmV4cG9ydCB7IFZpZXcgfTtcbiIsImltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgRGVsYXVuYXkgfSBmcm9tICdkMy1kZWxhdW5heSc7XG5cbmZ1bmN0aW9uIFZvcm9ub2kocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Wb3Jvbm9pLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1Zvcm9ub2knLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICd4JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAneScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdhcnJheScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFtbLTFlNSwgLTFlNV0sIFsxZTUsIDFlNV1dLFxuICAgICdjb250ZW50Jzoge1xuICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICdhcnJheSc6IHRydWUsXG4gICAgICAnbGVuZ3RoJzogMlxuICAgIH1cbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ3BhdGgnXG4gIH1dXG59O1xuY29uc3QgZGVmYXVsdEV4dGVudCA9IFstMWU1LCAtMWU1LCAxZTUsIDFlNV07XG5pbmhlcml0cyhWb3Jvbm9pLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgYXMgPSBfLmFzIHx8ICdwYXRoJyxcbiAgICAgICAgICBkYXRhID0gcHVsc2Uuc291cmNlOyAvLyBub3RoaW5nIHRvIGRvIGlmIG5vIGRhdGFcblxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBwdWxzZTsgLy8gY29uZmlndXJlIGFuZCBjb25zdHJ1Y3Qgdm9yb25vaSBkaWFncmFtXG5cbiAgICBsZXQgcyA9IF8uc2l6ZTtcbiAgICBzID0gcyA/IFswLCAwLCBzWzBdLCBzWzFdXSA6IChzID0gXy5leHRlbnQpID8gW3NbMF1bMF0sIHNbMF1bMV0sIHNbMV1bMF0sIHNbMV1bMV1dIDogZGVmYXVsdEV4dGVudDtcbiAgICBjb25zdCB2b3Jvbm9pID0gdGhpcy52YWx1ZSA9IERlbGF1bmF5LmZyb20oZGF0YSwgXy54LCBfLnkpLnZvcm9ub2kocyk7IC8vIG1hcCBwb2x5Z29ucyB0byBwYXRoc1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgcG9seWdvbiA9IHZvcm9ub2kuY2VsbFBvbHlnb24oaSk7XG4gICAgICBkYXRhW2ldW2FzXSA9IHBvbHlnb24gPyB0b1BhdGhTdHJpbmcocG9seWdvbikgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwdWxzZS5yZWZsb3coXy5tb2RpZmllZCgpKS5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7IC8vIHN1cHByZXNzIGR1cGxpY2F0ZWQgZW5kIHBvaW50IHZlcnRpY2VzXG5cbmZ1bmN0aW9uIHRvUGF0aFN0cmluZyhwKSB7XG4gIGNvbnN0IHggPSBwWzBdWzBdLFxuICAgICAgICB5ID0gcFswXVsxXTtcbiAgbGV0IG4gPSBwLmxlbmd0aCAtIDE7XG5cbiAgZm9yICg7IHBbbl1bMF0gPT09IHggJiYgcFtuXVsxXSA9PT0geTsgLS1uKTtcblxuICByZXR1cm4gJ00nICsgcC5zbGljZSgwLCBuICsgMSkuam9pbignTCcpICsgJ1onO1xufVxuXG5leHBvcnQgeyBWb3Jvbm9pIGFzIHZvcm9ub2kgfTtcbiIsImltcG9ydCB7IGNhbnZhcyB9IGZyb20gJ3ZlZ2EtY2FudmFzJztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGVycm9yLCBpc0Z1bmN0aW9uLCBjb25zdGFudCwgZXh0ZW50IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHNjYWxlIH0gZnJvbSAndmVnYS1zY2FsZSc7XG5pbXBvcnQgeyByYW5kb20gfSBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDEzLCBKYXNvbiBEYXZpZXMuXG5BbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbm1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICogVGhlIG5hbWUgSmFzb24gRGF2aWVzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkFTT04gREFWSUVTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG5JTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG5MSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcblBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0Vcbk9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbkFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cbi8vIFdvcmQgY2xvdWQgbGF5b3V0IGJ5IEphc29uIERhdmllcywgaHR0cHM6Ly93d3cuamFzb25kYXZpZXMuY29tL3dvcmRjbG91ZC9cbi8vIEFsZ29yaXRobSBkdWUgdG8gSm9uYXRoYW4gRmVpbmJlcmcsIGh0dHA6Ly9zdGF0aWMubXJmZWluYmVyZy5jb20vYnZfY2gwMy5wZGZcblxudmFyIGNsb3VkUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXG4gICAgY3cgPSAxIDw8IDExID4+IDUsXG4gICAgY2ggPSAxIDw8IDExO1xuZnVuY3Rpb24gY2xvdWQgKCkge1xuICB2YXIgc2l6ZSA9IFsyNTYsIDI1Nl0sXG4gICAgICB0ZXh0LFxuICAgICAgZm9udCxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodCxcbiAgICAgIHJvdGF0ZSxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBzcGlyYWwgPSBhcmNoaW1lZGVhblNwaXJhbCxcbiAgICAgIHdvcmRzID0gW10sXG4gICAgICByYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgIGNsb3VkID0ge307XG5cbiAgY2xvdWQubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250ZXh0QW5kUmF0aW8gPSBnZXRDb250ZXh0KGNhbnZhcygpKSxcbiAgICAgICAgYm9hcmQgPSB6ZXJvQXJyYXkoKHNpemVbMF0gPj4gNSkgKiBzaXplWzFdKSxcbiAgICAgICAgYm91bmRzID0gbnVsbCxcbiAgICAgICAgbiA9IHdvcmRzLmxlbmd0aCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICB0YWdzID0gW10sXG4gICAgICAgIGRhdGEgPSB3b3Jkcy5tYXAoZCA9PiAoe1xuICAgICAgdGV4dDogdGV4dChkKSxcbiAgICAgIGZvbnQ6IGZvbnQoZCksXG4gICAgICBzdHlsZTogZm9udFN0eWxlKGQpLFxuICAgICAgd2VpZ2h0OiBmb250V2VpZ2h0KGQpLFxuICAgICAgcm90YXRlOiByb3RhdGUoZCksXG4gICAgICBzaXplOiB+fihmb250U2l6ZShkKSArIDFlLTE0KSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcoZCksXG4gICAgICB4b2ZmOiAwLFxuICAgICAgeW9mZjogMCxcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB4MDogMCxcbiAgICAgIHkwOiAwLFxuICAgICAgaGFzVGV4dDogZmFsc2UsXG4gICAgICBzcHJpdGU6IG51bGwsXG4gICAgICBkYXR1bTogZFxuICAgIH0pKS5zb3J0KChhLCBiKSA9PiBiLnNpemUgLSBhLnNpemUpO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHZhciBkID0gZGF0YVtpXTtcbiAgICAgIGQueCA9IHNpemVbMF0gKiAocmFuZG9tKCkgKyAuNSkgPj4gMTtcbiAgICAgIGQueSA9IHNpemVbMV0gKiAocmFuZG9tKCkgKyAuNSkgPj4gMTtcbiAgICAgIGNsb3VkU3ByaXRlKGNvbnRleHRBbmRSYXRpbywgZCwgZGF0YSwgaSk7XG5cbiAgICAgIGlmIChkLmhhc1RleHQgJiYgcGxhY2UoYm9hcmQsIGQsIGJvdW5kcykpIHtcbiAgICAgICAgdGFncy5wdXNoKGQpO1xuICAgICAgICBpZiAoYm91bmRzKSBjbG91ZEJvdW5kcyhib3VuZHMsIGQpO2Vsc2UgYm91bmRzID0gW3tcbiAgICAgICAgICB4OiBkLnggKyBkLngwLFxuICAgICAgICAgIHk6IGQueSArIGQueTBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGQueCArIGQueDEsXG4gICAgICAgICAgeTogZC55ICsgZC55MVxuICAgICAgICB9XTsgLy8gVGVtcG9yYXJ5IGhhY2tcblxuICAgICAgICBkLnggLT0gc2l6ZVswXSA+PiAxO1xuICAgICAgICBkLnkgLT0gc2l6ZVsxXSA+PiAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWdzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldENvbnRleHQoY2FudmFzKSB7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG4gICAgdmFyIHJhdGlvID0gTWF0aC5zcXJ0KGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLmxlbmd0aCA+PiAyKTtcbiAgICBjYW52YXMud2lkdGggPSAoY3cgPDwgNSkgLyByYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2ggLyByYXRpbztcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICByYXRpbzogcmF0aW9cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2UoYm9hcmQsIHRhZywgYm91bmRzKSB7XG4gICAgdmFyIHN0YXJ0WCA9IHRhZy54LFxuICAgICAgICBzdGFydFkgPSB0YWcueSxcbiAgICAgICAgbWF4RGVsdGEgPSBNYXRoLnNxcnQoc2l6ZVswXSAqIHNpemVbMF0gKyBzaXplWzFdICogc2l6ZVsxXSksXG4gICAgICAgIHMgPSBzcGlyYWwoc2l6ZSksXG4gICAgICAgIGR0ID0gcmFuZG9tKCkgPCAuNSA/IDEgOiAtMSxcbiAgICAgICAgdCA9IC1kdCxcbiAgICAgICAgZHhkeSxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGR4ZHkgPSBzKHQgKz0gZHQpKSB7XG4gICAgICBkeCA9IH5+ZHhkeVswXTtcbiAgICAgIGR5ID0gfn5keGR5WzFdO1xuICAgICAgaWYgKE1hdGgubWluKE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKSA+PSBtYXhEZWx0YSkgYnJlYWs7XG4gICAgICB0YWcueCA9IHN0YXJ0WCArIGR4O1xuICAgICAgdGFnLnkgPSBzdGFydFkgKyBkeTtcbiAgICAgIGlmICh0YWcueCArIHRhZy54MCA8IDAgfHwgdGFnLnkgKyB0YWcueTAgPCAwIHx8IHRhZy54ICsgdGFnLngxID4gc2l6ZVswXSB8fCB0YWcueSArIHRhZy55MSA+IHNpemVbMV0pIGNvbnRpbnVlOyAvLyBUT0RPIG9ubHkgY2hlY2sgZm9yIGNvbGxpc2lvbnMgd2l0aGluIGN1cnJlbnQgYm91bmRzLlxuXG4gICAgICBpZiAoIWJvdW5kcyB8fCAhY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHNpemVbMF0pKSB7XG4gICAgICAgIGlmICghYm91bmRzIHx8IGNvbGxpZGVSZWN0cyh0YWcsIGJvdW5kcykpIHtcbiAgICAgICAgICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcbiAgICAgICAgICAgICAgdyA9IHRhZy53aWR0aCA+PiA1LFxuICAgICAgICAgICAgICBzdyA9IHNpemVbMF0gPj4gNSxcbiAgICAgICAgICAgICAgbHggPSB0YWcueCAtICh3IDw8IDQpLFxuICAgICAgICAgICAgICBzeCA9IGx4ICYgMHg3ZixcbiAgICAgICAgICAgICAgbXN4ID0gMzIgLSBzeCxcbiAgICAgICAgICAgICAgaCA9IHRhZy55MSAtIHRhZy55MCxcbiAgICAgICAgICAgICAgeCA9ICh0YWcueSArIHRhZy55MCkgKiBzdyArIChseCA+PiA1KSxcbiAgICAgICAgICAgICAgbGFzdDtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICAgICAgICBsYXN0ID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdzsgaSsrKSB7XG4gICAgICAgICAgICAgIGJvYXJkW3ggKyBpXSB8PSBsYXN0IDw8IG1zeCB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4ICs9IHN3O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhZy5zcHJpdGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2xvdWQud29yZHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB3b3JkcyA9IF87XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3b3JkcztcbiAgICB9XG4gIH07XG5cbiAgY2xvdWQuc2l6ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNpemUgPSBbK19bMF0sICtfWzFdXTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLmZvbnQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250ID0gZnVuY3RvcihfKTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLmZvbnRTdHlsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGZvbnRTdHlsZSA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmb250U3R5bGU7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLmZvbnRXZWlnaHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250V2VpZ2h0ID0gZnVuY3RvcihfKTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZvbnRXZWlnaHQ7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLnJvdGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJvdGF0ZSA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb3RhdGU7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0ZXh0ID0gZnVuY3RvcihfKTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLnNwaXJhbCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNwaXJhbCA9IHNwaXJhbHNbX10gfHwgXztcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNwaXJhbDtcbiAgICB9XG4gIH07XG5cbiAgY2xvdWQuZm9udFNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250U2l6ZSA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmb250U2l6ZTtcbiAgICB9XG4gIH07XG5cbiAgY2xvdWQucGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHBhZGRpbmcgPSBmdW5jdG9yKF8pO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFkZGluZztcbiAgICB9XG4gIH07XG5cbiAgY2xvdWQucmFuZG9tID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmFuZG9tID0gXztcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJhbmRvbTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGNsb3VkO1xufSAvLyBGZXRjaGVzIGEgbW9ub2Nocm9tZSBzcHJpdGUgYml0bWFwIGZvciB0aGUgc3BlY2lmaWVkIHRleHQuXG4vLyBMb2FkIGluIGJhdGNoZXMgZm9yIHNwZWVkLlxuXG5mdW5jdGlvbiBjbG91ZFNwcml0ZShjb250ZXh0QW5kUmF0aW8sIGQsIGRhdGEsIGRpKSB7XG4gIGlmIChkLnNwcml0ZSkgcmV0dXJuO1xuICB2YXIgYyA9IGNvbnRleHRBbmRSYXRpby5jb250ZXh0LFxuICAgICAgcmF0aW8gPSBjb250ZXh0QW5kUmF0aW8ucmF0aW87XG4gIGMuY2xlYXJSZWN0KDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKTtcbiAgdmFyIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBtYXhoID0gMCxcbiAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHcsXG4gICAgICB3MzIsXG4gICAgICBoLFxuICAgICAgaSxcbiAgICAgIGo7XG4gIC0tZGk7XG5cbiAgd2hpbGUgKCsrZGkgPCBuKSB7XG4gICAgZCA9IGRhdGFbZGldO1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuZm9udCA9IGQuc3R5bGUgKyAnICcgKyBkLndlaWdodCArICcgJyArIH5+KChkLnNpemUgKyAxKSAvIHJhdGlvKSArICdweCAnICsgZC5mb250O1xuICAgIHcgPSBjLm1lYXN1cmVUZXh0KGQudGV4dCArICdtJykud2lkdGggKiByYXRpbztcbiAgICBoID0gZC5zaXplIDw8IDE7XG5cbiAgICBpZiAoZC5yb3RhdGUpIHtcbiAgICAgIHZhciBzciA9IE1hdGguc2luKGQucm90YXRlICogY2xvdWRSYWRpYW5zKSxcbiAgICAgICAgICBjciA9IE1hdGguY29zKGQucm90YXRlICogY2xvdWRSYWRpYW5zKSxcbiAgICAgICAgICB3Y3IgPSB3ICogY3IsXG4gICAgICAgICAgd3NyID0gdyAqIHNyLFxuICAgICAgICAgIGhjciA9IGggKiBjcixcbiAgICAgICAgICBoc3IgPSBoICogc3I7XG4gICAgICB3ID0gTWF0aC5tYXgoTWF0aC5hYnMod2NyICsgaHNyKSwgTWF0aC5hYnMod2NyIC0gaHNyKSkgKyAweDFmID4+IDUgPDwgNTtcbiAgICAgIGggPSB+fk1hdGgubWF4KE1hdGguYWJzKHdzciArIGhjciksIE1hdGguYWJzKHdzciAtIGhjcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ID0gdyArIDB4MWYgPj4gNSA8PCA1O1xuICAgIH1cblxuICAgIGlmIChoID4gbWF4aCkgbWF4aCA9IGg7XG5cbiAgICBpZiAoeCArIHcgPj0gY3cgPDwgNSkge1xuICAgICAgeCA9IDA7XG4gICAgICB5ICs9IG1heGg7XG4gICAgICBtYXhoID0gMDtcbiAgICB9XG5cbiAgICBpZiAoeSArIGggPj0gY2gpIGJyZWFrO1xuICAgIGMudHJhbnNsYXRlKCh4ICsgKHcgPj4gMSkpIC8gcmF0aW8sICh5ICsgKGggPj4gMSkpIC8gcmF0aW8pO1xuICAgIGlmIChkLnJvdGF0ZSkgYy5yb3RhdGUoZC5yb3RhdGUgKiBjbG91ZFJhZGlhbnMpO1xuICAgIGMuZmlsbFRleHQoZC50ZXh0LCAwLCAwKTtcblxuICAgIGlmIChkLnBhZGRpbmcpIHtcbiAgICAgIGMubGluZVdpZHRoID0gMiAqIGQucGFkZGluZztcbiAgICAgIGMuc3Ryb2tlVGV4dChkLnRleHQsIDAsIDApO1xuICAgIH1cblxuICAgIGMucmVzdG9yZSgpO1xuICAgIGQud2lkdGggPSB3O1xuICAgIGQuaGVpZ2h0ID0gaDtcbiAgICBkLnhvZmYgPSB4O1xuICAgIGQueW9mZiA9IHk7XG4gICAgZC54MSA9IHcgPj4gMTtcbiAgICBkLnkxID0gaCA+PiAxO1xuICAgIGQueDAgPSAtZC54MTtcbiAgICBkLnkwID0gLWQueTE7XG4gICAgZC5oYXNUZXh0ID0gdHJ1ZTtcbiAgICB4ICs9IHc7XG4gIH1cblxuICB2YXIgcGl4ZWxzID0gYy5nZXRJbWFnZURhdGEoMCwgMCwgKGN3IDw8IDUpIC8gcmF0aW8sIGNoIC8gcmF0aW8pLmRhdGEsXG4gICAgICBzcHJpdGUgPSBbXTtcblxuICB3aGlsZSAoLS1kaSA+PSAwKSB7XG4gICAgZCA9IGRhdGFbZGldO1xuICAgIGlmICghZC5oYXNUZXh0KSBjb250aW51ZTtcbiAgICB3ID0gZC53aWR0aDtcbiAgICB3MzIgPSB3ID4+IDU7XG4gICAgaCA9IGQueTEgLSBkLnkwOyAvLyBaZXJvIHRoZSBidWZmZXJcblxuICAgIGZvciAoaSA9IDA7IGkgPCBoICogdzMyOyBpKyspIHNwcml0ZVtpXSA9IDA7XG5cbiAgICB4ID0gZC54b2ZmO1xuICAgIGlmICh4ID09IG51bGwpIHJldHVybjtcbiAgICB5ID0gZC55b2ZmO1xuICAgIHZhciBzZWVuID0gMCxcbiAgICAgICAgc2VlblJvdyA9IC0xO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGg7IGorKykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICB2YXIgayA9IHczMiAqIGogKyAoaSA+PiA1KSxcbiAgICAgICAgICAgIG0gPSBwaXhlbHNbKHkgKyBqKSAqIChjdyA8PCA1KSArICh4ICsgaSkgPDwgMl0gPyAxIDw8IDMxIC0gaSAlIDMyIDogMDtcbiAgICAgICAgc3ByaXRlW2tdIHw9IG07XG4gICAgICAgIHNlZW4gfD0gbTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlZW4pIHNlZW5Sb3cgPSBqO2Vsc2Uge1xuICAgICAgICBkLnkwKys7XG4gICAgICAgIGgtLTtcbiAgICAgICAgai0tO1xuICAgICAgICB5Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZC55MSA9IGQueTAgKyBzZWVuUm93O1xuICAgIGQuc3ByaXRlID0gc3ByaXRlLnNsaWNlKDAsIChkLnkxIC0gZC55MCkgKiB3MzIpO1xuICB9XG59IC8vIFVzZSBtYXNrLWJhc2VkIGNvbGxpc2lvbiBkZXRlY3Rpb24uXG5cblxuZnVuY3Rpb24gY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHN3KSB7XG4gIHN3ID4+PSA1O1xuICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcbiAgICAgIHcgPSB0YWcud2lkdGggPj4gNSxcbiAgICAgIGx4ID0gdGFnLnggLSAodyA8PCA0KSxcbiAgICAgIHN4ID0gbHggJiAweDdmLFxuICAgICAgbXN4ID0gMzIgLSBzeCxcbiAgICAgIGggPSB0YWcueTEgLSB0YWcueTAsXG4gICAgICB4ID0gKHRhZy55ICsgdGFnLnkwKSAqIHN3ICsgKGx4ID4+IDUpLFxuICAgICAgbGFzdDtcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IGg7IGorKykge1xuICAgIGxhc3QgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdzsgaSsrKSB7XG4gICAgICBpZiAoKGxhc3QgPDwgbXN4IHwgKGkgPCB3ID8gKGxhc3QgPSBzcHJpdGVbaiAqIHcgKyBpXSkgPj4+IHN4IDogMCkpICYgYm9hcmRbeCArIGldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB4ICs9IHN3O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjbG91ZEJvdW5kcyhib3VuZHMsIGQpIHtcbiAgdmFyIGIwID0gYm91bmRzWzBdLFxuICAgICAgYjEgPSBib3VuZHNbMV07XG4gIGlmIChkLnggKyBkLngwIDwgYjAueCkgYjAueCA9IGQueCArIGQueDA7XG4gIGlmIChkLnkgKyBkLnkwIDwgYjAueSkgYjAueSA9IGQueSArIGQueTA7XG4gIGlmIChkLnggKyBkLngxID4gYjEueCkgYjEueCA9IGQueCArIGQueDE7XG4gIGlmIChkLnkgKyBkLnkxID4gYjEueSkgYjEueSA9IGQueSArIGQueTE7XG59XG5cbmZ1bmN0aW9uIGNvbGxpZGVSZWN0cyhhLCBiKSB7XG4gIHJldHVybiBhLnggKyBhLngxID4gYlswXS54ICYmIGEueCArIGEueDAgPCBiWzFdLnggJiYgYS55ICsgYS55MSA+IGJbMF0ueSAmJiBhLnkgKyBhLnkwIDwgYlsxXS55O1xufVxuXG5mdW5jdGlvbiBhcmNoaW1lZGVhblNwaXJhbChzaXplKSB7XG4gIHZhciBlID0gc2l6ZVswXSAvIHNpemVbMV07XG4gIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBbZSAqICh0ICo9IC4xKSAqIE1hdGguY29zKHQpLCB0ICogTWF0aC5zaW4odCldO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWN0YW5ndWxhclNwaXJhbChzaXplKSB7XG4gIHZhciBkeSA9IDQsXG4gICAgICBkeCA9IGR5ICogc2l6ZVswXSAvIHNpemVbMV0sXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgc2lnbiA9IHQgPCAwID8gLTEgOiAxOyAvLyBTZWUgdHJpYW5ndWxhciBudW1iZXJzOiBUX24gPSBuICogKG4gKyAxKSAvIDIuXG5cbiAgICBzd2l0Y2ggKE1hdGguc3FydCgxICsgNCAqIHNpZ24gKiB0KSAtIHNpZ24gJiAzKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHggKz0gZHg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHkgKz0gZHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHggLT0gZHg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB5IC09IGR5O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gW3gsIHldO1xuICB9O1xufSAvLyBUT0RPIHJldXNlIGFycmF5cz9cblxuXG5mdW5jdGlvbiB6ZXJvQXJyYXkobikge1xuICB2YXIgYSA9IFtdLFxuICAgICAgaSA9IC0xO1xuXG4gIHdoaWxlICgrK2kgPCBuKSBhW2ldID0gMDtcblxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gZnVuY3RvcihkKSB7XG4gIHJldHVybiB0eXBlb2YgZCA9PT0gJ2Z1bmN0aW9uJyA/IGQgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG59XG5cbnZhciBzcGlyYWxzID0ge1xuICBhcmNoaW1lZGVhbjogYXJjaGltZWRlYW5TcGlyYWwsXG4gIHJlY3Rhbmd1bGFyOiByZWN0YW5ndWxhclNwaXJhbFxufTtcblxuY29uc3QgT3V0cHV0ID0gWyd4JywgJ3knLCAnZm9udCcsICdmb250U2l6ZScsICdmb250U3R5bGUnLCAnZm9udFdlaWdodCcsICdhbmdsZSddO1xuY29uc3QgUGFyYW1zID0gWyd0ZXh0JywgJ2ZvbnQnLCAncm90YXRlJywgJ2ZvbnRTaXplJywgJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0J107XG5mdW5jdGlvbiBXb3JkY2xvdWQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIGNsb3VkKCksIHBhcmFtcyk7XG59XG5Xb3JkY2xvdWQuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnV29yZGNsb3VkJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb250JyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdzYW5zLXNlcmlmJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZm9udFN0eWxlJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdub3JtYWwnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb250V2VpZ2h0JyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdub3JtYWwnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb250U2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAxNFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZm9udFNpemVSYW5nZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiAnbnVsbGFibGUnLFxuICAgICdkZWZhdWx0JzogWzEwLCA1MF1cbiAgfSwge1xuICAgICduYW1lJzogJ3JvdGF0ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0ZXh0JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3NwaXJhbCcsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAndmFsdWVzJzogWydhcmNoaW1lZGVhbicsICdyZWN0YW5ndWxhciddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogNyxcbiAgICAnZGVmYXVsdCc6IE91dHB1dFxuICB9XVxufTtcbmluaGVyaXRzKFdvcmRjbG91ZCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmIChfLnNpemUgJiYgIShfLnNpemVbMF0gJiYgXy5zaXplWzFdKSkge1xuICAgICAgZXJyb3IoJ1dvcmRjbG91ZCBzaXplIGRpbWVuc2lvbnMgbXVzdCBiZSBub24temVyby4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2RwKHBhcmFtKSB7XG4gICAgICBjb25zdCBwID0gX1twYXJhbV07XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihwKSAmJiBwdWxzZS5tb2RpZmllZChwLmZpZWxkcyk7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kID0gXy5tb2RpZmllZCgpO1xuXG4gICAgaWYgKCEobW9kIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSkgfHwgUGFyYW1zLnNvbWUobW9kcCkpKSByZXR1cm47XG4gICAgY29uc3QgZGF0YSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICAgIGxheW91dCA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgYXMgPSBfLmFzIHx8IE91dHB1dDtcbiAgICBsZXQgZm9udFNpemUgPSBfLmZvbnRTaXplIHx8IDE0LFxuICAgICAgICByYW5nZTtcbiAgICBpc0Z1bmN0aW9uKGZvbnRTaXplKSA/IHJhbmdlID0gXy5mb250U2l6ZVJhbmdlIDogZm9udFNpemUgPSBjb25zdGFudChmb250U2l6ZSk7IC8vIGNyZWF0ZSBmb250IHNpemUgc2NhbGluZyBmdW5jdGlvbiBhcyBuZWVkZWRcblxuICAgIGlmIChyYW5nZSkge1xuICAgICAgY29uc3QgZnNpemUgPSBmb250U2l6ZSxcbiAgICAgICAgICAgIHNpemVTY2FsZSA9IHNjYWxlKCdzcXJ0JykoKS5kb21haW4oZXh0ZW50KGRhdGEsIGZzaXplKSkucmFuZ2UocmFuZ2UpO1xuXG4gICAgICBmb250U2l6ZSA9IHggPT4gc2l6ZVNjYWxlKGZzaXplKHgpKTtcbiAgICB9XG5cbiAgICBkYXRhLmZvckVhY2godCA9PiB7XG4gICAgICB0W2FzWzBdXSA9IE5hTjtcbiAgICAgIHRbYXNbMV1dID0gTmFOO1xuICAgICAgdFthc1szXV0gPSAwO1xuICAgIH0pOyAvLyBjb25maWd1cmUgbGF5b3V0XG5cbiAgICBjb25zdCB3b3JkcyA9IGxheW91dC53b3JkcyhkYXRhKS50ZXh0KF8udGV4dCkuc2l6ZShfLnNpemUgfHwgWzUwMCwgNTAwXSkucGFkZGluZyhfLnBhZGRpbmcgfHwgMSkuc3BpcmFsKF8uc3BpcmFsIHx8ICdhcmNoaW1lZGVhbicpLnJvdGF0ZShfLnJvdGF0ZSB8fCAwKS5mb250KF8uZm9udCB8fCAnc2Fucy1zZXJpZicpLmZvbnRTdHlsZShfLmZvbnRTdHlsZSB8fCAnbm9ybWFsJykuZm9udFdlaWdodChfLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCcpLmZvbnRTaXplKGZvbnRTaXplKS5yYW5kb20ocmFuZG9tKS5sYXlvdXQoKTtcbiAgICBjb25zdCBzaXplID0gbGF5b3V0LnNpemUoKSxcbiAgICAgICAgICBkeCA9IHNpemVbMF0gPj4gMSxcbiAgICAgICAgICBkeSA9IHNpemVbMV0gPj4gMSxcbiAgICAgICAgICBuID0gd29yZHMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIHcsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgIHcgPSB3b3Jkc1tpXTtcbiAgICAgIHQgPSB3LmRhdHVtO1xuICAgICAgdFthc1swXV0gPSB3LnggKyBkeDtcbiAgICAgIHRbYXNbMV1dID0gdy55ICsgZHk7XG4gICAgICB0W2FzWzJdXSA9IHcuZm9udDtcbiAgICAgIHRbYXNbM11dID0gdy5zaXplO1xuICAgICAgdFthc1s0XV0gPSB3LnN0eWxlO1xuICAgICAgdFthc1s1XV0gPSB3LndlaWdodDtcbiAgICAgIHRbYXNbNl1dID0gdy5yb3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhtb2QpLm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuZXhwb3J0IHsgV29yZGNsb3VkIGFzIHdvcmRjbG91ZCB9O1xuIiwiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAndmVnYS11dGlsJztcbmV4cG9ydCAqIGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1zIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5leHBvcnQgeyBEYXRhZmxvdywgRXZlbnRTdHJlYW0sIE11bHRpUHVsc2UsIE9wZXJhdG9yLCBQYXJhbWV0ZXJzLCBQdWxzZSwgVHJhbnNmb3JtLCBjaGFuZ2VzZXQsIGRlZmluaXRpb24sIGluZ2VzdCwgaXNUdXBsZSwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1zLCB0dXBsZWlkIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgKiBhcyB0eCBmcm9tICd2ZWdhLXRyYW5zZm9ybXMnO1xuaW1wb3J0ICogYXMgdnR4IGZyb20gJ3ZlZ2Etdmlldy10cmFuc2Zvcm1zJztcbmltcG9ydCAqIGFzIGVuY29kZSBmcm9tICd2ZWdhLWVuY29kZSc7XG5pbXBvcnQgKiBhcyBnZW8gZnJvbSAndmVnYS1nZW8nO1xuaW1wb3J0ICogYXMgZm9yY2UgZnJvbSAndmVnYS1mb3JjZSc7XG5pbXBvcnQgKiBhcyB0cmVlIGZyb20gJ3ZlZ2EtaGllcmFyY2h5JztcbmltcG9ydCAqIGFzIGxhYmVsIGZyb20gJ3ZlZ2EtbGFiZWwnO1xuaW1wb3J0ICogYXMgcmVnIGZyb20gJ3ZlZ2EtcmVncmVzc2lvbic7XG5pbXBvcnQgKiBhcyB2b3Jvbm9pIGZyb20gJ3ZlZ2Etdm9yb25vaSc7XG5pbXBvcnQgKiBhcyB3b3JkY2xvdWQgZnJvbSAndmVnYS13b3JkY2xvdWQnO1xuaW1wb3J0ICogYXMgeGYgZnJvbSAndmVnYS1jcm9zc2ZpbHRlcic7XG5leHBvcnQgKiBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuZXhwb3J0ICogZnJvbSAndmVnYS10aW1lJztcbmV4cG9ydCAqIGZyb20gJ3ZlZ2EtbG9hZGVyJztcbmV4cG9ydCAqIGZyb20gJ3ZlZ2Etc2NlbmVncmFwaCc7XG5leHBvcnQgeyBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGVDb2xvcnMsIGludGVycG9sYXRlUmFuZ2UsIHF1YW50aXplSW50ZXJwb2xhdG9yLCBzY2FsZSwgc2NoZW1lIH0gZnJvbSAndmVnYS1zY2FsZSc7XG5leHBvcnQgeyBwcm9qZWN0aW9uIH0gZnJvbSAndmVnYS1wcm9qZWN0aW9uJztcbmV4cG9ydCB7IFZpZXcgfSBmcm9tICd2ZWdhLXZpZXcnO1xuZXhwb3J0IHsgZGVmYXVsdExvY2FsZSwgbnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSBhcyBmb3JtYXRMb2NhbGUsIGxvY2FsZSwgcmVzZXREZWZhdWx0TG9jYWxlLCB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSBhcyB0aW1lRm9ybWF0TG9jYWxlIH0gZnJvbSAndmVnYS1mb3JtYXQnO1xuZXhwb3J0IHsgZXhwcmVzc2lvbkZ1bmN0aW9uIH0gZnJvbSAndmVnYS1mdW5jdGlvbnMnO1xuZXhwb3J0IHsgcGFyc2UgfSBmcm9tICd2ZWdhLXBhcnNlcic7XG5leHBvcnQgeyBjb250ZXh0IGFzIHJ1bnRpbWVDb250ZXh0IH0gZnJvbSAndmVnYS1ydW50aW1lJztcbmV4cG9ydCB7IGNvZGVnZW5FeHByZXNzaW9uLCBwYXJzZUV4cHJlc3Npb24gfSBmcm9tICd2ZWdhLWV4cHJlc3Npb24nO1xuZXhwb3J0IHsgcGFyc2VTZWxlY3RvciB9IGZyb20gJ3ZlZ2EtZXZlbnQtc2VsZWN0b3InO1xuXG52YXIgbmFtZSA9IFwidmVnYVwiO1xudmFyIHZlcnNpb24kMSA9IFwiNS4yMS4wXCI7XG52YXIgZGVzY3JpcHRpb24gPSBcIlRoZSBWZWdhIHZpc3VhbGl6YXRpb24gZ3JhbW1hci5cIjtcbnZhciBrZXl3b3JkcyA9IFtcblx0XCJ2ZWdhXCIsXG5cdFwidmlzdWFsaXphdGlvblwiLFxuXHRcImludGVyYWN0aW9uXCIsXG5cdFwiZGF0YWZsb3dcIixcblx0XCJsaWJyYXJ5XCIsXG5cdFwiZGF0YVwiLFxuXHRcImQzXCJcbl07XG52YXIgbGljZW5zZSA9IFwiQlNELTMtQ2xhdXNlXCI7XG52YXIgYXV0aG9yID0gXCJVVyBJbnRlcmFjdGl2ZSBEYXRhIExhYiAoaHR0cDovL2lkbC5jcy53YXNoaW5ndG9uLmVkdSlcIjtcbnZhciBtYWluID0gXCJidWlsZC92ZWdhLW5vZGUuanNcIjtcbnZhciBtb2R1bGUgPSBcImJ1aWxkL3ZlZ2EubW9kdWxlLmpzXCI7XG52YXIgdW5wa2cgPSBcImJ1aWxkL3ZlZ2EubWluLmpzXCI7XG52YXIganNkZWxpdnIgPSBcImJ1aWxkL3ZlZ2EubWluLmpzXCI7XG52YXIgdHlwZXMgPSBcImluZGV4LmQudHNcIjtcbnZhciByZXBvc2l0b3J5ID0gXCJ2ZWdhL3ZlZ2FcIjtcbnZhciBzY3JpcHRzID0ge1xuXHRidW5kbGU6IFwicm9sbHVwIC1jIC0tY29uZmlnLWJ1bmRsZVwiLFxuXHRwcmVidWlsZDogXCJyaW1yYWYgYnVpbGQgJiYgcmltcmFmIGJ1aWxkLWVzNVwiLFxuXHRidWlsZDogXCJyb2xsdXAgLWMgLS1jb25maWctY29yZSAtLWNvbmZpZy1idW5kbGUgLS1jb25maWctaWVcIixcblx0cG9zdGJ1aWxkOiBcIm5vZGUgc2NoZW1hLWNvcHlcIixcblx0cHJldGVzdDogXCJ5YXJuIGJ1aWxkIC0tY29uZmlnLXRlc3RcIixcblx0dGVzdDogXCJUWj1BbWVyaWNhL0xvc19BbmdlbGVzIHRhcGUgJ3Rlc3QvKiovKi10ZXN0LmpzJ1wiLFxuXHRwcmVwdWJsaXNoT25seTogXCJ5YXJuIHRlc3QgJiYgeWFybiBidWlsZFwiLFxuXHRwb3N0cHVibGlzaDogXCIuL3NjaGVtYS1kZXBsb3kuc2hcIlxufTtcbnZhciBkZXBlbmRlbmNpZXMgPSB7XG5cdFwidmVnYS1jcm9zc2ZpbHRlclwiOiBcIn40LjAuNVwiLFxuXHRcInZlZ2EtZGF0YWZsb3dcIjogXCJ+NS43LjRcIixcblx0XCJ2ZWdhLWVuY29kZVwiOiBcIn40LjguM1wiLFxuXHRcInZlZ2EtZXZlbnQtc2VsZWN0b3JcIjogXCJ+My4wLjBcIixcblx0XCJ2ZWdhLWV4cHJlc3Npb25cIjogXCJ+NS4wLjBcIixcblx0XCJ2ZWdhLWZvcmNlXCI6IFwifjQuMC43XCIsXG5cdFwidmVnYS1mb3JtYXRcIjogXCJ+MS4wLjRcIixcblx0XCJ2ZWdhLWZ1bmN0aW9uc1wiOiBcIn41LjEyLjFcIixcblx0XCJ2ZWdhLWdlb1wiOiBcIn40LjMuOFwiLFxuXHRcInZlZ2EtaGllcmFyY2h5XCI6IFwifjQuMC45XCIsXG5cdFwidmVnYS1sYWJlbFwiOiBcIn4xLjEuMFwiLFxuXHRcInZlZ2EtbG9hZGVyXCI6IFwifjQuNC4xXCIsXG5cdFwidmVnYS1wYXJzZXJcIjogXCJ+Ni4xLjRcIixcblx0XCJ2ZWdhLXByb2plY3Rpb25cIjogXCJ+MS40LjVcIixcblx0XCJ2ZWdhLXJlZ3Jlc3Npb25cIjogXCJ+MS4wLjlcIixcblx0XCJ2ZWdhLXJ1bnRpbWVcIjogXCJ+Ni4xLjNcIixcblx0XCJ2ZWdhLXNjYWxlXCI6IFwifjcuMS4xXCIsXG5cdFwidmVnYS1zY2VuZWdyYXBoXCI6IFwifjQuOS40XCIsXG5cdFwidmVnYS1zdGF0aXN0aWNzXCI6IFwifjEuNy4xMFwiLFxuXHRcInZlZ2EtdGltZVwiOiBcIn4yLjAuNFwiLFxuXHRcInZlZ2EtdHJhbnNmb3Jtc1wiOiBcIn40LjkuNFwiLFxuXHRcInZlZ2EtdHlwaW5nc1wiOiBcIn4wLjIyLjBcIixcblx0XCJ2ZWdhLXV0aWxcIjogXCJ+MS4xNy4wXCIsXG5cdFwidmVnYS12aWV3XCI6IFwifjUuMTAuMVwiLFxuXHRcInZlZ2Etdmlldy10cmFuc2Zvcm1zXCI6IFwifjQuNS44XCIsXG5cdFwidmVnYS12b3Jvbm9pXCI6IFwifjQuMS41XCIsXG5cdFwidmVnYS13b3JkY2xvdWRcIjogXCJ+NC4xLjNcIlxufTtcbnZhciBkZXZEZXBlbmRlbmNpZXMgPSB7XG5cdFwidmVnYS1zY2hlbWFcIjogXCIqXCJcbn07XG52YXIgZ2l0SGVhZCA9IFwiNzc0MTY1ZTI5ODUwYjY2ZWM4Yjc5YmE1MmE3OTU1ZjFhYjkzNmVhNlwiO1xudmFyIHBrZyA9IHtcblx0bmFtZTogbmFtZSxcblx0dmVyc2lvbjogdmVyc2lvbiQxLFxuXHRkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG5cdGtleXdvcmRzOiBrZXl3b3Jkcyxcblx0bGljZW5zZTogbGljZW5zZSxcblx0YXV0aG9yOiBhdXRob3IsXG5cdG1haW46IG1haW4sXG5cdG1vZHVsZTogbW9kdWxlLFxuXHR1bnBrZzogdW5wa2csXG5cdGpzZGVsaXZyOiBqc2RlbGl2cixcblx0dHlwZXM6IHR5cGVzLFxuXHRyZXBvc2l0b3J5OiByZXBvc2l0b3J5LFxuXHRzY3JpcHRzOiBzY3JpcHRzLFxuXHRkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcblx0ZGV2RGVwZW5kZW5jaWVzOiBkZXZEZXBlbmRlbmNpZXMsXG5cdGdpdEhlYWQ6IGdpdEhlYWRcbn07XG5cbi8vIC0tIFRyYW5zZm9ybXMgLS0tLS1cbmV4dGVuZCh0cmFuc2Zvcm1zLCB0eCwgdnR4LCBlbmNvZGUsIGdlbywgZm9yY2UsIGxhYmVsLCB0cmVlLCByZWcsIHZvcm9ub2ksIHdvcmRjbG91ZCwgeGYpOyAvLyAtLSBFeHBvcnRzIC0tLS0tXG5cbmNvbnN0IHZlcnNpb24gPSBwa2cudmVyc2lvbjtcblxuZXhwb3J0IHsgdmVyc2lvbiB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==