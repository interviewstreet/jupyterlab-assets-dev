(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["packages_debugger_lib_index_js"],{

/***/ "../../packages/debugger/style/icons/close-all.svg":
/*!*********************************************************!*\
  !*** ../../packages/debugger/style/icons/close-all.svg ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n  <g class=\"jp-icon3\" fill=\"#616161\">\n    <path d=\"M16.4805 17.2481C16.8158 16.3972 17 15.4701 17 14.5C17 10.3579 13.6421 7.00001 9.5 7.00001C8.36314 7.00001 7.28536 7.25295 6.31986 7.70564C7.60064 6.0592 9.60074 5 11.8482 5C15.7142 5 18.8482 8.13401 18.8482 12C18.8482 14.0897 17.9325 15.9655 16.4805 17.2481Z\" />\n    <path d=\"M19.1607 14.2481C19.496 13.3971 19.6801 12.4701 19.6801 11.5C19.6801 7.35786 16.3223 4 12.1801 4C11.0433 4 9.9655 4.25295 9.00001 4.70563C10.2808 3.05919 12.2809 2 14.5284 2C18.3944 2 21.5284 5.134 21.5284 9C21.5284 11.0897 20.6127 12.9655 19.1607 14.2481Z\" />\n    <path d=\"M16 15C16 18.866 12.866 22 9 22C5.13401 22 2 18.866 2 15C2 11.134 5.13401 8 9 8C12.866 8 16 11.134 16 15ZM11.7914 11L13 12.2086L10.2086 15L13 17.7914L11.7914 19L9 16.2086L6.20857 19L5 17.7914L7.79143 15L5 12.2086L6.20857 11L9 13.7914L11.7914 11Z\" />\n    </g>\n</svg>\n");

/***/ }),

/***/ "../../packages/debugger/style/icons/open-kernel-source.svg":
/*!******************************************************************!*\
  !*** ../../packages/debugger/style/icons/open-kernel-source.svg ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <g class=\"jp-icon3\" fill=\"#616161\">\n        <path d=\"M5 2H15L20 7V20C20 20.5304 19.7893 21.0391 19.4142 21.4142C19.0391 21.7893 18.5304 22 18 22H5C4.46957 22 3.96086 21.7893 3.58579 21.4142C3.21071 21.0391 3 20.5304 3 20V14H4V16L8 13L4 10V12H3V4C3 3.46957 3.21071 2.96086 3.58579 2.58579C3.96086 2.21071 4.46957 2 5 2ZM12 18H16V16H12V18ZM12 14H18V12H12V14ZM12 10H18V8H12V10ZM10 14C10.5523 14 11 13.5523 11 13C11 12.4477 10.5523 12 10 12C9.44771 12 9 12.4477 9 13C9 13.5523 9.44771 14 10 14Z\"/>\n        <path d=\"M3 12V14H1V13V12H3Z\"/>\n    </g>\n</svg>\n");

/***/ }),

/***/ "../../packages/debugger/style/icons/pause.svg":
/*!*****************************************************!*\
  !*** ../../packages/debugger/style/icons/pause.svg ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <g class=\"jp-icon3\" fill=\"#616161\">\n        <path d=\"m 7,6 h 4 V 18 H 7 Z\" />\n        <path d=\"m 13,6 h 4 v 12 h -4 z\" />\n    </g>\n</svg>\n");

/***/ }),

/***/ "../../packages/debugger/style/icons/step-into.svg":
/*!*********************************************************!*\
  !*** ../../packages/debugger/style/icons/step-into.svg ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\">\n\t<g class=\"jp-icon3\" fill=\"#616161\">\n\t\t<path d=\"M7.99998 9.53198H8.54198L12.447 5.62698L11.386 4.56698L8.74898 7.17698L8.74898 0.999985H7.99998H7.25098L7.25098 7.17698L4.61398 4.56698L3.55298 5.62698L7.45798 9.53198H7.99998ZM9.95598 13.013C9.95598 14.1175 9.06055 15.013 7.95598 15.013C6.85141 15.013 5.95598 14.1175 5.95598 13.013C5.95598 11.9084 6.85141 11.013 7.95598 11.013C9.06055 11.013 9.95598 11.9084 9.95598 13.013Z\"/>\n\t</g>\n</svg>\n");

/***/ }),

/***/ "../../packages/debugger/style/icons/step-out.svg":
/*!********************************************************!*\
  !*** ../../packages/debugger/style/icons/step-out.svg ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\">\n\t<g class=\"jp-icon3\" fill=\"#616161\">\n\t\t<path d=\"M7.99998 1H7.45798L3.55298 4.905L4.61398 5.965L7.25098 3.355V9.532H7.99998H8.74898V3.355L11.386 5.965L12.447 4.905L8.54198 1H7.99998ZM9.95598 13.013C9.95598 14.1176 9.06055 15.013 7.95598 15.013C6.85141 15.013 5.95598 14.1176 5.95598 13.013C5.95598 11.9084 6.85141 11.013 7.95598 11.013C9.06055 11.013 9.95598 11.9084 9.95598 13.013Z\"/>\n\t</g>\n</svg>\n");

/***/ }),

/***/ "../../packages/debugger/style/icons/step-over.svg":
/*!*********************************************************!*\
  !*** ../../packages/debugger/style/icons/step-over.svg ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\">\n\t<g class=\"jp-icon3\" fill=\"#616161\">\n\t\t<path d=\"M14.25 5.75V1.75H12.75V4.2916C11.605 2.93303 9.83899 2.08334 7.90914 2.08334C4.73316 2.08334 1.98941 4.39036 1.75072 7.48075L1.72992 7.75H3.231L3.25287 7.5241C3.46541 5.32932 5.45509 3.58334 7.90914 3.58334C9.6452 3.58334 11.1528 4.45925 11.9587 5.75H9.12986V7.25H13.292L14.2535 6.27493V5.75H14.25ZM7.99997 14C9.10454 14 9.99997 13.1046 9.99997 12C9.99997 10.8954 9.10454 10 7.99997 10C6.8954 10 5.99997 10.8954 5.99997 12C5.99997 13.1046 6.8954 14 7.99997 14Z\"/>\n\t</g>\n</svg>\n");

/***/ }),

/***/ "../../packages/debugger/style/icons/variable.svg":
/*!********************************************************!*\
  !*** ../../packages/debugger/style/icons/variable.svg ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M1.5 4L1 4.5V12.5L1.5 13H4V12H2V5H4V4H1.5ZM14.5 13L15 12.5L15 4.5L14.5 4H12V5L14 5L14 12H12V13H14.5ZM8.79693 5L4.29693 7L4 7.45691V9.95691L4.24275 10.3857L6.74275 11.8857L7.20307 11.9138L11.7031 9.91381L12 9.45691V6.95691L11.7572 6.52816L9.25725 5.02816L8.79693 5ZM5 8.34V9.67381L6.5 10.5738V9.24L5 8.34ZM7.5 9.28184V10.6875L11 9.13197V7.72629L7.5 9.28184ZM10.4178 6.89071L8.96559 6.01936L5.58216 7.52311L7.03441 8.39445L10.4178 6.89071Z\" fill=\"#007ACC\"/>\n</svg>\n");

/***/ }),

/***/ "../../packages/debugger/style/icons/view-breakpoint.svg":
/*!***************************************************************!*\
  !*** ../../packages/debugger/style/icons/view-breakpoint.svg ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <g class=\"jp-icon3\" fill=\"#616161\">\n        <path d=\"M5 2H15L20 7V20C20 20.5304 19.7893 21.0391 19.4142 21.4142C19.0391 21.7893 18.5304 22 18 22H5C4.46957 22 3.96086 21.7893 3.58579 21.4142C3.21071 21.0391 3 20.5304 3 20V14H4V16L8 13L4 10V12H3V4C3 3.46957 3.21071 2.96086 3.58579 2.58579C3.96086 2.21071 4.46957 2 5 2ZM12 18H16V16H12V18ZM12 14H18V12H12V14ZM12 10H18V8H12V10ZM10 14C10.5523 14 11 13.5523 11 13C11 12.4477 10.5523 12 10 12C9.44771 12 9 12.4477 9 13C9 13.5523 9.44771 14 10 14Z\"/>\n        <path d=\"M3 12V14H1V13V12H3Z\"/>\n    </g>\n</svg>\n");

/***/ }),

/***/ "../../packages/debugger/lib/config.js":
/*!*********************************************!*\
  !*** ../../packages/debugger/lib/config.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebuggerConfig": () => (/* binding */ DebuggerConfig)
/* harmony export */ });
/* harmony import */ var _hash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hash */ "../../packages/debugger/lib/hash.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * A class that holds debugger configuration for all kernels.
 */
class DebuggerConfig {
    constructor() {
        this._fileParams = new Map();
        this._hashMethods = new Map();
    }
    /**
     * Returns an id based on the given code.
     *
     * @param code The source code.
     * @param kernel The kernel name from current session.
     */
    getCodeId(code, kernel) {
        const fileParams = this._fileParams.get(kernel);
        if (!fileParams) {
            throw new Error(`Kernel (${kernel}) has no tmp file params.`);
        }
        const hash = this._hashMethods.get(kernel);
        if (!hash) {
            throw new Error(`Kernel (${kernel}) has no hashing params.`);
        }
        const { prefix, suffix } = fileParams;
        return `${prefix}${hash(code)}${suffix}`;
    }
    /**
     * Sets the hash parameters for a kernel.
     *
     * @param params - Hashing parameters for a kernel.
     */
    setHashParams(params) {
        const { kernel, method, seed } = params;
        if (!kernel) {
            throw new TypeError(`Kernel name is not defined.`);
        }
        switch (method) {
            case 'Murmur2':
                this._hashMethods.set(kernel, code => (0,_hash__WEBPACK_IMPORTED_MODULE_0__.murmur2)(code, seed).toString());
                break;
            default:
                throw new Error(`Hash method (${method}) is not supported.`);
        }
    }
    /**
     * Sets the parameters used by the kernel to create temp files (e.g. cells).
     *
     * @param params - Temporary file prefix and suffix for a kernel.
     */
    setTmpFileParams(params) {
        const { kernel, prefix, suffix } = params;
        if (!kernel) {
            throw new TypeError(`Kernel name is not defined.`);
        }
        this._fileParams.set(kernel, { kernel, prefix, suffix });
    }
    /**
     * Gets the parameters used for the temp files (e.e. cells) for a kernel.
     *
     * @param kernel - The kernel name from current session.
     */
    getTmpFileParams(kernel) {
        return this._fileParams.get(kernel);
    }
}
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "../../packages/debugger/lib/debugger.js":
/*!***********************************************!*\
  !*** ../../packages/debugger/lib/debugger.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debugger": () => (/* binding */ Debugger)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ "../../packages/debugger/lib/config.js");
/* harmony import */ var _dialogs_evaluate__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dialogs/evaluate */ "../../packages/debugger/lib/dialogs/evaluate.js");
/* harmony import */ var _factory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./factory */ "../../packages/debugger/lib/factory.js");
/* harmony import */ var _handler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./handler */ "../../packages/debugger/lib/handler.js");
/* harmony import */ var _handlers_editor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./handlers/editor */ "../../packages/debugger/lib/handlers/editor.js");
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./icons */ "../../packages/debugger/lib/icons.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model */ "../../packages/debugger/lib/model.js");
/* harmony import */ var _panels_variables_grid__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./panels/variables/grid */ "../../packages/debugger/lib/panels/variables/grid.js");
/* harmony import */ var _panels_variables_mimerenderer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./panels/variables/mimerenderer */ "../../packages/debugger/lib/panels/variables/mimerenderer.js");
/* harmony import */ var _service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./service */ "../../packages/debugger/lib/service.js");
/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./session */ "../../packages/debugger/lib/session.js");
/* harmony import */ var _sidebar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sidebar */ "../../packages/debugger/lib/sidebar.js");
/* harmony import */ var _sources__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sources */ "../../packages/debugger/lib/sources.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.














/**
 * A namespace for `Debugger` statics.
 */
var Debugger;
(function (Debugger) {
    /**
     * Debugger configuration for all kernels.
     */
    class Config extends _config__WEBPACK_IMPORTED_MODULE_1__.DebuggerConfig {
    }
    Debugger.Config = Config;
    /**
     * A handler for a CodeEditor.IEditor.
     */
    class EditorHandler extends _handlers_editor__WEBPACK_IMPORTED_MODULE_2__.EditorHandler {
    }
    Debugger.EditorHandler = EditorHandler;
    /**
     * A handler for debugging a widget.
     */
    class Handler extends _handler__WEBPACK_IMPORTED_MODULE_3__.DebuggerHandler {
    }
    Debugger.Handler = Handler;
    /**
     * A model for a debugger.
     */
    class Model extends _model__WEBPACK_IMPORTED_MODULE_4__.DebuggerModel {
    }
    Debugger.Model = Model;
    /**
     * A widget factory for read only editors.
     */
    class ReadOnlyEditorFactory extends _factory__WEBPACK_IMPORTED_MODULE_5__.ReadOnlyEditorFactory {
    }
    Debugger.ReadOnlyEditorFactory = ReadOnlyEditorFactory;
    /**
     * The main IDebugger implementation.
     */
    class Service extends _service__WEBPACK_IMPORTED_MODULE_6__.DebuggerService {
    }
    Debugger.Service = Service;
    /**
     * A concrete implementation of IDebugger.ISession.
     */
    class Session extends _session__WEBPACK_IMPORTED_MODULE_7__.DebuggerSession {
    }
    Debugger.Session = Session;
    /**
     * The debugger sidebar UI.
     */
    class Sidebar extends _sidebar__WEBPACK_IMPORTED_MODULE_8__.DebuggerSidebar {
    }
    Debugger.Sidebar = Sidebar;
    /**
     * The source and editor manager for a debugger instance.
     */
    class Sources extends _sources__WEBPACK_IMPORTED_MODULE_9__.DebuggerSources {
    }
    Debugger.Sources = Sources;
    /**
     * A data grid that displays variables in a debugger session.
     */
    class VariablesGrid extends _panels_variables_grid__WEBPACK_IMPORTED_MODULE_10__.VariablesBodyGrid {
    }
    Debugger.VariablesGrid = VariablesGrid;
    /**
     * A widget to display data according to its mime type
     */
    class VariableRenderer extends _panels_variables_mimerenderer__WEBPACK_IMPORTED_MODULE_11__.VariableMimeRenderer {
    }
    Debugger.VariableRenderer = VariableRenderer;
    /**
     * The command IDs used by the debugger plugin.
     */
    let CommandIDs;
    (function (CommandIDs) {
        CommandIDs.debugContinue = 'debugger:continue';
        CommandIDs.terminate = 'debugger:terminate';
        CommandIDs.next = 'debugger:next';
        CommandIDs.stepIn = 'debugger:stepIn';
        CommandIDs.stepOut = 'debugger:stepOut';
        CommandIDs.inspectVariable = 'debugger:inspect-variable';
        CommandIDs.renderMimeVariable = 'debugger:render-mime-variable';
        CommandIDs.evaluate = 'debugger:evaluate';
        CommandIDs.restartDebug = 'debugger:restart-debug';
        CommandIDs.pause = 'debugger:pause';
    })(CommandIDs = Debugger.CommandIDs || (Debugger.CommandIDs = {}));
    /**
     * The debugger user interface icons.
     */
    let Icons;
    (function (Icons) {
        Icons.closeAllIcon = _icons__WEBPACK_IMPORTED_MODULE_12__.closeAllIcon;
        Icons.evaluateIcon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.codeIcon;
        Icons.continueIcon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.runIcon;
        Icons.stepIntoIcon = _icons__WEBPACK_IMPORTED_MODULE_12__.stepIntoIcon;
        Icons.stepOutIcon = _icons__WEBPACK_IMPORTED_MODULE_12__.stepOutIcon;
        Icons.stepOverIcon = _icons__WEBPACK_IMPORTED_MODULE_12__.stepOverIcon;
        Icons.terminateIcon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.stopIcon;
        Icons.variableIcon = _icons__WEBPACK_IMPORTED_MODULE_12__.variableIcon;
        Icons.viewBreakpointIcon = _icons__WEBPACK_IMPORTED_MODULE_12__.viewBreakpointIcon;
        Icons.pauseOnExceptionsIcon = _icons__WEBPACK_IMPORTED_MODULE_12__.pauseOnExceptionsIcon;
    })(Icons = Debugger.Icons || (Debugger.Icons = {}));
    /**
     * The debugger dialog helpers.
     */
    let Dialogs;
    (function (Dialogs) {
        /**
         * Open a code prompt in a dialog.
         */
        Dialogs.getCode = _dialogs_evaluate__WEBPACK_IMPORTED_MODULE_13__.DebuggerEvaluateDialog.getCode;
    })(Dialogs = Debugger.Dialogs || (Debugger.Dialogs = {}));
})(Debugger || (Debugger = {}));
//# sourceMappingURL=debugger.js.map

/***/ }),

/***/ "../../packages/debugger/lib/dialogs/evaluate.js":
/*!*******************************************************!*\
  !*** ../../packages/debugger/lib/dialogs/evaluate.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebuggerEvaluateDialog": () => (/* binding */ DebuggerEvaluateDialog)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/cells */ "webpack/sharing/consume/default/@jupyterlab/cells/@jupyterlab/cells");
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);



/**
 * A namespace for DebuggerEvaluateDialog statics.
 */
var DebuggerEvaluateDialog;
(function (DebuggerEvaluateDialog) {
    /**
     * Create and show a dialog to prompt user for code.
     *
     * @param options - The dialog setup options.
     *
     * @returns A promise that resolves with whether the dialog was accepted
     */
    function getCode(options) {
        const dialog = new EvaluateDialog(Object.assign(Object.assign({}, options), { body: new EvaluateDialogBody(options), buttons: [
                _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.cancelButton({ label: options.cancelLabel }),
                _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.okButton({ label: options.okLabel })
            ] }));
        return dialog.launch();
    }
    DebuggerEvaluateDialog.getCode = getCode;
})(DebuggerEvaluateDialog || (DebuggerEvaluateDialog = {}));
/**
 * A dialog to prompt users for code to evaluate.
 */
class EvaluateDialog extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog {
    /**
     * Handle the DOM events for the Evaluate dialog.
     *
     * @param event The DOM event sent to the dialog widget
     */
    handleEvent(event) {
        if (event.type === 'keydown') {
            const keyboardEvent = event;
            const { code, shiftKey } = keyboardEvent;
            if (shiftKey && code === 'Enter') {
                return this.resolve();
            }
            if (code === 'Enter') {
                return;
            }
        }
        super.handleEvent(event);
    }
}
/**
 * Widget body with a code cell prompt in a dialog
 */
class EvaluateDialogBody extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {
    /**
     * CodePromptDialog constructor
     *
     * @param options Constructor options
     */
    constructor(options) {
        super();
        const { rendermime, mimeType } = options;
        const model = new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.CodeCellModel({});
        model.mimeType = mimeType !== null && mimeType !== void 0 ? mimeType : '';
        this._prompt = new _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_1__.CodeCell({
            rendermime,
            model
        }).initializeState();
        // explicitly remove the prompt in front of the input area
        this._prompt.inputArea.promptNode.remove();
        this.node.appendChild(this._prompt.node);
    }
    /**
     * Get the text specified by the user
     */
    getValue() {
        return this._prompt.model.value.text;
    }
    /**
     *  A message handler invoked on an `'after-attach'` message.
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this._prompt.activate();
    }
}
//# sourceMappingURL=evaluate.js.map

/***/ }),

/***/ "../../packages/debugger/lib/factory.js":
/*!**********************************************!*\
  !*** ../../packages/debugger/lib/factory.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReadOnlyEditorFactory": () => (/* binding */ ReadOnlyEditorFactory)
/* harmony export */ });
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/codeeditor */ "webpack/sharing/consume/default/@jupyterlab/codeeditor/@jupyterlab/codeeditor");
/* harmony import */ var _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * A widget factory for read only editors.
 */
class ReadOnlyEditorFactory {
    /**
     * Construct a new editor widget factory.
     *
     * @param options The instantiation options for a ReadOnlyEditorFactory.
     */
    constructor(options) {
        this._services = options.editorServices;
    }
    /**
     * Create a new CodeEditorWrapper given a Source.
     *
     * @param source The source to create a new editor for.
     */
    createNewEditor(source) {
        const { content, mimeType, path } = source;
        const factory = this._services.factoryService.newInlineEditor;
        const mimeTypeService = this._services.mimeTypeService;
        const editor = new _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_0__.CodeEditorWrapper({
            model: new _jupyterlab_codeeditor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor.Model({
                value: content,
                mimeType: mimeType || mimeTypeService.getMimeTypeByFilePath(path)
            }),
            factory,
            config: {
                readOnly: true,
                lineNumbers: true
            }
        });
        editor.node.setAttribute('data-jp-debugger', 'true');
        return editor;
    }
}
//# sourceMappingURL=factory.js.map

/***/ }),

/***/ "../../packages/debugger/lib/handler.js":
/*!**********************************************!*\
  !*** ../../packages/debugger/lib/handler.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebuggerHandler": () => (/* binding */ DebuggerHandler)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _debugger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./debugger */ "../../packages/debugger/lib/debugger.js");
/* harmony import */ var _handlers_console__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./handlers/console */ "../../packages/debugger/lib/handlers/console.js");
/* harmony import */ var _handlers_file__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./handlers/file */ "../../packages/debugger/lib/handlers/file.js");
/* harmony import */ var _handlers_notebook__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./handlers/notebook */ "../../packages/debugger/lib/handlers/notebook.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







const TOOLBAR_DEBUGGER_ITEM = 'debugger-icon';
/**
 * Add a bug icon to the widget toolbar to enable and disable debugging.
 *
 * @param widget The widget to add the debug toolbar button to.
 * @param onClick The callback when the toolbar button is clicked.
 */
function updateIconButton(widget, onClick, enabled, pressed, translator = _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator) {
    const trans = translator.load('jupyterlab');
    const icon = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
        className: 'jp-DebuggerBugButton',
        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.bugIcon,
        tooltip: trans.__('Enable Debugger'),
        pressedIcon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.bugDotIcon,
        pressedTooltip: trans.__('Disable Debugger'),
        disabledTooltip: trans.__('Select a kernel that supports debugging to enable debugger'),
        enabled,
        pressed,
        onClick
    });
    if (!widget.toolbar.insertBefore('kernelName', TOOLBAR_DEBUGGER_ITEM, icon)) {
        widget.toolbar.addItem(TOOLBAR_DEBUGGER_ITEM, icon);
    }
    return icon;
}
/**
 * Updates button state to on/off,
 * adds/removes css class to update styling
 *
 * @param widget the debug button widget
 * @param pressed true if pressed, false otherwise
 * @param enabled true if widget enabled, false otherwise
 * @param onClick click handler
 */
function updateIconButtonState(widget, pressed, enabled = true, onClick) {
    if (widget) {
        widget.enabled = enabled;
        widget.pressed = pressed;
        if (onClick) {
            widget.onClick = onClick;
        }
    }
}
/**
 * A handler for debugging a widget.
 */
class DebuggerHandler {
    /**
     * Instantiate a new DebuggerHandler.
     *
     * @param options The instantiation options for a DebuggerHandler.
     */
    constructor(options) {
        this._handlers = {};
        this._contextKernelChangedHandlers = {};
        this._kernelChangedHandlers = {};
        this._statusChangedHandlers = {};
        this._iopubMessageHandlers = {};
        this._iconButtons = {};
        this._type = options.type;
        this._shell = options.shell;
        this._service = options.service;
    }
    /**
     * Get the active widget.
     */
    get activeWidget() {
        return this._activeWidget;
    }
    /**
     * Update a debug handler for the given widget, and
     * handle kernel changed events.
     *
     * @param widget The widget to update.
     * @param connection The session connection.
     */
    async update(widget, connection) {
        if (!connection) {
            delete this._kernelChangedHandlers[widget.id];
            delete this._statusChangedHandlers[widget.id];
            delete this._iopubMessageHandlers[widget.id];
            return this.updateWidget(widget, connection);
        }
        const kernelChanged = () => {
            void this.updateWidget(widget, connection);
        };
        const kernelChangedHandler = this._kernelChangedHandlers[widget.id];
        if (kernelChangedHandler) {
            connection.kernelChanged.disconnect(kernelChangedHandler);
        }
        this._kernelChangedHandlers[widget.id] = kernelChanged;
        connection.kernelChanged.connect(kernelChanged);
        const statusChanged = (_, status) => {
            // FIXME-TRANS: Localizable?
            if (status.endsWith('restarting')) {
                void this.updateWidget(widget, connection);
            }
        };
        const statusChangedHandler = this._statusChangedHandlers[widget.id];
        if (statusChangedHandler) {
            connection.statusChanged.disconnect(statusChangedHandler);
        }
        connection.statusChanged.connect(statusChanged);
        this._statusChangedHandlers[widget.id] = statusChanged;
        const iopubMessage = (_, msg) => {
            if (msg.parent_header != {} &&
                msg.parent_header.msg_type ==
                    'execute_request' &&
                this._service.isStarted &&
                !this._service.hasStoppedThreads()) {
                void this._service.displayDefinedVariables();
            }
        };
        const iopubMessageHandler = this._iopubMessageHandlers[widget.id];
        if (iopubMessageHandler) {
            connection.iopubMessage.disconnect(iopubMessageHandler);
        }
        connection.iopubMessage.connect(iopubMessage);
        this._iopubMessageHandlers[widget.id] = iopubMessage;
        this._activeWidget = widget;
        return this.updateWidget(widget, connection);
    }
    /**
     * Update a debug handler for the given widget, and
     * handle connection kernel changed events.
     *
     * @param widget The widget to update.
     * @param sessionContext The session context.
     */
    async updateContext(widget, sessionContext) {
        const connectionChanged = () => {
            const { session: connection } = sessionContext;
            void this.update(widget, connection);
        };
        const contextKernelChangedHandlers = this._contextKernelChangedHandlers[widget.id];
        if (contextKernelChangedHandlers) {
            sessionContext.kernelChanged.disconnect(contextKernelChangedHandlers);
        }
        this._contextKernelChangedHandlers[widget.id] = connectionChanged;
        sessionContext.kernelChanged.connect(connectionChanged);
        return this.update(widget, sessionContext.session);
    }
    /**
     * Update a debug handler for the given widget.
     *
     * @param widget The widget to update.
     * @param connection The session connection.
     */
    async updateWidget(widget, connection) {
        var _a, _b, _c, _d;
        if (!this._service.model || !connection) {
            return;
        }
        const hasFocus = () => {
            return this._shell.currentWidget === widget;
        };
        const updateAttribute = () => {
            if (!this._handlers[widget.id]) {
                widget.node.removeAttribute('data-jp-debugger');
                return;
            }
            widget.node.setAttribute('data-jp-debugger', 'true');
        };
        const createHandler = () => {
            if (this._handlers[widget.id]) {
                return;
            }
            switch (this._type) {
                case 'notebook':
                    this._handlers[widget.id] = new _handlers_notebook__WEBPACK_IMPORTED_MODULE_3__.NotebookHandler({
                        debuggerService: this._service,
                        widget: widget
                    });
                    break;
                case 'console':
                    this._handlers[widget.id] = new _handlers_console__WEBPACK_IMPORTED_MODULE_4__.ConsoleHandler({
                        debuggerService: this._service,
                        widget: widget
                    });
                    break;
                case 'file':
                    this._handlers[widget.id] = new _handlers_file__WEBPACK_IMPORTED_MODULE_5__.FileHandler({
                        debuggerService: this._service,
                        widget: widget
                    });
                    break;
                default:
                    throw Error(`No handler for the type ${this._type}`);
            }
            updateAttribute();
        };
        const removeHandlers = () => {
            var _a, _b, _c, _d;
            const handler = this._handlers[widget.id];
            if (!handler) {
                return;
            }
            handler.dispose();
            delete this._handlers[widget.id];
            delete this._kernelChangedHandlers[widget.id];
            delete this._statusChangedHandlers[widget.id];
            delete this._iopubMessageHandlers[widget.id];
            delete this._contextKernelChangedHandlers[widget.id];
            // Clear the model if the handler being removed corresponds
            // to the current active debug session, or if the connection
            // does not have a kernel.
            if (((_b = (_a = this._service.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.path) === (connection === null || connection === void 0 ? void 0 : connection.path) ||
                !((_d = (_c = this._service.session) === null || _c === void 0 ? void 0 : _c.connection) === null || _d === void 0 ? void 0 : _d.kernel)) {
                const model = this._service.model;
                model.clear();
            }
            updateAttribute();
        };
        const addToolbarButton = (enabled = true) => {
            const debugButton = this._iconButtons[widget.id];
            if (!debugButton) {
                this._iconButtons[widget.id] = updateIconButton(widget, toggleDebugging, this._service.isStarted, enabled);
            }
            else {
                updateIconButtonState(debugButton, this._service.isStarted, enabled, toggleDebugging);
            }
        };
        const isDebuggerOn = () => {
            var _a;
            return (this._service.isStarted &&
                ((_a = this._previousConnection) === null || _a === void 0 ? void 0 : _a.id) === (connection === null || connection === void 0 ? void 0 : connection.id));
        };
        const stopDebugger = async () => {
            this._service.session.connection = connection;
            await this._service.stop();
        };
        const startDebugger = async () => {
            var _a, _b;
            this._service.session.connection = connection;
            this._previousConnection = connection;
            await this._service.restoreState(true);
            await this._service.displayDefinedVariables();
            if ((_b = (_a = this._service.session) === null || _a === void 0 ? void 0 : _a.capabilities) === null || _b === void 0 ? void 0 : _b.supportsModulesRequest) {
                await this._service.displayModules();
            }
        };
        const toggleDebugging = async () => {
            // bail if the widget doesn't have focus
            if (!hasFocus()) {
                return;
            }
            const debugButton = this._iconButtons[widget.id];
            if (isDebuggerOn()) {
                await stopDebugger();
                removeHandlers();
                updateIconButtonState(debugButton, false);
            }
            else {
                await startDebugger();
                createHandler();
                updateIconButtonState(debugButton, true);
            }
        };
        addToolbarButton(false);
        const debuggingEnabled = await this._service.isAvailable(connection);
        if (!debuggingEnabled) {
            removeHandlers();
            updateIconButtonState(this._iconButtons[widget.id], false, false);
            return;
        }
        // update the active debug session
        if (!this._service.session) {
            this._service.session = new _debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.Session({ connection });
        }
        else {
            this._previousConnection = ((_a = this._service.session.connection) === null || _a === void 0 ? void 0 : _a.kernel) ? this._service.session.connection
                : null;
            this._service.session.connection = connection;
        }
        await this._service.restoreState(false);
        if (this._service.isStarted && !this._service.hasStoppedThreads()) {
            await this._service.displayDefinedVariables();
            if ((_c = (_b = this._service.session) === null || _b === void 0 ? void 0 : _b.capabilities) === null || _c === void 0 ? void 0 : _c.supportsModulesRequest) {
                await this._service.displayModules();
            }
        }
        updateIconButtonState(this._iconButtons[widget.id], this._service.isStarted, true);
        // check the state of the debug session
        if (!this._service.isStarted) {
            removeHandlers();
            this._service.session.connection = (_d = this._previousConnection) !== null && _d !== void 0 ? _d : connection;
            await this._service.restoreState(false);
            return;
        }
        // if the debugger is started but there is no handler, create a new one
        createHandler();
        this._previousConnection = connection;
        // listen to the disposed signals
        widget.disposed.connect(removeHandlers);
    }
}
//# sourceMappingURL=handler.js.map

/***/ }),

/***/ "../../packages/debugger/lib/handlers/console.js":
/*!*******************************************************!*\
  !*** ../../packages/debugger/lib/handlers/console.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConsoleHandler": () => (/* binding */ ConsoleHandler)
/* harmony export */ });
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/observables */ "webpack/sharing/consume/default/@jupyterlab/observables/@jupyterlab/observables");
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/algorithm */ "webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm");
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _handlers_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../handlers/editor */ "../../packages/debugger/lib/handlers/editor.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/**
 * A handler for consoles.
 */
class ConsoleHandler {
    /**
     * Instantiate a new ConsoleHandler.
     *
     * @param options The instantiation options for a ConsoleHandler.
     */
    constructor(options) {
        this._debuggerService = options.debuggerService;
        this._consolePanel = options.widget;
        this._cellMap = new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__.ObservableMap();
        const codeConsole = this._consolePanel.console;
        if (codeConsole.promptCell) {
            this._addEditorHandler(codeConsole.promptCell);
        }
        codeConsole.promptCellCreated.connect((_, cell) => {
            this._addEditorHandler(cell);
        });
        const addHandlers = () => {
            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.each)(codeConsole.cells, cell => this._addEditorHandler(cell));
        };
        addHandlers();
        this._consolePanel.console.cells.changed.connect(addHandlers);
    }
    /**
     * Dispose the handler.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        this._cellMap.values().forEach(handler => handler.dispose());
        this._cellMap.dispose();
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal.clearData(this);
    }
    /**
     * Add a new editor handler for the given cell.
     *
     * @param cell The cell to add the handler to.
     */
    _addEditorHandler(cell) {
        const modelId = cell.model.id;
        if (cell.model.type !== 'code' || this._cellMap.has(modelId)) {
            return;
        }
        const codeCell = cell;
        const editorHandler = new _handlers_editor__WEBPACK_IMPORTED_MODULE_3__.EditorHandler({
            debuggerService: this._debuggerService,
            editor: codeCell.editor
        });
        codeCell.disposed.connect(() => {
            this._cellMap.delete(modelId);
            editorHandler.dispose();
        });
        this._cellMap.set(modelId, editorHandler);
    }
}
//# sourceMappingURL=console.js.map

/***/ }),

/***/ "../../packages/debugger/lib/handlers/editor.js":
/*!******************************************************!*\
  !*** ../../packages/debugger/lib/handlers/editor.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditorHandler": () => (/* binding */ EditorHandler)
/* harmony export */ });
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/coreutils */ "webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils");
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * The class name added to the current line.
 */
const LINE_HIGHLIGHT_CLASS = 'jp-DebuggerEditor-highlight';
/**
 * The timeout for listening to editor content changes.
 */
const EDITOR_CHANGED_TIMEOUT = 1000;
/**
 * A handler for a CodeEditor.IEditor.
 */
class EditorHandler {
    /**
     * Instantiate a new EditorHandler.
     *
     * @param options The instantiation options for a EditorHandler.
     */
    constructor(options) {
        var _a, _b, _c, _d;
        /**
         * Handle a click on the gutter.
         *
         * @param editor The editor from where the click originated.
         * @param lineNumber The line corresponding to the click event.
         */
        this._onGutterClick = (editor, lineNumber) => {
            var _a, _b, _c;
            const info = editor.lineInfo(lineNumber);
            if (!info || this._id !== ((_b = (_a = this._debuggerService.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.id)) {
                return;
            }
            const remove = !!info.gutterMarkers;
            let breakpoints = this._getBreakpoints();
            if (remove) {
                breakpoints = breakpoints.filter(ele => ele.line !== info.line + 1);
            }
            else {
                breakpoints.push(Private.createBreakpoint((_c = this._path) !== null && _c !== void 0 ? _c : this._debuggerService.session.connection.name, info.line + 1));
            }
            void this._debuggerService.updateBreakpoints(this._editor.model.value.text, breakpoints, this._path);
        };
        this._id = (_c = (_b = (_a = options.debuggerService.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : '';
        this._path = (_d = options.path) !== null && _d !== void 0 ? _d : '';
        this._debuggerService = options.debuggerService;
        this._editor = options.editor;
        this._editorMonitor = new _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__.ActivityMonitor({
            signal: this._editor.model.value.changed,
            timeout: EDITOR_CHANGED_TIMEOUT
        });
        this._editorMonitor.activityStopped.connect(() => {
            this._sendEditorBreakpoints();
        }, this);
        this._debuggerService.model.breakpoints.changed.connect(async () => {
            if (!this._editor || this._editor.isDisposed) {
                return;
            }
            this._addBreakpointsToEditor();
        });
        this._debuggerService.model.breakpoints.restored.connect(async () => {
            if (!this._editor || this._editor.isDisposed) {
                return;
            }
            this._addBreakpointsToEditor();
        });
        this._debuggerService.model.callstack.currentFrameChanged.connect(() => {
            EditorHandler.clearHighlight(this._editor);
        });
        this._setupEditor();
    }
    /**
     * The editor
     */
    get editor() {
        return this._editor;
    }
    /**
     * Dispose the handler.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._editorMonitor.dispose();
        this._clearEditor();
        this.isDisposed = true;
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);
    }
    /**
     * Refresh the breakpoints display
     */
    refreshBreakpoints() {
        this._addBreakpointsToEditor();
    }
    /**
     * Setup the editor.
     */
    _setupEditor() {
        if (!this._editor || this._editor.isDisposed) {
            return;
        }
        this._addBreakpointsToEditor();
        const editor = this._editor;
        editor.setOption('lineNumbers', true);
        editor.editor.setOption('gutters', [
            'CodeMirror-linenumbers',
            'breakpoints'
        ]);
        editor.editor.on('gutterClick', this._onGutterClick);
    }
    /**
     * Clear the editor by removing visual elements and handlers.
     */
    _clearEditor() {
        if (!this._editor || this._editor.isDisposed) {
            return;
        }
        const editor = this._editor;
        EditorHandler.clearHighlight(editor);
        EditorHandler.clearGutter(editor);
        editor.setOption('lineNumbers', false);
        editor.editor.setOption('gutters', []);
        editor.editor.off('gutterClick', this._onGutterClick);
    }
    /**
     * Send the breakpoints from the editor UI via the debug service.
     */
    _sendEditorBreakpoints() {
        if (this._editor.isDisposed) {
            return;
        }
        const breakpoints = this._getBreakpointsFromEditor().map(lineInfo => {
            var _a, _b;
            return Private.createBreakpoint(((_b = (_a = this._debuggerService.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.name) || '', lineInfo.line + 1);
        });
        void this._debuggerService.updateBreakpoints(this._editor.model.value.text, breakpoints, this._path);
    }
    /**
     * Add the breakpoints to the editor.
     */
    _addBreakpointsToEditor() {
        var _a, _b;
        const editor = this._editor;
        const breakpoints = this._getBreakpoints();
        if (this._id !== ((_b = (_a = this._debuggerService.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.id)) {
            return;
        }
        EditorHandler.clearGutter(editor);
        breakpoints.forEach(breakpoint => {
            if (typeof breakpoint.line === 'number') {
                editor.editor.setGutterMarker(breakpoint.line - 1, 'breakpoints', Private.createMarkerNode());
            }
        });
    }
    /**
     * Retrieve the breakpoints from the editor.
     */
    _getBreakpointsFromEditor() {
        const editor = this._editor;
        let lines = [];
        for (let i = 0; i < editor.doc.lineCount(); i++) {
            const info = editor.editor.lineInfo(i);
            if (info.gutterMarkers) {
                lines.push(info);
            }
        }
        return lines;
    }
    /**
     * Get the breakpoints for the editor using its content (code),
     * or its path (if it exists).
     */
    _getBreakpoints() {
        const code = this._editor.model.value.text;
        return this._debuggerService.model.breakpoints.getBreakpoints(this._path || this._debuggerService.getCodeId(code));
    }
}
/**
 * A namespace for EditorHandler `statics`.
 */
(function (EditorHandler) {
    /**
     * Highlight the current line of the frame in the given editor.
     *
     * @param editor The editor to highlight.
     * @param line The line number.
     */
    function showCurrentLine(editor, line) {
        clearHighlight(editor);
        const cmEditor = editor;
        cmEditor.editor.addLineClass(line - 1, 'wrap', LINE_HIGHLIGHT_CLASS);
        cmEditor.scrollIntoViewCentered({ ch: 0, line: line - 1 });
    }
    EditorHandler.showCurrentLine = showCurrentLine;
    /**
     * Remove all line highlighting indicators for the given editor.
     *
     * @param editor The editor to cleanup.
     */
    function clearHighlight(editor) {
        if (!editor || editor.isDisposed) {
            return;
        }
        const cmEditor = editor;
        cmEditor.doc.eachLine(line => {
            cmEditor.editor.removeLineClass(line, 'wrap', LINE_HIGHLIGHT_CLASS);
        });
    }
    EditorHandler.clearHighlight = clearHighlight;
    /**
     * Remove line numbers and all gutters from editor.
     *
     * @param editor The editor to cleanup.
     */
    function clearGutter(editor) {
        if (!editor) {
            return;
        }
        const cmEditor = editor;
        cmEditor.doc.eachLine(line => {
            if (line.gutterMarkers) {
                cmEditor.editor.setGutterMarker(line, 'breakpoints', null);
            }
        });
    }
    EditorHandler.clearGutter = clearGutter;
})(EditorHandler || (EditorHandler = {}));
/**
 * A namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Create a marker DOM element for a breakpoint.
     */
    function createMarkerNode() {
        const marker = document.createElement('div');
        marker.className = 'jp-DebuggerEditor-marker';
        marker.innerHTML = '●';
        return marker;
    }
    Private.createMarkerNode = createMarkerNode;
    /**
     * Create a new breakpoint.
     *
     * @param session The name of the session.
     * @param line The line number of the breakpoint.
     */
    function createBreakpoint(session, line) {
        return {
            line,
            verified: true,
            source: {
                name: session
            }
        };
    }
    Private.createBreakpoint = createBreakpoint;
})(Private || (Private = {}));
//# sourceMappingURL=editor.js.map

/***/ }),

/***/ "../../packages/debugger/lib/handlers/file.js":
/*!****************************************************!*\
  !*** ../../packages/debugger/lib/handlers/file.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileHandler": () => (/* binding */ FileHandler)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _handlers_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../handlers/editor */ "../../packages/debugger/lib/handlers/editor.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * A handler for files.
 */
class FileHandler {
    /**
     * Instantiate a new FileHandler.
     *
     * @param options The instantiation options for a FileHandler.
     */
    constructor(options) {
        this._debuggerService = options.debuggerService;
        this._fileEditor = options.widget.content;
        this._hasLineNumber = this._fileEditor.editor.getOption('lineNumbers');
        this._editorHandler = new _handlers_editor__WEBPACK_IMPORTED_MODULE_1__.EditorHandler({
            debuggerService: this._debuggerService,
            editor: this._fileEditor.editor
        });
    }
    /**
     * Dispose the handler.
     */
    dispose() {
        var _a, _b;
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        (_a = this._editorHandler) === null || _a === void 0 ? void 0 : _a.dispose();
        // Restore editor options
        (_b = this._editorHandler) === null || _b === void 0 ? void 0 : _b.editor.setOptions({
            lineNumbers: this._hasLineNumber
        });
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal.clearData(this);
    }
}
//# sourceMappingURL=file.js.map

/***/ }),

/***/ "../../packages/debugger/lib/handlers/notebook.js":
/*!********************************************************!*\
  !*** ../../packages/debugger/lib/handlers/notebook.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotebookHandler": () => (/* binding */ NotebookHandler)
/* harmony export */ });
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/observables */ "webpack/sharing/consume/default/@jupyterlab/observables/@jupyterlab/observables");
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editor */ "../../packages/debugger/lib/handlers/editor.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * A handler for notebooks.
 */
class NotebookHandler {
    /**
     * Instantiate a new NotebookHandler.
     *
     * @param options The instantiation options for a NotebookHandler.
     */
    constructor(options) {
        var _a;
        this._debuggerService = options.debuggerService;
        this._notebookPanel = options.widget;
        this._cellMap = new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_0__.ObservableMap();
        const notebook = this._notebookPanel.content;
        notebook.activeCellChanged.connect(this._onActiveCellChanged, this);
        (_a = notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this._onCellsChanged, this);
        this._onCellsChanged();
    }
    /**
     * Dispose the handler.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        this._cellMap.values().forEach(handler => {
            handler.dispose();
            // Ensure to restore notebook editor settings
            handler.editor.setOptions(Object.assign({}, this._notebookPanel.content.editorConfig.code));
        });
        this._cellMap.dispose();
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);
    }
    /**
     * Handle a notebook cells changed event.
     */
    _onCellsChanged(cells, changes) {
        var _a;
        this._notebookPanel.content.widgets.forEach(cell => this._addEditorHandler(cell));
        if ((changes === null || changes === void 0 ? void 0 : changes.type) === 'move') {
            for (const cell of changes.newValues) {
                (_a = this._cellMap.get(cell.id)) === null || _a === void 0 ? void 0 : _a.refreshBreakpoints();
            }
        }
    }
    /**
     * Add a new editor handler for the given cell.
     *
     * @param cell The cell to add the handler to.
     */
    _addEditorHandler(cell) {
        const modelId = cell.model.id;
        if (cell.model.type !== 'code' || this._cellMap.has(modelId)) {
            return;
        }
        const codeCell = cell;
        const editorHandler = new _editor__WEBPACK_IMPORTED_MODULE_2__.EditorHandler({
            debuggerService: this._debuggerService,
            editor: codeCell.editor
        });
        codeCell.disposed.connect(() => {
            this._cellMap.delete(modelId);
            editorHandler.dispose();
        });
        this._cellMap.set(cell.model.id, editorHandler);
    }
    /**
     * Handle a new active cell.
     *
     * @param notebook The notebook for which the active cell has changed.
     * @param cell The new active cell.
     */
    _onActiveCellChanged(notebook, cell) {
        if (this._notebookPanel.content !== notebook) {
            return;
        }
        this._addEditorHandler(cell);
    }
}
//# sourceMappingURL=notebook.js.map

/***/ }),

/***/ "../../packages/debugger/lib/hash.js":
/*!*******************************************!*\
  !*** ../../packages/debugger/lib/hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "murmur2": () => (/* binding */ murmur2)
/* harmony export */ });
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// Most of the implementation below is adapted from the following repository:
// https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js
// Which has the following MIT License:
//
// Copyright (c) 2011 Gary Court
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
//  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// The implementation below uses case fallthrough as part of the algorithm.
/* eslint-disable no-fallthrough */
const m = 0x5bd1e995;
const encoder = new TextEncoder();
/**
 * Calculate the murmurhash2 for a given string and seed.
 *
 * @param str The string to calculate the Murmur2 hash for.
 * @param seed The seed.
 *
 * @returns The Murmurhash2 hash.
 */
function murmur2(str, seed) {
    const data = encoder.encode(str);
    let len = data.length;
    let h = seed ^ len;
    let i = 0;
    while (len >= 4) {
        let k = (data[i] & 0xff) |
            ((data[++i] & 0xff) << 8) |
            ((data[++i] & 0xff) << 16) |
            ((data[++i] & 0xff) << 24);
        k = (k & 0xffff) * m + ((((k >>> 16) * m) & 0xffff) << 16);
        k ^= k >>> 24;
        k = (k & 0xffff) * m + ((((k >>> 16) * m) & 0xffff) << 16);
        h = ((h & 0xffff) * m + ((((h >>> 16) * m) & 0xffff) << 16)) ^ k;
        len -= 4;
        ++i;
    }
    switch (len) {
        case 3:
            h ^= (data[i + 2] & 0xff) << 16;
        case 2:
            h ^= (data[i + 1] & 0xff) << 8;
        case 1:
            h ^= data[i] & 0xff;
            h = (h & 0xffff) * m + ((((h >>> 16) * m) & 0xffff) << 16);
    }
    h ^= h >>> 13;
    h = (h & 0xffff) * m + ((((h >>> 16) * m) & 0xffff) << 16);
    h ^= h >>> 15;
    return h >>> 0;
}
//# sourceMappingURL=hash.js.map

/***/ }),

/***/ "../../packages/debugger/lib/icons.js":
/*!********************************************!*\
  !*** ../../packages/debugger/lib/icons.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "continueIcon": () => (/* reexport safe */ _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.runIcon),
/* harmony export */   "terminateIcon": () => (/* reexport safe */ _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.stopIcon),
/* harmony export */   "closeAllIcon": () => (/* binding */ closeAllIcon),
/* harmony export */   "pauseOnExceptionsIcon": () => (/* binding */ pauseOnExceptionsIcon),
/* harmony export */   "stepIntoIcon": () => (/* binding */ stepIntoIcon),
/* harmony export */   "stepOverIcon": () => (/* binding */ stepOverIcon),
/* harmony export */   "stepOutIcon": () => (/* binding */ stepOutIcon),
/* harmony export */   "variableIcon": () => (/* binding */ variableIcon),
/* harmony export */   "viewBreakpointIcon": () => (/* binding */ viewBreakpointIcon),
/* harmony export */   "openKernelSourceIcon": () => (/* binding */ openKernelSourceIcon)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_icons_close_all_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/icons/close-all.svg */ "../../packages/debugger/style/icons/close-all.svg");
/* harmony import */ var _style_icons_step_into_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style/icons/step-into.svg */ "../../packages/debugger/style/icons/step-into.svg");
/* harmony import */ var _style_icons_step_out_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style/icons/step-out.svg */ "../../packages/debugger/style/icons/step-out.svg");
/* harmony import */ var _style_icons_step_over_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style/icons/step-over.svg */ "../../packages/debugger/style/icons/step-over.svg");
/* harmony import */ var _style_icons_variable_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../style/icons/variable.svg */ "../../packages/debugger/style/icons/variable.svg");
/* harmony import */ var _style_icons_pause_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style/icons/pause.svg */ "../../packages/debugger/style/icons/pause.svg");
/* harmony import */ var _style_icons_view_breakpoint_svg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/icons/view-breakpoint.svg */ "../../packages/debugger/style/icons/view-breakpoint.svg");
/* harmony import */ var _style_icons_open_kernel_source_svg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../style/icons/open-kernel-source.svg */ "../../packages/debugger/style/icons/open-kernel-source.svg");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.










const closeAllIcon = new _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: 'debugger:close-all',
    svgstr: _style_icons_close_all_svg__WEBPACK_IMPORTED_MODULE_1__.default
});
const pauseOnExceptionsIcon = new _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: 'debugger:pause',
    svgstr: _style_icons_pause_svg__WEBPACK_IMPORTED_MODULE_2__.default
});
const stepIntoIcon = new _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: 'debugger:step-into',
    svgstr: _style_icons_step_into_svg__WEBPACK_IMPORTED_MODULE_3__.default
});
const stepOverIcon = new _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: 'debugger:step-over',
    svgstr: _style_icons_step_over_svg__WEBPACK_IMPORTED_MODULE_4__.default
});
const stepOutIcon = new _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: 'debugger:step-out',
    svgstr: _style_icons_step_out_svg__WEBPACK_IMPORTED_MODULE_5__.default
});
const variableIcon = new _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: 'debugger:variable',
    svgstr: _style_icons_variable_svg__WEBPACK_IMPORTED_MODULE_6__.default
});
const viewBreakpointIcon = new _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: 'debugger:view-breakpoint',
    svgstr: _style_icons_view_breakpoint_svg__WEBPACK_IMPORTED_MODULE_7__.default
});
const openKernelSourceIcon = new _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: 'debugger:open-kernel-source',
    svgstr: _style_icons_open_kernel_source_svg__WEBPACK_IMPORTED_MODULE_8__.default
});
//# sourceMappingURL=icons.js.map

/***/ }),

/***/ "../../packages/debugger/lib/index.js":
/*!********************************************!*\
  !*** ../../packages/debugger/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debugger": () => (/* reexport safe */ _debugger__WEBPACK_IMPORTED_MODULE_0__.Debugger),
/* harmony export */   "IDebugger": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_1__.IDebugger),
/* harmony export */   "IDebuggerConfig": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_1__.IDebuggerConfig),
/* harmony export */   "IDebuggerSources": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_1__.IDebuggerSources),
/* harmony export */   "IDebuggerSidebar": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_1__.IDebuggerSidebar),
/* harmony export */   "IDebuggerHandler": () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_1__.IDebuggerHandler)
/* harmony export */ });
/* harmony import */ var _debugger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debugger */ "../../packages/debugger/lib/debugger.js");
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokens */ "../../packages/debugger/lib/tokens.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module debugger
 */


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../packages/debugger/lib/model.js":
/*!********************************************!*\
  !*** ../../packages/debugger/lib/model.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebuggerModel": () => (/* binding */ DebuggerModel)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _panels_breakpoints_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./panels/breakpoints/model */ "../../packages/debugger/lib/panels/breakpoints/model.js");
/* harmony import */ var _panels_callstack_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./panels/callstack/model */ "../../packages/debugger/lib/panels/callstack/model.js");
/* harmony import */ var _panels_sources_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./panels/sources/model */ "../../packages/debugger/lib/panels/sources/model.js");
/* harmony import */ var _panels_kernelSources_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./panels/kernelSources/model */ "../../packages/debugger/lib/panels/kernelSources/model.js");
/* harmony import */ var _panels_variables_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./panels/variables/model */ "../../packages/debugger/lib/panels/variables/model.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/**
 * A model for a debugger.
 */
class DebuggerModel {
    /**
     * Instantiate a new DebuggerModel
     */
    constructor() {
        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._isDisposed = false;
        this._hasRichVariableRendering = false;
        this._stoppedThreads = new Set();
        this._title = '-';
        this._titleChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this.breakpoints = new _panels_breakpoints_model__WEBPACK_IMPORTED_MODULE_1__.BreakpointsModel();
        this.callstack = new _panels_callstack_model__WEBPACK_IMPORTED_MODULE_2__.CallstackModel();
        this.variables = new _panels_variables_model__WEBPACK_IMPORTED_MODULE_3__.VariablesModel();
        this.sources = new _panels_sources_model__WEBPACK_IMPORTED_MODULE_4__.SourcesModel({
            currentFrameChanged: this.callstack.currentFrameChanged
        });
        this.kernelSources = new _panels_kernelSources_model__WEBPACK_IMPORTED_MODULE_5__.KernelSourcesModel();
    }
    /**
     * A signal emitted when the debugger widget is disposed.
     */
    get disposed() {
        return this._disposed;
    }
    /**
     * Whether the kernel support rich variable rendering based on mime type.
     */
    get hasRichVariableRendering() {
        return this._hasRichVariableRendering;
    }
    set hasRichVariableRendering(v) {
        this._hasRichVariableRendering = v;
    }
    /**
     * Whether the model is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * The set of threads in stopped state.
     */
    get stoppedThreads() {
        return this._stoppedThreads;
    }
    /**
     * Assigns the parameters to the set of threads in stopped state.
     */
    set stoppedThreads(threads) {
        this._stoppedThreads = threads;
    }
    /**
     * The current debugger title.
     */
    get title() {
        return this._title;
    }
    /**
     * Set the current debugger title.
     */
    set title(title) {
        if (title === this._title) {
            return;
        }
        this._title = title !== null && title !== void 0 ? title : '-';
        this._titleChanged.emit(title);
    }
    /**
     * A signal emitted when the title changes.
     */
    get titleChanged() {
        return this._titleChanged;
    }
    /**
     * Dispose the model.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._disposed.emit();
    }
    /**
     * Clear the model.
     */
    clear() {
        this._stoppedThreads.clear();
        const breakpoints = new Map();
        this.breakpoints.restoreBreakpoints(breakpoints);
        this.callstack.frames = [];
        this.variables.scopes = [];
        this.sources.currentSource = null;
        this.kernelSources.kernelSources = null;
        this.title = '-';
    }
}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/breakpoints/body.js":
/*!**************************************************************!*\
  !*** ../../packages/debugger/lib/panels/breakpoints/body.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BreakpointsBody": () => (/* binding */ BreakpointsBody)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * The body for a Breakpoints Panel.
 */
class BreakpointsBody extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget {
    /**
     * Instantiate a new Body for the Breakpoints Panel.
     *
     * @param model The model for the breakpoints.
     */
    constructor(model) {
        super();
        this._model = model;
        this.addClass('jp-DebuggerBreakpoints-body');
    }
    /**
     * Render the BreakpointsComponent.
     */
    render() {
        return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(BreakpointsComponent, { model: this._model });
    }
}
/**
 * A React component to display a list of breakpoints.
 *
 * @param {object} props The component props.
 * @param props.model The model for the breakpoints.
 */
const BreakpointsComponent = ({ model }) => {
    const [breakpoints, setBreakpoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Array.from(model.breakpoints.entries()));
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        const updateBreakpoints = (_, updates) => {
            setBreakpoints(Array.from(model.breakpoints.entries()));
        };
        const restoreBreakpoints = (_) => {
            setBreakpoints(Array.from(model.breakpoints.entries()));
        };
        model.changed.connect(updateBreakpoints);
        model.restored.connect(restoreBreakpoints);
        return () => {
            model.changed.disconnect(updateBreakpoints);
            model.restored.disconnect(restoreBreakpoints);
        };
    });
    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, breakpoints.map(entry => (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(BreakpointCellComponent, { key: entry[0], breakpoints: entry[1], model: model })))));
};
/**
 * A React Component to display breakpoints grouped by source file.
 *
 * @param {object} props The component props.
 * @param props.breakpoints The list of breakpoints.
 * @param props.model The model for the breakpoints.
 */
const BreakpointCellComponent = ({ breakpoints, model }) => {
    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, breakpoints
        .sort((a, b) => {
        var _a, _b;
        return ((_a = a.line) !== null && _a !== void 0 ? _a : 0) - ((_b = b.line) !== null && _b !== void 0 ? _b : 0);
    })
        .map((breakpoint, index) => {
        var _a, _b;
        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(BreakpointComponent, { key: ((_b = (_a = breakpoint.source) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '') + index, breakpoint: breakpoint, model: model }));
    })));
};
/**
 * A React Component to display a single breakpoint.
 *
 * @param {object} props The component props.
 * @param props.breakpoint The breakpoint.
 * @param props.model The model for the breakpoints.
 */
const BreakpointComponent = ({ breakpoint, model }) => {
    var _a, _b, _c;
    const moveToEndFirstCharIfSlash = (breakpointSourcePath) => {
        return breakpointSourcePath[0] === '/'
            ? breakpointSourcePath.slice(1) + '/'
            : breakpointSourcePath;
    };
    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement("div", { className: 'jp-DebuggerBreakpoint', onClick: () => model.clicked.emit(breakpoint), title: (_a = breakpoint.source) === null || _a === void 0 ? void 0 : _a.path },
        react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { className: 'jp-DebuggerBreakpoint-marker' }, "\u25CF"),
        react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { className: 'jp-DebuggerBreakpoint-source jp-left-truncated' }, moveToEndFirstCharIfSlash((_c = (_b = breakpoint.source) === null || _b === void 0 ? void 0 : _b.path) !== null && _c !== void 0 ? _c : '')),
        react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { className: 'jp-DebuggerBreakpoint-line' }, breakpoint.line)));
};
//# sourceMappingURL=body.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/breakpoints/header.js":
/*!****************************************************************!*\
  !*** ../../packages/debugger/lib/panels/breakpoints/header.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BreakpointsHeader": () => (/* binding */ BreakpointsHeader)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The header for a Breakpoints Panel.
 */
class BreakpointsHeader extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {
    /**
     * Instantiate a new BreakpointsHeader.
     */
    constructor(translator) {
        super({ node: document.createElement('div') });
        /**
         * The toolbar for the breakpoints header.
         */
        this.toolbar = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar();
        this.node.classList.add('jp-stack-panel-header');
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
        const trans = translator.load('jupyterlab');
        const title = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget({ node: document.createElement('h2') });
        title.node.textContent = trans.__('Breakpoints');
        const layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.PanelLayout();
        layout.addWidget(title);
        layout.addWidget(this.toolbar);
        this.layout = layout;
    }
}
//# sourceMappingURL=header.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/breakpoints/index.js":
/*!***************************************************************!*\
  !*** ../../packages/debugger/lib/panels/breakpoints/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Breakpoints": () => (/* binding */ Breakpoints)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../icons */ "../../packages/debugger/lib/icons.js");
/* harmony import */ var _body__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./body */ "../../packages/debugger/lib/panels/breakpoints/body.js");
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./header */ "../../packages/debugger/lib/panels/breakpoints/header.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







/**
 * A Panel to show a list of breakpoints.
 */
class Breakpoints extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__.Panel {
    /**
     * Instantiate a new Breakpoints Panel.
     *
     * @param options The instantiation options for a Breakpoints Panel.
     */
    constructor(options) {
        var _a;
        super(options);
        this.clicked = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);
        const { model, service, commands } = options;
        const translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
        const trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        this.title.label = trans.__('Breakpoints');
        const header = new _header__WEBPACK_IMPORTED_MODULE_4__.BreakpointsHeader(translator);
        const body = new _body__WEBPACK_IMPORTED_MODULE_5__.BreakpointsBody(model);
        header.toolbar.addItem('pause', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.CommandToolbarButton({
            commands: commands.registry,
            id: commands.pause,
            label: ''
        }));
        header.toolbar.addItem('closeAll', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _icons__WEBPACK_IMPORTED_MODULE_6__.closeAllIcon,
            onClick: async () => {
                if (model.breakpoints.size === 0) {
                    return;
                }
                const result = await (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.showDialog)({
                    title: trans.__('Remove All Breakpoints'),
                    body: trans.__('Are you sure you want to remove all breakpoints?'),
                    buttons: [
                        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.okButton({ label: trans.__('Remove breakpoints') }),
                        _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Dialog.cancelButton({ label: trans.__('Cancel') })
                    ],
                    hasClose: true
                });
                if (result.button.accept) {
                    return service.clearBreakpoints();
                }
            },
            tooltip: trans.__('Remove All Breakpoints')
        }));
        this.addWidget(header);
        this.addWidget(body);
        this.addClass('jp-DebuggerBreakpoints');
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/breakpoints/model.js":
/*!***************************************************************!*\
  !*** ../../packages/debugger/lib/panels/breakpoints/model.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BreakpointsModel": () => (/* binding */ BreakpointsModel)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * A model for a list of breakpoints.
 */
class BreakpointsModel {
    constructor() {
        this._breakpoints = new Map();
        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._restored = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._clicked = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
    }
    /**
     * Signal emitted when the model changes.
     */
    get changed() {
        return this._changed;
    }
    /**
     * Signal emitted when the breakpoints are restored.
     */
    get restored() {
        return this._restored;
    }
    /**
     * Signal emitted when a breakpoint is clicked.
     */
    get clicked() {
        return this._clicked;
    }
    /**
     * Get all the breakpoints.
     */
    get breakpoints() {
        return this._breakpoints;
    }
    /**
     * Set the breakpoints for a given id (path).
     *
     * @param id The code id (path).
     * @param breakpoints The list of breakpoints.
     */
    setBreakpoints(id, breakpoints) {
        this._breakpoints.set(id, breakpoints);
        this._changed.emit(breakpoints);
    }
    /**
     * Get the breakpoints for a given id (path).
     *
     * @param id The code id (path).
     */
    getBreakpoints(id) {
        var _a;
        return (_a = this._breakpoints.get(id)) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Restore a map of breakpoints.
     *
     * @param breakpoints The map of breakpoints
     */
    restoreBreakpoints(breakpoints) {
        this._breakpoints = breakpoints;
        this._restored.emit();
    }
}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/callstack/body.js":
/*!************************************************************!*\
  !*** ../../packages/debugger/lib/panels/callstack/body.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CallstackBody": () => (/* binding */ CallstackBody)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/coreutils */ "webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils");
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The body for a Callstack Panel.
 */
class CallstackBody extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget {
    /**
     * Instantiate a new Body for the Callstack Panel.
     *
     * @param model The model for the callstack.
     */
    constructor(model) {
        super();
        this._model = model;
        this.addClass('jp-DebuggerCallstack-body');
    }
    /**
     * Render the FramesComponent.
     */
    render() {
        return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(FramesComponent, { model: this._model });
    }
}
/**
 * A React component to display a list of frames in a callstack.
 *
 * @param {object} props The component props.
 * @param props.model The model for the callstack.
 */
const FramesComponent = ({ model }) => {
    const [frames, setFrames] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(model.frames);
    const [selected, setSelected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(model.frame);
    const onSelected = (frame) => {
        setSelected(frame);
        model.frame = frame;
    };
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        const updateFrames = () => {
            setSelected(model.frame);
            setFrames(model.frames);
        };
        model.framesChanged.connect(updateFrames);
        return () => {
            model.framesChanged.disconnect(updateFrames);
        };
    }, [model]);
    const toShortLocation = (el) => {
        var _a;
        const path = ((_a = el.source) === null || _a === void 0 ? void 0 : _a.path) || '';
        const base = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PathExt.basename(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PathExt.dirname(path));
        const filename = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PathExt.basename(path);
        const shortname = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_2__.PathExt.join(base, filename);
        return `${shortname}:${el.line}`;
    };
    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement("ul", null, frames.map(ele => {
        var _a;
        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement("li", { key: ele.id, onClick: () => onSelected(ele), className: (selected === null || selected === void 0 ? void 0 : selected.id) === ele.id
                ? 'selected jp-DebuggerCallstackFrame'
                : 'jp-DebuggerCallstackFrame' },
            react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { className: 'jp-DebuggerCallstackFrame-name' }, ele.name),
            react__WEBPACK_IMPORTED_MODULE_1___default().createElement("span", { className: 'jp-DebuggerCallstackFrame-location', title: (_a = ele.source) === null || _a === void 0 ? void 0 : _a.path }, toShortLocation(ele))));
    })));
};
//# sourceMappingURL=body.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/callstack/header.js":
/*!**************************************************************!*\
  !*** ../../packages/debugger/lib/panels/callstack/header.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CallstackHeader": () => (/* binding */ CallstackHeader)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The header for a Callstack Panel.
 */
class CallstackHeader extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {
    /**
     * Instantiate a new CallstackHeader.
     */
    constructor(translator) {
        super({ node: document.createElement('div') });
        /**
         * The toolbar for the callstack header.
         */
        this.toolbar = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar();
        this.node.classList.add('jp-stack-panel-header');
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
        const trans = translator.load('jupyterlab');
        const title = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget({ node: document.createElement('h2') });
        title.node.textContent = trans.__('Callstack');
        const layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.PanelLayout();
        layout.addWidget(title);
        layout.addWidget(this.toolbar);
        this.layout = layout;
    }
}
//# sourceMappingURL=header.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/callstack/index.js":
/*!*************************************************************!*\
  !*** ../../packages/debugger/lib/panels/callstack/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Callstack": () => (/* binding */ Callstack)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _body__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./body */ "../../packages/debugger/lib/panels/callstack/body.js");
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./header */ "../../packages/debugger/lib/panels/callstack/header.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





/**
 * A Panel to show a callstack.
 */
class Callstack extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Panel {
    /**
     * Instantiate a new Callstack Panel.
     *
     * @param options The instantiation options for a Callstack Panel.
     */
    constructor(options) {
        super();
        const { commands, model } = options;
        const translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
        const header = new _header__WEBPACK_IMPORTED_MODULE_3__.CallstackHeader(translator);
        const body = new _body__WEBPACK_IMPORTED_MODULE_4__.CallstackBody(model);
        header.toolbar.addItem('continue', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.CommandToolbarButton({
            commands: commands.registry,
            id: commands.continue
        }));
        header.toolbar.addItem('terminate', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.CommandToolbarButton({
            commands: commands.registry,
            id: commands.terminate
        }));
        header.toolbar.addItem('step-over', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.CommandToolbarButton({
            commands: commands.registry,
            id: commands.next
        }));
        header.toolbar.addItem('step-in', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.CommandToolbarButton({
            commands: commands.registry,
            id: commands.stepIn
        }));
        header.toolbar.addItem('step-out', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.CommandToolbarButton({
            commands: commands.registry,
            id: commands.stepOut
        }));
        header.toolbar.addItem('evaluate', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.CommandToolbarButton({
            commands: commands.registry,
            id: commands.evaluate
        }));
        this.addWidget(header);
        this.addWidget(body);
        this.addClass('jp-DebuggerCallstack');
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/callstack/model.js":
/*!*************************************************************!*\
  !*** ../../packages/debugger/lib/panels/callstack/model.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CallstackModel": () => (/* binding */ CallstackModel)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * A model for a callstack.
 */
class CallstackModel {
    constructor() {
        this._state = [];
        this._currentFrame = null;
        this._framesChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._currentFrameChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
    }
    /**
     * Get all the frames.
     */
    get frames() {
        return this._state;
    }
    /**
     * Set the frames.
     */
    set frames(newFrames) {
        this._state = newFrames;
        const currentFrameId = this.frame !== null ? Private.getFrameId(this.frame) : '';
        const frame = newFrames.find(frame => Private.getFrameId(frame) === currentFrameId);
        // Default to the first frame if the previous one can't be found.
        // Otherwise keep the current frame selected.
        if (!frame) {
            this.frame = newFrames[0];
        }
        this._framesChanged.emit(newFrames);
    }
    /**
     * Get the current frame.
     */
    get frame() {
        return this._currentFrame;
    }
    /**
     * Set the current frame.
     */
    set frame(frame) {
        this._currentFrame = frame;
        this._currentFrameChanged.emit(frame);
    }
    /**
     * Signal emitted when the frames have changed.
     */
    get framesChanged() {
        return this._framesChanged;
    }
    /**
     * Signal emitted when the current frame has changed.
     */
    get currentFrameChanged() {
        return this._currentFrameChanged;
    }
}
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * Construct an id for the given frame.
     *
     * @param frame The frame.
     */
    function getFrameId(frame) {
        var _a;
        return `${(_a = frame === null || frame === void 0 ? void 0 : frame.source) === null || _a === void 0 ? void 0 : _a.path}-${frame === null || frame === void 0 ? void 0 : frame.id}`;
    }
    Private.getFrameId = getFrameId;
})(Private || (Private = {}));
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/kernelSources/body.js":
/*!****************************************************************!*\
  !*** ../../packages/debugger/lib/panels/kernelSources/body.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KernelSourcesBody": () => (/* binding */ KernelSourcesBody)
/* harmony export */ });
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../icons */ "../../packages/debugger/lib/icons.js");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter */ "../../packages/debugger/lib/panels/kernelSources/filter.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.






/**
 * The class name added to the filterbox node.
 */
const FILTERBOX_CLASS = 'jp-DebuggerKernelSource-filterBox';
/**
 * The class name added to hide the filterbox node.
 */
const FILTERBOX_HIDDEN_CLASS = 'jp-DebuggerKernelSource-filterBox-hidden';
/**
 * The body for a Sources Panel.
 */
class KernelSourcesBody extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {
    /**
     * Instantiate a new Body for the KernelSourcesBody widget.
     *
     * @param options The instantiation options for a KernelSourcesBody.
     */
    constructor(options) {
        var _a;
        super();
        this._model = options.model;
        this._debuggerService = options.service;
        const trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
        this.layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.PanelLayout();
        this.addClass('jp-DebuggerKernelSources-body');
        this._kernelSourcesFilter = (0,_filter__WEBPACK_IMPORTED_MODULE_3__.KernelSourcesFilter)({
            model: this._model
        });
        this._kernelSourcesFilter.addClass(FILTERBOX_CLASS);
        this._kernelSourcesFilter.addClass(FILTERBOX_HIDDEN_CLASS);
        this.layout.addWidget(this._kernelSourcesFilter);
        this._model.changed.connect((_, kernelSources) => {
            this._clear();
            if (kernelSources) {
                kernelSources.forEach(module => {
                    const name = module.name;
                    const path = module.path;
                    const button = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
                        icon: _icons__WEBPACK_IMPORTED_MODULE_4__.openKernelSourceIcon,
                        label: name,
                        tooltip: path
                    });
                    button.node.addEventListener('dblclick', () => {
                        this._debuggerService
                            .getSource({
                            sourceReference: 0,
                            path: path
                        })
                            .then(source => {
                            this._model.open(source);
                        })
                            .catch(reason => {
                            void (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.showErrorMessage)(trans.__('Fail to get source'), trans.__("Fail to get '%1' source:\n%2", path, reason));
                        });
                    });
                    this.layout.addWidget(button);
                });
            }
        });
    }
    /**
     * Show or hide the filter box.
     */
    toggleFilterbox() {
        this._kernelSourcesFilter.node.classList.contains(FILTERBOX_HIDDEN_CLASS)
            ? this._kernelSourcesFilter.node.classList.remove(FILTERBOX_HIDDEN_CLASS)
            : this._kernelSourcesFilter.node.classList.add(FILTERBOX_HIDDEN_CLASS);
    }
    /**
     * Clear the content of the kernel source read-only editor.
     */
    _clear() {
        while (this.layout.widgets.length > 1) {
            this.layout.removeWidgetAt(1);
        }
    }
}
//# sourceMappingURL=body.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/kernelSources/filter.js":
/*!******************************************************************!*\
  !*** ../../packages/debugger/lib/panels/kernelSources/filter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KernelSourcesFilter": () => (/* binding */ KernelSourcesFilter)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



const FilterBox = (props) => {
    const onFilterChange = (e) => {
        const filter = e.target.value;
        props.model.filter = filter;
    };
    return (react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.InputGroup, { type: "text", onChange: onFilterChange, placeholder: "Filter the kernel sources", value: props.model.filter }));
};
/**
 * A widget which hosts a input textbox to filter on file names.
 */
const KernelSourcesFilter = (props) => {
    return _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget.create(react__WEBPACK_IMPORTED_MODULE_2___default().createElement(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.UseSignal, { signal: props.model.filterChanged, initialArgs: props.model.filter }, model => react__WEBPACK_IMPORTED_MODULE_2___default().createElement(FilterBox, { model: props.model })));
};
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/kernelSources/header.js":
/*!******************************************************************!*\
  !*** ../../packages/debugger/lib/panels/kernelSources/header.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KernelSourcesHeader": () => (/* binding */ KernelSourcesHeader)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The header for a Kernel Source Panel.
 */
class KernelSourcesHeader extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {
    /**
     * Instantiate a new SourcesHeader.
     *
     * @param model The model for the Sources.
     */
    constructor(model, translator) {
        super({ node: document.createElement('div') });
        /**
         * The toolbar for the sources header.
         */
        this.toolbar = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar();
        this.node.classList.add('jp-stack-panel-header');
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
        const trans = translator.load('jupyterlab');
        const layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.PanelLayout();
        this.layout = layout;
        const title = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget({ node: document.createElement('h2') });
        title.node.textContent = trans.__('Kernel Sources');
        layout.addWidget(title);
        layout.addWidget(this.toolbar);
        this.addClass('jp-DebuggerSources-header');
    }
}
//# sourceMappingURL=header.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/kernelSources/index.js":
/*!*****************************************************************!*\
  !*** ../../packages/debugger/lib/panels/kernelSources/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KernelSources": () => (/* binding */ KernelSources)
/* harmony export */ });
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _body__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./body */ "../../packages/debugger/lib/panels/kernelSources/body.js");
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./header */ "../../packages/debugger/lib/panels/kernelSources/header.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







/**
 * A Panel that shows a preview of the source code while debugging.
 */
class KernelSources extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__.Panel {
    /**
     * Instantiate a new Sources preview Panel.
     *
     * @param options The Sources instantiation options.
     */
    constructor(options) {
        var _a;
        super();
        const { model, service } = options;
        this._model = model;
        const trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__.nullTranslator).load('jupyterlab');
        this.title.label = trans.__('Kernel Sources');
        const header = new _header__WEBPACK_IMPORTED_MODULE_4__.KernelSourcesHeader(model, options.translator);
        header.addClass('jp-DebuggerKernelSources-header');
        this._body = new _body__WEBPACK_IMPORTED_MODULE_5__.KernelSourcesBody({
            service,
            model,
            translator: options.translator
        });
        header.toolbar.addItem('open-filter', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.searchIcon,
            onClick: async () => {
                this._body.toggleFilterbox();
            },
            tooltip: trans.__('Toggle search filter')
        }));
        header.toolbar.addItem('refresh', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.refreshIcon,
            onClick: () => {
                this._model.kernelSources = [];
                void service.displayModules().catch(reason => {
                    void (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showErrorMessage)(trans.__('Fail to get kernel sources'), trans.__('Fail to get kernel sources:\n%2', reason));
                });
            },
            tooltip: trans.__('Refresh kernel sources')
        }));
        this.addClass('jp-DebuggerKernelSources-header');
        this.addClass('jp-DebuggerKernelSources');
        this.addWidget(header);
        this.addWidget(this._body);
    }
    set filter(filter) {
        this._model.filter = filter;
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/kernelSources/model.js":
/*!*****************************************************************!*\
  !*** ../../packages/debugger/lib/panels/kernelSources/model.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KernelSourcesModel": () => (/* binding */ KernelSourcesModel)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/polling */ "webpack/sharing/consume/default/@lumino/polling/@lumino/polling");
/* harmony import */ var _lumino_polling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_polling__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * The rate limit for the filter debouncer
 */
const DEBOUNCER_RATE_LIMIT_MS = 500;
const compare = (a, b) => {
    if (a.name < b.name) {
        return -1;
    }
    if (a.name > b.name) {
        return 1;
    }
    return 0;
};
/**
 * The model to keep track of the current source being displayed.
 */
class KernelSourcesModel {
    constructor() {
        this._kernelSources = null;
        this._filteredKernelSources = null;
        this._filter = '';
        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._filterChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._kernelSourceOpened = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this.refresh = this.refresh.bind(this);
        this._refreshDebouncer = new _lumino_polling__WEBPACK_IMPORTED_MODULE_1__.Debouncer(this.refresh, DEBOUNCER_RATE_LIMIT_MS);
    }
    /**
     * Get the filter.
     */
    get filter() {
        return this._filter;
    }
    /**
     * Set the filter.
     * The update
     */
    set filter(filter) {
        this._filter = filter;
        this._filterChanged.emit(filter);
        void this._refreshDebouncer.invoke();
    }
    /**
     * Get the kernel sources.
     */
    get kernelSources() {
        return this._kernelSources;
    }
    /**
     * Set the kernel sources and emit a changed signal.
     */
    set kernelSources(kernelSources) {
        this._kernelSources = kernelSources;
        this.refresh();
    }
    /**
     * Signal emitted when the current source changes.
     */
    get changed() {
        return this._changed;
    }
    /**
     * Signal emitted when the current source changes.
     */
    get filterChanged() {
        return this._filterChanged;
    }
    /**
     * Signal emitted when a kernel source should be open in the main area.
     */
    get kernelSourceOpened() {
        return this._kernelSourceOpened;
    }
    /**
     * Open a source in the main area.
     */
    open(kernelSource) {
        this._kernelSourceOpened.emit(kernelSource);
    }
    getFilteredKernelSources() {
        const regexp = new RegExp(this._filter);
        return this._kernelSources.filter(module => regexp.test(module.name));
    }
    refresh() {
        if (this._kernelSources) {
            this._filteredKernelSources = this._filter
                ? this.getFilteredKernelSources()
                : this._kernelSources;
            this._filteredKernelSources.sort(compare);
        }
        else {
            this._kernelSources = new Array();
            this._filteredKernelSources = new Array();
        }
        this._changed.emit(this._filteredKernelSources);
    }
}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/sources/body.js":
/*!**********************************************************!*\
  !*** ../../packages/debugger/lib/panels/sources/body.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SourcesBody": () => (/* binding */ SourcesBody)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../.. */ "../../packages/debugger/lib/debugger.js");
/* harmony import */ var _handlers_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../handlers/editor */ "../../packages/debugger/lib/handlers/editor.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/**
 * The body for a Sources Panel.
 */
class SourcesBody extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget {
    /**
     * Instantiate a new Body for the SourcesBody widget.
     *
     * @param options The instantiation options for a SourcesBody.
     */
    constructor(options) {
        super();
        this._model = options.model;
        this._debuggerService = options.service;
        this._mimeTypeService = options.editorServices.mimeTypeService;
        const factory = new ___WEBPACK_IMPORTED_MODULE_2__.Debugger.ReadOnlyEditorFactory({
            editorServices: options.editorServices
        });
        this._editor = factory.createNewEditor({
            content: '',
            mimeType: '',
            path: ''
        });
        this._editor.hide();
        this._model.currentFrameChanged.connect(async (_, frame) => {
            if (!frame) {
                this._clearEditor();
                return;
            }
            void this._showSource(frame);
        });
        const layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.PanelLayout();
        layout.addWidget(this._editor);
        this.layout = layout;
        this.addClass('jp-DebuggerSources-body');
    }
    /**
     * Dispose the sources body widget.
     */
    dispose() {
        var _a;
        if (this.isDisposed) {
            return;
        }
        (_a = this._editorHandler) === null || _a === void 0 ? void 0 : _a.dispose();
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal.clearData(this);
        super.dispose();
    }
    /**
     * Clear the content of the source read-only editor.
     */
    _clearEditor() {
        this._model.currentSource = null;
        this._editor.hide();
    }
    /**
     * Show the content of the source for the given frame.
     *
     * @param frame The current frame.
     */
    async _showSource(frame) {
        var _a;
        const path = (_a = frame.source) === null || _a === void 0 ? void 0 : _a.path;
        const source = await this._debuggerService.getSource({
            sourceReference: 0,
            path
        });
        if (!(source === null || source === void 0 ? void 0 : source.content)) {
            this._clearEditor();
            return;
        }
        if (this._editorHandler) {
            this._editorHandler.dispose();
        }
        const { content, mimeType } = source;
        const editorMimeType = mimeType || this._mimeTypeService.getMimeTypeByFilePath(path !== null && path !== void 0 ? path : '');
        this._editor.model.value.text = content;
        this._editor.model.mimeType = editorMimeType;
        this._editorHandler = new _handlers_editor__WEBPACK_IMPORTED_MODULE_3__.EditorHandler({
            debuggerService: this._debuggerService,
            editor: this._editor.editor,
            path
        });
        this._model.currentSource = {
            content,
            mimeType: editorMimeType,
            path: path !== null && path !== void 0 ? path : ''
        };
        requestAnimationFrame(() => {
            _handlers_editor__WEBPACK_IMPORTED_MODULE_3__.EditorHandler.showCurrentLine(this._editor.editor, frame.line);
        });
        this._editor.show();
    }
}
//# sourceMappingURL=body.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/sources/header.js":
/*!************************************************************!*\
  !*** ../../packages/debugger/lib/panels/sources/header.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SourcesHeader": () => (/* binding */ SourcesHeader)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/**
 * The header for a Source Panel.
 */
class SourcesHeader extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {
    /**
     * Instantiate a new SourcesHeader.
     *
     * @param model The model for the Sources.
     */
    constructor(model, translator) {
        super({ node: document.createElement('div') });
        /**
         * The toolbar for the sources header.
         */
        this.toolbar = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar();
        this.node.classList.add('jp-stack-panel-header');
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
        const trans = translator.load('jupyterlab');
        const layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.PanelLayout();
        this.layout = layout;
        const title = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget({ node: document.createElement('h2') });
        title.node.textContent = trans.__('Source');
        const sourcePath = _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget.create(react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SourcePathComponent, { model: model }));
        layout.addWidget(title);
        layout.addWidget(this.toolbar);
        layout.addWidget(sourcePath);
        this.addClass('jp-DebuggerSources-header');
    }
}
/**
 * A React component to display the path to a source.
 *
 * @param {object} props The component props.
 * @param props.model The model for the sources.
 */
const SourcePathComponent = ({ model }) => {
    return (react__WEBPACK_IMPORTED_MODULE_3___default().createElement(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.UseSignal, { signal: model.currentSourceChanged, initialSender: model }, (model) => {
        var _a, _b;
        return (react__WEBPACK_IMPORTED_MODULE_3___default().createElement("span", { onClick: () => model === null || model === void 0 ? void 0 : model.open() }, (_b = (_a = model === null || model === void 0 ? void 0 : model.currentSource) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : ''));
    }));
};
//# sourceMappingURL=header.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/sources/index.js":
/*!***********************************************************!*\
  !*** ../../packages/debugger/lib/panels/sources/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sources": () => (/* binding */ Sources)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../icons */ "../../packages/debugger/lib/icons.js");
/* harmony import */ var _body__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./body */ "../../packages/debugger/lib/panels/sources/body.js");
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./header */ "../../packages/debugger/lib/panels/sources/header.js");
/*-----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/






/**
 * A Panel that shows a preview of the source code while debugging.
 */
class Sources extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Panel {
    /**
     * Instantiate a new Sources preview Panel.
     *
     * @param options The Sources instantiation options.
     */
    constructor(options) {
        super();
        const { model, service, editorServices } = options;
        const translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
        const trans = translator.load('jupyterlab');
        const header = new _header__WEBPACK_IMPORTED_MODULE_3__.SourcesHeader(model, translator);
        const body = new _body__WEBPACK_IMPORTED_MODULE_4__.SourcesBody({
            service,
            model,
            editorServices
        });
        header.toolbar.addItem('open', new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _icons__WEBPACK_IMPORTED_MODULE_5__.viewBreakpointIcon,
            onClick: () => model.open(),
            tooltip: trans.__('Open in the Main Area')
        }));
        this.addWidget(header);
        this.addWidget(body);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/sources/model.js":
/*!***********************************************************!*\
  !*** ../../packages/debugger/lib/panels/sources/model.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SourcesModel": () => (/* binding */ SourcesModel)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * The model to keep track of the current source being displayed.
 */
class SourcesModel {
    /**
     * Instantiate a new Sources.Model
     *
     * @param options The Sources.Model instantiation options.
     */
    constructor(options) {
        this._currentSourceOpened = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._currentSourceChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this.currentFrameChanged = options.currentFrameChanged;
    }
    /**
     * Signal emitted when a source should be open in the main area.
     */
    get currentSourceOpened() {
        return this._currentSourceOpened;
    }
    /**
     * Signal emitted when the current source changes.
     */
    get currentSourceChanged() {
        return this._currentSourceChanged;
    }
    /**
     * Return the current source.
     */
    get currentSource() {
        return this._currentSource;
    }
    /**
     * Set the current source.
     *
     * @param source The source to set as the current source.
     */
    set currentSource(source) {
        this._currentSource = source;
        this._currentSourceChanged.emit(source);
    }
    /**
     * Open a source in the main area.
     */
    open() {
        this._currentSourceOpened.emit(this._currentSource);
    }
}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/variables/grid.js":
/*!************************************************************!*\
  !*** ../../packages/debugger/lib/panels/variables/grid.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VariablesBodyGrid": () => (/* binding */ VariablesBodyGrid)
/* harmony export */ });
/* harmony import */ var _lumino_datagrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/datagrid */ "webpack/sharing/consume/default/@lumino/datagrid/@lumino/datagrid");
/* harmony import */ var _lumino_datagrid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_datagrid__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ */ "../../packages/debugger/lib/debugger.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/**
 * A data grid that displays variables in a debugger session.
 */
class VariablesBodyGrid extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Panel {
    /**
     * Instantiate a new VariablesBodyGrid.
     *
     * @param options The instantiation options for a VariablesBodyGrid.
     */
    constructor(options) {
        super();
        const { model, commands, themeManager, scopes } = options;
        this._grid = new Grid({ commands, model, themeManager });
        this._grid.addClass('jp-DebuggerVariables-grid');
        this._model = model;
        this._model.changed.connect((model) => {
            this._update();
        }, this);
        this._grid.dataModel.setData(scopes !== null && scopes !== void 0 ? scopes : []);
        this.addWidget(this._grid);
        this.addClass('jp-DebuggerVariables-body');
    }
    /**
     * Set the variable filter list.
     *
     * @param filter The variable filter to apply.
     */
    set filter(filter) {
        this._grid.dataModel.filter = filter;
        this._update();
    }
    /**
     * Set the current scope.
     *
     * @param scope The current scope for the variables.
     */
    set scope(scope) {
        this._grid.dataModel.scope = scope;
        this._update();
    }
    /**
     * Update the underlying data model
     */
    _update() {
        var _a;
        this._grid.dataModel.setData((_a = this._model.scopes) !== null && _a !== void 0 ? _a : []);
    }
}
/**
 * A class wrapping the underlying variables datagrid.
 */
class Grid extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Panel {
    /**
     * Instantiate a new VariablesGrid.
     *
     * @param options The instantiation options for a VariablesGrid.
     */
    constructor(options) {
        super();
        const { commands, model, themeManager } = options;
        this.model = model;
        const dataModel = new GridModel();
        const grid = new _lumino_datagrid__WEBPACK_IMPORTED_MODULE_0__.DataGrid();
        const mouseHandler = new Private.MouseHandler();
        mouseHandler.doubleClicked.connect((_, hit) => commands.execute(___WEBPACK_IMPORTED_MODULE_3__.Debugger.CommandIDs.inspectVariable, {
            variableReference: dataModel.getVariableReference(hit.row),
            name: dataModel.getVariableName(hit.row)
        }));
        mouseHandler.selected.connect((_, hit) => {
            const { row } = hit;
            this.model.selectedVariable = {
                name: dataModel.getVariableName(row),
                value: dataModel.data('body', row, 1),
                type: dataModel.data('body', row, 2),
                variablesReference: dataModel.getVariableReference(row)
            };
        });
        grid.dataModel = dataModel;
        grid.keyHandler = new _lumino_datagrid__WEBPACK_IMPORTED_MODULE_0__.BasicKeyHandler();
        grid.mouseHandler = mouseHandler;
        grid.selectionModel = new _lumino_datagrid__WEBPACK_IMPORTED_MODULE_0__.BasicSelectionModel({
            dataModel
        });
        grid.stretchLastColumn = true;
        grid.node.style.height = '100%';
        this._grid = grid;
        // Compute the grid's styles based on the current theme.
        if (themeManager) {
            themeManager.themeChanged.connect(this._updateStyles, this);
        }
        this.addWidget(grid);
    }
    /**
     * Set the variable filter list.
     *
     * @param filter The variable filter to apply.
     */
    set filter(filter) {
        this._grid.dataModel.filter = filter;
        this.update();
    }
    /**
     * Set the scope for the variables data model.
     *
     * @param scope The scopes for the variables
     */
    set scope(scope) {
        this._grid.dataModel.scope = scope;
        this.update();
    }
    /**
     * Get the data model for the data grid.
     */
    get dataModel() {
        return this._grid.dataModel;
    }
    /**
     * Handle `after-attach` messages.
     *
     * @param message - The `after-attach` message.
     */
    onAfterAttach(message) {
        super.onAfterAttach(message);
        this._updateStyles();
    }
    /**
     * Update the computed style for the data grid on theme change.
     */
    _updateStyles() {
        const { style, textRenderer } = Private.computeStyle();
        this._grid.cellRenderers.update({}, textRenderer);
        this._grid.style = style;
    }
}
/**
 * A data grid model for variables.
 */
class GridModel extends _lumino_datagrid__WEBPACK_IMPORTED_MODULE_0__.DataModel {
    constructor() {
        super(...arguments);
        this._filter = new Set();
        this._scope = '';
        this._data = {
            name: [],
            type: [],
            value: [],
            variablesReference: []
        };
    }
    /**
     * Set the variable filter list.
     */
    set filter(filter) {
        this._filter = filter;
    }
    /**
     * Get the current scope for the variables.
     */
    get scope() {
        return this._scope;
    }
    /**
     * Set the variable scope
     */
    set scope(scope) {
        this._scope = scope;
    }
    /**
     * Get the row count for a particular region in the data grid.
     *
     * @param region The datagrid region.
     */
    rowCount(region) {
        return region === 'body' ? this._data.name.length : 1;
    }
    /**
     * Get the column count for a particular region in the data grid.
     *
     * @param region The datagrid region.
     */
    columnCount(region) {
        return region === 'body' ? 2 : 1;
    }
    /**
     * Get the data count for a particular region, row and column in the data grid.
     *
     * @param region The datagrid region.
     * @param row The datagrid row
     * @param column The datagrid column
     */
    data(region, row, column) {
        if (region === 'row-header') {
            return this._data.name[row];
        }
        if (region === 'column-header') {
            return column === 1 ? 'Value' : 'Type';
        }
        if (region === 'corner-header') {
            return 'Name';
        }
        return column === 1 ? this._data.value[row] : this._data.type[row];
    }
    /**
     * Get the variable reference for a given row
     *
     * @param row The row in the datagrid.
     */
    getVariableReference(row) {
        return this._data.variablesReference[row];
    }
    /**
     * Get the variable name for a given row
     *
     * @param row The row in the datagrid.
     */
    getVariableName(row) {
        return this._data.name[row];
    }
    /**
     * Set the datagrid model data from the list of variables.
     *
     * @param variables The list of variables.
     */
    setData(scopes) {
        var _a, _b;
        this._clearData();
        this.emitChanged({
            type: 'model-reset',
            region: 'body'
        });
        const scope = (_a = scopes.find(scope => scope.name === this._scope)) !== null && _a !== void 0 ? _a : scopes[0];
        const variables = (_b = scope === null || scope === void 0 ? void 0 : scope.variables) !== null && _b !== void 0 ? _b : [];
        const filtered = variables.filter(variable => variable.name && !this._filter.has(variable.name));
        filtered.forEach((variable, index) => {
            var _a;
            this._data.name[index] = variable.name;
            this._data.type[index] = (_a = variable.type) !== null && _a !== void 0 ? _a : '';
            this._data.value[index] = variable.value;
            this._data.variablesReference[index] = variable.variablesReference;
        });
        this.emitChanged({
            type: 'rows-inserted',
            region: 'body',
            index: 1,
            span: filtered.length
        });
    }
    /**
     * Clear all the data in the datagrid.
     */
    _clearData() {
        this._data = {
            name: [],
            type: [],
            value: [],
            variablesReference: []
        };
    }
}
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * Create a color palette element.
     */
    function createPalette() {
        const div = document.createElement('div');
        div.className = 'jp-DebuggerVariables-colorPalette';
        div.innerHTML = `
      <div class="jp-mod-void"></div>
      <div class="jp-mod-background"></div>
      <div class="jp-mod-header-background"></div>
      <div class="jp-mod-grid-line"></div>
      <div class="jp-mod-header-grid-line"></div>
      <div class="jp-mod-selection"></div>
      <div class="jp-mod-text"></div>
    `;
        return div;
    }
    /**
     * Compute the style and renderer for a data grid.
     */
    function computeStyle() {
        const palette = createPalette();
        document.body.appendChild(palette);
        let node;
        node = palette.querySelector('.jp-mod-void');
        const voidColor = getComputedStyle(node).color;
        node = palette.querySelector('.jp-mod-background');
        const backgroundColor = getComputedStyle(node).color;
        node = palette.querySelector('.jp-mod-header-background');
        const headerBackgroundColor = getComputedStyle(node).color;
        node = palette.querySelector('.jp-mod-grid-line');
        const gridLineColor = getComputedStyle(node).color;
        node = palette.querySelector('.jp-mod-header-grid-line');
        const headerGridLineColor = getComputedStyle(node).color;
        node = palette.querySelector('.jp-mod-selection');
        const selectionFillColor = getComputedStyle(node).color;
        node = palette.querySelector('.jp-mod-text');
        const textColor = getComputedStyle(node).color;
        document.body.removeChild(palette);
        return {
            style: {
                voidColor,
                backgroundColor,
                headerBackgroundColor,
                gridLineColor,
                headerGridLineColor,
                rowBackgroundColor: (i) => i % 2 === 0 ? voidColor : backgroundColor,
                selectionFillColor
            },
            textRenderer: new _lumino_datagrid__WEBPACK_IMPORTED_MODULE_0__.TextRenderer({
                font: '12px sans-serif',
                textColor,
                backgroundColor: '',
                verticalAlignment: 'center',
                horizontalAlignment: 'left'
            })
        };
    }
    Private.computeStyle = computeStyle;
    /**
     * A custom click handler to handle clicks on the variables grid.
     */
    class MouseHandler extends _lumino_datagrid__WEBPACK_IMPORTED_MODULE_0__.BasicMouseHandler {
        constructor() {
            super(...arguments);
            this._doubleClicked = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
            this._selected = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        }
        /**
         * A signal emitted when the variables grid is double clicked.
         */
        get doubleClicked() {
            return this._doubleClicked;
        }
        /**
         * A signal emitted when the variables grid received mouse down or context menu event.
         */
        get selected() {
            return this._selected;
        }
        /**
         * Dispose of the resources held by the mouse handler.
         */
        dispose() {
            if (this.isDisposed) {
                return;
            }
            _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.disconnectSender(this);
            super.dispose();
        }
        /**
         * Handle a mouse double-click event.
         *
         * @param grid The datagrid clicked.
         * @param event The mouse event.
         */
        onMouseDoubleClick(grid, event) {
            const hit = grid.hitTest(event.clientX, event.clientY);
            this._doubleClicked.emit(hit);
        }
        /**
         * Handle the mouse down event for the data grid.
         *
         * @param grid - The data grid of interest.
         *
         * @param event - The mouse down event of interest.
         */
        onMouseDown(grid, event) {
            // Unpack the event.
            let { clientX, clientY } = event;
            // Hit test the grid.
            let hit = grid.hitTest(clientX, clientY);
            this._selected.emit(hit);
        }
        /**
         * Handle the context menu event for the data grid.
         *
         * @param grid - The data grid of interest.
         *
         * @param event - The context menu event of interest.
         */
        onContextMenu(grid, event) {
            // Unpack the event.
            let { clientX, clientY } = event;
            // Hit test the grid.
            let hit = grid.hitTest(clientX, clientY);
            this._selected.emit(hit);
        }
    }
    Private.MouseHandler = MouseHandler;
})(Private || (Private = {}));
//# sourceMappingURL=grid.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/variables/header.js":
/*!**************************************************************!*\
  !*** ../../packages/debugger/lib/panels/variables/header.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VariablesHeader": () => (/* binding */ VariablesHeader)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The header for a Variables Panel.
 */
class VariablesHeader extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {
    /**
     * Instantiate a new VariablesHeader.
     */
    constructor(translator) {
        super({ node: document.createElement('div') });
        /**
         * The toolbar for the callstack header.
         */
        this.toolbar = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.Toolbar();
        this.node.classList.add('jp-stack-panel-header');
        translator = translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
        const trans = translator.load('jupyterlab');
        const title = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget({ node: document.createElement('h2') });
        title.node.textContent = trans.__('Variables');
        const layout = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.PanelLayout();
        layout.addWidget(title);
        layout.addWidget(this.toolbar);
        this.layout = layout;
    }
}
//# sourceMappingURL=header.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/variables/index.js":
/*!*************************************************************!*\
  !*** ../../packages/debugger/lib/panels/variables/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Variables": () => (/* binding */ Variables),
/* harmony export */   "convertType": () => (/* binding */ convertType)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./grid */ "../../packages/debugger/lib/panels/variables/grid.js");
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./header */ "../../packages/debugger/lib/panels/variables/header.js");
/* harmony import */ var _scope__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scope */ "../../packages/debugger/lib/panels/variables/scope.js");
/* harmony import */ var _tree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tree */ "../../packages/debugger/lib/panels/variables/tree.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








/**
 * A Panel to show a variable explorer.
 */
class Variables extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_3__.Panel {
    /**
     * Instantiate a new Variables Panel.
     *
     * @param options The instantiation options for a Variables Panel.
     */
    constructor(options) {
        super();
        const { model, service, commands, themeManager } = options;
        const translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator;
        const trans = translator.load('jupyterlab');
        this._header = new _header__WEBPACK_IMPORTED_MODULE_4__.VariablesHeader(translator);
        this._tree = new _tree__WEBPACK_IMPORTED_MODULE_5__.VariablesBodyTree({
            model,
            service,
            commands,
            translator
        });
        this._table = new _grid__WEBPACK_IMPORTED_MODULE_6__.VariablesBodyGrid({ model, commands, themeManager });
        this._table.hide();
        this._header.toolbar.addItem('scope-switcher', new _scope__WEBPACK_IMPORTED_MODULE_7__.ScopeSwitcher({
            translator,
            model,
            tree: this._tree,
            grid: this._table
        }));
        const onViewChange = () => {
            if (this._table.isHidden) {
                this._tree.hide();
                this._table.show();
                this.node.setAttribute('data-jp-table', 'true');
                markViewButtonSelection('table');
            }
            else {
                this._tree.show();
                this._table.hide();
                this.node.removeAttribute('data-jp-table');
                markViewButtonSelection('tree');
            }
            this.update();
        };
        const treeViewButton = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.treeViewIcon,
            className: 'jp-TreeView',
            onClick: onViewChange,
            tooltip: trans.__('Tree View')
        });
        const tableViewButton = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ToolbarButton({
            icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.tableRowsIcon,
            className: 'jp-TableView',
            onClick: onViewChange,
            tooltip: trans.__('Table View')
        });
        const markViewButtonSelection = (selectedView) => {
            const viewModeClassName = 'jp-ViewModeSelected';
            if (selectedView === 'tree') {
                tableViewButton.removeClass(viewModeClassName);
                treeViewButton.addClass(viewModeClassName);
            }
            else {
                treeViewButton.removeClass(viewModeClassName);
                tableViewButton.addClass(viewModeClassName);
            }
        };
        markViewButtonSelection(this._table.isHidden ? 'tree' : 'table');
        this._header.toolbar.addItem('view-VariableTreeView', treeViewButton);
        this._header.toolbar.addItem('view-VariableTableView', tableViewButton);
        this.addWidget(this._header);
        this.addWidget(this._tree);
        this.addWidget(this._table);
        this.addClass('jp-DebuggerVariables');
    }
    /**
     * Set the variable filter for both the tree and table views.
     */
    set filter(filter) {
        this._tree.filter = filter;
        this._table.filter = filter;
    }
    /**
     * A message handler invoked on a `'resize'` message.
     *
     * @param msg The Lumino message to process.
     */
    onResize(msg) {
        super.onResize(msg);
        this._resizeBody(msg);
    }
    /**
     * Resize the body.
     *
     * @param msg The resize message.
     */
    _resizeBody(msg) {
        const height = msg.height - this._header.node.offsetHeight;
        this._tree.node.style.height = `${height}px`;
    }
}
/**
 * Convert a variable to a primitive type.
 *
 * @param variable The variable.
 */
const convertType = (variable) => {
    var _a, _b;
    const { type, value } = variable;
    switch (type) {
        case 'int':
            return parseInt(value, 10);
        case 'float':
            return parseFloat(value);
        case 'bool':
            return value;
        case 'str':
            if ((_b = (_a = variable.presentationHint) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.includes('rawString')) {
                return value.slice(1, value.length - 1);
            }
            else {
                return value;
            }
        default:
            return type !== null && type !== void 0 ? type : value;
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/variables/mimerenderer.js":
/*!********************************************************************!*\
  !*** ../../packages/debugger/lib/panels/variables/mimerenderer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VariableMimeRenderer": () => (/* binding */ VariableMimeRenderer)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/rendermime */ "webpack/sharing/consume/default/@jupyterlab/rendermime/@jupyterlab/rendermime");
/* harmony import */ var _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _hash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../hash */ "../../packages/debugger/lib/hash.js");






/**
 * Debugger variable mime type renderer
 */
class VariableMimeRenderer extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.MainAreaWidget {
    /**
     * Instantiate a new VariableMimeRenderer.
     */
    constructor(options) {
        const { dataLoader, rendermime, translator } = options;
        const content = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_4__.Panel();
        const loaded = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_3__.PromiseDelegate();
        super({
            content,
            reveal: Promise.all([dataLoader, loaded.promise])
        });
        this.trans = (translator !== null && translator !== void 0 ? translator : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_2__.nullTranslator).load('jupyterlab');
        this.dataLoader = dataLoader;
        this.renderMime = rendermime;
        this._dataHash = null;
        this.refresh()
            .then(() => {
            loaded.resolve();
        })
            .catch(reason => loaded.reject(reason));
    }
    /**
     * Refresh the variable view
     */
    async refresh(force = false) {
        let data = await this.dataLoader();
        if (Object.keys(data.data).length === 0) {
            data = {
                data: {
                    'text/plain': this.trans.__('The variable is undefined in the active context.')
                },
                metadata: {}
            };
        }
        if (data.data) {
            const hash = (0,_hash__WEBPACK_IMPORTED_MODULE_5__.murmur2)(JSON.stringify(data), 17);
            if (force || this._dataHash !== hash) {
                if (this.content.layout) {
                    this.content.widgets.forEach(w => {
                        this.content.layout.removeWidget(w);
                    });
                }
                // We trust unconditionally the data as the user is required to
                // execute the code to load a particular variable in memory
                const mimeType = this.renderMime.preferredMimeType(data.data, 'any');
                if (mimeType) {
                    const widget = this.renderMime.createRenderer(mimeType);
                    const model = new _jupyterlab_rendermime__WEBPACK_IMPORTED_MODULE_1__.MimeModel(Object.assign(Object.assign({}, data), { trusted: true }));
                    this._dataHash = hash;
                    await widget.renderModel(model);
                    this.content.addWidget(widget);
                }
                else {
                    this._dataHash = null;
                    return Promise.reject('Unable to determine the preferred mime type.');
                }
            }
        }
        else {
            this._dataHash = null;
            return Promise.reject('Unable to get a view on the variable.');
        }
    }
}
//# sourceMappingURL=mimerenderer.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/variables/model.js":
/*!*************************************************************!*\
  !*** ../../packages/debugger/lib/panels/variables/model.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VariablesModel": () => (/* binding */ VariablesModel)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * A model for a variable explorer.
 */
class VariablesModel {
    constructor() {
        this._selectedVariable = null;
        this._state = [];
        this._variableExpanded = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
    }
    /**
     * Get all the scopes.
     */
    get scopes() {
        return this._state;
    }
    /**
     * Set the scopes.
     */
    set scopes(scopes) {
        this._state = scopes;
        this._changed.emit();
    }
    /**
     * Signal emitted when the current variable has changed.
     */
    get changed() {
        return this._changed;
    }
    /**
     * Signal emitted when the current variable has been expanded.
     */
    get variableExpanded() {
        return this._variableExpanded;
    }
    get selectedVariable() {
        return this._selectedVariable;
    }
    set selectedVariable(selection) {
        this._selectedVariable = selection;
    }
    /**
     * Expand a variable.
     *
     * @param variable The variable to expand.
     */
    expandVariable(variable) {
        this._variableExpanded.emit(variable);
    }
}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/variables/scope.js":
/*!*************************************************************!*\
  !*** ../../packages/debugger/lib/panels/variables/scope.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScopeSwitcher": () => (/* binding */ ScopeSwitcher)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);




/**
 * A React component to handle scope changes.
 *
 * @param {object} props The component props.
 * @param props.model The variables model.
 * @param props.tree The variables tree widget.
 * @param props.grid The variables grid widget.
 * @param props.trans The translation bundle.
 */
const ScopeSwitcherComponent = ({ model, tree, grid, trans }) => {
    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('-');
    const scopes = model.scopes;
    const onChange = (event) => {
        const value = event.target.value;
        setValue(value);
        tree.scope = value;
        grid.scope = value;
    };
    return (react__WEBPACK_IMPORTED_MODULE_3___default().createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.HTMLSelect, { onChange: onChange, value: value, "aria-label": trans.__('Scope') }, scopes.map(scope => (react__WEBPACK_IMPORTED_MODULE_3___default().createElement("option", { key: scope.name, value: scope.name }, trans.__(scope.name))))));
};
/**
 * A widget to switch between scopes.
 */
class ScopeSwitcher extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget {
    /**
     * Instantiate a new scope switcher.
     *
     * @param options The instantiation options for a ScopeSwitcher
     */
    constructor(options) {
        super();
        const { translator, model, tree, grid } = options;
        this._model = model;
        this._tree = tree;
        this._grid = grid;
        this._trans = (translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
    }
    /**
     * Render the scope switcher.
     */
    render() {
        return (react__WEBPACK_IMPORTED_MODULE_3___default().createElement(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.UseSignal, { signal: this._model.changed, initialSender: this._model }, () => (react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ScopeSwitcherComponent, { model: this._model, trans: this._trans, tree: this._tree, grid: this._grid }))));
    }
}
//# sourceMappingURL=scope.js.map

/***/ }),

/***/ "../../packages/debugger/lib/panels/variables/tree.js":
/*!************************************************************!*\
  !*** ../../packages/debugger/lib/panels/variables/tree.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VariablesBodyTree": () => (/* binding */ VariablesBodyTree)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/algorithm */ "webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm");
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! . */ "../../packages/debugger/lib/panels/variables/index.js");
/* harmony import */ var _debugger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../debugger */ "../../packages/debugger/lib/debugger.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







/**
 * The body for tree of variables.
 */
class VariablesBodyTree extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.ReactWidget {
    /**
     * Instantiate a new Body for the tree of variables.
     *
     * @param options The instantiation options for a VariablesBodyTree.
     */
    constructor(options) {
        super();
        this._scope = '';
        this._scopes = [];
        this._filter = new Set();
        this._commands = options.commands;
        this._service = options.service;
        this._translator = options.translator;
        const model = (this.model = options.model);
        model.changed.connect(this._updateScopes, this);
        this.addClass('jp-DebuggerVariables-body');
    }
    /**
     * Render the VariablesBodyTree.
     */
    render() {
        var _a;
        const scope = (_a = this._scopes.find(scope => scope.name === this._scope)) !== null && _a !== void 0 ? _a : this._scopes[0];
        return scope ? (react__WEBPACK_IMPORTED_MODULE_4___default().createElement(VariablesComponent, { key: scope.name, commands: this._commands, service: this._service, data: scope.variables, filter: this._filter, translator: this._translator, handleSelectVariable: variable => {
                this.model.selectedVariable = variable;
            } })) : (react__WEBPACK_IMPORTED_MODULE_4___default().createElement("div", null));
    }
    /**
     * Set the variable filter list.
     */
    set filter(filter) {
        this._filter = filter;
        this.update();
    }
    /**
     * Set the current scope
     */
    set scope(scope) {
        this._scope = scope;
        this.update();
    }
    /**
     * Update the scopes and the tree of variables.
     *
     * @param model The variables model.
     */
    _updateScopes(model) {
        if (_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.shallowEqual(this._scopes, model.scopes)) {
            return;
        }
        this._scopes = model.scopes;
        this.update();
    }
}
/**
 * A React component to display a list of variables.
 *
 * @param {object} props The component props.
 * @param props.data An array of variables.
 * @param props.service The debugger service.
 * @param props.filter Optional variable filter list.
 */
const VariablesComponent = (props) => {
    const { commands, data, service, filter, translator, handleSelectVariable } = props;
    const [variables, setVariables] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(data);
    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {
        setVariables(data);
    }, [data]);
    return (react__WEBPACK_IMPORTED_MODULE_4___default().createElement("ul", null, variables === null || variables === void 0 ? void 0 : variables.filter(variable => !(filter || new Set()).has(variable.evaluateName || '')).map(variable => {
        const key = `${variable.name}-${variable.evaluateName}-${variable.type}-${variable.value}-${variable.variablesReference}`;
        return (react__WEBPACK_IMPORTED_MODULE_4___default().createElement(VariableComponent, { key: key, commands: commands, data: variable, service: service, filter: filter, translator: translator, onSelect: handleSelectVariable }));
    })));
};
/**
 * A React component to display one node variable in tree.
 *
 * @param {object} props The component props.
 * @param props.data An array of variables.
 * @param props.service The debugger service.
 * @param props.filter Optional variable filter list.
 */
const VariableComponent = (props) => {
    const { commands, data, service, filter, translator, onSelect } = props;
    const [variable] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(data);
    const [expanded, setExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)();
    const [variables, setVariables] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)();
    const styleName = {
        color: 'var(--jp-mirror-editor-attribute-color)'
    };
    const styleType = {
        color: 'var(--jp-mirror-editor-string-color)'
    };
    const onSelection = onSelect !== null && onSelect !== void 0 ? onSelect : (() => void 0);
    const expandable = variable.variablesReference !== 0 || variable.type === 'function';
    const trans = (translator !== null && translator !== void 0 ? translator : _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_1__.nullTranslator).load('jupyterlab');
    const onVariableClicked = async (e) => {
        if (!expandable) {
            return;
        }
        e.stopPropagation();
        const variables = await service.inspectVariable(variable.variablesReference);
        setExpanded(!expanded);
        setVariables(variables);
    };
    return (react__WEBPACK_IMPORTED_MODULE_4___default().createElement("li", { onClick: (e) => onVariableClicked(e), onMouseDown: () => {
            onSelection(variable);
        } },
        react__WEBPACK_IMPORTED_MODULE_4___default().createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.caretDownEmptyIcon.react, { visibility: expandable ? 'visible' : 'hidden', stylesheet: "menuItem", tag: "span", transform: expanded ? 'rotate(0deg)' : 'rotate(-90deg)' }),
        react__WEBPACK_IMPORTED_MODULE_4___default().createElement("span", { style: styleName }, variable.name),
        react__WEBPACK_IMPORTED_MODULE_4___default().createElement("span", null, ": "),
        react__WEBPACK_IMPORTED_MODULE_4___default().createElement("span", { style: styleType }, (0,___WEBPACK_IMPORTED_MODULE_5__.convertType)(variable)),
        react__WEBPACK_IMPORTED_MODULE_4___default().createElement("span", { className: "jp-DebuggerVariables-hspacer" }),
        service.model.hasRichVariableRendering &&
            // Don't add rich display for special entries
            // debugpy: https://github.com/microsoft/debugpy/blob/cf0d684566edc339545b161da7c3dfc48af7c7d5/src/debugpy/_vendored/pydevd/_pydevd_bundle/pydevd_utils.py#L359
            ![
                'special variables',
                'protected variables',
                'function variables',
                'class variables'
            ].includes(variable.name) && (react__WEBPACK_IMPORTED_MODULE_4___default().createElement("button", { className: "jp-DebuggerVariables-renderVariable", disabled: !commands.isEnabled(_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.CommandIDs.renderMimeVariable, {
                name: variable.name,
                variablesReference: variable.variablesReference
            }), onClick: e => {
                e.stopPropagation();
                onSelection(variable);
                commands
                    .execute(_debugger__WEBPACK_IMPORTED_MODULE_6__.Debugger.CommandIDs.renderMimeVariable, {
                    name: variable.name,
                    variablesReference: variable.variablesReference
                })
                    .catch(reason => {
                    console.error(`Failed to render variable ${variable.name}`, reason);
                });
            }, title: trans.__('Render variable') },
            react__WEBPACK_IMPORTED_MODULE_4___default().createElement(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_2__.searchIcon.react, { stylesheet: "menuItem", tag: "span" }))),
        expanded && variables && (react__WEBPACK_IMPORTED_MODULE_4___default().createElement(VariablesComponent, { key: variable.name, commands: commands, data: variables, service: service, filter: filter, translator: translator }))));
};
//# sourceMappingURL=tree.js.map

/***/ }),

/***/ "../../packages/debugger/lib/service.js":
/*!**********************************************!*\
  !*** ../../packages/debugger/lib/service.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebuggerService": () => (/* binding */ DebuggerService)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _debugger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debugger */ "../../packages/debugger/lib/debugger.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


/**
 * A concrete implementation of the IDebugger interface.
 */
class DebuggerService {
    /**
     * Instantiate a new DebuggerService.
     *
     * @param options The instantiation options for a DebuggerService.
     */
    constructor(options) {
        var _a, _b;
        this._eventMessage = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._isDisposed = false;
        this._sessionChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
        this._config = options.config;
        // Avoids setting session with invalid client
        // session should be set only when a notebook or
        // a console get the focus.
        // TODO: also checks that the notebook or console
        // runs a kernel with debugging ability
        this._session = null;
        this._specsManager = (_a = options.specsManager) !== null && _a !== void 0 ? _a : null;
        this._model = new _debugger__WEBPACK_IMPORTED_MODULE_1__.Debugger.Model();
        this._debuggerSources = (_b = options.debuggerSources) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * Signal emitted for debug event messages.
     */
    get eventMessage() {
        return this._eventMessage;
    }
    /**
     * Whether the debug service is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Whether the current debugger is started.
     */
    get isStarted() {
        var _a, _b;
        return (_b = (_a = this._session) === null || _a === void 0 ? void 0 : _a.isStarted) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Whether the current debugger is pausing on exceptions.
     */
    get isPausingOnExceptions() {
        var _a, _b, _c, _d, _e, _f;
        const kernel = (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '';
        if (kernel) {
            const tmpFileParams = this._config.getTmpFileParams(kernel);
            if (tmpFileParams) {
                return ((_f = (_e = this._session) === null || _e === void 0 ? void 0 : _e.pausingOnExceptions.includes(tmpFileParams.prefix)) !== null && _f !== void 0 ? _f : false);
            }
        }
        return false;
    }
    /**
     * Returns the debugger service's model.
     */
    get model() {
        return this._model;
    }
    /**
     * Returns the current debug session.
     */
    get session() {
        return this._session;
    }
    /**
     * Sets the current debug session to the given parameter.
     *
     * @param session - the new debugger session.
     */
    set session(session) {
        var _a;
        if (this._session === session) {
            return;
        }
        if (this._session) {
            this._session.dispose();
        }
        this._session = session;
        (_a = this._session) === null || _a === void 0 ? void 0 : _a.eventMessage.connect((_, event) => {
            if (event.event === 'stopped') {
                this._model.stoppedThreads.add(event.body.threadId);
                void this._getAllFrames();
            }
            else if (event.event === 'continued') {
                this._model.stoppedThreads.delete(event.body.threadId);
                this._clearModel();
                this._clearSignals();
            }
            this._eventMessage.emit(event);
        });
        this._sessionChanged.emit(session);
    }
    /**
     * Signal emitted upon session changed.
     */
    get sessionChanged() {
        return this._sessionChanged;
    }
    /**
     * Dispose the debug service.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal.clearData(this);
    }
    /**
     * Computes an id based on the given code.
     *
     * @param code The source code.
     */
    getCodeId(code) {
        var _a, _b, _c, _d;
        try {
            return this._config.getCodeId(code, (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '');
        }
        catch (_e) {
            return '';
        }
    }
    /**
     * Whether there exists a thread in stopped state.
     */
    hasStoppedThreads() {
        var _a, _b;
        return (_b = ((_a = this._model) === null || _a === void 0 ? void 0 : _a.stoppedThreads.size) > 0) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Request whether debugging is available for the session connection.
     *
     * @param connection The session connection.
     */
    async isAvailable(connection) {
        var _a, _b, _c, _d;
        if (!this._specsManager) {
            return true;
        }
        await this._specsManager.ready;
        const kernel = connection === null || connection === void 0 ? void 0 : connection.kernel;
        if (!kernel) {
            return false;
        }
        const name = kernel.name;
        if (!((_a = this._specsManager.specs) === null || _a === void 0 ? void 0 : _a.kernelspecs[name])) {
            return true;
        }
        return !!((_d = (_c = (_b = this._specsManager.specs.kernelspecs[name]) === null || _b === void 0 ? void 0 : _b.metadata) === null || _c === void 0 ? void 0 : _c['debugger']) !== null && _d !== void 0 ? _d : false);
    }
    /**
     * Clear all the breakpoints for the current session.
     */
    async clearBreakpoints() {
        var _a;
        if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.isStarted) !== true) {
            return;
        }
        this._model.breakpoints.breakpoints.forEach((_, path, map) => {
            void this._setBreakpoints([], path);
        });
        let bpMap = new Map();
        this._model.breakpoints.restoreBreakpoints(bpMap);
    }
    /**
     * Continues the execution of the current thread.
     */
    async continue() {
        try {
            if (!this.session) {
                throw new Error('No active debugger session');
            }
            await this.session.sendRequest('continue', {
                threadId: this._currentThread()
            });
            this._model.stoppedThreads.delete(this._currentThread());
            this._clearModel();
            this._clearSignals();
        }
        catch (err) {
            console.error('Error:', err.message);
        }
    }
    /**
     * Retrieve the content of a source file.
     *
     * @param source The source object containing the path to the file.
     */
    async getSource(source) {
        var _a, _b;
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        const reply = await this.session.sendRequest('source', {
            source,
            sourceReference: (_a = source.sourceReference) !== null && _a !== void 0 ? _a : 0
        });
        return Object.assign(Object.assign({}, reply.body), { path: (_b = source.path) !== null && _b !== void 0 ? _b : '' });
    }
    /**
     * Evaluate an expression.
     *
     * @param expression The expression to evaluate as a string.
     */
    async evaluate(expression) {
        var _a;
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        const frameId = (_a = this.model.callstack.frame) === null || _a === void 0 ? void 0 : _a.id;
        const reply = await this.session.sendRequest('evaluate', {
            context: 'repl',
            expression,
            frameId
        });
        if (!reply.success) {
            return null;
        }
        // get the frames to retrieve the latest state of the variables
        this._clearModel();
        await this._getAllFrames();
        return reply.body;
    }
    /**
     * Makes the current thread run again for one step.
     */
    async next() {
        try {
            if (!this.session) {
                throw new Error('No active debugger session');
            }
            await this.session.sendRequest('next', {
                threadId: this._currentThread()
            });
        }
        catch (err) {
            console.error('Error:', err.message);
        }
    }
    /**
     * Request rich representation of a variable.
     *
     * @param variableName The variable name to request
     * @param frameId The current frame id in which to request the variable
     * @returns The mime renderer data model
     */
    async inspectRichVariable(variableName, frameId) {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        const reply = await this.session.sendRequest('richInspectVariables', {
            variableName,
            frameId
        });
        if (reply.success) {
            return reply.body;
        }
        else {
            throw new Error(reply.message);
        }
    }
    /**
     * Request variables for a given variable reference.
     *
     * @param variablesReference The variable reference to request.
     */
    async inspectVariable(variablesReference) {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        const reply = await this.session.sendRequest('variables', {
            variablesReference
        });
        if (reply.success) {
            return reply.body.variables;
        }
        else {
            throw new Error(reply.message);
        }
    }
    /**
     * Requests all the defined variables and display them in the
     * table view.
     */
    async displayDefinedVariables() {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        const inspectReply = await this.session.sendRequest('inspectVariables', {});
        const variables = inspectReply.body.variables;
        const variableScopes = [
            {
                name: 'Globals',
                variables: variables
            }
        ];
        this._model.variables.scopes = variableScopes;
    }
    /**
     * Restart the debugger.
     */
    async restart() {
        const { breakpoints } = this._model.breakpoints;
        await this.stop();
        await this.start();
        await this._restoreBreakpoints(breakpoints);
    }
    /**
     * Restore the state of a debug session.
     *
     * @param autoStart - If true, starts the debugger if it has not been started.
     */
    async restoreState(autoStart) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (!this.model || !this.session) {
            return;
        }
        const reply = await this.session.restoreState();
        const { body } = reply;
        const breakpoints = this._mapBreakpoints(body.breakpoints);
        const stoppedThreads = new Set(body.stoppedThreads);
        this._model.hasRichVariableRendering = body.richRendering === true;
        this._config.setHashParams({
            kernel: (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '',
            method: body.hashMethod,
            seed: body.hashSeed
        });
        this._config.setTmpFileParams({
            kernel: (_h = (_g = (_f = (_e = this.session) === null || _e === void 0 ? void 0 : _e.connection) === null || _f === void 0 ? void 0 : _f.kernel) === null || _g === void 0 ? void 0 : _g.name) !== null && _h !== void 0 ? _h : '',
            prefix: body.tmpFilePrefix,
            suffix: body.tmpFileSuffix
        });
        this._model.stoppedThreads = stoppedThreads;
        if (!this.isStarted && (autoStart || stoppedThreads.size !== 0)) {
            await this.start();
        }
        if (this.isStarted || autoStart) {
            this._model.title = this.isStarted
                ? ((_k = (_j = this.session) === null || _j === void 0 ? void 0 : _j.connection) === null || _k === void 0 ? void 0 : _k.name) || '-'
                : '-';
        }
        if (this._debuggerSources) {
            const filtered = this._filterBreakpoints(breakpoints);
            this._model.breakpoints.restoreBreakpoints(filtered);
        }
        else {
            this._model.breakpoints.restoreBreakpoints(breakpoints);
        }
        if (stoppedThreads.size !== 0) {
            await this._getAllFrames();
        }
        else if (this.isStarted) {
            this._clearModel();
            this._clearSignals();
        }
    }
    /**
     * Starts a debugger.
     * Precondition: !isStarted
     */
    start() {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        return this.session.start();
    }
    /**
     * Makes the current thread step in a function / method if possible.
     */
    async stepIn() {
        try {
            if (!this.session) {
                throw new Error('No active debugger session');
            }
            await this.session.sendRequest('stepIn', {
                threadId: this._currentThread()
            });
        }
        catch (err) {
            console.error('Error:', err.message);
        }
    }
    /**
     * Makes the current thread step out a function / method if possible.
     */
    async stepOut() {
        try {
            if (!this.session) {
                throw new Error('No active debugger session');
            }
            await this.session.sendRequest('stepOut', {
                threadId: this._currentThread()
            });
        }
        catch (err) {
            console.error('Error:', err.message);
        }
    }
    /**
     * Stops the debugger.
     * Precondition: isStarted
     */
    async stop() {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        await this.session.stop();
        if (this._model) {
            this._model.clear();
        }
    }
    /**
     * Update all breakpoints at once.
     *
     * @param code - The code in the cell where the breakpoints are set.
     * @param breakpoints - The list of breakpoints to set.
     * @param path - Optional path to the file where to set the breakpoints.
     */
    async updateBreakpoints(code, breakpoints, path) {
        var _a;
        if (!((_a = this.session) === null || _a === void 0 ? void 0 : _a.isStarted)) {
            return;
        }
        if (!path) {
            path = (await this._dumpCell(code)).body.sourcePath;
        }
        const state = await this.session.restoreState();
        const localBreakpoints = breakpoints
            .filter(({ line }) => typeof line === 'number')
            .map(({ line }) => ({ line: line }));
        const remoteBreakpoints = this._mapBreakpoints(state.body.breakpoints);
        // Set the local copy of breakpoints to reflect only editors that exist.
        if (this._debuggerSources) {
            const filtered = this._filterBreakpoints(remoteBreakpoints);
            this._model.breakpoints.restoreBreakpoints(filtered);
        }
        else {
            this._model.breakpoints.restoreBreakpoints(remoteBreakpoints);
        }
        // Set the kernel's breakpoints for this path.
        const reply = await this._setBreakpoints(localBreakpoints, path);
        const updatedBreakpoints = reply.body.breakpoints.filter((val, _, arr) => arr.findIndex(el => el.line === val.line) > -1);
        // Update the local model and finish kernel configuration.
        this._model.breakpoints.setBreakpoints(path, updatedBreakpoints);
        await this.session.sendRequest('configurationDone', {});
    }
    /**
     * Determines if pausing on exceptions is supported by the kernel
     *
     */
    pauseOnExceptionsIsValid() {
        var _a;
        if (this.isStarted) {
            if ((_a = this.session) === null || _a === void 0 ? void 0 : _a.exceptionBreakpointFilters) {
                return true;
            }
        }
        return false;
    }
    /**
     * Enable or disable pausing on exceptions.
     *
     * @param enable - Whether to enbale or disable pausing on exceptions.
     */
    async pauseOnExceptions(enable) {
        var _a, _b, _c, _d, _e;
        if (!((_a = this.session) === null || _a === void 0 ? void 0 : _a.isStarted)) {
            return;
        }
        const kernel = (_e = (_d = (_c = (_b = this.session) === null || _b === void 0 ? void 0 : _b.connection) === null || _c === void 0 ? void 0 : _c.kernel) === null || _d === void 0 ? void 0 : _d.name) !== null && _e !== void 0 ? _e : '';
        if (!kernel) {
            return;
        }
        const tmpFileParams = this._config.getTmpFileParams(kernel);
        if (!tmpFileParams) {
            return;
        }
        let prefix = tmpFileParams.prefix;
        const exceptionBreakpointFilters = this.session.exceptionBreakpointFilters;
        let pauseOnExceptionKernels = this.session.pausingOnExceptions;
        if (enable) {
            if (!this.session.pausingOnExceptions.includes(prefix)) {
                pauseOnExceptionKernels.push(prefix);
                this.session.pausingOnExceptions = pauseOnExceptionKernels;
            }
        }
        else {
            let prefixIndex = this.session.pausingOnExceptions.indexOf(prefix);
            if (prefixIndex > -1) {
                this.session.pausingOnExceptions = pauseOnExceptionKernels.splice(prefixIndex, 1);
                this.session.pausingOnExceptions = pauseOnExceptionKernels;
            }
        }
        const filters = [];
        const exceptionOptions = [];
        const breakMode = enable ? 'userUnhandled' : 'never';
        for (let filterDict of exceptionBreakpointFilters !== null && exceptionBreakpointFilters !== void 0 ? exceptionBreakpointFilters : []) {
            filters.push(filterDict.filter);
            exceptionOptions.push({
                path: [{ names: this.session.exceptionPaths }],
                breakMode: breakMode
            });
        }
        const options = {
            filters: filters,
            exceptionOptions: exceptionOptions
        };
        await this.session.sendRequest('setExceptionBreakpoints', options);
    }
    /**
     * Get the debugger state
     *
     * @returns Debugger state
     */
    getDebuggerState() {
        var _a, _b, _c, _d, _e, _f, _g;
        const breakpoints = this._model.breakpoints.breakpoints;
        let cells = [];
        for (const id of breakpoints.keys()) {
            const editorList = this._debuggerSources.find({
                focus: false,
                kernel: (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '',
                path: (_g = (_f = (_e = this._session) === null || _e === void 0 ? void 0 : _e.connection) === null || _f === void 0 ? void 0 : _f.path) !== null && _g !== void 0 ? _g : '',
                source: id
            });
            const tmp_cells = editorList.map(e => e.model.value.text);
            cells = cells.concat(tmp_cells);
        }
        return { cells, breakpoints };
    }
    /**
     * Restore the debugger state
     *
     * @param state Debugger state
     * @returns Whether the state has been restored successfully or not
     */
    async restoreDebuggerState(state) {
        var _a, _b, _c, _d;
        await this.start();
        for (const cell of state.cells) {
            await this._dumpCell(cell);
        }
        const breakpoints = new Map();
        const kernel = (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '';
        const { prefix, suffix } = this._config.getTmpFileParams(kernel);
        for (const item of state.breakpoints) {
            const [id, list] = item;
            const unsuffixedId = id.substr(0, id.length - suffix.length);
            const codeHash = unsuffixedId.substr(unsuffixedId.lastIndexOf('/') + 1);
            const newId = prefix.concat(codeHash).concat(suffix);
            breakpoints.set(newId, list);
        }
        await this._restoreBreakpoints(breakpoints);
        const config = await this.session.sendRequest('configurationDone', {});
        await this.restoreState(false);
        return config.success;
    }
    /**
     * Clear the current model.
     */
    _clearModel() {
        this._model.callstack.frames = [];
        this._model.variables.scopes = [];
    }
    /**
     * Clear the signals set on the model.
     */
    _clearSignals() {
        this._model.callstack.currentFrameChanged.disconnect(this._onCurrentFrameChanged, this);
        this._model.variables.variableExpanded.disconnect(this._onVariableExpanded, this);
    }
    /**
     * Map a list of scopes to a list of variables.
     *
     * @param scopes The list of scopes.
     * @param variables The list of variables.
     */
    _convertScopes(scopes, variables) {
        if (!variables || !scopes) {
            return [];
        }
        return scopes.map((scope, i) => {
            return {
                name: scope.name,
                variables: variables[i].map(variable => {
                    return Object.assign({}, variable);
                })
            };
        });
    }
    /**
     * Get the current thread from the model.
     */
    _currentThread() {
        // TODO: ask the model for the current thread ID
        return 1;
    }
    /**
     * Dump the content of a cell.
     *
     * @param code The source code to dump.
     */
    async _dumpCell(code) {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        return this.session.sendRequest('dumpCell', { code });
    }
    /**
     * Filter breakpoints and only return those associated with a known editor.
     *
     * @param breakpoints - Map of breakpoints.
     *
     */
    _filterBreakpoints(breakpoints) {
        if (!this._debuggerSources) {
            return breakpoints;
        }
        let bpMapForRestore = new Map();
        for (const collection of breakpoints) {
            const [id, list] = collection;
            list.forEach(() => {
                var _a, _b, _c, _d, _e, _f, _g;
                this._debuggerSources.find({
                    focus: false,
                    kernel: (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '',
                    path: (_g = (_f = (_e = this._session) === null || _e === void 0 ? void 0 : _e.connection) === null || _f === void 0 ? void 0 : _f.path) !== null && _g !== void 0 ? _g : '',
                    source: id
                }).forEach(() => {
                    if (list.length > 0) {
                        bpMapForRestore.set(id, list);
                    }
                });
            });
        }
        return bpMapForRestore;
    }
    /**
     * Get all the frames from the kernel.
     */
    async _getAllFrames() {
        this._model.callstack.currentFrameChanged.connect(this._onCurrentFrameChanged, this);
        this._model.variables.variableExpanded.connect(this._onVariableExpanded, this);
        const stackFrames = await this._getFrames(this._currentThread());
        this._model.callstack.frames = stackFrames;
    }
    /**
     * Get all the frames for the given thread id.
     *
     * @param threadId The thread id.
     */
    async _getFrames(threadId) {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        const reply = await this.session.sendRequest('stackTrace', {
            threadId
        });
        const stackFrames = reply.body.stackFrames;
        return stackFrames;
    }
    /**
     * Get all the scopes for the given frame.
     *
     * @param frame The frame.
     */
    async _getScopes(frame) {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        if (!frame) {
            return [];
        }
        const reply = await this.session.sendRequest('scopes', {
            frameId: frame.id
        });
        return reply.body.scopes;
    }
    /**
     * Get the variables for a given scope.
     *
     * @param scope The scope to get variables for.
     */
    async _getVariables(scope) {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        if (!scope) {
            return [];
        }
        const reply = await this.session.sendRequest('variables', {
            variablesReference: scope.variablesReference
        });
        return reply.body.variables;
    }
    /**
     * Process the list of breakpoints from the server and return as a map.
     *
     * @param breakpoints - The list of breakpoints from the kernel.
     *
     */
    _mapBreakpoints(breakpoints) {
        if (!breakpoints.length) {
            return new Map();
        }
        return breakpoints.reduce((map, val) => {
            const { breakpoints, source } = val;
            map.set(source, breakpoints.map(point => (Object.assign(Object.assign({}, point), { source: { path: source }, verified: true }))));
            return map;
        }, new Map());
    }
    /**
     * Handle a change of the current active frame.
     *
     * @param _ The callstack model
     * @param frame The frame.
     */
    async _onCurrentFrameChanged(_, frame) {
        if (!frame) {
            return;
        }
        const scopes = await this._getScopes(frame);
        const variables = await Promise.all(scopes.map(scope => this._getVariables(scope)));
        const variableScopes = this._convertScopes(scopes, variables);
        this._model.variables.scopes = variableScopes;
    }
    async displayModules() {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        const modules = await this.session.sendRequest('modules', {});
        this._model.kernelSources.kernelSources = modules.body.modules.map(module => {
            return {
                name: module.name,
                path: module.path
            };
        });
    }
    /**
     * Handle a variable expanded event and request variables from the kernel.
     *
     * @param _ The variables model.
     * @param variable The expanded variable.
     */
    async _onVariableExpanded(_, variable) {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        const reply = await this.session.sendRequest('variables', {
            variablesReference: variable.variablesReference
        });
        let newVariable = Object.assign(Object.assign({}, variable), { expanded: true });
        reply.body.variables.forEach((variable) => {
            newVariable = Object.assign({ [variable.name]: variable }, newVariable);
        });
        const newScopes = this._model.variables.scopes.map(scope => {
            const findIndex = scope.variables.findIndex(ele => ele.variablesReference === variable.variablesReference);
            scope.variables[findIndex] = newVariable;
            return Object.assign({}, scope);
        });
        this._model.variables.scopes = [...newScopes];
        return reply.body.variables;
    }
    /**
     * Set the breakpoints for a given file.
     *
     * @param breakpoints The list of breakpoints to set.
     * @param path The path to where to set the breakpoints.
     */
    async _setBreakpoints(breakpoints, path) {
        if (!this.session) {
            throw new Error('No active debugger session');
        }
        return await this.session.sendRequest('setBreakpoints', {
            breakpoints: breakpoints,
            source: { path },
            sourceModified: false
        });
    }
    /**
     * Re-send the breakpoints to the kernel and update the model.
     *
     * @param breakpoints The map of breakpoints to send
     */
    async _restoreBreakpoints(breakpoints) {
        for (const [source, points] of breakpoints) {
            await this._setBreakpoints(points
                .filter(({ line }) => typeof line === 'number')
                .map(({ line }) => ({ line: line })), source);
        }
        this._model.breakpoints.restoreBreakpoints(breakpoints);
    }
}
//# sourceMappingURL=service.js.map

/***/ }),

/***/ "../../packages/debugger/lib/session.js":
/*!**********************************************!*\
  !*** ../../packages/debugger/lib/session.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebuggerSession": () => (/* binding */ DebuggerSession)
/* harmony export */ });
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * A concrete implementation of IDebugger.ISession.
 */
class DebuggerSession {
    /**
     * Instantiate a new debug session
     *
     * @param options - The debug session instantiation options.
     */
    constructor(options) {
        this._seq = 0;
        this._ready = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.PromiseDelegate();
        this._isDisposed = false;
        this._isStarted = false;
        this._pausingOnExceptions = [];
        this._exceptionPaths = [];
        this._exceptionBreakpointFilters = [];
        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);
        this._eventMessage = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);
        this.connection = options.connection;
        this.translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__.nullTranslator;
    }
    /**
     * Whether the debug session is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Returns the initialize response .
     */
    get capabilities() {
        return this._capabilities;
    }
    /**
     * A signal emitted when the debug session is disposed.
     */
    get disposed() {
        return this._disposed;
    }
    /**
     * Returns the API session connection to connect to a debugger.
     */
    get connection() {
        return this._connection;
    }
    /**
     * Sets the API session connection to connect to a debugger to
     * the given parameter.
     *
     * @param connection - The new API session connection.
     */
    set connection(connection) {
        var _a, _b;
        if (this._connection) {
            this._connection.iopubMessage.disconnect(this._handleEvent, this);
        }
        this._connection = connection;
        if (!this._connection) {
            this._isStarted = false;
            return;
        }
        this._connection.iopubMessage.connect(this._handleEvent, this);
        this._ready = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.PromiseDelegate();
        const future = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.requestDebug({
            type: 'request',
            seq: 0,
            command: 'debugInfo'
        });
        if (future) {
            future.onReply = (msg) => {
                this._ready.resolve();
                future.dispose();
            };
        }
    }
    /**
     * Whether the debug session is started.
     */
    get isStarted() {
        return this._isStarted;
    }
    /**
     * Whether to pause on exceptions
     */
    get pausingOnExceptions() {
        return this._pausingOnExceptions;
    }
    set pausingOnExceptions(updatedPausingOnExceptions) {
        this._pausingOnExceptions = updatedPausingOnExceptions;
    }
    /**
     * Exception paths defined by the debugger
     */
    get exceptionPaths() {
        return this._exceptionPaths;
    }
    /**
     * Exception breakpoint filters defined by the debugger
     */
    get exceptionBreakpointFilters() {
        return this._exceptionBreakpointFilters;
    }
    /**
     * Signal emitted for debug event messages.
     */
    get eventMessage() {
        return this._eventMessage;
    }
    /**
     * Dispose the debug session.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal.clearData(this);
    }
    /**
     * Start a new debug session
     */
    async start() {
        var _a, _b, _c, _d;
        const initializeResponse = await this.sendRequest('initialize', {
            clientID: 'jupyterlab',
            clientName: 'JupyterLab',
            adapterID: (_c = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : '',
            pathFormat: 'path',
            linesStartAt1: true,
            columnsStartAt1: true,
            supportsVariableType: true,
            supportsVariablePaging: true,
            supportsRunInTerminalRequest: true,
            locale: document.documentElement.lang
        });
        if (!initializeResponse.success) {
            throw new Error(`Could not start the debugger: ${initializeResponse.message}`);
        }
        this._capabilities = initializeResponse.body;
        this._isStarted = true;
        this._exceptionBreakpointFilters = (_d = initializeResponse.body) === null || _d === void 0 ? void 0 : _d.exceptionBreakpointFilters;
        await this.sendRequest('attach', {});
    }
    /**
     * Stop the running debug session.
     */
    async stop() {
        await this.sendRequest('disconnect', {
            restart: false,
            terminateDebuggee: false
        });
        this._isStarted = false;
    }
    /**
     * Restore the state of a debug session.
     */
    async restoreState() {
        var _a;
        const message = await this.sendRequest('debugInfo', {});
        this._isStarted = message.body.isStarted;
        this._exceptionPaths = (_a = message.body) === null || _a === void 0 ? void 0 : _a.exceptionPaths;
        return message;
    }
    /**
     * Send a custom debug request to the kernel.
     *
     * @param command debug command.
     * @param args arguments for the debug command.
     */
    async sendRequest(command, args) {
        await this._ready.promise;
        const message = await this._sendDebugMessage({
            type: 'request',
            seq: this._seq++,
            command,
            arguments: args
        });
        return message.content;
    }
    /**
     * Handle debug events sent on the 'iopub' channel.
     *
     * @param sender - the emitter of the event.
     * @param message - the event message.
     */
    _handleEvent(sender, message) {
        const msgType = message.header.msg_type;
        if (msgType !== 'debug_event') {
            return;
        }
        const event = message.content;
        this._eventMessage.emit(event);
    }
    /**
     * Send a debug request message to the kernel.
     *
     * @param msg debug request message to send to the kernel.
     */
    async _sendDebugMessage(msg) {
        var _a;
        const kernel = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel) {
            return Promise.reject(new Error('A kernel is required to send debug messages.'));
        }
        const reply = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.PromiseDelegate();
        const future = kernel.requestDebug(msg);
        future.onReply = (msg) => {
            reply.resolve(msg);
        };
        await future.done;
        return reply.promise;
    }
}
//# sourceMappingURL=session.js.map

/***/ }),

/***/ "../../packages/debugger/lib/sidebar.js":
/*!**********************************************!*\
  !*** ../../packages/debugger/lib/sidebar.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebuggerSidebar": () => (/* binding */ DebuggerSidebar)
/* harmony export */ });
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/translation */ "webpack/sharing/consume/default/@jupyterlab/translation/@jupyterlab/translation");
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _panels_breakpoints__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./panels/breakpoints */ "../../packages/debugger/lib/panels/breakpoints/index.js");
/* harmony import */ var _panels_callstack__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./panels/callstack */ "../../packages/debugger/lib/panels/callstack/index.js");
/* harmony import */ var _panels_sources__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./panels/sources */ "../../packages/debugger/lib/panels/sources/index.js");
/* harmony import */ var _panels_kernelSources__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./panels/kernelSources */ "../../packages/debugger/lib/panels/kernelSources/index.js");
/* harmony import */ var _panels_variables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./panels/variables */ "../../packages/debugger/lib/panels/variables/index.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.








/**
 * A debugger sidebar.
 */
class DebuggerSidebar extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Panel {
    /**
     * Instantiate a new Debugger.Sidebar
     *
     * @param options The instantiation options for a Debugger.Sidebar
     */
    constructor(options) {
        super();
        this.id = 'jp-debugger-sidebar';
        this.title.icon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.bugIcon;
        this.addClass('jp-DebuggerSidebar');
        const { callstackCommands, breakpointsCommands, editorServices, service, themeManager } = options;
        const translator = options.translator || _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_0__.nullTranslator;
        const model = service.model;
        this.variables = new _panels_variables__WEBPACK_IMPORTED_MODULE_3__.Variables({
            model: model.variables,
            commands: callstackCommands.registry,
            service,
            themeManager,
            translator
        });
        this.callstack = new _panels_callstack__WEBPACK_IMPORTED_MODULE_4__.Callstack({
            commands: callstackCommands,
            model: model.callstack,
            translator
        });
        this.breakpoints = new _panels_breakpoints__WEBPACK_IMPORTED_MODULE_5__.Breakpoints({
            service,
            commands: breakpointsCommands,
            model: model.breakpoints,
            translator
        });
        this.sources = new _panels_sources__WEBPACK_IMPORTED_MODULE_6__.Sources({
            model: model.sources,
            service,
            editorServices,
            translator
        });
        this.kernelSources = new _panels_kernelSources__WEBPACK_IMPORTED_MODULE_7__.KernelSources({
            model: model.kernelSources,
            service,
            translator
        });
        const header = new DebuggerSidebar.Header();
        this.addWidget(header);
        model.titleChanged.connect((_, title) => {
            header.title.label = title;
        });
        this._body = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.SplitPanel();
        this._body.orientation = 'vertical';
        this._body.addClass('jp-DebuggerSidebar-body');
        this.addWidget(this._body);
        this.addItem(this.variables);
        this.addItem(this.callstack);
        this.addItem(this.breakpoints);
        this.addItem(this.sources);
        this.addItem(this.kernelSources);
    }
    /**
     * Add an item at the end of the sidebar.
     *
     * @param widget - The widget to add to the sidebar.
     *
     * #### Notes
     * If the widget is already contained in the sidebar, it will be moved.
     * The item can be removed from the sidebar by setting its parent to `null`.
     */
    addItem(widget) {
        this._body.addWidget(widget);
    }
    /**
     * Insert an item at the specified index.
     *
     * @param index - The index at which to insert the widget.
     *
     * @param widget - The widget to insert into to the sidebar.
     *
     * #### Notes
     * If the widget is already contained in the sidebar, it will be moved.
     * The item can be removed from the sidebar by setting its parent to `null`.
     */
    insertItem(index, widget) {
        this._body.insertWidget(index, widget);
    }
    /**
     * A read-only array of the sidebar items.
     */
    get items() {
        return this._body.widgets;
    }
    /**
     * Dispose the sidebar.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        super.dispose();
    }
}
/**
 * A namespace for DebuggerSidebar statics
 */
(function (DebuggerSidebar) {
    /**
     * The header for a debugger sidebar.
     */
    class Header extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {
        /**
         * Instantiate a new sidebar header.
         */
        constructor() {
            super({ node: Private.createHeader() });
            this.title.changed.connect(_ => {
                this.node.querySelector('h2').textContent = this.title.label;
            });
        }
    }
    DebuggerSidebar.Header = Header;
})(DebuggerSidebar || (DebuggerSidebar = {}));
/**
 * A namespace for private module data.
 */
var Private;
(function (Private) {
    /**
     * Create a sidebar header node.
     */
    function createHeader() {
        const header = document.createElement('div');
        header.classList.add('jp-stack-panel-header');
        const title = document.createElement('h2');
        title.textContent = '-';
        title.classList.add('jp-left-truncated');
        header.appendChild(title);
        return header;
    }
    Private.createHeader = createHeader;
})(Private || (Private = {}));
//# sourceMappingURL=sidebar.js.map

/***/ }),

/***/ "../../packages/debugger/lib/sources.js":
/*!**********************************************!*\
  !*** ../../packages/debugger/lib/sources.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DebuggerSources": () => (/* binding */ DebuggerSources)
/* harmony export */ });
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/algorithm */ "webpack/sharing/consume/default/@lumino/algorithm/@lumino/algorithm");
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



/**
 * The source and editor manager for a debugger instance.
 */
class DebuggerSources {
    /**
     * Create a new DebuggerSources instance.
     *
     * @param options The instantiation options for a DebuggerSources instance.
     */
    constructor(options) {
        var _a, _b, _c;
        this._config = options.config;
        this._shell = options.shell;
        this._notebookTracker = (_a = options.notebookTracker) !== null && _a !== void 0 ? _a : null;
        this._consoleTracker = (_b = options.consoleTracker) !== null && _b !== void 0 ? _b : null;
        this._editorTracker = (_c = options.editorTracker) !== null && _c !== void 0 ? _c : null;
        this._readOnlyEditorTracker = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.WidgetTracker({ namespace: '@jupyterlab/debugger' });
    }
    /**
     * Returns an array of editors for a source matching the current debug
     * session by iterating through all the widgets in each of the supported
     * debugger types (i.e., consoles, files, notebooks).
     *
     * @param params - The editor search parameters.
     */
    find(params) {
        return [
            ...this._findInConsoles(params),
            ...this._findInEditors(params),
            ...this._findInNotebooks(params),
            ...this._findInReadOnlyEditors(params)
        ];
    }
    /**
     * Open a read-only editor in the main area.
     *
     * @param params The editor open parameters.
     */
    open(params) {
        const { editorWrapper, label, caption } = params;
        const widget = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.MainAreaWidget({
            content: editorWrapper
        });
        widget.id = _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_0__.DOMUtils.createDomID();
        widget.title.label = label;
        widget.title.closable = true;
        widget.title.caption = caption;
        widget.title.icon = _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_1__.textEditorIcon;
        this._shell.add(widget, 'main');
        void this._readOnlyEditorTracker.add(widget);
    }
    /**
     * Find relevant editors matching the search params in the notebook tracker.
     *
     * @param params - The editor search parameters.
     */
    _findInNotebooks(params) {
        if (!this._notebookTracker) {
            return [];
        }
        const { focus, kernel, path, source } = params;
        const editors = [];
        this._notebookTracker.forEach(notebookPanel => {
            const sessionContext = notebookPanel.sessionContext;
            if (path !== sessionContext.path) {
                return;
            }
            const notebook = notebookPanel.content;
            if (focus) {
                notebook.mode = 'command';
            }
            const cells = notebookPanel.content.widgets;
            cells.forEach((cell, i) => {
                // check the event is for the correct cell
                const code = cell.model.value.text;
                const codeId = this._getCodeId(code, kernel);
                if (!codeId) {
                    return;
                }
                if (source !== codeId) {
                    return;
                }
                if (focus) {
                    notebook.activeCellIndex = i;
                    if (notebook.activeCell) {
                        const node = notebook.activeCell.inputArea.node;
                        const rect = node.getBoundingClientRect();
                        notebook.scrollToPosition(rect.bottom, 45);
                    }
                    this._shell.activateById(notebookPanel.id);
                }
                editors.push(cell.editor);
            });
        });
        return editors;
    }
    /**
     * Find relevant editors matching the search params in the console tracker.
     *
     * @param params - The editor search parameters.
     */
    _findInConsoles(params) {
        if (!this._consoleTracker) {
            return [];
        }
        const { focus, kernel, path, source } = params;
        const editors = [];
        this._consoleTracker.forEach(consoleWidget => {
            const sessionContext = consoleWidget.sessionContext;
            if (path !== sessionContext.path) {
                return;
            }
            const cells = consoleWidget.console.cells;
            (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_2__.each)(cells, cell => {
                const code = cell.model.value.text;
                const codeId = this._getCodeId(code, kernel);
                if (!codeId) {
                    return;
                }
                if (source !== codeId) {
                    return;
                }
                editors.push(cell.editor);
                if (focus) {
                    this._shell.activateById(consoleWidget.id);
                }
            });
        });
        return editors;
    }
    /**
     * Find relevant editors matching the search params in the editor tracker.
     *
     * @param params - The editor search parameters.
     */
    _findInEditors(params) {
        if (!this._editorTracker) {
            return [];
        }
        const { focus, kernel, path, source } = params;
        const editors = [];
        this._editorTracker.forEach(doc => {
            const fileEditor = doc.content;
            if (path !== fileEditor.context.path) {
                return;
            }
            const editor = fileEditor.editor;
            if (!editor) {
                return;
            }
            const code = editor.model.value.text;
            const codeId = this._getCodeId(code, kernel);
            if (!codeId) {
                return;
            }
            if (source !== codeId) {
                return;
            }
            editors.push(editor);
            if (focus) {
                this._shell.activateById(doc.id);
            }
        });
        return editors;
    }
    /**
     * Find relevant editors matching the search params in the read-only tracker.
     *
     * @param params - The editor search parameters.
     */
    _findInReadOnlyEditors(params) {
        const { focus, kernel, source } = params;
        const editors = [];
        this._readOnlyEditorTracker.forEach(widget => {
            var _a;
            const editor = (_a = widget.content) === null || _a === void 0 ? void 0 : _a.editor;
            if (!editor) {
                return;
            }
            const code = editor.model.value.text;
            const codeId = this._getCodeId(code, kernel);
            if (!codeId) {
                return;
            }
            if (widget.title.caption !== source && source !== codeId) {
                return;
            }
            editors.push(editor);
            if (focus) {
                this._shell.activateById(widget.id);
            }
        });
        return editors;
    }
    /**
     * Get the code id for a given source and kernel,
     * and handle the case of a kernel without parameters.
     *
     * @param code The source code.
     * @param kernel The name of the kernel.
     */
    _getCodeId(code, kernel) {
        try {
            return this._config.getCodeId(code, kernel);
        }
        catch (_a) {
            return '';
        }
    }
}
//# sourceMappingURL=sources.js.map

/***/ }),

/***/ "../../packages/debugger/lib/tokens.js":
/*!*********************************************!*\
  !*** ../../packages/debugger/lib/tokens.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IDebugger": () => (/* binding */ IDebugger),
/* harmony export */   "IDebuggerConfig": () => (/* binding */ IDebuggerConfig),
/* harmony export */   "IDebuggerSources": () => (/* binding */ IDebuggerSources),
/* harmony export */   "IDebuggerSidebar": () => (/* binding */ IDebuggerSidebar),
/* harmony export */   "IDebuggerHandler": () => (/* binding */ IDebuggerHandler)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * The visual debugger token.
 */
const IDebugger = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/debugger:IDebugger');
/**
 * The debugger configuration token.
 */
const IDebuggerConfig = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/debugger:IDebuggerConfig');
/**
 * The debugger sources utility token.
 */
const IDebuggerSources = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/debugger:IDebuggerSources');
/**
 * The debugger configuration token.
 */
const IDebuggerSidebar = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/debugger:IDebuggerSidebar');
/**
 * The debugger handler token.
 */
const IDebuggerHandler = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/debugger:IDebuggerHandler');
//# sourceMappingURL=tokens.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvc3R5bGUvaWNvbnMvY2xvc2UtYWxsLnN2ZyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvc3R5bGUvaWNvbnMvb3Blbi1rZXJuZWwtc291cmNlLnN2ZyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvc3R5bGUvaWNvbnMvcGF1c2Uuc3ZnIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9zdHlsZS9pY29ucy9zdGVwLWludG8uc3ZnIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9zdHlsZS9pY29ucy9zdGVwLW91dC5zdmciLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL3N0eWxlL2ljb25zL3N0ZXAtb3Zlci5zdmciLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL3N0eWxlL2ljb25zL3ZhcmlhYmxlLnN2ZyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvc3R5bGUvaWNvbnMvdmlldy1icmVha3BvaW50LnN2ZyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL2RlYnVnZ2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvZGlhbG9ncy9ldmFsdWF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL2ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9oYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvaGFuZGxlcnMvY29uc29sZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL2hhbmRsZXJzL2VkaXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL2hhbmRsZXJzL2ZpbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9oYW5kbGVycy9ub3RlYm9vay5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL2hhc2guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9pY29ucy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9wYW5lbHMvYnJlYWtwb2ludHMvYm9keS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3BhbmVscy9icmVha3BvaW50cy9oZWFkZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9wYW5lbHMvYnJlYWtwb2ludHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9wYW5lbHMvYnJlYWtwb2ludHMvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9wYW5lbHMvY2FsbHN0YWNrL2JvZHkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9wYW5lbHMvY2FsbHN0YWNrL2hlYWRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3BhbmVscy9jYWxsc3RhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9wYW5lbHMvY2FsbHN0YWNrL21vZGVsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvcGFuZWxzL2tlcm5lbFNvdXJjZXMvYm9keS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3BhbmVscy9rZXJuZWxTb3VyY2VzL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3BhbmVscy9rZXJuZWxTb3VyY2VzL2hlYWRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3BhbmVscy9rZXJuZWxTb3VyY2VzL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvcGFuZWxzL2tlcm5lbFNvdXJjZXMvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9wYW5lbHMvc291cmNlcy9ib2R5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvcGFuZWxzL3NvdXJjZXMvaGVhZGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvcGFuZWxzL3NvdXJjZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9wYW5lbHMvc291cmNlcy9tb2RlbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3BhbmVscy92YXJpYWJsZXMvZ3JpZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3BhbmVscy92YXJpYWJsZXMvaGVhZGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvcGFuZWxzL3ZhcmlhYmxlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3BhbmVscy92YXJpYWJsZXMvbWltZXJlbmRlcmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvcGFuZWxzL3ZhcmlhYmxlcy9tb2RlbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3BhbmVscy92YXJpYWJsZXMvc2NvcGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9wYW5lbHMvdmFyaWFibGVzL3RyZWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9zZXJ2aWNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvc2Vzc2lvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vcGFja2FnZXMvZGVidWdnZXIvbGliL3NpZGViYXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL3BhY2thZ2VzL2RlYnVnZ2VyL2xpYi9zb3VyY2VzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9wYWNrYWdlcy9kZWJ1Z2dlci9saWIvdG9rZW5zLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxpRUFBZSxtOUJBQW05QixFOzs7Ozs7Ozs7Ozs7Ozs7QUNBbCtCLGlFQUFlLHNwQkFBc3BCLEU7Ozs7Ozs7Ozs7Ozs7OztBQ0FycUIsaUVBQWUsMFBBQTBQLEU7Ozs7Ozs7Ozs7Ozs7OztBQ0F6USxpRUFBZSxzaUJBQXNpQixFOzs7Ozs7Ozs7Ozs7Ozs7QUNBcmpCLGlFQUFlLDJmQUEyZixFOzs7Ozs7Ozs7Ozs7Ozs7QUNBMWdCLGlFQUFlLDBuQkFBMG5CLEU7Ozs7Ozs7Ozs7Ozs7OztBQ0F6b0IsaUVBQWUsdW5CQUF1bkIsRTs7Ozs7Ozs7Ozs7Ozs7O0FDQXRvQixpRUFBZSxzcEJBQXNwQixFOzs7Ozs7Ozs7Ozs7Ozs7O0FDQXJxQjtBQUNBO0FBQ2lDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGtCQUFrQixPQUFPLEVBQUUsV0FBVyxFQUFFLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDhDQUFPO0FBQzdEO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUN3RTtBQUM5QjtBQUNrQjtBQUNPO0FBQ3ZCO0FBQytCO0FBQ2dLO0FBQ25NO0FBQ29CO0FBQ1c7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDNUM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJEQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyREFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0VBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUZBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtEQUErRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlEQUFRO0FBQ3JDLDZCQUE2QiwrREFBUTtBQUNyQyw2QkFBNkIsOERBQU87QUFDcEMsNkJBQTZCLGlEQUFRO0FBQ3JDLDRCQUE0QixnREFBTztBQUNuQyw2QkFBNkIsaURBQVE7QUFDckMsOEJBQThCLCtEQUFRO0FBQ3RDLDZCQUE2QixpREFBUTtBQUNyQyxtQ0FBbUMsdURBQWM7QUFDakQsc0NBQXNDLDBEQUFpQjtBQUN2RCxLQUFLLGdEQUFnRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhFQUE4QjtBQUN4RCxLQUFLLHNEQUFzRDtBQUMzRCxDQUFDLDRCQUE0QjtBQUM3QixvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEk4QztBQUNjO0FBQ25CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckYsZ0JBQWdCLHFFQUFtQixFQUFFLDZCQUE2QjtBQUNsRSxnQkFBZ0IsaUVBQWUsRUFBRSx5QkFBeUI7QUFDMUQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0RBQXdEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3REFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLDBCQUEwQiw0REFBYSxHQUFHO0FBQzFDO0FBQ0EsMkJBQTJCLHVEQUFRO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBLDJCQUEyQixxRUFBaUI7QUFDNUMsdUJBQXVCLG9FQUFnQjtBQUN2QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ3FEO0FBQ0k7QUFDTztBQUMxQjtBQUNjO0FBQ047QUFDUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxtRUFBYztBQUN4RjtBQUNBLHFCQUFxQiwrREFBYTtBQUNsQztBQUNBLGNBQWMsOERBQU87QUFDckI7QUFDQSxxQkFBcUIsaUVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0RBQWU7QUFDbkU7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esb0RBQW9ELDZEQUFjO0FBQ2xFO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG9EQUFvRCx1REFBVztBQUMvRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwyREFBMkQsV0FBVztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1REFBZ0IsRUFBRSxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqVEE7QUFDQTtBQUN3RDtBQUNmO0FBQ0U7QUFDUTtBQUNuRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsWUFBWSx1REFBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJEQUFhO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDd0Q7QUFDYjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0VBQWU7QUFDakQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHdCQUF3QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkNBQTZDLGdCQUFnQiwrREFBK0Q7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhEQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZEQUE2RCwyQkFBMkI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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MGMxZTNkMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG4gIDxnIGNsYXNzPVxcXCJqcC1pY29uM1xcXCIgZmlsbD1cXFwiIzYxNjE2MVxcXCI+XFxuICAgIDxwYXRoIGQ9XFxcIk0xNi40ODA1IDE3LjI0ODFDMTYuODE1OCAxNi4zOTcyIDE3IDE1LjQ3MDEgMTcgMTQuNUMxNyAxMC4zNTc5IDEzLjY0MjEgNy4wMDAwMSA5LjUgNy4wMDAwMUM4LjM2MzE0IDcuMDAwMDEgNy4yODUzNiA3LjI1Mjk1IDYuMzE5ODYgNy43MDU2NEM3LjYwMDY0IDYuMDU5MiA5LjYwMDc0IDUgMTEuODQ4MiA1QzE1LjcxNDIgNSAxOC44NDgyIDguMTM0MDEgMTguODQ4MiAxMkMxOC44NDgyIDE0LjA4OTcgMTcuOTMyNSAxNS45NjU1IDE2LjQ4MDUgMTcuMjQ4MVpcXFwiIC8+XFxuICAgIDxwYXRoIGQ9XFxcIk0xOS4xNjA3IDE0LjI0ODFDMTkuNDk2IDEzLjM5NzEgMTkuNjgwMSAxMi40NzAxIDE5LjY4MDEgMTEuNUMxOS42ODAxIDcuMzU3ODYgMTYuMzIyMyA0IDEyLjE4MDEgNEMxMS4wNDMzIDQgOS45NjU1IDQuMjUyOTUgOS4wMDAwMSA0LjcwNTYzQzEwLjI4MDggMy4wNTkxOSAxMi4yODA5IDIgMTQuNTI4NCAyQzE4LjM5NDQgMiAyMS41Mjg0IDUuMTM0IDIxLjUyODQgOUMyMS41Mjg0IDExLjA4OTcgMjAuNjEyNyAxMi45NjU1IDE5LjE2MDcgMTQuMjQ4MVpcXFwiIC8+XFxuICAgIDxwYXRoIGQ9XFxcIk0xNiAxNUMxNiAxOC44NjYgMTIuODY2IDIyIDkgMjJDNS4xMzQwMSAyMiAyIDE4Ljg2NiAyIDE1QzIgMTEuMTM0IDUuMTM0MDEgOCA5IDhDMTIuODY2IDggMTYgMTEuMTM0IDE2IDE1Wk0xMS43OTE0IDExTDEzIDEyLjIwODZMMTAuMjA4NiAxNUwxMyAxNy43OTE0TDExLjc5MTQgMTlMOSAxNi4yMDg2TDYuMjA4NTcgMTlMNSAxNy43OTE0TDcuNzkxNDMgMTVMNSAxMi4yMDg2TDYuMjA4NTcgMTFMOSAxMy43OTE0TDExLjc5MTQgMTFaXFxcIiAvPlxcbiAgICA8L2c+XFxuPC9zdmc+XFxuXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlxcbiAgICA8ZyBjbGFzcz1cXFwianAtaWNvbjNcXFwiIGZpbGw9XFxcIiM2MTYxNjFcXFwiPlxcbiAgICAgICAgPHBhdGggZD1cXFwiTTUgMkgxNUwyMCA3VjIwQzIwIDIwLjUzMDQgMTkuNzg5MyAyMS4wMzkxIDE5LjQxNDIgMjEuNDE0MkMxOS4wMzkxIDIxLjc4OTMgMTguNTMwNCAyMiAxOCAyMkg1QzQuNDY5NTcgMjIgMy45NjA4NiAyMS43ODkzIDMuNTg1NzkgMjEuNDE0MkMzLjIxMDcxIDIxLjAzOTEgMyAyMC41MzA0IDMgMjBWMTRINFYxNkw4IDEzTDQgMTBWMTJIM1Y0QzMgMy40Njk1NyAzLjIxMDcxIDIuOTYwODYgMy41ODU3OSAyLjU4NTc5QzMuOTYwODYgMi4yMTA3MSA0LjQ2OTU3IDIgNSAyWk0xMiAxOEgxNlYxNkgxMlYxOFpNMTIgMTRIMThWMTJIMTJWMTRaTTEyIDEwSDE4VjhIMTJWMTBaTTEwIDE0QzEwLjU1MjMgMTQgMTEgMTMuNTUyMyAxMSAxM0MxMSAxMi40NDc3IDEwLjU1MjMgMTIgMTAgMTJDOS40NDc3MSAxMiA5IDEyLjQ0NzcgOSAxM0M5IDEzLjU1MjMgOS40NDc3MSAxNCAxMCAxNFpcXFwiLz5cXG4gICAgICAgIDxwYXRoIGQ9XFxcIk0zIDEyVjE0SDFWMTNWMTJIM1pcXFwiLz5cXG4gICAgPC9nPlxcbjwvc3ZnPlxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHdpZHRoPVxcXCIyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG4gICAgPGcgY2xhc3M9XFxcImpwLWljb24zXFxcIiBmaWxsPVxcXCIjNjE2MTYxXFxcIj5cXG4gICAgICAgIDxwYXRoIGQ9XFxcIm0gNyw2IGggNCBWIDE4IEggNyBaXFxcIiAvPlxcbiAgICAgICAgPHBhdGggZD1cXFwibSAxMyw2IGggNCB2IDEyIGggLTQgelxcXCIgLz5cXG4gICAgPC9nPlxcbjwvc3ZnPlxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB3aWR0aD1cXFwiMTZcXFwiIGhlaWdodD1cXFwiMTZcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG5cXHQ8ZyBjbGFzcz1cXFwianAtaWNvbjNcXFwiIGZpbGw9XFxcIiM2MTYxNjFcXFwiPlxcblxcdFxcdDxwYXRoIGQ9XFxcIk03Ljk5OTk4IDkuNTMxOThIOC41NDE5OEwxMi40NDcgNS42MjY5OEwxMS4zODYgNC41NjY5OEw4Ljc0ODk4IDcuMTc2OThMOC43NDg5OCAwLjk5OTk4NUg3Ljk5OTk4SDcuMjUwOThMNy4yNTA5OCA3LjE3Njk4TDQuNjEzOTggNC41NjY5OEwzLjU1Mjk4IDUuNjI2OThMNy40NTc5OCA5LjUzMTk4SDcuOTk5OThaTTkuOTU1OTggMTMuMDEzQzkuOTU1OTggMTQuMTE3NSA5LjA2MDU1IDE1LjAxMyA3Ljk1NTk4IDE1LjAxM0M2Ljg1MTQxIDE1LjAxMyA1Ljk1NTk4IDE0LjExNzUgNS45NTU5OCAxMy4wMTNDNS45NTU5OCAxMS45MDg0IDYuODUxNDEgMTEuMDEzIDcuOTU1OTggMTEuMDEzQzkuMDYwNTUgMTEuMDEzIDkuOTU1OTggMTEuOTA4NCA5Ljk1NTk4IDEzLjAxM1pcXFwiLz5cXG5cXHQ8L2c+XFxuPC9zdmc+XFxuXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHdpZHRoPVxcXCIxNlxcXCIgaGVpZ2h0PVxcXCIxNlxcXCIgdmlld0JveD1cXFwiMCAwIDE2IDE2XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlxcblxcdDxnIGNsYXNzPVxcXCJqcC1pY29uM1xcXCIgZmlsbD1cXFwiIzYxNjE2MVxcXCI+XFxuXFx0XFx0PHBhdGggZD1cXFwiTTcuOTk5OTggMUg3LjQ1Nzk4TDMuNTUyOTggNC45MDVMNC42MTM5OCA1Ljk2NUw3LjI1MDk4IDMuMzU1VjkuNTMySDcuOTk5OThIOC43NDg5OFYzLjM1NUwxMS4zODYgNS45NjVMMTIuNDQ3IDQuOTA1TDguNTQxOTggMUg3Ljk5OTk4Wk05Ljk1NTk4IDEzLjAxM0M5Ljk1NTk4IDE0LjExNzYgOS4wNjA1NSAxNS4wMTMgNy45NTU5OCAxNS4wMTNDNi44NTE0MSAxNS4wMTMgNS45NTU5OCAxNC4xMTc2IDUuOTU1OTggMTMuMDEzQzUuOTU1OTggMTEuOTA4NCA2Ljg1MTQxIDExLjAxMyA3Ljk1NTk4IDExLjAxM0M5LjA2MDU1IDExLjAxMyA5Ljk1NTk4IDExLjkwODQgOS45NTU5OCAxMy4wMTNaXFxcIi8+XFxuXFx0PC9nPlxcbjwvc3ZnPlxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB3aWR0aD1cXFwiMTZcXFwiIGhlaWdodD1cXFwiMTZcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG5cXHQ8ZyBjbGFzcz1cXFwianAtaWNvbjNcXFwiIGZpbGw9XFxcIiM2MTYxNjFcXFwiPlxcblxcdFxcdDxwYXRoIGQ9XFxcIk0xNC4yNSA1Ljc1VjEuNzVIMTIuNzVWNC4yOTE2QzExLjYwNSAyLjkzMzAzIDkuODM4OTkgMi4wODMzNCA3LjkwOTE0IDIuMDgzMzRDNC43MzMxNiAyLjA4MzM0IDEuOTg5NDEgNC4zOTAzNiAxLjc1MDcyIDcuNDgwNzVMMS43Mjk5MiA3Ljc1SDMuMjMxTDMuMjUyODcgNy41MjQxQzMuNDY1NDEgNS4zMjkzMiA1LjQ1NTA5IDMuNTgzMzQgNy45MDkxNCAzLjU4MzM0QzkuNjQ1MiAzLjU4MzM0IDExLjE1MjggNC40NTkyNSAxMS45NTg3IDUuNzVIOS4xMjk4NlY3LjI1SDEzLjI5MkwxNC4yNTM1IDYuMjc0OTNWNS43NUgxNC4yNVpNNy45OTk5NyAxNEM5LjEwNDU0IDE0IDkuOTk5OTcgMTMuMTA0NiA5Ljk5OTk3IDEyQzkuOTk5OTcgMTAuODk1NCA5LjEwNDU0IDEwIDcuOTk5OTcgMTBDNi44OTU0IDEwIDUuOTk5OTcgMTAuODk1NCA1Ljk5OTk3IDEyQzUuOTk5OTcgMTMuMTA0NiA2Ljg5NTQgMTQgNy45OTk5NyAxNFpcXFwiLz5cXG5cXHQ8L2c+XFxuPC9zdmc+XFxuXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHdpZHRoPVxcXCIxNlxcXCIgaGVpZ2h0PVxcXCIxNlxcXCIgdmlld0JveD1cXFwiMCAwIDE2IDE2XFxcIiBmaWxsPVxcXCJub25lXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlxcbjxwYXRoIGZpbGwtcnVsZT1cXFwiZXZlbm9kZFxcXCIgY2xpcC1ydWxlPVxcXCJldmVub2RkXFxcIiBkPVxcXCJNMS41IDRMMSA0LjVWMTIuNUwxLjUgMTNINFYxMkgyVjVINFY0SDEuNVpNMTQuNSAxM0wxNSAxMi41TDE1IDQuNUwxNC41IDRIMTJWNUwxNCA1TDE0IDEySDEyVjEzSDE0LjVaTTguNzk2OTMgNUw0LjI5NjkzIDdMNCA3LjQ1NjkxVjkuOTU2OTFMNC4yNDI3NSAxMC4zODU3TDYuNzQyNzUgMTEuODg1N0w3LjIwMzA3IDExLjkxMzhMMTEuNzAzMSA5LjkxMzgxTDEyIDkuNDU2OTFWNi45NTY5MUwxMS43NTcyIDYuNTI4MTZMOS4yNTcyNSA1LjAyODE2TDguNzk2OTMgNVpNNSA4LjM0VjkuNjczODFMNi41IDEwLjU3MzhWOS4yNEw1IDguMzRaTTcuNSA5LjI4MTg0VjEwLjY4NzVMMTEgOS4xMzE5N1Y3LjcyNjI5TDcuNSA5LjI4MTg0Wk0xMC40MTc4IDYuODkwNzFMOC45NjU1OSA2LjAxOTM2TDUuNTgyMTYgNy41MjMxMUw3LjAzNDQxIDguMzk0NDVMMTAuNDE3OCA2Ljg5MDcxWlxcXCIgZmlsbD1cXFwiIzAwN0FDQ1xcXCIvPlxcbjwvc3ZnPlxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG4gICAgPGcgY2xhc3M9XFxcImpwLWljb24zXFxcIiBmaWxsPVxcXCIjNjE2MTYxXFxcIj5cXG4gICAgICAgIDxwYXRoIGQ9XFxcIk01IDJIMTVMMjAgN1YyMEMyMCAyMC41MzA0IDE5Ljc4OTMgMjEuMDM5MSAxOS40MTQyIDIxLjQxNDJDMTkuMDM5MSAyMS43ODkzIDE4LjUzMDQgMjIgMTggMjJINUM0LjQ2OTU3IDIyIDMuOTYwODYgMjEuNzg5MyAzLjU4NTc5IDIxLjQxNDJDMy4yMTA3MSAyMS4wMzkxIDMgMjAuNTMwNCAzIDIwVjE0SDRWMTZMOCAxM0w0IDEwVjEySDNWNEMzIDMuNDY5NTcgMy4yMTA3MSAyLjk2MDg2IDMuNTg1NzkgMi41ODU3OUMzLjk2MDg2IDIuMjEwNzEgNC40Njk1NyAyIDUgMlpNMTIgMThIMTZWMTZIMTJWMThaTTEyIDE0SDE4VjEySDEyVjE0Wk0xMiAxMEgxOFY4SDEyVjEwWk0xMCAxNEMxMC41NTIzIDE0IDExIDEzLjU1MjMgMTEgMTNDMTEgMTIuNDQ3NyAxMC41NTIzIDEyIDEwIDEyQzkuNDQ3NzEgMTIgOSAxMi40NDc3IDkgMTNDOSAxMy41NTIzIDkuNDQ3NzEgMTQgMTAgMTRaXFxcIi8+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMyAxMlYxNEgxVjEzVjEySDNaXFxcIi8+XFxuICAgIDwvZz5cXG48L3N2Zz5cXG5cIjsiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5pbXBvcnQgeyBtdXJtdXIyIH0gZnJvbSAnLi9oYXNoJztcbi8qKlxuICogQSBjbGFzcyB0aGF0IGhvbGRzIGRlYnVnZ2VyIGNvbmZpZ3VyYXRpb24gZm9yIGFsbCBrZXJuZWxzLlxuICovXG5leHBvcnQgY2xhc3MgRGVidWdnZXJDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9maWxlUGFyYW1zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oYXNoTWV0aG9kcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpZCBiYXNlZCBvbiB0aGUgZ2l2ZW4gY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2RlIFRoZSBzb3VyY2UgY29kZS5cbiAgICAgKiBAcGFyYW0ga2VybmVsIFRoZSBrZXJuZWwgbmFtZSBmcm9tIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBnZXRDb2RlSWQoY29kZSwga2VybmVsKSB7XG4gICAgICAgIGNvbnN0IGZpbGVQYXJhbXMgPSB0aGlzLl9maWxlUGFyYW1zLmdldChrZXJuZWwpO1xuICAgICAgICBpZiAoIWZpbGVQYXJhbXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsICgke2tlcm5lbH0pIGhhcyBubyB0bXAgZmlsZSBwYXJhbXMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzaCA9IHRoaXMuX2hhc2hNZXRob2RzLmdldChrZXJuZWwpO1xuICAgICAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsICgke2tlcm5lbH0pIGhhcyBubyBoYXNoaW5nIHBhcmFtcy5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByZWZpeCwgc3VmZml4IH0gPSBmaWxlUGFyYW1zO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7aGFzaChjb2RlKX0ke3N1ZmZpeH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIHBhcmFtZXRlcnMgZm9yIGEga2VybmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIEhhc2hpbmcgcGFyYW1ldGVycyBmb3IgYSBrZXJuZWwuXG4gICAgICovXG4gICAgc2V0SGFzaFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBrZXJuZWwsIG1ldGhvZCwgc2VlZCB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAoIWtlcm5lbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgS2VybmVsIG5hbWUgaXMgbm90IGRlZmluZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ011cm11cjInOlxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc2hNZXRob2RzLnNldChrZXJuZWwsIGNvZGUgPT4gbXVybXVyMihjb2RlLCBzZWVkKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIYXNoIG1ldGhvZCAoJHttZXRob2R9KSBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBhcmFtZXRlcnMgdXNlZCBieSB0aGUga2VybmVsIHRvIGNyZWF0ZSB0ZW1wIGZpbGVzIChlLmcuIGNlbGxzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUZW1wb3JhcnkgZmlsZSBwcmVmaXggYW5kIHN1ZmZpeCBmb3IgYSBrZXJuZWwuXG4gICAgICovXG4gICAgc2V0VG1wRmlsZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBrZXJuZWwsIHByZWZpeCwgc3VmZml4IH0gPSBwYXJhbXM7XG4gICAgICAgIGlmICgha2VybmVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBLZXJuZWwgbmFtZSBpcyBub3QgZGVmaW5lZC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maWxlUGFyYW1zLnNldChrZXJuZWwsIHsga2VybmVsLCBwcmVmaXgsIHN1ZmZpeCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyYW1ldGVycyB1c2VkIGZvciB0aGUgdGVtcCBmaWxlcyAoZS5lLiBjZWxscykgZm9yIGEga2VybmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtlcm5lbCAtIFRoZSBrZXJuZWwgbmFtZSBmcm9tIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBnZXRUbXBGaWxlUGFyYW1zKGtlcm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsZVBhcmFtcy5nZXQoa2VybmVsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgY29kZUljb24sIHJ1bkljb24sIHN0b3BJY29uIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdWktY29tcG9uZW50cyc7XG5pbXBvcnQgeyBEZWJ1Z2dlckNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IERlYnVnZ2VyRXZhbHVhdGVEaWFsb2cgfSBmcm9tICcuL2RpYWxvZ3MvZXZhbHVhdGUnO1xuaW1wb3J0IHsgUmVhZE9ubHlFZGl0b3JGYWN0b3J5IGFzIEVkaXRvckZhY3RvcnkgfSBmcm9tICcuL2ZhY3RvcnknO1xuaW1wb3J0IHsgRGVidWdnZXJIYW5kbGVyIH0gZnJvbSAnLi9oYW5kbGVyJztcbmltcG9ydCB7IEVkaXRvckhhbmRsZXIgYXMgRGVidWdnZXJFZGl0b3JIYW5kbGVyIH0gZnJvbSAnLi9oYW5kbGVycy9lZGl0b3InO1xuaW1wb3J0IHsgY2xvc2VBbGxJY29uIGFzIGNsb3NlQWxsLCBwYXVzZU9uRXhjZXB0aW9uc0ljb24gYXMgcGF1c2VPbkV4Y2VwdGlvbnMsIHN0ZXBJbnRvSWNvbiBhcyBzdGVwSW50bywgc3RlcE91dEljb24gYXMgc3RlcE91dCwgc3RlcE92ZXJJY29uIGFzIHN0ZXBPdmVyLCB2YXJpYWJsZUljb24gYXMgdmFyaWFibGUsIHZpZXdCcmVha3BvaW50SWNvbiBhcyB2aWV3QnJlYWtwb2ludCB9IGZyb20gJy4vaWNvbnMnO1xuaW1wb3J0IHsgRGVidWdnZXJNb2RlbCB9IGZyb20gJy4vbW9kZWwnO1xuaW1wb3J0IHsgVmFyaWFibGVzQm9keUdyaWQgfSBmcm9tICcuL3BhbmVscy92YXJpYWJsZXMvZ3JpZCc7XG5pbXBvcnQgeyBWYXJpYWJsZU1pbWVSZW5kZXJlciB9IGZyb20gJy4vcGFuZWxzL3ZhcmlhYmxlcy9taW1lcmVuZGVyZXInO1xuaW1wb3J0IHsgRGVidWdnZXJTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlJztcbmltcG9ydCB7IERlYnVnZ2VyU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbic7XG5pbXBvcnQgeyBEZWJ1Z2dlclNpZGViYXIgfSBmcm9tICcuL3NpZGViYXInO1xuaW1wb3J0IHsgRGVidWdnZXJTb3VyY2VzIH0gZnJvbSAnLi9zb3VyY2VzJztcbi8qKlxuICogQSBuYW1lc3BhY2UgZm9yIGBEZWJ1Z2dlcmAgc3RhdGljcy5cbiAqL1xuZXhwb3J0IHZhciBEZWJ1Z2dlcjtcbihmdW5jdGlvbiAoRGVidWdnZXIpIHtcbiAgICAvKipcbiAgICAgKiBEZWJ1Z2dlciBjb25maWd1cmF0aW9uIGZvciBhbGwga2VybmVscy5cbiAgICAgKi9cbiAgICBjbGFzcyBDb25maWcgZXh0ZW5kcyBEZWJ1Z2dlckNvbmZpZyB7XG4gICAgfVxuICAgIERlYnVnZ2VyLkNvbmZpZyA9IENvbmZpZztcbiAgICAvKipcbiAgICAgKiBBIGhhbmRsZXIgZm9yIGEgQ29kZUVkaXRvci5JRWRpdG9yLlxuICAgICAqL1xuICAgIGNsYXNzIEVkaXRvckhhbmRsZXIgZXh0ZW5kcyBEZWJ1Z2dlckVkaXRvckhhbmRsZXIge1xuICAgIH1cbiAgICBEZWJ1Z2dlci5FZGl0b3JIYW5kbGVyID0gRWRpdG9ySGFuZGxlcjtcbiAgICAvKipcbiAgICAgKiBBIGhhbmRsZXIgZm9yIGRlYnVnZ2luZyBhIHdpZGdldC5cbiAgICAgKi9cbiAgICBjbGFzcyBIYW5kbGVyIGV4dGVuZHMgRGVidWdnZXJIYW5kbGVyIHtcbiAgICB9XG4gICAgRGVidWdnZXIuSGFuZGxlciA9IEhhbmRsZXI7XG4gICAgLyoqXG4gICAgICogQSBtb2RlbCBmb3IgYSBkZWJ1Z2dlci5cbiAgICAgKi9cbiAgICBjbGFzcyBNb2RlbCBleHRlbmRzIERlYnVnZ2VyTW9kZWwge1xuICAgIH1cbiAgICBEZWJ1Z2dlci5Nb2RlbCA9IE1vZGVsO1xuICAgIC8qKlxuICAgICAqIEEgd2lkZ2V0IGZhY3RvcnkgZm9yIHJlYWQgb25seSBlZGl0b3JzLlxuICAgICAqL1xuICAgIGNsYXNzIFJlYWRPbmx5RWRpdG9yRmFjdG9yeSBleHRlbmRzIEVkaXRvckZhY3Rvcnkge1xuICAgIH1cbiAgICBEZWJ1Z2dlci5SZWFkT25seUVkaXRvckZhY3RvcnkgPSBSZWFkT25seUVkaXRvckZhY3Rvcnk7XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gSURlYnVnZ2VyIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFNlcnZpY2UgZXh0ZW5kcyBEZWJ1Z2dlclNlcnZpY2Uge1xuICAgIH1cbiAgICBEZWJ1Z2dlci5TZXJ2aWNlID0gU2VydmljZTtcbiAgICAvKipcbiAgICAgKiBBIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIElEZWJ1Z2dlci5JU2Vzc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBTZXNzaW9uIGV4dGVuZHMgRGVidWdnZXJTZXNzaW9uIHtcbiAgICB9XG4gICAgRGVidWdnZXIuU2Vzc2lvbiA9IFNlc3Npb247XG4gICAgLyoqXG4gICAgICogVGhlIGRlYnVnZ2VyIHNpZGViYXIgVUkuXG4gICAgICovXG4gICAgY2xhc3MgU2lkZWJhciBleHRlbmRzIERlYnVnZ2VyU2lkZWJhciB7XG4gICAgfVxuICAgIERlYnVnZ2VyLlNpZGViYXIgPSBTaWRlYmFyO1xuICAgIC8qKlxuICAgICAqIFRoZSBzb3VyY2UgYW5kIGVkaXRvciBtYW5hZ2VyIGZvciBhIGRlYnVnZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNsYXNzIFNvdXJjZXMgZXh0ZW5kcyBEZWJ1Z2dlclNvdXJjZXMge1xuICAgIH1cbiAgICBEZWJ1Z2dlci5Tb3VyY2VzID0gU291cmNlcztcbiAgICAvKipcbiAgICAgKiBBIGRhdGEgZ3JpZCB0aGF0IGRpc3BsYXlzIHZhcmlhYmxlcyBpbiBhIGRlYnVnZ2VyIHNlc3Npb24uXG4gICAgICovXG4gICAgY2xhc3MgVmFyaWFibGVzR3JpZCBleHRlbmRzIFZhcmlhYmxlc0JvZHlHcmlkIHtcbiAgICB9XG4gICAgRGVidWdnZXIuVmFyaWFibGVzR3JpZCA9IFZhcmlhYmxlc0dyaWQ7XG4gICAgLyoqXG4gICAgICogQSB3aWRnZXQgdG8gZGlzcGxheSBkYXRhIGFjY29yZGluZyB0byBpdHMgbWltZSB0eXBlXG4gICAgICovXG4gICAgY2xhc3MgVmFyaWFibGVSZW5kZXJlciBleHRlbmRzIFZhcmlhYmxlTWltZVJlbmRlcmVyIHtcbiAgICB9XG4gICAgRGVidWdnZXIuVmFyaWFibGVSZW5kZXJlciA9IFZhcmlhYmxlUmVuZGVyZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbW1hbmQgSURzIHVzZWQgYnkgdGhlIGRlYnVnZ2VyIHBsdWdpbi5cbiAgICAgKi9cbiAgICBsZXQgQ29tbWFuZElEcztcbiAgICAoZnVuY3Rpb24gKENvbW1hbmRJRHMpIHtcbiAgICAgICAgQ29tbWFuZElEcy5kZWJ1Z0NvbnRpbnVlID0gJ2RlYnVnZ2VyOmNvbnRpbnVlJztcbiAgICAgICAgQ29tbWFuZElEcy50ZXJtaW5hdGUgPSAnZGVidWdnZXI6dGVybWluYXRlJztcbiAgICAgICAgQ29tbWFuZElEcy5uZXh0ID0gJ2RlYnVnZ2VyOm5leHQnO1xuICAgICAgICBDb21tYW5kSURzLnN0ZXBJbiA9ICdkZWJ1Z2dlcjpzdGVwSW4nO1xuICAgICAgICBDb21tYW5kSURzLnN0ZXBPdXQgPSAnZGVidWdnZXI6c3RlcE91dCc7XG4gICAgICAgIENvbW1hbmRJRHMuaW5zcGVjdFZhcmlhYmxlID0gJ2RlYnVnZ2VyOmluc3BlY3QtdmFyaWFibGUnO1xuICAgICAgICBDb21tYW5kSURzLnJlbmRlck1pbWVWYXJpYWJsZSA9ICdkZWJ1Z2dlcjpyZW5kZXItbWltZS12YXJpYWJsZSc7XG4gICAgICAgIENvbW1hbmRJRHMuZXZhbHVhdGUgPSAnZGVidWdnZXI6ZXZhbHVhdGUnO1xuICAgICAgICBDb21tYW5kSURzLnJlc3RhcnREZWJ1ZyA9ICdkZWJ1Z2dlcjpyZXN0YXJ0LWRlYnVnJztcbiAgICAgICAgQ29tbWFuZElEcy5wYXVzZSA9ICdkZWJ1Z2dlcjpwYXVzZSc7XG4gICAgfSkoQ29tbWFuZElEcyA9IERlYnVnZ2VyLkNvbW1hbmRJRHMgfHwgKERlYnVnZ2VyLkNvbW1hbmRJRHMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWJ1Z2dlciB1c2VyIGludGVyZmFjZSBpY29ucy5cbiAgICAgKi9cbiAgICBsZXQgSWNvbnM7XG4gICAgKGZ1bmN0aW9uIChJY29ucykge1xuICAgICAgICBJY29ucy5jbG9zZUFsbEljb24gPSBjbG9zZUFsbDtcbiAgICAgICAgSWNvbnMuZXZhbHVhdGVJY29uID0gY29kZUljb247XG4gICAgICAgIEljb25zLmNvbnRpbnVlSWNvbiA9IHJ1bkljb247XG4gICAgICAgIEljb25zLnN0ZXBJbnRvSWNvbiA9IHN0ZXBJbnRvO1xuICAgICAgICBJY29ucy5zdGVwT3V0SWNvbiA9IHN0ZXBPdXQ7XG4gICAgICAgIEljb25zLnN0ZXBPdmVySWNvbiA9IHN0ZXBPdmVyO1xuICAgICAgICBJY29ucy50ZXJtaW5hdGVJY29uID0gc3RvcEljb247XG4gICAgICAgIEljb25zLnZhcmlhYmxlSWNvbiA9IHZhcmlhYmxlO1xuICAgICAgICBJY29ucy52aWV3QnJlYWtwb2ludEljb24gPSB2aWV3QnJlYWtwb2ludDtcbiAgICAgICAgSWNvbnMucGF1c2VPbkV4Y2VwdGlvbnNJY29uID0gcGF1c2VPbkV4Y2VwdGlvbnM7XG4gICAgfSkoSWNvbnMgPSBEZWJ1Z2dlci5JY29ucyB8fCAoRGVidWdnZXIuSWNvbnMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWJ1Z2dlciBkaWFsb2cgaGVscGVycy5cbiAgICAgKi9cbiAgICBsZXQgRGlhbG9ncztcbiAgICAoZnVuY3Rpb24gKERpYWxvZ3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZW4gYSBjb2RlIHByb21wdCBpbiBhIGRpYWxvZy5cbiAgICAgICAgICovXG4gICAgICAgIERpYWxvZ3MuZ2V0Q29kZSA9IERlYnVnZ2VyRXZhbHVhdGVEaWFsb2cuZ2V0Q29kZTtcbiAgICB9KShEaWFsb2dzID0gRGVidWdnZXIuRGlhbG9ncyB8fCAoRGVidWdnZXIuRGlhbG9ncyA9IHt9KSk7XG59KShEZWJ1Z2dlciB8fCAoRGVidWdnZXIgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWdnZXIuanMubWFwIiwiaW1wb3J0IHsgRGlhbG9nIH0gZnJvbSAnQGp1cHl0ZXJsYWIvYXBwdXRpbHMnO1xuaW1wb3J0IHsgQ29kZUNlbGwsIENvZGVDZWxsTW9kZWwgfSBmcm9tICdAanVweXRlcmxhYi9jZWxscyc7XG5pbXBvcnQgeyBXaWRnZXQgfSBmcm9tICdAbHVtaW5vL3dpZGdldHMnO1xuLyoqXG4gKiBBIG5hbWVzcGFjZSBmb3IgRGVidWdnZXJFdmFsdWF0ZURpYWxvZyBzdGF0aWNzLlxuICovXG5leHBvcnQgdmFyIERlYnVnZ2VyRXZhbHVhdGVEaWFsb2c7XG4oZnVuY3Rpb24gKERlYnVnZ2VyRXZhbHVhdGVEaWFsb2cpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHNob3cgYSBkaWFsb2cgdG8gcHJvbXB0IHVzZXIgZm9yIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBkaWFsb2cgc2V0dXAgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggd2hldGhlciB0aGUgZGlhbG9nIHdhcyBhY2NlcHRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENvZGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCBkaWFsb2cgPSBuZXcgRXZhbHVhdGVEaWFsb2coT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBib2R5OiBuZXcgRXZhbHVhdGVEaWFsb2dCb2R5KG9wdGlvbnMpLCBidXR0b25zOiBbXG4gICAgICAgICAgICAgICAgRGlhbG9nLmNhbmNlbEJ1dHRvbih7IGxhYmVsOiBvcHRpb25zLmNhbmNlbExhYmVsIH0pLFxuICAgICAgICAgICAgICAgIERpYWxvZy5va0J1dHRvbih7IGxhYmVsOiBvcHRpb25zLm9rTGFiZWwgfSlcbiAgICAgICAgICAgIF0gfSkpO1xuICAgICAgICByZXR1cm4gZGlhbG9nLmxhdW5jaCgpO1xuICAgIH1cbiAgICBEZWJ1Z2dlckV2YWx1YXRlRGlhbG9nLmdldENvZGUgPSBnZXRDb2RlO1xufSkoRGVidWdnZXJFdmFsdWF0ZURpYWxvZyB8fCAoRGVidWdnZXJFdmFsdWF0ZURpYWxvZyA9IHt9KSk7XG4vKipcbiAqIEEgZGlhbG9nIHRvIHByb21wdCB1c2VycyBmb3IgY29kZSB0byBldmFsdWF0ZS5cbiAqL1xuY2xhc3MgRXZhbHVhdGVEaWFsb2cgZXh0ZW5kcyBEaWFsb2cge1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgRE9NIGV2ZW50cyBmb3IgdGhlIEV2YWx1YXRlIGRpYWxvZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgRE9NIGV2ZW50IHNlbnQgdG8gdGhlIGRpYWxvZyB3aWRnZXRcbiAgICAgKi9cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7IGNvZGUsIHNoaWZ0S2V5IH0gPSBrZXlib2FyZEV2ZW50O1xuICAgICAgICAgICAgaWYgKHNoaWZ0S2V5ICYmIGNvZGUgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5oYW5kbGVFdmVudChldmVudCk7XG4gICAgfVxufVxuLyoqXG4gKiBXaWRnZXQgYm9keSB3aXRoIGEgY29kZSBjZWxsIHByb21wdCBpbiBhIGRpYWxvZ1xuICovXG5jbGFzcyBFdmFsdWF0ZURpYWxvZ0JvZHkgZXh0ZW5kcyBXaWRnZXQge1xuICAgIC8qKlxuICAgICAqIENvZGVQcm9tcHREaWFsb2cgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIENvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IHsgcmVuZGVybWltZSwgbWltZVR5cGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gbmV3IENvZGVDZWxsTW9kZWwoe30pO1xuICAgICAgICBtb2RlbC5taW1lVHlwZSA9IG1pbWVUeXBlICE9PSBudWxsICYmIG1pbWVUeXBlICE9PSB2b2lkIDAgPyBtaW1lVHlwZSA6ICcnO1xuICAgICAgICB0aGlzLl9wcm9tcHQgPSBuZXcgQ29kZUNlbGwoe1xuICAgICAgICAgICAgcmVuZGVybWltZSxcbiAgICAgICAgICAgIG1vZGVsXG4gICAgICAgIH0pLmluaXRpYWxpemVTdGF0ZSgpO1xuICAgICAgICAvLyBleHBsaWNpdGx5IHJlbW92ZSB0aGUgcHJvbXB0IGluIGZyb250IG9mIHRoZSBpbnB1dCBhcmVhXG4gICAgICAgIHRoaXMuX3Byb21wdC5pbnB1dEFyZWEucHJvbXB0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuX3Byb21wdC5ub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0ZXh0IHNwZWNpZmllZCBieSB0aGUgdXNlclxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbXB0Lm1vZGVsLnZhbHVlLnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGFuIGAnYWZ0ZXItYXR0YWNoJ2AgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBvbkFmdGVyQXR0YWNoKG1zZykge1xuICAgICAgICBzdXBlci5vbkFmdGVyQXR0YWNoKG1zZyk7XG4gICAgICAgIHRoaXMuX3Byb21wdC5hY3RpdmF0ZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2YWx1YXRlLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IENvZGVFZGl0b3IsIENvZGVFZGl0b3JXcmFwcGVyIH0gZnJvbSAnQGp1cHl0ZXJsYWIvY29kZWVkaXRvcic7XG4vKipcbiAqIEEgd2lkZ2V0IGZhY3RvcnkgZm9yIHJlYWQgb25seSBlZGl0b3JzLlxuICovXG5leHBvcnQgY2xhc3MgUmVhZE9ubHlFZGl0b3JGYWN0b3J5IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgZWRpdG9yIHdpZGdldCBmYWN0b3J5LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGluc3RhbnRpYXRpb24gb3B0aW9ucyBmb3IgYSBSZWFkT25seUVkaXRvckZhY3RvcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9zZXJ2aWNlcyA9IG9wdGlvbnMuZWRpdG9yU2VydmljZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBDb2RlRWRpdG9yV3JhcHBlciBnaXZlbiBhIFNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgVGhlIHNvdXJjZSB0byBjcmVhdGUgYSBuZXcgZWRpdG9yIGZvci5cbiAgICAgKi9cbiAgICBjcmVhdGVOZXdFZGl0b3Ioc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudCwgbWltZVR5cGUsIHBhdGggfSA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuX3NlcnZpY2VzLmZhY3RvcnlTZXJ2aWNlLm5ld0lubGluZUVkaXRvcjtcbiAgICAgICAgY29uc3QgbWltZVR5cGVTZXJ2aWNlID0gdGhpcy5fc2VydmljZXMubWltZVR5cGVTZXJ2aWNlO1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBuZXcgQ29kZUVkaXRvcldyYXBwZXIoe1xuICAgICAgICAgICAgbW9kZWw6IG5ldyBDb2RlRWRpdG9yLk1vZGVsKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY29udGVudCxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUgfHwgbWltZVR5cGVTZXJ2aWNlLmdldE1pbWVUeXBlQnlGaWxlUGF0aChwYXRoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmYWN0b3J5LFxuICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcnM6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5ub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1qcC1kZWJ1Z2dlcicsICd0cnVlJyk7XG4gICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFjdG9yeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5pbXBvcnQgeyBUb29sYmFyQnV0dG9uIH0gZnJvbSAnQGp1cHl0ZXJsYWIvYXBwdXRpbHMnO1xuaW1wb3J0IHsgbnVsbFRyYW5zbGF0b3IgfSBmcm9tICdAanVweXRlcmxhYi90cmFuc2xhdGlvbic7XG5pbXBvcnQgeyBidWdEb3RJY29uLCBidWdJY29uIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdWktY29tcG9uZW50cyc7XG5pbXBvcnQgeyBEZWJ1Z2dlciB9IGZyb20gJy4vZGVidWdnZXInO1xuaW1wb3J0IHsgQ29uc29sZUhhbmRsZXIgfSBmcm9tICcuL2hhbmRsZXJzL2NvbnNvbGUnO1xuaW1wb3J0IHsgRmlsZUhhbmRsZXIgfSBmcm9tICcuL2hhbmRsZXJzL2ZpbGUnO1xuaW1wb3J0IHsgTm90ZWJvb2tIYW5kbGVyIH0gZnJvbSAnLi9oYW5kbGVycy9ub3RlYm9vayc7XG5jb25zdCBUT09MQkFSX0RFQlVHR0VSX0lURU0gPSAnZGVidWdnZXItaWNvbic7XG4vKipcbiAqIEFkZCBhIGJ1ZyBpY29uIHRvIHRoZSB3aWRnZXQgdG9vbGJhciB0byBlbmFibGUgYW5kIGRpc2FibGUgZGVidWdnaW5nLlxuICpcbiAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byBhZGQgdGhlIGRlYnVnIHRvb2xiYXIgYnV0dG9uIHRvLlxuICogQHBhcmFtIG9uQ2xpY2sgVGhlIGNhbGxiYWNrIHdoZW4gdGhlIHRvb2xiYXIgYnV0dG9uIGlzIGNsaWNrZWQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUljb25CdXR0b24od2lkZ2V0LCBvbkNsaWNrLCBlbmFibGVkLCBwcmVzc2VkLCB0cmFuc2xhdG9yID0gbnVsbFRyYW5zbGF0b3IpIHtcbiAgICBjb25zdCB0cmFucyA9IHRyYW5zbGF0b3IubG9hZCgnanVweXRlcmxhYicpO1xuICAgIGNvbnN0IGljb24gPSBuZXcgVG9vbGJhckJ1dHRvbih7XG4gICAgICAgIGNsYXNzTmFtZTogJ2pwLURlYnVnZ2VyQnVnQnV0dG9uJyxcbiAgICAgICAgaWNvbjogYnVnSWNvbixcbiAgICAgICAgdG9vbHRpcDogdHJhbnMuX18oJ0VuYWJsZSBEZWJ1Z2dlcicpLFxuICAgICAgICBwcmVzc2VkSWNvbjogYnVnRG90SWNvbixcbiAgICAgICAgcHJlc3NlZFRvb2x0aXA6IHRyYW5zLl9fKCdEaXNhYmxlIERlYnVnZ2VyJyksXG4gICAgICAgIGRpc2FibGVkVG9vbHRpcDogdHJhbnMuX18oJ1NlbGVjdCBhIGtlcm5lbCB0aGF0IHN1cHBvcnRzIGRlYnVnZ2luZyB0byBlbmFibGUgZGVidWdnZXInKSxcbiAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgcHJlc3NlZCxcbiAgICAgICAgb25DbGlja1xuICAgIH0pO1xuICAgIGlmICghd2lkZ2V0LnRvb2xiYXIuaW5zZXJ0QmVmb3JlKCdrZXJuZWxOYW1lJywgVE9PTEJBUl9ERUJVR0dFUl9JVEVNLCBpY29uKSkge1xuICAgICAgICB3aWRnZXQudG9vbGJhci5hZGRJdGVtKFRPT0xCQVJfREVCVUdHRVJfSVRFTSwgaWNvbik7XG4gICAgfVxuICAgIHJldHVybiBpY29uO1xufVxuLyoqXG4gKiBVcGRhdGVzIGJ1dHRvbiBzdGF0ZSB0byBvbi9vZmYsXG4gKiBhZGRzL3JlbW92ZXMgY3NzIGNsYXNzIHRvIHVwZGF0ZSBzdHlsaW5nXG4gKlxuICogQHBhcmFtIHdpZGdldCB0aGUgZGVidWcgYnV0dG9uIHdpZGdldFxuICogQHBhcmFtIHByZXNzZWQgdHJ1ZSBpZiBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcbiAqIEBwYXJhbSBlbmFibGVkIHRydWUgaWYgd2lkZ2V0IGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZVxuICogQHBhcmFtIG9uQ2xpY2sgY2xpY2sgaGFuZGxlclxuICovXG5mdW5jdGlvbiB1cGRhdGVJY29uQnV0dG9uU3RhdGUod2lkZ2V0LCBwcmVzc2VkLCBlbmFibGVkID0gdHJ1ZSwgb25DbGljaykge1xuICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgd2lkZ2V0LmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICB3aWRnZXQucHJlc3NlZCA9IHByZXNzZWQ7XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICB3aWRnZXQub25DbGljayA9IG9uQ2xpY2s7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgaGFuZGxlciBmb3IgZGVidWdnaW5nIGEgd2lkZ2V0LlxuICovXG5leHBvcnQgY2xhc3MgRGVidWdnZXJIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBEZWJ1Z2dlckhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciBhIERlYnVnZ2VySGFuZGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuX2NvbnRleHRLZXJuZWxDaGFuZ2VkSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fa2VybmVsQ2hhbmdlZEhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZWRIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9pb3B1Yk1lc3NhZ2VIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9pY29uQnV0dG9ucyA9IHt9O1xuICAgICAgICB0aGlzLl90eXBlID0gb3B0aW9ucy50eXBlO1xuICAgICAgICB0aGlzLl9zaGVsbCA9IG9wdGlvbnMuc2hlbGw7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UgPSBvcHRpb25zLnNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWN0aXZlIHdpZGdldC5cbiAgICAgKi9cbiAgICBnZXQgYWN0aXZlV2lkZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlV2lkZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBkZWJ1ZyBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gd2lkZ2V0LCBhbmRcbiAgICAgKiBoYW5kbGUga2VybmVsIGNoYW5nZWQgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgc2Vzc2lvbiBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZSh3aWRnZXQsIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fa2VybmVsQ2hhbmdlZEhhbmRsZXJzW3dpZGdldC5pZF07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3RhdHVzQ2hhbmdlZEhhbmRsZXJzW3dpZGdldC5pZF07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faW9wdWJNZXNzYWdlSGFuZGxlcnNbd2lkZ2V0LmlkXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVdpZGdldCh3aWRnZXQsIGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtlcm5lbENoYW5nZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB2b2lkIHRoaXMudXBkYXRlV2lkZ2V0KHdpZGdldCwgY29ubmVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGtlcm5lbENoYW5nZWRIYW5kbGVyID0gdGhpcy5fa2VybmVsQ2hhbmdlZEhhbmRsZXJzW3dpZGdldC5pZF07XG4gICAgICAgIGlmIChrZXJuZWxDaGFuZ2VkSGFuZGxlcikge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5rZXJuZWxDaGFuZ2VkLmRpc2Nvbm5lY3Qoa2VybmVsQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2tlcm5lbENoYW5nZWRIYW5kbGVyc1t3aWRnZXQuaWRdID0ga2VybmVsQ2hhbmdlZDtcbiAgICAgICAgY29ubmVjdGlvbi5rZXJuZWxDaGFuZ2VkLmNvbm5lY3Qoa2VybmVsQ2hhbmdlZCk7XG4gICAgICAgIGNvbnN0IHN0YXR1c0NoYW5nZWQgPSAoXywgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAvLyBGSVhNRS1UUkFOUzogTG9jYWxpemFibGU/XG4gICAgICAgICAgICBpZiAoc3RhdHVzLmVuZHNXaXRoKCdyZXN0YXJ0aW5nJykpIHtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMudXBkYXRlV2lkZ2V0KHdpZGdldCwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXR1c0NoYW5nZWRIYW5kbGVyID0gdGhpcy5fc3RhdHVzQ2hhbmdlZEhhbmRsZXJzW3dpZGdldC5pZF07XG4gICAgICAgIGlmIChzdGF0dXNDaGFuZ2VkSGFuZGxlcikge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5zdGF0dXNDaGFuZ2VkLmRpc2Nvbm5lY3Qoc3RhdHVzQ2hhbmdlZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb24uc3RhdHVzQ2hhbmdlZC5jb25uZWN0KHN0YXR1c0NoYW5nZWQpO1xuICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VkSGFuZGxlcnNbd2lkZ2V0LmlkXSA9IHN0YXR1c0NoYW5nZWQ7XG4gICAgICAgIGNvbnN0IGlvcHViTWVzc2FnZSA9IChfLCBtc2cpID0+IHtcbiAgICAgICAgICAgIGlmIChtc2cucGFyZW50X2hlYWRlciAhPSB7fSAmJlxuICAgICAgICAgICAgICAgIG1zZy5wYXJlbnRfaGVhZGVyLm1zZ190eXBlID09XG4gICAgICAgICAgICAgICAgICAgICdleGVjdXRlX3JlcXVlc3QnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VydmljZS5pc1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5fc2VydmljZS5oYXNTdG9wcGVkVGhyZWFkcygpKSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLl9zZXJ2aWNlLmRpc3BsYXlEZWZpbmVkVmFyaWFibGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlvcHViTWVzc2FnZUhhbmRsZXIgPSB0aGlzLl9pb3B1Yk1lc3NhZ2VIYW5kbGVyc1t3aWRnZXQuaWRdO1xuICAgICAgICBpZiAoaW9wdWJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5pb3B1Yk1lc3NhZ2UuZGlzY29ubmVjdChpb3B1Yk1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uLmlvcHViTWVzc2FnZS5jb25uZWN0KGlvcHViTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX2lvcHViTWVzc2FnZUhhbmRsZXJzW3dpZGdldC5pZF0gPSBpb3B1Yk1lc3NhZ2U7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVdpZGdldCA9IHdpZGdldDtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlV2lkZ2V0KHdpZGdldCwgY29ubmVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGRlYnVnIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB3aWRnZXQsIGFuZFxuICAgICAqIGhhbmRsZSBjb25uZWN0aW9uIGtlcm5lbCBjaGFuZ2VkIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHNlc3Npb25Db250ZXh0IFRoZSBzZXNzaW9uIGNvbnRleHQuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ29udGV4dCh3aWRnZXQsIHNlc3Npb25Db250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25DaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZXNzaW9uOiBjb25uZWN0aW9uIH0gPSBzZXNzaW9uQ29udGV4dDtcbiAgICAgICAgICAgIHZvaWQgdGhpcy51cGRhdGUod2lkZ2V0LCBjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29udGV4dEtlcm5lbENoYW5nZWRIYW5kbGVycyA9IHRoaXMuX2NvbnRleHRLZXJuZWxDaGFuZ2VkSGFuZGxlcnNbd2lkZ2V0LmlkXTtcbiAgICAgICAgaWYgKGNvbnRleHRLZXJuZWxDaGFuZ2VkSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHNlc3Npb25Db250ZXh0Lmtlcm5lbENoYW5nZWQuZGlzY29ubmVjdChjb250ZXh0S2VybmVsQ2hhbmdlZEhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0S2VybmVsQ2hhbmdlZEhhbmRsZXJzW3dpZGdldC5pZF0gPSBjb25uZWN0aW9uQ2hhbmdlZDtcbiAgICAgICAgc2Vzc2lvbkNvbnRleHQua2VybmVsQ2hhbmdlZC5jb25uZWN0KGNvbm5lY3Rpb25DaGFuZ2VkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHdpZGdldCwgc2Vzc2lvbkNvbnRleHQuc2Vzc2lvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGRlYnVnIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBzZXNzaW9uIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlV2lkZ2V0KHdpZGdldCwgY29ubmVjdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICghdGhpcy5fc2VydmljZS5tb2RlbCB8fCAhY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0ZvY3VzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NoZWxsLmN1cnJlbnRXaWRnZXQgPT09IHdpZGdldDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlQXR0cmlidXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyc1t3aWRnZXQuaWRdKSB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0Lm5vZGUucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWpwLWRlYnVnZ2VyJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2lkZ2V0Lm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLWpwLWRlYnVnZ2VyJywgJ3RydWUnKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3JlYXRlSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1t3aWRnZXQuaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbm90ZWJvb2snOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1t3aWRnZXQuaWRdID0gbmV3IE5vdGVib29rSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z2dlclNlcnZpY2U6IHRoaXMuX3NlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IHdpZGdldFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29uc29sZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW3dpZGdldC5pZF0gPSBuZXcgQ29uc29sZUhhbmRsZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdnZXJTZXJ2aWNlOiB0aGlzLl9zZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiB3aWRnZXRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1t3aWRnZXQuaWRdID0gbmV3IEZpbGVIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyU2VydmljZTogdGhpcy5fc2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldDogd2lkZ2V0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgTm8gaGFuZGxlciBmb3IgdGhlIHR5cGUgJHt0aGlzLl90eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlbW92ZUhhbmRsZXJzID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2hhbmRsZXJzW3dpZGdldC5pZF07XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1t3aWRnZXQuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2tlcm5lbENoYW5nZWRIYW5kbGVyc1t3aWRnZXQuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N0YXR1c0NoYW5nZWRIYW5kbGVyc1t3aWRnZXQuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lvcHViTWVzc2FnZUhhbmRsZXJzW3dpZGdldC5pZF07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY29udGV4dEtlcm5lbENoYW5nZWRIYW5kbGVyc1t3aWRnZXQuaWRdO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIG1vZGVsIGlmIHRoZSBoYW5kbGVyIGJlaW5nIHJlbW92ZWQgY29ycmVzcG9uZHNcbiAgICAgICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGFjdGl2ZSBkZWJ1ZyBzZXNzaW9uLCBvciBpZiB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgLy8gZG9lcyBub3QgaGF2ZSBhIGtlcm5lbC5cbiAgICAgICAgICAgIGlmICgoKF9iID0gKF9hID0gdGhpcy5fc2VydmljZS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29ubmVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhdGgpID09PSAoY29ubmVjdGlvbiA9PT0gbnVsbCB8fCBjb25uZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uLnBhdGgpIHx8XG4gICAgICAgICAgICAgICAgISgoX2QgPSAoX2MgPSB0aGlzLl9zZXJ2aWNlLnNlc3Npb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qua2VybmVsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fc2VydmljZS5tb2RlbDtcbiAgICAgICAgICAgICAgICBtb2RlbC5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZFRvb2xiYXJCdXR0b24gPSAoZW5hYmxlZCA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlYnVnQnV0dG9uID0gdGhpcy5faWNvbkJ1dHRvbnNbd2lkZ2V0LmlkXTtcbiAgICAgICAgICAgIGlmICghZGVidWdCdXR0b24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pY29uQnV0dG9uc1t3aWRnZXQuaWRdID0gdXBkYXRlSWNvbkJ1dHRvbih3aWRnZXQsIHRvZ2dsZURlYnVnZ2luZywgdGhpcy5fc2VydmljZS5pc1N0YXJ0ZWQsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlSWNvbkJ1dHRvblN0YXRlKGRlYnVnQnV0dG9uLCB0aGlzLl9zZXJ2aWNlLmlzU3RhcnRlZCwgZW5hYmxlZCwgdG9nZ2xlRGVidWdnaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaXNEZWJ1Z2dlck9uID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9zZXJ2aWNlLmlzU3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLl9wcmV2aW91c0Nvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkgPT09IChjb25uZWN0aW9uID09PSBudWxsIHx8IGNvbm5lY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaWQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RvcERlYnVnZ2VyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5zZXNzaW9uLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2VydmljZS5zdG9wKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXJ0RGVidWdnZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5zZXNzaW9uLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNDb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NlcnZpY2UucmVzdG9yZVN0YXRlKHRydWUpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2VydmljZS5kaXNwbGF5RGVmaW5lZFZhcmlhYmxlcygpO1xuICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IHRoaXMuX3NlcnZpY2Uuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN1cHBvcnRzTW9kdWxlc1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXJ2aWNlLmRpc3BsYXlNb2R1bGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvZ2dsZURlYnVnZ2luZyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIGJhaWwgaWYgdGhlIHdpZGdldCBkb2Vzbid0IGhhdmUgZm9jdXNcbiAgICAgICAgICAgIGlmICghaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlYnVnQnV0dG9uID0gdGhpcy5faWNvbkJ1dHRvbnNbd2lkZ2V0LmlkXTtcbiAgICAgICAgICAgIGlmIChpc0RlYnVnZ2VyT24oKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0b3BEZWJ1Z2dlcigpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlSWNvbkJ1dHRvblN0YXRlKGRlYnVnQnV0dG9uLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdGFydERlYnVnZ2VyKCk7XG4gICAgICAgICAgICAgICAgY3JlYXRlSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUljb25CdXR0b25TdGF0ZShkZWJ1Z0J1dHRvbiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZFRvb2xiYXJCdXR0b24oZmFsc2UpO1xuICAgICAgICBjb25zdCBkZWJ1Z2dpbmdFbmFibGVkID0gYXdhaXQgdGhpcy5fc2VydmljZS5pc0F2YWlsYWJsZShjb25uZWN0aW9uKTtcbiAgICAgICAgaWYgKCFkZWJ1Z2dpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICByZW1vdmVIYW5kbGVycygpO1xuICAgICAgICAgICAgdXBkYXRlSWNvbkJ1dHRvblN0YXRlKHRoaXMuX2ljb25CdXR0b25zW3dpZGdldC5pZF0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBhY3RpdmUgZGVidWcgc2Vzc2lvblxuICAgICAgICBpZiAoIXRoaXMuX3NlcnZpY2Uuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5zZXNzaW9uID0gbmV3IERlYnVnZ2VyLlNlc3Npb24oeyBjb25uZWN0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNDb25uZWN0aW9uID0gKChfYSA9IHRoaXMuX3NlcnZpY2Uuc2Vzc2lvbi5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eua2VybmVsKSA/IHRoaXMuX3NlcnZpY2Uuc2Vzc2lvbi5jb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5zZXNzaW9uLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX3NlcnZpY2UucmVzdG9yZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuX3NlcnZpY2UuaXNTdGFydGVkICYmICF0aGlzLl9zZXJ2aWNlLmhhc1N0b3BwZWRUaHJlYWRzKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NlcnZpY2UuZGlzcGxheURlZmluZWRWYXJpYWJsZXMoKTtcbiAgICAgICAgICAgIGlmICgoX2MgPSAoX2IgPSB0aGlzLl9zZXJ2aWNlLnNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdXBwb3J0c01vZHVsZXNSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2VydmljZS5kaXNwbGF5TW9kdWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUljb25CdXR0b25TdGF0ZSh0aGlzLl9pY29uQnV0dG9uc1t3aWRnZXQuaWRdLCB0aGlzLl9zZXJ2aWNlLmlzU3RhcnRlZCwgdHJ1ZSk7XG4gICAgICAgIC8vIGNoZWNrIHRoZSBzdGF0ZSBvZiB0aGUgZGVidWcgc2Vzc2lvblxuICAgICAgICBpZiAoIXRoaXMuX3NlcnZpY2UuaXNTdGFydGVkKSB7XG4gICAgICAgICAgICByZW1vdmVIYW5kbGVycygpO1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5zZXNzaW9uLmNvbm5lY3Rpb24gPSAoX2QgPSB0aGlzLl9wcmV2aW91c0Nvbm5lY3Rpb24pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGNvbm5lY3Rpb247XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXJ2aWNlLnJlc3RvcmVTdGF0ZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGRlYnVnZ2VyIGlzIHN0YXJ0ZWQgYnV0IHRoZXJlIGlzIG5vIGhhbmRsZXIsIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgY3JlYXRlSGFuZGxlcigpO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIGRpc3Bvc2VkIHNpZ25hbHNcbiAgICAgICAgd2lkZ2V0LmRpc3Bvc2VkLmNvbm5lY3QocmVtb3ZlSGFuZGxlcnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhbmRsZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgT2JzZXJ2YWJsZU1hcCB9IGZyb20gJ0BqdXB5dGVybGFiL29ic2VydmFibGVzJztcbmltcG9ydCB7IGVhY2ggfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG5pbXBvcnQgeyBFZGl0b3JIYW5kbGVyIH0gZnJvbSAnLi4vaGFuZGxlcnMvZWRpdG9yJztcbi8qKlxuICogQSBoYW5kbGVyIGZvciBjb25zb2xlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnNvbGVIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBDb25zb2xlSGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbnN0YW50aWF0aW9uIG9wdGlvbnMgZm9yIGEgQ29uc29sZUhhbmRsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9kZWJ1Z2dlclNlcnZpY2UgPSBvcHRpb25zLmRlYnVnZ2VyU2VydmljZTtcbiAgICAgICAgdGhpcy5fY29uc29sZVBhbmVsID0gb3B0aW9ucy53aWRnZXQ7XG4gICAgICAgIHRoaXMuX2NlbGxNYXAgPSBuZXcgT2JzZXJ2YWJsZU1hcCgpO1xuICAgICAgICBjb25zdCBjb2RlQ29uc29sZSA9IHRoaXMuX2NvbnNvbGVQYW5lbC5jb25zb2xlO1xuICAgICAgICBpZiAoY29kZUNvbnNvbGUucHJvbXB0Q2VsbCkge1xuICAgICAgICAgICAgdGhpcy5fYWRkRWRpdG9ySGFuZGxlcihjb2RlQ29uc29sZS5wcm9tcHRDZWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlQ29uc29sZS5wcm9tcHRDZWxsQ3JlYXRlZC5jb25uZWN0KChfLCBjZWxsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFZGl0b3JIYW5kbGVyKGNlbGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWRkSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICBlYWNoKGNvZGVDb25zb2xlLmNlbGxzLCBjZWxsID0+IHRoaXMuX2FkZEVkaXRvckhhbmRsZXIoY2VsbCkpO1xuICAgICAgICB9O1xuICAgICAgICBhZGRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9jb25zb2xlUGFuZWwuY29uc29sZS5jZWxscy5jaGFuZ2VkLmNvbm5lY3QoYWRkSGFuZGxlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jZWxsTWFwLnZhbHVlcygpLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyLmRpc3Bvc2UoKSk7XG4gICAgICAgIHRoaXMuX2NlbGxNYXAuZGlzcG9zZSgpO1xuICAgICAgICBTaWduYWwuY2xlYXJEYXRhKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgZWRpdG9yIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBjZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlbGwgVGhlIGNlbGwgdG8gYWRkIHRoZSBoYW5kbGVyIHRvLlxuICAgICAqL1xuICAgIF9hZGRFZGl0b3JIYW5kbGVyKGNlbGwpIHtcbiAgICAgICAgY29uc3QgbW9kZWxJZCA9IGNlbGwubW9kZWwuaWQ7XG4gICAgICAgIGlmIChjZWxsLm1vZGVsLnR5cGUgIT09ICdjb2RlJyB8fCB0aGlzLl9jZWxsTWFwLmhhcyhtb2RlbElkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVDZWxsID0gY2VsbDtcbiAgICAgICAgY29uc3QgZWRpdG9ySGFuZGxlciA9IG5ldyBFZGl0b3JIYW5kbGVyKHtcbiAgICAgICAgICAgIGRlYnVnZ2VyU2VydmljZTogdGhpcy5fZGVidWdnZXJTZXJ2aWNlLFxuICAgICAgICAgICAgZWRpdG9yOiBjb2RlQ2VsbC5lZGl0b3JcbiAgICAgICAgfSk7XG4gICAgICAgIGNvZGVDZWxsLmRpc3Bvc2VkLmNvbm5lY3QoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY2VsbE1hcC5kZWxldGUobW9kZWxJZCk7XG4gICAgICAgICAgICBlZGl0b3JIYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NlbGxNYXAuc2V0KG1vZGVsSWQsIGVkaXRvckhhbmRsZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnNvbGUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgQWN0aXZpdHlNb25pdG9yIH0gZnJvbSAnQGp1cHl0ZXJsYWIvY29yZXV0aWxzJztcbmltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ0BsdW1pbm8vc2lnbmFsaW5nJztcbi8qKlxuICogVGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgbGluZS5cbiAqL1xuY29uc3QgTElORV9ISUdITElHSFRfQ0xBU1MgPSAnanAtRGVidWdnZXJFZGl0b3ItaGlnaGxpZ2h0Jztcbi8qKlxuICogVGhlIHRpbWVvdXQgZm9yIGxpc3RlbmluZyB0byBlZGl0b3IgY29udGVudCBjaGFuZ2VzLlxuICovXG5jb25zdCBFRElUT1JfQ0hBTkdFRF9USU1FT1VUID0gMTAwMDtcbi8qKlxuICogQSBoYW5kbGVyIGZvciBhIENvZGVFZGl0b3IuSUVkaXRvci5cbiAqL1xuZXhwb3J0IGNsYXNzIEVkaXRvckhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgbmV3IEVkaXRvckhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciBhIEVkaXRvckhhbmRsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGUgYSBjbGljayBvbiB0aGUgZ3V0dGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBlZGl0b3IgZnJvbSB3aGVyZSB0aGUgY2xpY2sgb3JpZ2luYXRlZC5cbiAgICAgICAgICogQHBhcmFtIGxpbmVOdW1iZXIgVGhlIGxpbmUgY29ycmVzcG9uZGluZyB0byB0aGUgY2xpY2sgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbkd1dHRlckNsaWNrID0gKGVkaXRvciwgbGluZU51bWJlcikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gZWRpdG9yLmxpbmVJbmZvKGxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgaWYgKCFpbmZvIHx8IHRoaXMuX2lkICE9PSAoKF9iID0gKF9hID0gdGhpcy5fZGVidWdnZXJTZXJ2aWNlLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gISFpbmZvLmd1dHRlck1hcmtlcnM7XG4gICAgICAgICAgICBsZXQgYnJlYWtwb2ludHMgPSB0aGlzLl9nZXRCcmVha3BvaW50cygpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzID0gYnJlYWtwb2ludHMuZmlsdGVyKGVsZSA9PiBlbGUubGluZSAhPT0gaW5mby5saW5lICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVha3BvaW50cy5wdXNoKFByaXZhdGUuY3JlYXRlQnJlYWtwb2ludCgoX2MgPSB0aGlzLl9wYXRoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLl9kZWJ1Z2dlclNlcnZpY2Uuc2Vzc2lvbi5jb25uZWN0aW9uLm5hbWUsIGluZm8ubGluZSArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgdGhpcy5fZGVidWdnZXJTZXJ2aWNlLnVwZGF0ZUJyZWFrcG9pbnRzKHRoaXMuX2VkaXRvci5tb2RlbC52YWx1ZS50ZXh0LCBicmVha3BvaW50cywgdGhpcy5fcGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2lkID0gKF9jID0gKF9iID0gKF9hID0gb3B0aW9ucy5kZWJ1Z2dlclNlcnZpY2Uuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XG4gICAgICAgIHRoaXMuX3BhdGggPSAoX2QgPSBvcHRpb25zLnBhdGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnO1xuICAgICAgICB0aGlzLl9kZWJ1Z2dlclNlcnZpY2UgPSBvcHRpb25zLmRlYnVnZ2VyU2VydmljZTtcbiAgICAgICAgdGhpcy5fZWRpdG9yID0gb3B0aW9ucy5lZGl0b3I7XG4gICAgICAgIHRoaXMuX2VkaXRvck1vbml0b3IgPSBuZXcgQWN0aXZpdHlNb25pdG9yKHtcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5fZWRpdG9yLm1vZGVsLnZhbHVlLmNoYW5nZWQsXG4gICAgICAgICAgICB0aW1lb3V0OiBFRElUT1JfQ0hBTkdFRF9USU1FT1VUXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9lZGl0b3JNb25pdG9yLmFjdGl2aXR5U3RvcHBlZC5jb25uZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRFZGl0b3JCcmVha3BvaW50cygpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fZGVidWdnZXJTZXJ2aWNlLm1vZGVsLmJyZWFrcG9pbnRzLmNoYW5nZWQuY29ubmVjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2VkaXRvciB8fCB0aGlzLl9lZGl0b3IuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkZEJyZWFrcG9pbnRzVG9FZGl0b3IoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RlYnVnZ2VyU2VydmljZS5tb2RlbC5icmVha3BvaW50cy5yZXN0b3JlZC5jb25uZWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZWRpdG9yIHx8IHRoaXMuX2VkaXRvci5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkQnJlYWtwb2ludHNUb0VkaXRvcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGVidWdnZXJTZXJ2aWNlLm1vZGVsLmNhbGxzdGFjay5jdXJyZW50RnJhbWVDaGFuZ2VkLmNvbm5lY3QoKCkgPT4ge1xuICAgICAgICAgICAgRWRpdG9ySGFuZGxlci5jbGVhckhpZ2hsaWdodCh0aGlzLl9lZGl0b3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2V0dXBFZGl0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvclxuICAgICAqL1xuICAgIGdldCBlZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lZGl0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgdGhlIGhhbmRsZXIuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VkaXRvck1vbml0b3IuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9jbGVhckVkaXRvcigpO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICBTaWduYWwuY2xlYXJEYXRhKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoIHRoZSBicmVha3BvaW50cyBkaXNwbGF5XG4gICAgICovXG4gICAgcmVmcmVzaEJyZWFrcG9pbnRzKCkge1xuICAgICAgICB0aGlzLl9hZGRCcmVha3BvaW50c1RvRWRpdG9yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHVwIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgX3NldHVwRWRpdG9yKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VkaXRvciB8fCB0aGlzLl9lZGl0b3IuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZEJyZWFrcG9pbnRzVG9FZGl0b3IoKTtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBlZGl0b3Iuc2V0T3B0aW9uKCdsaW5lTnVtYmVycycsIHRydWUpO1xuICAgICAgICBlZGl0b3IuZWRpdG9yLnNldE9wdGlvbignZ3V0dGVycycsIFtcbiAgICAgICAgICAgICdDb2RlTWlycm9yLWxpbmVudW1iZXJzJyxcbiAgICAgICAgICAgICdicmVha3BvaW50cydcbiAgICAgICAgXSk7XG4gICAgICAgIGVkaXRvci5lZGl0b3Iub24oJ2d1dHRlckNsaWNrJywgdGhpcy5fb25HdXR0ZXJDbGljayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBlZGl0b3IgYnkgcmVtb3ZpbmcgdmlzdWFsIGVsZW1lbnRzIGFuZCBoYW5kbGVycy5cbiAgICAgKi9cbiAgICBfY2xlYXJFZGl0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWRpdG9yIHx8IHRoaXMuX2VkaXRvci5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBFZGl0b3JIYW5kbGVyLmNsZWFySGlnaGxpZ2h0KGVkaXRvcik7XG4gICAgICAgIEVkaXRvckhhbmRsZXIuY2xlYXJHdXR0ZXIoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLnNldE9wdGlvbignbGluZU51bWJlcnMnLCBmYWxzZSk7XG4gICAgICAgIGVkaXRvci5lZGl0b3Iuc2V0T3B0aW9uKCdndXR0ZXJzJywgW10pO1xuICAgICAgICBlZGl0b3IuZWRpdG9yLm9mZignZ3V0dGVyQ2xpY2snLCB0aGlzLl9vbkd1dHRlckNsaWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgYnJlYWtwb2ludHMgZnJvbSB0aGUgZWRpdG9yIFVJIHZpYSB0aGUgZGVidWcgc2VydmljZS5cbiAgICAgKi9cbiAgICBfc2VuZEVkaXRvckJyZWFrcG9pbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5fZWRpdG9yLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBicmVha3BvaW50cyA9IHRoaXMuX2dldEJyZWFrcG9pbnRzRnJvbUVkaXRvcigpLm1hcChsaW5lSW5mbyA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIFByaXZhdGUuY3JlYXRlQnJlYWtwb2ludCgoKF9iID0gKF9hID0gdGhpcy5fZGVidWdnZXJTZXJ2aWNlLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgfHwgJycsIGxpbmVJbmZvLmxpbmUgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZvaWQgdGhpcy5fZGVidWdnZXJTZXJ2aWNlLnVwZGF0ZUJyZWFrcG9pbnRzKHRoaXMuX2VkaXRvci5tb2RlbC52YWx1ZS50ZXh0LCBicmVha3BvaW50cywgdGhpcy5fcGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgYnJlYWtwb2ludHMgdG8gdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBfYWRkQnJlYWtwb2ludHNUb0VkaXRvcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBjb25zdCBicmVha3BvaW50cyA9IHRoaXMuX2dldEJyZWFrcG9pbnRzKCk7XG4gICAgICAgIGlmICh0aGlzLl9pZCAhPT0gKChfYiA9IChfYSA9IHRoaXMuX2RlYnVnZ2VyU2VydmljZS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29ubmVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEVkaXRvckhhbmRsZXIuY2xlYXJHdXR0ZXIoZWRpdG9yKTtcbiAgICAgICAgYnJlYWtwb2ludHMuZm9yRWFjaChicmVha3BvaW50ID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnJlYWtwb2ludC5saW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGVkaXRvci5lZGl0b3Iuc2V0R3V0dGVyTWFya2VyKGJyZWFrcG9pbnQubGluZSAtIDEsICdicmVha3BvaW50cycsIFByaXZhdGUuY3JlYXRlTWFya2VyTm9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBicmVha3BvaW50cyBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgX2dldEJyZWFrcG9pbnRzRnJvbUVkaXRvcigpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0b3IuZG9jLmxpbmVDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBlZGl0b3IuZWRpdG9yLmxpbmVJbmZvKGkpO1xuICAgICAgICAgICAgaWYgKGluZm8uZ3V0dGVyTWFya2Vycykge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goaW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJyZWFrcG9pbnRzIGZvciB0aGUgZWRpdG9yIHVzaW5nIGl0cyBjb250ZW50IChjb2RlKSxcbiAgICAgKiBvciBpdHMgcGF0aCAoaWYgaXQgZXhpc3RzKS5cbiAgICAgKi9cbiAgICBfZ2V0QnJlYWtwb2ludHMoKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9lZGl0b3IubW9kZWwudmFsdWUudGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnZ2VyU2VydmljZS5tb2RlbC5icmVha3BvaW50cy5nZXRCcmVha3BvaW50cyh0aGlzLl9wYXRoIHx8IHRoaXMuX2RlYnVnZ2VyU2VydmljZS5nZXRDb2RlSWQoY29kZSkpO1xuICAgIH1cbn1cbi8qKlxuICogQSBuYW1lc3BhY2UgZm9yIEVkaXRvckhhbmRsZXIgYHN0YXRpY3NgLlxuICovXG4oZnVuY3Rpb24gKEVkaXRvckhhbmRsZXIpIHtcbiAgICAvKipcbiAgICAgKiBIaWdobGlnaHQgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgZnJhbWUgaW4gdGhlIGdpdmVuIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3IgVGhlIGVkaXRvciB0byBoaWdobGlnaHQuXG4gICAgICogQHBhcmFtIGxpbmUgVGhlIGxpbmUgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3dDdXJyZW50TGluZShlZGl0b3IsIGxpbmUpIHtcbiAgICAgICAgY2xlYXJIaWdobGlnaHQoZWRpdG9yKTtcbiAgICAgICAgY29uc3QgY21FZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIGNtRWRpdG9yLmVkaXRvci5hZGRMaW5lQ2xhc3MobGluZSAtIDEsICd3cmFwJywgTElORV9ISUdITElHSFRfQ0xBU1MpO1xuICAgICAgICBjbUVkaXRvci5zY3JvbGxJbnRvVmlld0NlbnRlcmVkKHsgY2g6IDAsIGxpbmU6IGxpbmUgLSAxIH0pO1xuICAgIH1cbiAgICBFZGl0b3JIYW5kbGVyLnNob3dDdXJyZW50TGluZSA9IHNob3dDdXJyZW50TGluZTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGxpbmUgaGlnaGxpZ2h0aW5nIGluZGljYXRvcnMgZm9yIHRoZSBnaXZlbiBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBlZGl0b3IgdG8gY2xlYW51cC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhckhpZ2hsaWdodChlZGl0b3IpIHtcbiAgICAgICAgaWYgKCFlZGl0b3IgfHwgZWRpdG9yLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbUVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgY21FZGl0b3IuZG9jLmVhY2hMaW5lKGxpbmUgPT4ge1xuICAgICAgICAgICAgY21FZGl0b3IuZWRpdG9yLnJlbW92ZUxpbmVDbGFzcyhsaW5lLCAnd3JhcCcsIExJTkVfSElHSExJR0hUX0NMQVNTKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEVkaXRvckhhbmRsZXIuY2xlYXJIaWdobGlnaHQgPSBjbGVhckhpZ2hsaWdodDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgbGluZSBudW1iZXJzIGFuZCBhbGwgZ3V0dGVycyBmcm9tIGVkaXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3IgVGhlIGVkaXRvciB0byBjbGVhbnVwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyR3V0dGVyKGVkaXRvcikge1xuICAgICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNtRWRpdG9yID0gZWRpdG9yO1xuICAgICAgICBjbUVkaXRvci5kb2MuZWFjaExpbmUobGluZSA9PiB7XG4gICAgICAgICAgICBpZiAobGluZS5ndXR0ZXJNYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgY21FZGl0b3IuZWRpdG9yLnNldEd1dHRlck1hcmtlcihsaW5lLCAnYnJlYWtwb2ludHMnLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEVkaXRvckhhbmRsZXIuY2xlYXJHdXR0ZXIgPSBjbGVhckd1dHRlcjtcbn0pKEVkaXRvckhhbmRsZXIgfHwgKEVkaXRvckhhbmRsZXIgPSB7fSkpO1xuLyoqXG4gKiBBIG5hbWVzcGFjZSBmb3IgbW9kdWxlIHByaXZhdGUgZGF0YS5cbiAqL1xudmFyIFByaXZhdGU7XG4oZnVuY3Rpb24gKFByaXZhdGUpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtYXJrZXIgRE9NIGVsZW1lbnQgZm9yIGEgYnJlYWtwb2ludC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXJrZXJOb2RlKCkge1xuICAgICAgICBjb25zdCBtYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWFya2VyLmNsYXNzTmFtZSA9ICdqcC1EZWJ1Z2dlckVkaXRvci1tYXJrZXInO1xuICAgICAgICBtYXJrZXIuaW5uZXJIVE1MID0gJ+KXjyc7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlTWFya2VyTm9kZSA9IGNyZWF0ZU1hcmtlck5vZGU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGJyZWFrcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbiBUaGUgbmFtZSBvZiB0aGUgc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgbGluZSBudW1iZXIgb2YgdGhlIGJyZWFrcG9pbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQnJlYWtwb2ludChzZXNzaW9uLCBsaW5lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgdmVyaWZpZWQ6IHRydWUsXG4gICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzZXNzaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlQnJlYWtwb2ludCA9IGNyZWF0ZUJyZWFrcG9pbnQ7XG59KShQcml2YXRlIHx8IChQcml2YXRlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkaXRvci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG5pbXBvcnQgeyBFZGl0b3JIYW5kbGVyIH0gZnJvbSAnLi4vaGFuZGxlcnMvZWRpdG9yJztcbi8qKlxuICogQSBoYW5kbGVyIGZvciBmaWxlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBGaWxlSGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbnN0YW50aWF0aW9uIG9wdGlvbnMgZm9yIGEgRmlsZUhhbmRsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9kZWJ1Z2dlclNlcnZpY2UgPSBvcHRpb25zLmRlYnVnZ2VyU2VydmljZTtcbiAgICAgICAgdGhpcy5fZmlsZUVkaXRvciA9IG9wdGlvbnMud2lkZ2V0LmNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2hhc0xpbmVOdW1iZXIgPSB0aGlzLl9maWxlRWRpdG9yLmVkaXRvci5nZXRPcHRpb24oJ2xpbmVOdW1iZXJzJyk7XG4gICAgICAgIHRoaXMuX2VkaXRvckhhbmRsZXIgPSBuZXcgRWRpdG9ySGFuZGxlcih7XG4gICAgICAgICAgICBkZWJ1Z2dlclNlcnZpY2U6IHRoaXMuX2RlYnVnZ2VyU2VydmljZSxcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5fZmlsZUVkaXRvci5lZGl0b3JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgdGhlIGhhbmRsZXIuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIChfYSA9IHRoaXMuX2VkaXRvckhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgICAgIC8vIFJlc3RvcmUgZWRpdG9yIG9wdGlvbnNcbiAgICAgICAgKF9iID0gdGhpcy5fZWRpdG9ySGFuZGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVkaXRvci5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0aGlzLl9oYXNMaW5lTnVtYmVyXG4gICAgICAgIH0pO1xuICAgICAgICBTaWduYWwuY2xlYXJEYXRhKHRoaXMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgT2JzZXJ2YWJsZU1hcCB9IGZyb20gJ0BqdXB5dGVybGFiL29ic2VydmFibGVzJztcbmltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ0BsdW1pbm8vc2lnbmFsaW5nJztcbmltcG9ydCB7IEVkaXRvckhhbmRsZXIgfSBmcm9tICcuL2VkaXRvcic7XG4vKipcbiAqIEEgaGFuZGxlciBmb3Igbm90ZWJvb2tzLlxuICovXG5leHBvcnQgY2xhc3MgTm90ZWJvb2tIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBOb3RlYm9va0hhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciBhIE5vdGVib29rSGFuZGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fZGVidWdnZXJTZXJ2aWNlID0gb3B0aW9ucy5kZWJ1Z2dlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuX25vdGVib29rUGFuZWwgPSBvcHRpb25zLndpZGdldDtcbiAgICAgICAgdGhpcy5fY2VsbE1hcCA9IG5ldyBPYnNlcnZhYmxlTWFwKCk7XG4gICAgICAgIGNvbnN0IG5vdGVib29rID0gdGhpcy5fbm90ZWJvb2tQYW5lbC5jb250ZW50O1xuICAgICAgICBub3RlYm9vay5hY3RpdmVDZWxsQ2hhbmdlZC5jb25uZWN0KHRoaXMuX29uQWN0aXZlQ2VsbENoYW5nZWQsIHRoaXMpO1xuICAgICAgICAoX2EgPSBub3RlYm9vay5tb2RlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNlbGxzLmNoYW5nZWQuY29ubmVjdCh0aGlzLl9vbkNlbGxzQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX29uQ2VsbHNDaGFuZ2VkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgdGhlIGhhbmRsZXIuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NlbGxNYXAudmFsdWVzKCkuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRvIHJlc3RvcmUgbm90ZWJvb2sgZWRpdG9yIHNldHRpbmdzXG4gICAgICAgICAgICBoYW5kbGVyLmVkaXRvci5zZXRPcHRpb25zKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX25vdGVib29rUGFuZWwuY29udGVudC5lZGl0b3JDb25maWcuY29kZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY2VsbE1hcC5kaXNwb3NlKCk7XG4gICAgICAgIFNpZ25hbC5jbGVhckRhdGEodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIG5vdGVib29rIGNlbGxzIGNoYW5nZWQgZXZlbnQuXG4gICAgICovXG4gICAgX29uQ2VsbHNDaGFuZ2VkKGNlbGxzLCBjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fbm90ZWJvb2tQYW5lbC5jb250ZW50LndpZGdldHMuZm9yRWFjaChjZWxsID0+IHRoaXMuX2FkZEVkaXRvckhhbmRsZXIoY2VsbCkpO1xuICAgICAgICBpZiAoKGNoYW5nZXMgPT09IG51bGwgfHwgY2hhbmdlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbmdlcy50eXBlKSA9PT0gJ21vdmUnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgY2hhbmdlcy5uZXdWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl9jZWxsTWFwLmdldChjZWxsLmlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZnJlc2hCcmVha3BvaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBlZGl0b3IgaGFuZGxlciBmb3IgdGhlIGdpdmVuIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2VsbCBUaGUgY2VsbCB0byBhZGQgdGhlIGhhbmRsZXIgdG8uXG4gICAgICovXG4gICAgX2FkZEVkaXRvckhhbmRsZXIoY2VsbCkge1xuICAgICAgICBjb25zdCBtb2RlbElkID0gY2VsbC5tb2RlbC5pZDtcbiAgICAgICAgaWYgKGNlbGwubW9kZWwudHlwZSAhPT0gJ2NvZGUnIHx8IHRoaXMuX2NlbGxNYXAuaGFzKG1vZGVsSWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZUNlbGwgPSBjZWxsO1xuICAgICAgICBjb25zdCBlZGl0b3JIYW5kbGVyID0gbmV3IEVkaXRvckhhbmRsZXIoe1xuICAgICAgICAgICAgZGVidWdnZXJTZXJ2aWNlOiB0aGlzLl9kZWJ1Z2dlclNlcnZpY2UsXG4gICAgICAgICAgICBlZGl0b3I6IGNvZGVDZWxsLmVkaXRvclxuICAgICAgICB9KTtcbiAgICAgICAgY29kZUNlbGwuZGlzcG9zZWQuY29ubmVjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jZWxsTWFwLmRlbGV0ZShtb2RlbElkKTtcbiAgICAgICAgICAgIGVkaXRvckhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY2VsbE1hcC5zZXQoY2VsbC5tb2RlbC5pZCwgZWRpdG9ySGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIG5ldyBhY3RpdmUgY2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub3RlYm9vayBUaGUgbm90ZWJvb2sgZm9yIHdoaWNoIHRoZSBhY3RpdmUgY2VsbCBoYXMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0gY2VsbCBUaGUgbmV3IGFjdGl2ZSBjZWxsLlxuICAgICAqL1xuICAgIF9vbkFjdGl2ZUNlbGxDaGFuZ2VkKG5vdGVib29rLCBjZWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl9ub3RlYm9va1BhbmVsLmNvbnRlbnQgIT09IG5vdGVib29rKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkRWRpdG9ySGFuZGxlcihjZWxsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3RlYm9vay5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4vLyBNb3N0IG9mIHRoZSBpbXBsZW1lbnRhdGlvbiBiZWxvdyBpcyBhZGFwdGVkIGZyb20gdGhlIGZvbGxvd2luZyByZXBvc2l0b3J5OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dhcnljb3VydC9tdXJtdXJoYXNoLWpzL2Jsb2IvbWFzdGVyL211cm11cmhhc2gyX2djLmpzXG4vLyBXaGljaCBoYXMgdGhlIGZvbGxvd2luZyBNSVQgTGljZW5zZTpcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTEgR2FyeSBDb3VydFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuLy8gdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbi8vIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcbi8vICBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIFRoZSBpbXBsZW1lbnRhdGlvbiBiZWxvdyB1c2VzIGNhc2UgZmFsbHRocm91Z2ggYXMgcGFydCBvZiB0aGUgYWxnb3JpdGhtLlxuLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2ggKi9cbmNvbnN0IG0gPSAweDViZDFlOTk1O1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG11cm11cmhhc2gyIGZvciBhIGdpdmVuIHN0cmluZyBhbmQgc2VlZC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgdG8gY2FsY3VsYXRlIHRoZSBNdXJtdXIyIGhhc2ggZm9yLlxuICogQHBhcmFtIHNlZWQgVGhlIHNlZWQuXG4gKlxuICogQHJldHVybnMgVGhlIE11cm11cmhhc2gyIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdXJtdXIyKHN0ciwgc2VlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShzdHIpO1xuICAgIGxldCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgaCA9IHNlZWQgXiBsZW47XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChsZW4gPj0gNCkge1xuICAgICAgICBsZXQgayA9IChkYXRhW2ldICYgMHhmZikgfFxuICAgICAgICAgICAgKChkYXRhWysraV0gJiAweGZmKSA8PCA4KSB8XG4gICAgICAgICAgICAoKGRhdGFbKytpXSAmIDB4ZmYpIDw8IDE2KSB8XG4gICAgICAgICAgICAoKGRhdGFbKytpXSAmIDB4ZmYpIDw8IDI0KTtcbiAgICAgICAgayA9IChrICYgMHhmZmZmKSAqIG0gKyAoKCgoayA+Pj4gMTYpICogbSkgJiAweGZmZmYpIDw8IDE2KTtcbiAgICAgICAgayBePSBrID4+PiAyNDtcbiAgICAgICAgayA9IChrICYgMHhmZmZmKSAqIG0gKyAoKCgoayA+Pj4gMTYpICogbSkgJiAweGZmZmYpIDw8IDE2KTtcbiAgICAgICAgaCA9ICgoaCAmIDB4ZmZmZikgKiBtICsgKCgoKGggPj4+IDE2KSAqIG0pICYgMHhmZmZmKSA8PCAxNikpIF4gaztcbiAgICAgICAgbGVuIC09IDQ7XG4gICAgICAgICsraTtcbiAgICB9XG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaCBePSAoZGF0YVtpICsgMl0gJiAweGZmKSA8PCAxNjtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaCBePSAoZGF0YVtpICsgMV0gJiAweGZmKSA8PCA4O1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBoIF49IGRhdGFbaV0gJiAweGZmO1xuICAgICAgICAgICAgaCA9IChoICYgMHhmZmZmKSAqIG0gKyAoKCgoaCA+Pj4gMTYpICogbSkgJiAweGZmZmYpIDw8IDE2KTtcbiAgICB9XG4gICAgaCBePSBoID4+PiAxMztcbiAgICBoID0gKGggJiAweGZmZmYpICogbSArICgoKChoID4+PiAxNikgKiBtKSAmIDB4ZmZmZikgPDwgMTYpO1xuICAgIGggXj0gaCA+Pj4gMTU7XG4gICAgcmV0dXJuIGggPj4+IDA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IExhYkljb24gfSBmcm9tICdAanVweXRlcmxhYi91aS1jb21wb25lbnRzJztcbmltcG9ydCBjbG9zZUFsbFN2Z1N0ciBmcm9tICcuLi9zdHlsZS9pY29ucy9jbG9zZS1hbGwuc3ZnJztcbmltcG9ydCBzdGVwSW50b1N2Z1N0ciBmcm9tICcuLi9zdHlsZS9pY29ucy9zdGVwLWludG8uc3ZnJztcbmltcG9ydCBzdGVwT3V0U3ZnU3RyIGZyb20gJy4uL3N0eWxlL2ljb25zL3N0ZXAtb3V0LnN2Zyc7XG5pbXBvcnQgc3RlcE92ZXJTdmdTdHIgZnJvbSAnLi4vc3R5bGUvaWNvbnMvc3RlcC1vdmVyLnN2Zyc7XG5pbXBvcnQgdmFyaWFibGVTdmdTdHIgZnJvbSAnLi4vc3R5bGUvaWNvbnMvdmFyaWFibGUuc3ZnJztcbmltcG9ydCBwYXVzZVN2Z1N0ciBmcm9tICcuLi9zdHlsZS9pY29ucy9wYXVzZS5zdmcnO1xuaW1wb3J0IHZpZXdCcmVha3BvaW50U3ZnU3RyIGZyb20gJy4uL3N0eWxlL2ljb25zL3ZpZXctYnJlYWtwb2ludC5zdmcnO1xuaW1wb3J0IG9wZW5LZXJuZWxTb3VyY2VTdmdTdHIgZnJvbSAnLi4vc3R5bGUvaWNvbnMvb3Blbi1rZXJuZWwtc291cmNlLnN2Zyc7XG5leHBvcnQgeyBydW5JY29uIGFzIGNvbnRpbnVlSWNvbiwgc3RvcEljb24gYXMgdGVybWluYXRlSWNvbiB9IGZyb20gJ0BqdXB5dGVybGFiL3VpLWNvbXBvbmVudHMnO1xuZXhwb3J0IGNvbnN0IGNsb3NlQWxsSWNvbiA9IG5ldyBMYWJJY29uKHtcbiAgICBuYW1lOiAnZGVidWdnZXI6Y2xvc2UtYWxsJyxcbiAgICBzdmdzdHI6IGNsb3NlQWxsU3ZnU3RyXG59KTtcbmV4cG9ydCBjb25zdCBwYXVzZU9uRXhjZXB0aW9uc0ljb24gPSBuZXcgTGFiSWNvbih7XG4gICAgbmFtZTogJ2RlYnVnZ2VyOnBhdXNlJyxcbiAgICBzdmdzdHI6IHBhdXNlU3ZnU3RyXG59KTtcbmV4cG9ydCBjb25zdCBzdGVwSW50b0ljb24gPSBuZXcgTGFiSWNvbih7XG4gICAgbmFtZTogJ2RlYnVnZ2VyOnN0ZXAtaW50bycsXG4gICAgc3Znc3RyOiBzdGVwSW50b1N2Z1N0clxufSk7XG5leHBvcnQgY29uc3Qgc3RlcE92ZXJJY29uID0gbmV3IExhYkljb24oe1xuICAgIG5hbWU6ICdkZWJ1Z2dlcjpzdGVwLW92ZXInLFxuICAgIHN2Z3N0cjogc3RlcE92ZXJTdmdTdHJcbn0pO1xuZXhwb3J0IGNvbnN0IHN0ZXBPdXRJY29uID0gbmV3IExhYkljb24oe1xuICAgIG5hbWU6ICdkZWJ1Z2dlcjpzdGVwLW91dCcsXG4gICAgc3Znc3RyOiBzdGVwT3V0U3ZnU3RyXG59KTtcbmV4cG9ydCBjb25zdCB2YXJpYWJsZUljb24gPSBuZXcgTGFiSWNvbih7XG4gICAgbmFtZTogJ2RlYnVnZ2VyOnZhcmlhYmxlJyxcbiAgICBzdmdzdHI6IHZhcmlhYmxlU3ZnU3RyXG59KTtcbmV4cG9ydCBjb25zdCB2aWV3QnJlYWtwb2ludEljb24gPSBuZXcgTGFiSWNvbih7XG4gICAgbmFtZTogJ2RlYnVnZ2VyOnZpZXctYnJlYWtwb2ludCcsXG4gICAgc3Znc3RyOiB2aWV3QnJlYWtwb2ludFN2Z1N0clxufSk7XG5leHBvcnQgY29uc3Qgb3Blbktlcm5lbFNvdXJjZUljb24gPSBuZXcgTGFiSWNvbih7XG4gICAgbmFtZTogJ2RlYnVnZ2VyOm9wZW4ta2VybmVsLXNvdXJjZScsXG4gICAgc3Znc3RyOiBvcGVuS2VybmVsU291cmNlU3ZnU3RyXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljb25zLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIGRlYnVnZ2VyXG4gKi9cbmV4cG9ydCB7IERlYnVnZ2VyIH0gZnJvbSAnLi9kZWJ1Z2dlcic7XG5leHBvcnQgeyBJRGVidWdnZXIsIElEZWJ1Z2dlckNvbmZpZywgSURlYnVnZ2VyU291cmNlcywgSURlYnVnZ2VyU2lkZWJhciwgSURlYnVnZ2VySGFuZGxlciB9IGZyb20gJy4vdG9rZW5zJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ0BsdW1pbm8vc2lnbmFsaW5nJztcbmltcG9ydCB7IEJyZWFrcG9pbnRzTW9kZWwgfSBmcm9tICcuL3BhbmVscy9icmVha3BvaW50cy9tb2RlbCc7XG5pbXBvcnQgeyBDYWxsc3RhY2tNb2RlbCB9IGZyb20gJy4vcGFuZWxzL2NhbGxzdGFjay9tb2RlbCc7XG5pbXBvcnQgeyBTb3VyY2VzTW9kZWwgfSBmcm9tICcuL3BhbmVscy9zb3VyY2VzL21vZGVsJztcbmltcG9ydCB7IEtlcm5lbFNvdXJjZXNNb2RlbCB9IGZyb20gJy4vcGFuZWxzL2tlcm5lbFNvdXJjZXMvbW9kZWwnO1xuaW1wb3J0IHsgVmFyaWFibGVzTW9kZWwgfSBmcm9tICcuL3BhbmVscy92YXJpYWJsZXMvbW9kZWwnO1xuLyoqXG4gKiBBIG1vZGVsIGZvciBhIGRlYnVnZ2VyLlxuICovXG5leHBvcnQgY2xhc3MgRGVidWdnZXJNb2RlbCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgRGVidWdnZXJNb2RlbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFzUmljaFZhcmlhYmxlUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0b3BwZWRUaHJlYWRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl90aXRsZSA9ICctJztcbiAgICAgICAgdGhpcy5fdGl0bGVDaGFuZ2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5icmVha3BvaW50cyA9IG5ldyBCcmVha3BvaW50c01vZGVsKCk7XG4gICAgICAgIHRoaXMuY2FsbHN0YWNrID0gbmV3IENhbGxzdGFja01vZGVsKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gbmV3IFZhcmlhYmxlc01vZGVsKCk7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IG5ldyBTb3VyY2VzTW9kZWwoe1xuICAgICAgICAgICAgY3VycmVudEZyYW1lQ2hhbmdlZDogdGhpcy5jYWxsc3RhY2suY3VycmVudEZyYW1lQ2hhbmdlZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5rZXJuZWxTb3VyY2VzID0gbmV3IEtlcm5lbFNvdXJjZXNNb2RlbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGRlYnVnZ2VyIHdpZGdldCBpcyBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgZGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUga2VybmVsIHN1cHBvcnQgcmljaCB2YXJpYWJsZSByZW5kZXJpbmcgYmFzZWQgb24gbWltZSB0eXBlLlxuICAgICAqL1xuICAgIGdldCBoYXNSaWNoVmFyaWFibGVSZW5kZXJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNSaWNoVmFyaWFibGVSZW5kZXJpbmc7XG4gICAgfVxuICAgIHNldCBoYXNSaWNoVmFyaWFibGVSZW5kZXJpbmcodikge1xuICAgICAgICB0aGlzLl9oYXNSaWNoVmFyaWFibGVSZW5kZXJpbmcgPSB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgb2YgdGhyZWFkcyBpbiBzdG9wcGVkIHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBzdG9wcGVkVGhyZWFkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWRUaHJlYWRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIHRoZSBwYXJhbWV0ZXJzIHRvIHRoZSBzZXQgb2YgdGhyZWFkcyBpbiBzdG9wcGVkIHN0YXRlLlxuICAgICAqL1xuICAgIHNldCBzdG9wcGVkVGhyZWFkcyh0aHJlYWRzKSB7XG4gICAgICAgIHRoaXMuX3N0b3BwZWRUaHJlYWRzID0gdGhyZWFkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZGVidWdnZXIgdGl0bGUuXG4gICAgICovXG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGl0bGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBkZWJ1Z2dlciB0aXRsZS5cbiAgICAgKi9cbiAgICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICAgICAgaWYgKHRpdGxlID09PSB0aGlzLl90aXRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RpdGxlID0gdGl0bGUgIT09IG51bGwgJiYgdGl0bGUgIT09IHZvaWQgMCA/IHRpdGxlIDogJy0nO1xuICAgICAgICB0aGlzLl90aXRsZUNoYW5nZWQuZW1pdCh0aXRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgdGl0bGUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXQgdGl0bGVDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGl0bGVDaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kaXNwb3NlZC5lbWl0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fc3RvcHBlZFRocmVhZHMuY2xlYXIoKTtcbiAgICAgICAgY29uc3QgYnJlYWtwb2ludHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYnJlYWtwb2ludHMucmVzdG9yZUJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKTtcbiAgICAgICAgdGhpcy5jYWxsc3RhY2suZnJhbWVzID0gW107XG4gICAgICAgIHRoaXMudmFyaWFibGVzLnNjb3BlcyA9IFtdO1xuICAgICAgICB0aGlzLnNvdXJjZXMuY3VycmVudFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMua2VybmVsU291cmNlcy5rZXJuZWxTb3VyY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy50aXRsZSA9ICctJztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5pbXBvcnQgeyBSZWFjdFdpZGdldCB9IGZyb20gJ0BqdXB5dGVybGFiL2FwcHV0aWxzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBUaGUgYm9keSBmb3IgYSBCcmVha3BvaW50cyBQYW5lbC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJyZWFrcG9pbnRzQm9keSBleHRlbmRzIFJlYWN0V2lkZ2V0IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBCb2R5IGZvciB0aGUgQnJlYWtwb2ludHMgUGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgVGhlIG1vZGVsIGZvciB0aGUgYnJlYWtwb2ludHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygnanAtRGVidWdnZXJCcmVha3BvaW50cy1ib2R5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgQnJlYWtwb2ludHNDb21wb25lbnQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCcmVha3BvaW50c0NvbXBvbmVudCwgeyBtb2RlbDogdGhpcy5fbW9kZWwgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0byBkaXNwbGF5IGEgbGlzdCBvZiBicmVha3BvaW50cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGNvbXBvbmVudCBwcm9wcy5cbiAqIEBwYXJhbSBwcm9wcy5tb2RlbCBUaGUgbW9kZWwgZm9yIHRoZSBicmVha3BvaW50cy5cbiAqL1xuY29uc3QgQnJlYWtwb2ludHNDb21wb25lbnQgPSAoeyBtb2RlbCB9KSA9PiB7XG4gICAgY29uc3QgW2JyZWFrcG9pbnRzLCBzZXRCcmVha3BvaW50c10gPSB1c2VTdGF0ZShBcnJheS5mcm9tKG1vZGVsLmJyZWFrcG9pbnRzLmVudHJpZXMoKSkpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUJyZWFrcG9pbnRzID0gKF8sIHVwZGF0ZXMpID0+IHtcbiAgICAgICAgICAgIHNldEJyZWFrcG9pbnRzKEFycmF5LmZyb20obW9kZWwuYnJlYWtwb2ludHMuZW50cmllcygpKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3RvcmVCcmVha3BvaW50cyA9IChfKSA9PiB7XG4gICAgICAgICAgICBzZXRCcmVha3BvaW50cyhBcnJheS5mcm9tKG1vZGVsLmJyZWFrcG9pbnRzLmVudHJpZXMoKSkpO1xuICAgICAgICB9O1xuICAgICAgICBtb2RlbC5jaGFuZ2VkLmNvbm5lY3QodXBkYXRlQnJlYWtwb2ludHMpO1xuICAgICAgICBtb2RlbC5yZXN0b3JlZC5jb25uZWN0KHJlc3RvcmVCcmVha3BvaW50cyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBtb2RlbC5jaGFuZ2VkLmRpc2Nvbm5lY3QodXBkYXRlQnJlYWtwb2ludHMpO1xuICAgICAgICAgICAgbW9kZWwucmVzdG9yZWQuZGlzY29ubmVjdChyZXN0b3JlQnJlYWtwb2ludHMpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgYnJlYWtwb2ludHMubWFwKGVudHJ5ID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KEJyZWFrcG9pbnRDZWxsQ29tcG9uZW50LCB7IGtleTogZW50cnlbMF0sIGJyZWFrcG9pbnRzOiBlbnRyeVsxXSwgbW9kZWw6IG1vZGVsIH0pKSkpKTtcbn07XG4vKipcbiAqIEEgUmVhY3QgQ29tcG9uZW50IHRvIGRpc3BsYXkgYnJlYWtwb2ludHMgZ3JvdXBlZCBieSBzb3VyY2UgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGNvbXBvbmVudCBwcm9wcy5cbiAqIEBwYXJhbSBwcm9wcy5icmVha3BvaW50cyBUaGUgbGlzdCBvZiBicmVha3BvaW50cy5cbiAqIEBwYXJhbSBwcm9wcy5tb2RlbCBUaGUgbW9kZWwgZm9yIHRoZSBicmVha3BvaW50cy5cbiAqL1xuY29uc3QgQnJlYWtwb2ludENlbGxDb21wb25lbnQgPSAoeyBicmVha3BvaW50cywgbW9kZWwgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgYnJlYWtwb2ludHNcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBhLmxpbmUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIC0gKChfYiA9IGIubGluZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCk7XG4gICAgfSlcbiAgICAgICAgLm1hcCgoYnJlYWtwb2ludCwgaW5kZXgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJyZWFrcG9pbnRDb21wb25lbnQsIHsga2V5OiAoKF9iID0gKF9hID0gYnJlYWtwb2ludC5zb3VyY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJykgKyBpbmRleCwgYnJlYWtwb2ludDogYnJlYWtwb2ludCwgbW9kZWw6IG1vZGVsIH0pKTtcbiAgICB9KSkpO1xufTtcbi8qKlxuICogQSBSZWFjdCBDb21wb25lbnQgdG8gZGlzcGxheSBhIHNpbmdsZSBicmVha3BvaW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBUaGUgY29tcG9uZW50IHByb3BzLlxuICogQHBhcmFtIHByb3BzLmJyZWFrcG9pbnQgVGhlIGJyZWFrcG9pbnQuXG4gKiBAcGFyYW0gcHJvcHMubW9kZWwgVGhlIG1vZGVsIGZvciB0aGUgYnJlYWtwb2ludHMuXG4gKi9cbmNvbnN0IEJyZWFrcG9pbnRDb21wb25lbnQgPSAoeyBicmVha3BvaW50LCBtb2RlbCB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgbW92ZVRvRW5kRmlyc3RDaGFySWZTbGFzaCA9IChicmVha3BvaW50U291cmNlUGF0aCkgPT4ge1xuICAgICAgICByZXR1cm4gYnJlYWtwb2ludFNvdXJjZVBhdGhbMF0gPT09ICcvJ1xuICAgICAgICAgICAgPyBicmVha3BvaW50U291cmNlUGF0aC5zbGljZSgxKSArICcvJ1xuICAgICAgICAgICAgOiBicmVha3BvaW50U291cmNlUGF0aDtcbiAgICB9O1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2pwLURlYnVnZ2VyQnJlYWtwb2ludCcsIG9uQ2xpY2s6ICgpID0+IG1vZGVsLmNsaWNrZWQuZW1pdChicmVha3BvaW50KSwgdGl0bGU6IChfYSA9IGJyZWFrcG9pbnQuc291cmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogJ2pwLURlYnVnZ2VyQnJlYWtwb2ludC1tYXJrZXInIH0sIFwiXFx1MjVDRlwiKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6ICdqcC1EZWJ1Z2dlckJyZWFrcG9pbnQtc291cmNlIGpwLWxlZnQtdHJ1bmNhdGVkJyB9LCBtb3ZlVG9FbmRGaXJzdENoYXJJZlNsYXNoKChfYyA9IChfYiA9IGJyZWFrcG9pbnQuc291cmNlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGF0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJycpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6ICdqcC1EZWJ1Z2dlckJyZWFrcG9pbnQtbGluZScgfSwgYnJlYWtwb2ludC5saW5lKSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvZHkuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgVG9vbGJhciB9IGZyb20gJ0BqdXB5dGVybGFiL2FwcHV0aWxzJztcbmltcG9ydCB7IG51bGxUcmFuc2xhdG9yIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdHJhbnNsYXRpb24nO1xuaW1wb3J0IHsgUGFuZWxMYXlvdXQsIFdpZGdldCB9IGZyb20gJ0BsdW1pbm8vd2lkZ2V0cyc7XG4vKipcbiAqIFRoZSBoZWFkZXIgZm9yIGEgQnJlYWtwb2ludHMgUGFuZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBCcmVha3BvaW50c0hlYWRlciBleHRlbmRzIFdpZGdldCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgQnJlYWtwb2ludHNIZWFkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHJhbnNsYXRvcikge1xuICAgICAgICBzdXBlcih7IG5vZGU6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2xiYXIgZm9yIHRoZSBicmVha3BvaW50cyBoZWFkZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvb2xiYXIgPSBuZXcgVG9vbGJhcigpO1xuICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgnanAtc3RhY2stcGFuZWwtaGVhZGVyJyk7XG4gICAgICAgIHRyYW5zbGF0b3IgPSB0cmFuc2xhdG9yIHx8IG51bGxUcmFuc2xhdG9yO1xuICAgICAgICBjb25zdCB0cmFucyA9IHRyYW5zbGF0b3IubG9hZCgnanVweXRlcmxhYicpO1xuICAgICAgICBjb25zdCB0aXRsZSA9IG5ldyBXaWRnZXQoeyBub2RlOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpIH0pO1xuICAgICAgICB0aXRsZS5ub2RlLnRleHRDb250ZW50ID0gdHJhbnMuX18oJ0JyZWFrcG9pbnRzJyk7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IG5ldyBQYW5lbExheW91dCgpO1xuICAgICAgICBsYXlvdXQuYWRkV2lkZ2V0KHRpdGxlKTtcbiAgICAgICAgbGF5b3V0LmFkZFdpZGdldCh0aGlzLnRvb2xiYXIpO1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgQ29tbWFuZFRvb2xiYXJCdXR0b24sIERpYWxvZywgc2hvd0RpYWxvZywgVG9vbGJhckJ1dHRvbiB9IGZyb20gJ0BqdXB5dGVybGFiL2FwcHV0aWxzJztcbmltcG9ydCB7IG51bGxUcmFuc2xhdG9yIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdHJhbnNsYXRpb24nO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuaW1wb3J0IHsgUGFuZWwgfSBmcm9tICdAbHVtaW5vL3dpZGdldHMnO1xuaW1wb3J0IHsgY2xvc2VBbGxJY29uIH0gZnJvbSAnLi4vLi4vaWNvbnMnO1xuaW1wb3J0IHsgQnJlYWtwb2ludHNCb2R5IH0gZnJvbSAnLi9ib2R5JztcbmltcG9ydCB7IEJyZWFrcG9pbnRzSGVhZGVyIH0gZnJvbSAnLi9oZWFkZXInO1xuLyoqXG4gKiBBIFBhbmVsIHRvIHNob3cgYSBsaXN0IG9mIGJyZWFrcG9pbnRzLlxuICovXG5leHBvcnQgY2xhc3MgQnJlYWtwb2ludHMgZXh0ZW5kcyBQYW5lbCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgQnJlYWtwb2ludHMgUGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciBhIEJyZWFrcG9pbnRzIFBhbmVsLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jbGlja2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBtb2RlbCwgc2VydmljZSwgY29tbWFuZHMgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3IgfHwgbnVsbFRyYW5zbGF0b3I7XG4gICAgICAgIGNvbnN0IHRyYW5zID0gKChfYSA9IG9wdGlvbnMudHJhbnNsYXRvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbFRyYW5zbGF0b3IpLmxvYWQoJ2p1cHl0ZXJsYWInKTtcbiAgICAgICAgdGhpcy50aXRsZS5sYWJlbCA9IHRyYW5zLl9fKCdCcmVha3BvaW50cycpO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgQnJlYWtwb2ludHNIZWFkZXIodHJhbnNsYXRvcik7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBuZXcgQnJlYWtwb2ludHNCb2R5KG1vZGVsKTtcbiAgICAgICAgaGVhZGVyLnRvb2xiYXIuYWRkSXRlbSgncGF1c2UnLCBuZXcgQ29tbWFuZFRvb2xiYXJCdXR0b24oe1xuICAgICAgICAgICAgY29tbWFuZHM6IGNvbW1hbmRzLnJlZ2lzdHJ5LFxuICAgICAgICAgICAgaWQ6IGNvbW1hbmRzLnBhdXNlLFxuICAgICAgICAgICAgbGFiZWw6ICcnXG4gICAgICAgIH0pKTtcbiAgICAgICAgaGVhZGVyLnRvb2xiYXIuYWRkSXRlbSgnY2xvc2VBbGwnLCBuZXcgVG9vbGJhckJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBjbG9zZUFsbEljb24sXG4gICAgICAgICAgICBvbkNsaWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmJyZWFrcG9pbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzaG93RGlhbG9nKHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRyYW5zLl9fKCdSZW1vdmUgQWxsIEJyZWFrcG9pbnRzJyksXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHRyYW5zLl9fKCdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcmVtb3ZlIGFsbCBicmVha3BvaW50cz8nKSxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgRGlhbG9nLm9rQnV0dG9uKHsgbGFiZWw6IHRyYW5zLl9fKCdSZW1vdmUgYnJlYWtwb2ludHMnKSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIERpYWxvZy5jYW5jZWxCdXR0b24oeyBsYWJlbDogdHJhbnMuX18oJ0NhbmNlbCcpIH0pXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGhhc0Nsb3NlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5idXR0b24uYWNjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlLmNsZWFyQnJlYWtwb2ludHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHRpcDogdHJhbnMuX18oJ1JlbW92ZSBBbGwgQnJlYWtwb2ludHMnKVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KGhlYWRlcik7XG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KGJvZHkpO1xuICAgICAgICB0aGlzLmFkZENsYXNzKCdqcC1EZWJ1Z2dlckJyZWFrcG9pbnRzJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuLyoqXG4gKiBBIG1vZGVsIGZvciBhIGxpc3Qgb2YgYnJlYWtwb2ludHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCcmVha3BvaW50c01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fYnJlYWtwb2ludHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXN0b3JlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2NsaWNrZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBtb2RlbCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGdldCBjaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgYnJlYWtwb2ludHMgYXJlIHJlc3RvcmVkLlxuICAgICAqL1xuICAgIGdldCByZXN0b3JlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RvcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgZW1pdHRlZCB3aGVuIGEgYnJlYWtwb2ludCBpcyBjbGlja2VkLlxuICAgICAqL1xuICAgIGdldCBjbGlja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpY2tlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgYnJlYWtwb2ludHMuXG4gICAgICovXG4gICAgZ2V0IGJyZWFrcG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnJlYWtwb2ludHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYnJlYWtwb2ludHMgZm9yIGEgZ2l2ZW4gaWQgKHBhdGgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSBjb2RlIGlkIChwYXRoKS5cbiAgICAgKiBAcGFyYW0gYnJlYWtwb2ludHMgVGhlIGxpc3Qgb2YgYnJlYWtwb2ludHMuXG4gICAgICovXG4gICAgc2V0QnJlYWtwb2ludHMoaWQsIGJyZWFrcG9pbnRzKSB7XG4gICAgICAgIHRoaXMuX2JyZWFrcG9pbnRzLnNldChpZCwgYnJlYWtwb2ludHMpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQoYnJlYWtwb2ludHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJyZWFrcG9pbnRzIGZvciBhIGdpdmVuIGlkIChwYXRoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgY29kZSBpZCAocGF0aCkuXG4gICAgICovXG4gICAgZ2V0QnJlYWtwb2ludHMoaWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fYnJlYWtwb2ludHMuZ2V0KGlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgYSBtYXAgb2YgYnJlYWtwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJlYWtwb2ludHMgVGhlIG1hcCBvZiBicmVha3BvaW50c1xuICAgICAqL1xuICAgIHJlc3RvcmVCcmVha3BvaW50cyhicmVha3BvaW50cykge1xuICAgICAgICB0aGlzLl9icmVha3BvaW50cyA9IGJyZWFrcG9pbnRzO1xuICAgICAgICB0aGlzLl9yZXN0b3JlZC5lbWl0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgUmVhY3RXaWRnZXQgfSBmcm9tICdAanVweXRlcmxhYi9hcHB1dGlscyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFBhdGhFeHQgfSBmcm9tICdAanVweXRlcmxhYi9jb3JldXRpbHMnO1xuLyoqXG4gKiBUaGUgYm9keSBmb3IgYSBDYWxsc3RhY2sgUGFuZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsc3RhY2tCb2R5IGV4dGVuZHMgUmVhY3RXaWRnZXQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgbmV3IEJvZHkgZm9yIHRoZSBDYWxsc3RhY2sgUGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgVGhlIG1vZGVsIGZvciB0aGUgY2FsbHN0YWNrLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2pwLURlYnVnZ2VyQ2FsbHN0YWNrLWJvZHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBGcmFtZXNDb21wb25lbnQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChGcmFtZXNDb21wb25lbnQsIHsgbW9kZWw6IHRoaXMuX21vZGVsIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdG8gZGlzcGxheSBhIGxpc3Qgb2YgZnJhbWVzIGluIGEgY2FsbHN0YWNrLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBUaGUgY29tcG9uZW50IHByb3BzLlxuICogQHBhcmFtIHByb3BzLm1vZGVsIFRoZSBtb2RlbCBmb3IgdGhlIGNhbGxzdGFjay5cbiAqL1xuY29uc3QgRnJhbWVzQ29tcG9uZW50ID0gKHsgbW9kZWwgfSkgPT4ge1xuICAgIGNvbnN0IFtmcmFtZXMsIHNldEZyYW1lc10gPSB1c2VTdGF0ZShtb2RlbC5mcmFtZXMpO1xuICAgIGNvbnN0IFtzZWxlY3RlZCwgc2V0U2VsZWN0ZWRdID0gdXNlU3RhdGUobW9kZWwuZnJhbWUpO1xuICAgIGNvbnN0IG9uU2VsZWN0ZWQgPSAoZnJhbWUpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZnJhbWUpO1xuICAgICAgICBtb2RlbC5mcmFtZSA9IGZyYW1lO1xuICAgIH07XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlRnJhbWVzID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWQobW9kZWwuZnJhbWUpO1xuICAgICAgICAgICAgc2V0RnJhbWVzKG1vZGVsLmZyYW1lcyk7XG4gICAgICAgIH07XG4gICAgICAgIG1vZGVsLmZyYW1lc0NoYW5nZWQuY29ubmVjdCh1cGRhdGVGcmFtZXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbW9kZWwuZnJhbWVzQ2hhbmdlZC5kaXNjb25uZWN0KHVwZGF0ZUZyYW1lcyk7XG4gICAgICAgIH07XG4gICAgfSwgW21vZGVsXSk7XG4gICAgY29uc3QgdG9TaG9ydExvY2F0aW9uID0gKGVsKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcGF0aCA9ICgoX2EgPSBlbC5zb3VyY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSB8fCAnJztcbiAgICAgICAgY29uc3QgYmFzZSA9IFBhdGhFeHQuYmFzZW5hbWUoUGF0aEV4dC5kaXJuYW1lKHBhdGgpKTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBQYXRoRXh0LmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICBjb25zdCBzaG9ydG5hbWUgPSBQYXRoRXh0LmpvaW4oYmFzZSwgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gYCR7c2hvcnRuYW1lfToke2VsLmxpbmV9YDtcbiAgICB9O1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIG51bGwsIGZyYW1lcy5tYXAoZWxlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7IGtleTogZWxlLmlkLCBvbkNsaWNrOiAoKSA9PiBvblNlbGVjdGVkKGVsZSksIGNsYXNzTmFtZTogKHNlbGVjdGVkID09PSBudWxsIHx8IHNlbGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZC5pZCkgPT09IGVsZS5pZFxuICAgICAgICAgICAgICAgID8gJ3NlbGVjdGVkIGpwLURlYnVnZ2VyQ2FsbHN0YWNrRnJhbWUnXG4gICAgICAgICAgICAgICAgOiAnanAtRGVidWdnZXJDYWxsc3RhY2tGcmFtZScgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiAnanAtRGVidWdnZXJDYWxsc3RhY2tGcmFtZS1uYW1lJyB9LCBlbGUubmFtZSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogJ2pwLURlYnVnZ2VyQ2FsbHN0YWNrRnJhbWUtbG9jYXRpb24nLCB0aXRsZTogKF9hID0gZWxlLnNvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGggfSwgdG9TaG9ydExvY2F0aW9uKGVsZSkpKSk7XG4gICAgfSkpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib2R5LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IFRvb2xiYXIgfSBmcm9tICdAanVweXRlcmxhYi9hcHB1dGlscyc7XG5pbXBvcnQgeyBudWxsVHJhbnNsYXRvciB9IGZyb20gJ0BqdXB5dGVybGFiL3RyYW5zbGF0aW9uJztcbmltcG9ydCB7IFBhbmVsTGF5b3V0LCBXaWRnZXQgfSBmcm9tICdAbHVtaW5vL3dpZGdldHMnO1xuLyoqXG4gKiBUaGUgaGVhZGVyIGZvciBhIENhbGxzdGFjayBQYW5lbC5cbiAqL1xuZXhwb3J0IGNsYXNzIENhbGxzdGFja0hlYWRlciBleHRlbmRzIFdpZGdldCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgQ2FsbHN0YWNrSGVhZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zbGF0b3IpIHtcbiAgICAgICAgc3VwZXIoeyBub2RlOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b29sYmFyIGZvciB0aGUgY2FsbHN0YWNrIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9vbGJhciA9IG5ldyBUb29sYmFyKCk7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKCdqcC1zdGFjay1wYW5lbC1oZWFkZXInKTtcbiAgICAgICAgdHJhbnNsYXRvciA9IHRyYW5zbGF0b3IgfHwgbnVsbFRyYW5zbGF0b3I7XG4gICAgICAgIGNvbnN0IHRyYW5zID0gdHJhbnNsYXRvci5sb2FkKCdqdXB5dGVybGFiJyk7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gbmV3IFdpZGdldCh7IG5vZGU6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gyJykgfSk7XG4gICAgICAgIHRpdGxlLm5vZGUudGV4dENvbnRlbnQgPSB0cmFucy5fXygnQ2FsbHN0YWNrJyk7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IG5ldyBQYW5lbExheW91dCgpO1xuICAgICAgICBsYXlvdXQuYWRkV2lkZ2V0KHRpdGxlKTtcbiAgICAgICAgbGF5b3V0LmFkZFdpZGdldCh0aGlzLnRvb2xiYXIpO1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgQ29tbWFuZFRvb2xiYXJCdXR0b24gfSBmcm9tICdAanVweXRlcmxhYi9hcHB1dGlscyc7XG5pbXBvcnQgeyBudWxsVHJhbnNsYXRvciB9IGZyb20gJ0BqdXB5dGVybGFiL3RyYW5zbGF0aW9uJztcbmltcG9ydCB7IFBhbmVsIH0gZnJvbSAnQGx1bWluby93aWRnZXRzJztcbmltcG9ydCB7IENhbGxzdGFja0JvZHkgfSBmcm9tICcuL2JvZHknO1xuaW1wb3J0IHsgQ2FsbHN0YWNrSGVhZGVyIH0gZnJvbSAnLi9oZWFkZXInO1xuLyoqXG4gKiBBIFBhbmVsIHRvIHNob3cgYSBjYWxsc3RhY2suXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsc3RhY2sgZXh0ZW5kcyBQYW5lbCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgQ2FsbHN0YWNrIFBhbmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGluc3RhbnRpYXRpb24gb3B0aW9ucyBmb3IgYSBDYWxsc3RhY2sgUGFuZWwuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCB7IGNvbW1hbmRzLCBtb2RlbCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgdHJhbnNsYXRvciA9IG9wdGlvbnMudHJhbnNsYXRvciB8fCBudWxsVHJhbnNsYXRvcjtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IENhbGxzdGFja0hlYWRlcih0cmFuc2xhdG9yKTtcbiAgICAgICAgY29uc3QgYm9keSA9IG5ldyBDYWxsc3RhY2tCb2R5KG1vZGVsKTtcbiAgICAgICAgaGVhZGVyLnRvb2xiYXIuYWRkSXRlbSgnY29udGludWUnLCBuZXcgQ29tbWFuZFRvb2xiYXJCdXR0b24oe1xuICAgICAgICAgICAgY29tbWFuZHM6IGNvbW1hbmRzLnJlZ2lzdHJ5LFxuICAgICAgICAgICAgaWQ6IGNvbW1hbmRzLmNvbnRpbnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgaGVhZGVyLnRvb2xiYXIuYWRkSXRlbSgndGVybWluYXRlJywgbmV3IENvbW1hbmRUb29sYmFyQnV0dG9uKHtcbiAgICAgICAgICAgIGNvbW1hbmRzOiBjb21tYW5kcy5yZWdpc3RyeSxcbiAgICAgICAgICAgIGlkOiBjb21tYW5kcy50ZXJtaW5hdGVcbiAgICAgICAgfSkpO1xuICAgICAgICBoZWFkZXIudG9vbGJhci5hZGRJdGVtKCdzdGVwLW92ZXInLCBuZXcgQ29tbWFuZFRvb2xiYXJCdXR0b24oe1xuICAgICAgICAgICAgY29tbWFuZHM6IGNvbW1hbmRzLnJlZ2lzdHJ5LFxuICAgICAgICAgICAgaWQ6IGNvbW1hbmRzLm5leHRcbiAgICAgICAgfSkpO1xuICAgICAgICBoZWFkZXIudG9vbGJhci5hZGRJdGVtKCdzdGVwLWluJywgbmV3IENvbW1hbmRUb29sYmFyQnV0dG9uKHtcbiAgICAgICAgICAgIGNvbW1hbmRzOiBjb21tYW5kcy5yZWdpc3RyeSxcbiAgICAgICAgICAgIGlkOiBjb21tYW5kcy5zdGVwSW5cbiAgICAgICAgfSkpO1xuICAgICAgICBoZWFkZXIudG9vbGJhci5hZGRJdGVtKCdzdGVwLW91dCcsIG5ldyBDb21tYW5kVG9vbGJhckJ1dHRvbih7XG4gICAgICAgICAgICBjb21tYW5kczogY29tbWFuZHMucmVnaXN0cnksXG4gICAgICAgICAgICBpZDogY29tbWFuZHMuc3RlcE91dFxuICAgICAgICB9KSk7XG4gICAgICAgIGhlYWRlci50b29sYmFyLmFkZEl0ZW0oJ2V2YWx1YXRlJywgbmV3IENvbW1hbmRUb29sYmFyQnV0dG9uKHtcbiAgICAgICAgICAgIGNvbW1hbmRzOiBjb21tYW5kcy5yZWdpc3RyeSxcbiAgICAgICAgICAgIGlkOiBjb21tYW5kcy5ldmFsdWF0ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KGhlYWRlcik7XG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KGJvZHkpO1xuICAgICAgICB0aGlzLmFkZENsYXNzKCdqcC1EZWJ1Z2dlckNhbGxzdGFjaycpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ0BsdW1pbm8vc2lnbmFsaW5nJztcbi8qKlxuICogQSBtb2RlbCBmb3IgYSBjYWxsc3RhY2suXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsc3RhY2tNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gW107XG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZyYW1lc0NoYW5nZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWVDaGFuZ2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgZnJhbWVzLlxuICAgICAqL1xuICAgIGdldCBmcmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmcmFtZXMuXG4gICAgICovXG4gICAgc2V0IGZyYW1lcyhuZXdGcmFtZXMpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdGcmFtZXM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZUlkID0gdGhpcy5mcmFtZSAhPT0gbnVsbCA/IFByaXZhdGUuZ2V0RnJhbWVJZCh0aGlzLmZyYW1lKSA6ICcnO1xuICAgICAgICBjb25zdCBmcmFtZSA9IG5ld0ZyYW1lcy5maW5kKGZyYW1lID0+IFByaXZhdGUuZ2V0RnJhbWVJZChmcmFtZSkgPT09IGN1cnJlbnRGcmFtZUlkKTtcbiAgICAgICAgLy8gRGVmYXVsdCB0byB0aGUgZmlyc3QgZnJhbWUgaWYgdGhlIHByZXZpb3VzIG9uZSBjYW4ndCBiZSBmb3VuZC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGtlZXAgdGhlIGN1cnJlbnQgZnJhbWUgc2VsZWN0ZWQuXG4gICAgICAgIGlmICghZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUgPSBuZXdGcmFtZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnJhbWVzQ2hhbmdlZC5lbWl0KG5ld0ZyYW1lcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RnJhbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgKi9cbiAgICBzZXQgZnJhbWUoZnJhbWUpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lID0gZnJhbWU7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZUNoYW5nZWQuZW1pdChmcmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGZyYW1lcyBoYXZlIGNoYW5nZWQuXG4gICAgICovXG4gICAgZ2V0IGZyYW1lc0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZXNDaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBjdXJyZW50IGZyYW1lIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGdldCBjdXJyZW50RnJhbWVDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEZyYW1lQ2hhbmdlZDtcbiAgICB9XG59XG4vKipcbiAqIEEgbmFtZXNwYWNlIGZvciBwcml2YXRlIGRhdGEuXG4gKi9cbnZhciBQcml2YXRlO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIGlkIGZvciB0aGUgZ2l2ZW4gZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJhbWUgVGhlIGZyYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZyYW1lSWQoZnJhbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gYCR7KF9hID0gZnJhbWUgPT09IG51bGwgfHwgZnJhbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyYW1lLnNvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGh9LSR7ZnJhbWUgPT09IG51bGwgfHwgZnJhbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyYW1lLmlkfWA7XG4gICAgfVxuICAgIFByaXZhdGUuZ2V0RnJhbWVJZCA9IGdldEZyYW1lSWQ7XG59KShQcml2YXRlIHx8IChQcml2YXRlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IG9wZW5LZXJuZWxTb3VyY2VJY29uIH0gZnJvbSAnLi4vLi4vaWNvbnMnO1xuaW1wb3J0IHsgVG9vbGJhckJ1dHRvbiB9IGZyb20gJ0BqdXB5dGVybGFiL2FwcHV0aWxzJztcbmltcG9ydCB7IHNob3dFcnJvck1lc3NhZ2UgfSBmcm9tICdAanVweXRlcmxhYi9hcHB1dGlscyc7XG5pbXBvcnQgeyBudWxsVHJhbnNsYXRvciB9IGZyb20gJ0BqdXB5dGVybGFiL3RyYW5zbGF0aW9uJztcbmltcG9ydCB7IFBhbmVsTGF5b3V0LCBXaWRnZXQgfSBmcm9tICdAbHVtaW5vL3dpZGdldHMnO1xuaW1wb3J0IHsgS2VybmVsU291cmNlc0ZpbHRlciB9IGZyb20gJy4vZmlsdGVyJztcbi8qKlxuICogVGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGZpbHRlcmJveCBub2RlLlxuICovXG5jb25zdCBGSUxURVJCT1hfQ0xBU1MgPSAnanAtRGVidWdnZXJLZXJuZWxTb3VyY2UtZmlsdGVyQm94Jztcbi8qKlxuICogVGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gaGlkZSB0aGUgZmlsdGVyYm94IG5vZGUuXG4gKi9cbmNvbnN0IEZJTFRFUkJPWF9ISURERU5fQ0xBU1MgPSAnanAtRGVidWdnZXJLZXJuZWxTb3VyY2UtZmlsdGVyQm94LWhpZGRlbic7XG4vKipcbiAqIFRoZSBib2R5IGZvciBhIFNvdXJjZXMgUGFuZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBLZXJuZWxTb3VyY2VzQm9keSBleHRlbmRzIFdpZGdldCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgQm9keSBmb3IgdGhlIEtlcm5lbFNvdXJjZXNCb2R5IHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbnN0YW50aWF0aW9uIG9wdGlvbnMgZm9yIGEgS2VybmVsU291cmNlc0JvZHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX21vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICAgICAgdGhpcy5fZGVidWdnZXJTZXJ2aWNlID0gb3B0aW9ucy5zZXJ2aWNlO1xuICAgICAgICBjb25zdCB0cmFucyA9ICgoX2EgPSBvcHRpb25zLnRyYW5zbGF0b3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGxUcmFuc2xhdG9yKS5sb2FkKCdqdXB5dGVybGFiJyk7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gbmV3IFBhbmVsTGF5b3V0KCk7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2pwLURlYnVnZ2VyS2VybmVsU291cmNlcy1ib2R5Jyk7XG4gICAgICAgIHRoaXMuX2tlcm5lbFNvdXJjZXNGaWx0ZXIgPSBLZXJuZWxTb3VyY2VzRmlsdGVyKHtcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLl9tb2RlbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fa2VybmVsU291cmNlc0ZpbHRlci5hZGRDbGFzcyhGSUxURVJCT1hfQ0xBU1MpO1xuICAgICAgICB0aGlzLl9rZXJuZWxTb3VyY2VzRmlsdGVyLmFkZENsYXNzKEZJTFRFUkJPWF9ISURERU5fQ0xBU1MpO1xuICAgICAgICB0aGlzLmxheW91dC5hZGRXaWRnZXQodGhpcy5fa2VybmVsU291cmNlc0ZpbHRlcik7XG4gICAgICAgIHRoaXMuX21vZGVsLmNoYW5nZWQuY29ubmVjdCgoXywga2VybmVsU291cmNlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICAgICAgICAgIGlmIChrZXJuZWxTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAga2VybmVsU291cmNlcy5mb3JFYWNoKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBtb2R1bGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IG1vZHVsZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidXR0b24gPSBuZXcgVG9vbGJhckJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBvcGVuS2VybmVsU291cmNlSWNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogcGF0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1Z2dlclNlcnZpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0U291cmNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VSZWZlcmVuY2U6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihzb3VyY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZGVsLm9wZW4oc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCBzaG93RXJyb3JNZXNzYWdlKHRyYW5zLl9fKCdGYWlsIHRvIGdldCBzb3VyY2UnKSwgdHJhbnMuX18oXCJGYWlsIHRvIGdldCAnJTEnIHNvdXJjZTpcXG4lMlwiLCBwYXRoLCByZWFzb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuYWRkV2lkZ2V0KGJ1dHRvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IG9yIGhpZGUgdGhlIGZpbHRlciBib3guXG4gICAgICovXG4gICAgdG9nZ2xlRmlsdGVyYm94KCkge1xuICAgICAgICB0aGlzLl9rZXJuZWxTb3VyY2VzRmlsdGVyLm5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKEZJTFRFUkJPWF9ISURERU5fQ0xBU1MpXG4gICAgICAgICAgICA/IHRoaXMuX2tlcm5lbFNvdXJjZXNGaWx0ZXIubm9kZS5jbGFzc0xpc3QucmVtb3ZlKEZJTFRFUkJPWF9ISURERU5fQ0xBU1MpXG4gICAgICAgICAgICA6IHRoaXMuX2tlcm5lbFNvdXJjZXNGaWx0ZXIubm9kZS5jbGFzc0xpc3QuYWRkKEZJTFRFUkJPWF9ISURERU5fQ0xBU1MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY29udGVudCBvZiB0aGUga2VybmVsIHNvdXJjZSByZWFkLW9ubHkgZWRpdG9yLlxuICAgICAqL1xuICAgIF9jbGVhcigpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGF5b3V0LndpZGdldHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQucmVtb3ZlV2lkZ2V0QXQoMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib2R5LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IFJlYWN0V2lkZ2V0LCBVc2VTaWduYWwgfSBmcm9tICdAanVweXRlcmxhYi9hcHB1dGlscyc7XG5pbXBvcnQgeyBJbnB1dEdyb3VwIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdWktY29tcG9uZW50cyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuY29uc3QgRmlsdGVyQm94ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3Qgb25GaWx0ZXJDaGFuZ2UgPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgcHJvcHMubW9kZWwuZmlsdGVyID0gZmlsdGVyO1xuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElucHV0R3JvdXAsIHsgdHlwZTogXCJ0ZXh0XCIsIG9uQ2hhbmdlOiBvbkZpbHRlckNoYW5nZSwgcGxhY2Vob2xkZXI6IFwiRmlsdGVyIHRoZSBrZXJuZWwgc291cmNlc1wiLCB2YWx1ZTogcHJvcHMubW9kZWwuZmlsdGVyIH0pKTtcbn07XG4vKipcbiAqIEEgd2lkZ2V0IHdoaWNoIGhvc3RzIGEgaW5wdXQgdGV4dGJveCB0byBmaWx0ZXIgb24gZmlsZSBuYW1lcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEtlcm5lbFNvdXJjZXNGaWx0ZXIgPSAocHJvcHMpID0+IHtcbiAgICByZXR1cm4gUmVhY3RXaWRnZXQuY3JlYXRlKFJlYWN0LmNyZWF0ZUVsZW1lbnQoVXNlU2lnbmFsLCB7IHNpZ25hbDogcHJvcHMubW9kZWwuZmlsdGVyQ2hhbmdlZCwgaW5pdGlhbEFyZ3M6IHByb3BzLm1vZGVsLmZpbHRlciB9LCBtb2RlbCA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KEZpbHRlckJveCwgeyBtb2RlbDogcHJvcHMubW9kZWwgfSkpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgVG9vbGJhciB9IGZyb20gJ0BqdXB5dGVybGFiL2FwcHV0aWxzJztcbmltcG9ydCB7IG51bGxUcmFuc2xhdG9yIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdHJhbnNsYXRpb24nO1xuaW1wb3J0IHsgUGFuZWxMYXlvdXQsIFdpZGdldCB9IGZyb20gJ0BsdW1pbm8vd2lkZ2V0cyc7XG4vKipcbiAqIFRoZSBoZWFkZXIgZm9yIGEgS2VybmVsIFNvdXJjZSBQYW5lbC5cbiAqL1xuZXhwb3J0IGNsYXNzIEtlcm5lbFNvdXJjZXNIZWFkZXIgZXh0ZW5kcyBXaWRnZXQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgbmV3IFNvdXJjZXNIZWFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgVGhlIG1vZGVsIGZvciB0aGUgU291cmNlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgdHJhbnNsYXRvcikge1xuICAgICAgICBzdXBlcih7IG5vZGU6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2xiYXIgZm9yIHRoZSBzb3VyY2VzIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9vbGJhciA9IG5ldyBUb29sYmFyKCk7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKCdqcC1zdGFjay1wYW5lbC1oZWFkZXInKTtcbiAgICAgICAgdHJhbnNsYXRvciA9IHRyYW5zbGF0b3IgfHwgbnVsbFRyYW5zbGF0b3I7XG4gICAgICAgIGNvbnN0IHRyYW5zID0gdHJhbnNsYXRvci5sb2FkKCdqdXB5dGVybGFiJyk7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IG5ldyBQYW5lbExheW91dCgpO1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICAgICAgY29uc3QgdGl0bGUgPSBuZXcgV2lkZ2V0KHsgbm9kZTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKSB9KTtcbiAgICAgICAgdGl0bGUubm9kZS50ZXh0Q29udGVudCA9IHRyYW5zLl9fKCdLZXJuZWwgU291cmNlcycpO1xuICAgICAgICBsYXlvdXQuYWRkV2lkZ2V0KHRpdGxlKTtcbiAgICAgICAgbGF5b3V0LmFkZFdpZGdldCh0aGlzLnRvb2xiYXIpO1xuICAgICAgICB0aGlzLmFkZENsYXNzKCdqcC1EZWJ1Z2dlclNvdXJjZXMtaGVhZGVyJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IG51bGxUcmFuc2xhdG9yIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdHJhbnNsYXRpb24nO1xuaW1wb3J0IHsgc2hvd0Vycm9yTWVzc2FnZSB9IGZyb20gJ0BqdXB5dGVybGFiL2FwcHV0aWxzJztcbmltcG9ydCB7IFRvb2xiYXJCdXR0b24gfSBmcm9tICdAanVweXRlcmxhYi9hcHB1dGlscyc7XG5pbXBvcnQgeyByZWZyZXNoSWNvbiwgc2VhcmNoSWNvbiB9IGZyb20gJ0BqdXB5dGVybGFiL3VpLWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgUGFuZWwgfSBmcm9tICdAbHVtaW5vL3dpZGdldHMnO1xuaW1wb3J0IHsgS2VybmVsU291cmNlc0JvZHkgfSBmcm9tICcuL2JvZHknO1xuaW1wb3J0IHsgS2VybmVsU291cmNlc0hlYWRlciB9IGZyb20gJy4vaGVhZGVyJztcbi8qKlxuICogQSBQYW5lbCB0aGF0IHNob3dzIGEgcHJldmlldyBvZiB0aGUgc291cmNlIGNvZGUgd2hpbGUgZGVidWdnaW5nLlxuICovXG5leHBvcnQgY2xhc3MgS2VybmVsU291cmNlcyBleHRlbmRzIFBhbmVsIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBTb3VyY2VzIHByZXZpZXcgUGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgU291cmNlcyBpbnN0YW50aWF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwsIHNlcnZpY2UgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgICAgIGNvbnN0IHRyYW5zID0gKChfYSA9IG9wdGlvbnMudHJhbnNsYXRvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbFRyYW5zbGF0b3IpLmxvYWQoJ2p1cHl0ZXJsYWInKTtcbiAgICAgICAgdGhpcy50aXRsZS5sYWJlbCA9IHRyYW5zLl9fKCdLZXJuZWwgU291cmNlcycpO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgS2VybmVsU291cmNlc0hlYWRlcihtb2RlbCwgb3B0aW9ucy50cmFuc2xhdG9yKTtcbiAgICAgICAgaGVhZGVyLmFkZENsYXNzKCdqcC1EZWJ1Z2dlcktlcm5lbFNvdXJjZXMtaGVhZGVyJyk7XG4gICAgICAgIHRoaXMuX2JvZHkgPSBuZXcgS2VybmVsU291cmNlc0JvZHkoe1xuICAgICAgICAgICAgc2VydmljZSxcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgdHJhbnNsYXRvcjogb3B0aW9ucy50cmFuc2xhdG9yXG4gICAgICAgIH0pO1xuICAgICAgICBoZWFkZXIudG9vbGJhci5hZGRJdGVtKCdvcGVuLWZpbHRlcicsIG5ldyBUb29sYmFyQnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IHNlYXJjaEljb24sXG4gICAgICAgICAgICBvbkNsaWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keS50b2dnbGVGaWx0ZXJib3goKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b29sdGlwOiB0cmFucy5fXygnVG9nZ2xlIHNlYXJjaCBmaWx0ZXInKVxuICAgICAgICB9KSk7XG4gICAgICAgIGhlYWRlci50b29sYmFyLmFkZEl0ZW0oJ3JlZnJlc2gnLCBuZXcgVG9vbGJhckJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiByZWZyZXNoSWNvbixcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbC5rZXJuZWxTb3VyY2VzID0gW107XG4gICAgICAgICAgICAgICAgdm9pZCBzZXJ2aWNlLmRpc3BsYXlNb2R1bGVzKCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBzaG93RXJyb3JNZXNzYWdlKHRyYW5zLl9fKCdGYWlsIHRvIGdldCBrZXJuZWwgc291cmNlcycpLCB0cmFucy5fXygnRmFpbCB0byBnZXQga2VybmVsIHNvdXJjZXM6XFxuJTInLCByZWFzb24pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b29sdGlwOiB0cmFucy5fXygnUmVmcmVzaCBrZXJuZWwgc291cmNlcycpXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygnanAtRGVidWdnZXJLZXJuZWxTb3VyY2VzLWhlYWRlcicpO1xuICAgICAgICB0aGlzLmFkZENsYXNzKCdqcC1EZWJ1Z2dlcktlcm5lbFNvdXJjZXMnKTtcbiAgICAgICAgdGhpcy5hZGRXaWRnZXQoaGVhZGVyKTtcbiAgICAgICAgdGhpcy5hZGRXaWRnZXQodGhpcy5fYm9keSk7XG4gICAgfVxuICAgIHNldCBmaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuX21vZGVsLmZpbHRlciA9IGZpbHRlcjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICdAbHVtaW5vL3BvbGxpbmcnO1xuLyoqXG4gKiBUaGUgcmF0ZSBsaW1pdCBmb3IgdGhlIGZpbHRlciBkZWJvdW5jZXJcbiAqL1xuY29uc3QgREVCT1VOQ0VSX1JBVEVfTElNSVRfTVMgPSA1MDA7XG5jb25zdCBjb21wYXJlID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5uYW1lIDwgYi5uYW1lKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEubmFtZSA+IGIubmFtZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBUaGUgbW9kZWwgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBzb3VyY2UgYmVpbmcgZGlzcGxheWVkLlxuICovXG5leHBvcnQgY2xhc3MgS2VybmVsU291cmNlc01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fa2VybmVsU291cmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkS2VybmVsU291cmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpbHRlciA9ICcnO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZmlsdGVyQ2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2tlcm5lbFNvdXJjZU9wZW5lZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMucmVmcmVzaCA9IHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoRGVib3VuY2VyID0gbmV3IERlYm91bmNlcih0aGlzLnJlZnJlc2gsIERFQk9VTkNFUl9SQVRFX0xJTUlUX01TKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaWx0ZXIuXG4gICAgICovXG4gICAgZ2V0IGZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWx0ZXIuXG4gICAgICogVGhlIHVwZGF0ZVxuICAgICAqL1xuICAgIHNldCBmaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy5fZmlsdGVyQ2hhbmdlZC5lbWl0KGZpbHRlcik7XG4gICAgICAgIHZvaWQgdGhpcy5fcmVmcmVzaERlYm91bmNlci5pbnZva2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBrZXJuZWwgc291cmNlcy5cbiAgICAgKi9cbiAgICBnZXQga2VybmVsU291cmNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tlcm5lbFNvdXJjZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUga2VybmVsIHNvdXJjZXMgYW5kIGVtaXQgYSBjaGFuZ2VkIHNpZ25hbC5cbiAgICAgKi9cbiAgICBzZXQga2VybmVsU291cmNlcyhrZXJuZWxTb3VyY2VzKSB7XG4gICAgICAgIHRoaXMuX2tlcm5lbFNvdXJjZXMgPSBrZXJuZWxTb3VyY2VzO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgY3VycmVudCBzb3VyY2UgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXQgY2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGN1cnJlbnQgc291cmNlIGNoYW5nZXMuXG4gICAgICovXG4gICAgZ2V0IGZpbHRlckNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJDaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgZW1pdHRlZCB3aGVuIGEga2VybmVsIHNvdXJjZSBzaG91bGQgYmUgb3BlbiBpbiB0aGUgbWFpbiBhcmVhLlxuICAgICAqL1xuICAgIGdldCBrZXJuZWxTb3VyY2VPcGVuZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXJuZWxTb3VyY2VPcGVuZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBzb3VyY2UgaW4gdGhlIG1haW4gYXJlYS5cbiAgICAgKi9cbiAgICBvcGVuKGtlcm5lbFNvdXJjZSkge1xuICAgICAgICB0aGlzLl9rZXJuZWxTb3VyY2VPcGVuZWQuZW1pdChrZXJuZWxTb3VyY2UpO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJlZEtlcm5lbFNvdXJjZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAodGhpcy5fZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tlcm5lbFNvdXJjZXMuZmlsdGVyKG1vZHVsZSA9PiByZWdleHAudGVzdChtb2R1bGUubmFtZSkpO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBpZiAodGhpcy5fa2VybmVsU291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyZWRLZXJuZWxTb3VyY2VzID0gdGhpcy5fZmlsdGVyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmdldEZpbHRlcmVkS2VybmVsU291cmNlcygpXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9rZXJuZWxTb3VyY2VzO1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyZWRLZXJuZWxTb3VyY2VzLnNvcnQoY29tcGFyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9rZXJuZWxTb3VyY2VzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJlZEtlcm5lbFNvdXJjZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQodGhpcy5fZmlsdGVyZWRLZXJuZWxTb3VyY2VzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG5pbXBvcnQgeyBQYW5lbExheW91dCwgV2lkZ2V0IH0gZnJvbSAnQGx1bWluby93aWRnZXRzJztcbmltcG9ydCB7IERlYnVnZ2VyIH0gZnJvbSAnLi4vLi4nO1xuaW1wb3J0IHsgRWRpdG9ySGFuZGxlciB9IGZyb20gJy4uLy4uL2hhbmRsZXJzL2VkaXRvcic7XG4vKipcbiAqIFRoZSBib2R5IGZvciBhIFNvdXJjZXMgUGFuZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBTb3VyY2VzQm9keSBleHRlbmRzIFdpZGdldCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgQm9keSBmb3IgdGhlIFNvdXJjZXNCb2R5IHdpZGdldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbnN0YW50aWF0aW9uIG9wdGlvbnMgZm9yIGEgU291cmNlc0JvZHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgICAgIHRoaXMuX2RlYnVnZ2VyU2VydmljZSA9IG9wdGlvbnMuc2VydmljZTtcbiAgICAgICAgdGhpcy5fbWltZVR5cGVTZXJ2aWNlID0gb3B0aW9ucy5lZGl0b3JTZXJ2aWNlcy5taW1lVHlwZVNlcnZpY2U7XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgRGVidWdnZXIuUmVhZE9ubHlFZGl0b3JGYWN0b3J5KHtcbiAgICAgICAgICAgIGVkaXRvclNlcnZpY2VzOiBvcHRpb25zLmVkaXRvclNlcnZpY2VzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9lZGl0b3IgPSBmYWN0b3J5LmNyZWF0ZU5ld0VkaXRvcih7XG4gICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgIG1pbWVUeXBlOiAnJyxcbiAgICAgICAgICAgIHBhdGg6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9lZGl0b3IuaGlkZSgpO1xuICAgICAgICB0aGlzLl9tb2RlbC5jdXJyZW50RnJhbWVDaGFuZ2VkLmNvbm5lY3QoYXN5bmMgKF8sIGZyYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2b2lkIHRoaXMuX3Nob3dTb3VyY2UoZnJhbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gbmV3IFBhbmVsTGF5b3V0KCk7XG4gICAgICAgIGxheW91dC5hZGRXaWRnZXQodGhpcy5fZWRpdG9yKTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2pwLURlYnVnZ2VyU291cmNlcy1ib2R5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgdGhlIHNvdXJjZXMgYm9keSB3aWRnZXQuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZWRpdG9ySGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3Bvc2UoKTtcbiAgICAgICAgU2lnbmFsLmNsZWFyRGF0YSh0aGlzKTtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY29udGVudCBvZiB0aGUgc291cmNlIHJlYWQtb25seSBlZGl0b3IuXG4gICAgICovXG4gICAgX2NsZWFyRWRpdG9yKCkge1xuICAgICAgICB0aGlzLl9tb2RlbC5jdXJyZW50U291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZWRpdG9yLmhpZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgY29udGVudCBvZiB0aGUgc291cmNlIGZvciB0aGUgZ2l2ZW4gZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJhbWUgVGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICovXG4gICAgYXN5bmMgX3Nob3dTb3VyY2UoZnJhbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBwYXRoID0gKF9hID0gZnJhbWUuc291cmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aDtcbiAgICAgICAgY29uc3Qgc291cmNlID0gYXdhaXQgdGhpcy5fZGVidWdnZXJTZXJ2aWNlLmdldFNvdXJjZSh7XG4gICAgICAgICAgICBzb3VyY2VSZWZlcmVuY2U6IDAsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIShzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2UuY29udGVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyRWRpdG9yKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2VkaXRvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRvckhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29udGVudCwgbWltZVR5cGUgfSA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgZWRpdG9yTWltZVR5cGUgPSBtaW1lVHlwZSB8fCB0aGlzLl9taW1lVHlwZVNlcnZpY2UuZ2V0TWltZVR5cGVCeUZpbGVQYXRoKHBhdGggIT09IG51bGwgJiYgcGF0aCAhPT0gdm9pZCAwID8gcGF0aCA6ICcnKTtcbiAgICAgICAgdGhpcy5fZWRpdG9yLm1vZGVsLnZhbHVlLnRleHQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9lZGl0b3IubW9kZWwubWltZVR5cGUgPSBlZGl0b3JNaW1lVHlwZTtcbiAgICAgICAgdGhpcy5fZWRpdG9ySGFuZGxlciA9IG5ldyBFZGl0b3JIYW5kbGVyKHtcbiAgICAgICAgICAgIGRlYnVnZ2VyU2VydmljZTogdGhpcy5fZGVidWdnZXJTZXJ2aWNlLFxuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLl9lZGl0b3IuZWRpdG9yLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbW9kZWwuY3VycmVudFNvdXJjZSA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICBtaW1lVHlwZTogZWRpdG9yTWltZVR5cGUsXG4gICAgICAgICAgICBwYXRoOiBwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHZvaWQgMCA/IHBhdGggOiAnJ1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgRWRpdG9ySGFuZGxlci5zaG93Q3VycmVudExpbmUodGhpcy5fZWRpdG9yLmVkaXRvciwgZnJhbWUubGluZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9lZGl0b3Iuc2hvdygpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvZHkuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgUmVhY3RXaWRnZXQsIFRvb2xiYXIsIFVzZVNpZ25hbCB9IGZyb20gJ0BqdXB5dGVybGFiL2FwcHV0aWxzJztcbmltcG9ydCB7IG51bGxUcmFuc2xhdG9yIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdHJhbnNsYXRpb24nO1xuaW1wb3J0IHsgUGFuZWxMYXlvdXQsIFdpZGdldCB9IGZyb20gJ0BsdW1pbm8vd2lkZ2V0cyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBUaGUgaGVhZGVyIGZvciBhIFNvdXJjZSBQYW5lbC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNvdXJjZXNIZWFkZXIgZXh0ZW5kcyBXaWRnZXQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgbmV3IFNvdXJjZXNIZWFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgVGhlIG1vZGVsIGZvciB0aGUgU291cmNlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCwgdHJhbnNsYXRvcikge1xuICAgICAgICBzdXBlcih7IG5vZGU6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2xiYXIgZm9yIHRoZSBzb3VyY2VzIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9vbGJhciA9IG5ldyBUb29sYmFyKCk7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKCdqcC1zdGFjay1wYW5lbC1oZWFkZXInKTtcbiAgICAgICAgdHJhbnNsYXRvciA9IHRyYW5zbGF0b3IgfHwgbnVsbFRyYW5zbGF0b3I7XG4gICAgICAgIGNvbnN0IHRyYW5zID0gdHJhbnNsYXRvci5sb2FkKCdqdXB5dGVybGFiJyk7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IG5ldyBQYW5lbExheW91dCgpO1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICAgICAgY29uc3QgdGl0bGUgPSBuZXcgV2lkZ2V0KHsgbm9kZTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKSB9KTtcbiAgICAgICAgdGl0bGUubm9kZS50ZXh0Q29udGVudCA9IHRyYW5zLl9fKCdTb3VyY2UnKTtcbiAgICAgICAgY29uc3Qgc291cmNlUGF0aCA9IFJlYWN0V2lkZ2V0LmNyZWF0ZShSZWFjdC5jcmVhdGVFbGVtZW50KFNvdXJjZVBhdGhDb21wb25lbnQsIHsgbW9kZWw6IG1vZGVsIH0pKTtcbiAgICAgICAgbGF5b3V0LmFkZFdpZGdldCh0aXRsZSk7XG4gICAgICAgIGxheW91dC5hZGRXaWRnZXQodGhpcy50b29sYmFyKTtcbiAgICAgICAgbGF5b3V0LmFkZFdpZGdldChzb3VyY2VQYXRoKTtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygnanAtRGVidWdnZXJTb3VyY2VzLWhlYWRlcicpO1xuICAgIH1cbn1cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdG8gZGlzcGxheSB0aGUgcGF0aCB0byBhIHNvdXJjZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGNvbXBvbmVudCBwcm9wcy5cbiAqIEBwYXJhbSBwcm9wcy5tb2RlbCBUaGUgbW9kZWwgZm9yIHRoZSBzb3VyY2VzLlxuICovXG5jb25zdCBTb3VyY2VQYXRoQ29tcG9uZW50ID0gKHsgbW9kZWwgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChVc2VTaWduYWwsIHsgc2lnbmFsOiBtb2RlbC5jdXJyZW50U291cmNlQ2hhbmdlZCwgaW5pdGlhbFNlbmRlcjogbW9kZWwgfSwgKG1vZGVsKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBvbkNsaWNrOiAoKSA9PiBtb2RlbCA9PT0gbnVsbCB8fCBtb2RlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kZWwub3BlbigpIH0sIChfYiA9IChfYSA9IG1vZGVsID09PSBudWxsIHx8IG1vZGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RlbC5jdXJyZW50U291cmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpKTtcbiAgICB9KSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyLmpzLm1hcCIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBUb29sYmFyQnV0dG9uIH0gZnJvbSAnQGp1cHl0ZXJsYWIvYXBwdXRpbHMnO1xuaW1wb3J0IHsgbnVsbFRyYW5zbGF0b3IgfSBmcm9tICdAanVweXRlcmxhYi90cmFuc2xhdGlvbic7XG5pbXBvcnQgeyBQYW5lbCB9IGZyb20gJ0BsdW1pbm8vd2lkZ2V0cyc7XG5pbXBvcnQgeyB2aWV3QnJlYWtwb2ludEljb24gfSBmcm9tICcuLi8uLi9pY29ucyc7XG5pbXBvcnQgeyBTb3VyY2VzQm9keSB9IGZyb20gJy4vYm9keSc7XG5pbXBvcnQgeyBTb3VyY2VzSGVhZGVyIH0gZnJvbSAnLi9oZWFkZXInO1xuLyoqXG4gKiBBIFBhbmVsIHRoYXQgc2hvd3MgYSBwcmV2aWV3IG9mIHRoZSBzb3VyY2UgY29kZSB3aGlsZSBkZWJ1Z2dpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBTb3VyY2VzIGV4dGVuZHMgUGFuZWwge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgbmV3IFNvdXJjZXMgcHJldmlldyBQYW5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBTb3VyY2VzIGluc3RhbnRpYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwsIHNlcnZpY2UsIGVkaXRvclNlcnZpY2VzIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB0cmFuc2xhdG9yID0gb3B0aW9ucy50cmFuc2xhdG9yIHx8IG51bGxUcmFuc2xhdG9yO1xuICAgICAgICBjb25zdCB0cmFucyA9IHRyYW5zbGF0b3IubG9hZCgnanVweXRlcmxhYicpO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgU291cmNlc0hlYWRlcihtb2RlbCwgdHJhbnNsYXRvcik7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBuZXcgU291cmNlc0JvZHkoe1xuICAgICAgICAgICAgc2VydmljZSxcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgZWRpdG9yU2VydmljZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGhlYWRlci50b29sYmFyLmFkZEl0ZW0oJ29wZW4nLCBuZXcgVG9vbGJhckJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiB2aWV3QnJlYWtwb2ludEljb24sXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBtb2RlbC5vcGVuKCksXG4gICAgICAgICAgICB0b29sdGlwOiB0cmFucy5fXygnT3BlbiBpbiB0aGUgTWFpbiBBcmVhJylcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmFkZFdpZGdldChoZWFkZXIpO1xuICAgICAgICB0aGlzLmFkZFdpZGdldChib2R5KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG4vKipcbiAqIFRoZSBtb2RlbCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHNvdXJjZSBiZWluZyBkaXNwbGF5ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTb3VyY2VzTW9kZWwge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgbmV3IFNvdXJjZXMuTW9kZWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBTb3VyY2VzLk1vZGVsIGluc3RhbnRpYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTb3VyY2VPcGVuZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLl9jdXJyZW50U291cmNlQ2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lQ2hhbmdlZCA9IG9wdGlvbnMuY3VycmVudEZyYW1lQ2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFsIGVtaXR0ZWQgd2hlbiBhIHNvdXJjZSBzaG91bGQgYmUgb3BlbiBpbiB0aGUgbWFpbiBhcmVhLlxuICAgICAqL1xuICAgIGdldCBjdXJyZW50U291cmNlT3BlbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFNvdXJjZU9wZW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgY3VycmVudCBzb3VyY2UgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFNvdXJjZUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U291cmNlQ2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTb3VyY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2UgdG8gc2V0IGFzIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAgICAgKi9cbiAgICBzZXQgY3VycmVudFNvdXJjZShzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFNvdXJjZUNoYW5nZWQuZW1pdChzb3VyY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgc291cmNlIGluIHRoZSBtYWluIGFyZWEuXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFNvdXJjZU9wZW5lZC5lbWl0KHRoaXMuX2N1cnJlbnRTb3VyY2UpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IEJhc2ljS2V5SGFuZGxlciwgQmFzaWNNb3VzZUhhbmRsZXIsIEJhc2ljU2VsZWN0aW9uTW9kZWwsIERhdGFHcmlkLCBEYXRhTW9kZWwsIFRleHRSZW5kZXJlciB9IGZyb20gJ0BsdW1pbm8vZGF0YWdyaWQnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuaW1wb3J0IHsgUGFuZWwgfSBmcm9tICdAbHVtaW5vL3dpZGdldHMnO1xuaW1wb3J0IHsgRGVidWdnZXIgfSBmcm9tICcuLi8uLi8nO1xuLyoqXG4gKiBBIGRhdGEgZ3JpZCB0aGF0IGRpc3BsYXlzIHZhcmlhYmxlcyBpbiBhIGRlYnVnZ2VyIHNlc3Npb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZXNCb2R5R3JpZCBleHRlbmRzIFBhbmVsIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBWYXJpYWJsZXNCb2R5R3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbnN0YW50aWF0aW9uIG9wdGlvbnMgZm9yIGEgVmFyaWFibGVzQm9keUdyaWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCB7IG1vZGVsLCBjb21tYW5kcywgdGhlbWVNYW5hZ2VyLCBzY29wZXMgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2dyaWQgPSBuZXcgR3JpZCh7IGNvbW1hbmRzLCBtb2RlbCwgdGhlbWVNYW5hZ2VyIH0pO1xuICAgICAgICB0aGlzLl9ncmlkLmFkZENsYXNzKCdqcC1EZWJ1Z2dlclZhcmlhYmxlcy1ncmlkJyk7XG4gICAgICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuX21vZGVsLmNoYW5nZWQuY29ubmVjdCgobW9kZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fZ3JpZC5kYXRhTW9kZWwuc2V0RGF0YShzY29wZXMgIT09IG51bGwgJiYgc2NvcGVzICE9PSB2b2lkIDAgPyBzY29wZXMgOiBbXSk7XG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KHRoaXMuX2dyaWQpO1xuICAgICAgICB0aGlzLmFkZENsYXNzKCdqcC1EZWJ1Z2dlclZhcmlhYmxlcy1ib2R5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFyaWFibGUgZmlsdGVyIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFRoZSB2YXJpYWJsZSBmaWx0ZXIgdG8gYXBwbHkuXG4gICAgICovXG4gICAgc2V0IGZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5fZ3JpZC5kYXRhTW9kZWwuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHNjb3BlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjb3BlIFRoZSBjdXJyZW50IHNjb3BlIGZvciB0aGUgdmFyaWFibGVzLlxuICAgICAqL1xuICAgIHNldCBzY29wZShzY29wZSkge1xuICAgICAgICB0aGlzLl9ncmlkLmRhdGFNb2RlbC5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB1bmRlcmx5aW5nIGRhdGEgbW9kZWxcbiAgICAgKi9cbiAgICBfdXBkYXRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX2dyaWQuZGF0YU1vZGVsLnNldERhdGEoKF9hID0gdGhpcy5fbW9kZWwuc2NvcGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHdyYXBwaW5nIHRoZSB1bmRlcmx5aW5nIHZhcmlhYmxlcyBkYXRhZ3JpZC5cbiAqL1xuY2xhc3MgR3JpZCBleHRlbmRzIFBhbmVsIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBWYXJpYWJsZXNHcmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGluc3RhbnRpYXRpb24gb3B0aW9ucyBmb3IgYSBWYXJpYWJsZXNHcmlkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgeyBjb21tYW5kcywgbW9kZWwsIHRoZW1lTWFuYWdlciB9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICBjb25zdCBkYXRhTW9kZWwgPSBuZXcgR3JpZE1vZGVsKCk7XG4gICAgICAgIGNvbnN0IGdyaWQgPSBuZXcgRGF0YUdyaWQoKTtcbiAgICAgICAgY29uc3QgbW91c2VIYW5kbGVyID0gbmV3IFByaXZhdGUuTW91c2VIYW5kbGVyKCk7XG4gICAgICAgIG1vdXNlSGFuZGxlci5kb3VibGVDbGlja2VkLmNvbm5lY3QoKF8sIGhpdCkgPT4gY29tbWFuZHMuZXhlY3V0ZShEZWJ1Z2dlci5Db21tYW5kSURzLmluc3BlY3RWYXJpYWJsZSwge1xuICAgICAgICAgICAgdmFyaWFibGVSZWZlcmVuY2U6IGRhdGFNb2RlbC5nZXRWYXJpYWJsZVJlZmVyZW5jZShoaXQucm93KSxcbiAgICAgICAgICAgIG5hbWU6IGRhdGFNb2RlbC5nZXRWYXJpYWJsZU5hbWUoaGl0LnJvdylcbiAgICAgICAgfSkpO1xuICAgICAgICBtb3VzZUhhbmRsZXIuc2VsZWN0ZWQuY29ubmVjdCgoXywgaGl0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJvdyB9ID0gaGl0O1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZWxlY3RlZFZhcmlhYmxlID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGRhdGFNb2RlbC5nZXRWYXJpYWJsZU5hbWUocm93KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YU1vZGVsLmRhdGEoJ2JvZHknLCByb3csIDEpLFxuICAgICAgICAgICAgICAgIHR5cGU6IGRhdGFNb2RlbC5kYXRhKCdib2R5Jywgcm93LCAyKSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXNSZWZlcmVuY2U6IGRhdGFNb2RlbC5nZXRWYXJpYWJsZVJlZmVyZW5jZShyb3cpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZ3JpZC5kYXRhTW9kZWwgPSBkYXRhTW9kZWw7XG4gICAgICAgIGdyaWQua2V5SGFuZGxlciA9IG5ldyBCYXNpY0tleUhhbmRsZXIoKTtcbiAgICAgICAgZ3JpZC5tb3VzZUhhbmRsZXIgPSBtb3VzZUhhbmRsZXI7XG4gICAgICAgIGdyaWQuc2VsZWN0aW9uTW9kZWwgPSBuZXcgQmFzaWNTZWxlY3Rpb25Nb2RlbCh7XG4gICAgICAgICAgICBkYXRhTW9kZWxcbiAgICAgICAgfSk7XG4gICAgICAgIGdyaWQuc3RyZXRjaExhc3RDb2x1bW4gPSB0cnVlO1xuICAgICAgICBncmlkLm5vZGUuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLl9ncmlkID0gZ3JpZDtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZ3JpZCdzIHN0eWxlcyBiYXNlZCBvbiB0aGUgY3VycmVudCB0aGVtZS5cbiAgICAgICAgaWYgKHRoZW1lTWFuYWdlcikge1xuICAgICAgICAgICAgdGhlbWVNYW5hZ2VyLnRoZW1lQ2hhbmdlZC5jb25uZWN0KHRoaXMuX3VwZGF0ZVN0eWxlcywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRXaWRnZXQoZ3JpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFyaWFibGUgZmlsdGVyIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFRoZSB2YXJpYWJsZSBmaWx0ZXIgdG8gYXBwbHkuXG4gICAgICovXG4gICAgc2V0IGZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5fZ3JpZC5kYXRhTW9kZWwuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNjb3BlIGZvciB0aGUgdmFyaWFibGVzIGRhdGEgbW9kZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NvcGUgVGhlIHNjb3BlcyBmb3IgdGhlIHZhcmlhYmxlc1xuICAgICAqL1xuICAgIHNldCBzY29wZShzY29wZSkge1xuICAgICAgICB0aGlzLl9ncmlkLmRhdGFNb2RlbC5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRhdGEgbW9kZWwgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICovXG4gICAgZ2V0IGRhdGFNb2RlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyaWQuZGF0YU1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYGFmdGVyLWF0dGFjaGAgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBgYWZ0ZXItYXR0YWNoYCBtZXNzYWdlLlxuICAgICAqL1xuICAgIG9uQWZ0ZXJBdHRhY2gobWVzc2FnZSkge1xuICAgICAgICBzdXBlci5vbkFmdGVyQXR0YWNoKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl91cGRhdGVTdHlsZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjb21wdXRlZCBzdHlsZSBmb3IgdGhlIGRhdGEgZ3JpZCBvbiB0aGVtZSBjaGFuZ2UuXG4gICAgICovXG4gICAgX3VwZGF0ZVN0eWxlcygpIHtcbiAgICAgICAgY29uc3QgeyBzdHlsZSwgdGV4dFJlbmRlcmVyIH0gPSBQcml2YXRlLmNvbXB1dGVTdHlsZSgpO1xuICAgICAgICB0aGlzLl9ncmlkLmNlbGxSZW5kZXJlcnMudXBkYXRlKHt9LCB0ZXh0UmVuZGVyZXIpO1xuICAgICAgICB0aGlzLl9ncmlkLnN0eWxlID0gc3R5bGU7XG4gICAgfVxufVxuLyoqXG4gKiBBIGRhdGEgZ3JpZCBtb2RlbCBmb3IgdmFyaWFibGVzLlxuICovXG5jbGFzcyBHcmlkTW9kZWwgZXh0ZW5kcyBEYXRhTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9maWx0ZXIgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3Njb3BlID0gJyc7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB7XG4gICAgICAgICAgICBuYW1lOiBbXSxcbiAgICAgICAgICAgIHR5cGU6IFtdLFxuICAgICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgICAgdmFyaWFibGVzUmVmZXJlbmNlOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhcmlhYmxlIGZpbHRlciBsaXN0LlxuICAgICAqL1xuICAgIHNldCBmaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlciA9IGZpbHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHNjb3BlIGZvciB0aGUgdmFyaWFibGVzLlxuICAgICAqL1xuICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhcmlhYmxlIHNjb3BlXG4gICAgICovXG4gICAgc2V0IHNjb3BlKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuX3Njb3BlID0gc2NvcGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm93IGNvdW50IGZvciBhIHBhcnRpY3VsYXIgcmVnaW9uIGluIHRoZSBkYXRhIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVnaW9uIFRoZSBkYXRhZ3JpZCByZWdpb24uXG4gICAgICovXG4gICAgcm93Q291bnQocmVnaW9uKSB7XG4gICAgICAgIHJldHVybiByZWdpb24gPT09ICdib2R5JyA/IHRoaXMuX2RhdGEubmFtZS5sZW5ndGggOiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbHVtbiBjb3VudCBmb3IgYSBwYXJ0aWN1bGFyIHJlZ2lvbiBpbiB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiBUaGUgZGF0YWdyaWQgcmVnaW9uLlxuICAgICAqL1xuICAgIGNvbHVtbkNvdW50KHJlZ2lvbikge1xuICAgICAgICByZXR1cm4gcmVnaW9uID09PSAnYm9keScgPyAyIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkYXRhIGNvdW50IGZvciBhIHBhcnRpY3VsYXIgcmVnaW9uLCByb3cgYW5kIGNvbHVtbiBpbiB0aGUgZGF0YSBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiBUaGUgZGF0YWdyaWQgcmVnaW9uLlxuICAgICAqIEBwYXJhbSByb3cgVGhlIGRhdGFncmlkIHJvd1xuICAgICAqIEBwYXJhbSBjb2x1bW4gVGhlIGRhdGFncmlkIGNvbHVtblxuICAgICAqL1xuICAgIGRhdGEocmVnaW9uLCByb3csIGNvbHVtbikge1xuICAgICAgICBpZiAocmVnaW9uID09PSAncm93LWhlYWRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLm5hbWVbcm93XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVnaW9uID09PSAnY29sdW1uLWhlYWRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4gPT09IDEgPyAnVmFsdWUnIDogJ1R5cGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdpb24gPT09ICdjb3JuZXItaGVhZGVyJykge1xuICAgICAgICAgICAgcmV0dXJuICdOYW1lJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uID09PSAxID8gdGhpcy5fZGF0YS52YWx1ZVtyb3ddIDogdGhpcy5fZGF0YS50eXBlW3Jvd107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFyaWFibGUgcmVmZXJlbmNlIGZvciBhIGdpdmVuIHJvd1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvdyBUaGUgcm93IGluIHRoZSBkYXRhZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRWYXJpYWJsZVJlZmVyZW5jZShyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudmFyaWFibGVzUmVmZXJlbmNlW3Jvd107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFyaWFibGUgbmFtZSBmb3IgYSBnaXZlbiByb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgVGhlIHJvdyBpbiB0aGUgZGF0YWdyaWQuXG4gICAgICovXG4gICAgZ2V0VmFyaWFibGVOYW1lKHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5uYW1lW3Jvd107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGF0YWdyaWQgbW9kZWwgZGF0YSBmcm9tIHRoZSBsaXN0IG9mIHZhcmlhYmxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YXJpYWJsZXMgVGhlIGxpc3Qgb2YgdmFyaWFibGVzLlxuICAgICAqL1xuICAgIHNldERhdGEoc2NvcGVzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuX2NsZWFyRGF0YSgpO1xuICAgICAgICB0aGlzLmVtaXRDaGFuZ2VkKHtcbiAgICAgICAgICAgIHR5cGU6ICdtb2RlbC1yZXNldCcsXG4gICAgICAgICAgICByZWdpb246ICdib2R5J1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSAoX2EgPSBzY29wZXMuZmluZChzY29wZSA9PiBzY29wZS5uYW1lID09PSB0aGlzLl9zY29wZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNjb3Blc1swXTtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gKF9iID0gc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLnZhcmlhYmxlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gdmFyaWFibGVzLmZpbHRlcih2YXJpYWJsZSA9PiB2YXJpYWJsZS5uYW1lICYmICF0aGlzLl9maWx0ZXIuaGFzKHZhcmlhYmxlLm5hbWUpKTtcbiAgICAgICAgZmlsdGVyZWQuZm9yRWFjaCgodmFyaWFibGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB0aGlzLl9kYXRhLm5hbWVbaW5kZXhdID0gdmFyaWFibGUubmFtZTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEudHlwZVtpbmRleF0gPSAoX2EgPSB2YXJpYWJsZS50eXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgICAgIHRoaXMuX2RhdGEudmFsdWVbaW5kZXhdID0gdmFyaWFibGUudmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9kYXRhLnZhcmlhYmxlc1JlZmVyZW5jZVtpbmRleF0gPSB2YXJpYWJsZS52YXJpYWJsZXNSZWZlcmVuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXRDaGFuZ2VkKHtcbiAgICAgICAgICAgIHR5cGU6ICdyb3dzLWluc2VydGVkJyxcbiAgICAgICAgICAgIHJlZ2lvbjogJ2JvZHknLFxuICAgICAgICAgICAgaW5kZXg6IDEsXG4gICAgICAgICAgICBzcGFuOiBmaWx0ZXJlZC5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCB0aGUgZGF0YSBpbiB0aGUgZGF0YWdyaWQuXG4gICAgICovXG4gICAgX2NsZWFyRGF0YSgpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IFtdLFxuICAgICAgICAgICAgdHlwZTogW10sXG4gICAgICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgICAgICB2YXJpYWJsZXNSZWZlcmVuY2U6IFtdXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBBIG5hbWVzcGFjZSBmb3IgcHJpdmF0ZSBkYXRhLlxuICovXG52YXIgUHJpdmF0ZTtcbihmdW5jdGlvbiAoUHJpdmF0ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbG9yIHBhbGV0dGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWxldHRlKCkge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICdqcC1EZWJ1Z2dlclZhcmlhYmxlcy1jb2xvclBhbGV0dGUnO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gYFxuICAgICAgPGRpdiBjbGFzcz1cImpwLW1vZC12b2lkXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwianAtbW9kLWJhY2tncm91bmRcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJqcC1tb2QtaGVhZGVyLWJhY2tncm91bmRcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJqcC1tb2QtZ3JpZC1saW5lXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwianAtbW9kLWhlYWRlci1ncmlkLWxpbmVcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJqcC1tb2Qtc2VsZWN0aW9uXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwianAtbW9kLXRleHRcIj48L2Rpdj5cbiAgICBgO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBzdHlsZSBhbmQgcmVuZGVyZXIgZm9yIGEgZGF0YSBncmlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVTdHlsZSgpIHtcbiAgICAgICAgY29uc3QgcGFsZXR0ZSA9IGNyZWF0ZVBhbGV0dGUoKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYWxldHRlKTtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYWxldHRlLnF1ZXJ5U2VsZWN0b3IoJy5qcC1tb2Qtdm9pZCcpO1xuICAgICAgICBjb25zdCB2b2lkQ29sb3IgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpLmNvbG9yO1xuICAgICAgICBub2RlID0gcGFsZXR0ZS5xdWVyeVNlbGVjdG9yKCcuanAtbW9kLWJhY2tncm91bmQnKTtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5jb2xvcjtcbiAgICAgICAgbm9kZSA9IHBhbGV0dGUucXVlcnlTZWxlY3RvcignLmpwLW1vZC1oZWFkZXItYmFja2dyb3VuZCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJCYWNrZ3JvdW5kQ29sb3IgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpLmNvbG9yO1xuICAgICAgICBub2RlID0gcGFsZXR0ZS5xdWVyeVNlbGVjdG9yKCcuanAtbW9kLWdyaWQtbGluZScpO1xuICAgICAgICBjb25zdCBncmlkTGluZUNvbG9yID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5jb2xvcjtcbiAgICAgICAgbm9kZSA9IHBhbGV0dGUucXVlcnlTZWxlY3RvcignLmpwLW1vZC1oZWFkZXItZ3JpZC1saW5lJyk7XG4gICAgICAgIGNvbnN0IGhlYWRlckdyaWRMaW5lQ29sb3IgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpLmNvbG9yO1xuICAgICAgICBub2RlID0gcGFsZXR0ZS5xdWVyeVNlbGVjdG9yKCcuanAtbW9kLXNlbGVjdGlvbicpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25GaWxsQ29sb3IgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpLmNvbG9yO1xuICAgICAgICBub2RlID0gcGFsZXR0ZS5xdWVyeVNlbGVjdG9yKCcuanAtbW9kLXRleHQnKTtcbiAgICAgICAgY29uc3QgdGV4dENvbG9yID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5jb2xvcjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChwYWxldHRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgdm9pZENvbG9yLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBoZWFkZXJCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgZ3JpZExpbmVDb2xvcixcbiAgICAgICAgICAgICAgICBoZWFkZXJHcmlkTGluZUNvbG9yLFxuICAgICAgICAgICAgICAgIHJvd0JhY2tncm91bmRDb2xvcjogKGkpID0+IGkgJSAyID09PSAwID8gdm9pZENvbG9yIDogYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkZpbGxDb2xvclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHRSZW5kZXJlcjogbmV3IFRleHRSZW5kZXJlcih7XG4gICAgICAgICAgICAgICAgZm9udDogJzEycHggc2Fucy1zZXJpZicsXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbm1lbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQ6ICdsZWZ0J1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgUHJpdmF0ZS5jb21wdXRlU3R5bGUgPSBjb21wdXRlU3R5bGU7XG4gICAgLyoqXG4gICAgICogQSBjdXN0b20gY2xpY2sgaGFuZGxlciB0byBoYW5kbGUgY2xpY2tzIG9uIHRoZSB2YXJpYWJsZXMgZ3JpZC5cbiAgICAgKi9cbiAgICBjbGFzcyBNb3VzZUhhbmRsZXIgZXh0ZW5kcyBCYXNpY01vdXNlSGFuZGxlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX2RvdWJsZUNsaWNrZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBuZXcgU2lnbmFsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIHZhcmlhYmxlcyBncmlkIGlzIGRvdWJsZSBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGRvdWJsZUNsaWNrZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG91YmxlQ2xpY2tlZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSB2YXJpYWJsZXMgZ3JpZCByZWNlaXZlZCBtb3VzZSBkb3duIG9yIGNvbnRleHQgbWVudSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIG1vdXNlIGhhbmRsZXIuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNpZ25hbC5kaXNjb25uZWN0U2VuZGVyKHRoaXMpO1xuICAgICAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGUgYSBtb3VzZSBkb3VibGUtY2xpY2sgZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBncmlkIFRoZSBkYXRhZ3JpZCBjbGlja2VkLlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIG1vdXNlIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgb25Nb3VzZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBoaXQgPSBncmlkLmhpdFRlc3QoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgICB0aGlzLl9kb3VibGVDbGlja2VkLmVtaXQoaGl0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIHRoZSBtb3VzZSBkb3duIGV2ZW50IGZvciB0aGUgZGF0YSBncmlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZ3JpZCAtIFRoZSBkYXRhIGdyaWQgb2YgaW50ZXJlc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBkb3duIGV2ZW50IG9mIGludGVyZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgb25Nb3VzZURvd24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFVucGFjayB0aGUgZXZlbnQuXG4gICAgICAgICAgICBsZXQgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBldmVudDtcbiAgICAgICAgICAgIC8vIEhpdCB0ZXN0IHRoZSBncmlkLlxuICAgICAgICAgICAgbGV0IGhpdCA9IGdyaWQuaGl0VGVzdChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkLmVtaXQoaGl0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIHRoZSBjb250ZXh0IG1lbnUgZXZlbnQgZm9yIHRoZSBkYXRhIGdyaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBncmlkIC0gVGhlIGRhdGEgZ3JpZCBvZiBpbnRlcmVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGNvbnRleHQgbWVudSBldmVudCBvZiBpbnRlcmVzdC5cbiAgICAgICAgICovXG4gICAgICAgIG9uQ29udGV4dE1lbnUoZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFVucGFjayB0aGUgZXZlbnQuXG4gICAgICAgICAgICBsZXQgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBldmVudDtcbiAgICAgICAgICAgIC8vIEhpdCB0ZXN0IHRoZSBncmlkLlxuICAgICAgICAgICAgbGV0IGhpdCA9IGdyaWQuaGl0VGVzdChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkLmVtaXQoaGl0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQcml2YXRlLk1vdXNlSGFuZGxlciA9IE1vdXNlSGFuZGxlcjtcbn0pKFByaXZhdGUgfHwgKFByaXZhdGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JpZC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5pbXBvcnQgeyBUb29sYmFyIH0gZnJvbSAnQGp1cHl0ZXJsYWIvYXBwdXRpbHMnO1xuaW1wb3J0IHsgbnVsbFRyYW5zbGF0b3IgfSBmcm9tICdAanVweXRlcmxhYi90cmFuc2xhdGlvbic7XG5pbXBvcnQgeyBQYW5lbExheW91dCwgV2lkZ2V0IH0gZnJvbSAnQGx1bWluby93aWRnZXRzJztcbi8qKlxuICogVGhlIGhlYWRlciBmb3IgYSBWYXJpYWJsZXMgUGFuZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZXNIZWFkZXIgZXh0ZW5kcyBXaWRnZXQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgbmV3IFZhcmlhYmxlc0hlYWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0cmFuc2xhdG9yKSB7XG4gICAgICAgIHN1cGVyKHsgbm9kZTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9vbGJhciBmb3IgdGhlIGNhbGxzdGFjayBoZWFkZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvb2xiYXIgPSBuZXcgVG9vbGJhcigpO1xuICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgnanAtc3RhY2stcGFuZWwtaGVhZGVyJyk7XG4gICAgICAgIHRyYW5zbGF0b3IgPSB0cmFuc2xhdG9yIHx8IG51bGxUcmFuc2xhdG9yO1xuICAgICAgICBjb25zdCB0cmFucyA9IHRyYW5zbGF0b3IubG9hZCgnanVweXRlcmxhYicpO1xuICAgICAgICBjb25zdCB0aXRsZSA9IG5ldyBXaWRnZXQoeyBub2RlOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpIH0pO1xuICAgICAgICB0aXRsZS5ub2RlLnRleHRDb250ZW50ID0gdHJhbnMuX18oJ1ZhcmlhYmxlcycpO1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBuZXcgUGFuZWxMYXlvdXQoKTtcbiAgICAgICAgbGF5b3V0LmFkZFdpZGdldCh0aXRsZSk7XG4gICAgICAgIGxheW91dC5hZGRXaWRnZXQodGhpcy50b29sYmFyKTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IFRvb2xiYXJCdXR0b24gfSBmcm9tICdAanVweXRlcmxhYi9hcHB1dGlscyc7XG5pbXBvcnQgeyBudWxsVHJhbnNsYXRvciB9IGZyb20gJ0BqdXB5dGVybGFiL3RyYW5zbGF0aW9uJztcbmltcG9ydCB7IHRhYmxlUm93c0ljb24sIHRyZWVWaWV3SWNvbiB9IGZyb20gJ0BqdXB5dGVybGFiL3VpLWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgUGFuZWwgfSBmcm9tICdAbHVtaW5vL3dpZGdldHMnO1xuaW1wb3J0IHsgVmFyaWFibGVzQm9keUdyaWQgfSBmcm9tICcuL2dyaWQnO1xuaW1wb3J0IHsgVmFyaWFibGVzSGVhZGVyIH0gZnJvbSAnLi9oZWFkZXInO1xuaW1wb3J0IHsgU2NvcGVTd2l0Y2hlciB9IGZyb20gJy4vc2NvcGUnO1xuaW1wb3J0IHsgVmFyaWFibGVzQm9keVRyZWUgfSBmcm9tICcuL3RyZWUnO1xuLyoqXG4gKiBBIFBhbmVsIHRvIHNob3cgYSB2YXJpYWJsZSBleHBsb3Jlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFZhcmlhYmxlcyBleHRlbmRzIFBhbmVsIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBWYXJpYWJsZXMgUGFuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciBhIFZhcmlhYmxlcyBQYW5lbC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwsIHNlcnZpY2UsIGNvbW1hbmRzLCB0aGVtZU1hbmFnZXIgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3IgfHwgbnVsbFRyYW5zbGF0b3I7XG4gICAgICAgIGNvbnN0IHRyYW5zID0gdHJhbnNsYXRvci5sb2FkKCdqdXB5dGVybGFiJyk7XG4gICAgICAgIHRoaXMuX2hlYWRlciA9IG5ldyBWYXJpYWJsZXNIZWFkZXIodHJhbnNsYXRvcik7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBuZXcgVmFyaWFibGVzQm9keVRyZWUoe1xuICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICBzZXJ2aWNlLFxuICAgICAgICAgICAgY29tbWFuZHMsXG4gICAgICAgICAgICB0cmFuc2xhdG9yXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90YWJsZSA9IG5ldyBWYXJpYWJsZXNCb2R5R3JpZCh7IG1vZGVsLCBjb21tYW5kcywgdGhlbWVNYW5hZ2VyIH0pO1xuICAgICAgICB0aGlzLl90YWJsZS5oaWRlKCk7XG4gICAgICAgIHRoaXMuX2hlYWRlci50b29sYmFyLmFkZEl0ZW0oJ3Njb3BlLXN3aXRjaGVyJywgbmV3IFNjb3BlU3dpdGNoZXIoe1xuICAgICAgICAgICAgdHJhbnNsYXRvcixcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgdHJlZTogdGhpcy5fdHJlZSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXMuX3RhYmxlXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgb25WaWV3Q2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RhYmxlLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJlZS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFibGUuc2hvdygpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtanAtdGFibGUnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIG1hcmtWaWV3QnV0dG9uU2VsZWN0aW9uKCd0YWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJlZS5zaG93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFibGUuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtanAtdGFibGUnKTtcbiAgICAgICAgICAgICAgICBtYXJrVmlld0J1dHRvblNlbGVjdGlvbigndHJlZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdHJlZVZpZXdCdXR0b24gPSBuZXcgVG9vbGJhckJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiB0cmVlVmlld0ljb24sXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdqcC1UcmVlVmlldycsXG4gICAgICAgICAgICBvbkNsaWNrOiBvblZpZXdDaGFuZ2UsXG4gICAgICAgICAgICB0b29sdGlwOiB0cmFucy5fXygnVHJlZSBWaWV3JylcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRhYmxlVmlld0J1dHRvbiA9IG5ldyBUb29sYmFyQnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IHRhYmxlUm93c0ljb24sXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdqcC1UYWJsZVZpZXcnLFxuICAgICAgICAgICAgb25DbGljazogb25WaWV3Q2hhbmdlLFxuICAgICAgICAgICAgdG9vbHRpcDogdHJhbnMuX18oJ1RhYmxlIFZpZXcnKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWFya1ZpZXdCdXR0b25TZWxlY3Rpb24gPSAoc2VsZWN0ZWRWaWV3KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aWV3TW9kZUNsYXNzTmFtZSA9ICdqcC1WaWV3TW9kZVNlbGVjdGVkJztcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFZpZXcgPT09ICd0cmVlJykge1xuICAgICAgICAgICAgICAgIHRhYmxlVmlld0J1dHRvbi5yZW1vdmVDbGFzcyh2aWV3TW9kZUNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgdHJlZVZpZXdCdXR0b24uYWRkQ2xhc3Modmlld01vZGVDbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJlZVZpZXdCdXR0b24ucmVtb3ZlQ2xhc3Modmlld01vZGVDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIHRhYmxlVmlld0J1dHRvbi5hZGRDbGFzcyh2aWV3TW9kZUNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1hcmtWaWV3QnV0dG9uU2VsZWN0aW9uKHRoaXMuX3RhYmxlLmlzSGlkZGVuID8gJ3RyZWUnIDogJ3RhYmxlJyk7XG4gICAgICAgIHRoaXMuX2hlYWRlci50b29sYmFyLmFkZEl0ZW0oJ3ZpZXctVmFyaWFibGVUcmVlVmlldycsIHRyZWVWaWV3QnV0dG9uKTtcbiAgICAgICAgdGhpcy5faGVhZGVyLnRvb2xiYXIuYWRkSXRlbSgndmlldy1WYXJpYWJsZVRhYmxlVmlldycsIHRhYmxlVmlld0J1dHRvbik7XG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KHRoaXMuX2hlYWRlcik7XG4gICAgICAgIHRoaXMuYWRkV2lkZ2V0KHRoaXMuX3RyZWUpO1xuICAgICAgICB0aGlzLmFkZFdpZGdldCh0aGlzLl90YWJsZSk7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2pwLURlYnVnZ2VyVmFyaWFibGVzJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFyaWFibGUgZmlsdGVyIGZvciBib3RoIHRoZSB0cmVlIGFuZCB0YWJsZSB2aWV3cy5cbiAgICAgKi9cbiAgICBzZXQgZmlsdGVyKGZpbHRlcikge1xuICAgICAgICB0aGlzLl90cmVlLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy5fdGFibGUuZmlsdGVyID0gZmlsdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFuZGxlciBpbnZva2VkIG9uIGEgYCdyZXNpemUnYCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyBUaGUgTHVtaW5vIG1lc3NhZ2UgdG8gcHJvY2Vzcy5cbiAgICAgKi9cbiAgICBvblJlc2l6ZShtc2cpIHtcbiAgICAgICAgc3VwZXIub25SZXNpemUobXNnKTtcbiAgICAgICAgdGhpcy5fcmVzaXplQm9keShtc2cpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXNnIFRoZSByZXNpemUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBfcmVzaXplQm9keShtc2cpIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbXNnLmhlaWdodCAtIHRoaXMuX2hlYWRlci5ub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgdGhpcy5fdHJlZS5ub2RlLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0IGEgdmFyaWFibGUgdG8gYSBwcmltaXRpdmUgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdmFyaWFibGUgVGhlIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgY29udmVydFR5cGUgPSAodmFyaWFibGUpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IHZhcmlhYmxlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgJ3N0cic6XG4gICAgICAgICAgICBpZiAoKF9iID0gKF9hID0gdmFyaWFibGUucHJlc2VudGF0aW9uSGludCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcygncmF3U3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB2b2lkIDAgPyB0eXBlIDogdmFsdWU7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IE1haW5BcmVhV2lkZ2V0IH0gZnJvbSAnQGp1cHl0ZXJsYWIvYXBwdXRpbHMnO1xuaW1wb3J0IHsgTWltZU1vZGVsIH0gZnJvbSAnQGp1cHl0ZXJsYWIvcmVuZGVybWltZSc7XG5pbXBvcnQgeyBudWxsVHJhbnNsYXRvciB9IGZyb20gJ0BqdXB5dGVybGFiL3RyYW5zbGF0aW9uJztcbmltcG9ydCB7IFByb21pc2VEZWxlZ2F0ZSB9IGZyb20gJ0BsdW1pbm8vY29yZXV0aWxzJztcbmltcG9ydCB7IFBhbmVsIH0gZnJvbSAnQGx1bWluby93aWRnZXRzJztcbmltcG9ydCB7IG11cm11cjIgfSBmcm9tICcuLi8uLi9oYXNoJztcbi8qKlxuICogRGVidWdnZXIgdmFyaWFibGUgbWltZSB0eXBlIHJlbmRlcmVyXG4gKi9cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZU1pbWVSZW5kZXJlciBleHRlbmRzIE1haW5BcmVhV2lkZ2V0IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBWYXJpYWJsZU1pbWVSZW5kZXJlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YUxvYWRlciwgcmVuZGVybWltZSwgdHJhbnNsYXRvciB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY29udGVudCA9IG5ldyBQYW5lbCgpO1xuICAgICAgICBjb25zdCBsb2FkZWQgPSBuZXcgUHJvbWlzZURlbGVnYXRlKCk7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICByZXZlYWw6IFByb21pc2UuYWxsKFtkYXRhTG9hZGVyLCBsb2FkZWQucHJvbWlzZV0pXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zID0gKHRyYW5zbGF0b3IgIT09IG51bGwgJiYgdHJhbnNsYXRvciAhPT0gdm9pZCAwID8gdHJhbnNsYXRvciA6IG51bGxUcmFuc2xhdG9yKS5sb2FkKCdqdXB5dGVybGFiJyk7XG4gICAgICAgIHRoaXMuZGF0YUxvYWRlciA9IGRhdGFMb2FkZXI7XG4gICAgICAgIHRoaXMucmVuZGVyTWltZSA9IHJlbmRlcm1pbWU7XG4gICAgICAgIHRoaXMuX2RhdGFIYXNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWZyZXNoKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGxvYWRlZC5yZXNvbHZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gocmVhc29uID0+IGxvYWRlZC5yZWplY3QocmVhc29uKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2ggdGhlIHZhcmlhYmxlIHZpZXdcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmRhdGFMb2FkZXIoKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRhdGEuZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nOiB0aGlzLnRyYW5zLl9fKCdUaGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkIGluIHRoZSBhY3RpdmUgY29udGV4dC4nKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBtdXJtdXIyKEpTT04uc3RyaW5naWZ5KGRhdGEpLCAxNyk7XG4gICAgICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy5fZGF0YUhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LmxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQud2lkZ2V0cy5mb3JFYWNoKHcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmxheW91dC5yZW1vdmVXaWRnZXQodyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSB0cnVzdCB1bmNvbmRpdGlvbmFsbHkgdGhlIGRhdGEgYXMgdGhlIHVzZXIgaXMgcmVxdWlyZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjb2RlIHRvIGxvYWQgYSBwYXJ0aWN1bGFyIHZhcmlhYmxlIGluIG1lbW9yeVxuICAgICAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gdGhpcy5yZW5kZXJNaW1lLnByZWZlcnJlZE1pbWVUeXBlKGRhdGEuZGF0YSwgJ2FueScpO1xuICAgICAgICAgICAgICAgIGlmIChtaW1lVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWRnZXQgPSB0aGlzLnJlbmRlck1pbWUuY3JlYXRlUmVuZGVyZXIobWltZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IG5ldyBNaW1lTW9kZWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyB0cnVzdGVkOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YUhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3aWRnZXQucmVuZGVyTW9kZWwobW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuYWRkV2lkZ2V0KHdpZGdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhSGFzaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnVW5hYmxlIHRvIGRldGVybWluZSB0aGUgcHJlZmVycmVkIG1pbWUgdHlwZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhSGFzaCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1VuYWJsZSB0byBnZXQgYSB2aWV3IG9uIHRoZSB2YXJpYWJsZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbWVyZW5kZXJlci5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG4vKipcbiAqIEEgbW9kZWwgZm9yIGEgdmFyaWFibGUgZXhwbG9yZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZXNNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkVmFyaWFibGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFtdO1xuICAgICAgICB0aGlzLl92YXJpYWJsZUV4cGFuZGVkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIHNjb3Blcy5cbiAgICAgKi9cbiAgICBnZXQgc2NvcGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2NvcGVzLlxuICAgICAqL1xuICAgIHNldCBzY29wZXMoc2NvcGVzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc2NvcGVzO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkLmVtaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgY3VycmVudCB2YXJpYWJsZSBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBnZXQgY2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGN1cnJlbnQgdmFyaWFibGUgaGFzIGJlZW4gZXhwYW5kZWQuXG4gICAgICovXG4gICAgZ2V0IHZhcmlhYmxlRXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YXJpYWJsZUV4cGFuZGVkO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRWYXJpYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkVmFyaWFibGU7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZFZhcmlhYmxlKHNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZFZhcmlhYmxlID0gc2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBhbmQgYSB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YXJpYWJsZSBUaGUgdmFyaWFibGUgdG8gZXhwYW5kLlxuICAgICAqL1xuICAgIGV4cGFuZFZhcmlhYmxlKHZhcmlhYmxlKSB7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlRXhwYW5kZWQuZW1pdCh2YXJpYWJsZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwuanMubWFwIiwiaW1wb3J0IHsgUmVhY3RXaWRnZXQsIFVzZVNpZ25hbCB9IGZyb20gJ0BqdXB5dGVybGFiL2FwcHV0aWxzJztcbmltcG9ydCB7IG51bGxUcmFuc2xhdG9yIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdHJhbnNsYXRpb24nO1xuaW1wb3J0IHsgSFRNTFNlbGVjdCB9IGZyb20gJ0BqdXB5dGVybGFiL3VpLWNvbXBvbmVudHMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBBIFJlYWN0IGNvbXBvbmVudCB0byBoYW5kbGUgc2NvcGUgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGNvbXBvbmVudCBwcm9wcy5cbiAqIEBwYXJhbSBwcm9wcy5tb2RlbCBUaGUgdmFyaWFibGVzIG1vZGVsLlxuICogQHBhcmFtIHByb3BzLnRyZWUgVGhlIHZhcmlhYmxlcyB0cmVlIHdpZGdldC5cbiAqIEBwYXJhbSBwcm9wcy5ncmlkIFRoZSB2YXJpYWJsZXMgZ3JpZCB3aWRnZXQuXG4gKiBAcGFyYW0gcHJvcHMudHJhbnMgVGhlIHRyYW5zbGF0aW9uIGJ1bmRsZS5cbiAqL1xuY29uc3QgU2NvcGVTd2l0Y2hlckNvbXBvbmVudCA9ICh7IG1vZGVsLCB0cmVlLCBncmlkLCB0cmFucyB9KSA9PiB7XG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZSgnLScpO1xuICAgIGNvbnN0IHNjb3BlcyA9IG1vZGVsLnNjb3BlcztcbiAgICBjb25zdCBvbkNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB0cmVlLnNjb3BlID0gdmFsdWU7XG4gICAgICAgIGdyaWQuc2NvcGUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChIVE1MU2VsZWN0LCB7IG9uQ2hhbmdlOiBvbkNoYW5nZSwgdmFsdWU6IHZhbHVlLCBcImFyaWEtbGFiZWxcIjogdHJhbnMuX18oJ1Njb3BlJykgfSwgc2NvcGVzLm1hcChzY29wZSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7IGtleTogc2NvcGUubmFtZSwgdmFsdWU6IHNjb3BlLm5hbWUgfSwgdHJhbnMuX18oc2NvcGUubmFtZSkpKSkpKTtcbn07XG4vKipcbiAqIEEgd2lkZ2V0IHRvIHN3aXRjaCBiZXR3ZWVuIHNjb3Blcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNjb3BlU3dpdGNoZXIgZXh0ZW5kcyBSZWFjdFdpZGdldCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgc2NvcGUgc3dpdGNoZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5zdGFudGlhdGlvbiBvcHRpb25zIGZvciBhIFNjb3BlU3dpdGNoZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNsYXRvciwgbW9kZWwsIHRyZWUsIGdyaWQgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuX3RyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLl9ncmlkID0gZ3JpZDtcbiAgICAgICAgdGhpcy5fdHJhbnMgPSAodHJhbnNsYXRvciB8fCBudWxsVHJhbnNsYXRvcikubG9hZCgnanVweXRlcmxhYicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIHNjb3BlIHN3aXRjaGVyLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFVzZVNpZ25hbCwgeyBzaWduYWw6IHRoaXMuX21vZGVsLmNoYW5nZWQsIGluaXRpYWxTZW5kZXI6IHRoaXMuX21vZGVsIH0sICgpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFNjb3BlU3dpdGNoZXJDb21wb25lbnQsIHsgbW9kZWw6IHRoaXMuX21vZGVsLCB0cmFuczogdGhpcy5fdHJhbnMsIHRyZWU6IHRoaXMuX3RyZWUsIGdyaWQ6IHRoaXMuX2dyaWQgfSkpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgUmVhY3RXaWRnZXQgfSBmcm9tICdAanVweXRlcmxhYi9hcHB1dGlscyc7XG5pbXBvcnQgeyBudWxsVHJhbnNsYXRvciB9IGZyb20gJ0BqdXB5dGVybGFiL3RyYW5zbGF0aW9uJztcbmltcG9ydCB7IGNhcmV0RG93bkVtcHR5SWNvbiwgc2VhcmNoSWNvbiB9IGZyb20gJ0BqdXB5dGVybGFiL3VpLWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgQXJyYXlFeHQgfSBmcm9tICdAbHVtaW5vL2FsZ29yaXRobSc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbnZlcnRUeXBlIH0gZnJvbSAnLic7XG5pbXBvcnQgeyBEZWJ1Z2dlciB9IGZyb20gJy4uLy4uL2RlYnVnZ2VyJztcbi8qKlxuICogVGhlIGJvZHkgZm9yIHRyZWUgb2YgdmFyaWFibGVzLlxuICovXG5leHBvcnQgY2xhc3MgVmFyaWFibGVzQm9keVRyZWUgZXh0ZW5kcyBSZWFjdFdpZGdldCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgQm9keSBmb3IgdGhlIHRyZWUgb2YgdmFyaWFibGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGluc3RhbnRpYXRpb24gb3B0aW9ucyBmb3IgYSBWYXJpYWJsZXNCb2R5VHJlZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3Njb3BlID0gJyc7XG4gICAgICAgIHRoaXMuX3Njb3BlcyA9IFtdO1xuICAgICAgICB0aGlzLl9maWx0ZXIgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2NvbW1hbmRzID0gb3B0aW9ucy5jb21tYW5kcztcbiAgICAgICAgdGhpcy5fc2VydmljZSA9IG9wdGlvbnMuc2VydmljZTtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRvciA9IG9wdGlvbnMudHJhbnNsYXRvcjtcbiAgICAgICAgY29uc3QgbW9kZWwgPSAodGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWwpO1xuICAgICAgICBtb2RlbC5jaGFuZ2VkLmNvbm5lY3QodGhpcy5fdXBkYXRlU2NvcGVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygnanAtRGVidWdnZXJWYXJpYWJsZXMtYm9keScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIFZhcmlhYmxlc0JvZHlUcmVlLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzY29wZSA9IChfYSA9IHRoaXMuX3Njb3Blcy5maW5kKHNjb3BlID0+IHNjb3BlLm5hbWUgPT09IHRoaXMuX3Njb3BlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fc2NvcGVzWzBdO1xuICAgICAgICByZXR1cm4gc2NvcGUgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChWYXJpYWJsZXNDb21wb25lbnQsIHsga2V5OiBzY29wZS5uYW1lLCBjb21tYW5kczogdGhpcy5fY29tbWFuZHMsIHNlcnZpY2U6IHRoaXMuX3NlcnZpY2UsIGRhdGE6IHNjb3BlLnZhcmlhYmxlcywgZmlsdGVyOiB0aGlzLl9maWx0ZXIsIHRyYW5zbGF0b3I6IHRoaXMuX3RyYW5zbGF0b3IsIGhhbmRsZVNlbGVjdFZhcmlhYmxlOiB2YXJpYWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZWxlY3RlZFZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgICAgICAgICB9IH0pKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YXJpYWJsZSBmaWx0ZXIgbGlzdC5cbiAgICAgKi9cbiAgICBzZXQgZmlsdGVyKGZpbHRlcikge1xuICAgICAgICB0aGlzLl9maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBzY29wZVxuICAgICAqL1xuICAgIHNldCBzY29wZShzY29wZSkge1xuICAgICAgICB0aGlzLl9zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNjb3BlcyBhbmQgdGhlIHRyZWUgb2YgdmFyaWFibGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIFRoZSB2YXJpYWJsZXMgbW9kZWwuXG4gICAgICovXG4gICAgX3VwZGF0ZVNjb3Blcyhtb2RlbCkge1xuICAgICAgICBpZiAoQXJyYXlFeHQuc2hhbGxvd0VxdWFsKHRoaXMuX3Njb3BlcywgbW9kZWwuc2NvcGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Njb3BlcyA9IG1vZGVsLnNjb3BlcztcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG59XG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRvIGRpc3BsYXkgYSBsaXN0IG9mIHZhcmlhYmxlcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGNvbXBvbmVudCBwcm9wcy5cbiAqIEBwYXJhbSBwcm9wcy5kYXRhIEFuIGFycmF5IG9mIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSBwcm9wcy5zZXJ2aWNlIFRoZSBkZWJ1Z2dlciBzZXJ2aWNlLlxuICogQHBhcmFtIHByb3BzLmZpbHRlciBPcHRpb25hbCB2YXJpYWJsZSBmaWx0ZXIgbGlzdC5cbiAqL1xuY29uc3QgVmFyaWFibGVzQ29tcG9uZW50ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjb21tYW5kcywgZGF0YSwgc2VydmljZSwgZmlsdGVyLCB0cmFuc2xhdG9yLCBoYW5kbGVTZWxlY3RWYXJpYWJsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgW3ZhcmlhYmxlcywgc2V0VmFyaWFibGVzXSA9IHVzZVN0YXRlKGRhdGEpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldFZhcmlhYmxlcyhkYXRhKTtcbiAgICB9LCBbZGF0YV0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIG51bGwsIHZhcmlhYmxlcyA9PT0gbnVsbCB8fCB2YXJpYWJsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhcmlhYmxlcy5maWx0ZXIodmFyaWFibGUgPT4gIShmaWx0ZXIgfHwgbmV3IFNldCgpKS5oYXModmFyaWFibGUuZXZhbHVhdGVOYW1lIHx8ICcnKSkubWFwKHZhcmlhYmxlID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7dmFyaWFibGUubmFtZX0tJHt2YXJpYWJsZS5ldmFsdWF0ZU5hbWV9LSR7dmFyaWFibGUudHlwZX0tJHt2YXJpYWJsZS52YWx1ZX0tJHt2YXJpYWJsZS52YXJpYWJsZXNSZWZlcmVuY2V9YDtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFZhcmlhYmxlQ29tcG9uZW50LCB7IGtleToga2V5LCBjb21tYW5kczogY29tbWFuZHMsIGRhdGE6IHZhcmlhYmxlLCBzZXJ2aWNlOiBzZXJ2aWNlLCBmaWx0ZXI6IGZpbHRlciwgdHJhbnNsYXRvcjogdHJhbnNsYXRvciwgb25TZWxlY3Q6IGhhbmRsZVNlbGVjdFZhcmlhYmxlIH0pKTtcbiAgICB9KSkpO1xufTtcbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdG8gZGlzcGxheSBvbmUgbm9kZSB2YXJpYWJsZSBpbiB0cmVlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBUaGUgY29tcG9uZW50IHByb3BzLlxuICogQHBhcmFtIHByb3BzLmRhdGEgQW4gYXJyYXkgb2YgdmFyaWFibGVzLlxuICogQHBhcmFtIHByb3BzLnNlcnZpY2UgVGhlIGRlYnVnZ2VyIHNlcnZpY2UuXG4gKiBAcGFyYW0gcHJvcHMuZmlsdGVyIE9wdGlvbmFsIHZhcmlhYmxlIGZpbHRlciBsaXN0LlxuICovXG5jb25zdCBWYXJpYWJsZUNvbXBvbmVudCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY29tbWFuZHMsIGRhdGEsIHNlcnZpY2UsIGZpbHRlciwgdHJhbnNsYXRvciwgb25TZWxlY3QgfSA9IHByb3BzO1xuICAgIGNvbnN0IFt2YXJpYWJsZV0gPSB1c2VTdGF0ZShkYXRhKTtcbiAgICBjb25zdCBbZXhwYW5kZWQsIHNldEV4cGFuZGVkXSA9IHVzZVN0YXRlKCk7XG4gICAgY29uc3QgW3ZhcmlhYmxlcywgc2V0VmFyaWFibGVzXSA9IHVzZVN0YXRlKCk7XG4gICAgY29uc3Qgc3R5bGVOYW1lID0ge1xuICAgICAgICBjb2xvcjogJ3ZhcigtLWpwLW1pcnJvci1lZGl0b3ItYXR0cmlidXRlLWNvbG9yKSdcbiAgICB9O1xuICAgIGNvbnN0IHN0eWxlVHlwZSA9IHtcbiAgICAgICAgY29sb3I6ICd2YXIoLS1qcC1taXJyb3ItZWRpdG9yLXN0cmluZy1jb2xvciknXG4gICAgfTtcbiAgICBjb25zdCBvblNlbGVjdGlvbiA9IG9uU2VsZWN0ICE9PSBudWxsICYmIG9uU2VsZWN0ICE9PSB2b2lkIDAgPyBvblNlbGVjdCA6ICgoKSA9PiB2b2lkIDApO1xuICAgIGNvbnN0IGV4cGFuZGFibGUgPSB2YXJpYWJsZS52YXJpYWJsZXNSZWZlcmVuY2UgIT09IDAgfHwgdmFyaWFibGUudHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCB0cmFucyA9ICh0cmFuc2xhdG9yICE9PSBudWxsICYmIHRyYW5zbGF0b3IgIT09IHZvaWQgMCA/IHRyYW5zbGF0b3IgOiBudWxsVHJhbnNsYXRvcikubG9hZCgnanVweXRlcmxhYicpO1xuICAgIGNvbnN0IG9uVmFyaWFibGVDbGlja2VkID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKCFleHBhbmRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gYXdhaXQgc2VydmljZS5pbnNwZWN0VmFyaWFibGUodmFyaWFibGUudmFyaWFibGVzUmVmZXJlbmNlKTtcbiAgICAgICAgc2V0RXhwYW5kZWQoIWV4cGFuZGVkKTtcbiAgICAgICAgc2V0VmFyaWFibGVzKHZhcmlhYmxlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7IG9uQ2xpY2s6IChlKSA9PiBvblZhcmlhYmxlQ2xpY2tlZChlKSwgb25Nb3VzZURvd246ICgpID0+IHtcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uKHZhcmlhYmxlKTtcbiAgICAgICAgfSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KGNhcmV0RG93bkVtcHR5SWNvbi5yZWFjdCwgeyB2aXNpYmlsaXR5OiBleHBhbmRhYmxlID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIHN0eWxlc2hlZXQ6IFwibWVudUl0ZW1cIiwgdGFnOiBcInNwYW5cIiwgdHJhbnNmb3JtOiBleHBhbmRlZCA/ICdyb3RhdGUoMGRlZyknIDogJ3JvdGF0ZSgtOTBkZWcpJyB9KSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBzdHlsZTogc3R5bGVOYW1lIH0sIHZhcmlhYmxlLm5hbWUpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIjogXCIpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IHN0eWxlOiBzdHlsZVR5cGUgfSwgY29udmVydFR5cGUodmFyaWFibGUpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwianAtRGVidWdnZXJWYXJpYWJsZXMtaHNwYWNlclwiIH0pLFxuICAgICAgICBzZXJ2aWNlLm1vZGVsLmhhc1JpY2hWYXJpYWJsZVJlbmRlcmluZyAmJlxuICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHJpY2ggZGlzcGxheSBmb3Igc3BlY2lhbCBlbnRyaWVzXG4gICAgICAgICAgICAvLyBkZWJ1Z3B5OiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L2RlYnVncHkvYmxvYi9jZjBkNjg0NTY2ZWRjMzM5NTQ1YjE2MWRhN2MzZGZjNDhhZjdjN2Q1L3NyYy9kZWJ1Z3B5L192ZW5kb3JlZC9weWRldmQvX3B5ZGV2ZF9idW5kbGUvcHlkZXZkX3V0aWxzLnB5I0wzNTlcbiAgICAgICAgICAgICFbXG4gICAgICAgICAgICAgICAgJ3NwZWNpYWwgdmFyaWFibGVzJyxcbiAgICAgICAgICAgICAgICAncHJvdGVjdGVkIHZhcmlhYmxlcycsXG4gICAgICAgICAgICAgICAgJ2Z1bmN0aW9uIHZhcmlhYmxlcycsXG4gICAgICAgICAgICAgICAgJ2NsYXNzIHZhcmlhYmxlcydcbiAgICAgICAgICAgIF0uaW5jbHVkZXModmFyaWFibGUubmFtZSkgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwianAtRGVidWdnZXJWYXJpYWJsZXMtcmVuZGVyVmFyaWFibGVcIiwgZGlzYWJsZWQ6ICFjb21tYW5kcy5pc0VuYWJsZWQoRGVidWdnZXIuQ29tbWFuZElEcy5yZW5kZXJNaW1lVmFyaWFibGUsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB2YXJpYWJsZS5uYW1lLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlc1JlZmVyZW5jZTogdmFyaWFibGUudmFyaWFibGVzUmVmZXJlbmNlXG4gICAgICAgICAgICB9KSwgb25DbGljazogZSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBvblNlbGVjdGlvbih2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgY29tbWFuZHNcbiAgICAgICAgICAgICAgICAgICAgLmV4ZWN1dGUoRGVidWdnZXIuQ29tbWFuZElEcy5yZW5kZXJNaW1lVmFyaWFibGUsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFyaWFibGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzUmVmZXJlbmNlOiB2YXJpYWJsZS52YXJpYWJsZXNSZWZlcmVuY2VcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHJlbmRlciB2YXJpYWJsZSAke3ZhcmlhYmxlLm5hbWV9YCwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRpdGxlOiB0cmFucy5fXygnUmVuZGVyIHZhcmlhYmxlJykgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoc2VhcmNoSWNvbi5yZWFjdCwgeyBzdHlsZXNoZWV0OiBcIm1lbnVJdGVtXCIsIHRhZzogXCJzcGFuXCIgfSkpKSxcbiAgICAgICAgZXhwYW5kZWQgJiYgdmFyaWFibGVzICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFZhcmlhYmxlc0NvbXBvbmVudCwgeyBrZXk6IHZhcmlhYmxlLm5hbWUsIGNvbW1hbmRzOiBjb21tYW5kcywgZGF0YTogdmFyaWFibGVzLCBzZXJ2aWNlOiBzZXJ2aWNlLCBmaWx0ZXI6IGZpbHRlciwgdHJhbnNsYXRvcjogdHJhbnNsYXRvciB9KSkpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmVlLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ0BsdW1pbm8vc2lnbmFsaW5nJztcbmltcG9ydCB7IERlYnVnZ2VyIH0gZnJvbSAnLi9kZWJ1Z2dlcic7XG4vKipcbiAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIElEZWJ1Z2dlciBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWJ1Z2dlclNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgbmV3IERlYnVnZ2VyU2VydmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbnN0YW50aWF0aW9uIG9wdGlvbnMgZm9yIGEgRGVidWdnZXJTZXJ2aWNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5fZXZlbnRNZXNzYWdlID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZXNzaW9uQ2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IG9wdGlvbnMuY29uZmlnO1xuICAgICAgICAvLyBBdm9pZHMgc2V0dGluZyBzZXNzaW9uIHdpdGggaW52YWxpZCBjbGllbnRcbiAgICAgICAgLy8gc2Vzc2lvbiBzaG91bGQgYmUgc2V0IG9ubHkgd2hlbiBhIG5vdGVib29rIG9yXG4gICAgICAgIC8vIGEgY29uc29sZSBnZXQgdGhlIGZvY3VzLlxuICAgICAgICAvLyBUT0RPOiBhbHNvIGNoZWNrcyB0aGF0IHRoZSBub3RlYm9vayBvciBjb25zb2xlXG4gICAgICAgIC8vIHJ1bnMgYSBrZXJuZWwgd2l0aCBkZWJ1Z2dpbmcgYWJpbGl0eVxuICAgICAgICB0aGlzLl9zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3BlY3NNYW5hZ2VyID0gKF9hID0gb3B0aW9ucy5zcGVjc01hbmFnZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgIHRoaXMuX21vZGVsID0gbmV3IERlYnVnZ2VyLk1vZGVsKCk7XG4gICAgICAgIHRoaXMuX2RlYnVnZ2VyU291cmNlcyA9IChfYiA9IG9wdGlvbnMuZGVidWdnZXJTb3VyY2VzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgZW1pdHRlZCBmb3IgZGVidWcgZXZlbnQgbWVzc2FnZXMuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZGVidWcgc2VydmljZSBpcyBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgZGVidWdnZXIgaXMgc3RhcnRlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNTdGFydGVkKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzU3RhcnRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgZGVidWdnZXIgaXMgcGF1c2luZyBvbiBleGNlcHRpb25zLlxuICAgICAqL1xuICAgIGdldCBpc1BhdXNpbmdPbkV4Y2VwdGlvbnMoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCBrZXJuZWwgPSAoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iua2VybmVsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubmFtZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJyc7XG4gICAgICAgIGlmIChrZXJuZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcEZpbGVQYXJhbXMgPSB0aGlzLl9jb25maWcuZ2V0VG1wRmlsZVBhcmFtcyhrZXJuZWwpO1xuICAgICAgICAgICAgaWYgKHRtcEZpbGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChfZiA9IChfZSA9IHRoaXMuX3Nlc3Npb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5wYXVzaW5nT25FeGNlcHRpb25zLmluY2x1ZGVzKHRtcEZpbGVQYXJhbXMucHJlZml4KSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVidWdnZXIgc2VydmljZSdzIG1vZGVsLlxuICAgICAqL1xuICAgIGdldCBtb2RlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlYnVnIHNlc3Npb24uXG4gICAgICovXG4gICAgZ2V0IHNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGRlYnVnIHNlc3Npb24gdG8gdGhlIGdpdmVuIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXNzaW9uIC0gdGhlIG5ldyBkZWJ1Z2dlciBzZXNzaW9uLlxuICAgICAqL1xuICAgIHNldCBzZXNzaW9uKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbiA9PT0gc2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXNzaW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgKF9hID0gdGhpcy5fc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2ZW50TWVzc2FnZS5jb25uZWN0KChfLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmV2ZW50ID09PSAnc3RvcHBlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbC5zdG9wcGVkVGhyZWFkcy5hZGQoZXZlbnQuYm9keS50aHJlYWRJZCk7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLl9nZXRBbGxGcmFtZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmV2ZW50ID09PSAnY29udGludWVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGVsLnN0b3BwZWRUaHJlYWRzLmRlbGV0ZShldmVudC5ib2R5LnRocmVhZElkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhck1vZGVsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJTaWduYWxzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ldmVudE1lc3NhZ2UuZW1pdChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZXNzaW9uQ2hhbmdlZC5lbWl0KHNlc3Npb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgZW1pdHRlZCB1cG9uIHNlc3Npb24gY2hhbmdlZC5cbiAgICAgKi9cbiAgICBnZXQgc2Vzc2lvbkNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uQ2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB0aGUgZGVidWcgc2VydmljZS5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIFNpZ25hbC5jbGVhckRhdGEodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGFuIGlkIGJhc2VkIG9uIHRoZSBnaXZlbiBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgVGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGdldENvZGVJZChjb2RlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuZ2V0Q29kZUlkKGNvZGUsIChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5rZXJuZWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5uYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGVyZSBleGlzdHMgYSB0aHJlYWQgaW4gc3RvcHBlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBoYXNTdG9wcGVkVGhyZWFkcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9ICgoX2EgPSB0aGlzLl9tb2RlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3BwZWRUaHJlYWRzLnNpemUpID4gMCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3Qgd2hldGhlciBkZWJ1Z2dpbmcgaXMgYXZhaWxhYmxlIGZvciB0aGUgc2Vzc2lvbiBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIHNlc3Npb24gY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBpc0F2YWlsYWJsZShjb25uZWN0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKCF0aGlzLl9zcGVjc01hbmFnZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX3NwZWNzTWFuYWdlci5yZWFkeTtcbiAgICAgICAgY29uc3Qga2VybmVsID0gY29ubmVjdGlvbiA9PT0gbnVsbCB8fCBjb25uZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmtlcm5lbDtcbiAgICAgICAgaWYgKCFrZXJuZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0ga2VybmVsLm5hbWU7XG4gICAgICAgIGlmICghKChfYSA9IHRoaXMuX3NwZWNzTWFuYWdlci5zcGVjcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmtlcm5lbHNwZWNzW25hbWVdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhKChfZCA9IChfYyA9IChfYiA9IHRoaXMuX3NwZWNzTWFuYWdlci5zcGVjcy5rZXJuZWxzcGVjc1tuYW1lXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbJ2RlYnVnZ2VyJ10pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIHRoZSBicmVha3BvaW50cyBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBhc3luYyBjbGVhckJyZWFrcG9pbnRzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNTdGFydGVkKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vZGVsLmJyZWFrcG9pbnRzLmJyZWFrcG9pbnRzLmZvckVhY2goKF8sIHBhdGgsIG1hcCkgPT4ge1xuICAgICAgICAgICAgdm9pZCB0aGlzLl9zZXRCcmVha3BvaW50cyhbXSwgcGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgYnBNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX21vZGVsLmJyZWFrcG9pbnRzLnJlc3RvcmVCcmVha3BvaW50cyhicE1hcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRpbnVlcyB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjdXJyZW50IHRocmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBjb250aW51ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgZGVidWdnZXIgc2Vzc2lvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmRSZXF1ZXN0KCdjb250aW51ZScsIHtcbiAgICAgICAgICAgICAgICB0aHJlYWRJZDogdGhpcy5fY3VycmVudFRocmVhZCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX21vZGVsLnN0b3BwZWRUaHJlYWRzLmRlbGV0ZSh0aGlzLl9jdXJyZW50VGhyZWFkKCkpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJNb2RlbCgpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJTaWduYWxzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6JywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjb250ZW50IG9mIGEgc291cmNlIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U291cmNlKHNvdXJjZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgZGVidWdnZXIgc2Vzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcGx5ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmRSZXF1ZXN0KCdzb3VyY2UnLCB7XG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBzb3VyY2VSZWZlcmVuY2U6IChfYSA9IHNvdXJjZS5zb3VyY2VSZWZlcmVuY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcGx5LmJvZHkpLCB7IHBhdGg6IChfYiA9IHNvdXJjZS5wYXRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYW4gZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIGV2YWx1YXRlIGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGV2YWx1YXRlKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgZGVidWdnZXIgc2Vzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lSWQgPSAoX2EgPSB0aGlzLm1vZGVsLmNhbGxzdGFjay5mcmFtZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkO1xuICAgICAgICBjb25zdCByZXBseSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kUmVxdWVzdCgnZXZhbHVhdGUnLCB7XG4gICAgICAgICAgICBjb250ZXh0OiAncmVwbCcsXG4gICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgZnJhbWVJZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXBseS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgdGhlIGZyYW1lcyB0byByZXRyaWV2ZSB0aGUgbGF0ZXN0IHN0YXRlIG9mIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgdGhpcy5fY2xlYXJNb2RlbCgpO1xuICAgICAgICBhd2FpdCB0aGlzLl9nZXRBbGxGcmFtZXMoKTtcbiAgICAgICAgcmV0dXJuIHJlcGx5LmJvZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBjdXJyZW50IHRocmVhZCBydW4gYWdhaW4gZm9yIG9uZSBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIGRlYnVnZ2VyIHNlc3Npb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kUmVxdWVzdCgnbmV4dCcsIHtcbiAgICAgICAgICAgICAgICB0aHJlYWRJZDogdGhpcy5fY3VycmVudFRocmVhZCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjonLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCByaWNoIHJlcHJlc2VudGF0aW9uIG9mIGEgdmFyaWFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVOYW1lIFRoZSB2YXJpYWJsZSBuYW1lIHRvIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gZnJhbWVJZCBUaGUgY3VycmVudCBmcmFtZSBpZCBpbiB3aGljaCB0byByZXF1ZXN0IHRoZSB2YXJpYWJsZVxuICAgICAqIEByZXR1cm5zIFRoZSBtaW1lIHJlbmRlcmVyIGRhdGEgbW9kZWxcbiAgICAgKi9cbiAgICBhc3luYyBpbnNwZWN0UmljaFZhcmlhYmxlKHZhcmlhYmxlTmFtZSwgZnJhbWVJZCkge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgZGVidWdnZXIgc2Vzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcGx5ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmRSZXF1ZXN0KCdyaWNoSW5zcGVjdFZhcmlhYmxlcycsIHtcbiAgICAgICAgICAgIHZhcmlhYmxlTmFtZSxcbiAgICAgICAgICAgIGZyYW1lSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXBseS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbHkuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXBseS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHZhcmlhYmxlcyBmb3IgYSBnaXZlbiB2YXJpYWJsZSByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVzUmVmZXJlbmNlIFRoZSB2YXJpYWJsZSByZWZlcmVuY2UgdG8gcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnNwZWN0VmFyaWFibGUodmFyaWFibGVzUmVmZXJlbmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBkZWJ1Z2dlciBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVwbHkgPSBhd2FpdCB0aGlzLnNlc3Npb24uc2VuZFJlcXVlc3QoJ3ZhcmlhYmxlcycsIHtcbiAgICAgICAgICAgIHZhcmlhYmxlc1JlZmVyZW5jZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlcGx5LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBseS5ib2R5LnZhcmlhYmxlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXBseS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBhbGwgdGhlIGRlZmluZWQgdmFyaWFibGVzIGFuZCBkaXNwbGF5IHRoZW0gaW4gdGhlXG4gICAgICogdGFibGUgdmlldy5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNwbGF5RGVmaW5lZFZhcmlhYmxlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIGRlYnVnZ2VyIHNlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnNwZWN0UmVwbHkgPSBhd2FpdCB0aGlzLnNlc3Npb24uc2VuZFJlcXVlc3QoJ2luc3BlY3RWYXJpYWJsZXMnLCB7fSk7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IGluc3BlY3RSZXBseS5ib2R5LnZhcmlhYmxlcztcbiAgICAgICAgY29uc3QgdmFyaWFibGVTY29wZXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0dsb2JhbHMnLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX21vZGVsLnZhcmlhYmxlcy5zY29wZXMgPSB2YXJpYWJsZVNjb3BlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdGFydCB0aGUgZGVidWdnZXIuXG4gICAgICovXG4gICAgYXN5bmMgcmVzdGFydCgpIHtcbiAgICAgICAgY29uc3QgeyBicmVha3BvaW50cyB9ID0gdGhpcy5fbW9kZWwuYnJlYWtwb2ludHM7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcCgpO1xuICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Jlc3RvcmVCcmVha3BvaW50cyhicmVha3BvaW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIHN0YXRlIG9mIGEgZGVidWcgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdXRvU3RhcnQgLSBJZiB0cnVlLCBzdGFydHMgdGhlIGRlYnVnZ2VyIGlmIGl0IGhhcyBub3QgYmVlbiBzdGFydGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc3RvcmVTdGF0ZShhdXRvU3RhcnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwgfHwgIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcGx5ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJlc3RvcmVTdGF0ZSgpO1xuICAgICAgICBjb25zdCB7IGJvZHkgfSA9IHJlcGx5O1xuICAgICAgICBjb25zdCBicmVha3BvaW50cyA9IHRoaXMuX21hcEJyZWFrcG9pbnRzKGJvZHkuYnJlYWtwb2ludHMpO1xuICAgICAgICBjb25zdCBzdG9wcGVkVGhyZWFkcyA9IG5ldyBTZXQoYm9keS5zdG9wcGVkVGhyZWFkcyk7XG4gICAgICAgIHRoaXMuX21vZGVsLmhhc1JpY2hWYXJpYWJsZVJlbmRlcmluZyA9IGJvZHkucmljaFJlbmRlcmluZyA9PT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY29uZmlnLnNldEhhc2hQYXJhbXMoe1xuICAgICAgICAgICAga2VybmVsOiAoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iua2VybmVsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubmFtZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJycsXG4gICAgICAgICAgICBtZXRob2Q6IGJvZHkuaGFzaE1ldGhvZCxcbiAgICAgICAgICAgIHNlZWQ6IGJvZHkuaGFzaFNlZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NvbmZpZy5zZXRUbXBGaWxlUGFyYW1zKHtcbiAgICAgICAgICAgIGtlcm5lbDogKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY29ubmVjdGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmtlcm5lbCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLm5hbWUpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6ICcnLFxuICAgICAgICAgICAgcHJlZml4OiBib2R5LnRtcEZpbGVQcmVmaXgsXG4gICAgICAgICAgICBzdWZmaXg6IGJvZHkudG1wRmlsZVN1ZmZpeFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbW9kZWwuc3RvcHBlZFRocmVhZHMgPSBzdG9wcGVkVGhyZWFkcztcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RhcnRlZCAmJiAoYXV0b1N0YXJ0IHx8IHN0b3BwZWRUaHJlYWRzLnNpemUgIT09IDApKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydGVkIHx8IGF1dG9TdGFydCkge1xuICAgICAgICAgICAgdGhpcy5fbW9kZWwudGl0bGUgPSB0aGlzLmlzU3RhcnRlZFxuICAgICAgICAgICAgICAgID8gKChfayA9IChfaiA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5uYW1lKSB8fCAnLSdcbiAgICAgICAgICAgICAgICA6ICctJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVidWdnZXJTb3VyY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHRoaXMuX2ZpbHRlckJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX21vZGVsLmJyZWFrcG9pbnRzLnJlc3RvcmVCcmVha3BvaW50cyhmaWx0ZXJlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tb2RlbC5icmVha3BvaW50cy5yZXN0b3JlQnJlYWtwb2ludHMoYnJlYWtwb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wcGVkVGhyZWFkcy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9nZXRBbGxGcmFtZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJNb2RlbCgpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJTaWduYWxzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgZGVidWdnZXIuXG4gICAgICogUHJlY29uZGl0aW9uOiAhaXNTdGFydGVkXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBkZWJ1Z2dlciBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgY3VycmVudCB0aHJlYWQgc3RlcCBpbiBhIGZ1bmN0aW9uIC8gbWV0aG9kIGlmIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0ZXBJbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgZGVidWdnZXIgc2Vzc2lvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmRSZXF1ZXN0KCdzdGVwSW4nLCB7XG4gICAgICAgICAgICAgICAgdGhyZWFkSWQ6IHRoaXMuX2N1cnJlbnRUaHJlYWQoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6JywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBjdXJyZW50IHRocmVhZCBzdGVwIG91dCBhIGZ1bmN0aW9uIC8gbWV0aG9kIGlmIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0ZXBPdXQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIGRlYnVnZ2VyIHNlc3Npb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kUmVxdWVzdCgnc3RlcE91dCcsIHtcbiAgICAgICAgICAgICAgICB0aHJlYWRJZDogdGhpcy5fY3VycmVudFRocmVhZCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjonLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIGRlYnVnZ2VyLlxuICAgICAqIFByZWNvbmRpdGlvbjogaXNTdGFydGVkXG4gICAgICovXG4gICAgYXN5bmMgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIGRlYnVnZ2VyIHNlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlc3Npb24uc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX21vZGVsLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFsbCBicmVha3BvaW50cyBhdCBvbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgLSBUaGUgY29kZSBpbiB0aGUgY2VsbCB3aGVyZSB0aGUgYnJlYWtwb2ludHMgYXJlIHNldC5cbiAgICAgKiBAcGFyYW0gYnJlYWtwb2ludHMgLSBUaGUgbGlzdCBvZiBicmVha3BvaW50cyB0byBzZXQuXG4gICAgICogQHBhcmFtIHBhdGggLSBPcHRpb25hbCBwYXRoIHRvIHRoZSBmaWxlIHdoZXJlIHRvIHNldCB0aGUgYnJlYWtwb2ludHMuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQnJlYWtwb2ludHMoY29kZSwgYnJlYWtwb2ludHMsIHBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoISgoX2EgPSB0aGlzLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1N0YXJ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gKGF3YWl0IHRoaXMuX2R1bXBDZWxsKGNvZGUpKS5ib2R5LnNvdXJjZVBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLnNlc3Npb24ucmVzdG9yZVN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsQnJlYWtwb2ludHMgPSBicmVha3BvaW50c1xuICAgICAgICAgICAgLmZpbHRlcigoeyBsaW5lIH0pID0+IHR5cGVvZiBsaW5lID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIC5tYXAoKHsgbGluZSB9KSA9PiAoeyBsaW5lOiBsaW5lIH0pKTtcbiAgICAgICAgY29uc3QgcmVtb3RlQnJlYWtwb2ludHMgPSB0aGlzLl9tYXBCcmVha3BvaW50cyhzdGF0ZS5ib2R5LmJyZWFrcG9pbnRzKTtcbiAgICAgICAgLy8gU2V0IHRoZSBsb2NhbCBjb3B5IG9mIGJyZWFrcG9pbnRzIHRvIHJlZmxlY3Qgb25seSBlZGl0b3JzIHRoYXQgZXhpc3QuXG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z2dlclNvdXJjZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gdGhpcy5fZmlsdGVyQnJlYWtwb2ludHMocmVtb3RlQnJlYWtwb2ludHMpO1xuICAgICAgICAgICAgdGhpcy5fbW9kZWwuYnJlYWtwb2ludHMucmVzdG9yZUJyZWFrcG9pbnRzKGZpbHRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21vZGVsLmJyZWFrcG9pbnRzLnJlc3RvcmVCcmVha3BvaW50cyhyZW1vdGVCcmVha3BvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBrZXJuZWwncyBicmVha3BvaW50cyBmb3IgdGhpcyBwYXRoLlxuICAgICAgICBjb25zdCByZXBseSA9IGF3YWl0IHRoaXMuX3NldEJyZWFrcG9pbnRzKGxvY2FsQnJlYWtwb2ludHMsIHBhdGgpO1xuICAgICAgICBjb25zdCB1cGRhdGVkQnJlYWtwb2ludHMgPSByZXBseS5ib2R5LmJyZWFrcG9pbnRzLmZpbHRlcigodmFsLCBfLCBhcnIpID0+IGFyci5maW5kSW5kZXgoZWwgPT4gZWwubGluZSA9PT0gdmFsLmxpbmUpID4gLTEpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIG1vZGVsIGFuZCBmaW5pc2gga2VybmVsIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIHRoaXMuX21vZGVsLmJyZWFrcG9pbnRzLnNldEJyZWFrcG9pbnRzKHBhdGgsIHVwZGF0ZWRCcmVha3BvaW50cyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kUmVxdWVzdCgnY29uZmlndXJhdGlvbkRvbmUnLCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgcGF1c2luZyBvbiBleGNlcHRpb25zIGlzIHN1cHBvcnRlZCBieSB0aGUga2VybmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBwYXVzZU9uRXhjZXB0aW9uc0lzVmFsaWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydGVkKSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXhjZXB0aW9uQnJlYWtwb2ludEZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHBhdXNpbmcgb24gZXhjZXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmFibGUgLSBXaGV0aGVyIHRvIGVuYmFsZSBvciBkaXNhYmxlIHBhdXNpbmcgb24gZXhjZXB0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBwYXVzZU9uRXhjZXB0aW9ucyhlbmFibGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNTdGFydGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtlcm5lbCA9IChfZSA9IChfZCA9IChfYyA9IChfYiA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5rZXJuZWwpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5uYW1lKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAnJztcbiAgICAgICAgaWYgKCFrZXJuZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0bXBGaWxlUGFyYW1zID0gdGhpcy5fY29uZmlnLmdldFRtcEZpbGVQYXJhbXMoa2VybmVsKTtcbiAgICAgICAgaWYgKCF0bXBGaWxlUGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWZpeCA9IHRtcEZpbGVQYXJhbXMucHJlZml4O1xuICAgICAgICBjb25zdCBleGNlcHRpb25CcmVha3BvaW50RmlsdGVycyA9IHRoaXMuc2Vzc2lvbi5leGNlcHRpb25CcmVha3BvaW50RmlsdGVycztcbiAgICAgICAgbGV0IHBhdXNlT25FeGNlcHRpb25LZXJuZWxzID0gdGhpcy5zZXNzaW9uLnBhdXNpbmdPbkV4Y2VwdGlvbnM7XG4gICAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXNzaW9uLnBhdXNpbmdPbkV4Y2VwdGlvbnMuaW5jbHVkZXMocHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHBhdXNlT25FeGNlcHRpb25LZXJuZWxzLnB1c2gocHJlZml4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ucGF1c2luZ09uRXhjZXB0aW9ucyA9IHBhdXNlT25FeGNlcHRpb25LZXJuZWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByZWZpeEluZGV4ID0gdGhpcy5zZXNzaW9uLnBhdXNpbmdPbkV4Y2VwdGlvbnMuaW5kZXhPZihwcmVmaXgpO1xuICAgICAgICAgICAgaWYgKHByZWZpeEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ucGF1c2luZ09uRXhjZXB0aW9ucyA9IHBhdXNlT25FeGNlcHRpb25LZXJuZWxzLnNwbGljZShwcmVmaXhJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnBhdXNpbmdPbkV4Y2VwdGlvbnMgPSBwYXVzZU9uRXhjZXB0aW9uS2VybmVscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJzID0gW107XG4gICAgICAgIGNvbnN0IGV4Y2VwdGlvbk9wdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgYnJlYWtNb2RlID0gZW5hYmxlID8gJ3VzZXJVbmhhbmRsZWQnIDogJ25ldmVyJztcbiAgICAgICAgZm9yIChsZXQgZmlsdGVyRGljdCBvZiBleGNlcHRpb25CcmVha3BvaW50RmlsdGVycyAhPT0gbnVsbCAmJiBleGNlcHRpb25CcmVha3BvaW50RmlsdGVycyAhPT0gdm9pZCAwID8gZXhjZXB0aW9uQnJlYWtwb2ludEZpbHRlcnMgOiBbXSkge1xuICAgICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlckRpY3QuZmlsdGVyKTtcbiAgICAgICAgICAgIGV4Y2VwdGlvbk9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0aDogW3sgbmFtZXM6IHRoaXMuc2Vzc2lvbi5leGNlcHRpb25QYXRocyB9XSxcbiAgICAgICAgICAgICAgICBicmVha01vZGU6IGJyZWFrTW9kZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGZpbHRlcnM6IGZpbHRlcnMsXG4gICAgICAgICAgICBleGNlcHRpb25PcHRpb25zOiBleGNlcHRpb25PcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kUmVxdWVzdCgnc2V0RXhjZXB0aW9uQnJlYWtwb2ludHMnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWJ1Z2dlciBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMgRGVidWdnZXIgc3RhdGVcbiAgICAgKi9cbiAgICBnZXREZWJ1Z2dlclN0YXRlKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIGNvbnN0IGJyZWFrcG9pbnRzID0gdGhpcy5fbW9kZWwuYnJlYWtwb2ludHMuYnJlYWtwb2ludHM7XG4gICAgICAgIGxldCBjZWxscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGJyZWFrcG9pbnRzLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3QgZWRpdG9yTGlzdCA9IHRoaXMuX2RlYnVnZ2VyU291cmNlcy5maW5kKHtcbiAgICAgICAgICAgICAgICBmb2N1czogZmFsc2UsXG4gICAgICAgICAgICAgICAga2VybmVsOiAoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iua2VybmVsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubmFtZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJycsXG4gICAgICAgICAgICAgICAgcGF0aDogKF9nID0gKF9mID0gKF9lID0gdGhpcy5fc2Vzc2lvbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5wYXRoKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiAnJyxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRtcF9jZWxscyA9IGVkaXRvckxpc3QubWFwKGUgPT4gZS5tb2RlbC52YWx1ZS50ZXh0KTtcbiAgICAgICAgICAgIGNlbGxzID0gY2VsbHMuY29uY2F0KHRtcF9jZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2VsbHMsIGJyZWFrcG9pbnRzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIGRlYnVnZ2VyIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGUgRGVidWdnZXIgc3RhdGVcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzdGF0ZSBoYXMgYmVlbiByZXN0b3JlZCBzdWNjZXNzZnVsbHkgb3Igbm90XG4gICAgICovXG4gICAgYXN5bmMgcmVzdG9yZURlYnVnZ2VyU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiBzdGF0ZS5jZWxscykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZHVtcENlbGwoY2VsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnJlYWtwb2ludHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGtlcm5lbCA9IChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5rZXJuZWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5uYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJztcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHN1ZmZpeCB9ID0gdGhpcy5fY29uZmlnLmdldFRtcEZpbGVQYXJhbXMoa2VybmVsKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHN0YXRlLmJyZWFrcG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBbaWQsIGxpc3RdID0gaXRlbTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3VmZml4ZWRJZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVIYXNoID0gdW5zdWZmaXhlZElkLnN1YnN0cih1bnN1ZmZpeGVkSWQubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBwcmVmaXguY29uY2F0KGNvZGVIYXNoKS5jb25jYXQoc3VmZml4KTtcbiAgICAgICAgICAgIGJyZWFrcG9pbnRzLnNldChuZXdJZCwgbGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fcmVzdG9yZUJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmRSZXF1ZXN0KCdjb25maWd1cmF0aW9uRG9uZScsIHt9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0b3JlU3RhdGUoZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29uZmlnLnN1Y2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjdXJyZW50IG1vZGVsLlxuICAgICAqL1xuICAgIF9jbGVhck1vZGVsKCkge1xuICAgICAgICB0aGlzLl9tb2RlbC5jYWxsc3RhY2suZnJhbWVzID0gW107XG4gICAgICAgIHRoaXMuX21vZGVsLnZhcmlhYmxlcy5zY29wZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHNpZ25hbHMgc2V0IG9uIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBfY2xlYXJTaWduYWxzKCkge1xuICAgICAgICB0aGlzLl9tb2RlbC5jYWxsc3RhY2suY3VycmVudEZyYW1lQ2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuX29uQ3VycmVudEZyYW1lQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21vZGVsLnZhcmlhYmxlcy52YXJpYWJsZUV4cGFuZGVkLmRpc2Nvbm5lY3QodGhpcy5fb25WYXJpYWJsZUV4cGFuZGVkLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFwIGEgbGlzdCBvZiBzY29wZXMgdG8gYSBsaXN0IG9mIHZhcmlhYmxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY29wZXMgVGhlIGxpc3Qgb2Ygc2NvcGVzLlxuICAgICAqIEBwYXJhbSB2YXJpYWJsZXMgVGhlIGxpc3Qgb2YgdmFyaWFibGVzLlxuICAgICAqL1xuICAgIF9jb252ZXJ0U2NvcGVzKHNjb3BlcywgdmFyaWFibGVzKSB7XG4gICAgICAgIGlmICghdmFyaWFibGVzIHx8ICFzY29wZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVzLm1hcCgoc2NvcGUsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogc2NvcGUubmFtZSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlc1tpXS5tYXAodmFyaWFibGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHRocmVhZCBmcm9tIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBfY3VycmVudFRocmVhZCgpIHtcbiAgICAgICAgLy8gVE9ETzogYXNrIHRoZSBtb2RlbCBmb3IgdGhlIGN1cnJlbnQgdGhyZWFkIElEXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEdW1wIHRoZSBjb250ZW50IG9mIGEgY2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2RlIFRoZSBzb3VyY2UgY29kZSB0byBkdW1wLlxuICAgICAqL1xuICAgIGFzeW5jIF9kdW1wQ2VsbChjb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBkZWJ1Z2dlciBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5zZW5kUmVxdWVzdCgnZHVtcENlbGwnLCB7IGNvZGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbHRlciBicmVha3BvaW50cyBhbmQgb25seSByZXR1cm4gdGhvc2UgYXNzb2NpYXRlZCB3aXRoIGEga25vd24gZWRpdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJyZWFrcG9pbnRzIC0gTWFwIG9mIGJyZWFrcG9pbnRzLlxuICAgICAqXG4gICAgICovXG4gICAgX2ZpbHRlckJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGVidWdnZXJTb3VyY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJlYWtwb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJwTWFwRm9yUmVzdG9yZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBjb2xsZWN0aW9uIG9mIGJyZWFrcG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBbaWQsIGxpc3RdID0gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIGxpc3QuZm9yRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnZ2VyU291cmNlcy5maW5kKHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBrZXJuZWw6IChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5rZXJuZWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5uYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogKF9nID0gKF9mID0gKF9lID0gdGhpcy5fc2Vzc2lvbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5wYXRoKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBpZFxuICAgICAgICAgICAgICAgIH0pLmZvckVhY2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicE1hcEZvclJlc3RvcmUuc2V0KGlkLCBsaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJwTWFwRm9yUmVzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgZnJhbWVzIGZyb20gdGhlIGtlcm5lbC5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QWxsRnJhbWVzKCkge1xuICAgICAgICB0aGlzLl9tb2RlbC5jYWxsc3RhY2suY3VycmVudEZyYW1lQ2hhbmdlZC5jb25uZWN0KHRoaXMuX29uQ3VycmVudEZyYW1lQ2hhbmdlZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21vZGVsLnZhcmlhYmxlcy52YXJpYWJsZUV4cGFuZGVkLmNvbm5lY3QodGhpcy5fb25WYXJpYWJsZUV4cGFuZGVkLCB0aGlzKTtcbiAgICAgICAgY29uc3Qgc3RhY2tGcmFtZXMgPSBhd2FpdCB0aGlzLl9nZXRGcmFtZXModGhpcy5fY3VycmVudFRocmVhZCgpKTtcbiAgICAgICAgdGhpcy5fbW9kZWwuY2FsbHN0YWNrLmZyYW1lcyA9IHN0YWNrRnJhbWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSBmcmFtZXMgZm9yIHRoZSBnaXZlbiB0aHJlYWQgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIHRocmVhZCBpZC5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0RnJhbWVzKHRocmVhZElkKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBkZWJ1Z2dlciBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVwbHkgPSBhd2FpdCB0aGlzLnNlc3Npb24uc2VuZFJlcXVlc3QoJ3N0YWNrVHJhY2UnLCB7XG4gICAgICAgICAgICB0aHJlYWRJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3RhY2tGcmFtZXMgPSByZXBseS5ib2R5LnN0YWNrRnJhbWVzO1xuICAgICAgICByZXR1cm4gc3RhY2tGcmFtZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIHNjb3BlcyBmb3IgdGhlIGdpdmVuIGZyYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyYW1lIFRoZSBmcmFtZS5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0U2NvcGVzKGZyYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBkZWJ1Z2dlciBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcGx5ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmRSZXF1ZXN0KCdzY29wZXMnLCB7XG4gICAgICAgICAgICBmcmFtZUlkOiBmcmFtZS5pZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcGx5LmJvZHkuc2NvcGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhcmlhYmxlcyBmb3IgYSBnaXZlbiBzY29wZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY29wZSBUaGUgc2NvcGUgdG8gZ2V0IHZhcmlhYmxlcyBmb3IuXG4gICAgICovXG4gICAgYXN5bmMgX2dldFZhcmlhYmxlcyhzY29wZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgZGVidWdnZXIgc2Vzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kUmVxdWVzdCgndmFyaWFibGVzJywge1xuICAgICAgICAgICAgdmFyaWFibGVzUmVmZXJlbmNlOiBzY29wZS52YXJpYWJsZXNSZWZlcmVuY2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXBseS5ib2R5LnZhcmlhYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgbGlzdCBvZiBicmVha3BvaW50cyBmcm9tIHRoZSBzZXJ2ZXIgYW5kIHJldHVybiBhcyBhIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBicmVha3BvaW50cyAtIFRoZSBsaXN0IG9mIGJyZWFrcG9pbnRzIGZyb20gdGhlIGtlcm5lbC5cbiAgICAgKlxuICAgICAqL1xuICAgIF9tYXBCcmVha3BvaW50cyhicmVha3BvaW50cykge1xuICAgICAgICBpZiAoIWJyZWFrcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnJlYWtwb2ludHMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBicmVha3BvaW50cywgc291cmNlIH0gPSB2YWw7XG4gICAgICAgICAgICBtYXAuc2V0KHNvdXJjZSwgYnJlYWtwb2ludHMubWFwKHBvaW50ID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBvaW50KSwgeyBzb3VyY2U6IHsgcGF0aDogc291cmNlIH0sIHZlcmlmaWVkOiB0cnVlIH0pKSkpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfSwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgY2hhbmdlIG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfIFRoZSBjYWxsc3RhY2sgbW9kZWxcbiAgICAgKiBAcGFyYW0gZnJhbWUgVGhlIGZyYW1lLlxuICAgICAqL1xuICAgIGFzeW5jIF9vbkN1cnJlbnRGcmFtZUNoYW5nZWQoXywgZnJhbWUpIHtcbiAgICAgICAgaWYgKCFmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IGF3YWl0IHRoaXMuX2dldFNjb3BlcyhmcmFtZSk7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IGF3YWl0IFByb21pc2UuYWxsKHNjb3Blcy5tYXAoc2NvcGUgPT4gdGhpcy5fZ2V0VmFyaWFibGVzKHNjb3BlKSkpO1xuICAgICAgICBjb25zdCB2YXJpYWJsZVNjb3BlcyA9IHRoaXMuX2NvbnZlcnRTY29wZXMoc2NvcGVzLCB2YXJpYWJsZXMpO1xuICAgICAgICB0aGlzLl9tb2RlbC52YXJpYWJsZXMuc2NvcGVzID0gdmFyaWFibGVTY29wZXM7XG4gICAgfVxuICAgIGFzeW5jIGRpc3BsYXlNb2R1bGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgZGVidWdnZXIgc2Vzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZHVsZXMgPSBhd2FpdCB0aGlzLnNlc3Npb24uc2VuZFJlcXVlc3QoJ21vZHVsZXMnLCB7fSk7XG4gICAgICAgIHRoaXMuX21vZGVsLmtlcm5lbFNvdXJjZXMua2VybmVsU291cmNlcyA9IG1vZHVsZXMuYm9keS5tb2R1bGVzLm1hcChtb2R1bGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtb2R1bGUubmFtZSxcbiAgICAgICAgICAgICAgICBwYXRoOiBtb2R1bGUucGF0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIHZhcmlhYmxlIGV4cGFuZGVkIGV2ZW50IGFuZCByZXF1ZXN0IHZhcmlhYmxlcyBmcm9tIHRoZSBrZXJuZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gXyBUaGUgdmFyaWFibGVzIG1vZGVsLlxuICAgICAqIEBwYXJhbSB2YXJpYWJsZSBUaGUgZXhwYW5kZWQgdmFyaWFibGUuXG4gICAgICovXG4gICAgYXN5bmMgX29uVmFyaWFibGVFeHBhbmRlZChfLCB2YXJpYWJsZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgZGVidWdnZXIgc2Vzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcGx5ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmRSZXF1ZXN0KCd2YXJpYWJsZXMnLCB7XG4gICAgICAgICAgICB2YXJpYWJsZXNSZWZlcmVuY2U6IHZhcmlhYmxlLnZhcmlhYmxlc1JlZmVyZW5jZVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG5ld1ZhcmlhYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YXJpYWJsZSksIHsgZXhwYW5kZWQ6IHRydWUgfSk7XG4gICAgICAgIHJlcGx5LmJvZHkudmFyaWFibGVzLmZvckVhY2goKHZhcmlhYmxlKSA9PiB7XG4gICAgICAgICAgICBuZXdWYXJpYWJsZSA9IE9iamVjdC5hc3NpZ24oeyBbdmFyaWFibGUubmFtZV06IHZhcmlhYmxlIH0sIG5ld1ZhcmlhYmxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlcyA9IHRoaXMuX21vZGVsLnZhcmlhYmxlcy5zY29wZXMubWFwKHNjb3BlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmRJbmRleCA9IHNjb3BlLnZhcmlhYmxlcy5maW5kSW5kZXgoZWxlID0+IGVsZS52YXJpYWJsZXNSZWZlcmVuY2UgPT09IHZhcmlhYmxlLnZhcmlhYmxlc1JlZmVyZW5jZSk7XG4gICAgICAgICAgICBzY29wZS52YXJpYWJsZXNbZmluZEluZGV4XSA9IG5ld1ZhcmlhYmxlO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHNjb3BlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21vZGVsLnZhcmlhYmxlcy5zY29wZXMgPSBbLi4ubmV3U2NvcGVzXTtcbiAgICAgICAgcmV0dXJuIHJlcGx5LmJvZHkudmFyaWFibGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGJyZWFrcG9pbnRzIGZvciBhIGdpdmVuIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnJlYWtwb2ludHMgVGhlIGxpc3Qgb2YgYnJlYWtwb2ludHMgdG8gc2V0LlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHdoZXJlIHRvIHNldCB0aGUgYnJlYWtwb2ludHMuXG4gICAgICovXG4gICAgYXN5bmMgX3NldEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzLCBwYXRoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBkZWJ1Z2dlciBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kUmVxdWVzdCgnc2V0QnJlYWtwb2ludHMnLCB7XG4gICAgICAgICAgICBicmVha3BvaW50czogYnJlYWtwb2ludHMsXG4gICAgICAgICAgICBzb3VyY2U6IHsgcGF0aCB9LFxuICAgICAgICAgICAgc291cmNlTW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZS1zZW5kIHRoZSBicmVha3BvaW50cyB0byB0aGUga2VybmVsIGFuZCB1cGRhdGUgdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJyZWFrcG9pbnRzIFRoZSBtYXAgb2YgYnJlYWtwb2ludHMgdG8gc2VuZFxuICAgICAqL1xuICAgIGFzeW5jIF9yZXN0b3JlQnJlYWtwb2ludHMoYnJlYWtwb2ludHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBbc291cmNlLCBwb2ludHNdIG9mIGJyZWFrcG9pbnRzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXRCcmVha3BvaW50cyhwb2ludHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh7IGxpbmUgfSkgPT4gdHlwZW9mIGxpbmUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIC5tYXAoKHsgbGluZSB9KSA9PiAoeyBsaW5lOiBsaW5lIH0pKSwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb2RlbC5icmVha3BvaW50cy5yZXN0b3JlQnJlYWtwb2ludHMoYnJlYWtwb2ludHMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2UuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgbnVsbFRyYW5zbGF0b3IgfSBmcm9tICdAanVweXRlcmxhYi90cmFuc2xhdGlvbic7XG5pbXBvcnQgeyBQcm9taXNlRGVsZWdhdGUgfSBmcm9tICdAbHVtaW5vL2NvcmV1dGlscyc7XG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICdAbHVtaW5vL3NpZ25hbGluZyc7XG4vKipcbiAqIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgSURlYnVnZ2VyLklTZXNzaW9uLlxuICovXG5leHBvcnQgY2xhc3MgRGVidWdnZXJTZXNzaW9uIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBkZWJ1ZyBzZXNzaW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBkZWJ1ZyBzZXNzaW9uIGluc3RhbnRpYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NlcSA9IDA7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gbmV3IFByb21pc2VEZWxlZ2F0ZSgpO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXVzaW5nT25FeGNlcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuX2V4Y2VwdGlvblBhdGhzID0gW107XG4gICAgICAgIHRoaXMuX2V4Y2VwdGlvbkJyZWFrcG9pbnRGaWx0ZXJzID0gW107XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZXZlbnRNZXNzYWdlID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gb3B0aW9ucy5jb25uZWN0aW9uO1xuICAgICAgICB0aGlzLnRyYW5zbGF0b3IgPSBvcHRpb25zLnRyYW5zbGF0b3IgfHwgbnVsbFRyYW5zbGF0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGRlYnVnIHNlc3Npb24gaXMgZGlzcG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Rpc3Bvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsaXplIHJlc3BvbnNlIC5cbiAgICAgKi9cbiAgICBnZXQgY2FwYWJpbGl0aWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0aWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGRlYnVnIHNlc3Npb24gaXMgZGlzcG9zZWQuXG4gICAgICovXG4gICAgZ2V0IGRpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFQSSBzZXNzaW9uIGNvbm5lY3Rpb24gdG8gY29ubmVjdCB0byBhIGRlYnVnZ2VyLlxuICAgICAqL1xuICAgIGdldCBjb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgQVBJIHNlc3Npb24gY29ubmVjdGlvbiB0byBjb25uZWN0IHRvIGEgZGVidWdnZXIgdG9cbiAgICAgKiB0aGUgZ2l2ZW4gcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb24gLSBUaGUgbmV3IEFQSSBzZXNzaW9uIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgc2V0IGNvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5pb3B1Yk1lc3NhZ2UuZGlzY29ubmVjdCh0aGlzLl9oYW5kbGVFdmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5faXNTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5pb3B1Yk1lc3NhZ2UuY29ubmVjdCh0aGlzLl9oYW5kbGVFdmVudCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gbmV3IFByb21pc2VEZWxlZ2F0ZSgpO1xuICAgICAgICBjb25zdCBmdXR1cmUgPSAoX2IgPSAoX2EgPSB0aGlzLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5rZXJuZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXF1ZXN0RGVidWcoe1xuICAgICAgICAgICAgdHlwZTogJ3JlcXVlc3QnLFxuICAgICAgICAgICAgc2VxOiAwLFxuICAgICAgICAgICAgY29tbWFuZDogJ2RlYnVnSW5mbydcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmdXR1cmUpIHtcbiAgICAgICAgICAgIGZ1dHVyZS5vblJlcGx5ID0gKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBmdXR1cmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBkZWJ1ZyBzZXNzaW9uIGlzIHN0YXJ0ZWQuXG4gICAgICovXG4gICAgZ2V0IGlzU3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU3RhcnRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBwYXVzZSBvbiBleGNlcHRpb25zXG4gICAgICovXG4gICAgZ2V0IHBhdXNpbmdPbkV4Y2VwdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXVzaW5nT25FeGNlcHRpb25zO1xuICAgIH1cbiAgICBzZXQgcGF1c2luZ09uRXhjZXB0aW9ucyh1cGRhdGVkUGF1c2luZ09uRXhjZXB0aW9ucykge1xuICAgICAgICB0aGlzLl9wYXVzaW5nT25FeGNlcHRpb25zID0gdXBkYXRlZFBhdXNpbmdPbkV4Y2VwdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2VwdGlvbiBwYXRocyBkZWZpbmVkIGJ5IHRoZSBkZWJ1Z2dlclxuICAgICAqL1xuICAgIGdldCBleGNlcHRpb25QYXRocygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4Y2VwdGlvblBhdGhzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNlcHRpb24gYnJlYWtwb2ludCBmaWx0ZXJzIGRlZmluZWQgYnkgdGhlIGRlYnVnZ2VyXG4gICAgICovXG4gICAgZ2V0IGV4Y2VwdGlvbkJyZWFrcG9pbnRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhjZXB0aW9uQnJlYWtwb2ludEZpbHRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25hbCBlbWl0dGVkIGZvciBkZWJ1ZyBldmVudCBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRNZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSBkZWJ1ZyBzZXNzaW9uLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkLmVtaXQoKTtcbiAgICAgICAgU2lnbmFsLmNsZWFyRGF0YSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBuZXcgZGVidWcgc2Vzc2lvblxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IGluaXRpYWxpemVSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoJ2luaXRpYWxpemUnLCB7XG4gICAgICAgICAgICBjbGllbnRJRDogJ2p1cHl0ZXJsYWInLFxuICAgICAgICAgICAgY2xpZW50TmFtZTogJ0p1cHl0ZXJMYWInLFxuICAgICAgICAgICAgYWRhcHRlcklEOiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5rZXJuZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJyxcbiAgICAgICAgICAgIHBhdGhGb3JtYXQ6ICdwYXRoJyxcbiAgICAgICAgICAgIGxpbmVzU3RhcnRBdDE6IHRydWUsXG4gICAgICAgICAgICBjb2x1bW5zU3RhcnRBdDE6IHRydWUsXG4gICAgICAgICAgICBzdXBwb3J0c1ZhcmlhYmxlVHlwZTogdHJ1ZSxcbiAgICAgICAgICAgIHN1cHBvcnRzVmFyaWFibGVQYWdpbmc6IHRydWUsXG4gICAgICAgICAgICBzdXBwb3J0c1J1bkluVGVybWluYWxSZXF1ZXN0OiB0cnVlLFxuICAgICAgICAgICAgbG9jYWxlOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpbml0aWFsaXplUmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3Qgc3RhcnQgdGhlIGRlYnVnZ2VyOiAke2luaXRpYWxpemVSZXNwb25zZS5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcGFiaWxpdGllcyA9IGluaXRpYWxpemVSZXNwb25zZS5ib2R5O1xuICAgICAgICB0aGlzLl9pc1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9leGNlcHRpb25CcmVha3BvaW50RmlsdGVycyA9IChfZCA9IGluaXRpYWxpemVSZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZXhjZXB0aW9uQnJlYWtwb2ludEZpbHRlcnM7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoJ2F0dGFjaCcsIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgcnVubmluZyBkZWJ1ZyBzZXNzaW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoJ2Rpc2Nvbm5lY3QnLCB7XG4gICAgICAgICAgICByZXN0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgIHRlcm1pbmF0ZURlYnVnZ2VlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faXNTdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIHN0YXRlIG9mIGEgZGVidWcgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBhc3luYyByZXN0b3JlU3RhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QoJ2RlYnVnSW5mbycsIHt9KTtcbiAgICAgICAgdGhpcy5faXNTdGFydGVkID0gbWVzc2FnZS5ib2R5LmlzU3RhcnRlZDtcbiAgICAgICAgdGhpcy5fZXhjZXB0aW9uUGF0aHMgPSAoX2EgPSBtZXNzYWdlLmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leGNlcHRpb25QYXRocztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBjdXN0b20gZGVidWcgcmVxdWVzdCB0byB0aGUga2VybmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbW1hbmQgZGVidWcgY29tbWFuZC5cbiAgICAgKiBAcGFyYW0gYXJncyBhcmd1bWVudHMgZm9yIHRoZSBkZWJ1ZyBjb21tYW5kLlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRSZXF1ZXN0KGNvbW1hbmQsIGFyZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcmVhZHkucHJvbWlzZTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMuX3NlbmREZWJ1Z01lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ3JlcXVlc3QnLFxuICAgICAgICAgICAgc2VxOiB0aGlzLl9zZXErKyxcbiAgICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBkZWJ1ZyBldmVudHMgc2VudCBvbiB0aGUgJ2lvcHViJyBjaGFubmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbmRlciAtIHRoZSBlbWl0dGVyIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIHRoZSBldmVudCBtZXNzYWdlLlxuICAgICAqL1xuICAgIF9oYW5kbGVFdmVudChzZW5kZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbXNnVHlwZSA9IG1lc3NhZ2UuaGVhZGVyLm1zZ190eXBlO1xuICAgICAgICBpZiAobXNnVHlwZSAhPT0gJ2RlYnVnX2V2ZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbWVzc2FnZS5jb250ZW50O1xuICAgICAgICB0aGlzLl9ldmVudE1lc3NhZ2UuZW1pdChldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBkZWJ1ZyByZXF1ZXN0IG1lc3NhZ2UgdG8gdGhlIGtlcm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgZGVidWcgcmVxdWVzdCBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIGtlcm5lbC5cbiAgICAgKi9cbiAgICBhc3luYyBfc2VuZERlYnVnTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBrZXJuZWwgPSAoX2EgPSB0aGlzLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5rZXJuZWw7XG4gICAgICAgIGlmICgha2VybmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdBIGtlcm5lbCBpcyByZXF1aXJlZCB0byBzZW5kIGRlYnVnIG1lc3NhZ2VzLicpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseSA9IG5ldyBQcm9taXNlRGVsZWdhdGUoKTtcbiAgICAgICAgY29uc3QgZnV0dXJlID0ga2VybmVsLnJlcXVlc3REZWJ1Zyhtc2cpO1xuICAgICAgICBmdXR1cmUub25SZXBseSA9IChtc2cpID0+IHtcbiAgICAgICAgICAgIHJlcGx5LnJlc29sdmUobXNnKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgZnV0dXJlLmRvbmU7XG4gICAgICAgIHJldHVybiByZXBseS5wcm9taXNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb24uanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuaW1wb3J0IHsgbnVsbFRyYW5zbGF0b3IgfSBmcm9tICdAanVweXRlcmxhYi90cmFuc2xhdGlvbic7XG5pbXBvcnQgeyBidWdJY29uIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdWktY29tcG9uZW50cyc7XG5pbXBvcnQgeyBQYW5lbCwgU3BsaXRQYW5lbCwgV2lkZ2V0IH0gZnJvbSAnQGx1bWluby93aWRnZXRzJztcbmltcG9ydCB7IEJyZWFrcG9pbnRzIGFzIEJyZWFrcG9pbnRzUGFuZWwgfSBmcm9tICcuL3BhbmVscy9icmVha3BvaW50cyc7XG5pbXBvcnQgeyBDYWxsc3RhY2sgYXMgQ2FsbHN0YWNrUGFuZWwgfSBmcm9tICcuL3BhbmVscy9jYWxsc3RhY2snO1xuaW1wb3J0IHsgU291cmNlcyBhcyBTb3VyY2VzUGFuZWwgfSBmcm9tICcuL3BhbmVscy9zb3VyY2VzJztcbmltcG9ydCB7IEtlcm5lbFNvdXJjZXMgYXMgS2VybmVsU291cmNlc1BhbmVsIH0gZnJvbSAnLi9wYW5lbHMva2VybmVsU291cmNlcyc7XG5pbXBvcnQgeyBWYXJpYWJsZXMgYXMgVmFyaWFibGVzUGFuZWwgfSBmcm9tICcuL3BhbmVscy92YXJpYWJsZXMnO1xuLyoqXG4gKiBBIGRlYnVnZ2VyIHNpZGViYXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWJ1Z2dlclNpZGViYXIgZXh0ZW5kcyBQYW5lbCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBuZXcgRGVidWdnZXIuU2lkZWJhclxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGluc3RhbnRpYXRpb24gb3B0aW9ucyBmb3IgYSBEZWJ1Z2dlci5TaWRlYmFyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlkID0gJ2pwLWRlYnVnZ2VyLXNpZGViYXInO1xuICAgICAgICB0aGlzLnRpdGxlLmljb24gPSBidWdJY29uO1xuICAgICAgICB0aGlzLmFkZENsYXNzKCdqcC1EZWJ1Z2dlclNpZGViYXInKTtcbiAgICAgICAgY29uc3QgeyBjYWxsc3RhY2tDb21tYW5kcywgYnJlYWtwb2ludHNDb21tYW5kcywgZWRpdG9yU2VydmljZXMsIHNlcnZpY2UsIHRoZW1lTWFuYWdlciB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgdHJhbnNsYXRvciA9IG9wdGlvbnMudHJhbnNsYXRvciB8fCBudWxsVHJhbnNsYXRvcjtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBzZXJ2aWNlLm1vZGVsO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IG5ldyBWYXJpYWJsZXNQYW5lbCh7XG4gICAgICAgICAgICBtb2RlbDogbW9kZWwudmFyaWFibGVzLFxuICAgICAgICAgICAgY29tbWFuZHM6IGNhbGxzdGFja0NvbW1hbmRzLnJlZ2lzdHJ5LFxuICAgICAgICAgICAgc2VydmljZSxcbiAgICAgICAgICAgIHRoZW1lTWFuYWdlcixcbiAgICAgICAgICAgIHRyYW5zbGF0b3JcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbHN0YWNrID0gbmV3IENhbGxzdGFja1BhbmVsKHtcbiAgICAgICAgICAgIGNvbW1hbmRzOiBjYWxsc3RhY2tDb21tYW5kcyxcbiAgICAgICAgICAgIG1vZGVsOiBtb2RlbC5jYWxsc3RhY2ssXG4gICAgICAgICAgICB0cmFuc2xhdG9yXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJyZWFrcG9pbnRzID0gbmV3IEJyZWFrcG9pbnRzUGFuZWwoe1xuICAgICAgICAgICAgc2VydmljZSxcbiAgICAgICAgICAgIGNvbW1hbmRzOiBicmVha3BvaW50c0NvbW1hbmRzLFxuICAgICAgICAgICAgbW9kZWw6IG1vZGVsLmJyZWFrcG9pbnRzLFxuICAgICAgICAgICAgdHJhbnNsYXRvclxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb3VyY2VzID0gbmV3IFNvdXJjZXNQYW5lbCh7XG4gICAgICAgICAgICBtb2RlbDogbW9kZWwuc291cmNlcyxcbiAgICAgICAgICAgIHNlcnZpY2UsXG4gICAgICAgICAgICBlZGl0b3JTZXJ2aWNlcyxcbiAgICAgICAgICAgIHRyYW5zbGF0b3JcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMua2VybmVsU291cmNlcyA9IG5ldyBLZXJuZWxTb3VyY2VzUGFuZWwoe1xuICAgICAgICAgICAgbW9kZWw6IG1vZGVsLmtlcm5lbFNvdXJjZXMsXG4gICAgICAgICAgICBzZXJ2aWNlLFxuICAgICAgICAgICAgdHJhbnNsYXRvclxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IERlYnVnZ2VyU2lkZWJhci5IZWFkZXIoKTtcbiAgICAgICAgdGhpcy5hZGRXaWRnZXQoaGVhZGVyKTtcbiAgICAgICAgbW9kZWwudGl0bGVDaGFuZ2VkLmNvbm5lY3QoKF8sIHRpdGxlKSA9PiB7XG4gICAgICAgICAgICBoZWFkZXIudGl0bGUubGFiZWwgPSB0aXRsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JvZHkgPSBuZXcgU3BsaXRQYW5lbCgpO1xuICAgICAgICB0aGlzLl9ib2R5Lm9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgdGhpcy5fYm9keS5hZGRDbGFzcygnanAtRGVidWdnZXJTaWRlYmFyLWJvZHknKTtcbiAgICAgICAgdGhpcy5hZGRXaWRnZXQodGhpcy5fYm9keSk7XG4gICAgICAgIHRoaXMuYWRkSXRlbSh0aGlzLnZhcmlhYmxlcyk7XG4gICAgICAgIHRoaXMuYWRkSXRlbSh0aGlzLmNhbGxzdGFjayk7XG4gICAgICAgIHRoaXMuYWRkSXRlbSh0aGlzLmJyZWFrcG9pbnRzKTtcbiAgICAgICAgdGhpcy5hZGRJdGVtKHRoaXMuc291cmNlcyk7XG4gICAgICAgIHRoaXMuYWRkSXRlbSh0aGlzLmtlcm5lbFNvdXJjZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gaXRlbSBhdCB0aGUgZW5kIG9mIHRoZSBzaWRlYmFyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldCAtIFRoZSB3aWRnZXQgdG8gYWRkIHRvIHRoZSBzaWRlYmFyLlxuICAgICAqXG4gICAgICogIyMjIyBOb3Rlc1xuICAgICAqIElmIHRoZSB3aWRnZXQgaXMgYWxyZWFkeSBjb250YWluZWQgaW4gdGhlIHNpZGViYXIsIGl0IHdpbGwgYmUgbW92ZWQuXG4gICAgICogVGhlIGl0ZW0gY2FuIGJlIHJlbW92ZWQgZnJvbSB0aGUgc2lkZWJhciBieSBzZXR0aW5nIGl0cyBwYXJlbnQgdG8gYG51bGxgLlxuICAgICAqL1xuICAgIGFkZEl0ZW0od2lkZ2V0KSB7XG4gICAgICAgIHRoaXMuX2JvZHkuYWRkV2lkZ2V0KHdpZGdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSB3aWRnZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IC0gVGhlIHdpZGdldCB0byBpbnNlcnQgaW50byB0byB0aGUgc2lkZWJhci5cbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBJZiB0aGUgd2lkZ2V0IGlzIGFscmVhZHkgY29udGFpbmVkIGluIHRoZSBzaWRlYmFyLCBpdCB3aWxsIGJlIG1vdmVkLlxuICAgICAqIFRoZSBpdGVtIGNhbiBiZSByZW1vdmVkIGZyb20gdGhlIHNpZGViYXIgYnkgc2V0dGluZyBpdHMgcGFyZW50IHRvIGBudWxsYC5cbiAgICAgKi9cbiAgICBpbnNlcnRJdGVtKGluZGV4LCB3aWRnZXQpIHtcbiAgICAgICAgdGhpcy5fYm9keS5pbnNlcnRXaWRnZXQoaW5kZXgsIHdpZGdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVhZC1vbmx5IGFycmF5IG9mIHRoZSBzaWRlYmFyIGl0ZW1zLlxuICAgICAqL1xuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHkud2lkZ2V0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB0aGUgc2lkZWJhci5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbn1cbi8qKlxuICogQSBuYW1lc3BhY2UgZm9yIERlYnVnZ2VyU2lkZWJhciBzdGF0aWNzXG4gKi9cbihmdW5jdGlvbiAoRGVidWdnZXJTaWRlYmFyKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGhlYWRlciBmb3IgYSBkZWJ1Z2dlciBzaWRlYmFyLlxuICAgICAqL1xuICAgIGNsYXNzIEhlYWRlciBleHRlbmRzIFdpZGdldCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZSBhIG5ldyBzaWRlYmFyIGhlYWRlci5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoeyBub2RlOiBQcml2YXRlLmNyZWF0ZUhlYWRlcigpIH0pO1xuICAgICAgICAgICAgdGhpcy50aXRsZS5jaGFuZ2VkLmNvbm5lY3QoXyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJ2gyJykudGV4dENvbnRlbnQgPSB0aGlzLnRpdGxlLmxhYmVsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVidWdnZXJTaWRlYmFyLkhlYWRlciA9IEhlYWRlcjtcbn0pKERlYnVnZ2VyU2lkZWJhciB8fCAoRGVidWdnZXJTaWRlYmFyID0ge30pKTtcbi8qKlxuICogQSBuYW1lc3BhY2UgZm9yIHByaXZhdGUgbW9kdWxlIGRhdGEuXG4gKi9cbnZhciBQcml2YXRlO1xuKGZ1bmN0aW9uIChQcml2YXRlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2lkZWJhciBoZWFkZXIgbm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBoZWFkZXIuY2xhc3NMaXN0LmFkZCgnanAtc3RhY2stcGFuZWwtaGVhZGVyJyk7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICAgICAgdGl0bGUudGV4dENvbnRlbnQgPSAnLSc7XG4gICAgICAgIHRpdGxlLmNsYXNzTGlzdC5hZGQoJ2pwLWxlZnQtdHJ1bmNhdGVkJyk7XG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgfVxuICAgIFByaXZhdGUuY3JlYXRlSGVhZGVyID0gY3JlYXRlSGVhZGVyO1xufSkoUHJpdmF0ZSB8fCAoUHJpdmF0ZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWRlYmFyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IERPTVV0aWxzLCBNYWluQXJlYVdpZGdldCwgV2lkZ2V0VHJhY2tlciB9IGZyb20gJ0BqdXB5dGVybGFiL2FwcHV0aWxzJztcbmltcG9ydCB7IHRleHRFZGl0b3JJY29uIH0gZnJvbSAnQGp1cHl0ZXJsYWIvdWktY29tcG9uZW50cyc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnQGx1bWluby9hbGdvcml0aG0nO1xuLyoqXG4gKiBUaGUgc291cmNlIGFuZCBlZGl0b3IgbWFuYWdlciBmb3IgYSBkZWJ1Z2dlciBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGNsYXNzIERlYnVnZ2VyU291cmNlcyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IERlYnVnZ2VyU291cmNlcyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbnN0YW50aWF0aW9uIG9wdGlvbnMgZm9yIGEgRGVidWdnZXJTb3VyY2VzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IG9wdGlvbnMuY29uZmlnO1xuICAgICAgICB0aGlzLl9zaGVsbCA9IG9wdGlvbnMuc2hlbGw7XG4gICAgICAgIHRoaXMuX25vdGVib29rVHJhY2tlciA9IChfYSA9IG9wdGlvbnMubm90ZWJvb2tUcmFja2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICB0aGlzLl9jb25zb2xlVHJhY2tlciA9IChfYiA9IG9wdGlvbnMuY29uc29sZVRyYWNrZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgICAgIHRoaXMuX2VkaXRvclRyYWNrZXIgPSAoX2MgPSBvcHRpb25zLmVkaXRvclRyYWNrZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGw7XG4gICAgICAgIHRoaXMuX3JlYWRPbmx5RWRpdG9yVHJhY2tlciA9IG5ldyBXaWRnZXRUcmFja2VyKHsgbmFtZXNwYWNlOiAnQGp1cHl0ZXJsYWIvZGVidWdnZXInIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGVkaXRvcnMgZm9yIGEgc291cmNlIG1hdGNoaW5nIHRoZSBjdXJyZW50IGRlYnVnXG4gICAgICogc2Vzc2lvbiBieSBpdGVyYXRpbmcgdGhyb3VnaCBhbGwgdGhlIHdpZGdldHMgaW4gZWFjaCBvZiB0aGUgc3VwcG9ydGVkXG4gICAgICogZGVidWdnZXIgdHlwZXMgKGkuZS4sIGNvbnNvbGVzLCBmaWxlcywgbm90ZWJvb2tzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgZWRpdG9yIHNlYXJjaCBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGZpbmQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLl9maW5kSW5Db25zb2xlcyhwYXJhbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5fZmluZEluRWRpdG9ycyhwYXJhbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5fZmluZEluTm90ZWJvb2tzKHBhcmFtcyksXG4gICAgICAgICAgICAuLi50aGlzLl9maW5kSW5SZWFkT25seUVkaXRvcnMocGFyYW1zKVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgcmVhZC1vbmx5IGVkaXRvciBpbiB0aGUgbWFpbiBhcmVhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgZWRpdG9yIG9wZW4gcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBvcGVuKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGVkaXRvcldyYXBwZXIsIGxhYmVsLCBjYXB0aW9uIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHdpZGdldCA9IG5ldyBNYWluQXJlYVdpZGdldCh7XG4gICAgICAgICAgICBjb250ZW50OiBlZGl0b3JXcmFwcGVyXG4gICAgICAgIH0pO1xuICAgICAgICB3aWRnZXQuaWQgPSBET01VdGlscy5jcmVhdGVEb21JRCgpO1xuICAgICAgICB3aWRnZXQudGl0bGUubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgd2lkZ2V0LnRpdGxlLmNsb3NhYmxlID0gdHJ1ZTtcbiAgICAgICAgd2lkZ2V0LnRpdGxlLmNhcHRpb24gPSBjYXB0aW9uO1xuICAgICAgICB3aWRnZXQudGl0bGUuaWNvbiA9IHRleHRFZGl0b3JJY29uO1xuICAgICAgICB0aGlzLl9zaGVsbC5hZGQod2lkZ2V0LCAnbWFpbicpO1xuICAgICAgICB2b2lkIHRoaXMuX3JlYWRPbmx5RWRpdG9yVHJhY2tlci5hZGQod2lkZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCByZWxldmFudCBlZGl0b3JzIG1hdGNoaW5nIHRoZSBzZWFyY2ggcGFyYW1zIGluIHRoZSBub3RlYm9vayB0cmFja2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBlZGl0b3Igc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgX2ZpbmRJbk5vdGVib29rcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ub3RlYm9va1RyYWNrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGZvY3VzLCBrZXJuZWwsIHBhdGgsIHNvdXJjZSB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgICAgIHRoaXMuX25vdGVib29rVHJhY2tlci5mb3JFYWNoKG5vdGVib29rUGFuZWwgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkNvbnRleHQgPSBub3RlYm9va1BhbmVsLnNlc3Npb25Db250ZXh0O1xuICAgICAgICAgICAgaWYgKHBhdGggIT09IHNlc3Npb25Db250ZXh0LnBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3RlYm9vayA9IG5vdGVib29rUGFuZWwuY29udGVudDtcbiAgICAgICAgICAgIGlmIChmb2N1cykge1xuICAgICAgICAgICAgICAgIG5vdGVib29rLm1vZGUgPSAnY29tbWFuZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IG5vdGVib29rUGFuZWwuY29udGVudC53aWRnZXRzO1xuICAgICAgICAgICAgY2VsbHMuZm9yRWFjaCgoY2VsbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBldmVudCBpcyBmb3IgdGhlIGNvcnJlY3QgY2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBjZWxsLm1vZGVsLnZhbHVlLnRleHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZUlkID0gdGhpcy5fZ2V0Q29kZUlkKGNvZGUsIGtlcm5lbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSBjb2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZWJvb2suYWN0aXZlQ2VsbEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGVib29rLmFjdGl2ZUNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub3RlYm9vay5hY3RpdmVDZWxsLmlucHV0QXJlYS5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RlYm9vay5zY3JvbGxUb1Bvc2l0aW9uKHJlY3QuYm90dG9tLCA0NSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hlbGwuYWN0aXZhdGVCeUlkKG5vdGVib29rUGFuZWwuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZGl0b3JzLnB1c2goY2VsbC5lZGl0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWRpdG9ycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCByZWxldmFudCBlZGl0b3JzIG1hdGNoaW5nIHRoZSBzZWFyY2ggcGFyYW1zIGluIHRoZSBjb25zb2xlIHRyYWNrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIGVkaXRvciBzZWFyY2ggcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBfZmluZEluQ29uc29sZXMocGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29uc29sZVRyYWNrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGZvY3VzLCBrZXJuZWwsIHBhdGgsIHNvdXJjZSB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgICAgIHRoaXMuX2NvbnNvbGVUcmFja2VyLmZvckVhY2goY29uc29sZVdpZGdldCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uQ29udGV4dCA9IGNvbnNvbGVXaWRnZXQuc2Vzc2lvbkNvbnRleHQ7XG4gICAgICAgICAgICBpZiAocGF0aCAhPT0gc2Vzc2lvbkNvbnRleHQucGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gY29uc29sZVdpZGdldC5jb25zb2xlLmNlbGxzO1xuICAgICAgICAgICAgZWFjaChjZWxscywgY2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGNlbGwubW9kZWwudmFsdWUudGV4dDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlSWQgPSB0aGlzLl9nZXRDb2RlSWQoY29kZSwga2VybmVsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IGNvZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVkaXRvcnMucHVzaChjZWxsLmVkaXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NoZWxsLmFjdGl2YXRlQnlJZChjb25zb2xlV2lkZ2V0LmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlZGl0b3JzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHJlbGV2YW50IGVkaXRvcnMgbWF0Y2hpbmcgdGhlIHNlYXJjaCBwYXJhbXMgaW4gdGhlIGVkaXRvciB0cmFja2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBlZGl0b3Igc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgX2ZpbmRJbkVkaXRvcnMocGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5fZWRpdG9yVHJhY2tlcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZm9jdXMsIGtlcm5lbCwgcGF0aCwgc291cmNlIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fZWRpdG9yVHJhY2tlci5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlRWRpdG9yID0gZG9jLmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAocGF0aCAhPT0gZmlsZUVkaXRvci5jb250ZXh0LnBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBmaWxlRWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGVkaXRvci5tb2RlbC52YWx1ZS50ZXh0O1xuICAgICAgICAgICAgY29uc3QgY29kZUlkID0gdGhpcy5fZ2V0Q29kZUlkKGNvZGUsIGtlcm5lbCk7XG4gICAgICAgICAgICBpZiAoIWNvZGVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IGNvZGVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvcnMucHVzaChlZGl0b3IpO1xuICAgICAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hlbGwuYWN0aXZhdGVCeUlkKGRvYy5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWRpdG9ycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCByZWxldmFudCBlZGl0b3JzIG1hdGNoaW5nIHRoZSBzZWFyY2ggcGFyYW1zIGluIHRoZSByZWFkLW9ubHkgdHJhY2tlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgZWRpdG9yIHNlYXJjaCBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIF9maW5kSW5SZWFkT25seUVkaXRvcnMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgZm9jdXMsIGtlcm5lbCwgc291cmNlIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVhZE9ubHlFZGl0b3JUcmFja2VyLmZvckVhY2god2lkZ2V0ID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IChfYSA9IHdpZGdldC5jb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWRpdG9yO1xuICAgICAgICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZWRpdG9yLm1vZGVsLnZhbHVlLnRleHQ7XG4gICAgICAgICAgICBjb25zdCBjb2RlSWQgPSB0aGlzLl9nZXRDb2RlSWQoY29kZSwga2VybmVsKTtcbiAgICAgICAgICAgIGlmICghY29kZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpZGdldC50aXRsZS5jYXB0aW9uICE9PSBzb3VyY2UgJiYgc291cmNlICE9PSBjb2RlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3JzLnB1c2goZWRpdG9yKTtcbiAgICAgICAgICAgIGlmIChmb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoZWxsLmFjdGl2YXRlQnlJZCh3aWRnZXQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVkaXRvcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29kZSBpZCBmb3IgYSBnaXZlbiBzb3VyY2UgYW5kIGtlcm5lbCxcbiAgICAgKiBhbmQgaGFuZGxlIHRoZSBjYXNlIG9mIGEga2VybmVsIHdpdGhvdXQgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2RlIFRoZSBzb3VyY2UgY29kZS5cbiAgICAgKiBAcGFyYW0ga2VybmVsIFRoZSBuYW1lIG9mIHRoZSBrZXJuZWwuXG4gICAgICovXG4gICAgX2dldENvZGVJZChjb2RlLCBrZXJuZWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuZ2V0Q29kZUlkKGNvZGUsIGtlcm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3VyY2VzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbmltcG9ydCB7IFRva2VuIH0gZnJvbSAnQGx1bWluby9jb3JldXRpbHMnO1xuLyoqXG4gKiBUaGUgdmlzdWFsIGRlYnVnZ2VyIHRva2VuLlxuICovXG5leHBvcnQgY29uc3QgSURlYnVnZ2VyID0gbmV3IFRva2VuKCdAanVweXRlcmxhYi9kZWJ1Z2dlcjpJRGVidWdnZXInKTtcbi8qKlxuICogVGhlIGRlYnVnZ2VyIGNvbmZpZ3VyYXRpb24gdG9rZW4uXG4gKi9cbmV4cG9ydCBjb25zdCBJRGVidWdnZXJDb25maWcgPSBuZXcgVG9rZW4oJ0BqdXB5dGVybGFiL2RlYnVnZ2VyOklEZWJ1Z2dlckNvbmZpZycpO1xuLyoqXG4gKiBUaGUgZGVidWdnZXIgc291cmNlcyB1dGlsaXR5IHRva2VuLlxuICovXG5leHBvcnQgY29uc3QgSURlYnVnZ2VyU291cmNlcyA9IG5ldyBUb2tlbignQGp1cHl0ZXJsYWIvZGVidWdnZXI6SURlYnVnZ2VyU291cmNlcycpO1xuLyoqXG4gKiBUaGUgZGVidWdnZXIgY29uZmlndXJhdGlvbiB0b2tlbi5cbiAqL1xuZXhwb3J0IGNvbnN0IElEZWJ1Z2dlclNpZGViYXIgPSBuZXcgVG9rZW4oJ0BqdXB5dGVybGFiL2RlYnVnZ2VyOklEZWJ1Z2dlclNpZGViYXInKTtcbi8qKlxuICogVGhlIGRlYnVnZ2VyIGhhbmRsZXIgdG9rZW4uXG4gKi9cbmV4cG9ydCBjb25zdCBJRGVidWdnZXJIYW5kbGVyID0gbmV3IFRva2VuKCdAanVweXRlcmxhYi9kZWJ1Z2dlcjpJRGVidWdnZXJIYW5kbGVyJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbnMuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==