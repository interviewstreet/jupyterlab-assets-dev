(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyterlab-plotly_lib_index_js"],{

/***/ "../../node_modules/jupyterlab-plotly/lib/Figure.js":
/*!**********************************************************!*\
  !*** ../../node_modules/jupyterlab-plotly/lib/Figure.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FigureModel": () => (/* binding */ FigureModel),
/* harmony export */   "FigureView": () => (/* binding */ FigureView)
/* harmony export */ });
/* harmony import */ var _jupyter_widgets_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyter-widgets/base */ "webpack/sharing/consume/default/@jupyter-widgets/base");
/* harmony import */ var _jupyter_widgets_base__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyter_widgets_base__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "webpack/sharing/consume/default/lodash/lodash");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! plotly.js/dist/plotly */ "../../node_modules/plotly.js/dist/plotly.js");
/* harmony import */ var plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./version */ "../../node_modules/jupyterlab-plotly/lib/version.js");




// @ts-ignore
window.PlotlyConfig = { MathJaxConfig: "local" };
const semver_range = "^" + _version__WEBPACK_IMPORTED_MODULE_3__.MODULE_VERSION;
// Model
// =====
/**
 * A FigureModel holds a mirror copy of the state of a FigureWidget on
 * the Python side.  There is a one-to-one relationship between JavaScript
 * FigureModels and Python FigureWidgets. The JavaScript FigureModel is
 * initialized as soon as a Python FigureWidget initialized, this happens
 * even before the widget is first displayed in the Notebook
 * @type {widgets.DOMWidgetModel}
 */
class FigureModel extends _jupyter_widgets_base__WEBPACK_IMPORTED_MODULE_0__.DOMWidgetModel {
    defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { 
            // Model metadata
            // --------------
            _model_name: FigureModel.model_name, _model_module: FigureModel.model_module, _model_module_version: FigureModel.model_module_version, _view_name: FigureModel.view_name, _view_module: FigureModel.view_module, _view_module_version: FigureModel.view_module_version, 
            // Data and Layout
            // ---------------
            // The _data and _layout properties are synchronized with the
            // Python side on initialization only.  After initialization, these
            // properties are kept in sync through the use of the _py2js_*
            // messages
            _data: [], _layout: {}, _config: {}, 
            // Python -> JS messages
            // ---------------------
            // Messages are implemented using trait properties. This is done so
            // that we can take advantage of ipywidget's binary serialization
            // protocol.
            //
            // Messages are sent by the Python side by assigning the message
            // contents to the appropriate _py2js_* property, and then immediately
            // setting it to None.  Messages are received by the JavaScript
            // side by registering property change callbacks in the initialize
            // methods for FigureModel and FigureView. e.g. (where this is a
            // FigureModel):
            //
            //      this.on('change:_py2js_addTraces', this.do_addTraces, this);
            //
            // Message handling methods, do_addTraces, are responsible for
            // performing the appropriate action if the message contents are
            // not null
            /**
             * @typedef {null|Object} Py2JsAddTracesMsg
             * @property {Array.<Object>} trace_data
             *  Array of traces to append to the end of the figure's current traces
             * @property {Number} trace_edit_id
             *  Edit ID to use when returning trace deltas using
             *  the _js2py_traceDeltas message.
             * @property {Number} layout_edit_id
             *  Edit ID to use when returning layout deltas using
             *  the _js2py_layoutDelta message.
             */
            _py2js_addTraces: null, 
            /**
             * @typedef {null|Object} Py2JsDeleteTracesMsg
             * @property {Array.<Number>} delete_inds
             *  Array of indexes of traces to be deleted, in ascending order
             * @property {Number} trace_edit_id
             *  Edit ID to use when returning trace deltas using
             *  the _js2py_traceDeltas message.
             * @property {Number} layout_edit_id
             *  Edit ID to use when returning layout deltas using
             *  the _js2py_layoutDelta message.
             */
            _py2js_deleteTraces: null, 
            /**
             * @typedef {null|Object} Py2JsMoveTracesMsg
             * @property {Array.<Number>} current_trace_inds
             *  Array of the current indexes of traces to be moved
             * @property {Array.<Number>} new_trace_inds
             *  Array of the new indexes that traces should be moved to.
             */
            _py2js_moveTraces: null, 
            /**
             * @typedef {null|Object} Py2JsRestyleMsg
             * @property {Object} restyle_data
             *  Restyle data as accepted by Plotly.restyle
             * @property {null|Array.<Number>} restyle_traces
             *  Array of indexes of the traces that the resytle operation applies
             *  to, or null to apply the operation to all traces
             * @property {Number} trace_edit_id
             *  Edit ID to use when returning trace deltas using
             *  the _js2py_traceDeltas message
             * @property {Number} layout_edit_id
             *  Edit ID to use when returning layout deltas using
             *  the _js2py_layoutDelta message
             * @property {null|String} source_view_id
             *  view_id of the FigureView that triggered the original restyle
             *  event (e.g. by clicking the legend), or null if the restyle was
             *  triggered from Python
             */
            _py2js_restyle: null, 
            /**
             * @typedef {null|Object} Py2JsRelayoutMsg
             * @property {Object} relayout_data
             *  Relayout data as accepted by Plotly.relayout
             * @property {Number} layout_edit_id
             *  Edit ID to use when returning layout deltas using
             *  the _js2py_layoutDelta message
             * @property {null|String} source_view_id
             *  view_id of the FigureView that triggered the original relayout
             *  event (e.g. by clicking the zoom button), or null if the
             *  relayout was triggered from Python
             */
            _py2js_relayout: null, 
            /**
             * @typedef {null|Object} Py2JsUpdateMsg
             * @property {Object} style_data
             *  Style data as accepted by Plotly.update
             * @property {Object} layout_data
             *  Layout data as accepted by Plotly.update
             * @property {Array.<Number>} style_traces
             *  Array of indexes of the traces that the update operation applies
             *  to, or null to apply the operation to all traces
             * @property {Number} trace_edit_id
             *  Edit ID to use when returning trace deltas using
             *  the _js2py_traceDeltas message
             * @property {Number} layout_edit_id
             *  Edit ID to use when returning layout deltas using
             *  the _js2py_layoutDelta message
             * @property {null|String} source_view_id
             *  view_id of the FigureView that triggered the original update
             *  event (e.g. by clicking a button), or null if the update was
             *  triggered from Python
             */
            _py2js_update: null, 
            /**
             * @typedef {null|Object} Py2JsAnimateMsg
             * @property {Object} style_data
             *  Style data as accepted by Plotly.animate
             * @property {Object} layout_data
             *  Layout data as accepted by Plotly.animate
             * @property {Array.<Number>} style_traces
             *  Array of indexes of the traces that the animate operation applies
             *  to, or null to apply the operation to all traces
             * @property {Object} animation_opts
             *  Animation options as accepted by Plotly.animate
             * @property {Number} trace_edit_id
             *  Edit ID to use when returning trace deltas using
             *  the _js2py_traceDeltas message
             * @property {Number} layout_edit_id
             *  Edit ID to use when returning layout deltas using
             *  the _js2py_layoutDelta message
             * @property {null|String} source_view_id
             *  view_id of the FigureView that triggered the original animate
             *  event (e.g. by clicking a button), or null if the update was
             *  triggered from Python
             */
            _py2js_animate: null, 
            /**
             * @typedef {null|Object} Py2JsRemoveLayoutPropsMsg
             * @property {Array.<Array.<String|Number>>} remove_props
             *  Array of property paths to remove. Each propery path is an
             *  array of property names or array indexes that locate a property
             *  inside the _layout object
             */
            _py2js_removeLayoutProps: null, 
            /**
             * @typedef {null|Object} Py2JsRemoveTracePropsMsg
             * @property {Number} remove_trace
             *  The index of the trace from which to remove properties
             * @property {Array.<Array.<String|Number>>} remove_props
             *  Array of property paths to remove. Each propery path is an
             *  array of property names or array indexes that locate a property
             *  inside the _data[remove_trace] object
             */
            _py2js_removeTraceProps: null, 
            // JS -> Python messages
            // ---------------------
            // Messages are sent by the JavaScript side by assigning the
            // message contents to the appropriate _js2py_* property and then
            // calling the `touch` method on the view that triggered the
            // change. e.g. (where this is a FigureView):
            //
            //      this.model.set('_js2py_restyle', data);
            //      this.touch();
            //
            // The Python side is responsible for setting the property to None
            // after receiving the message.
            //
            // Message trigger logic is described in the corresponding
            // handle_plotly_* methods of FigureView
            /**
             * @typedef {null|Object} Js2PyRestyleMsg
             * @property {Object} style_data
             *  Style data that was passed to Plotly.restyle
             * @property {Array.<Number>} style_traces
             *  Array of indexes of the traces that the restyle operation
             *  was applied to, or null if applied to all traces
             * @property {String} source_view_id
             *  view_id of the FigureView that triggered the original restyle
             *  event (e.g. by clicking the legend)
             */
            _js2py_restyle: null, 
            /**
             * @typedef {null|Object} Js2PyRelayoutMsg
             * @property {Object} relayout_data
             *  Relayout data that was passed to Plotly.relayout
             * @property {String} source_view_id
             *  view_id of the FigureView that triggered the original relayout
             *  event (e.g. by clicking the zoom button)
             */
            _js2py_relayout: null, 
            /**
             * @typedef {null|Object} Js2PyUpdateMsg
             * @property {Object} style_data
             *  Style data that was passed to Plotly.update
             * @property {Object} layout_data
             *  Layout data that was passed to Plotly.update
             * @property {Array.<Number>} style_traces
             *  Array of indexes of the traces that the update operation applied
             *  to, or null if applied to all traces
             * @property {String} source_view_id
             *  view_id of the FigureView that triggered the original relayout
             *  event (e.g. by clicking the zoom button)
             */
            _js2py_update: null, 
            /**
             * @typedef {null|Object} Js2PyLayoutDeltaMsg
             * @property {Object} layout_delta
             *  The layout delta object that contains all of the properties of
             *  _fullLayout that are not identical to those in the
             *  FigureModel's _layout property
             * @property {Number} layout_edit_id
             *  Edit ID of message that triggered the creation of layout delta
             */
            _js2py_layoutDelta: null, 
            /**
             * @typedef {null|Object} Js2PyTraceDeltasMsg
             * @property {Array.<Object>} trace_deltas
             *  Array of trace delta objects. Each trace delta contains the
             *  trace's uid along with all of the properties of _fullData that
             *  are not identical to those in the FigureModel's _data property
             * @property {Number} trace_edit_id
             *  Edit ID of message that triggered the creation of trace deltas
             */
            _js2py_traceDeltas: null, 
            /**
             * Object representing a collection of points for use in click, hover,
             * and selection events
             * @typedef {Object} Points
             * @property {Array.<Number>} trace_indexes
             *  Array of the trace index for each point
             * @property {Array.<Number>} point_indexes
             *  Array of the index of each point in its own trace
             * @property {null|Array.<Number>} xs
             *  Array of the x coordinate of each point (for cartesian trace types)
             *  or null (for non-cartesian trace types)
             * @property {null|Array.<Number>} ys
             *  Array of the y coordinate of each point (for cartesian trace types)
             *  or null (for non-cartesian trace types
             * @property {null|Array.<Number>} zs
             *  Array of the z coordinate of each point (for 3D cartesian
             *  trace types)
             *  or null (for non-3D-cartesian trace types)
             */
            /**
             * Object representing the state of the input devices during a
             * plotly event
             * @typedef {Object} InputDeviceState
             * @property {boolean} alt - true if alt key pressed,
             * false otherwise
             * @property {boolean} ctrl - true if ctrl key pressed,
             * false otherwise
             * @property {boolean} meta - true if meta key pressed,
             * false otherwise
             * @property {boolean} shift - true if shift key pressed,
             * false otherwise
             *
             * @property {boolean} button
             *  Indicates which button was pressed on the mouse to trigger the
             *  event.
             *    0: Main button pressed, usually the left button or the
             *       un-initialized state
             *    1: Auxiliary button pressed, usually the wheel button or
             *       the middle button (if present)
             *    2: Secondary button pressed, usually the right button
             *    3: Fourth button, typically the Browser Back button
             *    4: Fifth button, typically the Browser Forward button
             *
             * @property {boolean} buttons
             *  Indicates which buttons were pressed on the mouse when the event
             *  is triggered.
             *    0  : No button or un-initialized
             *    1  : Primary button (usually left)
             *    2  : Secondary button (usually right)
             *    4  : Auxilary button (usually middle or mouse wheel button)
             *    8  : 4th button (typically the "Browser Back" button)
             *    16 : 5th button (typically the "Browser Forward" button)
             *
             *  Combinations of buttons are represented by the sum of the codes
             *  above. e.g. a value of 7 indicates buttons 1 (primary),
             *  2 (secondary), and 4 (auxilary) were pressed during the event
             */
            /**
             * @typedef {Object} BoxSelectorState
             * @property {Array.<Number>} xrange
             *  Two element array containing the x-range of the box selection
             * @property {Array.<Number>} yrange
             *  Two element array containing the y-range of the box selection
             */
            /**
             * @typedef {Object} LassoSelectorState
             * @property {Array.<Number>} xs
             *  Array of the x-coordinates of the lasso selection region
             * @property {Array.<Number>} ys
             *  Array of the y-coordinates of the lasso selection region
             */
            /**
             * Object representing the state of the selection tool during a
             * plotly_select event
             * @typedef {Object} Selector
             * @property {String} type
             *  Selection type. One of: 'box', or 'lasso'
             * @property {BoxSelectorState|LassoSelectorState} selector_state
             */
            /**
             * @typedef {null|Object} Js2PyPointsCallbackMsg
             * @property {string} event_type
             *  Name of the triggering event. One of 'plotly_click',
             *  'plotly_hover', 'plotly_unhover', or 'plotly_selected'
             * @property {null|Points} points
             *  Points object for event
             * @property {null|InputDeviceState} device_state
             *  InputDeviceState object for event
             * @property {null|Selector} selector
             *  State of the selection tool for 'plotly_selected' events, null
             *  for other event types
             */
            _js2py_pointsCallback: null, 
            // Message tracking
            // ----------------
            /**
             * @type {Number}
             * layout_edit_id of the last layout modification operation
             * requested by the Python side
             */
            _last_layout_edit_id: 0, 
            /**
             * @type {Number}
             * trace_edit_id of the last trace modification operation
             * requested by the Python side
             */
            _last_trace_edit_id: 0 });
    }
    /**
     * Initialize FigureModel. Called when the Python FigureWidget is first
     * constructed
     */
    initialize() {
        super.initialize.apply(this, arguments);
        this.on("change:_data", this.do_data, this);
        this.on("change:_layout", this.do_layout, this);
        this.on("change:_py2js_addTraces", this.do_addTraces, this);
        this.on("change:_py2js_deleteTraces", this.do_deleteTraces, this);
        this.on("change:_py2js_moveTraces", this.do_moveTraces, this);
        this.on("change:_py2js_restyle", this.do_restyle, this);
        this.on("change:_py2js_relayout", this.do_relayout, this);
        this.on("change:_py2js_update", this.do_update, this);
        this.on("change:_py2js_animate", this.do_animate, this);
        this.on("change:_py2js_removeLayoutProps", this.do_removeLayoutProps, this);
        this.on("change:_py2js_removeTraceProps", this.do_removeTraceProps, this);
    }
    /**
     * Input a trace index specification and return an Array of trace
     * indexes where:
     *
     *  - null|undefined -> Array of all traces
     *  - Trace index as Number -> Single element array of input index
     *  - Array of trace indexes -> Input array unchanged
     *
     * @param {undefined|null|Number|Array.<Number>} trace_indexes
     * @returns {Array.<Number>}
     *  Array of trace indexes
     * @private
     */
    _normalize_trace_indexes(trace_indexes) {
        if (trace_indexes === null || trace_indexes === undefined) {
            var numTraces = this.get("_data").length;
            trace_indexes = lodash__WEBPACK_IMPORTED_MODULE_1___default().range(numTraces);
        }
        if (!Array.isArray(trace_indexes)) {
            // Make sure idx is an array
            trace_indexes = [trace_indexes];
        }
        return trace_indexes;
    }
    /**
     * Log changes to the _data trait
     *
     * This should only happed on FigureModel initialization
     */
    do_data() { }
    /**
     * Log changes to the _layout trait
     *
     * This should only happed on FigureModel initialization
     */
    do_layout() { }
    /**
     * Handle addTraces message
     */
    do_addTraces() {
        // add trace to plot
        /** @type {Py2JsAddTracesMsg} */
        var msgData = this.get("_py2js_addTraces");
        if (msgData !== null) {
            var currentTraces = this.get("_data");
            var newTraces = msgData.trace_data;
            lodash__WEBPACK_IMPORTED_MODULE_1___default().forEach(newTraces, function (newTrace) {
                currentTraces.push(newTrace);
            });
        }
    }
    /**
     * Handle deleteTraces message
     */
    do_deleteTraces() {
        // remove traces from plot
        /** @type {Py2JsDeleteTracesMsg} */
        var msgData = this.get("_py2js_deleteTraces");
        if (msgData !== null) {
            var delete_inds = msgData.delete_inds;
            var tracesData = this.get("_data");
            // Remove del inds in reverse order so indexes remain valid
            // throughout loop
            delete_inds
                .slice()
                .reverse()
                .forEach(function (del_ind) {
                tracesData.splice(del_ind, 1);
            });
        }
    }
    /**
     * Handle moveTraces message
     */
    do_moveTraces() {
        /** @type {Py2JsMoveTracesMsg} */
        var msgData = this.get("_py2js_moveTraces");
        if (msgData !== null) {
            var tracesData = this.get("_data");
            var currentInds = msgData.current_trace_inds;
            var newInds = msgData.new_trace_inds;
            performMoveTracesLike(tracesData, currentInds, newInds);
        }
    }
    /**
     * Handle restyle message
     */
    do_restyle() {
        /** @type {Py2JsRestyleMsg} */
        var msgData = this.get("_py2js_restyle");
        if (msgData !== null) {
            var restyleData = msgData.restyle_data;
            var restyleTraces = this._normalize_trace_indexes(msgData.restyle_traces);
            performRestyleLike(this.get("_data"), restyleData, restyleTraces);
        }
    }
    /**
     * Handle relayout message
     */
    do_relayout() {
        /** @type {Py2JsRelayoutMsg} */
        var msgData = this.get("_py2js_relayout");
        if (msgData !== null) {
            performRelayoutLike(this.get("_layout"), msgData.relayout_data);
        }
    }
    /**
     * Handle update message
     */
    do_update() {
        /** @type {Py2JsUpdateMsg} */
        var msgData = this.get("_py2js_update");
        if (msgData !== null) {
            var style = msgData.style_data;
            var layout = msgData.layout_data;
            var styleTraces = this._normalize_trace_indexes(msgData.style_traces);
            performRestyleLike(this.get("_data"), style, styleTraces);
            performRelayoutLike(this.get("_layout"), layout);
        }
    }
    /**
     * Handle animate message
     */
    do_animate() {
        /** @type {Py2JsAnimateMsg} */
        var msgData = this.get("_py2js_animate");
        if (msgData !== null) {
            var styles = msgData.style_data;
            var layout = msgData.layout_data;
            var trace_indexes = this._normalize_trace_indexes(msgData.style_traces);
            for (var i = 0; i < styles.length; i++) {
                var style = styles[i];
                var trace_index = trace_indexes[i];
                var trace = this.get("_data")[trace_index];
                performRelayoutLike(trace, style);
            }
            performRelayoutLike(this.get("_layout"), layout);
        }
    }
    /**
     * Handle removeLayoutProps message
     */
    do_removeLayoutProps() {
        /** @type {Py2JsRemoveLayoutPropsMsg} */
        var msgData = this.get("_py2js_removeLayoutProps");
        if (msgData !== null) {
            var keyPaths = msgData.remove_props;
            var layout = this.get("_layout");
            performRemoveProps(layout, keyPaths);
        }
    }
    /**
     * Handle removeTraceProps message
     */
    do_removeTraceProps() {
        /** @type {Py2JsRemoveTracePropsMsg} */
        var msgData = this.get("_py2js_removeTraceProps");
        if (msgData !== null) {
            var keyPaths = msgData.remove_props;
            var traceIndex = msgData.remove_trace;
            var trace = this.get("_data")[traceIndex];
            performRemoveProps(trace, keyPaths);
        }
    }
}
FigureModel.serializers = Object.assign(Object.assign({}, _jupyter_widgets_base__WEBPACK_IMPORTED_MODULE_0__.DOMWidgetModel.serializers), { _data: { deserialize: py2js_deserializer, serialize: js2py_serializer }, _layout: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _py2js_addTraces: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _py2js_deleteTraces: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _py2js_moveTraces: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _py2js_restyle: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _py2js_relayout: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _py2js_update: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _py2js_animate: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _py2js_removeLayoutProps: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _py2js_removeTraceProps: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _js2py_restyle: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _js2py_relayout: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _js2py_update: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _js2py_layoutDelta: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _js2py_traceDeltas: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    }, _js2py_pointsCallback: {
        deserialize: py2js_deserializer,
        serialize: js2py_serializer,
    } });
FigureModel.model_name = "FigureModel";
FigureModel.model_module = _version__WEBPACK_IMPORTED_MODULE_3__.MODULE_NAME;
FigureModel.model_module_version = semver_range;
FigureModel.view_name = "FigureView";
FigureModel.view_module = _version__WEBPACK_IMPORTED_MODULE_3__.MODULE_NAME;
FigureModel.view_module_version = semver_range;
// View
// ====
/**
 * A FigureView manages the visual presentation of a single Plotly.js
 * figure for a single notebook output cell. Each FigureView has a
 * reference to FigureModel.  Multiple views may share a single model
 * instance, as is the case when a Python FigureWidget is displayed in
 * multiple notebook output cells.
 *
 * @type {widgets.DOMWidgetView}
 */
class FigureView extends _jupyter_widgets_base__WEBPACK_IMPORTED_MODULE_0__.DOMWidgetView {
    /**
     * The perform_render method is called by processPhosphorMessage
     * after the widget's DOM element has been attached to the notebook
     * output cell. This happens after the initialize of the
     * FigureModel, and it won't happen at all if the Python FigureWidget
     * is never displayed in a notebook output cell
     */
    perform_render() {
        var _a, _b, _c, _d;
        var that = this;
        // Wire up message property callbacks
        // ----------------------------------
        // Python -> JS event properties
        this.model.on("change:_py2js_addTraces", this.do_addTraces, this);
        this.model.on("change:_py2js_deleteTraces", this.do_deleteTraces, this);
        this.model.on("change:_py2js_moveTraces", this.do_moveTraces, this);
        this.model.on("change:_py2js_restyle", this.do_restyle, this);
        this.model.on("change:_py2js_relayout", this.do_relayout, this);
        this.model.on("change:_py2js_update", this.do_update, this);
        this.model.on("change:_py2js_animate", this.do_animate, this);
        // MathJax v2 configuration
        // ---------------------
        (_d = (_c = (_b = (_a = window) === null || _a === void 0 ? void 0 : _a.MathJax) === null || _b === void 0 ? void 0 : _b.Hub) === null || _c === void 0 ? void 0 : _c.Config) === null || _d === void 0 ? void 0 : _d.call(_c, { SVG: { font: "STIX-Web" } });
        // Get message ids
        // ---------------------
        var layout_edit_id = this.model.get("_last_layout_edit_id");
        var trace_edit_id = this.model.get("_last_trace_edit_id");
        // Set view UID
        // ------------
        this.viewID = randstr();
        // Initialize Plotly.js figure
        // ---------------------------
        // We must clone the model's data and layout properties so that
        // the model is not directly mutated by the Plotly.js library.
        var initialTraces = lodash__WEBPACK_IMPORTED_MODULE_1___default().cloneDeep(this.model.get("_data"));
        var initialLayout = lodash__WEBPACK_IMPORTED_MODULE_1___default().cloneDeep(this.model.get("_layout"));
        var config = this.model.get("_config");
        plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().newPlot(that.el, initialTraces, initialLayout, config).then(function () {
            // ### Send trace deltas ###
            // We create an array of deltas corresponding to the new
            // traces.
            that._sendTraceDeltas(trace_edit_id);
            // ### Send layout delta ###
            that._sendLayoutDelta(layout_edit_id);
            // Wire up plotly event callbacks
            that.el.on("plotly_restyle", function (update) {
                that.handle_plotly_restyle(update);
            });
            that.el.on("plotly_relayout", function (update) {
                that.handle_plotly_relayout(update);
            });
            that.el.on("plotly_update", function (update) {
                that.handle_plotly_update(update);
            });
            that.el.on("plotly_click", function (update) {
                that.handle_plotly_click(update);
            });
            that.el.on("plotly_hover", function (update) {
                that.handle_plotly_hover(update);
            });
            that.el.on("plotly_unhover", function (update) {
                that.handle_plotly_unhover(update);
            });
            that.el.on("plotly_selected", function (update) {
                that.handle_plotly_selected(update);
            });
            that.el.on("plotly_deselect", function (update) {
                that.handle_plotly_deselect(update);
            });
            that.el.on("plotly_doubleclick", function (update) {
                that.handle_plotly_doubleclick(update);
            });
            // Emit event indicating that the widget has finished
            // rendering
            var event = new CustomEvent("plotlywidget-after-render", {
                detail: { element: that.el, viewID: that.viewID },
            });
            // Dispatch/Trigger/Fire the event
            document.dispatchEvent(event);
        });
    }
    /**
     * Respond to phosphorjs events
     */
    processPhosphorMessage(msg) {
        super.processPhosphorMessage.apply(this, arguments);
        var that = this;
        switch (msg.type) {
            case "before-attach":
                // Render an initial empty figure. This establishes with
                // the page that the element will not be empty, avoiding
                // some occasions where the dynamic sizing behavior leads
                // to collapsed figure dimensions.
                var axisHidden = {
                    showgrid: false,
                    showline: false,
                    tickvals: [],
                };
                plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().newPlot(that.el, [], {
                    xaxis: axisHidden,
                    yaxis: axisHidden,
                });
                window.addEventListener("resize", function () {
                    that.autosizeFigure();
                });
                break;
            case "after-attach":
                // Rendering actual figure in the after-attach event allows
                // Plotly.js to size the figure to fill the available element
                this.perform_render();
                break;
            case "after-show":
            case "resize":
                this.autosizeFigure();
                break;
        }
    }
    autosizeFigure() {
        var that = this;
        var layout = that.model.get("_layout");
        if (lodash__WEBPACK_IMPORTED_MODULE_1___default().isNil(layout) || lodash__WEBPACK_IMPORTED_MODULE_1___default().isNil(layout.width)) {
            // @ts-ignore
            plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().Plots.resize(that.el).then(function () {
                var layout_edit_id = that.model.get("_last_layout_edit_id");
                that._sendLayoutDelta(layout_edit_id);
            });
        }
    }
    /**
     * Purge Plotly.js data structures from the notebook output display
     * element when the view is destroyed
     */
    destroy() {
        plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().purge(this.el);
    }
    /**
     * Return the figure's _fullData array merged with its data array
     *
     * The merge ensures that for any properties that el._fullData and
     * el.data have in common, we return the version from el.data
     *
     * Named colorscales are one example of why this is needed. The el.data
     * array will hold named colorscale strings (e.g. 'Viridis'), while the
     * el._fullData array will hold the actual colorscale array. e.g.
     *
     *      el.data[0].marker.colorscale == 'Viridis' but
     *      el._fullData[0].marker.colorscale = [[..., ...], ...]
     *
     * Performing the merge allows our FigureModel to retain the 'Viridis'
     * string, rather than having it overridded by the colorscale array.
     *
     */
    getFullData() {
        return lodash__WEBPACK_IMPORTED_MODULE_1___default().mergeWith({}, this.el._fullData, this.el.data, fullMergeCustomizer);
    }
    /**
     * Return the figure's _fullLayout object merged with its layout object
     *
     * See getFullData documentation for discussion of why the merge is
     * necessary
     */
    getFullLayout() {
        return lodash__WEBPACK_IMPORTED_MODULE_1___default().mergeWith({}, this.el._fullLayout, this.el.layout, fullMergeCustomizer);
    }
    /**
     * Build Points data structure from data supplied by the plotly_click,
     * plotly_hover, or plotly_select events
     * @param {Object} data
     * @returns {null|Points}
     */
    buildPointsObject(data) {
        var pointsObject;
        if (data.hasOwnProperty("points")) {
            // Most cartesian plots
            var pointObjects = data["points"];
            var numPoints = pointObjects.length;
            var hasNestedPointObjects = true;
            for (let i = 0; i < numPoints; i++) {
                hasNestedPointObjects =
                    hasNestedPointObjects &&
                        pointObjects[i].hasOwnProperty("pointNumbers");
                if (!hasNestedPointObjects)
                    break;
            }
            var numPointNumbers = numPoints;
            if (hasNestedPointObjects) {
                numPointNumbers = 0;
                for (let i = 0; i < numPoints; i++) {
                    numPointNumbers += pointObjects[i]["pointNumbers"].length;
                }
            }
            pointsObject = {
                trace_indexes: new Array(numPointNumbers),
                point_indexes: new Array(numPointNumbers),
                xs: new Array(numPointNumbers),
                ys: new Array(numPointNumbers),
            };
            if (hasNestedPointObjects) {
                var flatPointIndex = 0;
                for (var p = 0; p < numPoints; p++) {
                    for (let i = 0; i < pointObjects[p]["pointNumbers"].length; i++, flatPointIndex++) {
                        pointsObject["point_indexes"][flatPointIndex] =
                            pointObjects[p]["pointNumbers"][i];
                        // also add xs, ys and traces so that the array doesn't get truncated later
                        pointsObject["xs"][flatPointIndex] = pointObjects[p]["x"];
                        pointsObject["ys"][flatPointIndex] = pointObjects[p]["y"];
                        pointsObject["trace_indexes"][flatPointIndex] =
                            pointObjects[p]["curveNumber"];
                    }
                }
                let single_trace = true;
                for (let i = 1; i < numPointNumbers; i++) {
                    single_trace = single_trace && (pointsObject["trace_indexes"][i - 1] === pointsObject["trace_indexes"][i]);
                    if (!single_trace)
                        break;
                }
                if (single_trace) {
                    pointsObject["point_indexes"].sort((function (a, b) {
                        return a - b;
                    }));
                }
            }
            else {
                for (var p = 0; p < numPoints; p++) {
                    pointsObject["trace_indexes"][p] = pointObjects[p]["curveNumber"];
                    pointsObject["point_indexes"][p] = pointObjects[p]["pointNumber"];
                    pointsObject["xs"][p] = pointObjects[p]["x"];
                    pointsObject["ys"][p] = pointObjects[p]["y"];
                }
            }
            // Add z if present
            var hasZ = pointObjects[0] !== undefined && pointObjects[0].hasOwnProperty("z");
            if (hasZ) {
                pointsObject["zs"] = new Array(numPoints);
                for (p = 0; p < numPoints; p++) {
                    pointsObject["zs"][p] = pointObjects[p]["z"];
                }
            }
            return pointsObject;
        }
        else {
            return null;
        }
    }
    /**
     * Build InputDeviceState data structure from data supplied by the
     * plotly_click, plotly_hover, or plotly_select events
     * @param {Object} data
     * @returns {null|InputDeviceState}
     */
    buildInputDeviceStateObject(data) {
        var event = data["event"];
        if (event === undefined) {
            return null;
        }
        else {
            /** @type {InputDeviceState} */
            var inputDeviceState = {
                // Keyboard modifiers
                alt: event["altKey"],
                ctrl: event["ctrlKey"],
                meta: event["metaKey"],
                shift: event["shiftKey"],
                // Mouse buttons
                button: event["button"],
                buttons: event["buttons"],
            };
            return inputDeviceState;
        }
    }
    /**
     * Build Selector data structure from data supplied by the
     * plotly_select event
     * @param data
     * @returns {null|Selector}
     */
    buildSelectorObject(data) {
        var selectorObject;
        if (data.hasOwnProperty("range")) {
            // Box selection
            selectorObject = {
                type: "box",
                selector_state: {
                    xrange: data["range"]["x"],
                    yrange: data["range"]["y"],
                },
            };
        }
        else if (data.hasOwnProperty("lassoPoints")) {
            // Lasso selection
            selectorObject = {
                type: "lasso",
                selector_state: {
                    xs: data["lassoPoints"]["x"],
                    ys: data["lassoPoints"]["y"],
                },
            };
        }
        else {
            selectorObject = null;
        }
        return selectorObject;
    }
    /**
     * Handle ploty_restyle events emitted by the Plotly.js library
     * @param data
     */
    handle_plotly_restyle(data) {
        if (data === null || data === undefined) {
            // No data to report to the Python side
            return;
        }
        if (data[0] && data[0].hasOwnProperty("_doNotReportToPy")) {
            // Restyle originated on the Python side
            return;
        }
        // Unpack data
        var styleData = data[0];
        var styleTraces = data[1];
        // Construct restyle message to send to the Python side
        /** @type {Js2PyRestyleMsg} */
        var restyleMsg = {
            style_data: styleData,
            style_traces: styleTraces,
            source_view_id: this.viewID,
        };
        this.model.set("_js2py_restyle", restyleMsg);
        this.touch();
    }
    /**
     * Handle plotly_relayout events emitted by the Plotly.js library
     * @param data
     */
    handle_plotly_relayout(data) {
        if (data === null || data === undefined) {
            // No data to report to the Python side
            return;
        }
        if (data.hasOwnProperty("_doNotReportToPy")) {
            // Relayout originated on the Python side
            return;
        }
        /** @type {Js2PyRelayoutMsg} */
        var relayoutMsg = {
            relayout_data: data,
            source_view_id: this.viewID,
        };
        this.model.set("_js2py_relayout", relayoutMsg);
        this.touch();
    }
    /**
     * Handle plotly_update events emitted by the Plotly.js library
     * @param data
     */
    handle_plotly_update(data) {
        if (data === null || data === undefined) {
            // No data to report to the Python side
            return;
        }
        if (data["data"] && data["data"][0].hasOwnProperty("_doNotReportToPy")) {
            // Update originated on the Python side
            return;
        }
        /** @type {Js2PyUpdateMsg} */
        var updateMsg = {
            style_data: data["data"][0],
            style_traces: data["data"][1],
            layout_data: data["layout"],
            source_view_id: this.viewID,
        };
        // Log message
        this.model.set("_js2py_update", updateMsg);
        this.touch();
    }
    /**
     * Handle plotly_click events emitted by the Plotly.js library
     * @param data
     */
    handle_plotly_click(data) {
        this._send_points_callback_message(data, "plotly_click");
    }
    /**
     * Handle plotly_hover events emitted by the Plotly.js library
     * @param data
     */
    handle_plotly_hover(data) {
        this._send_points_callback_message(data, "plotly_hover");
    }
    /**
     * Handle plotly_unhover events emitted by the Plotly.js library
     * @param data
     */
    handle_plotly_unhover(data) {
        this._send_points_callback_message(data, "plotly_unhover");
    }
    /**
     * Handle plotly_selected events emitted by the Plotly.js library
     * @param data
     */
    handle_plotly_selected(data) {
        this._send_points_callback_message(data, "plotly_selected");
    }
    /**
     * Handle plotly_deselect events emitted by the Plotly.js library
     * @param data
     */
    handle_plotly_deselect(data) {
        data = {
            points: [],
        };
        this._send_points_callback_message(data, "plotly_deselect");
    }
    /**
     * Build and send a points callback message to the Python side
     *
     * @param {Object} data
     *  data object as provided by the plotly_click, plotly_hover,
     *  plotly_unhover, or plotly_selected events
     * @param {String} event_type
     *  Name of the triggering event. One of 'plotly_click',
     *  'plotly_hover', 'plotly_unhover', or 'plotly_selected'
     * @private
     */
    _send_points_callback_message(data, event_type) {
        if (data === null || data === undefined) {
            // No data to report to the Python side
            return;
        }
        /** @type {Js2PyPointsCallbackMsg} */
        var pointsMsg = {
            event_type: event_type,
            points: this.buildPointsObject(data),
            device_state: this.buildInputDeviceStateObject(data),
            selector: this.buildSelectorObject(data),
        };
        if (pointsMsg["points"] !== null && pointsMsg["points"] !== undefined) {
            this.model.set("_js2py_pointsCallback", pointsMsg);
            this.touch();
        }
    }
    /**
     * Stub for future handling of plotly_doubleclick
     * @param data
     */
    handle_plotly_doubleclick(data) { }
    /**
     * Handle Plotly.addTraces request
     */
    do_addTraces() {
        /** @type {Py2JsAddTracesMsg} */
        var msgData = this.model.get("_py2js_addTraces");
        if (msgData !== null) {
            var that = this;
            plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().addTraces(this.el, msgData.trace_data).then(function () {
                // ### Send trace deltas ###
                that._sendTraceDeltas(msgData.trace_edit_id);
                // ### Send layout delta ###
                var layout_edit_id = msgData.layout_edit_id;
                that._sendLayoutDelta(layout_edit_id);
            });
        }
    }
    /**
     * Handle Plotly.deleteTraces request
     */
    do_deleteTraces() {
        /** @type {Py2JsDeleteTracesMsg} */
        var msgData = this.model.get("_py2js_deleteTraces");
        if (msgData !== null) {
            var delete_inds = msgData.delete_inds;
            var that = this;
            plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().deleteTraces(this.el, delete_inds).then(function () {
                // ### Send trace deltas ###
                var trace_edit_id = msgData.trace_edit_id;
                that._sendTraceDeltas(trace_edit_id);
                // ### Send layout delta ###
                var layout_edit_id = msgData.layout_edit_id;
                that._sendLayoutDelta(layout_edit_id);
            });
        }
    }
    /**
     * Handle Plotly.moveTraces request
     */
    do_moveTraces() {
        /** @type {Py2JsMoveTracesMsg} */
        var msgData = this.model.get("_py2js_moveTraces");
        if (msgData !== null) {
            // Unpack message
            var currentInds = msgData.current_trace_inds;
            var newInds = msgData.new_trace_inds;
            // Check if the new trace indexes are actually different than
            // the current indexes
            var inds_equal = lodash__WEBPACK_IMPORTED_MODULE_1___default().isEqual(currentInds, newInds);
            if (!inds_equal) {
                plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().moveTraces(this.el, currentInds, newInds);
            }
        }
    }
    /**
     * Handle Plotly.restyle request
     */
    do_restyle() {
        /** @type {Py2JsRestyleMsg} */
        var msgData = this.model.get("_py2js_restyle");
        if (msgData !== null) {
            var restyleData = msgData.restyle_data;
            var traceIndexes = this.model._normalize_trace_indexes(msgData.restyle_traces);
            restyleData["_doNotReportToPy"] = true;
            plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().restyle(this.el, restyleData, traceIndexes);
            // ### Send trace deltas ###
            // We create an array of deltas corresponding to the restyled
            // traces.
            this._sendTraceDeltas(msgData.trace_edit_id);
            // ### Send layout delta ###
            var layout_edit_id = msgData.layout_edit_id;
            this._sendLayoutDelta(layout_edit_id);
        }
    }
    /**
     * Handle Plotly.relayout request
     */
    do_relayout() {
        /** @type {Py2JsRelayoutMsg} */
        var msgData = this.model.get("_py2js_relayout");
        if (msgData !== null) {
            if (msgData.source_view_id !== this.viewID) {
                var relayoutData = msgData.relayout_data;
                relayoutData["_doNotReportToPy"] = true;
                plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().relayout(this.el, msgData.relayout_data);
            }
            // ### Send layout delta ###
            var layout_edit_id = msgData.layout_edit_id;
            this._sendLayoutDelta(layout_edit_id);
        }
    }
    /**
     * Handle Plotly.update request
     */
    do_update() {
        /** @type {Py2JsUpdateMsg} */
        var msgData = this.model.get("_py2js_update");
        if (msgData !== null) {
            var style = msgData.style_data || {};
            var layout = msgData.layout_data || {};
            var traceIndexes = this.model._normalize_trace_indexes(msgData.style_traces);
            style["_doNotReportToPy"] = true;
            plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().update(this.el, style, layout, traceIndexes);
            // ### Send trace deltas ###
            // We create an array of deltas corresponding to the updated
            // traces.
            this._sendTraceDeltas(msgData.trace_edit_id);
            // ### Send layout delta ###
            var layout_edit_id = msgData.layout_edit_id;
            this._sendLayoutDelta(layout_edit_id);
        }
    }
    /**
     * Handle Plotly.animate request
     */
    do_animate() {
        /** @type {Py2JsAnimateMsg} */
        var msgData = this.model.get("_py2js_animate");
        if (msgData !== null) {
            // Unpack params
            // var animationData = msgData[0];
            var animationOpts = msgData.animation_opts;
            var styles = msgData.style_data;
            var layout = msgData.layout_data;
            var traceIndexes = this.model._normalize_trace_indexes(msgData.style_traces);
            var animationData = {
                data: styles,
                layout: layout,
                traces: traceIndexes,
            };
            animationData["_doNotReportToPy"] = true;
            var that = this;
            // @ts-ignore
            plotly_js_dist_plotly__WEBPACK_IMPORTED_MODULE_2___default().animate(this.el, animationData, animationOpts).then(function () {
                // ### Send trace deltas ###
                // We create an array of deltas corresponding to the
                // animated traces.
                that._sendTraceDeltas(msgData.trace_edit_id);
                // ### Send layout delta ###
                var layout_edit_id = msgData.layout_edit_id;
                that._sendLayoutDelta(layout_edit_id);
            });
        }
    }
    /**
     * Construct layout delta object and send layoutDelta message to the
     * Python side
     *
     * @param layout_edit_id
     *  Edit ID of message that triggered the creation of the layout delta
     * @private
     */
    _sendLayoutDelta(layout_edit_id) {
        // ### Handle layout delta ###
        var layout_delta = createDeltaObject(this.getFullLayout(), this.model.get("_layout"));
        /** @type{Js2PyLayoutDeltaMsg} */
        var layoutDeltaMsg = {
            layout_delta: layout_delta,
            layout_edit_id: layout_edit_id,
        };
        this.model.set("_js2py_layoutDelta", layoutDeltaMsg);
        this.touch();
    }
    /**
     * Construct trace deltas array for the requested trace indexes and
     * send traceDeltas message to the Python side
     *  Array of indexes of traces for which to compute deltas
     * @param trace_edit_id
     *  Edit ID of message that triggered the creation of trace deltas
     * @private
     */
    _sendTraceDeltas(trace_edit_id) {
        var trace_data = this.model.get("_data");
        var traceIndexes = lodash__WEBPACK_IMPORTED_MODULE_1___default().range(trace_data.length);
        var trace_deltas = new Array(traceIndexes.length);
        var fullData = this.getFullData();
        for (var i = 0; i < traceIndexes.length; i++) {
            var traceInd = traceIndexes[i];
            trace_deltas[i] = createDeltaObject(fullData[traceInd], trace_data[traceInd]);
        }
        /** @type{Js2PyTraceDeltasMsg} */
        var traceDeltasMsg = {
            trace_deltas: trace_deltas,
            trace_edit_id: trace_edit_id,
        };
        this.model.set("_js2py_traceDeltas", traceDeltasMsg);
        this.touch();
    }
}
// Serialization
/**
 * Create a mapping from numpy dtype strings to corresponding typed array
 * constructors
 */
const numpy_dtype_to_typedarray_type = {
    int8: Int8Array,
    int16: Int16Array,
    int32: Int32Array,
    uint8: Uint8Array,
    uint16: Uint16Array,
    uint32: Uint32Array,
    float32: Float32Array,
    float64: Float64Array,
};
function serializeTypedArray(v) {
    var numpyType;
    if (v instanceof Int8Array) {
        numpyType = "int8";
    }
    else if (v instanceof Int16Array) {
        numpyType = "int16";
    }
    else if (v instanceof Int32Array) {
        numpyType = "int32";
    }
    else if (v instanceof Uint8Array) {
        numpyType = "uint8";
    }
    else if (v instanceof Uint16Array) {
        numpyType = "uint16";
    }
    else if (v instanceof Uint32Array) {
        numpyType = "uint32";
    }
    else if (v instanceof Float32Array) {
        numpyType = "float32";
    }
    else if (v instanceof Float64Array) {
        numpyType = "float64";
    }
    else {
        // Don't understand it, return as is
        return v;
    }
    var res = {
        dtype: numpyType,
        shape: [v.length],
        value: v.buffer,
    };
    return res;
}
/**
 * ipywidget JavaScript -> Python serializer
 */
function js2py_serializer(v, widgetManager) {
    var res;
    if (lodash__WEBPACK_IMPORTED_MODULE_1___default().isTypedArray(v)) {
        res = serializeTypedArray(v);
    }
    else if (Array.isArray(v)) {
        // Serialize array elements recursively
        res = new Array(v.length);
        for (var i = 0; i < v.length; i++) {
            res[i] = js2py_serializer(v[i]);
        }
    }
    else if (lodash__WEBPACK_IMPORTED_MODULE_1___default().isPlainObject(v)) {
        // Serialize object properties recursively
        res = {};
        for (var p in v) {
            if (v.hasOwnProperty(p)) {
                res[p] = js2py_serializer(v[p]);
            }
        }
    }
    else if (v === undefined) {
        // Translate undefined into '_undefined_' sentinal string. The
        // Python _js_to_py deserializer will convert this into an
        // Undefined object
        res = "_undefined_";
    }
    else {
        // Primitive value to transfer directly
        res = v;
    }
    return res;
}
/**
 * ipywidget Python -> Javascript deserializer
 */
function py2js_deserializer(v, widgetManager) {
    var res;
    if (Array.isArray(v)) {
        // Deserialize array elements recursively
        res = new Array(v.length);
        for (var i = 0; i < v.length; i++) {
            res[i] = py2js_deserializer(v[i]);
        }
    }
    else if (lodash__WEBPACK_IMPORTED_MODULE_1___default().isPlainObject(v)) {
        if ((lodash__WEBPACK_IMPORTED_MODULE_1___default().has(v, "value") || lodash__WEBPACK_IMPORTED_MODULE_1___default().has(v, "buffer")) &&
            lodash__WEBPACK_IMPORTED_MODULE_1___default().has(v, "dtype") &&
            lodash__WEBPACK_IMPORTED_MODULE_1___default().has(v, "shape")) {
            // Deserialize special buffer/dtype/shape objects into typed arrays
            // These objects correspond to numpy arrays on the Python side
            //
            // Note plotly.py<=3.1.1 called the buffer object `buffer`
            // This was renamed `value` in 3.2 to work around a naming conflict
            // when saving widget state to a notebook.
            // @ts-ignore
            var typedarray_type = numpy_dtype_to_typedarray_type[v.dtype];
            var buffer = lodash__WEBPACK_IMPORTED_MODULE_1___default().has(v, "value") ? v.value.buffer : v.buffer.buffer;
            res = new typedarray_type(buffer);
        }
        else {
            // Deserialize object properties recursively
            res = {};
            for (var p in v) {
                if (v.hasOwnProperty(p)) {
                    res[p] = py2js_deserializer(v[p]);
                }
            }
        }
    }
    else if (v === "_undefined_") {
        // Convert the _undefined_ sentinal into undefined
        res = undefined;
    }
    else {
        // Accept primitive value directly
        res = v;
    }
    return res;
}
/**
 * Return whether the input value is a typed array
 * @param potentialTypedArray
 *  Value to examine
 * @returns {boolean}
 */
function isTypedArray(potentialTypedArray) {
    return (ArrayBuffer.isView(potentialTypedArray) &&
        !(potentialTypedArray instanceof DataView));
}
/**
 * Customizer for use with lodash's mergeWith function
 *
 * The customizer ensures that typed arrays are not converted into standard
 * arrays during the recursive merge
 *
 * See: https://lodash.com/docs/latest#mergeWith
 */
function fullMergeCustomizer(objValue, srcValue, key) {
    if (key[0] === "_") {
        // Don't recurse into private properties
        return null;
    }
    else if (isTypedArray(srcValue)) {
        // Return typed arrays directly, don't recurse inside
        return srcValue;
    }
}
/**
 * Reform a Plotly.relayout like operation on an input object
 *
 * @param {Object} parentObj
 *  The object that the relayout operation should be applied to
 * @param {Object} relayoutData
 *  An relayout object as accepted by Plotly.relayout
 *
 *  Examples:
 *      var d = {foo {bar [5, 10]}};
 *      performRelayoutLike(d, {'foo.bar': [0, 1]});
 *      d -> {foo: {bar: [0, 1]}}
 *
 *      var d = {foo {bar [5, 10]}};
 *      performRelayoutLike(d, {'baz': 34});
 *      d -> {foo: {bar: [5, 10]}, baz: 34}
 *
 *      var d = {foo: {bar: [5, 10]};
 *      performRelayoutLike(d, {'foo.baz[1]': 17});
 *      d -> {foo: {bar: [5, 17]}}
 *
 */
function performRelayoutLike(parentObj, relayoutData) {
    // Perform a relayout style operation on a given parent object
    for (var rawKey in relayoutData) {
        if (!relayoutData.hasOwnProperty(rawKey)) {
            continue;
        }
        // Extract value for this key
        var relayoutVal = relayoutData[rawKey];
        // Set property value
        if (relayoutVal === null) {
            lodash__WEBPACK_IMPORTED_MODULE_1___default().unset(parentObj, rawKey);
        }
        else {
            lodash__WEBPACK_IMPORTED_MODULE_1___default().set(parentObj, rawKey, relayoutVal);
        }
    }
}
/**
 * Perform a Plotly.restyle like operation on an input object array
 *
 * @param {Array.<Object>} parentArray
 *  The object that the restyle operation should be applied to
 * @param {Object} restyleData
 *  A restyle object as accepted by Plotly.restyle
 * @param {Array.<Number>} restyleTraces
 *  Array of indexes of the traces that the resytle operation applies to
 *
 *  Examples:
 *      var d = [{foo: {bar: 1}}, {}, {}]
 *      performRestyleLike(d, {'foo.bar': 2}, [0])
 *      d -> [{foo: {bar: 2}}, {}, {}]
 *
 *      var d = [{foo: {bar: 1}}, {}, {}]
 *      performRestyleLike(d, {'foo.bar': 2}, [0, 1, 2])
 *      d -> [{foo: {bar: 2}}, {foo: {bar: 2}}, {foo: {bar: 2}}]
 *
 *      var d = [{foo: {bar: 1}}, {}, {}]
 *      performRestyleLike(d, {'foo.bar': [2, 3, 4]}, [0, 1, 2])
 *      d -> [{foo: {bar: 2}}, {foo: {bar: 3}}, {foo: {bar: 4}}]
 *
 */
function performRestyleLike(parentArray, restyleData, restyleTraces) {
    // Loop over the properties of restyleData
    for (var rawKey in restyleData) {
        if (!restyleData.hasOwnProperty(rawKey)) {
            continue;
        }
        // Extract value for property and normalize into a value list
        var valArray = restyleData[rawKey];
        if (!Array.isArray(valArray)) {
            valArray = [valArray];
        }
        // Loop over the indexes of the traces being restyled
        for (var i = 0; i < restyleTraces.length; i++) {
            // Get trace object
            var traceInd = restyleTraces[i];
            var trace = parentArray[traceInd];
            // Extract value for this trace
            var singleVal = valArray[i % valArray.length];
            // Set property value
            if (singleVal === null) {
                lodash__WEBPACK_IMPORTED_MODULE_1___default().unset(trace, rawKey);
            }
            else if (singleVal !== undefined) {
                lodash__WEBPACK_IMPORTED_MODULE_1___default().set(trace, rawKey, singleVal);
            }
        }
    }
}
/**
 * Perform a Plotly.moveTraces like operation on an input object array
 * @param parentArray
 *  The object that the moveTraces operation should be applied to
 * @param currentInds
 *  Array of the current indexes of traces to be moved
 * @param newInds
 *  Array of the new indexes that traces selected by currentInds should be
 *  moved to.
 *
 *  Examples:
 *      var d = [{foo: 0}, {foo: 1}, {foo: 2}]
 *      performMoveTracesLike(d, [0, 1], [2, 0])
 *      d -> [{foo: 1}, {foo: 2}, {foo: 0}]
 *
 *      var d = [{foo: 0}, {foo: 1}, {foo: 2}]
 *      performMoveTracesLike(d, [0, 2], [1, 2])
 *      d -> [{foo: 1}, {foo: 0}, {foo: 2}]
 */
function performMoveTracesLike(parentArray, currentInds, newInds) {
    // ### Remove by currentInds in reverse order ###
    var movingTracesData = [];
    for (var ci = currentInds.length - 1; ci >= 0; ci--) {
        // Insert moving parentArray at beginning of the list
        movingTracesData.splice(0, 0, parentArray[currentInds[ci]]);
        parentArray.splice(currentInds[ci], 1);
    }
    // ### Sort newInds and movingTracesData by newInds ###
    var newIndexSortedArrays = lodash__WEBPACK_IMPORTED_MODULE_1___default()(newInds)
        .zip(movingTracesData)
        .sortBy(0)
        .unzip()
        .value();
    newInds = newIndexSortedArrays[0];
    movingTracesData = newIndexSortedArrays[1];
    // ### Insert by newInds in forward order ###
    for (var ni = 0; ni < newInds.length; ni++) {
        parentArray.splice(newInds[ni], 0, movingTracesData[ni]);
    }
}
/**
 * Remove nested properties from a parent object
 * @param {Object} parentObj
 *  Parent object from which properties or nested properties should be removed
 * @param {Array.<Array.<Number|String>>} keyPaths
 *  Array of key paths for properties that should be removed. Each key path
 *  is an array of properties names or array indexes that reference a
 *  property to be removed
 *
 *  Examples:
 *      var d = {foo: [{bar: 0}, {bar: 1}], baz: 32}
 *      performRemoveProps(d, ['baz'])
 *      d -> {foo: [{bar: 0}, {bar: 1}]}
 *
 *      var d = {foo: [{bar: 0}, {bar: 1}], baz: 32}
 *      performRemoveProps(d, ['foo[1].bar', 'baz'])
 *      d -> {foo: [{bar: 0}, {}]}
 *
 */
function performRemoveProps(parentObj, keyPaths) {
    for (var i = 0; i < keyPaths.length; i++) {
        var keyPath = keyPaths[i];
        lodash__WEBPACK_IMPORTED_MODULE_1___default().unset(parentObj, keyPath);
    }
}
/**
 * Return object that contains all properties in fullObj that are not
 * identical to the corresponding properties in removeObj
 *
 * Properties of fullObj and removeObj may be objects or arrays of objects
 *
 * Returned object is a deep clone of the properties of the input objects
 *
 * @param {Object} fullObj
 * @param {Object} removeObj
 *
 *  Examples:
 *      var fullD = {foo: [{bar: 0}, {bar: 1}], baz: 32}
 *      var removeD = {baz: 32}
 *      createDeltaObject(fullD, removeD)
 *          -> {foo: [{bar: 0}, {bar: 1}]}
 *
 *      var fullD = {foo: [{bar: 0}, {bar: 1}], baz: 32}
 *      var removeD = {baz: 45}
 *      createDeltaObject(fullD, removeD)
 *          -> {foo: [{bar: 0}, {bar: 1}], baz: 32}
 *
 *      var fullD = {foo: [{bar: 0}, {bar: 1}], baz: 32}
 *      var removeD = {foo: [{bar: 0}, {bar: 1}]}
 *      createDeltaObject(fullD, removeD)
 *          -> {baz: 32}
 *
 */
function createDeltaObject(fullObj, removeObj) {
    // Initialize result as object or array
    var res;
    if (Array.isArray(fullObj)) {
        res = new Array(fullObj.length);
    }
    else {
        res = {};
    }
    // Initialize removeObj to empty object if not specified
    if (removeObj === null || removeObj === undefined) {
        removeObj = {};
    }
    // Iterate over object properties or array indices
    for (var p in fullObj) {
        if (p[0] !== "_" && // Don't consider private properties
            fullObj.hasOwnProperty(p) && // Exclude parent properties
            fullObj[p] !== null // Exclude cases where fullObj doesn't
        // have the property
        ) {
            // Compute object equality
            var props_equal;
            props_equal = lodash__WEBPACK_IMPORTED_MODULE_1___default().isEqual(fullObj[p], removeObj[p]);
            // Perform recursive comparison if props are not equal
            if (!props_equal || p === "uid") {
                // Let uids through
                // property has non-null value in fullObj that doesn't
                // match the value in removeObj
                var fullVal = fullObj[p];
                if (removeObj.hasOwnProperty(p) && typeof fullVal === "object") {
                    // Recurse over object properties
                    if (Array.isArray(fullVal)) {
                        if (fullVal.length > 0 && typeof fullVal[0] === "object") {
                            // We have an object array
                            res[p] = new Array(fullVal.length);
                            for (var i = 0; i < fullVal.length; i++) {
                                if (!Array.isArray(removeObj[p]) || removeObj[p].length <= i) {
                                    res[p][i] = fullVal[i];
                                }
                                else {
                                    res[p][i] = createDeltaObject(fullVal[i], removeObj[p][i]);
                                }
                            }
                        }
                        else {
                            // We have a primitive array or typed array
                            res[p] = fullVal;
                        }
                    }
                    else {
                        // object
                        var full_obj = createDeltaObject(fullVal, removeObj[p]);
                        if (Object.keys(full_obj).length > 0) {
                            // new object is not empty
                            res[p] = full_obj;
                        }
                    }
                }
                else if (typeof fullVal === "object" && !Array.isArray(fullVal)) {
                    // Return 'clone' of fullVal
                    // We don't use a standard clone method so that we keep
                    // the special case handling of this method
                    res[p] = createDeltaObject(fullVal, {});
                }
                else if (fullVal !== undefined && typeof fullVal !== "function") {
                    // No recursion necessary, Just keep value from fullObj.
                    // But skip values with function type
                    res[p] = fullVal;
                }
            }
        }
    }
    return res;
}
function randstr(existing, bits, base, _recursion) {
    if (!base)
        base = 16;
    if (bits === undefined)
        bits = 24;
    if (bits <= 0)
        return "0";
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    var res = "";
    var i, b, x;
    for (i = 2; digits === Infinity; i *= 2) {
        digits = (Math.log(Math.pow(2, bits / i)) / Math.log(base)) * i;
    }
    var rem = digits - Math.floor(digits);
    for (i = 0; i < Math.floor(digits); i++) {
        x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    if (rem) {
        b = Math.pow(base, rem);
        x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    var parsed = parseInt(res, base);
    if ((existing && existing[res]) ||
        (parsed !== Infinity && parsed >= Math.pow(2, bits))) {
        if (_recursion > 10) {
            console.warn("randstr failed uniqueness");
            return res;
        }
        return randstr(existing, bits, base, (_recursion || 0) + 1);
    }
    else
        return res;
}


/***/ }),

/***/ "../../node_modules/jupyterlab-plotly/lib/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/jupyterlab-plotly/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FigureModel": () => (/* reexport safe */ _Figure__WEBPACK_IMPORTED_MODULE_0__.FigureModel),
/* harmony export */   "FigureView": () => (/* reexport safe */ _Figure__WEBPACK_IMPORTED_MODULE_0__.FigureView),
/* harmony export */   "MODULE_NAME": () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_1__.MODULE_NAME),
/* harmony export */   "MODULE_VERSION": () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_1__.MODULE_VERSION)
/* harmony export */ });
/* harmony import */ var _Figure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Figure */ "../../node_modules/jupyterlab-plotly/lib/Figure.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version */ "../../node_modules/jupyterlab-plotly/lib/version.js");
// Export widget models and views, and the npm package version number.




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2p1cHl0ZXJsYWItcGxvdGx5L2xpYi9GaWd1cmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9qdXB5dGVybGFiLXBsb3RseS9saWIvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ2hEO0FBQ29CO0FBQ2E7QUFDeEQ7QUFDQSx1QkFBdUI7QUFDdkIsMkJBQTJCLG9EQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTywwQkFBMEIsaUVBQWM7QUFDL0M7QUFDQSw2Q0FBNkMsc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQywwQkFBMEIsZUFBZTtBQUN6QztBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckMsMEJBQTBCLGVBQWU7QUFDekM7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQywwQkFBMEIsT0FB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QUFPO0FBQy9DO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsb0JBQW9CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM3BEQTtBQUN5QjtBQUNDIiwiZmlsZSI6InZlbmRvcnMtbm9kZV9tb2R1bGVzX2p1cHl0ZXJsYWItcGxvdGx5X2xpYl9pbmRleF9qcy5lMTcwYjUzMTkzNDUxYzVmODVjNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPTVdpZGdldE1vZGVsLCBET01XaWRnZXRWaWV3LCB9IGZyb20gXCJAanVweXRlci13aWRnZXRzL2Jhc2VcIjtcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBQbG90bHkgZnJvbSBcInBsb3RseS5qcy9kaXN0L3Bsb3RseVwiO1xuaW1wb3J0IHsgTU9EVUxFX05BTUUsIE1PRFVMRV9WRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvblwiO1xuLy8gQHRzLWlnbm9yZVxud2luZG93LlBsb3RseUNvbmZpZyA9IHsgTWF0aEpheENvbmZpZzogXCJsb2NhbFwiIH07XG5jb25zdCBzZW12ZXJfcmFuZ2UgPSBcIl5cIiArIE1PRFVMRV9WRVJTSU9OO1xuLy8gTW9kZWxcbi8vID09PT09XG4vKipcbiAqIEEgRmlndXJlTW9kZWwgaG9sZHMgYSBtaXJyb3IgY29weSBvZiB0aGUgc3RhdGUgb2YgYSBGaWd1cmVXaWRnZXQgb25cbiAqIHRoZSBQeXRob24gc2lkZS4gIFRoZXJlIGlzIGEgb25lLXRvLW9uZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBKYXZhU2NyaXB0XG4gKiBGaWd1cmVNb2RlbHMgYW5kIFB5dGhvbiBGaWd1cmVXaWRnZXRzLiBUaGUgSmF2YVNjcmlwdCBGaWd1cmVNb2RlbCBpc1xuICogaW5pdGlhbGl6ZWQgYXMgc29vbiBhcyBhIFB5dGhvbiBGaWd1cmVXaWRnZXQgaW5pdGlhbGl6ZWQsIHRoaXMgaGFwcGVuc1xuICogZXZlbiBiZWZvcmUgdGhlIHdpZGdldCBpcyBmaXJzdCBkaXNwbGF5ZWQgaW4gdGhlIE5vdGVib29rXG4gKiBAdHlwZSB7d2lkZ2V0cy5ET01XaWRnZXRNb2RlbH1cbiAqL1xuZXhwb3J0IGNsYXNzIEZpZ3VyZU1vZGVsIGV4dGVuZHMgRE9NV2lkZ2V0TW9kZWwge1xuICAgIGRlZmF1bHRzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdXBlci5kZWZhdWx0cygpKSwgeyBcbiAgICAgICAgICAgIC8vIE1vZGVsIG1ldGFkYXRhXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgX21vZGVsX25hbWU6IEZpZ3VyZU1vZGVsLm1vZGVsX25hbWUsIF9tb2RlbF9tb2R1bGU6IEZpZ3VyZU1vZGVsLm1vZGVsX21vZHVsZSwgX21vZGVsX21vZHVsZV92ZXJzaW9uOiBGaWd1cmVNb2RlbC5tb2RlbF9tb2R1bGVfdmVyc2lvbiwgX3ZpZXdfbmFtZTogRmlndXJlTW9kZWwudmlld19uYW1lLCBfdmlld19tb2R1bGU6IEZpZ3VyZU1vZGVsLnZpZXdfbW9kdWxlLCBfdmlld19tb2R1bGVfdmVyc2lvbjogRmlndXJlTW9kZWwudmlld19tb2R1bGVfdmVyc2lvbiwgXG4gICAgICAgICAgICAvLyBEYXRhIGFuZCBMYXlvdXRcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gVGhlIF9kYXRhIGFuZCBfbGF5b3V0IHByb3BlcnRpZXMgYXJlIHN5bmNocm9uaXplZCB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gUHl0aG9uIHNpZGUgb24gaW5pdGlhbGl6YXRpb24gb25seS4gIEFmdGVyIGluaXRpYWxpemF0aW9uLCB0aGVzZVxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyBhcmUga2VwdCBpbiBzeW5jIHRocm91Z2ggdGhlIHVzZSBvZiB0aGUgX3B5MmpzXypcbiAgICAgICAgICAgIC8vIG1lc3NhZ2VzXG4gICAgICAgICAgICBfZGF0YTogW10sIF9sYXlvdXQ6IHt9LCBfY29uZmlnOiB7fSwgXG4gICAgICAgICAgICAvLyBQeXRob24gLT4gSlMgbWVzc2FnZXNcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgYXJlIGltcGxlbWVudGVkIHVzaW5nIHRyYWl0IHByb3BlcnRpZXMuIFRoaXMgaXMgZG9uZSBzb1xuICAgICAgICAgICAgLy8gdGhhdCB3ZSBjYW4gdGFrZSBhZHZhbnRhZ2Ugb2YgaXB5d2lkZ2V0J3MgYmluYXJ5IHNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgIC8vIHByb3RvY29sLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE1lc3NhZ2VzIGFyZSBzZW50IGJ5IHRoZSBQeXRob24gc2lkZSBieSBhc3NpZ25pbmcgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIC8vIGNvbnRlbnRzIHRvIHRoZSBhcHByb3ByaWF0ZSBfcHkyanNfKiBwcm9wZXJ0eSwgYW5kIHRoZW4gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIHNldHRpbmcgaXQgdG8gTm9uZS4gIE1lc3NhZ2VzIGFyZSByZWNlaXZlZCBieSB0aGUgSmF2YVNjcmlwdFxuICAgICAgICAgICAgLy8gc2lkZSBieSByZWdpc3RlcmluZyBwcm9wZXJ0eSBjaGFuZ2UgY2FsbGJhY2tzIGluIHRoZSBpbml0aWFsaXplXG4gICAgICAgICAgICAvLyBtZXRob2RzIGZvciBGaWd1cmVNb2RlbCBhbmQgRmlndXJlVmlldy4gZS5nLiAod2hlcmUgdGhpcyBpcyBhXG4gICAgICAgICAgICAvLyBGaWd1cmVNb2RlbCk6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgICB0aGlzLm9uKCdjaGFuZ2U6X3B5MmpzX2FkZFRyYWNlcycsIHRoaXMuZG9fYWRkVHJhY2VzLCB0aGlzKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBNZXNzYWdlIGhhbmRsaW5nIG1ldGhvZHMsIGRvX2FkZFRyYWNlcywgYXJlIHJlc3BvbnNpYmxlIGZvclxuICAgICAgICAgICAgLy8gcGVyZm9ybWluZyB0aGUgYXBwcm9wcmlhdGUgYWN0aW9uIGlmIHRoZSBtZXNzYWdlIGNvbnRlbnRzIGFyZVxuICAgICAgICAgICAgLy8gbm90IG51bGxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge251bGx8T2JqZWN0fSBQeTJKc0FkZFRyYWNlc01zZ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48T2JqZWN0Pn0gdHJhY2VfZGF0YVxuICAgICAgICAgICAgICogIEFycmF5IG9mIHRyYWNlcyB0byBhcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgZmlndXJlJ3MgY3VycmVudCB0cmFjZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0cmFjZV9lZGl0X2lkXG4gICAgICAgICAgICAgKiAgRWRpdCBJRCB0byB1c2Ugd2hlbiByZXR1cm5pbmcgdHJhY2UgZGVsdGFzIHVzaW5nXG4gICAgICAgICAgICAgKiAgdGhlIF9qczJweV90cmFjZURlbHRhcyBtZXNzYWdlLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxheW91dF9lZGl0X2lkXG4gICAgICAgICAgICAgKiAgRWRpdCBJRCB0byB1c2Ugd2hlbiByZXR1cm5pbmcgbGF5b3V0IGRlbHRhcyB1c2luZ1xuICAgICAgICAgICAgICogIHRoZSBfanMycHlfbGF5b3V0RGVsdGEgbWVzc2FnZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3B5MmpzX2FkZFRyYWNlczogbnVsbCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHtudWxsfE9iamVjdH0gUHkySnNEZWxldGVUcmFjZXNNc2dcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj59IGRlbGV0ZV9pbmRzXG4gICAgICAgICAgICAgKiAgQXJyYXkgb2YgaW5kZXhlcyBvZiB0cmFjZXMgdG8gYmUgZGVsZXRlZCwgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdHJhY2VfZWRpdF9pZFxuICAgICAgICAgICAgICogIEVkaXQgSUQgdG8gdXNlIHdoZW4gcmV0dXJuaW5nIHRyYWNlIGRlbHRhcyB1c2luZ1xuICAgICAgICAgICAgICogIHRoZSBfanMycHlfdHJhY2VEZWx0YXMgbWVzc2FnZS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsYXlvdXRfZWRpdF9pZFxuICAgICAgICAgICAgICogIEVkaXQgSUQgdG8gdXNlIHdoZW4gcmV0dXJuaW5nIGxheW91dCBkZWx0YXMgdXNpbmdcbiAgICAgICAgICAgICAqICB0aGUgX2pzMnB5X2xheW91dERlbHRhIG1lc3NhZ2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9weTJqc19kZWxldGVUcmFjZXM6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7bnVsbHxPYmplY3R9IFB5MkpzTW92ZVRyYWNlc01zZ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gY3VycmVudF90cmFjZV9pbmRzXG4gICAgICAgICAgICAgKiAgQXJyYXkgb2YgdGhlIGN1cnJlbnQgaW5kZXhlcyBvZiB0cmFjZXMgdG8gYmUgbW92ZWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj59IG5ld190cmFjZV9pbmRzXG4gICAgICAgICAgICAgKiAgQXJyYXkgb2YgdGhlIG5ldyBpbmRleGVzIHRoYXQgdHJhY2VzIHNob3VsZCBiZSBtb3ZlZCB0by5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3B5MmpzX21vdmVUcmFjZXM6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7bnVsbHxPYmplY3R9IFB5MkpzUmVzdHlsZU1zZ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IHJlc3R5bGVfZGF0YVxuICAgICAgICAgICAgICogIFJlc3R5bGUgZGF0YSBhcyBhY2NlcHRlZCBieSBQbG90bHkucmVzdHlsZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudWxsfEFycmF5LjxOdW1iZXI+fSByZXN0eWxlX3RyYWNlc1xuICAgICAgICAgICAgICogIEFycmF5IG9mIGluZGV4ZXMgb2YgdGhlIHRyYWNlcyB0aGF0IHRoZSByZXN5dGxlIG9wZXJhdGlvbiBhcHBsaWVzXG4gICAgICAgICAgICAgKiAgdG8sIG9yIG51bGwgdG8gYXBwbHkgdGhlIG9wZXJhdGlvbiB0byBhbGwgdHJhY2VzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdHJhY2VfZWRpdF9pZFxuICAgICAgICAgICAgICogIEVkaXQgSUQgdG8gdXNlIHdoZW4gcmV0dXJuaW5nIHRyYWNlIGRlbHRhcyB1c2luZ1xuICAgICAgICAgICAgICogIHRoZSBfanMycHlfdHJhY2VEZWx0YXMgbWVzc2FnZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxheW91dF9lZGl0X2lkXG4gICAgICAgICAgICAgKiAgRWRpdCBJRCB0byB1c2Ugd2hlbiByZXR1cm5pbmcgbGF5b3V0IGRlbHRhcyB1c2luZ1xuICAgICAgICAgICAgICogIHRoZSBfanMycHlfbGF5b3V0RGVsdGEgbWVzc2FnZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudWxsfFN0cmluZ30gc291cmNlX3ZpZXdfaWRcbiAgICAgICAgICAgICAqICB2aWV3X2lkIG9mIHRoZSBGaWd1cmVWaWV3IHRoYXQgdHJpZ2dlcmVkIHRoZSBvcmlnaW5hbCByZXN0eWxlXG4gICAgICAgICAgICAgKiAgZXZlbnQgKGUuZy4gYnkgY2xpY2tpbmcgdGhlIGxlZ2VuZCksIG9yIG51bGwgaWYgdGhlIHJlc3R5bGUgd2FzXG4gICAgICAgICAgICAgKiAgdHJpZ2dlcmVkIGZyb20gUHl0aG9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9weTJqc19yZXN0eWxlOiBudWxsLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge251bGx8T2JqZWN0fSBQeTJKc1JlbGF5b3V0TXNnXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gcmVsYXlvdXRfZGF0YVxuICAgICAgICAgICAgICogIFJlbGF5b3V0IGRhdGEgYXMgYWNjZXB0ZWQgYnkgUGxvdGx5LnJlbGF5b3V0XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGF5b3V0X2VkaXRfaWRcbiAgICAgICAgICAgICAqICBFZGl0IElEIHRvIHVzZSB3aGVuIHJldHVybmluZyBsYXlvdXQgZGVsdGFzIHVzaW5nXG4gICAgICAgICAgICAgKiAgdGhlIF9qczJweV9sYXlvdXREZWx0YSBtZXNzYWdlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bGx8U3RyaW5nfSBzb3VyY2Vfdmlld19pZFxuICAgICAgICAgICAgICogIHZpZXdfaWQgb2YgdGhlIEZpZ3VyZVZpZXcgdGhhdCB0cmlnZ2VyZWQgdGhlIG9yaWdpbmFsIHJlbGF5b3V0XG4gICAgICAgICAgICAgKiAgZXZlbnQgKGUuZy4gYnkgY2xpY2tpbmcgdGhlIHpvb20gYnV0dG9uKSwgb3IgbnVsbCBpZiB0aGVcbiAgICAgICAgICAgICAqICByZWxheW91dCB3YXMgdHJpZ2dlcmVkIGZyb20gUHl0aG9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9weTJqc19yZWxheW91dDogbnVsbCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHtudWxsfE9iamVjdH0gUHkySnNVcGRhdGVNc2dcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzdHlsZV9kYXRhXG4gICAgICAgICAgICAgKiAgU3R5bGUgZGF0YSBhcyBhY2NlcHRlZCBieSBQbG90bHkudXBkYXRlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gbGF5b3V0X2RhdGFcbiAgICAgICAgICAgICAqICBMYXlvdXQgZGF0YSBhcyBhY2NlcHRlZCBieSBQbG90bHkudXBkYXRlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSBzdHlsZV90cmFjZXNcbiAgICAgICAgICAgICAqICBBcnJheSBvZiBpbmRleGVzIG9mIHRoZSB0cmFjZXMgdGhhdCB0aGUgdXBkYXRlIG9wZXJhdGlvbiBhcHBsaWVzXG4gICAgICAgICAgICAgKiAgdG8sIG9yIG51bGwgdG8gYXBwbHkgdGhlIG9wZXJhdGlvbiB0byBhbGwgdHJhY2VzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdHJhY2VfZWRpdF9pZFxuICAgICAgICAgICAgICogIEVkaXQgSUQgdG8gdXNlIHdoZW4gcmV0dXJuaW5nIHRyYWNlIGRlbHRhcyB1c2luZ1xuICAgICAgICAgICAgICogIHRoZSBfanMycHlfdHJhY2VEZWx0YXMgbWVzc2FnZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxheW91dF9lZGl0X2lkXG4gICAgICAgICAgICAgKiAgRWRpdCBJRCB0byB1c2Ugd2hlbiByZXR1cm5pbmcgbGF5b3V0IGRlbHRhcyB1c2luZ1xuICAgICAgICAgICAgICogIHRoZSBfanMycHlfbGF5b3V0RGVsdGEgbWVzc2FnZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudWxsfFN0cmluZ30gc291cmNlX3ZpZXdfaWRcbiAgICAgICAgICAgICAqICB2aWV3X2lkIG9mIHRoZSBGaWd1cmVWaWV3IHRoYXQgdHJpZ2dlcmVkIHRoZSBvcmlnaW5hbCB1cGRhdGVcbiAgICAgICAgICAgICAqICBldmVudCAoZS5nLiBieSBjbGlja2luZyBhIGJ1dHRvbiksIG9yIG51bGwgaWYgdGhlIHVwZGF0ZSB3YXNcbiAgICAgICAgICAgICAqICB0cmlnZ2VyZWQgZnJvbSBQeXRob25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3B5MmpzX3VwZGF0ZTogbnVsbCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHtudWxsfE9iamVjdH0gUHkySnNBbmltYXRlTXNnXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc3R5bGVfZGF0YVxuICAgICAgICAgICAgICogIFN0eWxlIGRhdGEgYXMgYWNjZXB0ZWQgYnkgUGxvdGx5LmFuaW1hdGVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBsYXlvdXRfZGF0YVxuICAgICAgICAgICAgICogIExheW91dCBkYXRhIGFzIGFjY2VwdGVkIGJ5IFBsb3RseS5hbmltYXRlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSBzdHlsZV90cmFjZXNcbiAgICAgICAgICAgICAqICBBcnJheSBvZiBpbmRleGVzIG9mIHRoZSB0cmFjZXMgdGhhdCB0aGUgYW5pbWF0ZSBvcGVyYXRpb24gYXBwbGllc1xuICAgICAgICAgICAgICogIHRvLCBvciBudWxsIHRvIGFwcGx5IHRoZSBvcGVyYXRpb24gdG8gYWxsIHRyYWNlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGFuaW1hdGlvbl9vcHRzXG4gICAgICAgICAgICAgKiAgQW5pbWF0aW9uIG9wdGlvbnMgYXMgYWNjZXB0ZWQgYnkgUGxvdGx5LmFuaW1hdGVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0cmFjZV9lZGl0X2lkXG4gICAgICAgICAgICAgKiAgRWRpdCBJRCB0byB1c2Ugd2hlbiByZXR1cm5pbmcgdHJhY2UgZGVsdGFzIHVzaW5nXG4gICAgICAgICAgICAgKiAgdGhlIF9qczJweV90cmFjZURlbHRhcyBtZXNzYWdlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGF5b3V0X2VkaXRfaWRcbiAgICAgICAgICAgICAqICBFZGl0IElEIHRvIHVzZSB3aGVuIHJldHVybmluZyBsYXlvdXQgZGVsdGFzIHVzaW5nXG4gICAgICAgICAgICAgKiAgdGhlIF9qczJweV9sYXlvdXREZWx0YSBtZXNzYWdlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bGx8U3RyaW5nfSBzb3VyY2Vfdmlld19pZFxuICAgICAgICAgICAgICogIHZpZXdfaWQgb2YgdGhlIEZpZ3VyZVZpZXcgdGhhdCB0cmlnZ2VyZWQgdGhlIG9yaWdpbmFsIGFuaW1hdGVcbiAgICAgICAgICAgICAqICBldmVudCAoZS5nLiBieSBjbGlja2luZyBhIGJ1dHRvbiksIG9yIG51bGwgaWYgdGhlIHVwZGF0ZSB3YXNcbiAgICAgICAgICAgICAqICB0cmlnZ2VyZWQgZnJvbSBQeXRob25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3B5MmpzX2FuaW1hdGU6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7bnVsbHxPYmplY3R9IFB5MkpzUmVtb3ZlTGF5b3V0UHJvcHNNc2dcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPEFycmF5LjxTdHJpbmd8TnVtYmVyPj59IHJlbW92ZV9wcm9wc1xuICAgICAgICAgICAgICogIEFycmF5IG9mIHByb3BlcnR5IHBhdGhzIHRvIHJlbW92ZS4gRWFjaCBwcm9wZXJ5IHBhdGggaXMgYW5cbiAgICAgICAgICAgICAqICBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvciBhcnJheSBpbmRleGVzIHRoYXQgbG9jYXRlIGEgcHJvcGVydHlcbiAgICAgICAgICAgICAqICBpbnNpZGUgdGhlIF9sYXlvdXQgb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9weTJqc19yZW1vdmVMYXlvdXRQcm9wczogbnVsbCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlZGVmIHtudWxsfE9iamVjdH0gUHkySnNSZW1vdmVUcmFjZVByb3BzTXNnXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmVtb3ZlX3RyYWNlXG4gICAgICAgICAgICAgKiAgVGhlIGluZGV4IG9mIHRoZSB0cmFjZSBmcm9tIHdoaWNoIHRvIHJlbW92ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxBcnJheS48U3RyaW5nfE51bWJlcj4+fSByZW1vdmVfcHJvcHNcbiAgICAgICAgICAgICAqICBBcnJheSBvZiBwcm9wZXJ0eSBwYXRocyB0byByZW1vdmUuIEVhY2ggcHJvcGVyeSBwYXRoIGlzIGFuXG4gICAgICAgICAgICAgKiAgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgb3IgYXJyYXkgaW5kZXhlcyB0aGF0IGxvY2F0ZSBhIHByb3BlcnR5XG4gICAgICAgICAgICAgKiAgaW5zaWRlIHRoZSBfZGF0YVtyZW1vdmVfdHJhY2VdIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfcHkyanNfcmVtb3ZlVHJhY2VQcm9wczogbnVsbCwgXG4gICAgICAgICAgICAvLyBKUyAtPiBQeXRob24gbWVzc2FnZXNcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgYXJlIHNlbnQgYnkgdGhlIEphdmFTY3JpcHQgc2lkZSBieSBhc3NpZ25pbmcgdGhlXG4gICAgICAgICAgICAvLyBtZXNzYWdlIGNvbnRlbnRzIHRvIHRoZSBhcHByb3ByaWF0ZSBfanMycHlfKiBwcm9wZXJ0eSBhbmQgdGhlblxuICAgICAgICAgICAgLy8gY2FsbGluZyB0aGUgYHRvdWNoYCBtZXRob2Qgb24gdGhlIHZpZXcgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gICAgICAgICAgICAvLyBjaGFuZ2UuIGUuZy4gKHdoZXJlIHRoaXMgaXMgYSBGaWd1cmVWaWV3KTpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgIHRoaXMubW9kZWwuc2V0KCdfanMycHlfcmVzdHlsZScsIGRhdGEpO1xuICAgICAgICAgICAgLy8gICAgICB0aGlzLnRvdWNoKCk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIFB5dGhvbiBzaWRlIGlzIHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIHRoZSBwcm9wZXJ0eSB0byBOb25lXG4gICAgICAgICAgICAvLyBhZnRlciByZWNlaXZpbmcgdGhlIG1lc3NhZ2UuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTWVzc2FnZSB0cmlnZ2VyIGxvZ2ljIGlzIGRlc2NyaWJlZCBpbiB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAgICAgICAgLy8gaGFuZGxlX3Bsb3RseV8qIG1ldGhvZHMgb2YgRmlndXJlVmlld1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7bnVsbHxPYmplY3R9IEpzMlB5UmVzdHlsZU1zZ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0eWxlX2RhdGFcbiAgICAgICAgICAgICAqICBTdHlsZSBkYXRhIHRoYXQgd2FzIHBhc3NlZCB0byBQbG90bHkucmVzdHlsZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gc3R5bGVfdHJhY2VzXG4gICAgICAgICAgICAgKiAgQXJyYXkgb2YgaW5kZXhlcyBvZiB0aGUgdHJhY2VzIHRoYXQgdGhlIHJlc3R5bGUgb3BlcmF0aW9uXG4gICAgICAgICAgICAgKiAgd2FzIGFwcGxpZWQgdG8sIG9yIG51bGwgaWYgYXBwbGllZCB0byBhbGwgdHJhY2VzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc291cmNlX3ZpZXdfaWRcbiAgICAgICAgICAgICAqICB2aWV3X2lkIG9mIHRoZSBGaWd1cmVWaWV3IHRoYXQgdHJpZ2dlcmVkIHRoZSBvcmlnaW5hbCByZXN0eWxlXG4gICAgICAgICAgICAgKiAgZXZlbnQgKGUuZy4gYnkgY2xpY2tpbmcgdGhlIGxlZ2VuZClcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2pzMnB5X3Jlc3R5bGU6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7bnVsbHxPYmplY3R9IEpzMlB5UmVsYXlvdXRNc2dcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSByZWxheW91dF9kYXRhXG4gICAgICAgICAgICAgKiAgUmVsYXlvdXQgZGF0YSB0aGF0IHdhcyBwYXNzZWQgdG8gUGxvdGx5LnJlbGF5b3V0XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc291cmNlX3ZpZXdfaWRcbiAgICAgICAgICAgICAqICB2aWV3X2lkIG9mIHRoZSBGaWd1cmVWaWV3IHRoYXQgdHJpZ2dlcmVkIHRoZSBvcmlnaW5hbCByZWxheW91dFxuICAgICAgICAgICAgICogIGV2ZW50IChlLmcuIGJ5IGNsaWNraW5nIHRoZSB6b29tIGJ1dHRvbilcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2pzMnB5X3JlbGF5b3V0OiBudWxsLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge251bGx8T2JqZWN0fSBKczJQeVVwZGF0ZU1zZ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0eWxlX2RhdGFcbiAgICAgICAgICAgICAqICBTdHlsZSBkYXRhIHRoYXQgd2FzIHBhc3NlZCB0byBQbG90bHkudXBkYXRlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gbGF5b3V0X2RhdGFcbiAgICAgICAgICAgICAqICBMYXlvdXQgZGF0YSB0aGF0IHdhcyBwYXNzZWQgdG8gUGxvdGx5LnVwZGF0ZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gc3R5bGVfdHJhY2VzXG4gICAgICAgICAgICAgKiAgQXJyYXkgb2YgaW5kZXhlcyBvZiB0aGUgdHJhY2VzIHRoYXQgdGhlIHVwZGF0ZSBvcGVyYXRpb24gYXBwbGllZFxuICAgICAgICAgICAgICogIHRvLCBvciBudWxsIGlmIGFwcGxpZWQgdG8gYWxsIHRyYWNlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHNvdXJjZV92aWV3X2lkXG4gICAgICAgICAgICAgKiAgdmlld19pZCBvZiB0aGUgRmlndXJlVmlldyB0aGF0IHRyaWdnZXJlZCB0aGUgb3JpZ2luYWwgcmVsYXlvdXRcbiAgICAgICAgICAgICAqICBldmVudCAoZS5nLiBieSBjbGlja2luZyB0aGUgem9vbSBidXR0b24pXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9qczJweV91cGRhdGU6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7bnVsbHxPYmplY3R9IEpzMlB5TGF5b3V0RGVsdGFNc2dcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBsYXlvdXRfZGVsdGFcbiAgICAgICAgICAgICAqICBUaGUgbGF5b3V0IGRlbHRhIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgcHJvcGVydGllcyBvZlxuICAgICAgICAgICAgICogIF9mdWxsTGF5b3V0IHRoYXQgYXJlIG5vdCBpZGVudGljYWwgdG8gdGhvc2UgaW4gdGhlXG4gICAgICAgICAgICAgKiAgRmlndXJlTW9kZWwncyBfbGF5b3V0IHByb3BlcnR5XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbGF5b3V0X2VkaXRfaWRcbiAgICAgICAgICAgICAqICBFZGl0IElEIG9mIG1lc3NhZ2UgdGhhdCB0cmlnZ2VyZWQgdGhlIGNyZWF0aW9uIG9mIGxheW91dCBkZWx0YVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfanMycHlfbGF5b3V0RGVsdGE6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7bnVsbHxPYmplY3R9IEpzMlB5VHJhY2VEZWx0YXNNc2dcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE9iamVjdD59IHRyYWNlX2RlbHRhc1xuICAgICAgICAgICAgICogIEFycmF5IG9mIHRyYWNlIGRlbHRhIG9iamVjdHMuIEVhY2ggdHJhY2UgZGVsdGEgY29udGFpbnMgdGhlXG4gICAgICAgICAgICAgKiAgdHJhY2UncyB1aWQgYWxvbmcgd2l0aCBhbGwgb2YgdGhlIHByb3BlcnRpZXMgb2YgX2Z1bGxEYXRhIHRoYXRcbiAgICAgICAgICAgICAqICBhcmUgbm90IGlkZW50aWNhbCB0byB0aG9zZSBpbiB0aGUgRmlndXJlTW9kZWwncyBfZGF0YSBwcm9wZXJ0eVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRyYWNlX2VkaXRfaWRcbiAgICAgICAgICAgICAqICBFZGl0IElEIG9mIG1lc3NhZ2UgdGhhdCB0cmlnZ2VyZWQgdGhlIGNyZWF0aW9uIG9mIHRyYWNlIGRlbHRhc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfanMycHlfdHJhY2VEZWx0YXM6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIGEgY29sbGVjdGlvbiBvZiBwb2ludHMgZm9yIHVzZSBpbiBjbGljaywgaG92ZXIsXG4gICAgICAgICAgICAgKiBhbmQgc2VsZWN0aW9uIGV2ZW50c1xuICAgICAgICAgICAgICogQHR5cGVkZWYge09iamVjdH0gUG9pbnRzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSB0cmFjZV9pbmRleGVzXG4gICAgICAgICAgICAgKiAgQXJyYXkgb2YgdGhlIHRyYWNlIGluZGV4IGZvciBlYWNoIHBvaW50XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSBwb2ludF9pbmRleGVzXG4gICAgICAgICAgICAgKiAgQXJyYXkgb2YgdGhlIGluZGV4IG9mIGVhY2ggcG9pbnQgaW4gaXRzIG93biB0cmFjZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudWxsfEFycmF5LjxOdW1iZXI+fSB4c1xuICAgICAgICAgICAgICogIEFycmF5IG9mIHRoZSB4IGNvb3JkaW5hdGUgb2YgZWFjaCBwb2ludCAoZm9yIGNhcnRlc2lhbiB0cmFjZSB0eXBlcylcbiAgICAgICAgICAgICAqICBvciBudWxsIChmb3Igbm9uLWNhcnRlc2lhbiB0cmFjZSB0eXBlcylcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVsbHxBcnJheS48TnVtYmVyPn0geXNcbiAgICAgICAgICAgICAqICBBcnJheSBvZiB0aGUgeSBjb29yZGluYXRlIG9mIGVhY2ggcG9pbnQgKGZvciBjYXJ0ZXNpYW4gdHJhY2UgdHlwZXMpXG4gICAgICAgICAgICAgKiAgb3IgbnVsbCAoZm9yIG5vbi1jYXJ0ZXNpYW4gdHJhY2UgdHlwZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVsbHxBcnJheS48TnVtYmVyPn0genNcbiAgICAgICAgICAgICAqICBBcnJheSBvZiB0aGUgeiBjb29yZGluYXRlIG9mIGVhY2ggcG9pbnQgKGZvciAzRCBjYXJ0ZXNpYW5cbiAgICAgICAgICAgICAqICB0cmFjZSB0eXBlcylcbiAgICAgICAgICAgICAqICBvciBudWxsIChmb3Igbm9uLTNELWNhcnRlc2lhbiB0cmFjZSB0eXBlcylcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgaW5wdXQgZGV2aWNlcyBkdXJpbmcgYVxuICAgICAgICAgICAgICogcGxvdGx5IGV2ZW50XG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJbnB1dERldmljZVN0YXRlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFsdCAtIHRydWUgaWYgYWx0IGtleSBwcmVzc2VkLFxuICAgICAgICAgICAgICogZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGN0cmwgLSB0cnVlIGlmIGN0cmwga2V5IHByZXNzZWQsXG4gICAgICAgICAgICAgKiBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWV0YSAtIHRydWUgaWYgbWV0YSBrZXkgcHJlc3NlZCxcbiAgICAgICAgICAgICAqIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBzaGlmdCAtIHRydWUgaWYgc2hpZnQga2V5IHByZXNzZWQsXG4gICAgICAgICAgICAgKiBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGJ1dHRvblxuICAgICAgICAgICAgICogIEluZGljYXRlcyB3aGljaCBidXR0b24gd2FzIHByZXNzZWQgb24gdGhlIG1vdXNlIHRvIHRyaWdnZXIgdGhlXG4gICAgICAgICAgICAgKiAgZXZlbnQuXG4gICAgICAgICAgICAgKiAgICAwOiBNYWluIGJ1dHRvbiBwcmVzc2VkLCB1c3VhbGx5IHRoZSBsZWZ0IGJ1dHRvbiBvciB0aGVcbiAgICAgICAgICAgICAqICAgICAgIHVuLWluaXRpYWxpemVkIHN0YXRlXG4gICAgICAgICAgICAgKiAgICAxOiBBdXhpbGlhcnkgYnV0dG9uIHByZXNzZWQsIHVzdWFsbHkgdGhlIHdoZWVsIGJ1dHRvbiBvclxuICAgICAgICAgICAgICogICAgICAgdGhlIG1pZGRsZSBidXR0b24gKGlmIHByZXNlbnQpXG4gICAgICAgICAgICAgKiAgICAyOiBTZWNvbmRhcnkgYnV0dG9uIHByZXNzZWQsIHVzdWFsbHkgdGhlIHJpZ2h0IGJ1dHRvblxuICAgICAgICAgICAgICogICAgMzogRm91cnRoIGJ1dHRvbiwgdHlwaWNhbGx5IHRoZSBCcm93c2VyIEJhY2sgYnV0dG9uXG4gICAgICAgICAgICAgKiAgICA0OiBGaWZ0aCBidXR0b24sIHR5cGljYWxseSB0aGUgQnJvd3NlciBGb3J3YXJkIGJ1dHRvblxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYnV0dG9uc1xuICAgICAgICAgICAgICogIEluZGljYXRlcyB3aGljaCBidXR0b25zIHdlcmUgcHJlc3NlZCBvbiB0aGUgbW91c2Ugd2hlbiB0aGUgZXZlbnRcbiAgICAgICAgICAgICAqICBpcyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgKiAgICAwICA6IE5vIGJ1dHRvbiBvciB1bi1pbml0aWFsaXplZFxuICAgICAgICAgICAgICogICAgMSAgOiBQcmltYXJ5IGJ1dHRvbiAodXN1YWxseSBsZWZ0KVxuICAgICAgICAgICAgICogICAgMiAgOiBTZWNvbmRhcnkgYnV0dG9uICh1c3VhbGx5IHJpZ2h0KVxuICAgICAgICAgICAgICogICAgNCAgOiBBdXhpbGFyeSBidXR0b24gKHVzdWFsbHkgbWlkZGxlIG9yIG1vdXNlIHdoZWVsIGJ1dHRvbilcbiAgICAgICAgICAgICAqICAgIDggIDogNHRoIGJ1dHRvbiAodHlwaWNhbGx5IHRoZSBcIkJyb3dzZXIgQmFja1wiIGJ1dHRvbilcbiAgICAgICAgICAgICAqICAgIDE2IDogNXRoIGJ1dHRvbiAodHlwaWNhbGx5IHRoZSBcIkJyb3dzZXIgRm9yd2FyZFwiIGJ1dHRvbilcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQ29tYmluYXRpb25zIG9mIGJ1dHRvbnMgYXJlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdW0gb2YgdGhlIGNvZGVzXG4gICAgICAgICAgICAgKiAgYWJvdmUuIGUuZy4gYSB2YWx1ZSBvZiA3IGluZGljYXRlcyBidXR0b25zIDEgKHByaW1hcnkpLFxuICAgICAgICAgICAgICogIDIgKHNlY29uZGFyeSksIGFuZCA0IChhdXhpbGFyeSkgd2VyZSBwcmVzc2VkIGR1cmluZyB0aGUgZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBCb3hTZWxlY3RvclN0YXRlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSB4cmFuZ2VcbiAgICAgICAgICAgICAqICBUd28gZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB4LXJhbmdlIG9mIHRoZSBib3ggc2VsZWN0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSB5cmFuZ2VcbiAgICAgICAgICAgICAqICBUd28gZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB5LXJhbmdlIG9mIHRoZSBib3ggc2VsZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGVkZWYge09iamVjdH0gTGFzc29TZWxlY3RvclN0YXRlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSB4c1xuICAgICAgICAgICAgICogIEFycmF5IG9mIHRoZSB4LWNvb3JkaW5hdGVzIG9mIHRoZSBsYXNzbyBzZWxlY3Rpb24gcmVnaW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSB5c1xuICAgICAgICAgICAgICogIEFycmF5IG9mIHRoZSB5LWNvb3JkaW5hdGVzIG9mIHRoZSBsYXNzbyBzZWxlY3Rpb24gcmVnaW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIHNlbGVjdGlvbiB0b29sIGR1cmluZyBhXG4gICAgICAgICAgICAgKiBwbG90bHlfc2VsZWN0IGV2ZW50XG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTZWxlY3RvclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGVcbiAgICAgICAgICAgICAqICBTZWxlY3Rpb24gdHlwZS4gT25lIG9mOiAnYm94Jywgb3IgJ2xhc3NvJ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb3hTZWxlY3RvclN0YXRlfExhc3NvU2VsZWN0b3JTdGF0ZX0gc2VsZWN0b3Jfc3RhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZWRlZiB7bnVsbHxPYmplY3R9IEpzMlB5UG9pbnRzQ2FsbGJhY2tNc2dcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudF90eXBlXG4gICAgICAgICAgICAgKiAgTmFtZSBvZiB0aGUgdHJpZ2dlcmluZyBldmVudC4gT25lIG9mICdwbG90bHlfY2xpY2snLFxuICAgICAgICAgICAgICogICdwbG90bHlfaG92ZXInLCAncGxvdGx5X3VuaG92ZXInLCBvciAncGxvdGx5X3NlbGVjdGVkJ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudWxsfFBvaW50c30gcG9pbnRzXG4gICAgICAgICAgICAgKiAgUG9pbnRzIG9iamVjdCBmb3IgZXZlbnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVsbHxJbnB1dERldmljZVN0YXRlfSBkZXZpY2Vfc3RhdGVcbiAgICAgICAgICAgICAqICBJbnB1dERldmljZVN0YXRlIG9iamVjdCBmb3IgZXZlbnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVsbHxTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICAgICAgICAgICAqICBTdGF0ZSBvZiB0aGUgc2VsZWN0aW9uIHRvb2wgZm9yICdwbG90bHlfc2VsZWN0ZWQnIGV2ZW50cywgbnVsbFxuICAgICAgICAgICAgICogIGZvciBvdGhlciBldmVudCB0eXBlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfanMycHlfcG9pbnRzQ2FsbGJhY2s6IG51bGwsIFxuICAgICAgICAgICAgLy8gTWVzc2FnZSB0cmFja2luZ1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogbGF5b3V0X2VkaXRfaWQgb2YgdGhlIGxhc3QgbGF5b3V0IG1vZGlmaWNhdGlvbiBvcGVyYXRpb25cbiAgICAgICAgICAgICAqIHJlcXVlc3RlZCBieSB0aGUgUHl0aG9uIHNpZGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2xhc3RfbGF5b3V0X2VkaXRfaWQ6IDAsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICogdHJhY2VfZWRpdF9pZCBvZiB0aGUgbGFzdCB0cmFjZSBtb2RpZmljYXRpb24gb3BlcmF0aW9uXG4gICAgICAgICAgICAgKiByZXF1ZXN0ZWQgYnkgdGhlIFB5dGhvbiBzaWRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9sYXN0X3RyYWNlX2VkaXRfaWQ6IDAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgRmlndXJlTW9kZWwuIENhbGxlZCB3aGVuIHRoZSBQeXRob24gRmlndXJlV2lkZ2V0IGlzIGZpcnN0XG4gICAgICogY29uc3RydWN0ZWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMub24oXCJjaGFuZ2U6X2RhdGFcIiwgdGhpcy5kb19kYXRhLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbihcImNoYW5nZTpfbGF5b3V0XCIsIHRoaXMuZG9fbGF5b3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbihcImNoYW5nZTpfcHkyanNfYWRkVHJhY2VzXCIsIHRoaXMuZG9fYWRkVHJhY2VzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbihcImNoYW5nZTpfcHkyanNfZGVsZXRlVHJhY2VzXCIsIHRoaXMuZG9fZGVsZXRlVHJhY2VzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbihcImNoYW5nZTpfcHkyanNfbW92ZVRyYWNlc1wiLCB0aGlzLmRvX21vdmVUcmFjZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKFwiY2hhbmdlOl9weTJqc19yZXN0eWxlXCIsIHRoaXMuZG9fcmVzdHlsZSwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oXCJjaGFuZ2U6X3B5MmpzX3JlbGF5b3V0XCIsIHRoaXMuZG9fcmVsYXlvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKFwiY2hhbmdlOl9weTJqc191cGRhdGVcIiwgdGhpcy5kb191cGRhdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKFwiY2hhbmdlOl9weTJqc19hbmltYXRlXCIsIHRoaXMuZG9fYW5pbWF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oXCJjaGFuZ2U6X3B5MmpzX3JlbW92ZUxheW91dFByb3BzXCIsIHRoaXMuZG9fcmVtb3ZlTGF5b3V0UHJvcHMsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKFwiY2hhbmdlOl9weTJqc19yZW1vdmVUcmFjZVByb3BzXCIsIHRoaXMuZG9fcmVtb3ZlVHJhY2VQcm9wcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElucHV0IGEgdHJhY2UgaW5kZXggc3BlY2lmaWNhdGlvbiBhbmQgcmV0dXJuIGFuIEFycmF5IG9mIHRyYWNlXG4gICAgICogaW5kZXhlcyB3aGVyZTpcbiAgICAgKlxuICAgICAqICAtIG51bGx8dW5kZWZpbmVkIC0+IEFycmF5IG9mIGFsbCB0cmFjZXNcbiAgICAgKiAgLSBUcmFjZSBpbmRleCBhcyBOdW1iZXIgLT4gU2luZ2xlIGVsZW1lbnQgYXJyYXkgb2YgaW5wdXQgaW5kZXhcbiAgICAgKiAgLSBBcnJheSBvZiB0cmFjZSBpbmRleGVzIC0+IElucHV0IGFycmF5IHVuY2hhbmdlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHt1bmRlZmluZWR8bnVsbHxOdW1iZXJ8QXJyYXkuPE51bWJlcj59IHRyYWNlX2luZGV4ZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE51bWJlcj59XG4gICAgICogIEFycmF5IG9mIHRyYWNlIGluZGV4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVfdHJhY2VfaW5kZXhlcyh0cmFjZV9pbmRleGVzKSB7XG4gICAgICAgIGlmICh0cmFjZV9pbmRleGVzID09PSBudWxsIHx8IHRyYWNlX2luZGV4ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIG51bVRyYWNlcyA9IHRoaXMuZ2V0KFwiX2RhdGFcIikubGVuZ3RoO1xuICAgICAgICAgICAgdHJhY2VfaW5kZXhlcyA9IF8ucmFuZ2UobnVtVHJhY2VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhY2VfaW5kZXhlcykpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBpZHggaXMgYW4gYXJyYXlcbiAgICAgICAgICAgIHRyYWNlX2luZGV4ZXMgPSBbdHJhY2VfaW5kZXhlc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNlX2luZGV4ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBjaGFuZ2VzIHRvIHRoZSBfZGF0YSB0cmFpdFxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgb25seSBoYXBwZWQgb24gRmlndXJlTW9kZWwgaW5pdGlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBkb19kYXRhKCkgeyB9XG4gICAgLyoqXG4gICAgICogTG9nIGNoYW5nZXMgdG8gdGhlIF9sYXlvdXQgdHJhaXRcbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVkIG9uIEZpZ3VyZU1vZGVsIGluaXRpYWxpemF0aW9uXG4gICAgICovXG4gICAgZG9fbGF5b3V0KCkgeyB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFkZFRyYWNlcyBtZXNzYWdlXG4gICAgICovXG4gICAgZG9fYWRkVHJhY2VzKCkge1xuICAgICAgICAvLyBhZGQgdHJhY2UgdG8gcGxvdFxuICAgICAgICAvKiogQHR5cGUge1B5MkpzQWRkVHJhY2VzTXNnfSAqL1xuICAgICAgICB2YXIgbXNnRGF0YSA9IHRoaXMuZ2V0KFwiX3B5MmpzX2FkZFRyYWNlc1wiKTtcbiAgICAgICAgaWYgKG1zZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VHJhY2VzID0gdGhpcy5nZXQoXCJfZGF0YVwiKTtcbiAgICAgICAgICAgIHZhciBuZXdUcmFjZXMgPSBtc2dEYXRhLnRyYWNlX2RhdGE7XG4gICAgICAgICAgICBfLmZvckVhY2gobmV3VHJhY2VzLCBmdW5jdGlvbiAobmV3VHJhY2UpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2VzLnB1c2gobmV3VHJhY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGRlbGV0ZVRyYWNlcyBtZXNzYWdlXG4gICAgICovXG4gICAgZG9fZGVsZXRlVHJhY2VzKCkge1xuICAgICAgICAvLyByZW1vdmUgdHJhY2VzIGZyb20gcGxvdFxuICAgICAgICAvKiogQHR5cGUge1B5MkpzRGVsZXRlVHJhY2VzTXNnfSAqL1xuICAgICAgICB2YXIgbXNnRGF0YSA9IHRoaXMuZ2V0KFwiX3B5MmpzX2RlbGV0ZVRyYWNlc1wiKTtcbiAgICAgICAgaWYgKG1zZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkZWxldGVfaW5kcyA9IG1zZ0RhdGEuZGVsZXRlX2luZHM7XG4gICAgICAgICAgICB2YXIgdHJhY2VzRGF0YSA9IHRoaXMuZ2V0KFwiX2RhdGFcIik7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZGVsIGluZHMgaW4gcmV2ZXJzZSBvcmRlciBzbyBpbmRleGVzIHJlbWFpbiB2YWxpZFxuICAgICAgICAgICAgLy8gdGhyb3VnaG91dCBsb29wXG4gICAgICAgICAgICBkZWxldGVfaW5kc1xuICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChkZWxfaW5kKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VzRGF0YS5zcGxpY2UoZGVsX2luZCwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgbW92ZVRyYWNlcyBtZXNzYWdlXG4gICAgICovXG4gICAgZG9fbW92ZVRyYWNlcygpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQeTJKc01vdmVUcmFjZXNNc2d9ICovXG4gICAgICAgIHZhciBtc2dEYXRhID0gdGhpcy5nZXQoXCJfcHkyanNfbW92ZVRyYWNlc1wiKTtcbiAgICAgICAgaWYgKG1zZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB0cmFjZXNEYXRhID0gdGhpcy5nZXQoXCJfZGF0YVwiKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SW5kcyA9IG1zZ0RhdGEuY3VycmVudF90cmFjZV9pbmRzO1xuICAgICAgICAgICAgdmFyIG5ld0luZHMgPSBtc2dEYXRhLm5ld190cmFjZV9pbmRzO1xuICAgICAgICAgICAgcGVyZm9ybU1vdmVUcmFjZXNMaWtlKHRyYWNlc0RhdGEsIGN1cnJlbnRJbmRzLCBuZXdJbmRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcmVzdHlsZSBtZXNzYWdlXG4gICAgICovXG4gICAgZG9fcmVzdHlsZSgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQeTJKc1Jlc3R5bGVNc2d9ICovXG4gICAgICAgIHZhciBtc2dEYXRhID0gdGhpcy5nZXQoXCJfcHkyanNfcmVzdHlsZVwiKTtcbiAgICAgICAgaWYgKG1zZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN0eWxlRGF0YSA9IG1zZ0RhdGEucmVzdHlsZV9kYXRhO1xuICAgICAgICAgICAgdmFyIHJlc3R5bGVUcmFjZXMgPSB0aGlzLl9ub3JtYWxpemVfdHJhY2VfaW5kZXhlcyhtc2dEYXRhLnJlc3R5bGVfdHJhY2VzKTtcbiAgICAgICAgICAgIHBlcmZvcm1SZXN0eWxlTGlrZSh0aGlzLmdldChcIl9kYXRhXCIpLCByZXN0eWxlRGF0YSwgcmVzdHlsZVRyYWNlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHJlbGF5b3V0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBkb19yZWxheW91dCgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQeTJKc1JlbGF5b3V0TXNnfSAqL1xuICAgICAgICB2YXIgbXNnRGF0YSA9IHRoaXMuZ2V0KFwiX3B5MmpzX3JlbGF5b3V0XCIpO1xuICAgICAgICBpZiAobXNnRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGVyZm9ybVJlbGF5b3V0TGlrZSh0aGlzLmdldChcIl9sYXlvdXRcIiksIG1zZ0RhdGEucmVsYXlvdXRfZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHVwZGF0ZSBtZXNzYWdlXG4gICAgICovXG4gICAgZG9fdXBkYXRlKCkge1xuICAgICAgICAvKiogQHR5cGUge1B5MkpzVXBkYXRlTXNnfSAqL1xuICAgICAgICB2YXIgbXNnRGF0YSA9IHRoaXMuZ2V0KFwiX3B5MmpzX3VwZGF0ZVwiKTtcbiAgICAgICAgaWYgKG1zZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IG1zZ0RhdGEuc3R5bGVfZGF0YTtcbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSBtc2dEYXRhLmxheW91dF9kYXRhO1xuICAgICAgICAgICAgdmFyIHN0eWxlVHJhY2VzID0gdGhpcy5fbm9ybWFsaXplX3RyYWNlX2luZGV4ZXMobXNnRGF0YS5zdHlsZV90cmFjZXMpO1xuICAgICAgICAgICAgcGVyZm9ybVJlc3R5bGVMaWtlKHRoaXMuZ2V0KFwiX2RhdGFcIiksIHN0eWxlLCBzdHlsZVRyYWNlcyk7XG4gICAgICAgICAgICBwZXJmb3JtUmVsYXlvdXRMaWtlKHRoaXMuZ2V0KFwiX2xheW91dFwiKSwgbGF5b3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW5pbWF0ZSBtZXNzYWdlXG4gICAgICovXG4gICAgZG9fYW5pbWF0ZSgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQeTJKc0FuaW1hdGVNc2d9ICovXG4gICAgICAgIHZhciBtc2dEYXRhID0gdGhpcy5nZXQoXCJfcHkyanNfYW5pbWF0ZVwiKTtcbiAgICAgICAgaWYgKG1zZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBtc2dEYXRhLnN0eWxlX2RhdGE7XG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gbXNnRGF0YS5sYXlvdXRfZGF0YTtcbiAgICAgICAgICAgIHZhciB0cmFjZV9pbmRleGVzID0gdGhpcy5fbm9ybWFsaXplX3RyYWNlX2luZGV4ZXMobXNnRGF0YS5zdHlsZV90cmFjZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNlX2luZGV4ID0gdHJhY2VfaW5kZXhlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2UgPSB0aGlzLmdldChcIl9kYXRhXCIpW3RyYWNlX2luZGV4XTtcbiAgICAgICAgICAgICAgICBwZXJmb3JtUmVsYXlvdXRMaWtlKHRyYWNlLCBzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXJmb3JtUmVsYXlvdXRMaWtlKHRoaXMuZ2V0KFwiX2xheW91dFwiKSwgbGF5b3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcmVtb3ZlTGF5b3V0UHJvcHMgbWVzc2FnZVxuICAgICAqL1xuICAgIGRvX3JlbW92ZUxheW91dFByb3BzKCkge1xuICAgICAgICAvKiogQHR5cGUge1B5MkpzUmVtb3ZlTGF5b3V0UHJvcHNNc2d9ICovXG4gICAgICAgIHZhciBtc2dEYXRhID0gdGhpcy5nZXQoXCJfcHkyanNfcmVtb3ZlTGF5b3V0UHJvcHNcIik7XG4gICAgICAgIGlmIChtc2dEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIga2V5UGF0aHMgPSBtc2dEYXRhLnJlbW92ZV9wcm9wcztcbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldChcIl9sYXlvdXRcIik7XG4gICAgICAgICAgICBwZXJmb3JtUmVtb3ZlUHJvcHMobGF5b3V0LCBrZXlQYXRocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHJlbW92ZVRyYWNlUHJvcHMgbWVzc2FnZVxuICAgICAqL1xuICAgIGRvX3JlbW92ZVRyYWNlUHJvcHMoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7UHkySnNSZW1vdmVUcmFjZVByb3BzTXNnfSAqL1xuICAgICAgICB2YXIgbXNnRGF0YSA9IHRoaXMuZ2V0KFwiX3B5MmpzX3JlbW92ZVRyYWNlUHJvcHNcIik7XG4gICAgICAgIGlmIChtc2dEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIga2V5UGF0aHMgPSBtc2dEYXRhLnJlbW92ZV9wcm9wcztcbiAgICAgICAgICAgIHZhciB0cmFjZUluZGV4ID0gbXNnRGF0YS5yZW1vdmVfdHJhY2U7XG4gICAgICAgICAgICB2YXIgdHJhY2UgPSB0aGlzLmdldChcIl9kYXRhXCIpW3RyYWNlSW5kZXhdO1xuICAgICAgICAgICAgcGVyZm9ybVJlbW92ZVByb3BzKHRyYWNlLCBrZXlQYXRocyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5GaWd1cmVNb2RlbC5zZXJpYWxpemVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRE9NV2lkZ2V0TW9kZWwuc2VyaWFsaXplcnMpLCB7IF9kYXRhOiB7IGRlc2VyaWFsaXplOiBweTJqc19kZXNlcmlhbGl6ZXIsIHNlcmlhbGl6ZToganMycHlfc2VyaWFsaXplciB9LCBfbGF5b3V0OiB7XG4gICAgICAgIGRlc2VyaWFsaXplOiBweTJqc19kZXNlcmlhbGl6ZXIsXG4gICAgICAgIHNlcmlhbGl6ZToganMycHlfc2VyaWFsaXplcixcbiAgICB9LCBfcHkyanNfYWRkVHJhY2VzOiB7XG4gICAgICAgIGRlc2VyaWFsaXplOiBweTJqc19kZXNlcmlhbGl6ZXIsXG4gICAgICAgIHNlcmlhbGl6ZToganMycHlfc2VyaWFsaXplcixcbiAgICB9LCBfcHkyanNfZGVsZXRlVHJhY2VzOiB7XG4gICAgICAgIGRlc2VyaWFsaXplOiBweTJqc19kZXNlcmlhbGl6ZXIsXG4gICAgICAgIHNlcmlhbGl6ZToganMycHlfc2VyaWFsaXplcixcbiAgICB9LCBfcHkyanNfbW92ZVRyYWNlczoge1xuICAgICAgICBkZXNlcmlhbGl6ZTogcHkyanNfZGVzZXJpYWxpemVyLFxuICAgICAgICBzZXJpYWxpemU6IGpzMnB5X3NlcmlhbGl6ZXIsXG4gICAgfSwgX3B5MmpzX3Jlc3R5bGU6IHtcbiAgICAgICAgZGVzZXJpYWxpemU6IHB5MmpzX2Rlc2VyaWFsaXplcixcbiAgICAgICAgc2VyaWFsaXplOiBqczJweV9zZXJpYWxpemVyLFxuICAgIH0sIF9weTJqc19yZWxheW91dDoge1xuICAgICAgICBkZXNlcmlhbGl6ZTogcHkyanNfZGVzZXJpYWxpemVyLFxuICAgICAgICBzZXJpYWxpemU6IGpzMnB5X3NlcmlhbGl6ZXIsXG4gICAgfSwgX3B5MmpzX3VwZGF0ZToge1xuICAgICAgICBkZXNlcmlhbGl6ZTogcHkyanNfZGVzZXJpYWxpemVyLFxuICAgICAgICBzZXJpYWxpemU6IGpzMnB5X3NlcmlhbGl6ZXIsXG4gICAgfSwgX3B5MmpzX2FuaW1hdGU6IHtcbiAgICAgICAgZGVzZXJpYWxpemU6IHB5MmpzX2Rlc2VyaWFsaXplcixcbiAgICAgICAgc2VyaWFsaXplOiBqczJweV9zZXJpYWxpemVyLFxuICAgIH0sIF9weTJqc19yZW1vdmVMYXlvdXRQcm9wczoge1xuICAgICAgICBkZXNlcmlhbGl6ZTogcHkyanNfZGVzZXJpYWxpemVyLFxuICAgICAgICBzZXJpYWxpemU6IGpzMnB5X3NlcmlhbGl6ZXIsXG4gICAgfSwgX3B5MmpzX3JlbW92ZVRyYWNlUHJvcHM6IHtcbiAgICAgICAgZGVzZXJpYWxpemU6IHB5MmpzX2Rlc2VyaWFsaXplcixcbiAgICAgICAgc2VyaWFsaXplOiBqczJweV9zZXJpYWxpemVyLFxuICAgIH0sIF9qczJweV9yZXN0eWxlOiB7XG4gICAgICAgIGRlc2VyaWFsaXplOiBweTJqc19kZXNlcmlhbGl6ZXIsXG4gICAgICAgIHNlcmlhbGl6ZToganMycHlfc2VyaWFsaXplcixcbiAgICB9LCBfanMycHlfcmVsYXlvdXQ6IHtcbiAgICAgICAgZGVzZXJpYWxpemU6IHB5MmpzX2Rlc2VyaWFsaXplcixcbiAgICAgICAgc2VyaWFsaXplOiBqczJweV9zZXJpYWxpemVyLFxuICAgIH0sIF9qczJweV91cGRhdGU6IHtcbiAgICAgICAgZGVzZXJpYWxpemU6IHB5MmpzX2Rlc2VyaWFsaXplcixcbiAgICAgICAgc2VyaWFsaXplOiBqczJweV9zZXJpYWxpemVyLFxuICAgIH0sIF9qczJweV9sYXlvdXREZWx0YToge1xuICAgICAgICBkZXNlcmlhbGl6ZTogcHkyanNfZGVzZXJpYWxpemVyLFxuICAgICAgICBzZXJpYWxpemU6IGpzMnB5X3NlcmlhbGl6ZXIsXG4gICAgfSwgX2pzMnB5X3RyYWNlRGVsdGFzOiB7XG4gICAgICAgIGRlc2VyaWFsaXplOiBweTJqc19kZXNlcmlhbGl6ZXIsXG4gICAgICAgIHNlcmlhbGl6ZToganMycHlfc2VyaWFsaXplcixcbiAgICB9LCBfanMycHlfcG9pbnRzQ2FsbGJhY2s6IHtcbiAgICAgICAgZGVzZXJpYWxpemU6IHB5MmpzX2Rlc2VyaWFsaXplcixcbiAgICAgICAgc2VyaWFsaXplOiBqczJweV9zZXJpYWxpemVyLFxuICAgIH0gfSk7XG5GaWd1cmVNb2RlbC5tb2RlbF9uYW1lID0gXCJGaWd1cmVNb2RlbFwiO1xuRmlndXJlTW9kZWwubW9kZWxfbW9kdWxlID0gTU9EVUxFX05BTUU7XG5GaWd1cmVNb2RlbC5tb2RlbF9tb2R1bGVfdmVyc2lvbiA9IHNlbXZlcl9yYW5nZTtcbkZpZ3VyZU1vZGVsLnZpZXdfbmFtZSA9IFwiRmlndXJlVmlld1wiO1xuRmlndXJlTW9kZWwudmlld19tb2R1bGUgPSBNT0RVTEVfTkFNRTtcbkZpZ3VyZU1vZGVsLnZpZXdfbW9kdWxlX3ZlcnNpb24gPSBzZW12ZXJfcmFuZ2U7XG4vLyBWaWV3XG4vLyA9PT09XG4vKipcbiAqIEEgRmlndXJlVmlldyBtYW5hZ2VzIHRoZSB2aXN1YWwgcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIFBsb3RseS5qc1xuICogZmlndXJlIGZvciBhIHNpbmdsZSBub3RlYm9vayBvdXRwdXQgY2VsbC4gRWFjaCBGaWd1cmVWaWV3IGhhcyBhXG4gKiByZWZlcmVuY2UgdG8gRmlndXJlTW9kZWwuICBNdWx0aXBsZSB2aWV3cyBtYXkgc2hhcmUgYSBzaW5nbGUgbW9kZWxcbiAqIGluc3RhbmNlLCBhcyBpcyB0aGUgY2FzZSB3aGVuIGEgUHl0aG9uIEZpZ3VyZVdpZGdldCBpcyBkaXNwbGF5ZWQgaW5cbiAqIG11bHRpcGxlIG5vdGVib29rIG91dHB1dCBjZWxscy5cbiAqXG4gKiBAdHlwZSB7d2lkZ2V0cy5ET01XaWRnZXRWaWV3fVxuICovXG5leHBvcnQgY2xhc3MgRmlndXJlVmlldyBleHRlbmRzIERPTVdpZGdldFZpZXcge1xuICAgIC8qKlxuICAgICAqIFRoZSBwZXJmb3JtX3JlbmRlciBtZXRob2QgaXMgY2FsbGVkIGJ5IHByb2Nlc3NQaG9zcGhvck1lc3NhZ2VcbiAgICAgKiBhZnRlciB0aGUgd2lkZ2V0J3MgRE9NIGVsZW1lbnQgaGFzIGJlZW4gYXR0YWNoZWQgdG8gdGhlIG5vdGVib29rXG4gICAgICogb3V0cHV0IGNlbGwuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgaW5pdGlhbGl6ZSBvZiB0aGVcbiAgICAgKiBGaWd1cmVNb2RlbCwgYW5kIGl0IHdvbid0IGhhcHBlbiBhdCBhbGwgaWYgdGhlIFB5dGhvbiBGaWd1cmVXaWRnZXRcbiAgICAgKiBpcyBuZXZlciBkaXNwbGF5ZWQgaW4gYSBub3RlYm9vayBvdXRwdXQgY2VsbFxuICAgICAqL1xuICAgIHBlcmZvcm1fcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgLy8gV2lyZSB1cCBtZXNzYWdlIHByb3BlcnR5IGNhbGxiYWNrc1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFB5dGhvbiAtPiBKUyBldmVudCBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMubW9kZWwub24oXCJjaGFuZ2U6X3B5MmpzX2FkZFRyYWNlc1wiLCB0aGlzLmRvX2FkZFRyYWNlcywgdGhpcyk7XG4gICAgICAgIHRoaXMubW9kZWwub24oXCJjaGFuZ2U6X3B5MmpzX2RlbGV0ZVRyYWNlc1wiLCB0aGlzLmRvX2RlbGV0ZVRyYWNlcywgdGhpcyk7XG4gICAgICAgIHRoaXMubW9kZWwub24oXCJjaGFuZ2U6X3B5MmpzX21vdmVUcmFjZXNcIiwgdGhpcy5kb19tb3ZlVHJhY2VzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vbihcImNoYW5nZTpfcHkyanNfcmVzdHlsZVwiLCB0aGlzLmRvX3Jlc3R5bGUsIHRoaXMpO1xuICAgICAgICB0aGlzLm1vZGVsLm9uKFwiY2hhbmdlOl9weTJqc19yZWxheW91dFwiLCB0aGlzLmRvX3JlbGF5b3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vbihcImNoYW5nZTpfcHkyanNfdXBkYXRlXCIsIHRoaXMuZG9fdXBkYXRlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vbihcImNoYW5nZTpfcHkyanNfYW5pbWF0ZVwiLCB0aGlzLmRvX2FuaW1hdGUsIHRoaXMpO1xuICAgICAgICAvLyBNYXRoSmF4IHYyIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIChfZCA9IChfYyA9IChfYiA9IChfYSA9IHdpbmRvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLk1hdGhKYXgpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5IdWIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5Db25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCB7IFNWRzogeyBmb250OiBcIlNUSVgtV2ViXCIgfSB9KTtcbiAgICAgICAgLy8gR2V0IG1lc3NhZ2UgaWRzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgbGF5b3V0X2VkaXRfaWQgPSB0aGlzLm1vZGVsLmdldChcIl9sYXN0X2xheW91dF9lZGl0X2lkXCIpO1xuICAgICAgICB2YXIgdHJhY2VfZWRpdF9pZCA9IHRoaXMubW9kZWwuZ2V0KFwiX2xhc3RfdHJhY2VfZWRpdF9pZFwiKTtcbiAgICAgICAgLy8gU2V0IHZpZXcgVUlEXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLnZpZXdJRCA9IHJhbmRzdHIoKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBQbG90bHkuanMgZmlndXJlXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBXZSBtdXN0IGNsb25lIHRoZSBtb2RlbCdzIGRhdGEgYW5kIGxheW91dCBwcm9wZXJ0aWVzIHNvIHRoYXRcbiAgICAgICAgLy8gdGhlIG1vZGVsIGlzIG5vdCBkaXJlY3RseSBtdXRhdGVkIGJ5IHRoZSBQbG90bHkuanMgbGlicmFyeS5cbiAgICAgICAgdmFyIGluaXRpYWxUcmFjZXMgPSBfLmNsb25lRGVlcCh0aGlzLm1vZGVsLmdldChcIl9kYXRhXCIpKTtcbiAgICAgICAgdmFyIGluaXRpYWxMYXlvdXQgPSBfLmNsb25lRGVlcCh0aGlzLm1vZGVsLmdldChcIl9sYXlvdXRcIikpO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5tb2RlbC5nZXQoXCJfY29uZmlnXCIpO1xuICAgICAgICBQbG90bHkubmV3UGxvdCh0aGF0LmVsLCBpbml0aWFsVHJhY2VzLCBpbml0aWFsTGF5b3V0LCBjb25maWcpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gIyMjIFNlbmQgdHJhY2UgZGVsdGFzICMjI1xuICAgICAgICAgICAgLy8gV2UgY3JlYXRlIGFuIGFycmF5IG9mIGRlbHRhcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBuZXdcbiAgICAgICAgICAgIC8vIHRyYWNlcy5cbiAgICAgICAgICAgIHRoYXQuX3NlbmRUcmFjZURlbHRhcyh0cmFjZV9lZGl0X2lkKTtcbiAgICAgICAgICAgIC8vICMjIyBTZW5kIGxheW91dCBkZWx0YSAjIyNcbiAgICAgICAgICAgIHRoYXQuX3NlbmRMYXlvdXREZWx0YShsYXlvdXRfZWRpdF9pZCk7XG4gICAgICAgICAgICAvLyBXaXJlIHVwIHBsb3RseSBldmVudCBjYWxsYmFja3NcbiAgICAgICAgICAgIHRoYXQuZWwub24oXCJwbG90bHlfcmVzdHlsZVwiLCBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVfcGxvdGx5X3Jlc3R5bGUodXBkYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhhdC5lbC5vbihcInBsb3RseV9yZWxheW91dFwiLCBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVfcGxvdGx5X3JlbGF5b3V0KHVwZGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoYXQuZWwub24oXCJwbG90bHlfdXBkYXRlXCIsIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZV9wbG90bHlfdXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoYXQuZWwub24oXCJwbG90bHlfY2xpY2tcIiwgZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoYXQuaGFuZGxlX3Bsb3RseV9jbGljayh1cGRhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGF0LmVsLm9uKFwicGxvdGx5X2hvdmVyXCIsIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZV9wbG90bHlfaG92ZXIodXBkYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhhdC5lbC5vbihcInBsb3RseV91bmhvdmVyXCIsIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZV9wbG90bHlfdW5ob3Zlcih1cGRhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGF0LmVsLm9uKFwicGxvdGx5X3NlbGVjdGVkXCIsIGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZV9wbG90bHlfc2VsZWN0ZWQodXBkYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhhdC5lbC5vbihcInBsb3RseV9kZXNlbGVjdFwiLCBmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVfcGxvdGx5X2Rlc2VsZWN0KHVwZGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoYXQuZWwub24oXCJwbG90bHlfZG91YmxlY2xpY2tcIiwgZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoYXQuaGFuZGxlX3Bsb3RseV9kb3VibGVjbGljayh1cGRhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBFbWl0IGV2ZW50IGluZGljYXRpbmcgdGhhdCB0aGUgd2lkZ2V0IGhhcyBmaW5pc2hlZFxuICAgICAgICAgICAgLy8gcmVuZGVyaW5nXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwbG90bHl3aWRnZXQtYWZ0ZXItcmVuZGVyXCIsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHsgZWxlbWVudDogdGhhdC5lbCwgdmlld0lEOiB0aGF0LnZpZXdJRCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBEaXNwYXRjaC9UcmlnZ2VyL0ZpcmUgdGhlIGV2ZW50XG4gICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3BvbmQgdG8gcGhvc3Bob3JqcyBldmVudHNcbiAgICAgKi9cbiAgICBwcm9jZXNzUGhvc3Bob3JNZXNzYWdlKG1zZykge1xuICAgICAgICBzdXBlci5wcm9jZXNzUGhvc3Bob3JNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImJlZm9yZS1hdHRhY2hcIjpcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgYW4gaW5pdGlhbCBlbXB0eSBmaWd1cmUuIFRoaXMgZXN0YWJsaXNoZXMgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSBwYWdlIHRoYXQgdGhlIGVsZW1lbnQgd2lsbCBub3QgYmUgZW1wdHksIGF2b2lkaW5nXG4gICAgICAgICAgICAgICAgLy8gc29tZSBvY2Nhc2lvbnMgd2hlcmUgdGhlIGR5bmFtaWMgc2l6aW5nIGJlaGF2aW9yIGxlYWRzXG4gICAgICAgICAgICAgICAgLy8gdG8gY29sbGFwc2VkIGZpZ3VyZSBkaW1lbnNpb25zLlxuICAgICAgICAgICAgICAgIHZhciBheGlzSGlkZGVuID0ge1xuICAgICAgICAgICAgICAgICAgICBzaG93Z3JpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNob3dsaW5lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGlja3ZhbHM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGxvdGx5Lm5ld1Bsb3QodGhhdC5lbCwgW10sIHtcbiAgICAgICAgICAgICAgICAgICAgeGF4aXM6IGF4aXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgIHlheGlzOiBheGlzSGlkZGVuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hdXRvc2l6ZUZpZ3VyZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFmdGVyLWF0dGFjaFwiOlxuICAgICAgICAgICAgICAgIC8vIFJlbmRlcmluZyBhY3R1YWwgZmlndXJlIGluIHRoZSBhZnRlci1hdHRhY2ggZXZlbnQgYWxsb3dzXG4gICAgICAgICAgICAgICAgLy8gUGxvdGx5LmpzIHRvIHNpemUgdGhlIGZpZ3VyZSB0byBmaWxsIHRoZSBhdmFpbGFibGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybV9yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhZnRlci1zaG93XCI6XG4gICAgICAgICAgICBjYXNlIFwicmVzaXplXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvc2l6ZUZpZ3VyZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF1dG9zaXplRmlndXJlKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGF0Lm1vZGVsLmdldChcIl9sYXlvdXRcIik7XG4gICAgICAgIGlmIChfLmlzTmlsKGxheW91dCkgfHwgXy5pc05pbChsYXlvdXQud2lkdGgpKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBQbG90bHkuUGxvdHMucmVzaXplKHRoYXQuZWwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRfZWRpdF9pZCA9IHRoYXQubW9kZWwuZ2V0KFwiX2xhc3RfbGF5b3V0X2VkaXRfaWRcIik7XG4gICAgICAgICAgICAgICAgdGhhdC5fc2VuZExheW91dERlbHRhKGxheW91dF9lZGl0X2lkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1cmdlIFBsb3RseS5qcyBkYXRhIHN0cnVjdHVyZXMgZnJvbSB0aGUgbm90ZWJvb2sgb3V0cHV0IGRpc3BsYXlcbiAgICAgKiBlbGVtZW50IHdoZW4gdGhlIHZpZXcgaXMgZGVzdHJveWVkXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgUGxvdGx5LnB1cmdlKHRoaXMuZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGZpZ3VyZSdzIF9mdWxsRGF0YSBhcnJheSBtZXJnZWQgd2l0aCBpdHMgZGF0YSBhcnJheVxuICAgICAqXG4gICAgICogVGhlIG1lcmdlIGVuc3VyZXMgdGhhdCBmb3IgYW55IHByb3BlcnRpZXMgdGhhdCBlbC5fZnVsbERhdGEgYW5kXG4gICAgICogZWwuZGF0YSBoYXZlIGluIGNvbW1vbiwgd2UgcmV0dXJuIHRoZSB2ZXJzaW9uIGZyb20gZWwuZGF0YVxuICAgICAqXG4gICAgICogTmFtZWQgY29sb3JzY2FsZXMgYXJlIG9uZSBleGFtcGxlIG9mIHdoeSB0aGlzIGlzIG5lZWRlZC4gVGhlIGVsLmRhdGFcbiAgICAgKiBhcnJheSB3aWxsIGhvbGQgbmFtZWQgY29sb3JzY2FsZSBzdHJpbmdzIChlLmcuICdWaXJpZGlzJyksIHdoaWxlIHRoZVxuICAgICAqIGVsLl9mdWxsRGF0YSBhcnJheSB3aWxsIGhvbGQgdGhlIGFjdHVhbCBjb2xvcnNjYWxlIGFycmF5LiBlLmcuXG4gICAgICpcbiAgICAgKiAgICAgIGVsLmRhdGFbMF0ubWFya2VyLmNvbG9yc2NhbGUgPT0gJ1ZpcmlkaXMnIGJ1dFxuICAgICAqICAgICAgZWwuX2Z1bGxEYXRhWzBdLm1hcmtlci5jb2xvcnNjYWxlID0gW1suLi4sIC4uLl0sIC4uLl1cbiAgICAgKlxuICAgICAqIFBlcmZvcm1pbmcgdGhlIG1lcmdlIGFsbG93cyBvdXIgRmlndXJlTW9kZWwgdG8gcmV0YWluIHRoZSAnVmlyaWRpcydcbiAgICAgKiBzdHJpbmcsIHJhdGhlciB0aGFuIGhhdmluZyBpdCBvdmVycmlkZGVkIGJ5IHRoZSBjb2xvcnNjYWxlIGFycmF5LlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0RnVsbERhdGEoKSB7XG4gICAgICAgIHJldHVybiBfLm1lcmdlV2l0aCh7fSwgdGhpcy5lbC5fZnVsbERhdGEsIHRoaXMuZWwuZGF0YSwgZnVsbE1lcmdlQ3VzdG9taXplcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZmlndXJlJ3MgX2Z1bGxMYXlvdXQgb2JqZWN0IG1lcmdlZCB3aXRoIGl0cyBsYXlvdXQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBTZWUgZ2V0RnVsbERhdGEgZG9jdW1lbnRhdGlvbiBmb3IgZGlzY3Vzc2lvbiBvZiB3aHkgdGhlIG1lcmdlIGlzXG4gICAgICogbmVjZXNzYXJ5XG4gICAgICovXG4gICAgZ2V0RnVsbExheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIF8ubWVyZ2VXaXRoKHt9LCB0aGlzLmVsLl9mdWxsTGF5b3V0LCB0aGlzLmVsLmxheW91dCwgZnVsbE1lcmdlQ3VzdG9taXplcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIFBvaW50cyBkYXRhIHN0cnVjdHVyZSBmcm9tIGRhdGEgc3VwcGxpZWQgYnkgdGhlIHBsb3RseV9jbGljayxcbiAgICAgKiBwbG90bHlfaG92ZXIsIG9yIHBsb3RseV9zZWxlY3QgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxQb2ludHN9XG4gICAgICovXG4gICAgYnVpbGRQb2ludHNPYmplY3QoZGF0YSkge1xuICAgICAgICB2YXIgcG9pbnRzT2JqZWN0O1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShcInBvaW50c1wiKSkge1xuICAgICAgICAgICAgLy8gTW9zdCBjYXJ0ZXNpYW4gcGxvdHNcbiAgICAgICAgICAgIHZhciBwb2ludE9iamVjdHMgPSBkYXRhW1wicG9pbnRzXCJdO1xuICAgICAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50T2JqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzTmVzdGVkUG9pbnRPYmplY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBoYXNOZXN0ZWRQb2ludE9iamVjdHMgPVxuICAgICAgICAgICAgICAgICAgICBoYXNOZXN0ZWRQb2ludE9iamVjdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50T2JqZWN0c1tpXS5oYXNPd25Qcm9wZXJ0eShcInBvaW50TnVtYmVyc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc05lc3RlZFBvaW50T2JqZWN0cylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtUG9pbnROdW1iZXJzID0gbnVtUG9pbnRzO1xuICAgICAgICAgICAgaWYgKGhhc05lc3RlZFBvaW50T2JqZWN0cykge1xuICAgICAgICAgICAgICAgIG51bVBvaW50TnVtYmVycyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBudW1Qb2ludE51bWJlcnMgKz0gcG9pbnRPYmplY3RzW2ldW1wicG9pbnROdW1iZXJzXCJdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHNPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgdHJhY2VfaW5kZXhlczogbmV3IEFycmF5KG51bVBvaW50TnVtYmVycyksXG4gICAgICAgICAgICAgICAgcG9pbnRfaW5kZXhlczogbmV3IEFycmF5KG51bVBvaW50TnVtYmVycyksXG4gICAgICAgICAgICAgICAgeHM6IG5ldyBBcnJheShudW1Qb2ludE51bWJlcnMpLFxuICAgICAgICAgICAgICAgIHlzOiBuZXcgQXJyYXkobnVtUG9pbnROdW1iZXJzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGFzTmVzdGVkUG9pbnRPYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZsYXRQb2ludEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IG51bVBvaW50czsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRPYmplY3RzW3BdW1wicG9pbnROdW1iZXJzXCJdLmxlbmd0aDsgaSsrLCBmbGF0UG9pbnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNPYmplY3RbXCJwb2ludF9pbmRleGVzXCJdW2ZsYXRQb2ludEluZGV4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRPYmplY3RzW3BdW1wicG9pbnROdW1iZXJzXCJdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhZGQgeHMsIHlzIGFuZCB0cmFjZXMgc28gdGhhdCB0aGUgYXJyYXkgZG9lc24ndCBnZXQgdHJ1bmNhdGVkIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNPYmplY3RbXCJ4c1wiXVtmbGF0UG9pbnRJbmRleF0gPSBwb2ludE9iamVjdHNbcF1bXCJ4XCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzT2JqZWN0W1wieXNcIl1bZmxhdFBvaW50SW5kZXhdID0gcG9pbnRPYmplY3RzW3BdW1wieVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c09iamVjdFtcInRyYWNlX2luZGV4ZXNcIl1bZmxhdFBvaW50SW5kZXhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludE9iamVjdHNbcF1bXCJjdXJ2ZU51bWJlclwiXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc2luZ2xlX3RyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bVBvaW50TnVtYmVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZV90cmFjZSA9IHNpbmdsZV90cmFjZSAmJiAocG9pbnRzT2JqZWN0W1widHJhY2VfaW5kZXhlc1wiXVtpIC0gMV0gPT09IHBvaW50c09iamVjdFtcInRyYWNlX2luZGV4ZXNcIl1baV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbmdsZV90cmFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlX3RyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c09iamVjdFtcInBvaW50X2luZGV4ZXNcIl0uc29ydCgoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgbnVtUG9pbnRzOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzT2JqZWN0W1widHJhY2VfaW5kZXhlc1wiXVtwXSA9IHBvaW50T2JqZWN0c1twXVtcImN1cnZlTnVtYmVyXCJdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNPYmplY3RbXCJwb2ludF9pbmRleGVzXCJdW3BdID0gcG9pbnRPYmplY3RzW3BdW1wicG9pbnROdW1iZXJcIl07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c09iamVjdFtcInhzXCJdW3BdID0gcG9pbnRPYmplY3RzW3BdW1wieFwiXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzT2JqZWN0W1wieXNcIl1bcF0gPSBwb2ludE9iamVjdHNbcF1bXCJ5XCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB6IGlmIHByZXNlbnRcbiAgICAgICAgICAgIHZhciBoYXNaID0gcG9pbnRPYmplY3RzWzBdICE9PSB1bmRlZmluZWQgJiYgcG9pbnRPYmplY3RzWzBdLmhhc093blByb3BlcnR5KFwielwiKTtcbiAgICAgICAgICAgIGlmIChoYXNaKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzT2JqZWN0W1wienNcIl0gPSBuZXcgQXJyYXkobnVtUG9pbnRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgbnVtUG9pbnRzOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzT2JqZWN0W1wienNcIl1bcF0gPSBwb2ludE9iamVjdHNbcF1bXCJ6XCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHNPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCBJbnB1dERldmljZVN0YXRlIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSBzdXBwbGllZCBieSB0aGVcbiAgICAgKiBwbG90bHlfY2xpY2ssIHBsb3RseV9ob3Zlciwgb3IgcGxvdGx5X3NlbGVjdCBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtudWxsfElucHV0RGV2aWNlU3RhdGV9XG4gICAgICovXG4gICAgYnVpbGRJbnB1dERldmljZVN0YXRlT2JqZWN0KGRhdGEpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZGF0YVtcImV2ZW50XCJdO1xuICAgICAgICBpZiAoZXZlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiogQHR5cGUge0lucHV0RGV2aWNlU3RhdGV9ICovXG4gICAgICAgICAgICB2YXIgaW5wdXREZXZpY2VTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAvLyBLZXlib2FyZCBtb2RpZmllcnNcbiAgICAgICAgICAgICAgICBhbHQ6IGV2ZW50W1wiYWx0S2V5XCJdLFxuICAgICAgICAgICAgICAgIGN0cmw6IGV2ZW50W1wiY3RybEtleVwiXSxcbiAgICAgICAgICAgICAgICBtZXRhOiBldmVudFtcIm1ldGFLZXlcIl0sXG4gICAgICAgICAgICAgICAgc2hpZnQ6IGV2ZW50W1wic2hpZnRLZXlcIl0sXG4gICAgICAgICAgICAgICAgLy8gTW91c2UgYnV0dG9uc1xuICAgICAgICAgICAgICAgIGJ1dHRvbjogZXZlbnRbXCJidXR0b25cIl0sXG4gICAgICAgICAgICAgICAgYnV0dG9uczogZXZlbnRbXCJidXR0b25zXCJdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dERldmljZVN0YXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIFNlbGVjdG9yIGRhdGEgc3RydWN0dXJlIGZyb20gZGF0YSBzdXBwbGllZCBieSB0aGVcbiAgICAgKiBwbG90bHlfc2VsZWN0IGV2ZW50XG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxTZWxlY3Rvcn1cbiAgICAgKi9cbiAgICBidWlsZFNlbGVjdG9yT2JqZWN0KGRhdGEpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yT2JqZWN0O1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShcInJhbmdlXCIpKSB7XG4gICAgICAgICAgICAvLyBCb3ggc2VsZWN0aW9uXG4gICAgICAgICAgICBzZWxlY3Rvck9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJveFwiLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yX3N0YXRlOiB7XG4gICAgICAgICAgICAgICAgICAgIHhyYW5nZTogZGF0YVtcInJhbmdlXCJdW1wieFwiXSxcbiAgICAgICAgICAgICAgICAgICAgeXJhbmdlOiBkYXRhW1wicmFuZ2VcIl1bXCJ5XCJdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoXCJsYXNzb1BvaW50c1wiKSkge1xuICAgICAgICAgICAgLy8gTGFzc28gc2VsZWN0aW9uXG4gICAgICAgICAgICBzZWxlY3Rvck9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImxhc3NvXCIsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3Jfc3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeHM6IGRhdGFbXCJsYXNzb1BvaW50c1wiXVtcInhcIl0sXG4gICAgICAgICAgICAgICAgICAgIHlzOiBkYXRhW1wibGFzc29Qb2ludHNcIl1bXCJ5XCJdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0b3JPYmplY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3Rvck9iamVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBsb3R5X3Jlc3R5bGUgZXZlbnRzIGVtaXR0ZWQgYnkgdGhlIFBsb3RseS5qcyBsaWJyYXJ5XG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVfcGxvdGx5X3Jlc3R5bGUoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgdG8gcmVwb3J0IHRvIHRoZSBQeXRob24gc2lkZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhWzBdICYmIGRhdGFbMF0uaGFzT3duUHJvcGVydHkoXCJfZG9Ob3RSZXBvcnRUb1B5XCIpKSB7XG4gICAgICAgICAgICAvLyBSZXN0eWxlIG9yaWdpbmF0ZWQgb24gdGhlIFB5dGhvbiBzaWRlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5wYWNrIGRhdGFcbiAgICAgICAgdmFyIHN0eWxlRGF0YSA9IGRhdGFbMF07XG4gICAgICAgIHZhciBzdHlsZVRyYWNlcyA9IGRhdGFbMV07XG4gICAgICAgIC8vIENvbnN0cnVjdCByZXN0eWxlIG1lc3NhZ2UgdG8gc2VuZCB0byB0aGUgUHl0aG9uIHNpZGVcbiAgICAgICAgLyoqIEB0eXBlIHtKczJQeVJlc3R5bGVNc2d9ICovXG4gICAgICAgIHZhciByZXN0eWxlTXNnID0ge1xuICAgICAgICAgICAgc3R5bGVfZGF0YTogc3R5bGVEYXRhLFxuICAgICAgICAgICAgc3R5bGVfdHJhY2VzOiBzdHlsZVRyYWNlcyxcbiAgICAgICAgICAgIHNvdXJjZV92aWV3X2lkOiB0aGlzLnZpZXdJRCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJfanMycHlfcmVzdHlsZVwiLCByZXN0eWxlTXNnKTtcbiAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGxvdGx5X3JlbGF5b3V0IGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBQbG90bHkuanMgbGlicmFyeVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgaGFuZGxlX3Bsb3RseV9yZWxheW91dChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gTm8gZGF0YSB0byByZXBvcnQgdG8gdGhlIFB5dGhvbiBzaWRlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoXCJfZG9Ob3RSZXBvcnRUb1B5XCIpKSB7XG4gICAgICAgICAgICAvLyBSZWxheW91dCBvcmlnaW5hdGVkIG9uIHRoZSBQeXRob24gc2lkZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7SnMyUHlSZWxheW91dE1zZ30gKi9cbiAgICAgICAgdmFyIHJlbGF5b3V0TXNnID0ge1xuICAgICAgICAgICAgcmVsYXlvdXRfZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHNvdXJjZV92aWV3X2lkOiB0aGlzLnZpZXdJRCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJfanMycHlfcmVsYXlvdXRcIiwgcmVsYXlvdXRNc2cpO1xuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwbG90bHlfdXBkYXRlIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBQbG90bHkuanMgbGlicmFyeVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgaGFuZGxlX3Bsb3RseV91cGRhdGUoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgdG8gcmVwb3J0IHRvIHRoZSBQeXRob24gc2lkZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhW1wiZGF0YVwiXSAmJiBkYXRhW1wiZGF0YVwiXVswXS5oYXNPd25Qcm9wZXJ0eShcIl9kb05vdFJlcG9ydFRvUHlcIikpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvcmlnaW5hdGVkIG9uIHRoZSBQeXRob24gc2lkZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7SnMyUHlVcGRhdGVNc2d9ICovXG4gICAgICAgIHZhciB1cGRhdGVNc2cgPSB7XG4gICAgICAgICAgICBzdHlsZV9kYXRhOiBkYXRhW1wiZGF0YVwiXVswXSxcbiAgICAgICAgICAgIHN0eWxlX3RyYWNlczogZGF0YVtcImRhdGFcIl1bMV0sXG4gICAgICAgICAgICBsYXlvdXRfZGF0YTogZGF0YVtcImxheW91dFwiXSxcbiAgICAgICAgICAgIHNvdXJjZV92aWV3X2lkOiB0aGlzLnZpZXdJRCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTG9nIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJfanMycHlfdXBkYXRlXCIsIHVwZGF0ZU1zZyk7XG4gICAgICAgIHRoaXMudG91Y2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBsb3RseV9jbGljayBldmVudHMgZW1pdHRlZCBieSB0aGUgUGxvdGx5LmpzIGxpYnJhcnlcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGhhbmRsZV9wbG90bHlfY2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLl9zZW5kX3BvaW50c19jYWxsYmFja19tZXNzYWdlKGRhdGEsIFwicGxvdGx5X2NsaWNrXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGxvdGx5X2hvdmVyIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBQbG90bHkuanMgbGlicmFyeVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgaGFuZGxlX3Bsb3RseV9ob3ZlcihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3NlbmRfcG9pbnRzX2NhbGxiYWNrX21lc3NhZ2UoZGF0YSwgXCJwbG90bHlfaG92ZXJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwbG90bHlfdW5ob3ZlciBldmVudHMgZW1pdHRlZCBieSB0aGUgUGxvdGx5LmpzIGxpYnJhcnlcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGhhbmRsZV9wbG90bHlfdW5ob3ZlcihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3NlbmRfcG9pbnRzX2NhbGxiYWNrX21lc3NhZ2UoZGF0YSwgXCJwbG90bHlfdW5ob3ZlclwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBsb3RseV9zZWxlY3RlZCBldmVudHMgZW1pdHRlZCBieSB0aGUgUGxvdGx5LmpzIGxpYnJhcnlcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGhhbmRsZV9wbG90bHlfc2VsZWN0ZWQoZGF0YSkge1xuICAgICAgICB0aGlzLl9zZW5kX3BvaW50c19jYWxsYmFja19tZXNzYWdlKGRhdGEsIFwicGxvdGx5X3NlbGVjdGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGxvdGx5X2Rlc2VsZWN0IGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBQbG90bHkuanMgbGlicmFyeVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgaGFuZGxlX3Bsb3RseV9kZXNlbGVjdChkYXRhKSB7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICBwb2ludHM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kX3BvaW50c19jYWxsYmFja19tZXNzYWdlKGRhdGEsIFwicGxvdGx5X2Rlc2VsZWN0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhbmQgc2VuZCBhIHBvaW50cyBjYWxsYmFjayBtZXNzYWdlIHRvIHRoZSBQeXRob24gc2lkZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiAgZGF0YSBvYmplY3QgYXMgcHJvdmlkZWQgYnkgdGhlIHBsb3RseV9jbGljaywgcGxvdGx5X2hvdmVyLFxuICAgICAqICBwbG90bHlfdW5ob3Zlciwgb3IgcGxvdGx5X3NlbGVjdGVkIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF90eXBlXG4gICAgICogIE5hbWUgb2YgdGhlIHRyaWdnZXJpbmcgZXZlbnQuIE9uZSBvZiAncGxvdGx5X2NsaWNrJyxcbiAgICAgKiAgJ3Bsb3RseV9ob3ZlcicsICdwbG90bHlfdW5ob3ZlcicsIG9yICdwbG90bHlfc2VsZWN0ZWQnXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VuZF9wb2ludHNfY2FsbGJhY2tfbWVzc2FnZShkYXRhLCBldmVudF90eXBlKSB7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gTm8gZGF0YSB0byByZXBvcnQgdG8gdGhlIFB5dGhvbiBzaWRlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHtKczJQeVBvaW50c0NhbGxiYWNrTXNnfSAqL1xuICAgICAgICB2YXIgcG9pbnRzTXNnID0ge1xuICAgICAgICAgICAgZXZlbnRfdHlwZTogZXZlbnRfdHlwZSxcbiAgICAgICAgICAgIHBvaW50czogdGhpcy5idWlsZFBvaW50c09iamVjdChkYXRhKSxcbiAgICAgICAgICAgIGRldmljZV9zdGF0ZTogdGhpcy5idWlsZElucHV0RGV2aWNlU3RhdGVPYmplY3QoZGF0YSksXG4gICAgICAgICAgICBzZWxlY3RvcjogdGhpcy5idWlsZFNlbGVjdG9yT2JqZWN0KGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocG9pbnRzTXNnW1wicG9pbnRzXCJdICE9PSBudWxsICYmIHBvaW50c01zZ1tcInBvaW50c1wiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIl9qczJweV9wb2ludHNDYWxsYmFja1wiLCBwb2ludHNNc2cpO1xuICAgICAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0dWIgZm9yIGZ1dHVyZSBoYW5kbGluZyBvZiBwbG90bHlfZG91YmxlY2xpY2tcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGhhbmRsZV9wbG90bHlfZG91YmxlY2xpY2soZGF0YSkgeyB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIFBsb3RseS5hZGRUcmFjZXMgcmVxdWVzdFxuICAgICAqL1xuICAgIGRvX2FkZFRyYWNlcygpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQeTJKc0FkZFRyYWNlc01zZ30gKi9cbiAgICAgICAgdmFyIG1zZ0RhdGEgPSB0aGlzLm1vZGVsLmdldChcIl9weTJqc19hZGRUcmFjZXNcIik7XG4gICAgICAgIGlmIChtc2dEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBQbG90bHkuYWRkVHJhY2VzKHRoaXMuZWwsIG1zZ0RhdGEudHJhY2VfZGF0YSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gIyMjIFNlbmQgdHJhY2UgZGVsdGFzICMjI1xuICAgICAgICAgICAgICAgIHRoYXQuX3NlbmRUcmFjZURlbHRhcyhtc2dEYXRhLnRyYWNlX2VkaXRfaWQpO1xuICAgICAgICAgICAgICAgIC8vICMjIyBTZW5kIGxheW91dCBkZWx0YSAjIyNcbiAgICAgICAgICAgICAgICB2YXIgbGF5b3V0X2VkaXRfaWQgPSBtc2dEYXRhLmxheW91dF9lZGl0X2lkO1xuICAgICAgICAgICAgICAgIHRoYXQuX3NlbmRMYXlvdXREZWx0YShsYXlvdXRfZWRpdF9pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgUGxvdGx5LmRlbGV0ZVRyYWNlcyByZXF1ZXN0XG4gICAgICovXG4gICAgZG9fZGVsZXRlVHJhY2VzKCkge1xuICAgICAgICAvKiogQHR5cGUge1B5MkpzRGVsZXRlVHJhY2VzTXNnfSAqL1xuICAgICAgICB2YXIgbXNnRGF0YSA9IHRoaXMubW9kZWwuZ2V0KFwiX3B5MmpzX2RlbGV0ZVRyYWNlc1wiKTtcbiAgICAgICAgaWYgKG1zZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkZWxldGVfaW5kcyA9IG1zZ0RhdGEuZGVsZXRlX2luZHM7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBQbG90bHkuZGVsZXRlVHJhY2VzKHRoaXMuZWwsIGRlbGV0ZV9pbmRzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyAjIyMgU2VuZCB0cmFjZSBkZWx0YXMgIyMjXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNlX2VkaXRfaWQgPSBtc2dEYXRhLnRyYWNlX2VkaXRfaWQ7XG4gICAgICAgICAgICAgICAgdGhhdC5fc2VuZFRyYWNlRGVsdGFzKHRyYWNlX2VkaXRfaWQpO1xuICAgICAgICAgICAgICAgIC8vICMjIyBTZW5kIGxheW91dCBkZWx0YSAjIyNcbiAgICAgICAgICAgICAgICB2YXIgbGF5b3V0X2VkaXRfaWQgPSBtc2dEYXRhLmxheW91dF9lZGl0X2lkO1xuICAgICAgICAgICAgICAgIHRoYXQuX3NlbmRMYXlvdXREZWx0YShsYXlvdXRfZWRpdF9pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgUGxvdGx5Lm1vdmVUcmFjZXMgcmVxdWVzdFxuICAgICAqL1xuICAgIGRvX21vdmVUcmFjZXMoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7UHkySnNNb3ZlVHJhY2VzTXNnfSAqL1xuICAgICAgICB2YXIgbXNnRGF0YSA9IHRoaXMubW9kZWwuZ2V0KFwiX3B5MmpzX21vdmVUcmFjZXNcIik7XG4gICAgICAgIGlmIChtc2dEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBVbnBhY2sgbWVzc2FnZVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRzID0gbXNnRGF0YS5jdXJyZW50X3RyYWNlX2luZHM7XG4gICAgICAgICAgICB2YXIgbmV3SW5kcyA9IG1zZ0RhdGEubmV3X3RyYWNlX2luZHM7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmV3IHRyYWNlIGluZGV4ZXMgYXJlIGFjdHVhbGx5IGRpZmZlcmVudCB0aGFuXG4gICAgICAgICAgICAvLyB0aGUgY3VycmVudCBpbmRleGVzXG4gICAgICAgICAgICB2YXIgaW5kc19lcXVhbCA9IF8uaXNFcXVhbChjdXJyZW50SW5kcywgbmV3SW5kcyk7XG4gICAgICAgICAgICBpZiAoIWluZHNfZXF1YWwpIHtcbiAgICAgICAgICAgICAgICBQbG90bHkubW92ZVRyYWNlcyh0aGlzLmVsLCBjdXJyZW50SW5kcywgbmV3SW5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIFBsb3RseS5yZXN0eWxlIHJlcXVlc3RcbiAgICAgKi9cbiAgICBkb19yZXN0eWxlKCkge1xuICAgICAgICAvKiogQHR5cGUge1B5MkpzUmVzdHlsZU1zZ30gKi9cbiAgICAgICAgdmFyIG1zZ0RhdGEgPSB0aGlzLm1vZGVsLmdldChcIl9weTJqc19yZXN0eWxlXCIpO1xuICAgICAgICBpZiAobXNnRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3R5bGVEYXRhID0gbXNnRGF0YS5yZXN0eWxlX2RhdGE7XG4gICAgICAgICAgICB2YXIgdHJhY2VJbmRleGVzID0gdGhpcy5tb2RlbC5fbm9ybWFsaXplX3RyYWNlX2luZGV4ZXMobXNnRGF0YS5yZXN0eWxlX3RyYWNlcyk7XG4gICAgICAgICAgICByZXN0eWxlRGF0YVtcIl9kb05vdFJlcG9ydFRvUHlcIl0gPSB0cnVlO1xuICAgICAgICAgICAgUGxvdGx5LnJlc3R5bGUodGhpcy5lbCwgcmVzdHlsZURhdGEsIHRyYWNlSW5kZXhlcyk7XG4gICAgICAgICAgICAvLyAjIyMgU2VuZCB0cmFjZSBkZWx0YXMgIyMjXG4gICAgICAgICAgICAvLyBXZSBjcmVhdGUgYW4gYXJyYXkgb2YgZGVsdGFzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlc3R5bGVkXG4gICAgICAgICAgICAvLyB0cmFjZXMuXG4gICAgICAgICAgICB0aGlzLl9zZW5kVHJhY2VEZWx0YXMobXNnRGF0YS50cmFjZV9lZGl0X2lkKTtcbiAgICAgICAgICAgIC8vICMjIyBTZW5kIGxheW91dCBkZWx0YSAjIyNcbiAgICAgICAgICAgIHZhciBsYXlvdXRfZWRpdF9pZCA9IG1zZ0RhdGEubGF5b3V0X2VkaXRfaWQ7XG4gICAgICAgICAgICB0aGlzLl9zZW5kTGF5b3V0RGVsdGEobGF5b3V0X2VkaXRfaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBQbG90bHkucmVsYXlvdXQgcmVxdWVzdFxuICAgICAqL1xuICAgIGRvX3JlbGF5b3V0KCkge1xuICAgICAgICAvKiogQHR5cGUge1B5MkpzUmVsYXlvdXRNc2d9ICovXG4gICAgICAgIHZhciBtc2dEYXRhID0gdGhpcy5tb2RlbC5nZXQoXCJfcHkyanNfcmVsYXlvdXRcIik7XG4gICAgICAgIGlmIChtc2dEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobXNnRGF0YS5zb3VyY2Vfdmlld19pZCAhPT0gdGhpcy52aWV3SUQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXlvdXREYXRhID0gbXNnRGF0YS5yZWxheW91dF9kYXRhO1xuICAgICAgICAgICAgICAgIHJlbGF5b3V0RGF0YVtcIl9kb05vdFJlcG9ydFRvUHlcIl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIFBsb3RseS5yZWxheW91dCh0aGlzLmVsLCBtc2dEYXRhLnJlbGF5b3V0X2RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIyMjIFNlbmQgbGF5b3V0IGRlbHRhICMjI1xuICAgICAgICAgICAgdmFyIGxheW91dF9lZGl0X2lkID0gbXNnRGF0YS5sYXlvdXRfZWRpdF9pZDtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRMYXlvdXREZWx0YShsYXlvdXRfZWRpdF9pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIFBsb3RseS51cGRhdGUgcmVxdWVzdFxuICAgICAqL1xuICAgIGRvX3VwZGF0ZSgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQeTJKc1VwZGF0ZU1zZ30gKi9cbiAgICAgICAgdmFyIG1zZ0RhdGEgPSB0aGlzLm1vZGVsLmdldChcIl9weTJqc191cGRhdGVcIik7XG4gICAgICAgIGlmIChtc2dEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBtc2dEYXRhLnN0eWxlX2RhdGEgfHwge307XG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gbXNnRGF0YS5sYXlvdXRfZGF0YSB8fCB7fTtcbiAgICAgICAgICAgIHZhciB0cmFjZUluZGV4ZXMgPSB0aGlzLm1vZGVsLl9ub3JtYWxpemVfdHJhY2VfaW5kZXhlcyhtc2dEYXRhLnN0eWxlX3RyYWNlcyk7XG4gICAgICAgICAgICBzdHlsZVtcIl9kb05vdFJlcG9ydFRvUHlcIl0gPSB0cnVlO1xuICAgICAgICAgICAgUGxvdGx5LnVwZGF0ZSh0aGlzLmVsLCBzdHlsZSwgbGF5b3V0LCB0cmFjZUluZGV4ZXMpO1xuICAgICAgICAgICAgLy8gIyMjIFNlbmQgdHJhY2UgZGVsdGFzICMjI1xuICAgICAgICAgICAgLy8gV2UgY3JlYXRlIGFuIGFycmF5IG9mIGRlbHRhcyBjb3JyZXNwb25kaW5nIHRvIHRoZSB1cGRhdGVkXG4gICAgICAgICAgICAvLyB0cmFjZXMuXG4gICAgICAgICAgICB0aGlzLl9zZW5kVHJhY2VEZWx0YXMobXNnRGF0YS50cmFjZV9lZGl0X2lkKTtcbiAgICAgICAgICAgIC8vICMjIyBTZW5kIGxheW91dCBkZWx0YSAjIyNcbiAgICAgICAgICAgIHZhciBsYXlvdXRfZWRpdF9pZCA9IG1zZ0RhdGEubGF5b3V0X2VkaXRfaWQ7XG4gICAgICAgICAgICB0aGlzLl9zZW5kTGF5b3V0RGVsdGEobGF5b3V0X2VkaXRfaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBQbG90bHkuYW5pbWF0ZSByZXF1ZXN0XG4gICAgICovXG4gICAgZG9fYW5pbWF0ZSgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQeTJKc0FuaW1hdGVNc2d9ICovXG4gICAgICAgIHZhciBtc2dEYXRhID0gdGhpcy5tb2RlbC5nZXQoXCJfcHkyanNfYW5pbWF0ZVwiKTtcbiAgICAgICAgaWYgKG1zZ0RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFVucGFjayBwYXJhbXNcbiAgICAgICAgICAgIC8vIHZhciBhbmltYXRpb25EYXRhID0gbXNnRGF0YVswXTtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25PcHRzID0gbXNnRGF0YS5hbmltYXRpb25fb3B0cztcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBtc2dEYXRhLnN0eWxlX2RhdGE7XG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gbXNnRGF0YS5sYXlvdXRfZGF0YTtcbiAgICAgICAgICAgIHZhciB0cmFjZUluZGV4ZXMgPSB0aGlzLm1vZGVsLl9ub3JtYWxpemVfdHJhY2VfaW5kZXhlcyhtc2dEYXRhLnN0eWxlX3RyYWNlcyk7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBzdHlsZXMsXG4gICAgICAgICAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgICAgICAgdHJhY2VzOiB0cmFjZUluZGV4ZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYW5pbWF0aW9uRGF0YVtcIl9kb05vdFJlcG9ydFRvUHlcIl0gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgUGxvdGx5LmFuaW1hdGUodGhpcy5lbCwgYW5pbWF0aW9uRGF0YSwgYW5pbWF0aW9uT3B0cykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gIyMjIFNlbmQgdHJhY2UgZGVsdGFzICMjI1xuICAgICAgICAgICAgICAgIC8vIFdlIGNyZWF0ZSBhbiBhcnJheSBvZiBkZWx0YXMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBhbmltYXRlZCB0cmFjZXMuXG4gICAgICAgICAgICAgICAgdGhhdC5fc2VuZFRyYWNlRGVsdGFzKG1zZ0RhdGEudHJhY2VfZWRpdF9pZCk7XG4gICAgICAgICAgICAgICAgLy8gIyMjIFNlbmQgbGF5b3V0IGRlbHRhICMjI1xuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRfZWRpdF9pZCA9IG1zZ0RhdGEubGF5b3V0X2VkaXRfaWQ7XG4gICAgICAgICAgICAgICAgdGhhdC5fc2VuZExheW91dERlbHRhKGxheW91dF9lZGl0X2lkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBsYXlvdXQgZGVsdGEgb2JqZWN0IGFuZCBzZW5kIGxheW91dERlbHRhIG1lc3NhZ2UgdG8gdGhlXG4gICAgICogUHl0aG9uIHNpZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXlvdXRfZWRpdF9pZFxuICAgICAqICBFZGl0IElEIG9mIG1lc3NhZ2UgdGhhdCB0cmlnZ2VyZWQgdGhlIGNyZWF0aW9uIG9mIHRoZSBsYXlvdXQgZGVsdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZW5kTGF5b3V0RGVsdGEobGF5b3V0X2VkaXRfaWQpIHtcbiAgICAgICAgLy8gIyMjIEhhbmRsZSBsYXlvdXQgZGVsdGEgIyMjXG4gICAgICAgIHZhciBsYXlvdXRfZGVsdGEgPSBjcmVhdGVEZWx0YU9iamVjdCh0aGlzLmdldEZ1bGxMYXlvdXQoKSwgdGhpcy5tb2RlbC5nZXQoXCJfbGF5b3V0XCIpKTtcbiAgICAgICAgLyoqIEB0eXBle0pzMlB5TGF5b3V0RGVsdGFNc2d9ICovXG4gICAgICAgIHZhciBsYXlvdXREZWx0YU1zZyA9IHtcbiAgICAgICAgICAgIGxheW91dF9kZWx0YTogbGF5b3V0X2RlbHRhLFxuICAgICAgICAgICAgbGF5b3V0X2VkaXRfaWQ6IGxheW91dF9lZGl0X2lkLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vZGVsLnNldChcIl9qczJweV9sYXlvdXREZWx0YVwiLCBsYXlvdXREZWx0YU1zZyk7XG4gICAgICAgIHRoaXMudG91Y2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IHRyYWNlIGRlbHRhcyBhcnJheSBmb3IgdGhlIHJlcXVlc3RlZCB0cmFjZSBpbmRleGVzIGFuZFxuICAgICAqIHNlbmQgdHJhY2VEZWx0YXMgbWVzc2FnZSB0byB0aGUgUHl0aG9uIHNpZGVcbiAgICAgKiAgQXJyYXkgb2YgaW5kZXhlcyBvZiB0cmFjZXMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgZGVsdGFzXG4gICAgICogQHBhcmFtIHRyYWNlX2VkaXRfaWRcbiAgICAgKiAgRWRpdCBJRCBvZiBtZXNzYWdlIHRoYXQgdHJpZ2dlcmVkIHRoZSBjcmVhdGlvbiBvZiB0cmFjZSBkZWx0YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZW5kVHJhY2VEZWx0YXModHJhY2VfZWRpdF9pZCkge1xuICAgICAgICB2YXIgdHJhY2VfZGF0YSA9IHRoaXMubW9kZWwuZ2V0KFwiX2RhdGFcIik7XG4gICAgICAgIHZhciB0cmFjZUluZGV4ZXMgPSBfLnJhbmdlKHRyYWNlX2RhdGEubGVuZ3RoKTtcbiAgICAgICAgdmFyIHRyYWNlX2RlbHRhcyA9IG5ldyBBcnJheSh0cmFjZUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGZ1bGxEYXRhID0gdGhpcy5nZXRGdWxsRGF0YSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNlSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRyYWNlSW5kID0gdHJhY2VJbmRleGVzW2ldO1xuICAgICAgICAgICAgdHJhY2VfZGVsdGFzW2ldID0gY3JlYXRlRGVsdGFPYmplY3QoZnVsbERhdGFbdHJhY2VJbmRdLCB0cmFjZV9kYXRhW3RyYWNlSW5kXSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBle0pzMlB5VHJhY2VEZWx0YXNNc2d9ICovXG4gICAgICAgIHZhciB0cmFjZURlbHRhc01zZyA9IHtcbiAgICAgICAgICAgIHRyYWNlX2RlbHRhczogdHJhY2VfZGVsdGFzLFxuICAgICAgICAgICAgdHJhY2VfZWRpdF9pZDogdHJhY2VfZWRpdF9pZCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJfanMycHlfdHJhY2VEZWx0YXNcIiwgdHJhY2VEZWx0YXNNc2cpO1xuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgfVxufVxuLy8gU2VyaWFsaXphdGlvblxuLyoqXG4gKiBDcmVhdGUgYSBtYXBwaW5nIGZyb20gbnVtcHkgZHR5cGUgc3RyaW5ncyB0byBjb3JyZXNwb25kaW5nIHR5cGVkIGFycmF5XG4gKiBjb25zdHJ1Y3RvcnNcbiAqL1xuY29uc3QgbnVtcHlfZHR5cGVfdG9fdHlwZWRhcnJheV90eXBlID0ge1xuICAgIGludDg6IEludDhBcnJheSxcbiAgICBpbnQxNjogSW50MTZBcnJheSxcbiAgICBpbnQzMjogSW50MzJBcnJheSxcbiAgICB1aW50ODogVWludDhBcnJheSxcbiAgICB1aW50MTY6IFVpbnQxNkFycmF5LFxuICAgIHVpbnQzMjogVWludDMyQXJyYXksXG4gICAgZmxvYXQzMjogRmxvYXQzMkFycmF5LFxuICAgIGZsb2F0NjQ6IEZsb2F0NjRBcnJheSxcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVUeXBlZEFycmF5KHYpIHtcbiAgICB2YXIgbnVtcHlUeXBlO1xuICAgIGlmICh2IGluc3RhbmNlb2YgSW50OEFycmF5KSB7XG4gICAgICAgIG51bXB5VHlwZSA9IFwiaW50OFwiO1xuICAgIH1cbiAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgSW50MTZBcnJheSkge1xuICAgICAgICBudW1weVR5cGUgPSBcImludDE2XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XG4gICAgICAgIG51bXB5VHlwZSA9IFwiaW50MzJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbnVtcHlUeXBlID0gXCJ1aW50OFwiO1xuICAgIH1cbiAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgVWludDE2QXJyYXkpIHtcbiAgICAgICAgbnVtcHlUeXBlID0gXCJ1aW50MTZcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgIG51bXB5VHlwZSA9IFwidWludDMyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgbnVtcHlUeXBlID0gXCJmbG9hdDMyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgICAgbnVtcHlUeXBlID0gXCJmbG9hdDY0XCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEb24ndCB1bmRlcnN0YW5kIGl0LCByZXR1cm4gYXMgaXNcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHZhciByZXMgPSB7XG4gICAgICAgIGR0eXBlOiBudW1weVR5cGUsXG4gICAgICAgIHNoYXBlOiBbdi5sZW5ndGhdLFxuICAgICAgICB2YWx1ZTogdi5idWZmZXIsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBpcHl3aWRnZXQgSmF2YVNjcmlwdCAtPiBQeXRob24gc2VyaWFsaXplclxuICovXG5mdW5jdGlvbiBqczJweV9zZXJpYWxpemVyKHYsIHdpZGdldE1hbmFnZXIpIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChfLmlzVHlwZWRBcnJheSh2KSkge1xuICAgICAgICByZXMgPSBzZXJpYWxpemVUeXBlZEFycmF5KHYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cyByZWN1cnNpdmVseVxuICAgICAgICByZXMgPSBuZXcgQXJyYXkodi5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGpzMnB5X3NlcmlhbGl6ZXIodltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHYpKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgcHJvcGVydGllcyByZWN1cnNpdmVseVxuICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB2KSB7XG4gICAgICAgICAgICBpZiAodi5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgIHJlc1twXSA9IGpzMnB5X3NlcmlhbGl6ZXIodltwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB1bmRlZmluZWQgaW50byAnX3VuZGVmaW5lZF8nIHNlbnRpbmFsIHN0cmluZy4gVGhlXG4gICAgICAgIC8vIFB5dGhvbiBfanNfdG9fcHkgZGVzZXJpYWxpemVyIHdpbGwgY29udmVydCB0aGlzIGludG8gYW5cbiAgICAgICAgLy8gVW5kZWZpbmVkIG9iamVjdFxuICAgICAgICByZXMgPSBcIl91bmRlZmluZWRfXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBQcmltaXRpdmUgdmFsdWUgdG8gdHJhbnNmZXIgZGlyZWN0bHlcbiAgICAgICAgcmVzID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogaXB5d2lkZ2V0IFB5dGhvbiAtPiBKYXZhc2NyaXB0IGRlc2VyaWFsaXplclxuICovXG5mdW5jdGlvbiBweTJqc19kZXNlcmlhbGl6ZXIodiwgd2lkZ2V0TWFuYWdlcikge1xuICAgIHZhciByZXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgLy8gRGVzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMgcmVjdXJzaXZlbHlcbiAgICAgICAgcmVzID0gbmV3IEFycmF5KHYubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBweTJqc19kZXNlcmlhbGl6ZXIodltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHYpKSB7XG4gICAgICAgIGlmICgoXy5oYXModiwgXCJ2YWx1ZVwiKSB8fCBfLmhhcyh2LCBcImJ1ZmZlclwiKSkgJiZcbiAgICAgICAgICAgIF8uaGFzKHYsIFwiZHR5cGVcIikgJiZcbiAgICAgICAgICAgIF8uaGFzKHYsIFwic2hhcGVcIikpIHtcbiAgICAgICAgICAgIC8vIERlc2VyaWFsaXplIHNwZWNpYWwgYnVmZmVyL2R0eXBlL3NoYXBlIG9iamVjdHMgaW50byB0eXBlZCBhcnJheXNcbiAgICAgICAgICAgIC8vIFRoZXNlIG9iamVjdHMgY29ycmVzcG9uZCB0byBudW1weSBhcnJheXMgb24gdGhlIFB5dGhvbiBzaWRlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gTm90ZSBwbG90bHkucHk8PTMuMS4xIGNhbGxlZCB0aGUgYnVmZmVyIG9iamVjdCBgYnVmZmVyYFxuICAgICAgICAgICAgLy8gVGhpcyB3YXMgcmVuYW1lZCBgdmFsdWVgIGluIDMuMiB0byB3b3JrIGFyb3VuZCBhIG5hbWluZyBjb25mbGljdFxuICAgICAgICAgICAgLy8gd2hlbiBzYXZpbmcgd2lkZ2V0IHN0YXRlIHRvIGEgbm90ZWJvb2suXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB2YXIgdHlwZWRhcnJheV90eXBlID0gbnVtcHlfZHR5cGVfdG9fdHlwZWRhcnJheV90eXBlW3YuZHR5cGVdO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IF8uaGFzKHYsIFwidmFsdWVcIikgPyB2LnZhbHVlLmJ1ZmZlciA6IHYuYnVmZmVyLmJ1ZmZlcjtcbiAgICAgICAgICAgIHJlcyA9IG5ldyB0eXBlZGFycmF5X3R5cGUoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlc2VyaWFsaXplIG9iamVjdCBwcm9wZXJ0aWVzIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gdikge1xuICAgICAgICAgICAgICAgIGlmICh2Lmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twXSA9IHB5MmpzX2Rlc2VyaWFsaXplcih2W3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiA9PT0gXCJfdW5kZWZpbmVkX1wiKSB7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIF91bmRlZmluZWRfIHNlbnRpbmFsIGludG8gdW5kZWZpbmVkXG4gICAgICAgIHJlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEFjY2VwdCBwcmltaXRpdmUgdmFsdWUgZGlyZWN0bHlcbiAgICAgICAgcmVzID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgdGhlIGlucHV0IHZhbHVlIGlzIGEgdHlwZWQgYXJyYXlcbiAqIEBwYXJhbSBwb3RlbnRpYWxUeXBlZEFycmF5XG4gKiAgVmFsdWUgdG8gZXhhbWluZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShwb3RlbnRpYWxUeXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIChBcnJheUJ1ZmZlci5pc1ZpZXcocG90ZW50aWFsVHlwZWRBcnJheSkgJiZcbiAgICAgICAgIShwb3RlbnRpYWxUeXBlZEFycmF5IGluc3RhbmNlb2YgRGF0YVZpZXcpKTtcbn1cbi8qKlxuICogQ3VzdG9taXplciBmb3IgdXNlIHdpdGggbG9kYXNoJ3MgbWVyZ2VXaXRoIGZ1bmN0aW9uXG4gKlxuICogVGhlIGN1c3RvbWl6ZXIgZW5zdXJlcyB0aGF0IHR5cGVkIGFycmF5cyBhcmUgbm90IGNvbnZlcnRlZCBpbnRvIHN0YW5kYXJkXG4gKiBhcnJheXMgZHVyaW5nIHRoZSByZWN1cnNpdmUgbWVyZ2VcbiAqXG4gKiBTZWU6IGh0dHBzOi8vbG9kYXNoLmNvbS9kb2NzL2xhdGVzdCNtZXJnZVdpdGhcbiAqL1xuZnVuY3Rpb24gZnVsbE1lcmdlQ3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChrZXlbMF0gPT09IFwiX1wiKSB7XG4gICAgICAgIC8vIERvbid0IHJlY3Vyc2UgaW50byBwcml2YXRlIHByb3BlcnRpZXNcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVHlwZWRBcnJheShzcmNWYWx1ZSkpIHtcbiAgICAgICAgLy8gUmV0dXJuIHR5cGVkIGFycmF5cyBkaXJlY3RseSwgZG9uJ3QgcmVjdXJzZSBpbnNpZGVcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgIH1cbn1cbi8qKlxuICogUmVmb3JtIGEgUGxvdGx5LnJlbGF5b3V0IGxpa2Ugb3BlcmF0aW9uIG9uIGFuIGlucHV0IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRPYmpcbiAqICBUaGUgb2JqZWN0IHRoYXQgdGhlIHJlbGF5b3V0IG9wZXJhdGlvbiBzaG91bGQgYmUgYXBwbGllZCB0b1xuICogQHBhcmFtIHtPYmplY3R9IHJlbGF5b3V0RGF0YVxuICogIEFuIHJlbGF5b3V0IG9iamVjdCBhcyBhY2NlcHRlZCBieSBQbG90bHkucmVsYXlvdXRcbiAqXG4gKiAgRXhhbXBsZXM6XG4gKiAgICAgIHZhciBkID0ge2ZvbyB7YmFyIFs1LCAxMF19fTtcbiAqICAgICAgcGVyZm9ybVJlbGF5b3V0TGlrZShkLCB7J2Zvby5iYXInOiBbMCwgMV19KTtcbiAqICAgICAgZCAtPiB7Zm9vOiB7YmFyOiBbMCwgMV19fVxuICpcbiAqICAgICAgdmFyIGQgPSB7Zm9vIHtiYXIgWzUsIDEwXX19O1xuICogICAgICBwZXJmb3JtUmVsYXlvdXRMaWtlKGQsIHsnYmF6JzogMzR9KTtcbiAqICAgICAgZCAtPiB7Zm9vOiB7YmFyOiBbNSwgMTBdfSwgYmF6OiAzNH1cbiAqXG4gKiAgICAgIHZhciBkID0ge2Zvbzoge2JhcjogWzUsIDEwXX07XG4gKiAgICAgIHBlcmZvcm1SZWxheW91dExpa2UoZCwgeydmb28uYmF6WzFdJzogMTd9KTtcbiAqICAgICAgZCAtPiB7Zm9vOiB7YmFyOiBbNSwgMTddfX1cbiAqXG4gKi9cbmZ1bmN0aW9uIHBlcmZvcm1SZWxheW91dExpa2UocGFyZW50T2JqLCByZWxheW91dERhdGEpIHtcbiAgICAvLyBQZXJmb3JtIGEgcmVsYXlvdXQgc3R5bGUgb3BlcmF0aW9uIG9uIGEgZ2l2ZW4gcGFyZW50IG9iamVjdFxuICAgIGZvciAodmFyIHJhd0tleSBpbiByZWxheW91dERhdGEpIHtcbiAgICAgICAgaWYgKCFyZWxheW91dERhdGEuaGFzT3duUHJvcGVydHkocmF3S2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmFjdCB2YWx1ZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgdmFyIHJlbGF5b3V0VmFsID0gcmVsYXlvdXREYXRhW3Jhd0tleV07XG4gICAgICAgIC8vIFNldCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICBpZiAocmVsYXlvdXRWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIF8udW5zZXQocGFyZW50T2JqLCByYXdLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgXy5zZXQocGFyZW50T2JqLCByYXdLZXksIHJlbGF5b3V0VmFsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUGVyZm9ybSBhIFBsb3RseS5yZXN0eWxlIGxpa2Ugb3BlcmF0aW9uIG9uIGFuIGlucHV0IG9iamVjdCBhcnJheVxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHBhcmVudEFycmF5XG4gKiAgVGhlIG9iamVjdCB0aGF0IHRoZSByZXN0eWxlIG9wZXJhdGlvbiBzaG91bGQgYmUgYXBwbGllZCB0b1xuICogQHBhcmFtIHtPYmplY3R9IHJlc3R5bGVEYXRhXG4gKiAgQSByZXN0eWxlIG9iamVjdCBhcyBhY2NlcHRlZCBieSBQbG90bHkucmVzdHlsZVxuICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gcmVzdHlsZVRyYWNlc1xuICogIEFycmF5IG9mIGluZGV4ZXMgb2YgdGhlIHRyYWNlcyB0aGF0IHRoZSByZXN5dGxlIG9wZXJhdGlvbiBhcHBsaWVzIHRvXG4gKlxuICogIEV4YW1wbGVzOlxuICogICAgICB2YXIgZCA9IFt7Zm9vOiB7YmFyOiAxfX0sIHt9LCB7fV1cbiAqICAgICAgcGVyZm9ybVJlc3R5bGVMaWtlKGQsIHsnZm9vLmJhcic6IDJ9LCBbMF0pXG4gKiAgICAgIGQgLT4gW3tmb286IHtiYXI6IDJ9fSwge30sIHt9XVxuICpcbiAqICAgICAgdmFyIGQgPSBbe2Zvbzoge2JhcjogMX19LCB7fSwge31dXG4gKiAgICAgIHBlcmZvcm1SZXN0eWxlTGlrZShkLCB7J2Zvby5iYXInOiAyfSwgWzAsIDEsIDJdKVxuICogICAgICBkIC0+IFt7Zm9vOiB7YmFyOiAyfX0sIHtmb286IHtiYXI6IDJ9fSwge2Zvbzoge2JhcjogMn19XVxuICpcbiAqICAgICAgdmFyIGQgPSBbe2Zvbzoge2JhcjogMX19LCB7fSwge31dXG4gKiAgICAgIHBlcmZvcm1SZXN0eWxlTGlrZShkLCB7J2Zvby5iYXInOiBbMiwgMywgNF19LCBbMCwgMSwgMl0pXG4gKiAgICAgIGQgLT4gW3tmb286IHtiYXI6IDJ9fSwge2Zvbzoge2JhcjogM319LCB7Zm9vOiB7YmFyOiA0fX1dXG4gKlxuICovXG5mdW5jdGlvbiBwZXJmb3JtUmVzdHlsZUxpa2UocGFyZW50QXJyYXksIHJlc3R5bGVEYXRhLCByZXN0eWxlVHJhY2VzKSB7XG4gICAgLy8gTG9vcCBvdmVyIHRoZSBwcm9wZXJ0aWVzIG9mIHJlc3R5bGVEYXRhXG4gICAgZm9yICh2YXIgcmF3S2V5IGluIHJlc3R5bGVEYXRhKSB7XG4gICAgICAgIGlmICghcmVzdHlsZURhdGEuaGFzT3duUHJvcGVydHkocmF3S2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmFjdCB2YWx1ZSBmb3IgcHJvcGVydHkgYW5kIG5vcm1hbGl6ZSBpbnRvIGEgdmFsdWUgbGlzdFxuICAgICAgICB2YXIgdmFsQXJyYXkgPSByZXN0eWxlRGF0YVtyYXdLZXldO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsQXJyYXkpKSB7XG4gICAgICAgICAgICB2YWxBcnJheSA9IFt2YWxBcnJheV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSBpbmRleGVzIG9mIHRoZSB0cmFjZXMgYmVpbmcgcmVzdHlsZWRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN0eWxlVHJhY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBHZXQgdHJhY2Ugb2JqZWN0XG4gICAgICAgICAgICB2YXIgdHJhY2VJbmQgPSByZXN0eWxlVHJhY2VzW2ldO1xuICAgICAgICAgICAgdmFyIHRyYWNlID0gcGFyZW50QXJyYXlbdHJhY2VJbmRdO1xuICAgICAgICAgICAgLy8gRXh0cmFjdCB2YWx1ZSBmb3IgdGhpcyB0cmFjZVxuICAgICAgICAgICAgdmFyIHNpbmdsZVZhbCA9IHZhbEFycmF5W2kgJSB2YWxBcnJheS5sZW5ndGhdO1xuICAgICAgICAgICAgLy8gU2V0IHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICBpZiAoc2luZ2xlVmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgXy51bnNldCh0cmFjZSwgcmF3S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpbmdsZVZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgXy5zZXQodHJhY2UsIHJhd0tleSwgc2luZ2xlVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUGVyZm9ybSBhIFBsb3RseS5tb3ZlVHJhY2VzIGxpa2Ugb3BlcmF0aW9uIG9uIGFuIGlucHV0IG9iamVjdCBhcnJheVxuICogQHBhcmFtIHBhcmVudEFycmF5XG4gKiAgVGhlIG9iamVjdCB0aGF0IHRoZSBtb3ZlVHJhY2VzIG9wZXJhdGlvbiBzaG91bGQgYmUgYXBwbGllZCB0b1xuICogQHBhcmFtIGN1cnJlbnRJbmRzXG4gKiAgQXJyYXkgb2YgdGhlIGN1cnJlbnQgaW5kZXhlcyBvZiB0cmFjZXMgdG8gYmUgbW92ZWRcbiAqIEBwYXJhbSBuZXdJbmRzXG4gKiAgQXJyYXkgb2YgdGhlIG5ldyBpbmRleGVzIHRoYXQgdHJhY2VzIHNlbGVjdGVkIGJ5IGN1cnJlbnRJbmRzIHNob3VsZCBiZVxuICogIG1vdmVkIHRvLlxuICpcbiAqICBFeGFtcGxlczpcbiAqICAgICAgdmFyIGQgPSBbe2ZvbzogMH0sIHtmb286IDF9LCB7Zm9vOiAyfV1cbiAqICAgICAgcGVyZm9ybU1vdmVUcmFjZXNMaWtlKGQsIFswLCAxXSwgWzIsIDBdKVxuICogICAgICBkIC0+IFt7Zm9vOiAxfSwge2ZvbzogMn0sIHtmb286IDB9XVxuICpcbiAqICAgICAgdmFyIGQgPSBbe2ZvbzogMH0sIHtmb286IDF9LCB7Zm9vOiAyfV1cbiAqICAgICAgcGVyZm9ybU1vdmVUcmFjZXNMaWtlKGQsIFswLCAyXSwgWzEsIDJdKVxuICogICAgICBkIC0+IFt7Zm9vOiAxfSwge2ZvbzogMH0sIHtmb286IDJ9XVxuICovXG5mdW5jdGlvbiBwZXJmb3JtTW92ZVRyYWNlc0xpa2UocGFyZW50QXJyYXksIGN1cnJlbnRJbmRzLCBuZXdJbmRzKSB7XG4gICAgLy8gIyMjIFJlbW92ZSBieSBjdXJyZW50SW5kcyBpbiByZXZlcnNlIG9yZGVyICMjI1xuICAgIHZhciBtb3ZpbmdUcmFjZXNEYXRhID0gW107XG4gICAgZm9yICh2YXIgY2kgPSBjdXJyZW50SW5kcy5sZW5ndGggLSAxOyBjaSA+PSAwOyBjaS0tKSB7XG4gICAgICAgIC8vIEluc2VydCBtb3ZpbmcgcGFyZW50QXJyYXkgYXQgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG4gICAgICAgIG1vdmluZ1RyYWNlc0RhdGEuc3BsaWNlKDAsIDAsIHBhcmVudEFycmF5W2N1cnJlbnRJbmRzW2NpXV0pO1xuICAgICAgICBwYXJlbnRBcnJheS5zcGxpY2UoY3VycmVudEluZHNbY2ldLCAxKTtcbiAgICB9XG4gICAgLy8gIyMjIFNvcnQgbmV3SW5kcyBhbmQgbW92aW5nVHJhY2VzRGF0YSBieSBuZXdJbmRzICMjI1xuICAgIHZhciBuZXdJbmRleFNvcnRlZEFycmF5cyA9IF8obmV3SW5kcylcbiAgICAgICAgLnppcChtb3ZpbmdUcmFjZXNEYXRhKVxuICAgICAgICAuc29ydEJ5KDApXG4gICAgICAgIC51bnppcCgpXG4gICAgICAgIC52YWx1ZSgpO1xuICAgIG5ld0luZHMgPSBuZXdJbmRleFNvcnRlZEFycmF5c1swXTtcbiAgICBtb3ZpbmdUcmFjZXNEYXRhID0gbmV3SW5kZXhTb3J0ZWRBcnJheXNbMV07XG4gICAgLy8gIyMjIEluc2VydCBieSBuZXdJbmRzIGluIGZvcndhcmQgb3JkZXIgIyMjXG4gICAgZm9yICh2YXIgbmkgPSAwOyBuaSA8IG5ld0luZHMubGVuZ3RoOyBuaSsrKSB7XG4gICAgICAgIHBhcmVudEFycmF5LnNwbGljZShuZXdJbmRzW25pXSwgMCwgbW92aW5nVHJhY2VzRGF0YVtuaV0pO1xuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlIG5lc3RlZCBwcm9wZXJ0aWVzIGZyb20gYSBwYXJlbnQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50T2JqXG4gKiAgUGFyZW50IG9iamVjdCBmcm9tIHdoaWNoIHByb3BlcnRpZXMgb3IgbmVzdGVkIHByb3BlcnRpZXMgc2hvdWxkIGJlIHJlbW92ZWRcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxOdW1iZXJ8U3RyaW5nPj59IGtleVBhdGhzXG4gKiAgQXJyYXkgb2Yga2V5IHBhdGhzIGZvciBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQuIEVhY2gga2V5IHBhdGhcbiAqICBpcyBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIG5hbWVzIG9yIGFycmF5IGluZGV4ZXMgdGhhdCByZWZlcmVuY2UgYVxuICogIHByb3BlcnR5IHRvIGJlIHJlbW92ZWRcbiAqXG4gKiAgRXhhbXBsZXM6XG4gKiAgICAgIHZhciBkID0ge2ZvbzogW3tiYXI6IDB9LCB7YmFyOiAxfV0sIGJhejogMzJ9XG4gKiAgICAgIHBlcmZvcm1SZW1vdmVQcm9wcyhkLCBbJ2JheiddKVxuICogICAgICBkIC0+IHtmb286IFt7YmFyOiAwfSwge2JhcjogMX1dfVxuICpcbiAqICAgICAgdmFyIGQgPSB7Zm9vOiBbe2JhcjogMH0sIHtiYXI6IDF9XSwgYmF6OiAzMn1cbiAqICAgICAgcGVyZm9ybVJlbW92ZVByb3BzKGQsIFsnZm9vWzFdLmJhcicsICdiYXonXSlcbiAqICAgICAgZCAtPiB7Zm9vOiBbe2JhcjogMH0sIHt9XX1cbiAqXG4gKi9cbmZ1bmN0aW9uIHBlcmZvcm1SZW1vdmVQcm9wcyhwYXJlbnRPYmosIGtleVBhdGhzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5UGF0aCA9IGtleVBhdGhzW2ldO1xuICAgICAgICBfLnVuc2V0KHBhcmVudE9iaiwga2V5UGF0aCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm4gb2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHByb3BlcnRpZXMgaW4gZnVsbE9iaiB0aGF0IGFyZSBub3RcbiAqIGlkZW50aWNhbCB0byB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIGluIHJlbW92ZU9ialxuICpcbiAqIFByb3BlcnRpZXMgb2YgZnVsbE9iaiBhbmQgcmVtb3ZlT2JqIG1heSBiZSBvYmplY3RzIG9yIGFycmF5cyBvZiBvYmplY3RzXG4gKlxuICogUmV0dXJuZWQgb2JqZWN0IGlzIGEgZGVlcCBjbG9uZSBvZiB0aGUgcHJvcGVydGllcyBvZiB0aGUgaW5wdXQgb2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmdWxsT2JqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVtb3ZlT2JqXG4gKlxuICogIEV4YW1wbGVzOlxuICogICAgICB2YXIgZnVsbEQgPSB7Zm9vOiBbe2JhcjogMH0sIHtiYXI6IDF9XSwgYmF6OiAzMn1cbiAqICAgICAgdmFyIHJlbW92ZUQgPSB7YmF6OiAzMn1cbiAqICAgICAgY3JlYXRlRGVsdGFPYmplY3QoZnVsbEQsIHJlbW92ZUQpXG4gKiAgICAgICAgICAtPiB7Zm9vOiBbe2JhcjogMH0sIHtiYXI6IDF9XX1cbiAqXG4gKiAgICAgIHZhciBmdWxsRCA9IHtmb286IFt7YmFyOiAwfSwge2JhcjogMX1dLCBiYXo6IDMyfVxuICogICAgICB2YXIgcmVtb3ZlRCA9IHtiYXo6IDQ1fVxuICogICAgICBjcmVhdGVEZWx0YU9iamVjdChmdWxsRCwgcmVtb3ZlRClcbiAqICAgICAgICAgIC0+IHtmb286IFt7YmFyOiAwfSwge2JhcjogMX1dLCBiYXo6IDMyfVxuICpcbiAqICAgICAgdmFyIGZ1bGxEID0ge2ZvbzogW3tiYXI6IDB9LCB7YmFyOiAxfV0sIGJhejogMzJ9XG4gKiAgICAgIHZhciByZW1vdmVEID0ge2ZvbzogW3tiYXI6IDB9LCB7YmFyOiAxfV19XG4gKiAgICAgIGNyZWF0ZURlbHRhT2JqZWN0KGZ1bGxELCByZW1vdmVEKVxuICogICAgICAgICAgLT4ge2JhejogMzJ9XG4gKlxuICovXG5mdW5jdGlvbiBjcmVhdGVEZWx0YU9iamVjdChmdWxsT2JqLCByZW1vdmVPYmopIHtcbiAgICAvLyBJbml0aWFsaXplIHJlc3VsdCBhcyBvYmplY3Qgb3IgYXJyYXlcbiAgICB2YXIgcmVzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZ1bGxPYmopKSB7XG4gICAgICAgIHJlcyA9IG5ldyBBcnJheShmdWxsT2JqLmxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMgPSB7fTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSByZW1vdmVPYmogdG8gZW1wdHkgb2JqZWN0IGlmIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAocmVtb3ZlT2JqID09PSBudWxsIHx8IHJlbW92ZU9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbW92ZU9iaiA9IHt9O1xuICAgIH1cbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgb3IgYXJyYXkgaW5kaWNlc1xuICAgIGZvciAodmFyIHAgaW4gZnVsbE9iaikge1xuICAgICAgICBpZiAocFswXSAhPT0gXCJfXCIgJiYgLy8gRG9uJ3QgY29uc2lkZXIgcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBmdWxsT2JqLmhhc093blByb3BlcnR5KHApICYmIC8vIEV4Y2x1ZGUgcGFyZW50IHByb3BlcnRpZXNcbiAgICAgICAgICAgIGZ1bGxPYmpbcF0gIT09IG51bGwgLy8gRXhjbHVkZSBjYXNlcyB3aGVyZSBmdWxsT2JqIGRvZXNuJ3RcbiAgICAgICAgLy8gaGF2ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIG9iamVjdCBlcXVhbGl0eVxuICAgICAgICAgICAgdmFyIHByb3BzX2VxdWFsO1xuICAgICAgICAgICAgcHJvcHNfZXF1YWwgPSBfLmlzRXF1YWwoZnVsbE9ialtwXSwgcmVtb3ZlT2JqW3BdKTtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gcmVjdXJzaXZlIGNvbXBhcmlzb24gaWYgcHJvcHMgYXJlIG5vdCBlcXVhbFxuICAgICAgICAgICAgaWYgKCFwcm9wc19lcXVhbCB8fCBwID09PSBcInVpZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTGV0IHVpZHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IGhhcyBub24tbnVsbCB2YWx1ZSBpbiBmdWxsT2JqIHRoYXQgZG9lc24ndFxuICAgICAgICAgICAgICAgIC8vIG1hdGNoIHRoZSB2YWx1ZSBpbiByZW1vdmVPYmpcbiAgICAgICAgICAgICAgICB2YXIgZnVsbFZhbCA9IGZ1bGxPYmpbcF07XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZU9iai5oYXNPd25Qcm9wZXJ0eShwKSAmJiB0eXBlb2YgZnVsbFZhbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIG92ZXIgb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnVsbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdWxsVmFsLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGZ1bGxWYWxbMF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFuIG9iamVjdCBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1twXSA9IG5ldyBBcnJheShmdWxsVmFsLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdWxsVmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZW1vdmVPYmpbcF0pIHx8IHJlbW92ZU9ialtwXS5sZW5ndGggPD0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW3BdW2ldID0gZnVsbFZhbFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1twXVtpXSA9IGNyZWF0ZURlbHRhT2JqZWN0KGZ1bGxWYWxbaV0sIHJlbW92ZU9ialtwXVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgcHJpbWl0aXZlIGFycmF5IG9yIHR5cGVkIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW3BdID0gZnVsbFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxfb2JqID0gY3JlYXRlRGVsdGFPYmplY3QoZnVsbFZhbCwgcmVtb3ZlT2JqW3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhmdWxsX29iaikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBvYmplY3QgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW3BdID0gZnVsbF9vYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZ1bGxWYWwgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZnVsbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuICdjbG9uZScgb2YgZnVsbFZhbFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgYSBzdGFuZGFyZCBjbG9uZSBtZXRob2Qgc28gdGhhdCB3ZSBrZWVwXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzcGVjaWFsIGNhc2UgaGFuZGxpbmcgb2YgdGhpcyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgcmVzW3BdID0gY3JlYXRlRGVsdGFPYmplY3QoZnVsbFZhbCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmdWxsVmFsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZ1bGxWYWwgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyByZWN1cnNpb24gbmVjZXNzYXJ5LCBKdXN0IGtlZXAgdmFsdWUgZnJvbSBmdWxsT2JqLlxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgc2tpcCB2YWx1ZXMgd2l0aCBmdW5jdGlvbiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHJlc1twXSA9IGZ1bGxWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiByYW5kc3RyKGV4aXN0aW5nLCBiaXRzLCBiYXNlLCBfcmVjdXJzaW9uKSB7XG4gICAgaWYgKCFiYXNlKVxuICAgICAgICBiYXNlID0gMTY7XG4gICAgaWYgKGJpdHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgYml0cyA9IDI0O1xuICAgIGlmIChiaXRzIDw9IDApXG4gICAgICAgIHJldHVybiBcIjBcIjtcbiAgICB2YXIgZGlnaXRzID0gTWF0aC5sb2coTWF0aC5wb3coMiwgYml0cykpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgdmFyIHJlcyA9IFwiXCI7XG4gICAgdmFyIGksIGIsIHg7XG4gICAgZm9yIChpID0gMjsgZGlnaXRzID09PSBJbmZpbml0eTsgaSAqPSAyKSB7XG4gICAgICAgIGRpZ2l0cyA9IChNYXRoLmxvZyhNYXRoLnBvdygyLCBiaXRzIC8gaSkpIC8gTWF0aC5sb2coYmFzZSkpICogaTtcbiAgICB9XG4gICAgdmFyIHJlbSA9IGRpZ2l0cyAtIE1hdGguZmxvb3IoZGlnaXRzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgTWF0aC5mbG9vcihkaWdpdHMpOyBpKyspIHtcbiAgICAgICAgeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICByZXMgPSB4ICsgcmVzO1xuICAgIH1cbiAgICBpZiAocmVtKSB7XG4gICAgICAgIGIgPSBNYXRoLnBvdyhiYXNlLCByZW0pO1xuICAgICAgICB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYikudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIHJlcyA9IHggKyByZXM7XG4gICAgfVxuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChyZXMsIGJhc2UpO1xuICAgIGlmICgoZXhpc3RpbmcgJiYgZXhpc3RpbmdbcmVzXSkgfHxcbiAgICAgICAgKHBhcnNlZCAhPT0gSW5maW5pdHkgJiYgcGFyc2VkID49IE1hdGgucG93KDIsIGJpdHMpKSkge1xuICAgICAgICBpZiAoX3JlY3Vyc2lvbiA+IDEwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJyYW5kc3RyIGZhaWxlZCB1bmlxdWVuZXNzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZHN0cihleGlzdGluZywgYml0cywgYmFzZSwgKF9yZWN1cnNpb24gfHwgMCkgKyAxKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gcmVzO1xufVxuIiwiLy8gRXhwb3J0IHdpZGdldCBtb2RlbHMgYW5kIHZpZXdzLCBhbmQgdGhlIG5wbSBwYWNrYWdlIHZlcnNpb24gbnVtYmVyLlxuZXhwb3J0ICogZnJvbSAnLi9GaWd1cmUnO1xuZXhwb3J0ICogZnJvbSAnLi92ZXJzaW9uJztcbiJdLCJzb3VyY2VSb290IjoiIn0=