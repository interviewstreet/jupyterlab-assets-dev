(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_vega_build_vega_module_js"],{

/***/ "../../node_modules/d3-array/src/ascending.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-array/src/ascending.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/bisect.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-array/src/bisect.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bisectRight": () => (/* binding */ bisectRight),
/* harmony export */   "bisectLeft": () => (/* binding */ bisectLeft),
/* harmony export */   "bisectCenter": () => (/* binding */ bisectCenter),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "../../node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisector.js */ "../../node_modules/d3-array/src/bisector.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-array/src/number.js");




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__.default)(_ascending_js__WEBPACK_IMPORTED_MODULE_1__.default);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__.default)(_number_js__WEBPACK_IMPORTED_MODULE_2__.default).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "../../node_modules/d3-array/src/bisector.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-array/src/bisector.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "../../node_modules/d3-array/src/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(f) {
  let delta = f;
  let compare = f;

  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function ascendingComparator(f) {
  return (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__.default)(f(d), x);
}


/***/ }),

/***/ "../../node_modules/d3-array/src/deviation.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-array/src/deviation.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ deviation)
/* harmony export */ });
/* harmony import */ var _variance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance.js */ "../../node_modules/d3-array/src/variance.js");


function deviation(values, valueof) {
  const v = (0,_variance_js__WEBPACK_IMPORTED_MODULE_0__.default)(values, valueof);
  return v ? Math.sqrt(v) : v;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/fsum.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-array/src/fsum.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Adder": () => (/* binding */ Adder),
/* harmony export */   "fsum": () => (/* binding */ fsum),
/* harmony export */   "fcumsum": () => (/* binding */ fcumsum)
/* harmony export */ });
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ "../../node_modules/d3-array/src/max.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-array/src/max.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/mean.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-array/src/mean.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mean)
/* harmony export */ });
function mean(values, valueof) {
  let count = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  }
  if (count) return sum / count;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/median.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-array/src/median.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quantile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quantile.js */ "../../node_modules/d3-array/src/quantile.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  return (0,_quantile_js__WEBPACK_IMPORTED_MODULE_0__.default)(values, 0.5, valueof);
}


/***/ }),

/***/ "../../node_modules/d3-array/src/merge.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-array/src/merge.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ merge)
/* harmony export */ });
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ "../../node_modules/d3-array/src/min.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-array/src/min.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/number.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-array/src/number.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "numbers": () => (/* binding */ numbers)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ "../../node_modules/d3-array/src/permute.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-array/src/permute.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ "../../node_modules/d3-array/src/quantile.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-array/src/quantile.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile),
/* harmony export */   "quantileSorted": () => (/* binding */ quantileSorted)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max.js */ "../../node_modules/d3-array/src/max.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./min.js */ "../../node_modules/d3-array/src/min.js");
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quickselect.js */ "../../node_modules/d3-array/src/quickselect.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-array/src/number.js");





function quantile(values, p, valueof) {
  values = Float64Array.from((0,_number_js__WEBPACK_IMPORTED_MODULE_0__.numbers)(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return (0,_min_js__WEBPACK_IMPORTED_MODULE_1__.default)(values);
  if (p >= 1) return (0,_max_js__WEBPACK_IMPORTED_MODULE_2__.default)(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0,_max_js__WEBPACK_IMPORTED_MODULE_2__.default)((0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__.default)(values, i0).subarray(0, i0 + 1)),
      value1 = (0,_min_js__WEBPACK_IMPORTED_MODULE_1__.default)(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__.default) {
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}


/***/ }),

/***/ "../../node_modules/d3-array/src/quickselect.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-array/src/quickselect.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "../../node_modules/d3-array/src/ascending.js");


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = array.length - 1, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__.default) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/range.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-array/src/range.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/sum.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-array/src/sum.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sum)
/* harmony export */ });
function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/ticks.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-array/src/ticks.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "tickIncrement": () => (/* binding */ tickIncrement),
/* harmony export */   "tickStep": () => (/* binding */ tickStep)
/* harmony export */ });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),

/***/ "../../node_modules/d3-array/src/variance.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-array/src/variance.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ variance)
/* harmony export */ });
function variance(values, valueof) {
  let count = 0;
  let delta;
  let mean = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  }
  if (count > 1) return sum / (count - 1);
}


/***/ }),

/***/ "../../node_modules/d3-color/src/color.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-color/src/color.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "darker": () => (/* binding */ darker),
/* harmony export */   "brighter": () => (/* binding */ brighter),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   "rgbConvert": () => (/* binding */ rgbConvert),
/* harmony export */   "rgb": () => (/* binding */ rgb),
/* harmony export */   "Rgb": () => (/* binding */ Rgb),
/* harmony export */   "hslConvert": () => (/* binding */ hslConvert),
/* harmony export */   "hsl": () => (/* binding */ hsl)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "../../node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__.default)(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__.default)(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__.default)(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "../../node_modules/d3-color/src/cubehelix.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-color/src/cubehelix.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cubehelix),
/* harmony export */   "Cubehelix": () => (/* binding */ Cubehelix)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./define.js */ "../../node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_2__.default)(Cubehelix, cubehelix, (0,_define_js__WEBPACK_IMPORTED_MODULE_2__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_0__.brighter : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_0__.brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_0__.darker : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_0__.darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "../../node_modules/d3-color/src/define.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-color/src/define.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "extend": () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "../../node_modules/d3-color/src/lab.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-color/src/lab.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gray": () => (/* binding */ gray),
/* harmony export */   "default": () => (/* binding */ lab),
/* harmony export */   "Lab": () => (/* binding */ Lab),
/* harmony export */   "lch": () => (/* binding */ lch),
/* harmony export */   "hcl": () => (/* binding */ hcl),
/* harmony export */   "Hcl": () => (/* binding */ Hcl)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./define.js */ "../../node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__.default)(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__.default)(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "../../node_modules/d3-color/src/math.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-color/src/math.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "radians": () => (/* binding */ radians),
/* harmony export */   "degrees": () => (/* binding */ degrees)
/* harmony export */ });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "../../node_modules/d3-delaunay/src/delaunay.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-delaunay/src/delaunay.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Delaunay)
/* harmony export */ });
/* harmony import */ var delaunator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! delaunator */ "../../node_modules/delaunator/index.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "../../node_modules/d3-delaunay/src/path.js");
/* harmony import */ var _polygon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polygon.js */ "../../node_modules/d3-delaunay/src/polygon.js");
/* harmony import */ var _voronoi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./voronoi.js */ "../../node_modules/d3-delaunay/src/voronoi.js");





const tau = 2 * Math.PI, pow = Math.pow;

function pointX(p) {
  return p[0];
}

function pointY(p) {
  return p[1];
}

// A triangulation is collinear if all its triangles have a non-null area
function collinear(d) {
  const {triangles, coords} = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a = 2 * triangles[i],
          b = 2 * triangles[i + 1],
          c = 2 * triangles[i + 2],
          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
    if (cross > 1e-10) return false;
  }
  return true;
}

function jitter(x, y, r) {
  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
}

class Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new Delaunay("length" in points
        ? flatArray(points, fx, fy, that)
        : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new delaunator__WEBPACK_IMPORTED_MODULE_0__.default(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;

    // check for collinear
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }
      this._delaunator = new delaunator__WEBPACK_IMPORTED_MODULE_0__.default(points);
    } else {
      delete this.collinear;
    }

    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);

    // Compute an index from each point to an (arbitrary) incoming halfedge
    // Used to give the first neighbor of each point; for this reason,
    // on the hull we give priority to exterior halfedges
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }

    // degenerate case: 1 or 2 (distinct) points
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      this.triangles[1] = hull[1];
      this.triangles[2] = hull[1];
      inedges[hull[0]] = 1;
      if (hull.length === 2) inedges[hull[1]] = 0;
    }
  }
  voronoi(bounds) {
    return new _voronoi_js__WEBPACK_IMPORTED_MODULE_1__.default(this, bounds);
  }
  *neighbors(i) {
    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

    // degenerate case with several collinear points
    if (collinear) {
      const l = collinear.indexOf(i);
      if (l > 0) yield collinear[l - 1];
      if (l < collinear.length - 1) yield collinear[l + 1];
      return;
    }

    const e0 = inedges[i];
    if (e0 === -1) return; // coincident point
    let e = e0, p0 = -1;
    do {
      yield p0 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) return; // bad triangulation
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p0) yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x, y, i = 0) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
    const i0 = i;
    let c;
    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
    return c;
  }
  _step(i, x, y) {
    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c = i;
    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c;
  }
  render(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {points, halfedges, triangles} = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r = 2) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {points} = this;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x = points[i], y = points[i + 1];
      context.moveTo(x + r, y);
      context.arc(x, y, r, 0, tau);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {hull, points} = this;
    const h = hull[0] * 2, n = hull.length;
    context.moveTo(points[h], points[h + 1]);
    for (let i = 1; i < n; ++i) {
      const h = 2 * hull[i];
      context.lineTo(points[h], points[h + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new _polygon_js__WEBPACK_IMPORTED_MODULE_3__.default;
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {points, triangles} = this;
    const t0 = triangles[i *= 3] * 2;
    const t1 = triangles[i + 1] * 2;
    const t2 = triangles[i + 2] * 2;
    context.moveTo(points[t0], points[t0 + 1]);
    context.lineTo(points[t1], points[t1 + 1]);
    context.lineTo(points[t2], points[t2 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const {triangles} = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new _polygon_js__WEBPACK_IMPORTED_MODULE_3__.default;
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
}

function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array[i * 2] = fx.call(that, p, i, points);
    array[i * 2 + 1] = fy.call(that, p, i, points);
  }
  return array;
}

function* flatIterable(points, fx, fy, that) {
  let i = 0;
  for (const p of points) {
    yield fx.call(that, p, i, points);
    yield fy.call(that, p, i, points);
    ++i;
  }
}


/***/ }),

/***/ "../../node_modules/d3-delaunay/src/path.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-delaunay/src/path.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Path)
/* harmony export */ });
const epsilon = 1e-6;

class Path {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }
  moveTo(x, y) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x, y) {
    this._ += `L${this._x1 = +x},${this._y1 = +y}`;
  }
  arc(x, y, r) {
    x = +x, y = +y, r = +r;
    const x0 = x + r;
    const y0 = y;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x0},${y0}`;
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += "L" + x0 + "," + y0;
    if (!r) return;
    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
  }
  rect(x, y, w, h) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
  }
  value() {
    return this._ || null;
  }
}


/***/ }),

/***/ "../../node_modules/d3-delaunay/src/polygon.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-delaunay/src/polygon.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Polygon)
/* harmony export */ });
class Polygon {
  constructor() {
    this._ = [];
  }
  moveTo(x, y) {
    this._.push([x, y]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x, y) {
    this._.push([x, y]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}


/***/ }),

/***/ "../../node_modules/d3-delaunay/src/voronoi.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-delaunay/src/voronoi.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Voronoi)
/* harmony export */ });
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.js */ "../../node_modules/d3-delaunay/src/path.js");
/* harmony import */ var _polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polygon.js */ "../../node_modules/d3-delaunay/src/polygon.js");



class Voronoi {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const {delaunay: {points, hull, triangles}, vectors} = this;

    // Compute circumcenters.
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
      const t1 = triangles[i] * 2;
      const t2 = triangles[i + 1] * 2;
      const t3 = triangles[i + 2] * 2;
      const x1 = points[t1];
      const y1 = points[t1 + 1];
      const x2 = points[t2];
      const y2 = points[t2 + 1];
      const x3 = points[t3];
      const y3 = points[t3 + 1];

      const dx = x2 - x1;
      const dy = y2 - y1;
      const ex = x3 - x1;
      const ey = y3 - y1;
      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const ab = (dx * ey - dy * ex) * 2;

      if (!ab) {
        // degenerate case (collinear diagram)
        x = (x1 + x3) / 2 - 1e8 * ey;
        y = (y1 + y3) / 2 + 1e8 * ex;
      }
      else if (Math.abs(ab) < 1e-8) {
        // almost equal points (degenerate triangle)
        x = (x1 + x3) / 2;
        y = (y1 + y3) / 2;
      } else {
        const d = 1 / ab;
        x = x1 + (ey * bl - dy * cl) * d;
        y = y1 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j] = x;
      circumcenters[j + 1] = y;
    }

    // Compute exterior cell rays.
    let h = hull[hull.length - 1];
    let p0, p1 = h * 4;
    let x0, x1 = points[2 * h];
    let y0, y1 = points[2 * h + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }
  render(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_0__.default : undefined;
    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x = circumcenters[t];
      const y = circumcenters[t + 1];
      const v = h0 * 4;
      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
      if (p) this._renderSegment(x, y, p[0], p[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_0__.default : undefined;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_0__.default : undefined;
    const points = this._clip(i);
    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n = points.length;
    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
    for (let i = 2; i < n; i += 2) {
      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
        context.lineTo(points[i], points[i + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const {delaunay: {points}} = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) cell.index = i, yield cell;
    }
  }
  cellPolygon(i) {
    const polygon = new _polygon_js__WEBPACK_IMPORTED_MODULE_1__.default;
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x0, y0, x1, y1, context) {
    let S;
    const c0 = this._regioncode(x0, y0);
    const c1 = this._regioncode(x1, y1);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  }
  contains(i, x, y) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
    return this.delaunay._step(i, x, y) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j);
      // find the common edge
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] == cj[aj]
          && ci[ai + 1] == cj[aj + 1]
          && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
          && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
          ) {
            yield j;
            break loop;
          }
        }
      }
    }
  }
  _cell(i) {
    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
    const e0 = inedges[i];
    if (e0 === -1) return null; // coincident point
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i) {
    // degenerate case (1 valid point: return the box)
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i);
    if (points === null) return null;
    const {vectors: V} = this;
    const v = i * 4;
    return V[v] || V[v + 1]
        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
        : this._clipFinite(i, points);
  }
  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
    let c0, c1 = this._regioncode(x1, y1);
    let e0, e1;
    for (let j = 0; j < n; j += 2) {
      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x1, y1);
        else P = [x1, y1];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x0, y0, x1, y1, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
      if (c0 & c1) return null;
      let x, y, c = c0 || c1;
      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
    }
  }
  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x, y;
      switch (e0) {
        case 0b0101: e0 = 0b0100; continue; // top-left
        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
        case 0b0110: e0 = 0b0010; continue; // top-right
        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
        case 0b1010: e0 = 0b1000; continue; // bottom-right
        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
        case 0b1001: e0 = 0b0001; continue; // bottom-left
        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
      }
      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
        P.splice(j, 0, x, y), j += 2;
      }
    }
    if (P.length > 4) {
      for (let i = 0; i < P.length; i+= 2) {
        const j = (i + 2) % P.length, k = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k]
        || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
          P.splice(j, 2), i -= 2;
      }
    }
    return j;
  }
  _project(x0, y0, vx, vy) {
    let t = Infinity, c, x, y;
    if (vy < 0) { // top
      if (y0 <= this.ymin) return null;
      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
    } else if (vy > 0) { // bottom
      if (y0 >= this.ymax) return null;
      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
    }
    if (vx > 0) { // right
      if (x0 >= this.xmax) return null;
      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
    } else if (vx < 0) { // left
      if (x0 <= this.xmin) return null;
      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
    }
    return [x, y];
  }
  _edgecode(x, y) {
    return (x === this.xmin ? 0b0001
        : x === this.xmax ? 0b0010 : 0b0000)
        | (y === this.ymin ? 0b0100
        : y === this.ymax ? 0b1000 : 0b0000);
  }
  _regioncode(x, y) {
    return (x < this.xmin ? 0b0001
        : x > this.xmax ? 0b0010 : 0b0000)
        | (y < this.ymin ? 0b0100
        : y > this.ymax ? 0b1000 : 0b0000);
  }
}


/***/ }),

/***/ "../../node_modules/d3-dispatch/src/dispatch.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-dispatch/src/dispatch.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "../../node_modules/d3-dsv/src/dsv.js":
/*!********************************************!*\
  !*** ../../node_modules/d3-dsv/src/dsv.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "../../node_modules/d3-force/src/center.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-force/src/center.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var nodes, strength = 1;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/d3-force/src/collide.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-force/src/collide.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "../../node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jiggle.js */ "../../node_modules/d3-force/src/jiggle.js");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__.default)(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__.default)(random), l += x * x;
            if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__.default)(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/d3-force/src/constant.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-force/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/d3-force/src/jiggle.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-force/src/jiggle.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "../../node_modules/d3-force/src/lcg.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-force/src/lcg.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "../../node_modules/d3-force/src/link.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-force/src/link.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jiggle.js */ "../../node_modules/d3-force/src/jiggle.js");



function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(30),
      distances,
      nodes,
      count,
      bias,
      random,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__.default)(random);
        y = target.y + target.vy - source.y - source.vy || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__.default)(random);
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initializeDistance(), force) : distance;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/d3-force/src/manyBody.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-force/src/manyBody.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "../../node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jiggle.js */ "../../node_modules/d3-force/src/jiggle.js");
/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./simulation.js */ "../../node_modules/d3-force/src/simulation.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes,
      node,
      random,
      alpha,
      strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__.default)(nodes, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.x, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.y).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += x * x;
        if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += x * x;
      if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/d3-force/src/simulation.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-force/src/simulation.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ x),
/* harmony export */   "y": () => (/* binding */ y),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "../../node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "../../node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "../../node_modules/d3-force/src/lcg.js");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__.default)("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__.default)();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "../../node_modules/d3-force/src/x.js":
/*!********************************************!*\
  !*** ../../node_modules/d3-force/src/x.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/d3-force/src/y.js":
/*!********************************************!*\
  !*** ../../node_modules/d3-force/src/y.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "../../node_modules/d3-format/src/defaultLocale.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-format/src/defaultLocale.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "formatPrefix": () => (/* binding */ formatPrefix),
/* harmony export */   "default": () => (/* binding */ defaultLocale)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "../../node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__.default)(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "../../node_modules/d3-format/src/exponent.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-format/src/exponent.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "../../node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatDecimal.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-format/src/formatDecimal.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "formatDecimalParts": () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatGroup.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-format/src/formatGroup.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatNumerals.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-format/src/formatNumerals.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatPrefixAuto.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-format/src/formatPrefixAuto.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prefixExponent": () => (/* binding */ prefixExponent),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "../../node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatRounded.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-format/src/formatRounded.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "../../node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatSpecifier.js":
/*!***********************************************************!*\
  !*** ../../node_modules/d3-format/src/formatSpecifier.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatSpecifier),
/* harmony export */   "FormatSpecifier": () => (/* binding */ FormatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "../../node_modules/d3-format/src/formatTrim.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-format/src/formatTrim.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "../../node_modules/d3-format/src/formatTypes.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-format/src/formatTypes.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "../../node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "../../node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "../../node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.default,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__.default)(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__.default,
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__.default,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "../../node_modules/d3-format/src/identity.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-format/src/identity.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "../../node_modules/d3-format/src/locale.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-format/src/locale.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "../../node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "../../node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "../../node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "../../node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "../../node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "../../node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "../../node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "../../node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__.default : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__.default)(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__.default : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__.default)(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__.default)(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__.default[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__.default[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__.default)(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__.default)(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__.default)(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "../../node_modules/d3-format/src/precisionFixed.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-format/src/precisionFixed.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "../../node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step) {
  return Math.max(0, -(0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(Math.abs(step)));
}


/***/ }),

/***/ "../../node_modules/d3-format/src/precisionPrefix.js":
/*!***********************************************************!*\
  !*** ../../node_modules/d3-format/src/precisionPrefix.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "../../node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(value) / 3))) * 3 - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(Math.abs(step)));
}


/***/ }),

/***/ "../../node_modules/d3-format/src/precisionRound.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-format/src/precisionRound.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "../../node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(max) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(step)) + 1;
}


/***/ }),

/***/ "../../node_modules/d3-geo-projection/src/math.js":
/*!********************************************************!*\
  !*** ../../node_modules/d3-geo-projection/src/math.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "atan": () => (/* binding */ atan),
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "exp": () => (/* binding */ exp),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "pow": () => (/* binding */ pow),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "sign": () => (/* binding */ sign),
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "tan": () => (/* binding */ tan),
/* harmony export */   "epsilon": () => (/* binding */ epsilon),
/* harmony export */   "epsilon2": () => (/* binding */ epsilon2),
/* harmony export */   "pi": () => (/* binding */ pi),
/* harmony export */   "halfPi": () => (/* binding */ halfPi),
/* harmony export */   "quarterPi": () => (/* binding */ quarterPi),
/* harmony export */   "sqrt1_2": () => (/* binding */ sqrt1_2),
/* harmony export */   "sqrt2": () => (/* binding */ sqrt2),
/* harmony export */   "sqrtPi": () => (/* binding */ sqrtPi),
/* harmony export */   "tau": () => (/* binding */ tau),
/* harmony export */   "degrees": () => (/* binding */ degrees),
/* harmony export */   "radians": () => (/* binding */ radians),
/* harmony export */   "sinci": () => (/* binding */ sinci),
/* harmony export */   "asin": () => (/* binding */ asin),
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "tanh": () => (/* binding */ tanh),
/* harmony export */   "sinh": () => (/* binding */ sinh),
/* harmony export */   "cosh": () => (/* binding */ cosh),
/* harmony export */   "arsinh": () => (/* binding */ arsinh),
/* harmony export */   "arcosh": () => (/* binding */ arcosh)
/* harmony export */ });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sin = Math.sin;
var tan = Math.tan;

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;

function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}

function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}

function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}

function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}

function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}

function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}


/***/ }),

/***/ "../../node_modules/d3-geo-projection/src/mollweide.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-geo-projection/src/mollweide.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mollweideBromleyTheta": () => (/* binding */ mollweideBromleyTheta),
/* harmony export */   "mollweideBromleyRaw": () => (/* binding */ mollweideBromleyRaw),
/* harmony export */   "mollweideRaw": () => (/* binding */ mollweideRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo-projection/src/math.js");



function mollweideBromleyTheta(cp, phi) {
  var cpsinPhi = cp * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi), i = 30, delta;
  do phi -= delta = (phi + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi) - cpsinPhi) / (1 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi));
  while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && --i > 0);
  return phi / 2;
}

function mollweideBromleyRaw(cx, cy, cp) {

  function forward(lambda, phi) {
    return [cx * lambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi = mollweideBromleyTheta(cp, phi)), cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
  }

  forward.invert = function(x, y) {
    return y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(y / cy), [x / (cx * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y)), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((2 * y + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(2 * y)) / cp)];
  };

  return forward;
}

var mollweideRaw = mollweideBromleyRaw(_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt2 / _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi, _math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt2, _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__.default)(mollweideRaw)
      .scale(169.529);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/area.js":
/*!*********************************************!*\
  !*** ../../node_modules/d3-geo/src/area.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areaRingSum": () => (/* binding */ areaRingSum),
/* harmony export */   "areaStream": () => (/* binding */ areaStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noop.js */ "../../node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "../../node_modules/d3-geo/src/stream.js");





var areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();

// hello?

var areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  polygonStart: function() {
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_2__.tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__.default;
  },
  sphere: function() {
    areaSum.add(_math_js__WEBPACK_IMPORTED_MODULE_2__.tau);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  lambda0 = lambda, cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.cos)(phi = phi / 2 + _math_js__WEBPACK_IMPORTED_MODULE_2__.quarterPi), sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sin)(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  phi = phi / 2 + _math_js__WEBPACK_IMPORTED_MODULE_2__.quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.cos)(phi),
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sin)(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.cos)(adLambda),
      v = k * sdLambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sin)(adLambda);
  areaRingSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.atan2)(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_3__.default)(object, areaStream);
  return areaSum * 2;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/bounds.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-geo/src/bounds.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "../../node_modules/d3-geo/src/area.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stream.js */ "../../node_modules/d3-geo/src/stream.js");






var lambda0, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    lambda00, phi00, // first point
    p0, // previous 3D point
    deltaSum,
    ranges,
    range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.polygonStart();
  },
  polygonEnd: function() {
    _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area_js__WEBPACK_IMPORTED_MODULE_1__.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon) phi1 = 90;
    else if (deltaSum < -_math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  },
  sphere: function() {
    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)([lambda * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians, phi * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians]);
  if (p0) {
    var normal = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(equatorial, normal);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianNormalizeInPlace)(inflection);
    inflection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees * sign,
        phii,
        antimeridian = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(delta) > 180;
    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }
  _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);
  _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.lineEnd();
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(deltaSum) > _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_4__.default)(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0, phi0], [lambda1, phi1]];
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/cartesian.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/cartesian.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "spherical": () => (/* binding */ spherical),
/* harmony export */   "cartesian": () => (/* binding */ cartesian),
/* harmony export */   "cartesianDot": () => (/* binding */ cartesianDot),
/* harmony export */   "cartesianCross": () => (/* binding */ cartesianCross),
/* harmony export */   "cartesianAddInPlace": () => (/* binding */ cartesianAddInPlace),
/* harmony export */   "cartesianScale": () => (/* binding */ cartesianScale),
/* harmony export */   "cartesianNormalizeInPlace": () => (/* binding */ cartesianNormalizeInPlace)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");


function spherical(cartesian) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  return [cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/centroid.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-geo/src/centroid.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop.js */ "../../node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "../../node_modules/d3-geo/src/stream.js");





var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00, phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  centroidPointCartesian(cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(cx, cy, cz),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 = 0;
  X2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Y2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Z2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_3__.default)(object, centroidStream);

  var x = +X2,
      y = +Y2,
      z = +Z2,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) x = X0, y = Y0, z = Z0;
    m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);
    // If the feature still has an undefined ccentroid, then return.
    if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) return [NaN, NaN];
  }

  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / m) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/circle.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-geo/src/circle.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "circleStream": () => (/* binding */ circleStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation.js */ "../../node_modules/d3-geo/src/rotation.js");





// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      sinRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.spherical)([cosRadius, -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(t), -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point), point[0] -= cosRadius;
  (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(point);
  var radius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var center = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)([0, 0]),
      radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(90),
      precision = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, x[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
        p = precision.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians;
    ring = [];
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_3__.rotateRadians)(-c[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, -c[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(+_), circle) : precision;
  };

  return circle;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/antimeridian.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/antimeridian.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_index_js__WEBPACK_IMPORTED_MODULE_0__.default)(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
          delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - lambda0);
      if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) { // line crosses antimeridian
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; // handle degeneracies
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0 - lambda1);
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan)(((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0) * (cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda1)
          - (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1) * (cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi;
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(0, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
  } else if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(from[0] - to[0]) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
    var lambda = from[0] < to[0] ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/buffer.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/buffer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/circle.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/circle.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle.js */ "../../node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointEqual.js */ "../../node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/clip/index.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var cr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      delta = 6 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
      smallRadius = cr > 0,
      notHemisphere = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(cr) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.default)(point0, point2) || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.default)(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !(0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.default)(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(a),
        pb = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(pa, pb),
        n2n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(n1, n2),
        A = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n1, c1),
        B = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n2, c2);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, u),
        uu = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(u, u),
        t2 = w * w - uu * ((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, A) - 1);

    if (t2 < 0) return;

    var t = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(t2),
        q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w - t) / uu);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q, A);
    q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon,
        meridian = polar || delta < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(q[0] - lambda0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w + t) / uu);
      (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q1, A);
      return [q, (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : _math_js__WEBPACK_IMPORTED_MODULE_0__.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return (0,_index_js__WEBPACK_IMPORTED_MODULE_4__.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math_js__WEBPACK_IMPORTED_MODULE_0__.pi, radius - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "../../node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "../../node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../polygonContains.js */ "../../node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/merge.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_0__.default)(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(segments);
        var startInside = (0,_polygonContains_js__WEBPACK_IMPORTED_MODULE_2__.default)(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__.default)(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - b[1]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/line.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/line.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/rectangle.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/rectangle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "../../node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "../../node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "../../node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/merge.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__.default)(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__.default)(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__.default)(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/clip/rejoin.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/clip/rejoin.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "../../node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__.default)(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/compose.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-geo/src/compose.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/constant.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-geo/src/constant.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/graticule.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/graticule.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graticule),
/* harmony export */   "graticule10": () => (/* binding */ graticule10)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(y0, y1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(x0, x1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(X0 / DX) * DX, X1, DX).map(X)
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(x0 / dx) * dx, x1, dx).filter(function(x) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(x % DX) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(x))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(y0 / dy) * dy, y1, dy).filter(function(y) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(y % DY) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 90 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]])
      .extentMinor([[-180, -80 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 80 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]]);
}

function graticule10() {
  return graticule()();
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/identity.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-geo/src/identity.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => x);


/***/ }),

/***/ "../../node_modules/d3-geo/src/math.js":
/*!*********************************************!*\
  !*** ../../node_modules/d3-geo/src/math.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "epsilon": () => (/* binding */ epsilon),
/* harmony export */   "epsilon2": () => (/* binding */ epsilon2),
/* harmony export */   "pi": () => (/* binding */ pi),
/* harmony export */   "halfPi": () => (/* binding */ halfPi),
/* harmony export */   "quarterPi": () => (/* binding */ quarterPi),
/* harmony export */   "tau": () => (/* binding */ tau),
/* harmony export */   "degrees": () => (/* binding */ degrees),
/* harmony export */   "radians": () => (/* binding */ radians),
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "atan": () => (/* binding */ atan),
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "exp": () => (/* binding */ exp),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "hypot": () => (/* binding */ hypot),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "pow": () => (/* binding */ pow),
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "sign": () => (/* binding */ sign),
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "tan": () => (/* binding */ tan),
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "asin": () => (/* binding */ asin),
/* harmony export */   "haversin": () => (/* binding */ haversin)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var hypot = Math.hypot;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/noop.js":
/*!*********************************************!*\
  !*** ../../node_modules/d3-geo/src/noop.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/area.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/area.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");




var areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    x00,
    y00,
    x0,
    y0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__.default;
    areaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(areaRingSum));
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (areaStream);


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/bounds.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/bounds.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/centroid.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/centroid.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");


// TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;

var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
        : Z1 ? [X1 / Z1, Y1 / Z1]
        : Z0 ? [X0 / Z0, Y0 / Z0]
        : [NaN, NaN];
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 =
    X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0, dy = y - y0, z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);

  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;

  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (centroidStream);


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/context.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/context.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathContext)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
        break;
      }
    }
  },
  result: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default
};


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../identity.js */ "../../node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "../../node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "../../node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds.js */ "../../node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid.js */ "../../node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./context.js */ "../../node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./measure.js */ "../../node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "../../node_modules/d3-geo/src/path/string.js");









/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_area_js__WEBPACK_IMPORTED_MODULE_1__.default));
    return _area_js__WEBPACK_IMPORTED_MODULE_1__.default.result();
  };

  path.measure = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_measure_js__WEBPACK_IMPORTED_MODULE_2__.default));
    return _measure_js__WEBPACK_IMPORTED_MODULE_2__.default.result();
  };

  path.bounds = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_bounds_js__WEBPACK_IMPORTED_MODULE_3__.default));
    return _bounds_js__WEBPACK_IMPORTED_MODULE_3__.default.result();
  };

  path.centroid = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_centroid_js__WEBPACK_IMPORTED_MODULE_4__.default));
    return _centroid_js__WEBPACK_IMPORTED_MODULE_4__.default.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity_js__WEBPACK_IMPORTED_MODULE_5__.default) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string_js__WEBPACK_IMPORTED_MODULE_6__.default) : new _context_js__WEBPACK_IMPORTED_MODULE_7__.default(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/measure.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/measure.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-geo/src/noop.js");




var lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;

var lengthStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__.default;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lengthStream);


/***/ }),

/***/ "../../node_modules/d3-geo/src/path/string.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-geo/src/path/string.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathString)
/* harmony export */ });
function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/pointEqual.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-geo/src/pointEqual.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/polygonContains.js":
/*!********************************************************!*\
  !*** ../../node_modules/d3-geo/src/polygonContains.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/fsum.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");




function longitude(point) {
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) <= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi)
    return point[0];
  else
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(point[0]) * (((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) + _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
      normal = [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), 0],
      angle = 0,
      winding = 0;

  var sum = new d3_array__WEBPACK_IMPORTED_MODULE_1__.Adder();

  if (sinPhi === 1) phi = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
  else if (sinPhi === -1) phi = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
        sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi0),
        cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
          sinPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi1),
          cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi,
          k = sinPhi0 * sinPhi1;

      sum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(k * sign * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point0), (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point1));
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(arc);
        var intersection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(normal, arc);
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || angle < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && sum < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) ^ (winding & 1);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/albers.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/albers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _conicEqualArea_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conicEqualArea.js */ "../../node_modules/d3-geo/src/projection/conicEqualArea.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_0__.default)()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/albersUsa.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/albersUsa.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _albers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./albers.js */ "../../node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var _conicEqualArea_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conicEqualArea.js */ "../../node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit.js */ "../../node_modules/d3-geo/src/projection/fit.js");





// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var cache,
      cacheStream,
      lower48 = (0,_albers_js__WEBPACK_IMPORTED_MODULE_0__.default)(), lower48Point,
      alaska = (0,_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_1__.default)().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = (0,_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_1__.default)().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.120 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon], [x - 0.214 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.234 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.166 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon], [x - 0.115 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.234 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitExtent)(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitSize)(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitWidth)(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitHeight)(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/azimuthal.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/azimuthal.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalRaw": () => (/* binding */ azimuthalRaw),
/* harmony export */   "azimuthalInvert": () => (/* binding */ azimuthalInvert)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");


function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x),
        cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y),
        k = scale(cx * cy);
        if (k === Infinity) return [2, 0];
    return [
      k * cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x),
      k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + y * y),
        c = angle(z),
        sc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(c),
        cc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(c);
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x * sc, z * cc),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(z && y * sc / z)
    ];
  }
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalEqualAreaRaw": () => (/* binding */ azimuthalEqualAreaRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




var azimuthalEqualAreaRaw = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalRaw)(function(cxcy) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalInvert)(function(z) {
  return 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / 2);
});

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js":
/*!************************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalEquidistantRaw": () => (/* binding */ azimuthalEquidistantRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




var azimuthalEquidistantRaw = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalRaw)(function(c) {
  return (c = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.acos)(c)) && c / (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(c);
});

azimuthalEquidistantRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalInvert)(function(z) {
  return z;
});

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/conic.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/conic.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicProjection": () => (/* binding */ conicProjection)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");



function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 3,
      m = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.projectionMutator)(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, phi1 = _[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians) : [phi0 * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, phi1 * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees];
  };

  return p;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/conicConformal.js":
/*!******************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/conicConformal.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicConformalRaw": () => (/* binding */ conicConformalRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conic.js */ "../../node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator.js */ "../../node_modules/d3-geo/src/projection/mercator.js");




function tany(y) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.tan)((_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y0),
      n = y0 === y1 ? (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y0) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)(cy0 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y1)) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)(tany(y1) / tany(y0)),
      f = cy0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.pow)(tany(y0), n) / n;

  if (!n) return _mercator_js__WEBPACK_IMPORTED_MODULE_1__.mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) y = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; }
    else { if (y > _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) y = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; }
    var r = f / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.pow)(tany(y), n);
    return [r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(n * x), f - r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(n) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + fy * fy),
      l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(fy)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(fy);
    if (fy * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(x) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(fy);
    return [l / n, 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.pow)(f / r, 1 / n)) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi];
  };

  return project;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic_js__WEBPACK_IMPORTED_MODULE_2__.conicProjection)(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/conicEqualArea.js":
/*!******************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/conicEqualArea.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicEqualAreaRaw": () => (/* binding */ conicEqualAreaRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conic.js */ "../../node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _cylindricalEqualArea_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cylindricalEqualArea.js */ "../../node_modules/d3-geo/src/projection/cylindricalEqualArea.js");




function conicEqualAreaRaw(y0, y1) {
  var sy0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y0), n = (sy0 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(n) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return (0,_cylindricalEqualArea_js__WEBPACK_IMPORTED_MODULE_1__.cylindricalEqualAreaRaw)(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(c) / n;

  function project(x, y) {
    var r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(c - 2 * n * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)) / n;
    return [r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x *= n), r0 - r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y,
        l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r0y)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(r0y);
    if (r0y * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(x) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(r0y);
    return [l / n, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic_js__WEBPACK_IMPORTED_MODULE_2__.conicProjection)(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/conicEquidistant.js":
/*!********************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/conicEquidistant.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicEquidistantRaw": () => (/* binding */ conicEquidistantRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conic.js */ "../../node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _equirectangular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equirectangular.js */ "../../node_modules/d3-geo/src/projection/equirectangular.js");




function conicEquidistantRaw(y0, y1) {
  var cy0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y0),
      n = y0 === y1 ? (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y0) : (cy0 - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(n) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return _equirectangular_js__WEBPACK_IMPORTED_MODULE_1__.equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(nx), g - gy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y,
        l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(gy)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(gy);
    if (gy * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(x) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(gy);
    return [l / n, g - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(n) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + gy * gy)];
  };

  return project;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic_js__WEBPACK_IMPORTED_MODULE_2__.conicProjection)(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/cylindricalEqualArea.js":
/*!************************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/cylindricalEqualArea.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cylindricalEqualAreaRaw": () => (/* binding */ cylindricalEqualAreaRaw)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");


function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(y * cosPhi0)];
  };

  return forward;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/equalEarth.js":
/*!**************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/equalEarth.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equalEarthRaw": () => (/* binding */ equalEarthRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");



var A1 = 1.340264,
    A2 = -0.081106,
    A3 = 0.000893,
    A4 = 0.003796,
    M = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3) / 2,
    iterations = 12;

function equalEarthRaw(lambda, phi) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(M * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}

equalEarthRaw.invert = function(x, y) {
  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) break;
  }
  return [
    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(l),
    (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(l) / M)
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.default)(equalEarthRaw)
      .scale(177.158);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/equirectangular.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/equirectangular.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equirectangularRaw": () => (/* binding */ equirectangularRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");


function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.default)(equirectangularRaw)
      .scale(152.63);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/fit.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/fit.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fitExtent": () => (/* binding */ fitExtent),
/* harmony export */   "fitSize": () => (/* binding */ fitSize),
/* harmony export */   "fitWidth": () => (/* binding */ fitWidth),
/* harmony export */   "fitHeight": () => (/* binding */ fitHeight)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "../../node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "../../node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__.default));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__.default.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/gnomonic.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/gnomonic.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gnomonicRaw": () => (/* binding */ gnomonicRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




function gnomonicRaw(x, y) {
  var cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y), k = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x) * cy;
  return [cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x) / k, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y) / k];
}

gnomonicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(_math_js__WEBPACK_IMPORTED_MODULE_0__.atan);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/identity.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/identity.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle.js */ "../../node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity.js */ "../../node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "../../node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fit.js */ "../../node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
      alpha = 0, ca, sa, // angle
      x0 = null, y0, x1, y1, // clip extent
      kx = 1, ky = 1,
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
        point: function(x, y) {
          var p = projection([x, y])
          this.stream.point(p[0], p[1]);
        }
      }),
      postclip = _identity_js__WEBPACK_IMPORTED_MODULE_1__.default,
      cache,
      cacheStream;

  function reset() {
    kx = k * sx;
    ky = k * sy;
    cache = cacheStream = null;
    return projection;
  }

  function projection (p) {
    var x = p[0] * kx, y = p[1] * ky;
    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }    
    return [x + tx, y + ty];
  }
  projection.invert = function(p) {
    var x = p[0] - tx, y = p[1] - ty;
    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }
    return [x / kx, y / ky];
  };
  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
  };
  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };
  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_1__.default) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };
  projection.scale = function(_) {
    return arguments.length ? (k = +_, reset()) : k;
  };
  projection.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  }
  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_3__.radians, sa = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.sin)(alpha), ca = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.cos)(alpha), reset()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_3__.degrees;
  };
  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitExtent)(projection, extent, object);
  };
  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitSize)(projection, size, object);
  };
  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitWidth)(projection, width, object);
  };
  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitHeight)(projection, height, object);
  };

  return projection;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ projection),
/* harmony export */   "projectionMutator": () => (/* binding */ projectionMutator)
/* harmony export */ });
/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/antimeridian.js */ "../../node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../clip/circle.js */ "../../node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../clip/rectangle.js */ "../../node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../compose.js */ "../../node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../identity.js */ "../../node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rotation.js */ "../../node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "../../node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fit.js */ "../../node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resample.js */ "../../node_modules/d3-geo/src/projection/resample.js");











var transformRadians = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
  point: function(x, y) {
    this.stream.point(x * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, y * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }
});

function transformRotate(rotate) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx; y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(alpha),
      sinAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx; y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate angle
      sx = 1, // reflectX
      sy = 1, // reflectX
      theta = null, preclip = _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__.default, // pre-clip angle
      x0 = null, y0, x1, y1, postclip = _identity_js__WEBPACK_IMPORTED_MODULE_3__.default, // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? (0,_clip_circle_js__WEBPACK_IMPORTED_MODULE_4__.default)(theta = _ * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians) : (theta = null, _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__.default), reset()) : theta * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_3__.default) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : [lambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, phi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaPhi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians : 0, recenter()) : [deltaLambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaPhi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaGamma * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__.default)(projectTransform, delta2 = _ * _), reset()) : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitSize)(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitHeight)(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_8__.rotateRadians)(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__.default)(project, transform);
    projectRotateTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__.default)(rotate, projectTransform);
    projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__.default)(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/mercator.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/mercator.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mercatorRaw": () => (/* binding */ mercatorRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mercatorProjection": () => (/* binding */ mercatorProjection)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rotation.js */ "../../node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




function mercatorRaw(lambda, phi) {
  return [lambda, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.tan)((_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.exp)(y)) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
}

function mercatorProjection(project) {
  var m = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.default)(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * scale(),
        t = m((0,_rotation_js__WEBPACK_IMPORTED_MODULE_2__.default)(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/naturalEarth1.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/naturalEarth1.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "naturalEarth1Raw": () => (/* binding */ naturalEarth1Raw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");



function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.default)(naturalEarth1Raw)
      .scale(175.295);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/orthographic.js":
/*!****************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/orthographic.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "orthographicRaw": () => (/* binding */ orthographicRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




function orthographicRaw(x, y) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)];
}

orthographicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(_math_js__WEBPACK_IMPORTED_MODULE_0__.asin);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/resample.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/resample.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cartesian.js */ "../../node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "../../node_modules/d3-geo/src/transform.js");




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(30 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians); // cos(minimum angular distance)

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.transformer)({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(a * a + b * b + c * c),
          phi2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(c /= m),
          lambda2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(c) - 1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda0 - lambda1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? (lambda0 + lambda1) / 2 : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/stereographic.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/stereographic.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stereographicRaw": () => (/* binding */ stereographicRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "../../node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "../../node_modules/d3-geo/src/projection/index.js");




function stereographicRaw(x, y) {
  var cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y), k = 1 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x) * cy;
  return [cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x) / k, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y) / k];
}

stereographicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(function(z) {
  return 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)(z);
});

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(stereographicRaw)
      .scale(250)
      .clipAngle(142);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/projection/transverseMercator.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/d3-geo/src/projection/transverseMercator.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transverseMercatorRaw": () => (/* binding */ transverseMercatorRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-geo/src/math.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator.js */ "../../node_modules/d3-geo/src/projection/mercator.js");



function transverseMercatorRaw(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.tan)((_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.exp)(x)) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var m = (0,_mercator_js__WEBPACK_IMPORTED_MODULE_1__.mercatorProjection)(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/rotation.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-geo/src/rotation.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rotateRadians": () => (/* binding */ rotateRadians),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose.js */ "../../node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + Math.round(-lambda / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) ? (deltaPhi || deltaGamma ? (0,_compose_js__WEBPACK_IMPORTED_MODULE_1__.default)(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda - _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda < -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaPhi),
      sinDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaPhi),
      cosDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaGamma),
      sinDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rotate) {
  rotate = rotateRadians(rotate[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate.length > 2 ? rotate[2] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  };

  return forward;
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/stream.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-geo/src/stream.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "../../node_modules/d3-geo/src/transform.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-geo/src/transform.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "transformer": () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/accessors.js":
/*!********************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/accessors.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "optional": () => (/* binding */ optional),
/* harmony export */   "required": () => (/* binding */ required)
/* harmony export */ });
function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/array.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/array.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "shuffle": () => (/* binding */ shuffle)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/cluster.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/cluster.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/constant.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/constant.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "constantZero": () => (/* binding */ constantZero),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function constantZero() {
  return 0;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/ancestors.js":
/*!******************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/ancestors.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/count.js":
/*!**************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/count.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.eachAfter(count);
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/descendants.js":
/*!********************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/descendants.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/each.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/each.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  let index = -1;
  for (const node of this) {
    callback.call(that, node, ++index, this);
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/eachAfter.js":
/*!******************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/eachAfter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/eachBefore.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/eachBefore.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  var node = this, nodes = [node], children, i, index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/find.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/find.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  let index = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index, this)) {
      return node;
    }
  }
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hierarchy),
/* harmony export */   "computeHeight": () => (/* binding */ computeHeight),
/* harmony export */   "Node": () => (/* binding */ Node)
/* harmony export */ });
/* harmony import */ var _count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./count.js */ "../../node_modules/d3-hierarchy/src/hierarchy/count.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "../../node_modules/d3-hierarchy/src/hierarchy/each.js");
/* harmony import */ var _eachBefore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eachBefore.js */ "../../node_modules/d3-hierarchy/src/hierarchy/eachBefore.js");
/* harmony import */ var _eachAfter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./eachAfter.js */ "../../node_modules/d3-hierarchy/src/hierarchy/eachAfter.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./find.js */ "../../node_modules/d3-hierarchy/src/hierarchy/find.js");
/* harmony import */ var _sum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sum.js */ "../../node_modules/d3-hierarchy/src/hierarchy/sum.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort.js */ "../../node_modules/d3-hierarchy/src/hierarchy/sort.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./path.js */ "../../node_modules/d3-hierarchy/src/hierarchy/path.js");
/* harmony import */ var _ancestors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ancestors.js */ "../../node_modules/d3-hierarchy/src/hierarchy/ancestors.js");
/* harmony import */ var _descendants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./descendants.js */ "../../node_modules/d3-hierarchy/src/hierarchy/descendants.js");
/* harmony import */ var _leaves_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./leaves.js */ "../../node_modules/d3-hierarchy/src/hierarchy/leaves.js");
/* harmony import */ var _links_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./links.js */ "../../node_modules/d3-hierarchy/src/hierarchy/links.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./iterator.js */ "../../node_modules/d3-hierarchy/src/hierarchy/iterator.js");














function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [undefined, data];
    if (children === undefined) children = mapChildren;
  } else if (children === undefined) {
    children = objectChildren;
  }

  var root = new Node(data),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function objectChildren(d) {
  return d.children;
}

function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}

function copyData(node) {
  if (node.data.value !== undefined) node.value = node.data.value;
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: _count_js__WEBPACK_IMPORTED_MODULE_0__.default,
  each: _each_js__WEBPACK_IMPORTED_MODULE_1__.default,
  eachAfter: _eachAfter_js__WEBPACK_IMPORTED_MODULE_2__.default,
  eachBefore: _eachBefore_js__WEBPACK_IMPORTED_MODULE_3__.default,
  find: _find_js__WEBPACK_IMPORTED_MODULE_4__.default,
  sum: _sum_js__WEBPACK_IMPORTED_MODULE_5__.default,
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_6__.default,
  path: _path_js__WEBPACK_IMPORTED_MODULE_7__.default,
  ancestors: _ancestors_js__WEBPACK_IMPORTED_MODULE_8__.default,
  descendants: _descendants_js__WEBPACK_IMPORTED_MODULE_9__.default,
  leaves: _leaves_js__WEBPACK_IMPORTED_MODULE_10__.default,
  links: _links_js__WEBPACK_IMPORTED_MODULE_11__.default,
  copy: node_copy,
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_12__.default
};


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/iterator.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/iterator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/leaves.js":
/*!***************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/leaves.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/links.js":
/*!**************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/links.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/path.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/path.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/sort.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/sort.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/hierarchy/sum.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/hierarchy/sum.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/pack/enclose.js":
/*!***********************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/pack/enclose.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "../../node_modules/d3-hierarchy/src/array.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(circles) {
  var i = 0, n = (circles = (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.shuffle)(Array.from(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/pack/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/pack/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _siblings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./siblings.js */ "../../node_modules/d3-hierarchy/src/pack/siblings.js");
/* harmony import */ var _accessors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../accessors.js */ "../../node_modules/d3-hierarchy/src/accessors.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constant.js */ "../../node_modules/d3-hierarchy/src/constant.js");




function defaultRadius(d) {
  return Math.sqrt(d.value);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = _constant_js__WEBPACK_IMPORTED_MODULE_0__.constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(_constant_js__WEBPACK_IMPORTED_MODULE_0__.constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_1__.optional)(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = (0,_siblings_js__WEBPACK_IMPORTED_MODULE_2__.packEnclose)(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/pack/siblings.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/pack/siblings.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "packEnclose": () => (/* binding */ packEnclose),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "../../node_modules/d3-hierarchy/src/array.js");
/* harmony import */ var _enclose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enclose.js */ "../../node_modules/d3-hierarchy/src/pack/enclose.js");



function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = (circles = (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.default)(circles)).length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = (0,_enclose_js__WEBPACK_IMPORTED_MODULE_1__.default)(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(circles) {
  packEnclose(circles);
  return circles;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/partition.js":
/*!********************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/partition.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _treemap_round_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./treemap/round.js */ "../../node_modules/d3-hierarchy/src/treemap/round.js");
/* harmony import */ var _treemap_dice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./treemap/dice.js */ "../../node_modules/d3-hierarchy/src/treemap/dice.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(_treemap_round_js__WEBPACK_IMPORTED_MODULE_0__.default);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        (0,_treemap_dice_js__WEBPACK_IMPORTED_MODULE_1__.default)(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/stratify.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/stratify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _accessors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accessors.js */ "../../node_modules/d3-hierarchy/src/accessors.js");
/* harmony import */ var _hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hierarchy/index.js */ "../../node_modules/d3-hierarchy/src/hierarchy/index.js");



var preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var nodes = Array.from(data),
        n = nodes.length,
        d,
        i,
        root,
        parent,
        node,
        nodeId,
        nodeKey,
        nodeByKey = new Map;

    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new _hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__.Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root) throw new Error("multiple roots");
        root = node;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(_hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__.computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_1__.required)(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_1__.required)(x), stratify) : parentId;
  };

  return stratify;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/tree.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/tree.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hierarchy/index.js */ "../../node_modules/d3-hierarchy/src/hierarchy/index.js");


function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(_hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__.Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/treemap/binary.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/treemap/binary.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/treemap/dice.js":
/*!***********************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/treemap/dice.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/treemap/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/treemap/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./round.js */ "../../node_modules/d3-hierarchy/src/treemap/round.js");
/* harmony import */ var _squarify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./squarify.js */ "../../node_modules/d3-hierarchy/src/treemap/squarify.js");
/* harmony import */ var _accessors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../accessors.js */ "../../node_modules/d3-hierarchy/src/accessors.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "../../node_modules/d3-hierarchy/src/constant.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var tile = _squarify_js__WEBPACK_IMPORTED_MODULE_0__.default,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingTop = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingRight = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingBottom = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingLeft = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(_round_js__WEBPACK_IMPORTED_MODULE_2__.default);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_3__.required)(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingLeft;
  };

  return treemap;
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/treemap/resquarify.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/treemap/resquarify.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dice.js */ "../../node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var _slice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice.js */ "../../node_modules/d3-hierarchy/src/treemap/slice.js");
/* harmony import */ var _squarify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./squarify.js */ "../../node_modules/d3-hierarchy/src/treemap/squarify.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) (0,_dice_js__WEBPACK_IMPORTED_MODULE_0__.default)(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
        else (0,_slice_js__WEBPACK_IMPORTED_MODULE_1__.default)(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = (0,_squarify_js__WEBPACK_IMPORTED_MODULE_2__.squarifyRatio)(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(_squarify_js__WEBPACK_IMPORTED_MODULE_2__.phi));


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/treemap/round.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/treemap/round.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/treemap/slice.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/treemap/slice.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/treemap/sliceDice.js":
/*!****************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/treemap/sliceDice.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dice.js */ "../../node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var _slice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slice.js */ "../../node_modules/d3-hierarchy/src/treemap/slice.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? _slice_js__WEBPACK_IMPORTED_MODULE_0__.default : _dice_js__WEBPACK_IMPORTED_MODULE_1__.default)(parent, x0, y0, x1, y1);
}


/***/ }),

/***/ "../../node_modules/d3-hierarchy/src/treemap/squarify.js":
/*!***************************************************************!*\
  !*** ../../node_modules/d3-hierarchy/src/treemap/squarify.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "phi": () => (/* binding */ phi),
/* harmony export */   "squarifyRatio": () => (/* binding */ squarifyRatio),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dice.js */ "../../node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var _slice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice.js */ "../../node_modules/d3-hierarchy/src/treemap/slice.js");



var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) (0,_dice_js__WEBPACK_IMPORTED_MODULE_0__.default)(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else (0,_slice_js__WEBPACK_IMPORTED_MODULE_1__.default)(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi));


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/array.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/array.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "genericArray": () => (/* binding */ genericArray)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./value.js */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberArray.js */ "../../node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return ((0,_numberArray_js__WEBPACK_IMPORTED_MODULE_0__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_0__.default : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0,_value_js__WEBPACK_IMPORTED_MODULE_1__.default)(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/basis.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/basis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "basis": () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/basisClosed.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/basisClosed.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/color.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/color.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hue": () => (/* binding */ hue),
/* harmony export */   "gamma": () => (/* binding */ gamma),
/* harmony export */   "default": () => (/* binding */ nogamma)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(a) ? b : a);
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/constant.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/constant.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/cubehelix.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/cubehelix.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "cubehelixLong": () => (/* binding */ cubehelixLong)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/cubehelix.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.default)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.default)(end)).h),
          s = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.s, end.s),
          l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.l, end.l),
          opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__.hue));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__.default);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/date.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/date.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/discrete.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/discrete.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/hcl.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/hcl.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "hclLong": () => (/* binding */ hclLong)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hcl)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hcl)(end)).h),
        c = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.c, end.c),
        l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.l, end.l),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__.hue));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__.default);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/hsl.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/hsl.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "hslLong": () => (/* binding */ hslLong)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hsl)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hsl)(end)).h),
        s = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.s, end.s),
        l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.l, end.l),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__.hue));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__.default);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/hue.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/hue.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.hue)(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interpolate": () => (/* reexport safe */ _value_js__WEBPACK_IMPORTED_MODULE_0__.default),
/* harmony export */   "interpolateArray": () => (/* reexport safe */ _array_js__WEBPACK_IMPORTED_MODULE_1__.default),
/* harmony export */   "interpolateBasis": () => (/* reexport safe */ _basis_js__WEBPACK_IMPORTED_MODULE_2__.default),
/* harmony export */   "interpolateBasisClosed": () => (/* reexport safe */ _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__.default),
/* harmony export */   "interpolateDate": () => (/* reexport safe */ _date_js__WEBPACK_IMPORTED_MODULE_4__.default),
/* harmony export */   "interpolateDiscrete": () => (/* reexport safe */ _discrete_js__WEBPACK_IMPORTED_MODULE_5__.default),
/* harmony export */   "interpolateHue": () => (/* reexport safe */ _hue_js__WEBPACK_IMPORTED_MODULE_6__.default),
/* harmony export */   "interpolateNumber": () => (/* reexport safe */ _number_js__WEBPACK_IMPORTED_MODULE_7__.default),
/* harmony export */   "interpolateNumberArray": () => (/* reexport safe */ _numberArray_js__WEBPACK_IMPORTED_MODULE_8__.default),
/* harmony export */   "interpolateObject": () => (/* reexport safe */ _object_js__WEBPACK_IMPORTED_MODULE_9__.default),
/* harmony export */   "interpolateRound": () => (/* reexport safe */ _round_js__WEBPACK_IMPORTED_MODULE_10__.default),
/* harmony export */   "interpolateString": () => (/* reexport safe */ _string_js__WEBPACK_IMPORTED_MODULE_11__.default),
/* harmony export */   "interpolateTransformCss": () => (/* reexport safe */ _transform_index_js__WEBPACK_IMPORTED_MODULE_12__.interpolateTransformCss),
/* harmony export */   "interpolateTransformSvg": () => (/* reexport safe */ _transform_index_js__WEBPACK_IMPORTED_MODULE_12__.interpolateTransformSvg),
/* harmony export */   "interpolateZoom": () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_13__.default),
/* harmony export */   "interpolateRgb": () => (/* reexport safe */ _rgb_js__WEBPACK_IMPORTED_MODULE_14__.default),
/* harmony export */   "interpolateRgbBasis": () => (/* reexport safe */ _rgb_js__WEBPACK_IMPORTED_MODULE_14__.rgbBasis),
/* harmony export */   "interpolateRgbBasisClosed": () => (/* reexport safe */ _rgb_js__WEBPACK_IMPORTED_MODULE_14__.rgbBasisClosed),
/* harmony export */   "interpolateHsl": () => (/* reexport safe */ _hsl_js__WEBPACK_IMPORTED_MODULE_15__.default),
/* harmony export */   "interpolateHslLong": () => (/* reexport safe */ _hsl_js__WEBPACK_IMPORTED_MODULE_15__.hslLong),
/* harmony export */   "interpolateLab": () => (/* reexport safe */ _lab_js__WEBPACK_IMPORTED_MODULE_16__.default),
/* harmony export */   "interpolateHcl": () => (/* reexport safe */ _hcl_js__WEBPACK_IMPORTED_MODULE_17__.default),
/* harmony export */   "interpolateHclLong": () => (/* reexport safe */ _hcl_js__WEBPACK_IMPORTED_MODULE_17__.hclLong),
/* harmony export */   "interpolateCubehelix": () => (/* reexport safe */ _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__.default),
/* harmony export */   "interpolateCubehelixLong": () => (/* reexport safe */ _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__.cubehelixLong),
/* harmony export */   "piecewise": () => (/* reexport safe */ _piecewise_js__WEBPACK_IMPORTED_MODULE_19__.default),
/* harmony export */   "quantize": () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_20__.default)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "../../node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "../../node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date.js */ "../../node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _discrete_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete.js */ "../../node_modules/d3-interpolate/src/discrete.js");
/* harmony import */ var _hue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue.js */ "../../node_modules/d3-interpolate/src/hue.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "../../node_modules/d3-interpolate/src/numberArray.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "../../node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./round.js */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./string.js */ "../../node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _transform_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/index.js */ "../../node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zoom.js */ "../../node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rgb.js */ "../../node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _hsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hsl.js */ "../../node_modules/d3-interpolate/src/hsl.js");
/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lab.js */ "../../node_modules/d3-interpolate/src/lab.js");
/* harmony import */ var _hcl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hcl.js */ "../../node_modules/d3-interpolate/src/hcl.js");
/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cubehelix.js */ "../../node_modules/d3-interpolate/src/cubehelix.js");
/* harmony import */ var _piecewise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./piecewise.js */ "../../node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./quantize.js */ "../../node_modules/d3-interpolate/src/quantize.js");























/***/ }),

/***/ "../../node_modules/d3-interpolate/src/lab.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/lab.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lab)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.default)(start)).l, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.default)(end)).l),
      a = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.a, end.a),
      b = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/number.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/number.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/numberArray.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/numberArray.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "isNumberArray": () => (/* binding */ isNumberArray)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/object.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/object.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "../../node_modules/d3-interpolate/src/value.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0,_value_js__WEBPACK_IMPORTED_MODULE_0__.default)(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/piecewise.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/piecewise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ piecewise)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "../../node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__.default;
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/quantize.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/quantize.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/rgb.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/rgb.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "rgbBasis": () => (/* binding */ rgbBasis),
/* harmony export */   "rgbBasisClosed": () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "../../node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "../../node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__.default);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__.default);


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/round.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/round.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/string.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/string.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/transform/decompose.js":
/*!********************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/transform/decompose.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/transform/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/transform/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interpolateTransformCss": () => (/* binding */ interpolateTransformCss),
/* harmony export */   "interpolateTransformSvg": () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "../../node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/transform/parse.js":
/*!****************************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/transform/parse.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseCss": () => (/* binding */ parseCss),
/* harmony export */   "parseSvg": () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "../../node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__.default)(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__.default)(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/value.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/value.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rgb.js */ "../../node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./array.js */ "../../node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./date.js */ "../../node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./object.js */ "../../node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ "../../node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./numberArray.js */ "../../node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_1__.default
      : t === "string" ? ((c = (0,d3_color__WEBPACK_IMPORTED_MODULE_2__.default)(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_3__.default) : _string_js__WEBPACK_IMPORTED_MODULE_4__.default)
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_2__.default ? _rgb_js__WEBPACK_IMPORTED_MODULE_3__.default
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_5__.default
      : (0,_numberArray_js__WEBPACK_IMPORTED_MODULE_6__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_6__.default
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_7__.genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_8__.default
      : _number_js__WEBPACK_IMPORTED_MODULE_1__.default)(a, b);
}


/***/ }),

/***/ "../../node_modules/d3-interpolate/src/zoom.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-interpolate/src/zoom.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "../../node_modules/d3-path/src/path.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-path/src/path.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (path);


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/add.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/add.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "addAll": () => (/* binding */ addAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/cover.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/cover.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/data.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/data.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/extent.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/extent.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/find.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/find.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "../../node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/quad.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/quad.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/quadtree.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/quadtree.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "../../node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "../../node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "../../node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "../../node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "../../node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "../../node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "../../node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "../../node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "../../node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "../../node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "../../node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "../../node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__.default;
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__.default;
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__.default;
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__.default;
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__.default;
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__.default;
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__.default;
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__.default;
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__.default;
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__.default;
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__.default;
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__.default;


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/remove.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/remove.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "removeAll": () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/root.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/root.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/size.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/size.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/visit.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/visit.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "../../node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/visitAfter.js":
/*!********************************************************!*\
  !*** ../../node_modules/d3-quadtree/src/visitAfter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "../../node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/x.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-quadtree/src/x.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultX": () => (/* binding */ defaultX),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "../../node_modules/d3-quadtree/src/y.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-quadtree/src/y.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultY": () => (/* binding */ defaultY),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/constant.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-scale/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ constants)
/* harmony export */ });
function constants(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/continuous.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-scale/src/continuous.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "transformer": () => (/* binding */ transformer),
/* harmony export */   "default": () => (/* binding */ continuous)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-scale/src/number.js");





var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.default,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_3__.default)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_4__.default), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__.default, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/diverging.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-scale/src/diverging.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ diverging),
/* harmony export */   "divergingLog": () => (/* binding */ divergingLog),
/* harmony export */   "divergingSymlog": () => (/* binding */ divergingSymlog),
/* harmony export */   "divergingPow": () => (/* binding */ divergingPow),
/* harmony export */   "divergingSqrt": () => (/* binding */ divergingSqrt)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./log.js */ "../../node_modules/d3-scale/src/log.js");
/* harmony import */ var _sequential_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sequential.js */ "../../node_modules/d3-scale/src/sequential.js");
/* harmony import */ var _symlog_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symlog.js */ "../../node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pow.js */ "../../node_modules/d3-scale/src/pow.js");









function transformer() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      s = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.default)(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }

  scale.range = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.default);

  scale.rangeRound = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_3__.default);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
    return scale;
  };
}

function diverging() {
  var scale = (0,_linear_js__WEBPACK_IMPORTED_MODULE_4__.linearish)(transformer()(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity));

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, diverging());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = (0,_log_js__WEBPACK_IMPORTED_MODULE_7__.loggish)(transformer()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, divergingLog()).base(scale.base());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = (0,_symlog_js__WEBPACK_IMPORTED_MODULE_8__.symlogish)(transformer());

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, divergingSymlog()).constant(scale.constant());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = (0,_pow_js__WEBPACK_IMPORTED_MODULE_9__.powish)(transformer());

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, divergingPow()).exponent(scale.exponent());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/identity.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-scale/src/identity.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ identity)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "../../node_modules/d3-scale/src/number.js");



function identity(domain) {
  var unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_0__.default), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity(domain).unknown(unknown);
  };

  domain = arguments.length ? Array.from(domain, _number_js__WEBPACK_IMPORTED_MODULE_0__.default) : [0, 1];

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/init.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-scale/src/init.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initRange": () => (/* binding */ initRange),
/* harmony export */   "initInterpolator": () => (/* binding */ initInterpolator)
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/linear.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-scale/src/linear.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearish": () => (/* binding */ linearish),
/* harmony export */   "default": () => (/* binding */ linear)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");
/* harmony import */ var _tickFormat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tickFormat.js */ "../../node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return (0,_tickFormat_js__WEBPACK_IMPORTED_MODULE_1__.default)(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.default)();

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.copy)(scale, linear());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/log.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-scale/src/log.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loggish": () => (/* binding */ loggish),
/* harmony export */   "default": () => (/* binding */ log)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _nice_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nice.js */ "../../node_modules/d3-scale/src/nice.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(u, v, n);
    } else {
      z = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.format)(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain((0,_nice_js__WEBPACK_IMPORTED_MODULE_2__.default)(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_3__.transformer)()).domain([1, 10]);

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_3__.copy)(scale, log()).base(scale.base());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_4__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/nice.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-scale/src/nice.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nice)
/* harmony export */ });
function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/number.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-scale/src/number.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number)
/* harmony export */ });
function number(x) {
  return +x;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/ordinal.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-scale/src/ordinal.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "implicit": () => (/* binding */ implicit),
/* harmony export */   "default": () => (/* binding */ ordinal)
/* harmony export */ });
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");


const implicit = Symbol("implicit");

function ordinal() {
  var index = new Map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new Map();
    for (const value of _) {
      const key = value + "";
      if (index.has(key)) continue;
      index.set(key, domain.push(value));
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init_js__WEBPACK_IMPORTED_MODULE_0__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/pow.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-scale/src/pow.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "powish": () => (/* binding */ powish),
/* harmony export */   "default": () => (/* binding */ pow),
/* harmony export */   "sqrt": () => (/* binding */ sqrt)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}

function pow() {
  var scale = powish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, pow()).exponent(scale.exponent());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/quantile.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-scale/src/quantile.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ascending.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.quantileSorted)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_2__.default);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/quantize.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-scale/src/quantize.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantize)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply((0,_linear_js__WEBPACK_IMPORTED_MODULE_2__.linearish)(scale), arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/sequential.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-scale/src/sequential.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "default": () => (/* binding */ sequential),
/* harmony export */   "sequentialLog": () => (/* binding */ sequentialLog),
/* harmony export */   "sequentialSymlog": () => (/* binding */ sequentialSymlog),
/* harmony export */   "sequentialPow": () => (/* binding */ sequentialPow),
/* harmony export */   "sequentialSqrt": () => (/* binding */ sequentialSqrt)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./log.js */ "../../node_modules/d3-scale/src/log.js");
/* harmony import */ var _symlog_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symlog.js */ "../../node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pow.js */ "../../node_modules/d3-scale/src/pow.js");








function transformer() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity,
      clamp = false,
      unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }

  scale.range = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.default);

  scale.rangeRound = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.default);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = (0,_linear_js__WEBPACK_IMPORTED_MODULE_3__.linearish)(transformer()(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity));

  scale.copy = function() {
    return copy(scale, sequential());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = (0,_log_js__WEBPACK_IMPORTED_MODULE_5__.loggish)(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, sequentialLog()).base(scale.base());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = (0,_symlog_js__WEBPACK_IMPORTED_MODULE_6__.symlogish)(transformer());

  scale.copy = function() {
    return copy(scale, sequentialSymlog()).constant(scale.constant());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = (0,_pow_js__WEBPACK_IMPORTED_MODULE_7__.powish)(transformer());

  scale.copy = function() {
    return copy(scale, sequentialPow()).exponent(scale.exponent());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/symlog.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-scale/src/symlog.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "symlogish": () => (/* binding */ symlogish),
/* harmony export */   "default": () => (/* binding */ symlog)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");




function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_0__.linearish)(scale);
}

function symlog() {
  var scale = symlogish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_1__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_1__.copy)(scale, symlog()).constant(scale.constant());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/threshold.js":
/*!****************************************************!*\
  !*** ../../node_modules/d3-scale/src/threshold.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ threshold)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/tickFormat.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-scale/src/tickFormat.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tickFormat)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionFixed.js");



function tickFormat(start, stop, count, specifier) {
  var step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start, stop, count),
      precision;
  specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.default)(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(step, value))) specifier.precision = precision;
      return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.formatPrefix)(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.default)(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__.default)(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.format)(specifier);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/time.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-scale/src/time.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calendar": () => (/* binding */ calendar),
/* harmony export */   "default": () => (/* binding */ time)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/ticks.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/month.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/hour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/minute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-time-format */ "../../node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "../../node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");
/* harmony import */ var _nice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nice.js */ "../../node_modules/d3-scale/src/nice.js");






function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.default)(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain((0,_nice_js__WEBPACK_IMPORTED_MODULE_1__.default)(d, interval)) : scale;
  };

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };

  return scale;
}

function time() {
  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(calendar(d3_time__WEBPACK_IMPORTED_MODULE_3__.timeTicks, d3_time__WEBPACK_IMPORTED_MODULE_3__.timeTickInterval, d3_time__WEBPACK_IMPORTED_MODULE_4__.default, d3_time__WEBPACK_IMPORTED_MODULE_5__.default, d3_time__WEBPACK_IMPORTED_MODULE_6__.sunday, d3_time__WEBPACK_IMPORTED_MODULE_7__.default, d3_time__WEBPACK_IMPORTED_MODULE_8__.default, d3_time__WEBPACK_IMPORTED_MODULE_9__.default, d3_time__WEBPACK_IMPORTED_MODULE_10__.default, d3_time_format__WEBPACK_IMPORTED_MODULE_11__.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}


/***/ }),

/***/ "../../node_modules/d3-scale/src/utcTime.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-scale/src/utcTime.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ utcTime)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/ticks.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcYear.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcHour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time-format */ "../../node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./time.js */ "../../node_modules/d3-scale/src/time.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init.js */ "../../node_modules/d3-scale/src/init.js");





function utcTime() {
  return _init_js__WEBPACK_IMPORTED_MODULE_0__.initRange.apply((0,_time_js__WEBPACK_IMPORTED_MODULE_1__.calendar)(d3_time__WEBPACK_IMPORTED_MODULE_2__.utcTicks, d3_time__WEBPACK_IMPORTED_MODULE_2__.utcTickInterval, d3_time__WEBPACK_IMPORTED_MODULE_3__.default, d3_time__WEBPACK_IMPORTED_MODULE_4__.default, d3_time__WEBPACK_IMPORTED_MODULE_5__.utcSunday, d3_time__WEBPACK_IMPORTED_MODULE_6__.default, d3_time__WEBPACK_IMPORTED_MODULE_7__.default, d3_time__WEBPACK_IMPORTED_MODULE_8__.default, d3_time__WEBPACK_IMPORTED_MODULE_9__.default, d3_time_format__WEBPACK_IMPORTED_MODULE_10__.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/arc.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-shape/src/arc.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "../../node_modules/d3-shape/src/math.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        da = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_2__.default)();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
      context.moveTo(r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a0), r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        context.moveTo(r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a1), r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(r0 * r0 + r1 * r1)),
          rc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var p0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap)),
            p1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a01),
          y01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a01),
          x10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a10),
          y10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var x11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a11),
            y11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a11),
            x00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a00),
            y00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_0__.pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)((ax * bx + ay * by) / ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(ax * ax + ay * ay) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(bx * bx + by * by))) / 2),
              lc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r0 - lc) / (kc - 1));
          rc1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 2;
    return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a) * r, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/area.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-shape/src/area.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ "../../node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "../../node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.js */ "../../node_modules/d3-shape/src/line.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point.js */ "../../node_modules/d3-shape/src/point.js");







/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x0, y0, y1) {
  var x1 = null,
      defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__.default,
      output = null;

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(0) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.default)(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__.default)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line_js__WEBPACK_IMPORTED_MODULE_5__.default)().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/array.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-shape/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var slice = Array.prototype.slice;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/constant.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-shape/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/basis.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/basis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "Basis": () => (/* binding */ Basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Basis(context);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/basisClosed.js":
/*!************************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/basisClosed.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: (0,_basis_js__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisClosed(context);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/basisOpen.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/basisOpen.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisOpen(context);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/bundle.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/bundle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "../../node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis_js__WEBPACK_IMPORTED_MODULE_0__.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis_js__WEBPACK_IMPORTED_MODULE_0__.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/cardinal.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/cardinal.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "Cardinal": () => (/* binding */ Cardinal),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!***************************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CardinalClosed": () => (/* binding */ CardinalClosed),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "../../node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_cardinal_js__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CardinalOpen": () => (/* binding */ CardinalOpen),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal.js */ "../../node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_cardinal_js__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/catmullRom.js":
/*!***********************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/catmullRom.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "../../node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal_js__WEBPACK_IMPORTED_MODULE_1__.Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cardinalClosed.js */ "../../node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom.js */ "../../node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_catmullRom_js__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_2__.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!***************************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinalOpen.js */ "../../node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./catmullRom.js */ "../../node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_catmullRom_js__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_1__.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/linear.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/linear.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/linearClosed.js":
/*!*************************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/linearClosed.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "../../node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new LinearClosed(context);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/monotone.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/monotone.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "monotoneX": () => (/* binding */ monotoneX),
/* harmony export */   "monotoneY": () => (/* binding */ monotoneY)
/* harmony export */ });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/natural.js":
/*!********************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/natural.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Natural(context);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/curve/step.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-shape/src/curve/step.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "stepBefore": () => (/* binding */ stepBefore),
/* harmony export */   "stepAfter": () => (/* binding */ stepAfter)
/* harmony export */ });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/line.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-shape/src/line.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ "../../node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "../../node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point.js */ "../../node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__.default,
      output = null;

  x = typeof x === "function" ? x : (x === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(x);
  y = typeof y === "function" ? y : (y === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(y);

  function line(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.default)(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__.default)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/math.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-shape/src/math.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "epsilon": () => (/* binding */ epsilon),
/* harmony export */   "pi": () => (/* binding */ pi),
/* harmony export */   "halfPi": () => (/* binding */ halfPi),
/* harmony export */   "tau": () => (/* binding */ tau),
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "asin": () => (/* binding */ asin)
/* harmony export */ });
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/noop.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-shape/src/noop.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {}


/***/ }),

/***/ "../../node_modules/d3-shape/src/point.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-shape/src/point.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ x),
/* harmony export */   "y": () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/symbol.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-shape/src/symbol.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "symbols": () => (/* binding */ symbols),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle.js */ "../../node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross.js */ "../../node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond.js */ "../../node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/star.js */ "../../node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/square.js */ "../../node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle.js */ "../../node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye.js */ "../../node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant.js */ "../../node_modules/d3-shape/src/constant.js");










var symbols = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__.default,
  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__.default,
  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__.default,
  _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__.default,
  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__.default,
  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__.default,
  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__.default
];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, size) {
  var context = null;
  type = typeof type === "function" ? type : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(type || _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__.default);
  size = typeof size === "function" ? size : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(size === undefined ? 64 : +size);

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_8__.default)();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "../../node_modules/d3-shape/src/symbol/circle.js":
/*!********************************************************!*\
  !*** ../../node_modules/d3-shape/src/symbol/circle.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "../../node_modules/d3-shape/src/symbol/cross.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-shape/src/symbol/cross.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/d3-shape/src/symbol/diamond.js":
/*!*********************************************************!*\
  !*** ../../node_modules/d3-shape/src/symbol/diamond.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/d3-shape/src/symbol/square.js":
/*!********************************************************!*\
  !*** ../../node_modules/d3-shape/src/symbol/square.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "../../node_modules/d3-shape/src/symbol/star.js":
/*!******************************************************!*\
  !*** ../../node_modules/d3-shape/src/symbol/star.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "../../node_modules/d3-shape/src/math.js");


var ka = 0.89081309152928522810,
    kr = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / Math.sin(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10),
    kx = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr,
    ky = -Math.cos(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = _math_js__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/d3-shape/src/symbol/triangle.js":
/*!**********************************************************!*\
  !*** ../../node_modules/d3-shape/src/symbol/triangle.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var sqrt3 = Math.sqrt(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/d3-shape/src/symbol/wye.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-shape/src/symbol/wye.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "../../node_modules/d3-time-format/src/defaultLocale.js":
/*!**************************************************************!*\
  !*** ../../node_modules/d3-time-format/src/defaultLocale.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timeFormat": () => (/* binding */ timeFormat),
/* harmony export */   "timeParse": () => (/* binding */ timeParse),
/* harmony export */   "utcFormat": () => (/* binding */ utcFormat),
/* harmony export */   "utcParse": () => (/* binding */ utcParse),
/* harmony export */   "default": () => (/* binding */ defaultLocale)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "../../node_modules/d3-time-format/src/locale.js");


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__.default)(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}


/***/ }),

/***/ "../../node_modules/d3-time-format/src/locale.js":
/*!*******************************************************!*\
  !*** ../../node_modules/d3-time-format/src/locale.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatLocale)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcYear.js");


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.ceil(week) : (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_1__.default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.ceil(week) : (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.monday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_3__.default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_3__.default.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d), d) + ((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_1__.default.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcSunday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d), d) + ((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}


/***/ }),

/***/ "../../node_modules/d3-time/src/day.js":
/*!*********************************************!*\
  !*** ../../node_modules/d3-time/src/day.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "days": () => (/* binding */ days)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var day = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(
  date => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay,
  date => date.getDate() - 1
);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (day);
var days = day.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/duration.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-time/src/duration.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "durationSecond": () => (/* binding */ durationSecond),
/* harmony export */   "durationMinute": () => (/* binding */ durationMinute),
/* harmony export */   "durationHour": () => (/* binding */ durationHour),
/* harmony export */   "durationDay": () => (/* binding */ durationDay),
/* harmony export */   "durationWeek": () => (/* binding */ durationWeek),
/* harmony export */   "durationMonth": () => (/* binding */ durationMonth),
/* harmony export */   "durationYear": () => (/* binding */ durationYear)
/* harmony export */ });
const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;


/***/ }),

/***/ "../../node_modules/d3-time/src/hour.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-time/src/hour.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "hours": () => (/* binding */ hours)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var hour = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond - date.getMinutes() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour;
}, function(date) {
  return date.getHours();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hour);
var hours = hour.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/interval.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-time/src/interval.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ newInterval)
/* harmony export */ });
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),

/***/ "../../node_modules/d3-time/src/millisecond.js":
/*!*****************************************************!*\
  !*** ../../node_modules/d3-time/src/millisecond.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "milliseconds": () => (/* binding */ milliseconds)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var millisecond = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (millisecond);
var milliseconds = millisecond.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/minute.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-time/src/minute.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "minutes": () => (/* binding */ minutes)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var minute = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute;
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (minute);
var minutes = minute.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/month.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-time/src/month.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "months": () => (/* binding */ months)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var month = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (month);
var months = month.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/second.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-time/src/second.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "seconds": () => (/* binding */ seconds)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var second = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (second);
var seconds = second.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/ticks.js":
/*!***********************************************!*\
  !*** ../../node_modules/d3-time/src/ticks.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcTicks": () => (/* binding */ utcTicks),
/* harmony export */   "utcTickInterval": () => (/* binding */ utcTickInterval),
/* harmony export */   "timeTicks": () => (/* binding */ timeTicks),
/* harmony export */   "timeTickInterval": () => (/* binding */ timeTickInterval)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisector.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");
/* harmony import */ var _millisecond_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./millisecond.js */ "../../node_modules/d3-time/src/millisecond.js");
/* harmony import */ var _second_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./second.js */ "../../node_modules/d3-time/src/second.js");
/* harmony import */ var _minute_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./minute.js */ "../../node_modules/d3-time/src/minute.js");
/* harmony import */ var _hour_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hour.js */ "../../node_modules/d3-time/src/hour.js");
/* harmony import */ var _day_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./day.js */ "../../node_modules/d3-time/src/day.js");
/* harmony import */ var _week_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./week.js */ "../../node_modules/d3-time/src/week.js");
/* harmony import */ var _month_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./month.js */ "../../node_modules/d3-time/src/month.js");
/* harmony import */ var _year_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./year.js */ "../../node_modules/d3-time/src/year.js");
/* harmony import */ var _utcMinute_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utcMinute.js */ "../../node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var _utcHour_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utcHour.js */ "../../node_modules/d3-time/src/utcHour.js");
/* harmony import */ var _utcDay_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utcDay.js */ "../../node_modules/d3-time/src/utcDay.js");
/* harmony import */ var _utcWeek_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utcWeek.js */ "../../node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var _utcMonth_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utcMonth.js */ "../../node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var _utcYear_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utcYear.js */ "../../node_modules/d3-time/src/utcYear.js");

















function ticker(year, month, week, day, hour, minute) {

  const tickIntervals = [
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default,  5,  5 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default, 15, 15 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default, 30, 30 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [minute,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [minute,  5,  5 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [minute, 15, 15 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [minute, 30, 30 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [  hour,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [  hour,  3,  3 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [  hour,  6,  6 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [  hour, 12, 12 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [   day,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay   ],
    [   day,  2,  2 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay   ],
    [  week,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek  ],
    [ month,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMonth ],
    [ month,  3,  3 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMonth ],
    [  year,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationYear  ]
  ];

  function ticks(start, stop, count) {
    const reverse = stop < start;
    if (reverse) [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
    return reverse ? ticks.reverse() : ticks;
  }

  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(([,, step]) => step).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every((0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationYear, stop / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationYear, count));
    if (i === 0) return _millisecond_js__WEBPACK_IMPORTED_MODULE_4__.default.every(Math.max((0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }

  return [ticks, tickInterval];
}

const [utcTicks, utcTickInterval] = ticker(_utcYear_js__WEBPACK_IMPORTED_MODULE_5__.default, _utcMonth_js__WEBPACK_IMPORTED_MODULE_6__.default, _utcWeek_js__WEBPACK_IMPORTED_MODULE_7__.utcSunday, _utcDay_js__WEBPACK_IMPORTED_MODULE_8__.default, _utcHour_js__WEBPACK_IMPORTED_MODULE_9__.default, _utcMinute_js__WEBPACK_IMPORTED_MODULE_10__.default);
const [timeTicks, timeTickInterval] = ticker(_year_js__WEBPACK_IMPORTED_MODULE_11__.default, _month_js__WEBPACK_IMPORTED_MODULE_12__.default, _week_js__WEBPACK_IMPORTED_MODULE_13__.sunday, _day_js__WEBPACK_IMPORTED_MODULE_14__.default, _hour_js__WEBPACK_IMPORTED_MODULE_15__.default, _minute_js__WEBPACK_IMPORTED_MODULE_16__.default);




/***/ }),

/***/ "../../node_modules/d3-time/src/utcDay.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-time/src/utcDay.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcDays": () => (/* binding */ utcDays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var utcDay = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcDay);
var utcDays = utcDay.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcHour.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-time/src/utcHour.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcHours": () => (/* binding */ utcHours)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var utcHour = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour;
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcHour);
var utcHours = utcHour.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcMinute.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-time/src/utcMinute.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcMinutes": () => (/* binding */ utcMinutes)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



var utcMinute = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcMonth.js":
/*!**************************************************!*\
  !*** ../../node_modules/d3-time/src/utcMonth.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcMonths": () => (/* binding */ utcMonths)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var utcMonth = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcWeek.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-time/src/utcWeek.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcSunday": () => (/* binding */ utcSunday),
/* harmony export */   "utcMonday": () => (/* binding */ utcMonday),
/* harmony export */   "utcTuesday": () => (/* binding */ utcTuesday),
/* harmony export */   "utcWednesday": () => (/* binding */ utcWednesday),
/* harmony export */   "utcThursday": () => (/* binding */ utcThursday),
/* harmony export */   "utcFriday": () => (/* binding */ utcFriday),
/* harmony export */   "utcSaturday": () => (/* binding */ utcSaturday),
/* harmony export */   "utcSundays": () => (/* binding */ utcSundays),
/* harmony export */   "utcMondays": () => (/* binding */ utcMondays),
/* harmony export */   "utcTuesdays": () => (/* binding */ utcTuesdays),
/* harmony export */   "utcWednesdays": () => (/* binding */ utcWednesdays),
/* harmony export */   "utcThursdays": () => (/* binding */ utcThursdays),
/* harmony export */   "utcFridays": () => (/* binding */ utcFridays),
/* harmony export */   "utcSaturdays": () => (/* binding */ utcSaturdays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



function utcWeekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/utcYear.js":
/*!*************************************************!*\
  !*** ../../node_modules/d3-time/src/utcYear.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcYears": () => (/* binding */ utcYears)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var utcYear = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcYear);
var utcYears = utcYear.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/week.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-time/src/week.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sunday": () => (/* binding */ sunday),
/* harmony export */   "monday": () => (/* binding */ monday),
/* harmony export */   "tuesday": () => (/* binding */ tuesday),
/* harmony export */   "wednesday": () => (/* binding */ wednesday),
/* harmony export */   "thursday": () => (/* binding */ thursday),
/* harmony export */   "friday": () => (/* binding */ friday),
/* harmony export */   "saturday": () => (/* binding */ saturday),
/* harmony export */   "sundays": () => (/* binding */ sundays),
/* harmony export */   "mondays": () => (/* binding */ mondays),
/* harmony export */   "tuesdays": () => (/* binding */ tuesdays),
/* harmony export */   "wednesdays": () => (/* binding */ wednesdays),
/* harmony export */   "thursdays": () => (/* binding */ thursdays),
/* harmony export */   "fridays": () => (/* binding */ fridays),
/* harmony export */   "saturdays": () => (/* binding */ saturdays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "../../node_modules/d3-time/src/duration.js");



function weekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),

/***/ "../../node_modules/d3-time/src/year.js":
/*!**********************************************!*\
  !*** ../../node_modules/d3-time/src/year.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "years": () => (/* binding */ years)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "../../node_modules/d3-time/src/interval.js");


var year = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (year);
var years = year.range;


/***/ }),

/***/ "../../node_modules/d3-timer/src/interval.js":
/*!***************************************************!*\
  !*** ../../node_modules/d3-timer/src/interval.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "../../node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  t._restart = t.restart;
  t.restart = function(callback, delay, time) {
    delay = +delay, time = time == null ? (0,_timer_js__WEBPACK_IMPORTED_MODULE_0__.now)() : +time;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
  }
  t.restart(callback, delay, time);
  return t;
}


/***/ }),

/***/ "../../node_modules/d3-timer/src/timer.js":
/*!************************************************!*\
  !*** ../../node_modules/d3-timer/src/timer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "Timer": () => (/* binding */ Timer),
/* harmony export */   "timer": () => (/* binding */ timer),
/* harmony export */   "timerFlush": () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "../../node_modules/delaunator/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/delaunator/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Delaunator)
/* harmony export */ });

const EPSILON = Math.pow(2, -52);
const EDGE_STACK = new Uint32Array(512);

class Delaunator {

    static from(points, getX = defaultGetX, getY = defaultGetY) {
        const n = points.length;
        const coords = new Float64Array(n * 2);

        for (let i = 0; i < n; i++) {
            const p = points[i];
            coords[2 * i] = getX(p);
            coords[2 * i + 1] = getY(p);
        }

        return new Delaunator(coords);
    }

    constructor(coords) {
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

        this.coords = coords;

        // arrays that will store the triangulation graph
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);

        // temporary arrays for tracking the edges of the advancing convex hull
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n); // edge to prev edge
        this._hullNext = new Uint32Array(n); // edge to next edge
        this._hullTri = new Uint32Array(n); // edge to adjacent triangle
        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

        // temporary arrays for sorting points
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);

        this.update();
    }

    update() {
        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
        const n = coords.length >> 1;

        // populate an array of point indices; calculate input data bbox
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        for (let i = 0; i < n; i++) {
            const x = coords[2 * i];
            const y = coords[2 * i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            this._ids[i] = i;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;

        let minDist = Infinity;
        let i0, i1, i2;

        // pick a seed point close to the center
        for (let i = 0; i < n; i++) {
            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist) {
                i0 = i;
                minDist = d;
            }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];

        minDist = Infinity;

        // find the point closest to the seed
        for (let i = 0; i < n; i++) {
            if (i === i0) continue;
            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist && d > 0) {
                i1 = i;
                minDist = d;
            }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];

        let minRadius = Infinity;

        // find the third point which forms the smallest circumcircle with the first two
        for (let i = 0; i < n; i++) {
            if (i === i0 || i === i1) continue;
            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
            if (r < minRadius) {
                i2 = i;
                minRadius = r;
            }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];

        if (minRadius === Infinity) {
            // order collinear points by dx (or dy if all x are identical)
            // and return the list as a hull
            for (let i = 0; i < n; i++) {
                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
            }
            quicksort(this._ids, this._dists, 0, n - 1);
            const hull = new Uint32Array(n);
            let j = 0;
            for (let i = 0, d0 = -Infinity; i < n; i++) {
                const id = this._ids[i];
                if (this._dists[id] > d0) {
                    hull[j++] = id;
                    d0 = this._dists[id];
                }
            }
            this.hull = hull.subarray(0, j);
            this.triangles = new Uint32Array(0);
            this.halfedges = new Uint32Array(0);
            return;
        }

        // swap the order of the seed points for counter-clockwise orientation
        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
            const i = i1;
            const x = i1x;
            const y = i1y;
            i1 = i2;
            i1x = i2x;
            i1y = i2y;
            i2 = i;
            i2x = x;
            i2y = y;
        }

        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center.x;
        this._cy = center.y;

        for (let i = 0; i < n; i++) {
            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
        }

        // sort the points by distance from the seed triangle circumcenter
        quicksort(this._ids, this._dists, 0, n - 1);

        // set up the seed triangle as the starting hull
        this._hullStart = i0;
        let hullSize = 3;

        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;

        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;

        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;

        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);

        for (let k = 0, xp, yp; k < this._ids.length; k++) {
            const i = this._ids[k];
            const x = coords[2 * i];
            const y = coords[2 * i + 1];

            // skip near-duplicate points
            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
            xp = x;
            yp = y;

            // skip seed triangle points
            if (i === i0 || i === i1 || i === i2) continue;

            // find a visible edge on the convex hull using edge hash
            let start = 0;
            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                start = hullHash[(key + j) % this._hashSize];
                if (start !== -1 && start !== hullNext[start]) break;
            }

            start = hullPrev[start];
            let e = start, q;
            while (q = hullNext[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
                e = q;
                if (e === start) {
                    e = -1;
                    break;
                }
            }
            if (e === -1) continue; // likely a near-duplicate point; skip it

            // add the first triangle from the point
            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

            // recursively flip triangles from the point until they satisfy the Delaunay condition
            hullTri[i] = this._legalize(t + 2);
            hullTri[e] = t; // keep track of boundary triangles on the hull
            hullSize++;

            // walk forward through the hull, adding more triangles and flipping recursively
            let n = hullNext[e];
            while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1])) {
                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                hullTri[i] = this._legalize(t + 2);
                hullNext[n] = n; // mark as removed
                hullSize--;
                n = q;
            }

            // walk backward from the other side, adding more triangles and flipping
            if (e === start) {
                while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                    this._legalize(t + 2);
                    hullTri[q] = t;
                    hullNext[e] = e; // mark as removed
                    hullSize--;
                    e = q;
                }
            }

            // update the hull indices
            this._hullStart = hullPrev[i] = e;
            hullNext[e] = hullPrev[n] = i;
            hullNext[i] = n;

            // save the two new edges in the hash table
            hullHash[this._hashKey(x, y)] = i;
            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
        }

        this.hull = new Uint32Array(hullSize);
        for (let i = 0, e = this._hullStart; i < hullSize; i++) {
            this.hull[i] = e;
            e = hullNext[e];
        }

        // trim typed triangle mesh arrays
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }

    _hashKey(x, y) {
        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
    }

    _legalize(a) {
        const {_triangles: triangles, _halfedges: halfedges, coords} = this;

        let i = 0;
        let ar = 0;

        // recursion eliminated with a fixed-size stack
        while (true) {
            const b = halfedges[a];

            /* if the pair of triangles doesn't satisfy the Delaunay condition
             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
             * then do the same check/flip recursively for the new pair of triangles
             *
             *           pl                    pl
             *          /||\                  /  \
             *       al/ || \bl            al/    \a
             *        /  ||  \              /      \
             *       /  a||b  \    flip    /___ar___\
             *     p0\   ||   /p1   =>   p0\---bl---/p1
             *        \  ||  /              \      /
             *       ar\ || /br             b\    /br
             *          \||/                  \  /
             *           pr                    pr
             */
            const a0 = a - a % 3;
            ar = a0 + (a + 2) % 3;

            if (b === -1) { // convex hull edge
                if (i === 0) break;
                a = EDGE_STACK[--i];
                continue;
            }

            const b0 = b - b % 3;
            const al = a0 + (a + 1) % 3;
            const bl = b0 + (b + 2) % 3;

            const p0 = triangles[ar];
            const pr = triangles[a];
            const pl = triangles[al];
            const p1 = triangles[bl];

            const illegal = inCircle(
                coords[2 * p0], coords[2 * p0 + 1],
                coords[2 * pr], coords[2 * pr + 1],
                coords[2 * pl], coords[2 * pl + 1],
                coords[2 * p1], coords[2 * p1 + 1]);

            if (illegal) {
                triangles[a] = p1;
                triangles[b] = p0;

                const hbl = halfedges[bl];

                // edge swapped on the other side of the hull (rare); fix the halfedge reference
                if (hbl === -1) {
                    let e = this._hullStart;
                    do {
                        if (this._hullTri[e] === bl) {
                            this._hullTri[e] = a;
                            break;
                        }
                        e = this._hullPrev[e];
                    } while (e !== this._hullStart);
                }
                this._link(a, hbl);
                this._link(b, halfedges[ar]);
                this._link(ar, bl);

                const br = b0 + (b + 1) % 3;

                // don't worry about hitting the cap: it can only happen on extremely degenerate input
                if (i < EDGE_STACK.length) {
                    EDGE_STACK[i++] = br;
                }
            } else {
                if (i === 0) break;
                a = EDGE_STACK[--i];
            }
        }

        return ar;
    }

    _link(a, b) {
        this._halfedges[a] = b;
        if (b !== -1) this._halfedges[b] = a;
    }

    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(i0, i1, i2, a, b, c) {
        const t = this.trianglesLen;

        this._triangles[t] = i0;
        this._triangles[t + 1] = i1;
        this._triangles[t + 2] = i2;

        this._link(t, a);
        this._link(t + 1, b);
        this._link(t + 2, c);

        this.trianglesLen += 3;

        return t;
    }
}

// monotonically increases with real angle, but doesn't need expensive trigonometry
function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
}

function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
}

// return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check
function orientIfSure(px, py, rx, ry, qx, qy) {
    const l = (ry - py) * (qx - px);
    const r = (rx - px) * (qy - py);
    return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;
}

// a more robust orientation test that's stable in a given triangle (to fix robustness issues)
function orient(rx, ry, qx, qy, px, py) {
    const sign = orientIfSure(px, py, rx, ry, qx, qy) ||
    orientIfSure(rx, ry, qx, qy, px, py) ||
    orientIfSure(qx, qy, px, py, rx, ry);
    return sign < 0;
}

function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;

    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;

    return dx * (ey * cp - bp * fy) -
           dy * (ex * cp - bp * fx) +
           ap * (ex * fy - ey * fx) < 0;
}

function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = (ey * bl - dy * cl) * d;
    const y = (dx * cl - ex * bl) * d;

    return x * x + y * y;
}

function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = ax + (ey * bl - dy * cl) * d;
    const y = ay + (dx * cl - ex * bl) * d;

    return {x, y};
}

function quicksort(ids, dists, left, right) {
    if (right - left <= 20) {
        for (let i = left + 1; i <= right; i++) {
            const temp = ids[i];
            const tempDist = dists[temp];
            let j = i - 1;
            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
            ids[j + 1] = temp;
        }
    } else {
        const median = (left + right) >> 1;
        let i = left + 1;
        let j = right;
        swap(ids, median, i);
        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

        const temp = ids[i];
        const tempDist = dists[temp];
        while (true) {
            do i++; while (dists[ids[i]] < tempDist);
            do j--; while (dists[ids[j]] > tempDist);
            if (j < i) break;
            swap(ids, i, j);
        }
        ids[left + 1] = ids[j];
        ids[j] = temp;

        if (right - i + 1 >= j - left) {
            quicksort(ids, dists, i, right);
            quicksort(ids, dists, left, j - 1);
        } else {
            quicksort(ids, dists, left, j - 1);
            quicksort(ids, dists, i, right);
        }
    }
}

function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultGetX(p) {
    return p[0];
}
function defaultGetY(p) {
    return p[1];
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/bbox.js":
/*!******************************************************!*\
  !*** ../../node_modules/topojson-client/src/bbox.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ "../../node_modules/topojson-client/src/transform.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  var t = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.default)(topology.transform), key,
      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/bisect.js":
/*!********************************************************!*\
  !*** ../../node_modules/topojson-client/src/bisect.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/feature.js":
/*!*********************************************************!*\
  !*** ../../node_modules/topojson-client/src/feature.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "object": () => (/* binding */ object)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "../../node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "../../node_modules/topojson-client/src/transform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature(topology, o); })}
      : feature(topology, o);
}

function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.default)(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0) (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__.default)(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/identity.js":
/*!**********************************************************!*\
  !*** ../../node_modules/topojson-client/src/identity.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/topojson-client/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bbox": () => (/* reexport safe */ _bbox_js__WEBPACK_IMPORTED_MODULE_0__.default),
/* harmony export */   "feature": () => (/* reexport safe */ _feature_js__WEBPACK_IMPORTED_MODULE_1__.default),
/* harmony export */   "mesh": () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.default),
/* harmony export */   "meshArcs": () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.meshArcs),
/* harmony export */   "merge": () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.default),
/* harmony export */   "mergeArcs": () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.mergeArcs),
/* harmony export */   "neighbors": () => (/* reexport safe */ _neighbors_js__WEBPACK_IMPORTED_MODULE_4__.default),
/* harmony export */   "quantize": () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_5__.default),
/* harmony export */   "transform": () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_6__.default),
/* harmony export */   "untransform": () => (/* reexport safe */ _untransform_js__WEBPACK_IMPORTED_MODULE_7__.default)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "../../node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ "../../node_modules/topojson-client/src/feature.js");
/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh.js */ "../../node_modules/topojson-client/src/mesh.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge.js */ "../../node_modules/topojson-client/src/merge.js");
/* harmony import */ var _neighbors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./neighbors.js */ "../../node_modules/topojson-client/src/neighbors.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quantize.js */ "../../node_modules/topojson-client/src/quantize.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transform.js */ "../../node_modules/topojson-client/src/transform.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./untransform.js */ "../../node_modules/topojson-client/src/untransform.js");










/***/ }),

/***/ "../../node_modules/topojson-client/src/merge.js":
/*!*******************************************************!*\
  !*** ../../node_modules/topojson-client/src/merge.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mergeArcs": () => (/* binding */ mergeArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "../../node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "../../node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea((0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__.default)(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/mesh.js":
/*!******************************************************!*\
  !*** ../../node_modules/topojson-client/src/mesh.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "meshArcs": () => (/* binding */ meshArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "../../node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "../../node_modules/topojson-client/src/stitch.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__.default)(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/neighbors.js":
/*!***********************************************************!*\
  !*** ../../node_modules/topojson-client/src/neighbors.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bisect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect.js */ "../../node_modules/topojson-client/src/bisect.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__.default)(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__.default)(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/quantize.js":
/*!**********************************************************!*\
  !*** ../../node_modules/topojson-client/src/quantize.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "../../node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./untransform.js */ "../../node_modules/topojson-client/src/untransform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
    box = topology.bbox || (0,_bbox_js__WEBPACK_IMPORTED_MODULE_0__.default)(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
  } else {
    box = topology.bbox;
  }

  var t = (0,_untransform_js__WEBPACK_IMPORTED_MODULE_1__.default)(transform), box, key, inputs = topology.objects, outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
      case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
      case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
      default: return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
    output[0] = t(input[0], 0);
    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
    output.length = j;
    return output;
  }

  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/reverse.js":
/*!*********************************************************!*\
  !*** ../../node_modules/topojson-client/src/reverse.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/stitch.js":
/*!********************************************************!*\
  !*** ../../node_modules/topojson-client/src/stitch.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/transform.js":
/*!***********************************************************!*\
  !*** ../../node_modules/topojson-client/src/transform.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "../../node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__.default;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "../../node_modules/topojson-client/src/untransform.js":
/*!*************************************************************!*\
  !*** ../../node_modules/topojson-client/src/untransform.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "../../node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__.default;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "../../node_modules/vega-canvas/index.browser.js":
/*!*******************************************************!*\
  !*** ../../node_modules/vega-canvas/index.browser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "domCanvas": () => (/* reexport safe */ _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__.domCanvas),
/* harmony export */   "canvas": () => (/* reexport safe */ _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__.domCanvas),
/* harmony export */   "image": () => (/* reexport safe */ _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__.domImage)
/* harmony export */ });
/* harmony import */ var _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/domCanvas */ "../../node_modules/vega-canvas/src/domCanvas.js");



/***/ }),

/***/ "../../node_modules/vega-canvas/src/domCanvas.js":
/*!*******************************************************!*\
  !*** ../../node_modules/vega-canvas/src/domCanvas.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "domCanvas": () => (/* binding */ domCanvas),
/* harmony export */   "domImage": () => (/* binding */ domImage)
/* harmony export */ });
function domCanvas(w, h) {
  if (typeof document !== 'undefined' && document.createElement) {
    const c = document.createElement('canvas');
    if (c && c.getContext) {
      c.width = w;
      c.height = h;
      return c;
    }
  }
  return null;
}

const domImage = () =>
  typeof Image !== 'undefined' ? Image : null;


/***/ }),

/***/ "../../node_modules/vega-crossfilter/build/vega-crossfilter.module.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/vega-crossfilter/build/vega-crossfilter.module.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "crossfilter": () => (/* binding */ CrossFilter),
/* harmony export */   "resolvefilter": () => (/* binding */ ResolveFilter)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/permute.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");




const array8 = n => new Uint8Array(n);
const array16 = n => new Uint16Array(n);
const array32 = n => new Uint32Array(n);

/**
 * Maintains CrossFilter state.
 */

function Bitmaps() {
  let width = 8,
      data = [],
      seen = array32(0),
      curr = array(0, width),
      prev = array(0, width);
  return {
    data: () => data,
    seen: () => seen = lengthen(seen, data.length),

    add(array) {
      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {
        t = array[i];
        t._index = j++;
        data.push(t);
      }
    },

    remove(num, map) {
      // map: index -> boolean (true => remove)
      const n = data.length,
            copy = Array(n - num),
            reindex = data; // reuse old data array for index map

      let t, i, j; // seek forward to first removal

      for (i = 0; !map[i] && i < n; ++i) {
        copy[i] = data[i];
        reindex[i] = i;
      } // condense arrays


      for (j = i; i < n; ++i) {
        t = data[i];

        if (!map[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy[j] = t;
          t._index = j++;
        } else {
          reindex[i] = -1;
        }

        curr[i] = 0; // clear unused bits
      }

      data = copy;
      return reindex;
    },

    size: () => data.length,
    curr: () => curr,
    prev: () => prev,
    reset: k => prev[k] = curr[k],
    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,

    set(k, one) {
      curr[k] |= one;
    },

    clear(k, one) {
      curr[k] &= ~one;
    },

    resize(n, m) {
      const k = curr.length;

      if (n > k || m > width) {
        width = Math.max(m, width);
        curr = array(n, width, curr);
        prev = array(n, width);
      }
    }

  };
}

function lengthen(array, length, copy) {
  if (array.length >= length) return array;
  copy = copy || new array.constructor(length);
  copy.set(array);
  return copy;
}

function array(n, m, array) {
  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);
  if (array) copy.set(array);
  return copy;
}

function Dimension (index, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index.bisect,
    index: index.index,
    size: index.size,

    onAdd(added, curr) {
      const dim = this,
            range = dim.bisect(dim.range, added.value),
            idx = added.index,
            lo = range[0],
            hi = range[1],
            n1 = idx.length;
      let i;

      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;

      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;

      return dim;
    }

  };
}

/**
 * Maintains a list of values, sorted by key.
 */

function SortedIndex() {
  let index = array32(0),
      value = [],
      size = 0;

  function insert(key, data, base) {
    if (!data.length) return [];
    const n0 = size,
          n1 = data.length,
          addi = array32(n1);
    let addv = Array(n1),
        oldv,
        oldi,
        i;

    for (i = 0; i < n1; ++i) {
      addv[i] = key(data[i]);
      addi[i] = i;
    }

    addv = sort(addv, addi);

    if (n0) {
      oldv = value;
      oldi = index;
      value = Array(n0 + n1);
      index = array32(n0 + n1);
      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);
    } else {
      if (base > 0) for (i = 0; i < n1; ++i) {
        addi[i] += base;
      }
      value = addv;
      index = addi;
    }

    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }

  function remove(num, map) {
    // map: index -> remove
    const n = size;
    let idx, i, j; // seek forward to first removal

    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays


    for (j = i; i < n; ++i) {
      if (!map[idx = index[i]]) {
        index[j] = idx;
        value[j] = value[i];
        ++j;
      }
    }

    size = n - num;
  }

  function reindex(map) {
    for (let i = 0, n = size; i < n; ++i) {
      index[i] = map[index[i]];
    }
  }

  function bisect(range, array) {
    let n;

    if (array) {
      n = array.length;
    } else {
      array = value;
      n = size;
    }

    return [(0,d3_array__WEBPACK_IMPORTED_MODULE_2__.bisectLeft)(array, range[0], 0, n), (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.bisectRight)(array, range[1], 0, n)];
  }

  return {
    insert: insert,
    remove: remove,
    bisect: bisect,
    reindex: reindex,
    index: () => index,
    size: () => size
  };
}

function sort(values, index) {
  values.sort.call(index, (a, b) => {
    const x = values[a],
          y = values[b];
    return x < y ? -1 : x > y ? 1 : 0;
  });
  return (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(values, index);
}

function merge(base, value0, index0, n0, value1, index1, n1, value, index) {
  let i0 = 0,
      i1 = 0,
      i;

  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value[i] = value0[i0];
      index[i] = index0[i0++];
    } else {
      value[i] = value1[i1];
      index[i] = index1[i1++] + base;
    }
  }

  for (; i0 < n0; ++i0, ++i) {
    value[i] = value0[i0];
    index[i] = index0[i0];
  }

  for (; i1 < n1; ++i1, ++i) {
    value[i] = value1[i1];
    index[i] = index1[i1] + base;
  }
}

/**
 * An indexed multi-dimensional filter.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.
 * @param {Array} params.query - An array of per-dimension range queries.
 */

function CrossFilter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, Bitmaps(), params);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  'type': 'CrossFilter',
  'metadata': {},
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'query',
    'type': 'array',
    'array': true,
    'required': true,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(CrossFilter, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!this._dims) {
      return this.init(_, pulse);
    } else {
      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));

      return init ? this.reinit(_, pulse) : this.eval(_, pulse);
    }
  },

  init(_, pulse) {
    const fields = _.fields,
          query = _.query,
          indices = this._indices = {},
          dims = this._dims = [],
          m = query.length;
    let i = 0,
        key,
        index; // instantiate indices and dimensions

    for (; i < m; ++i) {
      key = fields[i].fname;
      index = indices[key] || (indices[key] = SortedIndex());
      dims.push(Dimension(index, i, query[i]));
    }

    return this.eval(_, pulse);
  },

  reinit(_, pulse) {
    const output = pulse.materialize().fork(),
          fields = _.fields,
          query = _.query,
          indices = this._indices,
          dims = this._dims,
          bits = this.value,
          curr = bits.curr(),
          prev = bits.prev(),
          all = bits.all(),
          out = output.rem = output.add,
          mod = output.mod,
          m = query.length,
          adds = {};
    let add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state

    prev.set(curr); // if pulse has remove tuples, process them first

    if (pulse.rem.length) {
      remMap = this.remove(_, pulse, output);
    } // if pulse has added tuples, add them to state


    if (pulse.add.length) {
      bits.add(pulse.add);
    } // if pulse has modified tuples, create an index map


    if (pulse.mod.length) {
      modMap = {};

      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    } // re-initialize indices as needed, update curr bitmap


    for (i = 0; i < m; ++i) {
      f = fields[i];

      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {
        key = f.fname;

        if (!(add = adds[key])) {
          indices[key] = index = SortedIndex();
          adds[key] = add = index.insert(f, pulse.source, 0);
        }

        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);
      }
    } // visit each tuple
    // if filter state changed, push index to add/rem
    // else if in mod and passes a filter, push index to mod


    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        // skip if removed tuple
        continue;
      } else if (prev[i] !== curr[i]) {
        // add if state changed
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        // otherwise, pass mods through
        mod.push(i);
      }
    }

    bits.mask = (1 << m) - 1;
    return output;
  },

  eval(_, pulse) {
    const output = pulse.materialize().fork(),
          m = this._dims.length;
    let mask = 0;

    if (pulse.rem.length) {
      this.remove(_, pulse, output);
      mask |= (1 << m) - 1;
    }

    if (_.modified('query') && !_.modified('fields')) {
      mask |= this.update(_, pulse, output);
    }

    if (pulse.add.length) {
      this.insert(_, pulse, output);
      mask |= (1 << m) - 1;
    }

    if (pulse.mod.length) {
      this.modify(pulse, output);
      mask |= (1 << m) - 1;
    }

    this.value.mask = mask;
    return output;
  },

  insert(_, pulse, output) {
    const tuples = pulse.add,
          bits = this.value,
          dims = this._dims,
          indices = this._indices,
          fields = _.fields,
          adds = {},
          out = output.add,
          n = bits.size() + tuples.length,
          m = dims.length;
    let k = bits.size(),
        j,
        key,
        add; // resize bitmaps and add tuples as needed

    bits.resize(n, m);
    bits.add(tuples);
    const curr = bits.curr(),
          prev = bits.prev(),
          all = bits.all(); // add to dimensional indices

    for (j = 0; j < m; ++j) {
      key = fields[j].fname;
      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));
      dims[j].onAdd(add, curr);
    } // set previous filters, output if passes at least one filter


    for (; k < n; ++k) {
      prev[k] = all;
      if (curr[k] !== all) out.push(k);
    }
  },

  modify(pulse, output) {
    const out = output.mod,
          bits = this.value,
          curr = bits.curr(),
          all = bits.all(),
          tuples = pulse.mod;
    let i, n, k;

    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      if (curr[k] !== all) out.push(k);
    }
  },

  remove(_, pulse, output) {
    const indices = this._indices,
          bits = this.value,
          curr = bits.curr(),
          prev = bits.prev(),
          all = bits.all(),
          map = {},
          out = output.rem,
          tuples = pulse.rem;
    let i, n, k, f; // process tuples, output if passes at least one filter

    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      map[k] = 1; // build index map

      prev[k] = f = curr[k];
      curr[k] = all;
      if (f !== all) out.push(k);
    } // remove from dimensional indices


    for (k in indices) {
      indices[k].remove(n, map);
    }

    this.reindex(pulse, n, map);
    return map;
  },

  // reindex filters and indices after propagation completes
  reindex(pulse, num, map) {
    const indices = this._indices,
          bits = this.value;
    pulse.runAfter(() => {
      const indexMap = bits.remove(num, map);

      for (const key in indices) indices[key].reindex(indexMap);
    });
  },

  update(_, pulse, output) {
    const dims = this._dims,
          query = _.query,
          stamp = pulse.stamp,
          m = dims.length;
    let mask = 0,
        i,
        q; // survey how many queries have changed

    output.filters = 0;

    for (q = 0; q < m; ++q) {
      if (_.modified('query', q)) {
        i = q;
        ++mask;
      }
    }

    if (mask === 1) {
      // only one query changed, use more efficient update
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output.add, output.rem);
    } else {
      // multiple queries changed, perform full record keeping
      for (q = 0, mask = 0; q < m; ++q) {
        if (!_.modified('query', q)) continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output.add);
        output.rem = output.add; // duplicate add/rem for downstream resolve
      }
    }

    return mask;
  },

  incrementAll(dim, query, stamp, out) {
    const bits = this.value,
          seen = bits.seen(),
          curr = bits.curr(),
          prev = bits.prev(),
          index = dim.index(),
          old = dim.bisect(dim.range),
          range = dim.bisect(query),
          lo1 = range[0],
          hi1 = range[1],
          lo0 = old[0],
          hi0 = old[1],
          one = dim.one;
    let i, j, k; // Fast incremental update based on previous lo index.

    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    } // Fast incremental update based on previous hi index.


    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    }

    dim.range = query.slice();
  },

  incrementOne(dim, query, add, rem) {
    const bits = this.value,
          curr = bits.curr(),
          index = dim.index(),
          old = dim.bisect(dim.range),
          range = dim.bisect(query),
          lo1 = range[0],
          hi1 = range[1],
          lo0 = old[0],
          hi0 = old[1],
          one = dim.one;
    let i, j, k; // Fast incremental update based on previous lo index.

    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        add.push(k);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        rem.push(k);
      }
    } // Fast incremental update based on previous hi index.


    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        add.push(k);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        rem.push(k);
      }
    }

    dim.range = query.slice();
  }

});

/**
 * Selectively filters tuples by resolving against a filter bitmap.
 * Useful for processing the output of a cross-filter transform.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.ignore - A bit mask indicating which filters to ignore.
 * @param {object} params.filter - The per-tuple filter bitmaps. Typically this
 *   parameter value is a reference to a {@link CrossFilter} transform.
 */

function ResolveFilter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
ResolveFilter.Definition = {
  'type': 'ResolveFilter',
  'metadata': {},
  'params': [{
    'name': 'ignore',
    'type': 'number',
    'required': true,
    'description': 'A bit mask indicating which filters to ignore.'
  }, {
    'name': 'filter',
    'type': 'object',
    'required': true,
    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(ResolveFilter, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const ignore = ~(_.ignore || 0),
          // bit mask where zeros -> dims to ignore
    bitmap = _.filter,
          mask = bitmap.mask; // exit early if no relevant filter changes

    if ((mask & ignore) === 0) return pulse.StopPropagation;

    const output = pulse.fork(pulse.ALL),
          data = bitmap.data(),
          curr = bitmap.curr(),
          prev = bitmap.prev(),
          pass = k => !(curr[k] & ignore) ? data[k] : null; // propagate all mod tuples that pass the filter


    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions
    // for efficiency, we do *not* populate new arrays,
    // instead we add filter functions applied downstream

    if (!(mask & mask - 1)) {
      // only one filter changed
      output.filter(output.ADD, pass);
      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);
    } else {
      // multiple filters changed
      output.filter(output.ADD, k => {
        const c = curr[k] & ignore,
              f = !c && c ^ prev[k] & ignore;
        return f ? data[k] : null;
      });
      output.filter(output.REM, k => {
        const c = curr[k] & ignore,
              f = c && !(c ^ (c ^ prev[k] & ignore));
        return f ? data[k] : null;
      });
    } // add filter to source data in case of reflow...


    return output.filter(output.SOURCE, t => pass(t._index));
  }

});




/***/ }),

/***/ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/vega-dataflow/build/vega-dataflow.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dataflow": () => (/* binding */ Dataflow),
/* harmony export */   "EventStream": () => (/* binding */ EventStream),
/* harmony export */   "MultiPulse": () => (/* binding */ MultiPulse),
/* harmony export */   "Operator": () => (/* binding */ Operator),
/* harmony export */   "Parameters": () => (/* binding */ Parameters),
/* harmony export */   "Pulse": () => (/* binding */ Pulse),
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "UniqueList": () => (/* binding */ UniqueList),
/* harmony export */   "asyncCallback": () => (/* binding */ asyncCallback),
/* harmony export */   "changeset": () => (/* binding */ changeset),
/* harmony export */   "definition": () => (/* binding */ definition),
/* harmony export */   "derive": () => (/* binding */ derive),
/* harmony export */   "ingest": () => (/* binding */ ingest$1),
/* harmony export */   "isChangeSet": () => (/* binding */ isChangeSet),
/* harmony export */   "isTuple": () => (/* binding */ isTuple),
/* harmony export */   "rederive": () => (/* binding */ rederive),
/* harmony export */   "replace": () => (/* binding */ replace),
/* harmony export */   "stableCompare": () => (/* binding */ stableCompare),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transforms": () => (/* binding */ transforms),
/* harmony export */   "tupleid": () => (/* binding */ tupleid)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-loader */ "../../node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-format */ "../../node_modules/vega-format/build/vega-format.module.js");




function UniqueList(idFunc) {
  const $ = idFunc || vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,
        list = [],
        ids = {};

  list.add = _ => {
    const id = $(_);

    if (!ids[id]) {
      ids[id] = 1;
      list.push(_);
    }

    return list;
  };

  list.remove = _ => {
    const id = $(_);

    if (ids[id]) {
      ids[id] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0) list.splice(idx, 1);
    }

    return list;
  };

  return list;
}

/**
 * Invoke and await a potentially async callback function. If
 * an error occurs, trap it and route to Dataflow.error.
 * @param {Dataflow} df - The dataflow instance
 * @param {function} callback - A callback function to invoke
 *   and then await. The dataflow will be passed as the single
 *   argument to the function.
 */
async function asyncCallback (df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}

const TUPLE_ID_KEY = Symbol('vega_id');
let TUPLE_ID = 1;
/**
 * Checks if an input value is a registered tuple.
 * @param {*} t - The value to check.
 * @return {boolean} True if the input is a tuple, false otherwise.
 */

function isTuple(t) {
  return !!(t && tupleid(t));
}
/**
 * Returns the id of a tuple.
 * @param {object} t - The input tuple.
 * @return {*} the tuple id.
 */

function tupleid(t) {
  return t[TUPLE_ID_KEY];
}
/**
 * Sets the id of a tuple.
 * @param {object} t - The input tuple.
 * @param {*} id - The id value to set.
 * @return {object} the input tuple.
 */

function setid(t, id) {
  t[TUPLE_ID_KEY] = id;
  return t;
}
/**
 * Ingest an object or value as a data tuple.
 * If the input value is an object, an id field will be added to it. For
 * efficiency, the input object is modified directly. A copy is not made.
 * If the input value is a literal, it will be wrapped in a new object
 * instance, with the value accessible as the 'data' property.
 * @param datum - The value to ingest.
 * @return {object} The ingested data tuple.
 */


function ingest$1(datum) {
  const t = datum === Object(datum) ? datum : {
    data: datum
  };
  return tupleid(t) ? t : setid(t, TUPLE_ID++);
}
/**
 * Given a source tuple, return a derived copy.
 * @param {object} t - The source tuple.
 * @return {object} The derived tuple.
 */

function derive(t) {
  return rederive(t, ingest$1({}));
}
/**
 * Rederive a derived tuple by copying values from the source tuple.
 * @param {object} t - The source tuple.
 * @param {object} d - The derived tuple.
 * @return {object} The derived tuple.
 */

function rederive(t, d) {
  for (const k in t) d[k] = t[k];

  return d;
}
/**
 * Replace an existing tuple with a new tuple.
 * @param {object} t - The existing data tuple.
 * @param {object} d - The new tuple that replaces the old.
 * @return {object} The new tuple.
 */

function replace(t, d) {
  return setid(d, tupleid(t));
}
/**
 * Generate an augmented comparator function that provides stable
 * sorting by tuple id when the given comparator produces ties.
 * @param {function} cmp - The comparator to augment.
 * @param {function} [f] - Optional tuple accessor function.
 * @return {function} An augmented comparator function.
 */

function stableCompare(cmp, f) {
  return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);
}

function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add = [],
        // insert tuples
  rem = [],
        // remove tuples
  mod = [],
        // modify tuples
  remp = [],
        // remove by predicate
  modp = []; // modify by predicate

  let clean = null,
      reflow = false;
  return {
    constructor: changeset,

    insert(t) {
      const d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(t),
            n = d.length;

      for (let i = 0; i < n; ++i) add.push(d[i]);

      return this;
    },

    remove(t) {
      const a = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t) ? remp : rem,
            d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(t),
            n = d.length;

      for (let i = 0; i < n; ++i) a.push(d[i]);

      return this;
    },

    modify(t, field, value) {
      const m = {
        field: field,
        value: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(value)
      };

      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t)) {
        m.filter = t;
        modp.push(m);
      } else {
        m.tuple = t;
        mod.push(m);
      }

      return this;
    },

    encode(t, set) {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t)) modp.push({
        filter: t,
        field: set
      });else mod.push({
        tuple: t,
        field: set
      });
      return this;
    },

    clean(value) {
      clean = value;
      return this;
    },

    reflow() {
      reflow = true;
      return this;
    },

    pulse(pulse, tuples) {
      const cur = {},
            out = {};
      let i, n, m, f, t, id; // build lookup table of current tuples

      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      } // process individual tuples to remove


      for (i = 0, n = rem.length; i < n; ++i) {
        t = rem[i];
        cur[tupleid(t)] = -1;
      } // process predicate-based removals


      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach(t => {
          if (f(t)) cur[tupleid(t)] = -1;
        });
      } // process all add tuples


      for (i = 0, n = add.length; i < n; ++i) {
        t = add[i];
        id = tupleid(t);

        if (cur[id]) {
          // tuple already resides in dataset
          // if flagged for both add and remove, cancel
          cur[id] = 1;
        } else {
          // tuple does not reside in dataset, add
          pulse.add.push(ingest$1(add[i]));
        }
      } // populate pulse rem list


      for (i = 0, n = tuples.length; i < n; ++i) {
        t = tuples[i];
        if (cur[tupleid(t)] < 0) pulse.rem.push(t);
      } // modify helper method


      function modify(t, f, v) {
        if (v) {
          t[f] = v(t);
        } else {
          pulse.encode = f;
        }

        if (!reflow) out[tupleid(t)] = t;
      } // process individual tuples to modify


      for (i = 0, n = mod.length; i < n; ++i) {
        m = mod[i];
        t = m.tuple;
        f = m.field;
        id = cur[tupleid(t)];

        if (id > 0) {
          modify(t, f, m.value);
          pulse.modifies(f);
        }
      } // process predicate-based modifications


      for (i = 0, n = modp.length; i < n; ++i) {
        m = modp[i];
        f = m.filter;
        tuples.forEach(t => {
          if (f(t) && cur[tupleid(t)] > 0) {
            modify(t, m.field, m.value);
          }
        });
        pulse.modifies(m.field);
      } // upon reflow request, populate mod with all non-removed tuples
      // otherwise, populate mod with modified tuples only


      if (reflow) {
        pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();
      } else {
        for (id in out) pulse.mod.push(out[id]);
      } // set pulse garbage collection request


      if (clean || clean == null && (rem.length || remp.length)) {
        pulse.clean(true);
      }

      return pulse;
    }

  };
}

const CACHE = '_:mod:_';
/**
 * Hash that tracks modifications to assigned values.
 * Callers *must* use the set method to update values.
 */

function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(name, index, value, force) {
    const o = this,
          v = o[name],
          mod = o[CACHE];

    if (index != null && index >= 0) {
      if (v[index] !== value || force) {
        v[index] = value;
        mod[index + ':' + name] = -1;
        mod[name] = -1;
      }
    } else if (v !== value || force) {
      o[name] = value;
      mod[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? 1 + value.length : -1;
    }

    return o;
  },

  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(name, index) {
    const mod = this[CACHE];

    if (!arguments.length) {
      for (const k in mod) {
        if (mod[k]) return true;
      }

      return false;
    } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(name)) {
      for (let k = 0; k < name.length; ++k) {
        if (mod[name[k]]) return true;
      }

      return false;
    }

    return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];
  },

  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    this[CACHE] = {};
    return this;
  }

};

let OP_ID = 0;
const PULSE = 'pulse',
      NO_PARAMS = new Parameters(); // Boolean Flags

const SKIP$1 = 1,
      MODIFIED = 2;
/**
 * An Operator is a processing node in a dataflow graph.
 * Each operator stores a value and an optional value update function.
 * Operators can accept a hash of named parameters. Parameter values can
 * either be direct (JavaScript literals, arrays, objects) or indirect
 * (other operators whose values will be pulled dynamically). Operators
 * included as parameters will have this operator added as a dependency.
 * @constructor
 * @param {*} [init] - The initial value for this operator.
 * @param {function(object, Pulse)} [update] - An update function. Upon
 *   evaluation of this operator, the update function will be invoked and the
 *   return value will be used as the new value of this operator.
 * @param {object} [params] - The parameters for this operator.
 * @param {boolean} [react=true] - Flag indicating if this operator should
 *   listen for changes to upstream operators included as parameters.
 * @see parameters
 */

function Operator(init, update, params, react) {
  this.id = ++OP_ID;
  this.value = init;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;

  if (update) {
    this._update = update;
  }

  if (params) this.parameters(params, react);
}

function flag(bit) {
  return function (state) {
    const f = this.flags;
    if (arguments.length === 0) return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}

Operator.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id));
  },

  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(value) {
    if (this.value !== value) {
      this.value = value;
      return 1;
    } else {
      return 0;
    }
  },

  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: flag(SKIP$1),

  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: flag(MODIFIED),

  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initiatal evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(params, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(),
          argops = this._argops = this._argops || [],
          deps = [];
    let name, value, n, i;

    const add = (name, index, value) => {
      if (value instanceof Operator) {
        if (value !== this) {
          if (react) value.targets().add(this);
          deps.push(value);
        }

        argops.push({
          op: value,
          name: name,
          index: index
        });
      } else {
        argval.set(name, index, value);
      }
    };

    for (name in params) {
      value = params[name];

      if (name === PULSE) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(value).forEach(op => {
          if (!(op instanceof Operator)) {
            (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Pulse parameters must be operator instances.');
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value;
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
        argval.set(name, -1, Array(n = value.length));

        for (i = 0; i < n; ++i) add(name, i, value[i]);
      } else {
        add(name, -1, value);
      }
    }

    this.marshall().clear(); // initialize values

    if (initonly) argops.initonly = true;
    return deps;
  },

  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS,
          argops = this._argops;
    let item, i, op, mod;

    if (argops) {
      const n = argops.length;

      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }

      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }

        this._argops = null;
        this._update = null;
      }
    }

    return argval;
  },

  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const argops = this._argops;
    let i, n, item, op;

    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;

        if (op._targets) {
          op._targets.remove(this);
        }
      }
    } // remove references to the source and pulse object,
    // if present, to prevent memory leaks of old data.


    this.pulse = null;
    this.source = null;
  },

  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(pulse) {
    const update = this._update;

    if (update) {
      const params = this.marshall(pulse.stamp),
            v = update.call(this, params, pulse);
      params.clear();

      if (v !== this.value) {
        this.value = v;
      } else if (!this.modified()) {
        return pulse.StopPropagation;
      }
    }
  },

  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse) {
    if (pulse.stamp < this.stamp) return pulse.StopPropagation;
    let rv;

    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse);
    }

    return this.pulse = rv || pulse;
  }

};

/**
 * Add an operator to the dataflow graph. This function accepts a
 * variety of input argument types. The basic signature supports an
 * initial value, update function and parameters. If the first parameter
 * is an Operator instance, it will be added directly. If it is a
 * constructor for an Operator subclass, a new instance will be instantiated.
 * Otherwise, if the first parameter is a function instance, it will be used
 * as the update function and a null initial value is assumed.
 * @param {*} init - One of: the operator to add, the initial value of
 *   the operator, an operator class to instantiate, or an update function.
 * @param {function} [update] - The operator update function.
 * @param {object} [params] - The operator parameters.
 * @param {boolean} [react=true] - Flag indicating if this operator should
 *   listen for changes to upstream operators included as parameters.
 * @return {Operator} - The added operator.
 */

function add (init, update, params, react) {
  let shift = 1,
      op;

  if (init instanceof Operator) {
    op = init;
  } else if (init && init.prototype instanceof Operator) {
    op = new init();
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(init)) {
    op = new Operator(null, init);
  } else {
    shift = 0;
    op = new Operator(init, update);
  }

  this.rank(op);

  if (shift) {
    react = params;
    params = update;
  }

  if (params) this.connect(op, op.parameters(params, react));
  this.touch(op);
  return op;
}

/**
 * Connect a target operator as a dependent of source operators.
 * If necessary, this method will rerank the target operator and its
 * dependents to ensure propagation proceeds in a topologically sorted order.
 * @param {Operator} target - The target operator.
 * @param {Array<Operator>} - The source operators that should propagate
 *   to the target operator.
 */
function connect (target, sources) {
  const targetRank = target.rank,
        n = sources.length;

  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target);
      return;
    }
  }
}

let STREAM_ID = 0;
/**
 * Models an event stream.
 * @constructor
 * @param {function(Object, number): boolean} [filter] - Filter predicate.
 *   Events pass through when truthy, events are suppressed when falsy.
 * @param {function(Object): *} [apply] - Applied to input events to produce
 *   new event values.
 * @param {function(Object)} [receive] - Event callback function to invoke
 *   upon receipt of a new event. Use to override standard event processing.
 */

function EventStream(filter, apply, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive) this.receive = receive;
  if (filter) this._filter = filter;
  if (apply) this._apply = apply;
}
/**
 * Creates a new event stream instance with the provided
 * (optional) filter, apply and receive functions.
 * @param {function(Object, number): boolean} [filter] - Filter predicate.
 *   Events pass through when truthy, events are suppressed when falsy.
 * @param {function(Object): *} [apply] - Applied to input events to produce
 *   new event values.
 * @see EventStream
 */

function stream(filter, apply, receive) {
  return new EventStream(filter, apply, receive);
}
EventStream.prototype = {
  _filter: vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy,
  _apply: vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,

  targets() {
    return this._targets || (this._targets = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id));
  },

  consume(_) {
    if (!arguments.length) return !!this._consume;
    this._consume = !!_;
    return this;
  },

  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt),
            trg = this._targets,
            n = trg ? trg.length : 0;

      for (let i = 0; i < n; ++i) trg[i].receive(val);

      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },

  filter(filter) {
    const s = stream(filter);
    this.targets().add(s);
    return s;
  },

  apply(apply) {
    const s = stream(null, apply);
    this.targets().add(s);
    return s;
  },

  merge() {
    const s = stream();
    this.targets().add(s);

    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s);
    }

    return s;
  },

  throttle(pause) {
    let t = -1;
    return this.filter(() => {
      const now = Date.now();

      if (now - t > pause) {
        t = now;
        return 1;
      } else {
        return 0;
      }
    });
  },

  debounce(delay) {
    const s = stream();
    this.targets().add(stream(null, null, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(delay, e => {
      const df = e.dataflow;
      s.receive(e);
      if (df && df.run) df.run();
    })));
    return s;
  },

  between(a, b) {
    let active = false;
    a.targets().add(stream(null, null, () => active = true));
    b.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },

  detach() {
    // ensures compatibility with operators (#2753)
    // remove references to other streams and filter functions that may
    // be bound to subcontexts that need to be garbage collected.
    this._filter = vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy;
    this._targets = null;
  }

};

/**
 * Create a new event stream from an event source.
 * @param {object} source - The event source to monitor. The input must
 *  support the addEventListener method.
 * @param {string} type - The event type.
 * @param {function(object): boolean} [filter] - Event filter function.
 * @param {function(object): *} [apply] - Event application function.
 *   If provided, this function will be invoked and the result will be
 *   used as the downstream event value.
 * @return {EventStream}
 */

function events (source, type, filter, apply) {
  const df = this,
        s = stream(filter, apply),
        send = function (e) {
    e.dataflow = df;

    try {
      s.receive(e);
    } catch (error) {
      df.error(error);
    } finally {
      df.run();
    }
  };

  let sources;

  if (typeof source === 'string' && typeof document !== 'undefined') {
    sources = document.querySelectorAll(source);
  } else {
    sources = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(source);
  }

  const n = sources.length;

  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type, send);
  }

  return s;
}

function parse(data, format) {
  const locale = this.locale();
  return (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.read)(data, format, locale.timeParse, locale.utcParse);
}
/**
 * Ingests new data into the dataflow. First parses the data using the
 * vega-loader read method, then pulses a changeset to the target operator.
 * @param {Operator} target - The Operator to target with ingested data,
 *   typically a Collect transform instance.
 * @param {*} data - The input data, prior to parsing. For JSON this may
 *   be a string or an object. For CSV, TSV, etc should be a string.
 * @param {object} format - The data format description for parsing
 *   loaded data. This object is passed to the vega-loader read method.
 * @returns {Dataflow}
 */

function ingest(target, data, format) {
  data = this.parse(data, format);
  return this.pulse(target, this.changeset().insert(data));
}
/**
 * Request data from an external source, parse it, and return a Promise.
 * @param {string} url - The URL from which to load the data. This string
 *   is passed to the vega-loader load method.
 * @param {object} [format] - The data format description for parsing
 *   loaded data. This object is passed to the vega-loader read method.
 * @return {Promise} A Promise that resolves upon completion of the request.
 *   The resolved object contains the following properties:
 *   - data: an array of parsed data (or null upon error)
 *   - status: a code for success (0), load fail (-1), or parse fail (-2)
 */

async function request(url, format) {
  const df = this;
  let status = 0,
      data;

  try {
    data = await df.loader().load(url, {
      context: 'dataflow',
      response: (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.responseType)(format && format.type)
    });

    try {
      data = df.parse(data, format);
    } catch (err) {
      status = -2;
      df.warn('Data ingestion failed', url, err);
    }
  } catch (err) {
    status = -1;
    df.warn('Loading failed', url, err);
  }

  return {
    data,
    status
  };
}
async function preload(target, url, format) {
  const df = this,
        pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format);
  df.pulse(target, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(res.data || []));
  pending.done();
  return res;
}

function loadPending(df) {
  let accept;
  const pending = new Promise(a => accept = a);
  pending.requests = 0;

  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };

  return df._pending = pending;
}

const SKIP = {
  skip: true
};
/**
 * Perform operator updates in response to events. Applies an
 * update function to compute a new operator value. If the update function
 * returns a {@link ChangeSet}, the operator will be pulsed with those tuple
 * changes. Otherwise, the operator value will be updated to the return value.
 * @param {EventStream|Operator} source - The event source to react to.
 *   This argument can be either an EventStream or an Operator.
 * @param {Operator|function(object):Operator} target - The operator to update.
 *   This argument can either be an Operator instance or (if the source
 *   argument is an EventStream), a function that accepts an event object as
 *   input and returns an Operator to target.
 * @param {function(Parameters,Event): *} [update] - Optional update function
 *   to compute the new operator value, or a literal value to set. Update
 *   functions expect to receive a parameter object and event as arguments.
 *   This function can either return a new operator value or (if the source
 *   argument is an EventStream) a {@link ChangeSet} instance to pulse
 *   the target operator with tuple changes.
 * @param {object} [params] - The update function parameters.
 * @param {object} [options] - Additional options hash. If not overridden,
 *   updated operators will be skipped by default.
 * @param {boolean} [options.skip] - If true, the operator will
 *  be skipped: it will not be evaluated, but its dependents will be.
 * @param {boolean} [options.force] - If true, the operator will
 *   be re-evaluated even if its value has not changed.
 * @return {Dataflow}
 */

function on (source, target, update, params, options) {
  const fn = source instanceof Operator ? onOperator : onStream;
  fn(this, source, target, update, params, options);
  return this;
}

function onStream(df, stream, target, update, params, options) {
  const opt = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, SKIP);
  let func, op;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target)) target = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(target);

  if (update === undefined) {
    func = e => df.touch(target(e));
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(update)) {
    op = new Operator(null, update, params, false);

    func = e => {
      op.evaluate(e);
      const t = target(e),
            v = op.value;
      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);
    };
  } else {
    func = e => df.update(target(e), update, opt);
  }

  stream.apply(func);
}

function onOperator(df, source, target, update, params, options) {
  if (update === undefined) {
    source.targets().add(target);
  } else {
    const opt = options || {},
          op = new Operator(null, updater(target, update), params, false);
    op.modified(opt.force);
    op.rank = source.rank; // immediately follow source

    source.targets().add(op); // add dependency

    if (target) {
      op.skip(true); // skip first invocation

      op.value = target.value; // initialize value

      op.targets().add(target); // chain dependencies

      df.connect(target, [op]); // rerank as needed, #1672
    }
  }
}

function updater(target, update) {
  update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(update) ? update : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(update);
  return target ? function (_, pulse) {
    const value = update(_, pulse);

    if (!target.skip()) {
      target.skip(value !== this.value).value = value;
    }

    return value;
  } : update;
}

/**
 * Assigns a rank to an operator. Ranks are assigned in increasing order
 * by incrementing an internal rank counter.
 * @param {Operator} op - The operator to assign a rank.
 */

function rank(op) {
  op.rank = ++this._rank;
}
/**
 * Re-ranks an operator and all downstream target dependencies. This
 * is necessary when upstream dependencies of higher rank are added to
 * a target operator.
 * @param {Operator} op - The operator to re-rank.
 */

function rerank(op) {
  const queue = [op];
  let cur, list, i;

  while (queue.length) {
    this.rank(cur = queue.pop());

    if (list = cur._targets) {
      for (i = list.length; --i >= 0;) {
        queue.push(cur = list[i]);
        if (cur === op) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Cycle detected in dataflow graph.');
      }
    }
  }
}

/**
 * Sentinel value indicating pulse propagation should stop.
 */

const StopPropagation = {}; // Pulse visit type flags

const ADD = 1 << 0,
      REM = 1 << 1,
      MOD = 1 << 2,
      ADD_REM = ADD | REM,
      ADD_MOD = ADD | MOD,
      ALL = ADD | REM | MOD,
      REFLOW = 1 << 3,
      SOURCE = 1 << 4,
      NO_SOURCE = 1 << 5,
      NO_FIELDS = 1 << 6;
/**
 * A Pulse enables inter-operator communication during a run of the
 * dataflow graph. In addition to the current timestamp, a pulse may also
 * contain a change-set of added, removed or modified data tuples, as well as
 * a pointer to a full backing data source. Tuple change sets may not
 * be fully materialized; for example, to prevent needless array creation
 * a change set may include larger arrays and corresponding filter functions.
 * The pulse provides a {@link visit} method to enable proper and efficient
 * iteration over requested data tuples.
 *
 * In addition, each pulse can track modification flags for data tuple fields.
 * Responsible transform operators should call the {@link modifies} method to
 * indicate changes to data fields. The {@link modified} method enables
 * querying of this modification state.
 *
 * @constructor
 * @param {Dataflow} dataflow - The backing dataflow instance.
 * @param {number} stamp - The current propagation timestamp.
 * @param {string} [encode] - An optional encoding set name, which is then
 *   accessible as Pulse.encode. Operators can respond to (or ignore) this
 *   setting as appropriate. This parameter can be used in conjunction with
 *   the Encode transform in the vega-encode module.
 */

function Pulse(dataflow, stamp, encode) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode || null;
}

function materialize(data, filter) {
  const out = [];
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(data, filter, _ => out.push(_));
  return out;
}

function filter(pulse, flags) {
  const map = {};
  pulse.visit(flags, t => {
    map[tupleid(t)] = 1;
  });
  return t => map[tupleid(t)] ? null : t;
}

function addFilter(a, b) {
  return a ? (t, i) => a(t, i) && b(t, i) : b;
}

Pulse.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation,

  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD,

  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM,

  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD,

  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM,

  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD,

  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL,

  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW,

  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE,

  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE,

  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS,

  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },

  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source) p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },

  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)
    || !p.rem.length && p.source.length === p.add.length;

    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = []; // new operators can ignore rem #2769

      return p;
    }
  },

  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;

    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }

    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }

    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }

    if (flags & MOD) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }

    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans) p.cleans = src.cleans;
    }

    return p;
  },

  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(func) {
    this.dataflow.runAfter(func);
  },

  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
  },

  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(fork) {
    if (fork) return this.fork(ALL).reflow();
    const len = this.add.length,
          src = this.source && this.source.length;

    if (src && src !== len) {
      this.mod = this.source;
      if (len) this.filter(MOD, filter(this, ADD));
    }

    return this;
  },

  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(value) {
    if (arguments.length) {
      this.cleans = !!value;
      return this;
    } else {
      return this.cleans;
    }
  },

  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(_) {
    const hash = this.fields || (this.fields = {});

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_)) {
      _.forEach(f => hash[f] = true);
    } else {
      hash[_] = true;
    }

    return this;
  },

  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.some(f => fields[f]) : fields[_];
  },

  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(flags, filter) {
    const p = this;
    if (flags & ADD) p.addF = addFilter(p.addF, filter);
    if (flags & REM) p.remF = addFilter(p.remF, filter);
    if (flags & MOD) p.modF = addFilter(p.modF, filter);
    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);
    return p;
  },

  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(flags) {
    flags = flags || ALL;
    const p = this;

    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }

    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }

    if (flags & MOD && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }

    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }

    return p;
  },

  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(flags, visitor) {
    const p = this,
          v = visitor;

    if (flags & SOURCE) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.source, p.srcF, v);
      return p;
    }

    if (flags & ADD) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.add, p.addF, v);
    if (flags & REM) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.rem, p.remF, v);
    if (flags & MOD) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.mod, p.modF, v);
    const src = p.source;

    if (flags & REFLOW && src) {
      const sum = p.add.length + p.mod.length;

      if (sum === src.length) ; else if (sum) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(src, filter(p, ADD_MOD), v);
      } else {
        // if no add/rem/mod tuples, visit source
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(src, p.srcF, v);
      }
    }

    return p;
  }

};

/**
 * Represents a set of multiple pulses. Used as input for operators
 * that accept multiple pulses at a time. Contained pulses are
 * accessible via the public "pulses" array property. This pulse doe
 * not carry added, removed or modified tuples directly. However,
 * the visit method can be used to traverse all such tuples contained
 * in sub-pulses with a timestamp matching this parent multi-pulse.
 * @constructor
 * @param {Dataflow} dataflow - The backing dataflow instance.
 * @param {number} stamp - The timestamp.
 * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.
 */

function MultiPulse(dataflow, stamp, pulses, encode) {
  const p = this,
        n = pulses.length;
  let c = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode || null;
  this.pulses = pulses;

  for (let i = 0; i < n; ++i) {
    const pulse = pulses[i];
    if (pulse.stamp !== stamp) continue;

    if (pulse.fields) {
      const hash = p.fields || (p.fields = {});

      for (const f in pulse.fields) {
        hash[f] = 1;
      }
    }

    if (pulse.changed(p.ADD)) c |= p.ADD;
    if (pulse.changed(p.REM)) c |= p.REM;
    if (pulse.changed(p.MOD)) c |= p.MOD;
  }

  this.changes = c;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiPulse, Pulse, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);

    if (flags !== undefined) {
      if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));
      if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));
      if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));
    }

    return p;
  },

  changed(flags) {
    return this.changes & flags;
  },

  modified(_) {
    const p = this,
          fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.some(f => fields[f]) : fields[_];
  },

  filter() {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('MultiPulse does not support filtering.');
  },

  materialize() {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('MultiPulse does not support materialization.');
  },

  visit(flags, visitor) {
    const p = this,
          pulses = p.pulses,
          n = pulses.length;
    let i = 0;

    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }

    return p;
  }

});

/* eslint-disable require-atomic-updates */
/**
 * Evaluates the dataflow and returns a Promise that resolves when pulse
 * propagation completes. This method will increment the current timestamp
 * and process all updated, pulsed and touched operators. When invoked for
 * the first time, all registered operators will be processed. This method
 * should not be invoked by third-party clients, use {@link runAsync} or
 * {@link run} instead.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode package.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Promise} - A promise that resolves to this dataflow after
 *   evaluation completes.
 */

async function evaluate(encode, prerun, postrun) {
  const df = this,
        async = []; // if the pulse value is set, this is a re-entrant call

  if (df._pulse) return reentrant(df); // wait for pending datasets to load

  if (df._pending) await df._pending; // invoke prerun function, if provided

  if (prerun) await asyncCallback(df, prerun); // exit early if there are no updates

  if (!df._touched.length) {
    df.debug('Dataflow invoked, but nothing to do.');
    return df;
  } // increment timestamp clock


  const stamp = ++df._clock; // set the current pulse

  df._pulse = new Pulse(df, stamp, encode); // initialize priority queue, reset touched operators

  df._touched.forEach(op => df._enqueue(op, true));

  df._touched = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id);
  let count = 0,
      op,
      next,
      error;

  try {
    while (df._heap.size() > 0) {
      // dequeue operator with highest priority
      op = df._heap.pop(); // re-queue if rank changed

      if (op.rank !== op.qrank) {
        df._enqueue(op, true);

        continue;
      } // otherwise, evaluate the operator


      next = op.run(df._getPulse(op, encode));

      if (next.then) {
        // await if operator returns a promise directly
        next = await next;
      } else if (next.async) {
        // queue parallel asynchronous execution
        async.push(next.async);
        next = StopPropagation;
      } // propagate evaluation, enqueue dependent operators


      if (next !== StopPropagation) {
        if (op._targets) op._targets.forEach(op => df._enqueue(op));
      } // increment visit counter


      ++count;
    }
  } catch (err) {
    df._heap.clear();

    error = err;
  } // reset pulse map


  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count} operators`);

  if (error) {
    df._postrun = [];
    df.error(error);
  } // invoke callbacks queued via runAfter


  if (df._postrun.length) {
    const pr = df._postrun.sort((a, b) => b.priority - a.priority);

    df._postrun = [];

    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  } // invoke postrun function, if provided


  if (postrun) await asyncCallback(df, postrun); // handle non-blocking asynchronous callbacks

  if (async.length) {
    Promise.all(async).then(cb => df.runAsync(null, () => {
      cb.forEach(f => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }

  return df;
}
/**
 * Queues dataflow evaluation to run once any other queued evaluations have
 * completed and returns a Promise that resolves when the queued pulse
 * propagation completes. If provided, a callback function will be invoked
 * immediately before evaluation commences. This method will ensure a
 * separate evaluation is invoked for each time it is called.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode package.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Promise} - A promise that resolves to this dataflow after
 *   evaluation completes.
 */

async function runAsync(encode, prerun, postrun) {
  // await previously queued functions
  while (this._running) await this._running; // run dataflow, manage running promise


  const clear = () => this._running = null;

  (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);
  return this._running;
}
/**
 * Requests dataflow evaluation and the immediately returns this dataflow
 * instance. If there are pending data loading or other asynchronous
 * operations, the dataflow will evaluate asynchronously after this method
 * has been invoked. To track when dataflow evaluation completes, use the
 * {@link runAsync} method instead. This method will raise an error if
 * invoked while the dataflow is already in the midst of evaluation.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode module.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Dataflow} - This dataflow instance.
 */

function run(encode, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);
}
/**
 * Schedules a callback function to be invoked after the current pulse
 * propagation completes. If no propagation is currently occurring,
 * the function is invoked immediately. Callbacks scheduled via runAfter
 * are invoked immediately upon completion of the current cycle, before
 * any request queued via runAsync. This method is primarily intended for
 * internal use. Third-party callers using runAfter to schedule a callback
 * that invokes {@link run} or {@link runAsync} should not use this method,
 * but instead use {@link runAsync} with prerun or postrun arguments.
 * @param {function(Dataflow)} callback - The callback function to run.
 *   The callback will be invoked with this Dataflow instance as its
 *   sole argument.
 * @param {boolean} enqueue - A boolean flag indicating that the
 *   callback should be queued up to run after the next propagation
 *   cycle, suppressing immediate invocation when propagation is not
 *   currently occurring.
 * @param {number} [priority] - A priority value used to sort registered
 *   callbacks to determine execution order. This argument is intended
 *   for internal Vega use only.
 */

function runAfter(callback, enqueue, priority) {
  if (this._pulse || enqueue) {
    // pulse propagation is currently running, queue to run after
    this._postrun.push({
      priority: priority || 0,
      callback: callback
    });
  } else {
    // pulse propagation already complete, invoke immediately
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
/**
 * Raise an error for re-entrant dataflow evaluation.
 */

function reentrant(df) {
  df.error('Dataflow already running. Use runAsync() to chain invocations.');
  return df;
}
/**
 * Enqueue an operator into the priority queue for evaluation. The operator
 * will be enqueued if it has no registered pulse for the current cycle, or if
 * the force argument is true. Upon enqueue, this method also sets the
 * operator's qrank to the current rank value.
 * @param {Operator} op - The operator to enqueue.
 * @param {boolean} [force] - A flag indicating if the operator should be
 *   forceably added to the queue, even if it has already been previously
 *   enqueued during the current pulse propagation. This is useful when the
 *   dataflow graph is dynamically modified and the operator rank changes.
 */


function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q) op.stamp = this._clock;

  if (q || force) {
    op.qrank = op.rank;

    this._heap.push(op);
  }
}
/**
 * Provide a correct pulse for evaluating an operator. If the operator has an
 * explicit source operator, we will try to pull the pulse(s) from it.
 * If there is an array of source operators, we build a multi-pulse.
 * Otherwise, we return a current pulse with correct source data.
 * If the pulse is the pulse map has an explicit target set, we use that.
 * Else if the pulse on the upstream source operator is current, we use that.
 * Else we use the pulse from the pulse map, but copy the source tuple array.
 * @param {Operator} op - The operator for which to get an input pulse.
 * @param {string} [encode] - An (optional) encoding set name with which to
 *   annotate the returned pulse. See {@link run} for more information.
 */

function getPulse(op, encode) {
  const s = op.source,
        stamp = this._clock;
  return s && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
}

function singlePulse(p, s) {
  if (s && s.stamp === p.stamp) {
    return s;
  }

  p = p.fork();

  if (s && s !== StopPropagation) {
    p.source = s.source;
  }

  return p;
}

const NO_OPT = {
  skip: false,
  force: false
};
/**
 * Touches an operator, scheduling it to be evaluated. If invoked outside of
 * a pulse propagation, the operator will be evaluated the next time this
 * dataflow is run. If invoked in the midst of pulse propagation, the operator
 * will be queued for evaluation if and only if the operator has not yet been
 * evaluated on the current propagation timestamp.
 * @param {Operator} op - The operator to touch.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */

function touch(op, options) {
  const opt = options || NO_OPT;

  if (this._pulse) {
    // if in midst of propagation, add to priority queue
    this._enqueue(op);
  } else {
    // otherwise, queue for next propagation
    this._touched.add(op);
  }

  if (opt.skip) op.skip(true);
  return this;
}
/**
 * Updates the value of the given operator.
 * @param {Operator} op - The operator to update.
 * @param {*} value - The value to set.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.force] - If true, the operator will
 *   be re-evaluated even if its value has not changed.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */

function update(op, value, options) {
  const opt = options || NO_OPT;

  if (op.set(value) || opt.force) {
    this.touch(op, opt);
  }

  return this;
}
/**
 * Pulses an operator with a changeset of tuples. If invoked outside of
 * a pulse propagation, the pulse will be applied the next time this
 * dataflow is run. If invoked in the midst of pulse propagation, the pulse
 * will be added to the set of active pulses and will be applied if and
 * only if the target operator has not yet been evaluated on the current
 * propagation timestamp.
 * @param {Operator} op - The operator to pulse.
 * @param {ChangeSet} value - The tuple changeset to apply.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */

function pulse(op, changeset, options) {
  this.touch(op, options || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),
        t = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset.pulse(p, t);
  return this;
}

function Heap(cmp) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: x => {
      nodes.push(x);
      return siftdown(nodes, 0, nodes.length - 1, cmp);
    },
    pop: () => {
      const last = nodes.pop();
      let item;

      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp);
      } else {
        item = last;
      }

      return item;
    }
  };
}

function siftdown(array, start, idx, cmp) {
  let parent, pidx;
  const item = array[idx];

  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array[pidx];

    if (cmp(item, parent) < 0) {
      array[idx] = parent;
      idx = pidx;
      continue;
    }

    break;
  }

  return array[idx] = item;
}

function siftup(array, idx, cmp) {
  const start = idx,
        end = array.length,
        item = array[idx];
  let cidx = (idx << 1) + 1,
      ridx;

  while (cidx < end) {
    ridx = cidx + 1;

    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {
      cidx = ridx;
    }

    array[idx] = array[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }

  array[idx] = item;
  return siftdown(array, start, idx, cmp);
}

/**
 * A dataflow graph for reactive processing of data streams.
 * @constructor
 */

function Dataflow() {
  this.logger((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.logger)());
  this.logLevel(vega_util__WEBPACK_IMPORTED_MODULE_0__.Error);
  this._clock = 0;
  this._rank = 0;
  this._locale = (0,vega_format__WEBPACK_IMPORTED_MODULE_2__.defaultLocale)();

  try {
    this._loader = (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.loader)();
  } catch (e) {// do nothing if loader module is unavailable
  }

  this._touched = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a, b) => a.qrank - b.qrank);
  this._postrun = [];
}

function logMethod(method) {
  return function () {
    return this._log[method].apply(this, arguments);
  };
}

Dataflow.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },

  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },

  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },

  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(logger) {
    if (arguments.length) {
      this._log = logger;
      return this;
    } else {
      return this._log;
    }
  },

  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: logMethod('error'),

  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: logMethod('warn'),

  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: logMethod('info'),

  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: logMethod('debug'),

  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: logMethod('level'),

  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add,
  connect,
  rank,
  rerank,
  // OPERATOR UPDATES
  pulse,
  touch,
  update,
  changeset,
  // DATA LOADING
  ingest,
  parse,
  preload,
  request,
  // EVENT HANDLING
  events,
  on,
  // PULSE PROPAGATION
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};

/**
 * Abstract class for operators that process data tuples.
 * Subclasses must provide a {@link transform} method for operator processing.
 * @constructor
 * @param {*} [init] - The initial value for this operator.
 * @param {object} [params] - The parameters for this operator.
 * @param {Operator} [source] - The operator from which to receive pulses.
 */

function Transform(init, params) {
  Operator.call(this, init, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Transform, Operator, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse) {
    if (pulse.stamp < this.stamp) return pulse.StopPropagation;
    let rv;

    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse);
    }

    rv = rv || pulse;

    if (rv.then) {
      rv = rv.then(_ => this.pulse = _);
    } else if (rv !== pulse.StopPropagation) {
      this.pulse = rv;
    }

    return rv;
  },

  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(pulse) {
    const params = this.marshall(pulse.stamp),
          out = this.transform(params, pulse);
    params.clear();
    return out;
  },

  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {}

});

const transforms = {};
function definition(type) {
  const t = transform(type);
  return t && t.Definition || null;
}
function transform(type) {
  type = type && type.toLowerCase();
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(transforms, type) ? transforms[type] : null;
}




/***/ }),

/***/ "../../node_modules/vega-encode/build/vega-encode.module.js":
/*!******************************************************************!*\
  !*** ../../node_modules/vega-encode/build/vega-encode.module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "axisticks": () => (/* binding */ AxisTicks),
/* harmony export */   "datajoin": () => (/* binding */ DataJoin),
/* harmony export */   "encode": () => (/* binding */ Encode),
/* harmony export */   "legendentries": () => (/* binding */ LegendEntries),
/* harmony export */   "linkpath": () => (/* binding */ LinkPath),
/* harmony export */   "pie": () => (/* binding */ Pie),
/* harmony export */   "scale": () => (/* binding */ Scale),
/* harmony export */   "sortitems": () => (/* binding */ SortItems),
/* harmony export */   "stack": () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/sum.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/round.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/value.js");






/**
 * Generates axis ticks for visualizing a spatial scale.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Scale} params.scale - The scale to generate ticks for.
 * @param {*} [params.count=10] - The approximate number of ticks, or
 *   desired tick interval, to use.
 * @param {Array<*>} [params.values] - The exact tick values to use.
 *   These must be legal domain values for the provided scale.
 *   If provided, the count argument is ignored.
 * @param {function(*):string} [params.formatSpecifier] - A format specifier
 *   to use in conjunction with scale.tickFormat. Legal values are
 *   any valid d3 4.0 format specifier.
 * @param {function(*):string} [params.format] - The format function to use.
 *   If provided, the formatSpecifier argument is ignored.
 */

function AxisTicks(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(AxisTicks, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !_.modified()) {
      return pulse.StopPropagation;
    }

    var locale = pulse.dataflow.locale(),
        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        ticks = this.value,
        scale = _.scale,
        tally = _.count == null ? _.values ? _.values.length : 10 : _.count,
        count = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, tally, _.minstep),
        format = _.format || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickFormat)(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),
        values = _.values ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.validTicks)(scale, _.values, count) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickValues)(scale, count);
    if (ticks) out.rem = ticks;
    ticks = values.map((value, i) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
      index: i / (values.length - 1 || 1),
      value: value,
      label: format(value)
    }));

    if (_.extra && ticks.length) {
      // add an extra tick pegged to the initial domain value
      // this is used to generate axes with 'binned' domains
      ticks.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: -1,
        extra: {
          value: ticks[0].value
        },
        label: ''
      }));
    }

    out.source = ticks;
    out.add = ticks;
    this.value = ticks;
    return out;
  }

});

/**
 * Joins a set of data elements against a set of visual items.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): object} [params.item] - An item generator function.
 * @param {function(object): *} [params.key] - The key field associating data and visual items.
 */

function DataJoin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}

function defaultItemCreate() {
  return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({});
}

function newMap(key) {
  const map = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.fastmap)().test(t => t.exit);

  map.lookup = t => map.get(key(t));

  return map;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(DataJoin, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var df = pulse.dataflow,
        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        item = _.item || defaultItemCreate,
        key = _.key || vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid,
        map = this.value; // prevent transient (e.g., hover) requests from
    // cascading across marks derived from marks

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(out.encode)) {
      out.encode = null;
    }

    if (map && (_.modified('key') || pulse.modified(key))) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('DataJoin does not support modified key function or fields.');
    }

    if (!map) {
      pulse = pulse.addAll();
      this.value = map = newMap(key);
    }

    pulse.visit(pulse.ADD, t => {
      const k = key(t);
      let x = map.get(k);

      if (x) {
        if (x.exit) {
          map.empty--;
          out.add.push(x);
        } else {
          out.mod.push(x);
        }
      } else {
        x = item(t);
        map.set(k, x);
        out.add.push(x);
      }

      x.datum = t;
      x.exit = false;
    });
    pulse.visit(pulse.MOD, t => {
      const k = key(t),
            x = map.get(k);

      if (x) {
        x.datum = t;
        out.mod.push(x);
      }
    });
    pulse.visit(pulse.REM, t => {
      const k = key(t),
            x = map.get(k);

      if (t === x.datum && !x.exit) {
        out.rem.push(x);
        x.exit = true;
        ++map.empty;
      }
    });
    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');

    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {
      df.runAfter(map.clean);
    }

    return out;
  }

});

/**
 * Invokes encoding functions for visual items.
 * @constructor
 * @param {object} params - The parameters to the encoding functions. This
 *   parameter object will be passed through to all invoked encoding functions.
 * @param {object} [params.mod=false] - Flag indicating if tuples in the input
 *   mod set that are unmodified by encoders should be included in the output.
 * @param {object} param.encoders - The encoding functions
 * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set
 * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set
 * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set
 */

function Encode(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Encode, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ADD_REM),
        fmod = _.mod || false,
        encoders = _.encoders,
        encode = pulse.encode; // if an array, the encode directive includes additional sets
    // that must be defined in order for the primary set to be invoked
    // e.g., only run the update set if the hover set is defined

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(encode)) {
      if (out.changed() || encode.every(e => encoders[e])) {
        encode = encode[0];
        out.encode = null; // consume targeted encode directive
      } else {
        return pulse.StopPropagation;
      }
    } // marshall encoder functions


    var reenter = encode === 'enter',
        update = encoders.update || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
        enter = encoders.enter || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
        exit = encoders.exit || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
        set = (encode && !reenter ? encoders[encode] : update) || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy;

    if (pulse.changed(pulse.ADD)) {
      pulse.visit(pulse.ADD, t => {
        enter(t, _);
        update(t, _);
      });
      out.modifies(enter.output);
      out.modifies(update.output);

      if (set !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy && set !== update) {
        pulse.visit(pulse.ADD, t => {
          set(t, _);
        });
        out.modifies(set.output);
      }
    }

    if (pulse.changed(pulse.REM) && exit !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy) {
      pulse.visit(pulse.REM, t => {
        exit(t, _);
      });
      out.modifies(exit.output);
    }

    if (reenter || set !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy) {
      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);

      if (reenter) {
        pulse.visit(flag, t => {
          const mod = enter(t, _) || fmod;
          if (set(t, _) || mod) out.mod.push(t);
        });
        if (out.mod.length) out.modifies(enter.output);
      } else {
        pulse.visit(flag, t => {
          if (set(t, _) || fmod) out.mod.push(t);
        });
      }

      if (out.mod.length) out.modifies(set.output);
    }

    return out.changed() ? out : pulse.StopPropagation;
  }

});

/**
 * Generates legend entries for visualizing a scale.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Scale} params.scale - The scale to generate items for.
 * @param {*} [params.count=5] - The approximate number of items, or
 *   desired tick interval, to use.
 * @param {*} [params.limit] - The maximum number of entries to
 *   include in a symbol legend.
 * @param {Array<*>} [params.values] - The exact tick values to use.
 *   These must be legal domain values for the provided scale.
 *   If provided, the count argument is ignored.
 * @param {string} [params.formatSpecifier] - A format specifier
 *   to use in conjunction with scale.tickFormat. Legal values are
 *   any valid D3 format specifier string.
 * @param {function(*):string} [params.format] - The format function to use.
 *   If provided, the formatSpecifier argument is ignored.
 */

function LegendEntries(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(LegendEntries, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value != null && !_.modified()) {
      return pulse.StopPropagation;
    }

    var locale = pulse.dataflow.locale(),
        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        items = this.value,
        type = _.type || vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend,
        scale = _.scale,
        limit = +_.limit,
        count = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, _.count == null ? 5 : _.count, _.minstep),
        lskip = !!_.values || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend,
        format = _.format || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelFormat)(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),
        values = _.values || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelValues)(scale, count),
        domain,
        fraction,
        size,
        offset,
        ellipsis;
    if (items) out.rem = items;

    if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend) {
      if (limit && values.length > limit) {
        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');
        items = values.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items = values;
      }

      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(size = _.size)) {
        // if first value maps to size zero, remove from list (vega#717)
        if (!_.values && scale(items[0]) === 0) {
          items = items.slice(1);
        } // compute size offset for legend entries


        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);
      } else {
        size = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.constant)(offset = size || 8);
      }

      items = items.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, items),
        value: value,
        offset: offset,
        size: size(value, _)
      }));

      if (ellipsis) {
        ellipsis = values[items.length];
        items.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
          index: items.length,
          label: "\u2026".concat(values.length - items.length, " entries"),
          value: ellipsis,
          offset: offset,
          size: size(ellipsis, _)
        }));
      }
    } else if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.GradientLegend) {
      domain = scale.domain(), fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scaleFraction)(scale, domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)); // if automatic label generation produces 2 or fewer values,
      // use the domain end points instead (fixes vega/vega#1364)

      if (values.length < 3 && !_.values && domain[0] !== (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)) {
        values = [domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)];
      }

      items = values.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, values),
        value: value,
        perc: fraction(value)
      }));
    } else {
      size = values.length - 1;
      fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelFraction)(scale);
      items = values.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, values),
        value: value,
        perc: index ? fraction(value) : 0,
        perc2: index === size ? 1 : fraction(values[index + 1])
      }));
    }

    out.source = items;
    out.add = items;
    this.value = items;
    return out;
  }

});

const sourceX = t => t.source.x;

const sourceY = t => t.source.y;

const targetX = t => t.target.x;

const targetY = t => t.target.y;
/**
 * Layout paths linking source and target elements.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */


function LinkPath(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, {}, params);
}
LinkPath.Definition = {
  'type': 'LinkPath',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'sourceX',
    'type': 'field',
    'default': 'source.x'
  }, {
    'name': 'sourceY',
    'type': 'field',
    'default': 'source.y'
  }, {
    'name': 'targetX',
    'type': 'field',
    'default': 'target.x'
  }, {
    'name': 'targetY',
    'type': 'field',
    'default': 'target.y'
  }, {
    'name': 'orient',
    'type': 'enum',
    'default': 'vertical',
    'values': ['horizontal', 'vertical', 'radial']
  }, {
    'name': 'shape',
    'type': 'enum',
    'default': 'line',
    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']
  }, {
    'name': 'require',
    'type': 'signal'
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(LinkPath, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var sx = _.sourceX || sourceX,
        sy = _.sourceY || sourceY,
        tx = _.targetX || targetX,
        ty = _.targetY || targetY,
        as = _.as || 'path',
        orient = _.orient || 'vertical',
        shape = _.shape || 'line',
        path = Paths.get(shape + '-' + orient) || Paths.get(shape);

    if (!path) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));
    }

    pulse.visit(pulse.SOURCE, t => {
      t[as] = path(sx(t), sy(t), tx(t), ty(t));
    });
    return pulse.reflow(_.modified()).modifies(as);
  }

});

const line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;

const lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));

const arc = (sx, sy, tx, ty) => {
  var dx = tx - sx,
      dy = ty - sy,
      rr = Math.sqrt(dx * dx + dy * dy) / 2,
      ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;
};

const arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));

const curve = (sx, sy, tx, ty) => {
  const dx = tx - sx,
        dy = ty - sy,
        ix = 0.2 * (dx + dy),
        iy = 0.2 * (dy - dx);
  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;
};

const curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));

const orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;

const orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;

const orthoR = (sa, sr, ta, tr) => {
  const sc = Math.cos(sa),
        ss = Math.sin(sa),
        tc = Math.cos(ta),
        ts = Math.sin(ta),
        sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;
  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;
};

const diagonalX = (sx, sy, tx, ty) => {
  const m = (sx + tx) / 2;
  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;
};

const diagonalY = (sx, sy, tx, ty) => {
  const m = (sy + ty) / 2;
  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;
};

const diagonalR = (sa, sr, ta, tr) => {
  const sc = Math.cos(sa),
        ss = Math.sin(sa),
        tc = Math.cos(ta),
        ts = Math.sin(ta),
        mr = (sr + tr) / 2;
  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;
};

const Paths = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.fastmap)({
  'line': line,
  'line-radial': lineR,
  'arc': arc,
  'arc-radial': arcR,
  'curve': curve,
  'curve-radial': curveR,
  'orthogonal-horizontal': orthoX,
  'orthogonal-vertical': orthoY,
  'orthogonal-radial': orthoR,
  'diagonal-horizontal': diagonalX,
  'diagonal-vertical': diagonalY,
  'diagonal-radial': diagonalR
});

/**
 * Pie and donut chart layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size pie segments.
 * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.
 * @param {number} [params.endAngle=2π] - The end angle (in radians) of the layout.
 * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.
 */

function Pie(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Pie.Definition = {
  'type': 'Pie',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'startAngle',
    'type': 'number',
    'default': 0
  }, {
    'name': 'endAngle',
    'type': 'number',
    'default': 6.283185307179586
  }, {
    'name': 'sort',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['startAngle', 'endAngle']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Pie, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var as = _.as || ['startAngle', 'endAngle'],
        startAngle = as[0],
        endAngle = as[1],
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_2__.one,
        start = _.startAngle || 0,
        stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,
        data = pulse.source,
        values = data.map(field),
        n = values.length,
        a = start,
        k = (stop - start) / (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(values),
        index = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.default)(n),
        i,
        t,
        v;

    if (_.sort) {
      index.sort((a, b) => values[a] - values[b]);
    }

    for (i = 0; i < n; ++i) {
      v = values[index[i]];
      t = data[index[i]];
      t[startAngle] = a;
      t[endAngle] = a += v * k;
    }

    this.value = values;
    return pulse.reflow(_.modified()).modifies(as);
  }

});

const DEFAULT_COUNT = 5;

function includeZero(scale) {
  const type = scale.type;
  return !scale.bins && (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Pow || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sqrt);
}

function includePad(type) {
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isContinuous)(type) && type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential;
}

const SKIP = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.toSet)(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);
/**
 * Maintains a scale function mapping data values to visual channels.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Scale(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Scale, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var df = pulse.dataflow,
        scale$1 = this.value,
        key = scaleKey(_);

    if (!scale$1 || key !== scale$1.type) {
      this.value = scale$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scale)(key)();
    }

    for (key in _) if (!SKIP[key]) {
      // padding is a scale property for band/point but not others
      if (key === 'padding' && includePad(scale$1.type)) continue; // invoke scale property setter, raise warning if not found

      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);
    }

    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
  }

});

function scaleKey(_) {
  var t = _.type,
      d = '',
      n; // backwards compatibility pre Vega 5.

  if (t === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential) return vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential + '-' + vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear;

  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential + '-' : n === 3 ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.Diverging + '-' : '';
  }

  return (d + t || vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear).toLowerCase();
}

function isContinuousColor(_) {
  const t = _.type;
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isContinuous)(t) && t !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Time && t !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.UTC && (_.scheme || _.range && _.range.length && _.range.every(vega_util__WEBPACK_IMPORTED_MODULE_2__.isString));
}

function configureDomain(scale, _, df) {
  // check raw domain, if provided use that and exit early
  const raw = rawDomain(scale, _.domainRaw, df);
  if (raw > -1) return raw;
  var domain = _.domain,
      type = scale.type,
      zero = _.zero || _.zero === undefined && includeZero(scale),
      n,
      mid;
  if (!domain) return 0; // adjust continuous domain for minimum pixel padding

  if (includePad(type) && _.padding && domain[0] !== (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)) {
    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);
  } // adjust domain based on zero, min, max settings


  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain = domain.slice()).length - 1 || 1;

    if (zero) {
      if (domain[0] > 0) domain[0] = 0;
      if (domain[n] < 0) domain[n] = 0;
    }

    if (_.domainMin != null) domain[0] = _.domainMin;
    if (_.domainMax != null) domain[n] = _.domainMax;

    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;
      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);
      domain.splice(i, 0, mid);
    }
  } // set the scale domain


  scale.domain(domainCheck(type, domain, df)); // if ordinal scale domain is defined, prevent implicit
  // domain construction as side-effect of scale lookup

  if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Ordinal) {
    scale.unknown(_.domainImplicit ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.scaleImplicit : undefined);
  } // perform 'nice' adjustment as requested


  if (_.nice && scale.nice) {
    scale.nice(_.nice !== true && (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, _.nice) || null);
  } // return the cardinality of the domain


  return domain.length;
}

function rawDomain(scale, raw, df) {
  if (raw) {
    scale.domain(domainCheck(scale.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}

function padDomain(type, domain, range, pad, exponent, constant) {
  var span = Math.abs((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(range) - range[0]),
      frac = span / (span - 2 * pad),
      d = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Log ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomLog)(domain, null, frac) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sqrt ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomPow)(domain, null, frac, 0.5) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Pow ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomPow)(domain, null, frac, exponent || 1) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Symlog ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomSymlog)(domain, null, frac, constant || 1) : (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomLinear)(domain, null, frac);
  domain = domain.slice();
  domain[0] = d[0];
  domain[domain.length - 1] = d[1];
  return domain;
}

function domainCheck(type, domain, df) {
  if ((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isLogarithmic)(type)) {
    // sum signs of domain values
    // if all pos or all neg, abs(sum) === domain.length
    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));

    if (s !== domain.length) {
      df.warn('Log scale domain includes zero: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.stringValue)(domain));
    }
  }

  return domain;
}

function configureBins(scale, _, count) {
  let bins = _.bins;

  if (bins && !(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(bins)) {
    // generate bin boundary array
    const domain = scale.domain(),
          lo = domain[0],
          hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain),
          step = bins.step;
    let start = bins.start == null ? lo : bins.start,
        stop = bins.stop == null ? hi : bins.stop;
    if (!step) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Scale bins parameter missing step property.');
    if (start < lo) start = step * Math.ceil(lo / step);
    if (stop > hi) stop = step * Math.floor(hi / step);
    bins = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.default)(start, stop + step / 2, step);
  }

  if (bins) {
    // assign bin boundaries to scale instance
    scale.bins = bins;
  } else if (scale.bins) {
    // no current bins, remove bins if previously set
    delete scale.bins;
  } // special handling for bin-ordinal scales


  if (scale.type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.BinOrdinal) {
    if (!bins) {
      // the domain specifies the bins
      scale.bins = scale.domain();
    } else if (!_.domain && !_.domainRaw) {
      // the bins specify the domain
      scale.domain(bins);
      count = bins.length;
    }
  } // return domain cardinality


  return count;
}

function configureRange(scale, _, count) {
  var type = scale.type,
      round = _.round || false,
      range = _.range; // if range step specified, calculate full range extent

  if (_.rangeStep != null) {
    range = configureRangeStep(type, _, count);
  } // else if a range scheme is defined, use that
  else if (_.scheme) {
      range = configureScheme(type, _, count);

      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(range)) {
        if (scale.interpolator) {
          return scale.interpolator(range);
        } else {
          (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)("Scale type ".concat(type, " does not support interpolating color schemes."));
        }
      }
    } // given a range array for an interpolating scale, convert to interpolator


  if (range && (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isInterpolating)(type)) {
    return scale.interpolator((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateColors)(flip(range, _.reverse), _.interpolate, _.interpolateGamma));
  } // configure rounding / interpolation


  if (range && _.interpolate && scale.interpolate) {
    scale.interpolate((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolate)(_.interpolate, _.interpolateGamma));
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale.round)) {
    scale.round(round);
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale.rangeRound)) {
    scale.interpolate(round ? d3_interpolate__WEBPACK_IMPORTED_MODULE_5__.default : d3_interpolate__WEBPACK_IMPORTED_MODULE_6__.default);
  }

  if (range) scale.range(flip(range, _.reverse));
}

function configureRangeStep(type, _, count) {
  if (type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Band && type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Point) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Only band and point scales support rangeStep.');
  } // calculate full range based on requested step size and padding


  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,
      inner = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.bandSpace)(count, inner, outer)];
}

function configureScheme(type, _, count) {
  var extent = _.schemeExtent,
      name,
      scheme$1;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(_.scheme)) {
    scheme$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateColors)(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name = _.scheme.toLowerCase();
    scheme$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scheme)(name);
    if (!scheme$1) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)("Unrecognized scheme name: ".concat(_.scheme));
  } // determine size for potential discrete range


  count = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Threshold ? count + 1 : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.BinOrdinal ? count - 1 : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Quantile || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Quantize ? +_.schemeCount || DEFAULT_COUNT : count; // adjust and/or quantize scheme as appropriate

  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isInterpolating)(type) ? adjustScheme(scheme$1, extent, _.reverse) : (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scheme$1) ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.quantizeInterpolator)(adjustScheme(scheme$1, extent), count) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Ordinal ? scheme$1 : scheme$1.slice(0, count);
}

function adjustScheme(scheme, extent, reverse) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scheme) && (extent || reverse) ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateRange)(scheme, flip(extent || [0, 1], reverse)) : scheme;
}

function flip(array, reverse) {
  return reverse ? array.slice().reverse() : array;
}

/**
 * Sorts scenegraph items in the pulse source array.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator
 *   function for sorting tuples.
 */

function SortItems(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(SortItems, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');
    if (mod) pulse.source.sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort));
    this.modified(mod);
    return pulse;
  }

});

const Zero = 'zero',
      Center = 'center',
      Normalize = 'normalize',
      DefOutput = ['y0', 'y1'];
/**
 * Stack layout for visualization elements.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to stack.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.
 * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.
 */

function Stack(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Stack.Definition = {
  'type': 'Stack',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'offset',
    'type': 'enum',
    'default': Zero,
    'values': [Zero, Center, Normalize]
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': DefOutput
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Stack, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var as = _.as || DefOutput,
        y0 = as[0],
        y1 = as[1],
        sort = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort),
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_2__.one,
        stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,
        groups,
        i,
        n,
        max; // partition, sum, and sort the stack groups

    groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group

    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {
      stack(groups[i], max, field, y0, y1);
    }

    return pulse.reflow(_.modified()).modifies(as);
  }

});

function stackCenter(group, max, field, y0, y1) {
  var last = (max - group.sum) / 2,
      m = group.length,
      j = 0,
      t;

  for (; j < m; ++j) {
    t = group[j];
    t[y0] = last;
    t[y1] = last += Math.abs(field(t));
  }
}

function stackNormalize(group, max, field, y0, y1) {
  var scale = 1 / group.sum,
      last = 0,
      m = group.length,
      j = 0,
      v = 0,
      t;

  for (; j < m; ++j) {
    t = group[j];
    t[y0] = last;
    t[y1] = last = scale * (v += Math.abs(field(t)));
  }
}

function stackZero(group, max, field, y0, y1) {
  var lastPos = 0,
      lastNeg = 0,
      m = group.length,
      j = 0,
      v,
      t;

  for (; j < m; ++j) {
    t = group[j];
    v = +field(t);

    if (v < 0) {
      t[y0] = lastNeg;
      t[y1] = lastNeg += v;
    } else {
      t[y0] = lastPos;
      t[y1] = lastPos += v;
    }
  }
}

function partition(data, groupby, sort, field) {
  var groups = [],
      get = f => f(t),
      map,
      i,
      n,
      m,
      t,
      k,
      g,
      s,
      max; // partition data points into stack groups


  if (groupby == null) {
    groups.push(data.slice());
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        groups.push(g);
      }

      g.push(t);
    }
  } // compute sums of groups, sort groups as needed


  for (k = 0, max = 0, m = groups.length; k < m; ++k) {
    g = groups[k];

    for (i = 0, s = 0, n = g.length; i < n; ++i) {
      s += Math.abs(field(g[i]));
    }

    g.sum = s;
    if (s > max) max = s;
    if (sort) g.sort(sort);
  }

  groups.max = max;
  return groups;
}




/***/ }),

/***/ "../../node_modules/vega-event-selector/build/vega-event-selector.module.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/vega-event-selector/build/vega-event-selector.module.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseSelector": () => (/* binding */ eventSelector)
/* harmony export */ });
const VIEW = 'view',
      LBRACK = '[',
      RBRACK = ']',
      LBRACE = '{',
      RBRACE = '}',
      COLON = ':',
      COMMA = ',',
      NAME = '@',
      GT = '>',
      ILLEGAL = /[[\]{}]/,
      DEFAULT_MARKS = {
  '*': 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
let DEFAULT_SOURCE, MARKS;
/**
 * Parse an event selector string.
 * Returns an array of event stream definitions.
 */

function eventSelector (selector, source, marks) {
  DEFAULT_SOURCE = source || VIEW;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}

function isMarkType(type) {
  return MARKS[type];
}

function find(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count = 0,
      c;

  for (; i < n; ++i) {
    c = s[i];
    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;
  }

  return i;
}

function parseMerge(s) {
  const output = [],
        n = s.length;
  let start = 0,
      i = 0;

  while (i < n) {
    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output.push(s.substring(start, i).trim());
    start = ++i;
  }

  if (output.length === 0) {
    throw 'Empty event selector: ' + s;
  }

  return output;
}

function parseSelector(s) {
  return s[0] === '[' ? parseBetween(s) : parseStream(s);
}

function parseBetween(s) {
  const n = s.length;
  let i = 1,
      b;
  i = find(s, i, RBRACK, LBRACK, RBRACK);

  if (i === n) {
    throw 'Empty between selector: ' + s;
  }

  b = parseMerge(s.substring(1, i));

  if (b.length !== 2) {
    throw 'Between selector must have two elements: ' + s;
  }

  s = s.slice(i + 1).trim();

  if (s[0] !== GT) {
    throw 'Expected \'>\' after between selector: ' + s;
  }

  b = b.map(parseSelector);
  const stream = parseSelector(s.slice(1).trim());

  if (stream.between) {
    return {
      between: b,
      stream: stream
    };
  } else {
    stream.between = b;
  }

  return stream;
}

function parseStream(s) {
  const stream = {
    source: DEFAULT_SOURCE
  },
        source = [];
  let throttle = [0, 0],
      markname = 0,
      start = 0,
      n = s.length,
      i = 0,
      j,
      filter; // extract throttle from end

  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);

    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e) {
        throw 'Invalid throttle specification: ' + s;
      }

      s = s.slice(0, i).trim();
      n = s.length;
    } else throw 'Unmatched right brace: ' + s;

    i = 0;
  }

  if (!n) throw s; // set name flag based on first char

  if (s[0] === NAME) markname = ++i; // extract first part of multi-part stream selector

  j = find(s, i, COLON);

  if (j < n) {
    source.push(s.substring(start, j).trim());
    start = i = ++j;
  } // extract remaining part of stream selector


  i = find(s, i, LBRACK);

  if (i === n) {
    source.push(s.substring(start, n).trim());
  } else {
    source.push(s.substring(start, i).trim());
    filter = [];
    start = ++i;
    if (start === n) throw 'Unmatched left bracket: ' + s;
  } // extract filters


  while (i < n) {
    i = find(s, i, RBRACK);
    if (i === n) throw 'Unmatched left bracket: ' + s;
    filter.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;
    start = ++i;
  } // marshall event stream specification


  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {
    throw 'Invalid event selector: ' + s;
  }

  if (n > 1) {
    stream.type = source[1];

    if (markname) {
      stream.markname = source[0].slice(1);
    } else if (isMarkType(source[0])) {
      stream.marktype = source[0];
    } else {
      stream.source = source[0];
    }
  } else {
    stream.type = source[0];
  }

  if (stream.type.slice(-1) === '!') {
    stream.consume = true;
    stream.type = stream.type.slice(0, -1);
  }

  if (filter != null) stream.filter = filter;
  if (throttle[0]) stream.throttle = throttle[0];
  if (throttle[1]) stream.debounce = throttle[1];
  return stream;
}

function parseThrottle(s) {
  const a = s.split(COMMA);
  if (!s.length || a.length > 2) throw s;
  return a.map(_ => {
    const x = +_;
    if (x !== x) throw s;
    return x;
  });
}




/***/ }),

/***/ "../../node_modules/vega-expression/build/vega-expression.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-expression/build/vega-expression.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ASTNode": () => (/* binding */ ASTNode),
/* harmony export */   "ArrayExpression": () => (/* binding */ ArrayExpression),
/* harmony export */   "BinaryExpression": () => (/* binding */ BinaryExpression),
/* harmony export */   "CallExpression": () => (/* binding */ CallExpression),
/* harmony export */   "ConditionalExpression": () => (/* binding */ ConditionalExpression),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Literal": () => (/* binding */ Literal),
/* harmony export */   "LogicalExpression": () => (/* binding */ LogicalExpression),
/* harmony export */   "MemberExpression": () => (/* binding */ MemberExpression),
/* harmony export */   "ObjectExpression": () => (/* binding */ ObjectExpression),
/* harmony export */   "Property": () => (/* binding */ Property),
/* harmony export */   "RawCode": () => (/* binding */ RawCode),
/* harmony export */   "UnaryExpression": () => (/* binding */ UnaryExpression),
/* harmony export */   "codegenExpression": () => (/* binding */ codegen),
/* harmony export */   "constants": () => (/* binding */ Constants),
/* harmony export */   "functions": () => (/* binding */ Functions),
/* harmony export */   "parseExpression": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");


const RawCode = 'RawCode';
const Literal = 'Literal';
const Property = 'Property';
const Identifier = 'Identifier';
const ArrayExpression = 'ArrayExpression';
const BinaryExpression = 'BinaryExpression';
const CallExpression = 'CallExpression';
const ConditionalExpression = 'ConditionalExpression';
const LogicalExpression = 'LogicalExpression';
const MemberExpression = 'MemberExpression';
const ObjectExpression = 'ObjectExpression';
const UnaryExpression = 'UnaryExpression';
function ASTNode(type) {
  this.type = type;
}

ASTNode.prototype.visit = function (visitor) {
  let c, i, n;
  if (visitor(this)) return 1;

  for (c = children(this), i = 0, n = c.length; i < n; ++i) {
    if (c[i].visit(visitor)) return 1;
  }
};

function children(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;

    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];

    case CallExpression:
      return [node.callee].concat(node.arguments);

    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];

    case MemberExpression:
      return [node.object, node.property];

    case ObjectExpression:
      return node.properties;

    case Property:
      return [node.key, node.value];

    case UnaryExpression:
      return [node.argument];

    case Identifier:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}

/*
  The following expression parser is based on Esprima (http://esprima.org/).
  Original header comment and license for Esprima is included here:

  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var TokenName, source, index, length, lookahead;
var TokenBooleanLiteral = 1,
    TokenEOF = 2,
    TokenIdentifier = 3,
    TokenKeyword = 4,
    TokenNullLiteral = 5,
    TokenNumericLiteral = 6,
    TokenPunctuator = 7,
    TokenStringLiteral = 8,
    TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = 'Boolean';
TokenName[TokenEOF] = '<end>';
TokenName[TokenIdentifier] = 'Identifier';
TokenName[TokenKeyword] = 'Keyword';
TokenName[TokenNullLiteral] = 'Null';
TokenName[TokenNumericLiteral] = 'Numeric';
TokenName[TokenPunctuator] = 'Punctuator';
TokenName[TokenStringLiteral] = 'String';
TokenName[TokenRegularExpression] = 'RegularExpression';
var SyntaxArrayExpression = 'ArrayExpression',
    SyntaxBinaryExpression = 'BinaryExpression',
    SyntaxCallExpression = 'CallExpression',
    SyntaxConditionalExpression = 'ConditionalExpression',
    SyntaxIdentifier = 'Identifier',
    SyntaxLiteral = 'Literal',
    SyntaxLogicalExpression = 'LogicalExpression',
    SyntaxMemberExpression = 'MemberExpression',
    SyntaxObjectExpression = 'ObjectExpression',
    SyntaxProperty = 'Property',
    SyntaxUnaryExpression = 'UnaryExpression'; // Error messages should be identical to V8.

var MessageUnexpectedToken = 'Unexpected token %0',
    MessageUnexpectedNumber = 'Unexpected number',
    MessageUnexpectedString = 'Unexpected string',
    MessageUnexpectedIdentifier = 'Unexpected identifier',
    MessageUnexpectedReserved = 'Unexpected reserved word',
    MessageUnexpectedEOS = 'Unexpected end of input',
    MessageInvalidRegExp = 'Invalid regular expression',
    MessageUnterminatedRegExp = 'Invalid regular expression: missing /',
    MessageStrictOctalLiteral = 'Octal literals are not allowed in strict mode.',
    MessageStrictDuplicateProperty = 'Duplicate data property in object literal not allowed in strict mode';
var ILLEGAL = 'ILLEGAL',
    DISABLED = 'Disabled.'; // See also tools/generate-unicode-regex.py.

var RegexNonAsciiIdentifierStart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),
    // eslint-disable-next-line no-misleading-character-class
RegexNonAsciiIdentifierPart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'); // Ensure the condition is true, otherwise throw an error.
// This is only to have a better contract semantic, i.e. another safety net
// to catch a logic error. The condition shall be fulfilled in normal case.
// Do NOT use this to enforce a certain condition on any user input.

function assert(condition, message) {
  /* istanbul ignore next */
  if (!condition) {
    throw new Error('ASSERT: ' + message);
  }
}

function isDecimalDigit(ch) {
  return ch >= 0x30 && ch <= 0x39; // 0..9
}

function isHexDigit(ch) {
  return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
}

function isOctalDigit(ch) {
  return '01234567'.indexOf(ch) >= 0;
} // 7.2 White Space


function isWhiteSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;
} // 7.3 Line Terminators


function isLineTerminator(ch) {
  return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
} // 7.6 Identifier Names and Identifiers


function isIdentifierStart(ch) {
  return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch === 0x5C || ch >= 0x80 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch));
}

function isIdentifierPart(ch) {
  return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch >= 0x30 && ch <= 0x39 || ch === 0x5C || ch >= 0x80 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch));
} // 7.6.1.1 Keywords


const keywords = {
  'if': 1,
  'in': 1,
  'do': 1,
  'var': 1,
  'for': 1,
  'new': 1,
  'try': 1,
  'let': 1,
  'this': 1,
  'else': 1,
  'case': 1,
  'void': 1,
  'with': 1,
  'enum': 1,
  'while': 1,
  'break': 1,
  'catch': 1,
  'throw': 1,
  'const': 1,
  'yield': 1,
  'class': 1,
  'super': 1,
  'return': 1,
  'typeof': 1,
  'delete': 1,
  'switch': 1,
  'export': 1,
  'import': 1,
  'public': 1,
  'static': 1,
  'default': 1,
  'finally': 1,
  'extends': 1,
  'package': 1,
  'private': 1,
  'function': 1,
  'continue': 1,
  'debugger': 1,
  'interface': 1,
  'protected': 1,
  'instanceof': 1,
  'implements': 1
};

function skipComment() {
  while (index < length) {
    const ch = source.charCodeAt(index);

    if (isWhiteSpace(ch) || isLineTerminator(ch)) {
      ++index;
    } else {
      break;
    }
  }
}

function scanHexEscape(prefix) {
  var i,
      len,
      ch,
      code = 0;
  len = prefix === 'u' ? 4 : 2;

  for (i = 0; i < len; ++i) {
    if (index < length && isHexDigit(source[index])) {
      ch = source[index++];
      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }

  return String.fromCharCode(code);
}

function scanUnicodeCodePointEscape() {
  var ch, code, cu1, cu2;
  ch = source[index];
  code = 0; // At least, one hex digit is required.

  if (ch === '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  while (index < length) {
    ch = source[index++];

    if (!isHexDigit(ch)) {
      break;
    }

    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
  }

  if (code > 0x10FFFF || ch !== '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  } // UTF-16 Encoding


  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  }

  cu1 = (code - 0x10000 >> 10) + 0xD800;
  cu2 = (code - 0x10000 & 1023) + 0xDC00;
  return String.fromCharCode(cu1, cu2);
}

function getEscapedIdentifier() {
  var ch, id;
  ch = source.charCodeAt(index++);
  id = String.fromCharCode(ch); // '\u' (U+005C, U+0075) denotes an escaped character.

  if (ch === 0x5C) {
    if (source.charCodeAt(index) !== 0x75) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }

    ++index;
    ch = scanHexEscape('u');

    if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }

    id = ch;
  }

  while (index < length) {
    ch = source.charCodeAt(index);

    if (!isIdentifierPart(ch)) {
      break;
    }

    ++index;
    id += String.fromCharCode(ch); // '\u' (U+005C, U+0075) denotes an escaped character.

    if (ch === 0x5C) {
      id = id.substr(0, id.length - 1);

      if (source.charCodeAt(index) !== 0x75) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }

      ++index;
      ch = scanHexEscape('u');

      if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }

      id += ch;
    }
  }

  return id;
}

function getIdentifier() {
  var start, ch;
  start = index++;

  while (index < length) {
    ch = source.charCodeAt(index);

    if (ch === 0x5C) {
      // Blackslash (U+005C) marks Unicode escape sequence.
      index = start;
      return getEscapedIdentifier();
    }

    if (isIdentifierPart(ch)) {
      ++index;
    } else {
      break;
    }
  }

  return source.slice(start, index);
}

function scanIdentifier() {
  var start, id, type;
  start = index; // Backslash (U+005C) starts an escaped character.

  id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier(); // There is no keyword or literal with only one character.
  // Thus, it must be an identifier.

  if (id.length === 1) {
    type = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id)) {
    // eslint-disable-line no-prototype-builtins
    type = TokenKeyword;
  } else if (id === 'null') {
    type = TokenNullLiteral;
  } else if (id === 'true' || id === 'false') {
    type = TokenBooleanLiteral;
  } else {
    type = TokenIdentifier;
  }

  return {
    type: type,
    value: id,
    start: start,
    end: index
  };
} // 7.7 Punctuators


function scanPunctuator() {
  var start = index,
      code = source.charCodeAt(index),
      code2,
      ch1 = source[index],
      ch2,
      ch3,
      ch4;

  switch (code) {
    // Check for most common single-character punctuators.
    case 0x2E: // . dot

    case 0x28: // ( open bracket

    case 0x29: // ) close bracket

    case 0x3B: // ; semicolon

    case 0x2C: // , comma

    case 0x7B: // { open curly brace

    case 0x7D: // } close curly brace

    case 0x5B: // [

    case 0x5D: // ]

    case 0x3A: // :

    case 0x3F: // ?

    case 0x7E:
      // ~
      ++index;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start: start,
        end: index
      };

    default:
      code2 = source.charCodeAt(index + 1); // '=' (U+003D) marks an assignment or comparison operator.

      if (code2 === 0x3D) {
        switch (code) {
          case 0x2B: // +

          case 0x2D: // -

          case 0x2F: // /

          case 0x3C: // <

          case 0x3E: // >

          case 0x5E: // ^

          case 0x7C: // |

          case 0x25: // %

          case 0x26: // &

          case 0x2A:
            // *
            index += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start: start,
              end: index
            };

          case 0x21: // !

          case 0x3D:
            // =
            index += 2; // !== and ===

            if (source.charCodeAt(index) === 0x3D) {
              ++index;
            }

            return {
              type: TokenPunctuator,
              value: source.slice(start, index),
              start: start,
              end: index
            };
        }
      }

  } // 4-character punctuator: >>>=


  ch4 = source.substr(index, 4);

  if (ch4 === '>>>=') {
    index += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start: start,
      end: index
    };
  } // 3-character punctuators: === !== >>> <<= >>=


  ch3 = ch4.substr(0, 3);

  if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
    index += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start: start,
      end: index
    };
  } // Other 2-character punctuators: ++ -- << >> && ||


  ch2 = ch3.substr(0, 2);

  if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {
    index += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start: start,
      end: index
    };
  }

  if (ch2 === '//') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  } // 1-character punctuators: < > = ! + - * % & | ^ /


  if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
    ++index;
    return {
      type: TokenPunctuator,
      value: ch1,
      start: start,
      end: index
    };
  }

  throwError({}, MessageUnexpectedToken, ILLEGAL);
} // 7.8.3 Numeric Literals


function scanHexLiteral(start) {
  let number = '';

  while (index < length) {
    if (!isHexDigit(source[index])) {
      break;
    }

    number += source[index++];
  }

  if (number.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseInt('0x' + number, 16),
    start: start,
    end: index
  };
}

function scanOctalLiteral(start) {
  let number = '0' + source[index++];

  while (index < length) {
    if (!isOctalDigit(source[index])) {
      break;
    }

    number += source[index++];
  }

  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseInt(number, 8),
    octal: true,
    start: start,
    end: index
  };
}

function scanNumericLiteral() {
  var number, start, ch;
  ch = source[index];
  assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
  start = index;
  number = '';

  if (ch !== '.') {
    number = source[index++];
    ch = source[index]; // Hex number starts with '0x'.
    // Octal number starts with '0'.

    if (number === '0') {
      if (ch === 'x' || ch === 'X') {
        ++index;
        return scanHexLiteral(start);
      }

      if (isOctalDigit(ch)) {
        return scanOctalLiteral(start);
      } // decimal number starts with '0' such as '09' is illegal.


      if (ch && isDecimalDigit(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }

    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }

    ch = source[index];
  }

  if (ch === '.') {
    number += source[index++];

    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }

    ch = source[index];
  }

  if (ch === 'e' || ch === 'E') {
    number += source[index++];
    ch = source[index];

    if (ch === '+' || ch === '-') {
      number += source[index++];
    }

    if (isDecimalDigit(source.charCodeAt(index))) {
      while (isDecimalDigit(source.charCodeAt(index))) {
        number += source[index++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }

  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseFloat(number),
    start: start,
    end: index
  };
} // 7.8.4 String Literals


function scanStringLiteral() {
  var str = '',
      quote,
      start,
      ch,
      code,
      octal = false;
  quote = source[index];
  assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
  start = index;
  ++index;

  while (index < length) {
    ch = source[index++];

    if (ch === quote) {
      quote = '';
      break;
    } else if (ch === '\\') {
      ch = source[index++];

      if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
        switch (ch) {
          case 'u':
          case 'x':
            if (source[index] === '{') {
              ++index;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch);
            }

            break;

          case 'n':
            str += '\n';
            break;

          case 'r':
            str += '\r';
            break;

          case 't':
            str += '\t';
            break;

          case 'b':
            str += '\b';
            break;

          case 'f':
            str += '\f';
            break;

          case 'v':
            str += '\x0B';
            break;

          default:
            if (isOctalDigit(ch)) {
              code = '01234567'.indexOf(ch); // \0 is not octal escape sequence

              if (code !== 0) {
                octal = true;
              }

              if (index < length && isOctalDigit(source[index])) {
                octal = true;
                code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts
                // with 0, 1, 2, 3

                if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                  code = code * 8 + '01234567'.indexOf(source[index++]);
                }
              }

              str += String.fromCharCode(code);
            } else {
              str += ch;
            }

            break;
        }
      } else {
        if (ch === '\r' && source[index] === '\n') {
          ++index;
        }
      }
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      break;
    } else {
      str += ch;
    }
  }

  if (quote !== '') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenStringLiteral,
    value: str,
    octal: octal,
    start: start,
    end: index
  };
}

function testRegExp(pattern, flags) {
  let tmp = pattern;

  if (flags.indexOf('u') >= 0) {
    // Replace each astral symbol and every Unicode code point
    // escape sequence with a single ASCII symbol to avoid throwing on
    // regular expressions that are only valid in combination with the
    // `/u` flag.
    // Note: replacing with the ASCII symbol `x` might cause false
    // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
    // perfectly valid pattern that is equivalent to `[a-b]`, but it
    // would be replaced by `[x-b]` which throws an error.
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 0x10FFFF) {
        return 'x';
      }

      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
  } // First, detect invalid regular expressions.


  try {
    new RegExp(tmp);
  } catch (e) {
    throwError({}, MessageInvalidRegExp);
  } // Return a regular expression object for this pattern-flag pair, or
  // `null` in case the current environment doesn't support the flags it
  // uses.


  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}

function scanRegExpBody() {
  var ch, str, classMarker, terminated, body;
  ch = source[index];
  assert(ch === '/', 'Regular expression literal must start with a slash');
  str = source[index++];
  classMarker = false;
  terminated = false;

  while (index < length) {
    ch = source[index++];
    str += ch;

    if (ch === '\\') {
      ch = source[index++]; // ECMA-262 7.8.5

      if (isLineTerminator(ch.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }

      str += ch;
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch === ']') {
        classMarker = false;
      }
    } else {
      if (ch === '/') {
        terminated = true;
        break;
      } else if (ch === '[') {
        classMarker = true;
      }
    }
  }

  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  } // Exclude leading and trailing slash.


  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}

function scanRegExpFlags() {
  var ch, str, flags;
  str = '';
  flags = '';

  while (index < length) {
    ch = source[index];

    if (!isIdentifierPart(ch.charCodeAt(0))) {
      break;
    }

    ++index;

    if (ch === '\\' && index < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch;
      str += ch;
    }
  }

  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }

  return {
    value: flags,
    literal: str
  };
}

function scanRegExp() {
  var start, body, flags, value;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start: start,
    end: index
  };
}

function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}

function advance() {
  skipComment();

  if (index >= length) {
    return {
      type: TokenEOF,
      start: index,
      end: index
    };
  }

  const ch = source.charCodeAt(index);

  if (isIdentifierStart(ch)) {
    return scanIdentifier();
  } // Very common: ( and ) and ;


  if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
    return scanPunctuator();
  } // String literal starts with single quote (U+0027) or double quote (U+0022).


  if (ch === 0x27 || ch === 0x22) {
    return scanStringLiteral();
  } // Dot (.) U+002E can also start a floating-point number, hence the need
  // to check the next character.


  if (ch === 0x2E) {
    if (isDecimalDigit(source.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }

    return scanPunctuator();
  }

  if (isDecimalDigit(ch)) {
    return scanNumericLiteral();
  }

  return scanPunctuator();
}

function lex() {
  const token = lookahead;
  index = token.end;
  lookahead = advance();
  index = token.end;
  return token;
}

function peek() {
  const pos = index;
  lookahead = advance();
  index = pos;
}

function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}

function finishBinaryExpression(operator, left, right) {
  const node = new ASTNode(operator === '||' || operator === '&&' ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator;
  node.left = left;
  node.right = right;
  return node;
}

function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}

function finishConditionalExpression(test, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}

function finishIdentifier(name) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name;
  return node;
}

function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source.slice(token.start, token.end);

  if (token.regex) {
    if (node.raw === '//') {
      node.raw = '/(?:)/';
    }

    node.regex = token.regex;
  }

  return node;
}

function finishMemberExpression(accessor, object, property) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor === '[';
  node.object = object;
  node.property = property;
  if (!node.computed) property.member = true;
  return node;
}

function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}

function finishProperty(kind, key, value) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key;
  node.value = value;
  node.kind = kind;
  return node;
}

function finishUnaryExpression(operator, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator;
  node.argument = argument;
  node.prefix = true;
  return node;
} // Throw an exception


function throwError(token, messageFormat) {
  var error,
      args = Array.prototype.slice.call(arguments, 2),
      msg = messageFormat.replace(/%(\d)/g, (whole, index) => {
    assert(index < args.length, 'Message reference must be in range');
    return args[index];
  });
  error = new Error(msg);
  error.index = index;
  error.description = msg;
  throw error;
} // Throw an exception because of the token.


function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }

  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }

  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }

  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }

  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  } // BooleanLiteral, NullLiteral, or Punctuator.


  throwError(token, MessageUnexpectedToken, token.value);
} // Expect the next token to match the specified punctuator.
// If not, an exception will be thrown.


function expect(value) {
  const token = lex();

  if (token.type !== TokenPunctuator || token.value !== value) {
    throwUnexpected(token);
  }
} // Return true if the next token matches the specified punctuator.


function match(value) {
  return lookahead.type === TokenPunctuator && lookahead.value === value;
} // Return true if the next token matches the specified keyword


function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
} // 11.1.4 Array Initialiser


function parseArrayInitialiser() {
  const elements = [];
  index = lookahead.start;
  expect('[');

  while (!match(']')) {
    if (match(',')) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());

      if (!match(']')) {
        expect(',');
      }
    }
  }

  lex();
  return finishArrayExpression(elements);
} // 11.1.5 Object Initialiser


function parseObjectPropertyKey() {
  index = lookahead.start;
  const token = lex(); // Note: This function is called only from parseObjectProperty(), where
  // EOF and Punctuator tokens are already filtered out.

  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }

    return finishLiteral(token);
  }

  return finishIdentifier(token.value);
}

function parseObjectProperty() {
  var token, key, id, value;
  index = lookahead.start;
  token = lookahead;

  if (token.type === TokenIdentifier) {
    id = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', id, value);
  }

  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', key, value);
  }
}

function parseObjectInitialiser() {
  var properties = [],
      property,
      name,
      key,
      map = {},
      toString = String;
  index = lookahead.start;
  expect('{');

  while (!match('}')) {
    property = parseObjectProperty();

    if (property.key.type === SyntaxIdentifier) {
      name = property.key.name;
    } else {
      name = toString(property.key.value);
    }

    key = '$' + name;

    if (Object.prototype.hasOwnProperty.call(map, key)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map[key] = true;
    }

    properties.push(property);

    if (!match('}')) {
      expect(',');
    }
  }

  expect('}');
  return finishObjectExpression(properties);
} // 11.1.6 The Grouping Operator


function parseGroupExpression() {
  expect('(');
  const expr = parseExpression();
  expect(')');
  return expr;
} // 11.1 Primary Expressions


const legalKeywords = {
  'if': 1
};

function parsePrimaryExpression() {
  var type, token, expr;

  if (match('(')) {
    return parseGroupExpression();
  }

  if (match('[')) {
    return parseArrayInitialiser();
  }

  if (match('{')) {
    return parseObjectInitialiser();
  }

  type = lookahead.type;
  index = lookahead.start;

  if (type === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr = finishIdentifier(lex().value);
  } else if (type === TokenStringLiteral || type === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }

    expr = finishLiteral(lex());
  } else if (type === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === 'true';
    expr = finishLiteral(token);
  } else if (type === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr = finishLiteral(token);
  } else if (match('/') || match('/=')) {
    expr = finishLiteral(scanRegExp());
    peek();
  } else {
    throwUnexpected(lex());
  }

  return expr;
} // 11.2 Left-Hand-Side Expressions


function parseArguments() {
  const args = [];
  expect('(');

  if (!match(')')) {
    while (index < length) {
      args.push(parseConditionalExpression());

      if (match(')')) {
        break;
      }

      expect(',');
    }
  }

  expect(')');
  return args;
}

function parseNonComputedProperty() {
  index = lookahead.start;
  const token = lex();

  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }

  return finishIdentifier(token.value);
}

function parseNonComputedMember() {
  expect('.');
  return parseNonComputedProperty();
}

function parseComputedMember() {
  expect('[');
  const expr = parseExpression();
  expect(']');
  return expr;
}

function parseLeftHandSideExpressionAllowCall() {
  var expr, args, property;
  expr = parsePrimaryExpression();

  for (;;) {
    if (match('.')) {
      property = parseNonComputedMember();
      expr = finishMemberExpression('.', expr, property);
    } else if (match('(')) {
      args = parseArguments();
      expr = finishCallExpression(expr, args);
    } else if (match('[')) {
      property = parseComputedMember();
      expr = finishMemberExpression('[', expr, property);
    } else {
      break;
    }
  }

  return expr;
} // 11.3 Postfix Expressions


function parsePostfixExpression() {
  const expr = parseLeftHandSideExpressionAllowCall();

  if (lookahead.type === TokenPunctuator) {
    if (match('++') || match('--')) {
      throw new Error(DISABLED);
    }
  }

  return expr;
} // 11.4 Unary Operators


function parseUnaryExpression() {
  var token, expr;

  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr = parsePostfixExpression();
  } else if (match('++') || match('--')) {
    throw new Error(DISABLED);
  } else if (match('+') || match('-') || match('~') || match('!')) {
    token = lex();
    expr = parseUnaryExpression();
    expr = finishUnaryExpression(token.value, expr);
  } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
    throw new Error(DISABLED);
  } else {
    expr = parsePostfixExpression();
  }

  return expr;
}

function binaryPrecedence(token) {
  let prec = 0;

  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }

  switch (token.value) {
    case '||':
      prec = 1;
      break;

    case '&&':
      prec = 2;
      break;

    case '|':
      prec = 3;
      break;

    case '^':
      prec = 4;
      break;

    case '&':
      prec = 5;
      break;

    case '==':
    case '!=':
    case '===':
    case '!==':
      prec = 6;
      break;

    case '<':
    case '>':
    case '<=':
    case '>=':
    case 'instanceof':
    case 'in':
      prec = 7;
      break;

    case '<<':
    case '>>':
    case '>>>':
      prec = 8;
      break;

    case '+':
    case '-':
      prec = 9;
      break;

    case '*':
    case '/':
    case '%':
      prec = 11;
      break;
  }

  return prec;
} // 11.5 Multiplicative Operators
// 11.6 Additive Operators
// 11.7 Bitwise Shift Operators
// 11.8 Relational Operators
// 11.9 Equality Operators
// 11.10 Binary Bitwise Operators
// 11.11 Binary Logical Operators


function parseBinaryExpression() {
  var marker, markers, expr, token, prec, stack, right, operator, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);

  if (prec === 0) {
    return left;
  }

  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack = [left, token, right];

  while ((prec = binaryPrecedence(lookahead)) > 0) {
    // Reduce: make a binary expression from the three topmost entries.
    while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
      right = stack.pop();
      operator = stack.pop().value;
      left = stack.pop();
      markers.pop();
      expr = finishBinaryExpression(operator, left, right);
      stack.push(expr);
    } // Shift.


    token = lex();
    token.prec = prec;
    stack.push(token);
    markers.push(lookahead);
    expr = parseUnaryExpression();
    stack.push(expr);
  } // Final reduce to clean-up the stack.


  i = stack.length - 1;
  expr = stack[i];
  markers.pop();

  while (i > 1) {
    markers.pop();
    expr = finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
    i -= 2;
  }

  return expr;
} // 11.12 Conditional Operator


function parseConditionalExpression() {
  var expr, consequent, alternate;
  expr = parseBinaryExpression();

  if (match('?')) {
    lex();
    consequent = parseConditionalExpression();
    expect(':');
    alternate = parseConditionalExpression();
    expr = finishConditionalExpression(expr, consequent, alternate);
  }

  return expr;
} // 11.14 Comma Operator


function parseExpression() {
  const expr = parseConditionalExpression();

  if (match(',')) {
    throw new Error(DISABLED); // no sequence expressions
  }

  return expr;
}

function parser (code) {
  source = code;
  index = 0;
  length = source.length;
  lookahead = null;
  peek();
  const expr = parseExpression();

  if (lookahead.type !== TokenEOF) {
    throw new Error('Unexpect token after expression.');
  }

  return expr;
}

var Constants = {
  NaN: 'NaN',
  E: 'Math.E',
  LN2: 'Math.LN2',
  LN10: 'Math.LN10',
  LOG2E: 'Math.LOG2E',
  LOG10E: 'Math.LOG10E',
  PI: 'Math.PI',
  SQRT1_2: 'Math.SQRT1_2',
  SQRT2: 'Math.SQRT2',
  MIN_VALUE: 'Number.MIN_VALUE',
  MAX_VALUE: 'Number.MAX_VALUE'
};

function Functions (codegen) {
  function fncall(name, args, cast, type) {
    let obj = codegen(args[0]);

    if (cast) {
      obj = cast + '(' + obj + ')';
      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';
    }

    return obj + '.' + name + (type < 0 ? '' : type === 0 ? '()' : '(' + args.slice(1).map(codegen).join(',') + ')');
  }

  function fn(name, cast, type) {
    return args => fncall(name, args, cast, type);
  }

  const DATE = 'new Date',
        STRING = 'String',
        REGEXP = 'RegExp';
  return {
    // MATH functions
    isNaN: 'Number.isNaN',
    isFinite: 'Number.isFinite',
    abs: 'Math.abs',
    acos: 'Math.acos',
    asin: 'Math.asin',
    atan: 'Math.atan',
    atan2: 'Math.atan2',
    ceil: 'Math.ceil',
    cos: 'Math.cos',
    exp: 'Math.exp',
    floor: 'Math.floor',
    log: 'Math.log',
    max: 'Math.max',
    min: 'Math.min',
    pow: 'Math.pow',
    random: 'Math.random',
    round: 'Math.round',
    sin: 'Math.sin',
    sqrt: 'Math.sqrt',
    tan: 'Math.tan',
    clamp: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to clamp function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to clamp function.');
      const a = args.map(codegen);
      return 'Math.max(' + a[1] + ', Math.min(' + a[2] + ',' + a[0] + '))';
    },
    // DATE functions
    now: 'Date.now',
    utc: 'Date.UTC',
    datetime: DATE,
    date: fn('getDate', DATE, 0),
    day: fn('getDay', DATE, 0),
    year: fn('getFullYear', DATE, 0),
    month: fn('getMonth', DATE, 0),
    hours: fn('getHours', DATE, 0),
    minutes: fn('getMinutes', DATE, 0),
    seconds: fn('getSeconds', DATE, 0),
    milliseconds: fn('getMilliseconds', DATE, 0),
    time: fn('getTime', DATE, 0),
    timezoneoffset: fn('getTimezoneOffset', DATE, 0),
    utcdate: fn('getUTCDate', DATE, 0),
    utcday: fn('getUTCDay', DATE, 0),
    utcyear: fn('getUTCFullYear', DATE, 0),
    utcmonth: fn('getUTCMonth', DATE, 0),
    utchours: fn('getUTCHours', DATE, 0),
    utcminutes: fn('getUTCMinutes', DATE, 0),
    utcseconds: fn('getUTCSeconds', DATE, 0),
    utcmilliseconds: fn('getUTCMilliseconds', DATE, 0),
    // sequence functions
    length: fn('length', null, -1),
    // STRING functions
    parseFloat: 'parseFloat',
    parseInt: 'parseInt',
    upper: fn('toUpperCase', STRING, 0),
    lower: fn('toLowerCase', STRING, 0),
    substring: fn('substring', STRING),
    split: fn('split', STRING),
    trim: fn('trim', STRING, 0),
    // REGEXP functions
    regexp: REGEXP,
    test: fn('test', REGEXP),
    // Control Flow functions
    if: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to if function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to if function.');
      const a = args.map(codegen);
      return '(' + a[0] + '?' + a[1] + ':' + a[2] + ')';
    }
  };
}

function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === '\'' && s[n] === '\'') ? s.slice(1, -1) : s;
}

function codegen (opt) {
  opt = opt || {};
  const allowed = opt.allowed ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.allowed) : {},
        forbidden = opt.forbidden ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.forbidden) : {},
        constants = opt.constants || Constants,
        functions = (opt.functions || Functions)(visit),
        globalvar = opt.globalvar,
        fieldvar = opt.fieldvar,
        outputGlobal = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(globalvar) ? globalvar : id => `${globalvar}["${id}"]`;
  let globals = {},
      fields = {},
      memberDepth = 0;

  function visit(ast) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(ast)) return ast;
    const generator = Generators[ast.type];
    if (generator == null) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported type: ' + ast.type);
    return generator(ast);
  }

  const Generators = {
    Literal: n => n.raw,
    Identifier: n => {
      const id = n.name;

      if (memberDepth > 0) {
        return id;
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(forbidden, id)) {
        return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal identifier: ' + id);
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(constants, id)) {
        return constants[id];
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(allowed, id)) {
        return id;
      } else {
        globals[id] = 1;
        return outputGlobal(id);
      }
    },
    MemberExpression: n => {
      const d = !n.computed,
            o = visit(n.object);
      if (d) memberDepth += 1;
      const p = visit(n.property);

      if (o === fieldvar) {
        // strip quotes to sanitize field name (#1653)
        fields[stripQuotes(p)] = 1;
      }

      if (d) memberDepth -= 1;
      return o + (d ? '.' + p : '[' + p + ']');
    },
    CallExpression: n => {
      if (n.callee.type !== 'Identifier') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal callee type: ' + n.callee.type);
      }

      const callee = n.callee.name,
            args = n.arguments,
            fn = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(functions, callee) && functions[callee];
      if (!fn) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized function: ' + callee);
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(fn) ? fn(args) : fn + '(' + args.map(visit).join(',') + ')';
    },
    ArrayExpression: n => '[' + n.elements.map(visit).join(',') + ']',
    BinaryExpression: n => '(' + visit(n.left) + ' ' + n.operator + ' ' + visit(n.right) + ')',
    UnaryExpression: n => '(' + n.operator + visit(n.argument) + ')',
    ConditionalExpression: n => '(' + visit(n.test) + '?' + visit(n.consequent) + ':' + visit(n.alternate) + ')',
    LogicalExpression: n => '(' + visit(n.left) + n.operator + visit(n.right) + ')',
    ObjectExpression: n => '{' + n.properties.map(visit).join(',') + '}',
    Property: n => {
      memberDepth += 1;
      const k = visit(n.key);
      memberDepth -= 1;
      return k + ':' + visit(n.value);
    }
  };

  function codegen(ast) {
    const result = {
      code: visit(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }

  codegen.functions = functions;
  codegen.constants = constants;
  return codegen;
}




/***/ }),

/***/ "../../node_modules/vega-force/build/vega-force.module.js":
/*!****************************************************************!*\
  !*** ../../node_modules/vega-force/build/vega-force.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "force": () => (/* binding */ Force)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-force */ "../../node_modules/d3-force/src/center.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-force */ "../../node_modules/d3-force/src/collide.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-force */ "../../node_modules/d3-force/src/manyBody.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-force */ "../../node_modules/d3-force/src/link.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-force */ "../../node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-force */ "../../node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-force */ "../../node_modules/d3-force/src/simulation.js");




const ForceMap = {
  center: d3_force__WEBPACK_IMPORTED_MODULE_2__.default,
  collide: d3_force__WEBPACK_IMPORTED_MODULE_3__.default,
  nbody: d3_force__WEBPACK_IMPORTED_MODULE_4__.default,
  link: d3_force__WEBPACK_IMPORTED_MODULE_5__.default,
  x: d3_force__WEBPACK_IMPORTED_MODULE_6__.default,
  y: d3_force__WEBPACK_IMPORTED_MODULE_7__.default
};
const Forces = 'forces',
      ForceParams = ['alpha', 'alphaMin', 'alphaTarget', 'velocityDecay', 'forces'],
      ForceConfig = ['static', 'iterations'],
      ForceOutput = ['x', 'y', 'vx', 'vy'];
/**
 * Force simulation layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<object>} params.forces - The forces to apply.
 */

function Force(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Force.Definition = {
  'type': 'Force',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'static',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'restart',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'iterations',
    'type': 'number',
    'default': 300
  }, {
    'name': 'alpha',
    'type': 'number',
    'default': 1
  }, {
    'name': 'alphaMin',
    'type': 'number',
    'default': 0.001
  }, {
    'name': 'alphaTarget',
    'type': 'number',
    'default': 0
  }, {
    'name': 'velocityDecay',
    'type': 'number',
    'default': 0.4
  }, {
    'name': 'forces',
    'type': 'param',
    'array': true,
    'params': [{
      'key': {
        'force': 'center'
      },
      'params': [{
        'name': 'x',
        'type': 'number',
        'default': 0
      }, {
        'name': 'y',
        'type': 'number',
        'default': 0
      }]
    }, {
      'key': {
        'force': 'collide'
      },
      'params': [{
        'name': 'radius',
        'type': 'number',
        'expr': true
      }, {
        'name': 'strength',
        'type': 'number',
        'default': 0.7
      }, {
        'name': 'iterations',
        'type': 'number',
        'default': 1
      }]
    }, {
      'key': {
        'force': 'nbody'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': -30
      }, {
        'name': 'theta',
        'type': 'number',
        'default': 0.9
      }, {
        'name': 'distanceMin',
        'type': 'number',
        'default': 1
      }, {
        'name': 'distanceMax',
        'type': 'number'
      }]
    }, {
      'key': {
        'force': 'link'
      },
      'params': [{
        'name': 'links',
        'type': 'data'
      }, {
        'name': 'id',
        'type': 'field'
      }, {
        'name': 'distance',
        'type': 'number',
        'default': 30,
        'expr': true
      }, {
        'name': 'strength',
        'type': 'number',
        'expr': true
      }, {
        'name': 'iterations',
        'type': 'number',
        'default': 1
      }]
    }, {
      'key': {
        'force': 'x'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': 0.1
      }, {
        'name': 'x',
        'type': 'field'
      }]
    }, {
      'key': {
        'force': 'y'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': 0.1
      }, {
        'name': 'y',
        'type': 'field'
      }]
    }]
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'modify': false,
    'default': ForceOutput
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Force, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var sim = this.value,
        change = pulse.changed(pulse.ADD_REM),
        params = _.modified(ForceParams),
        iters = _.iterations || 300; // configure simulation


    if (!sim) {
      this.value = sim = simulation(pulse.source, _);
      sim.on('tick', rerun(pulse.dataflow, this));

      if (!_.static) {
        change = true;
        sim.tick(); // ensure we run on init
      }

      pulse.modifies('index');
    } else {
      if (change) {
        pulse.modifies('index');
        sim.nodes(pulse.source);
      }

      if (params || pulse.changed(pulse.MOD)) {
        setup(sim, _, 0, pulse);
      }
    } // run simulation


    if (params || change || _.modified(ForceConfig) || pulse.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));

      if (_.static) {
        for (sim.stop(); --iters >= 0;) sim.tick();
      } else {
        if (sim.stopped()) sim.restart();
        if (!change) return pulse.StopPropagation; // defer to sim ticks
      }
    }

    return this.finish(_, pulse);
  },

  finish(_, pulse) {
    const dataflow = pulse.dataflow; // inspect dependencies, touch link source data

    for (let args = this._argops, j = 0, m = args.length, arg; j < m; ++j) {
      arg = args[j];

      if (arg.name !== Forces || arg.op._argval.force !== 'link') {
        continue;
      }

      for (var ops = arg.op._argops, i = 0, n = ops.length, op; i < n; ++i) {
        if (ops[i].name === 'links' && (op = ops[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    } // reflow all nodes


    return pulse.reflow(_.modified()).modifies(ForceOutput);
  }

});

function rerun(df, op) {
  return () => df.touch(op).run();
}

function simulation(nodes, _) {
  const sim = (0,d3_force__WEBPACK_IMPORTED_MODULE_8__.default)(nodes),
        stop = sim.stop,
        restart = sim.restart;
  let stopped = false;

  sim.stopped = () => stopped;

  sim.restart = () => (stopped = false, restart());

  sim.stop = () => (stopped = true, stop());

  return setup(sim, _, true).on('end', () => stopped = true);
}

function setup(sim, _, init, pulse) {
  var f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_.forces),
      i,
      n,
      p,
      name;

  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p)) sim[p](_[p]);
  }

  for (i = 0, n = f.length; i < n; ++i) {
    name = Forces + i;
    p = init || _.modified(Forces, i) ? getForce(f[i]) : pulse && modified(f[i], pulse) ? sim.force(name) : null;
    if (p) sim.force(name, p);
  }

  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null); // remove
  }

  sim.numForces = f.length;
  return sim;
}

function modified(f, pulse) {
  var k, v;

  for (k in f) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(v = f[k]) && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(v))) return 1;
  }

  return 0;
}

function getForce(_) {
  var f, p;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(ForceMap, _.force)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized force: ' + _.force);
  }

  f = ForceMap[_.force]();

  for (p in _) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f[p])) setForceParam(f[p], _[p], _);
  }

  return f;
}

function setForceParam(f, v, _) {
  f((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(v) ? d => v(d, _) : v);
}




/***/ }),

/***/ "../../node_modules/vega-format/build/vega-format.module.js":
/*!******************************************************************!*\
  !*** ../../node_modules/vega-format/build/vega-format.module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultLocale": () => (/* binding */ defaultLocale),
/* harmony export */   "locale": () => (/* binding */ locale),
/* harmony export */   "numberFormatDefaultLocale": () => (/* binding */ numberFormatDefaultLocale),
/* harmony export */   "numberFormatLocale": () => (/* binding */ numberFormatLocale),
/* harmony export */   "resetDefaultLocale": () => (/* binding */ resetDefaultLocale),
/* harmony export */   "resetNumberFormatDefaultLocale": () => (/* binding */ resetNumberFormatDefaultLocale),
/* harmony export */   "resetTimeFormatDefaultLocale": () => (/* binding */ resetTimeFormatDefaultLocale),
/* harmony export */   "timeFormatDefaultLocale": () => (/* binding */ timeFormatDefaultLocale),
/* harmony export */   "timeFormatLocale": () => (/* binding */ timeFormatLocale)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/precisionFixed.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-format */ "../../node_modules/d3-format/src/locale.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time-format */ "../../node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time-format */ "../../node_modules/d3-time-format/src/locale.js");






function memoize (method) {
  const cache = {};
  return spec => cache[spec] || (cache[spec] = method(spec));
}

function trimZeroes(numberFormat, decimalChar) {
  return x => {
    const str = numberFormat(x),
          dec = str.indexOf(decimalChar);
    if (dec < 0) return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : '';

    while (--idx > dec) if (str[idx] !== '0') {
      ++idx;
      break;
    }

    return str.slice(0, idx) + end;
  };
}

function rightmostDigit(str, dec) {
  let i = str.lastIndexOf('e'),
      c;
  if (i > 0) return i;

  for (i = str.length; --i > dec;) {
    c = str.charCodeAt(i);
    if (c >= 48 && c <= 57) return i + 1; // is digit
  }
}

function numberLocale(locale) {
  const format = memoize(locale.format),
        formatPrefix = locale.formatPrefix;
  return {
    format,
    formatPrefix,

    formatFloat(spec) {
      const s = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(spec || ',');

      if (s.precision == null) {
        s.precision = 12;

        switch (s.type) {
          case '%':
            s.precision -= 2;
            break;

          case 'e':
            s.precision -= 1;
            break;
        }

        return trimZeroes(format(s), // number format
        format('.1f')(1)[1] // decimal point character
        );
      } else {
        return format(s);
      }
    },

    formatSpan(start, stop, count, specifier) {
      specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(specifier == null ? ',f' : specifier);
      const step = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start, stop, count),
            value = Math.max(Math.abs(start), Math.abs(stop));
      let precision;

      if (specifier.precision == null) {
        switch (specifier.type) {
          case 's':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.default)(step, value))) {
                specifier.precision = precision;
              }

              return formatPrefix(specifier, value);
            }

          case '':
          case 'e':
          case 'g':
          case 'p':
          case 'r':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__.default)(step, value))) {
                specifier.precision = precision - (specifier.type === 'e');
              }

              break;
            }

          case 'f':
          case '%':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_6__.default)(step))) {
                specifier.precision = precision - (specifier.type === '%') * 2;
              }

              break;
            }
        }
      }

      return format(specifier);
    }

  };
}

let defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format: d3_format__WEBPACK_IMPORTED_MODULE_7__.format,
    formatPrefix: d3_format__WEBPACK_IMPORTED_MODULE_7__.formatPrefix
  });
}
function numberFormatLocale(definition) {
  return numberLocale((0,d3_format__WEBPACK_IMPORTED_MODULE_8__.default)(definition));
}
function numberFormatDefaultLocale(definition) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition) : defaultNumberLocale;
}

function timeMultiFormat(format, interval, spec) {
  spec = spec || {};

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(spec)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)("Invalid time multi-format specifier: ".concat(spec));
  }

  const second = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.SECONDS),
        minute = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.MINUTES),
        hour = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.HOURS),
        day = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.DATE),
        week = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.WEEK),
        month = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.MONTH),
        quarter = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.QUARTER),
        year = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.YEAR),
        L = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MILLISECONDS] || '.%L'),
        S = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.SECONDS] || ':%S'),
        M = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MINUTES] || '%I:%M'),
        H = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.HOURS] || '%I %p'),
        d = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.DATE] || spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.DAY] || '%a %d'),
        w = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.WEEK] || '%b %d'),
        m = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MONTH] || '%B'),
        q = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.QUARTER] || '%B'),
        y = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.YEAR] || '%Y');
  return date => (second(date) < date ? L : minute(date) < date ? S : hour(date) < date ? M : day(date) < date ? H : month(date) < date ? week(date) < date ? d : w : year(date) < date ? quarter(date) < date ? m : q : y)(date);
}

function timeLocale(locale) {
  const timeFormat = memoize(locale.format),
        utcFormat = memoize(locale.utcFormat);
  return {
    timeFormat: spec => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isString)(spec) ? timeFormat(spec) : timeMultiFormat(timeFormat, vega_time__WEBPACK_IMPORTED_MODULE_0__.timeInterval, spec),
    utcFormat: spec => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isString)(spec) ? utcFormat(spec) : timeMultiFormat(utcFormat, vega_time__WEBPACK_IMPORTED_MODULE_0__.utcInterval, spec),
    timeParse: memoize(locale.parse),
    utcParse: memoize(locale.utcParse)
  };
}

let defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.timeFormat,
    parse: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.timeParse,
    utcFormat: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.utcFormat,
    utcParse: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.utcParse
  });
}
function timeFormatLocale(definition) {
  return timeLocale((0,d3_time_format__WEBPACK_IMPORTED_MODULE_10__.default)(definition));
}
function timeFormatDefaultLocale(definition) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition) : defaultTimeLocale;
}

const createLocale = (number, time) => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, number, time);

function locale(numberSpec, timeSpec) {
  const number = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
  const time = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
  return createLocale(number, time);
}
function defaultLocale(numberSpec, timeSpec) {
  const args = arguments.length;

  if (args && args !== 2) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('defaultLocale expects either zero or two arguments.');
  }

  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale();
  resetTimeFormatDefaultLocale();
  return defaultLocale();
}




/***/ }),

/***/ "../../node_modules/vega-functions/build/vega-functions.module.js":
/*!************************************************************************!*\
  !*** ../../node_modules/vega-functions/build/vega-functions.module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataPrefix": () => (/* binding */ DataPrefix),
/* harmony export */   "IndexPrefix": () => (/* binding */ IndexPrefix),
/* harmony export */   "ScalePrefix": () => (/* binding */ ScalePrefix),
/* harmony export */   "SignalPrefix": () => (/* binding */ SignalPrefix),
/* harmony export */   "bandspace": () => (/* binding */ bandspace),
/* harmony export */   "bandwidth": () => (/* binding */ bandwidth),
/* harmony export */   "codeGenerator": () => (/* binding */ codeGenerator),
/* harmony export */   "codegenParams": () => (/* binding */ codegenParams),
/* harmony export */   "containerSize": () => (/* binding */ containerSize),
/* harmony export */   "contrast": () => (/* binding */ contrast),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "data": () => (/* binding */ data),
/* harmony export */   "dataVisitor": () => (/* binding */ dataVisitor),
/* harmony export */   "dayAbbrevFormat": () => (/* binding */ dayAbbrevFormat),
/* harmony export */   "dayFormat": () => (/* binding */ dayFormat),
/* harmony export */   "debug": () => (/* binding */ debug),
/* harmony export */   "domain": () => (/* binding */ domain),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "expressionFunction": () => (/* binding */ expressionFunction),
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "functionContext": () => (/* binding */ functionContext),
/* harmony export */   "geoArea": () => (/* binding */ geoArea),
/* harmony export */   "geoBounds": () => (/* binding */ geoBounds),
/* harmony export */   "geoCentroid": () => (/* binding */ geoCentroid),
/* harmony export */   "geoShape": () => (/* binding */ geoShape),
/* harmony export */   "inScope": () => (/* binding */ inScope),
/* harmony export */   "indata": () => (/* binding */ indata),
/* harmony export */   "indataVisitor": () => (/* binding */ indataVisitor),
/* harmony export */   "indexof": () => (/* binding */ indexof),
/* harmony export */   "info": () => (/* binding */ info),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "join": () => (/* binding */ join),
/* harmony export */   "lastindexof": () => (/* binding */ lastindexof),
/* harmony export */   "luminance": () => (/* binding */ luminance),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "modify": () => (/* binding */ modify),
/* harmony export */   "monthAbbrevFormat": () => (/* binding */ monthAbbrevFormat),
/* harmony export */   "monthFormat": () => (/* binding */ monthFormat),
/* harmony export */   "parseExpression": () => (/* binding */ parser),
/* harmony export */   "pathShape": () => (/* binding */ pathShape),
/* harmony export */   "pinchAngle": () => (/* binding */ pinchAngle),
/* harmony export */   "pinchDistance": () => (/* binding */ pinchDistance),
/* harmony export */   "pluck": () => (/* binding */ pluck),
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "replace": () => (/* binding */ replace),
/* harmony export */   "reverse": () => (/* binding */ reverse),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleGradient": () => (/* binding */ scaleGradient),
/* harmony export */   "scaleVisitor": () => (/* binding */ scaleVisitor),
/* harmony export */   "screen": () => (/* binding */ screen),
/* harmony export */   "setdata": () => (/* binding */ setdata),
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "timeFormat": () => (/* binding */ timeFormat),
/* harmony export */   "timeParse": () => (/* binding */ timeParse),
/* harmony export */   "treeAncestors": () => (/* binding */ treeAncestors),
/* harmony export */   "treePath": () => (/* binding */ treePath),
/* harmony export */   "utcFormat": () => (/* binding */ utcFormat),
/* harmony export */   "utcParse": () => (/* binding */ utcParse),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "windowSize": () => (/* binding */ windowSize)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-expression */ "../../node_modules/vega-expression/build/vega-expression.module.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/area.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/bounds.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/centroid.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/lab.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_selections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-selections */ "../../node_modules/vega-selections/build/vega-selection.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");












function data(name) {
  const data = this.context.data[name];
  return data ? data.values.value : [];
}
function indata(name, field, value) {
  const index = this.context.data[name]['index:' + field],
        entry = index ? index.value.get(value) : undefined;
  return entry ? entry.count : entry;
}
function setdata(name, tuples) {
  const df = this.context.dataflow,
        data = this.context.data[name],
        input = data.input;
  df.pulse(input, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(tuples));
  return 1;
}

function encode (item, name, retval) {
  if (item) {
    const df = this.context.dataflow,
          target = item.mark.source;
    df.pulse(target, df.changeset().encode(item, name));
  }

  return retval !== undefined ? retval : item;
}

const wrap = method => function (value, spec) {
  const locale = this.context.dataflow.locale();
  return locale[method](spec)(value);
};

const format = wrap('format');
const timeFormat = wrap('timeFormat');
const utcFormat = wrap('utcFormat');
const timeParse = wrap('timeParse');
const utcParse = wrap('utcParse');
const dateObj = new Date(2000, 0, 1);

function time(month, day, specifier) {
  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';
  dateObj.setYear(2000);
  dateObj.setMonth(month);
  dateObj.setDate(day);
  return timeFormat.call(this, dateObj, specifier);
}

function monthFormat(month) {
  return time.call(this, month, 1, '%B');
}
function monthAbbrevFormat(month) {
  return time.call(this, month, 1, '%b');
}
function dayFormat(day) {
  return time.call(this, 0, 2 + day, '%A');
}
function dayAbbrevFormat(day) {
  return time.call(this, 0, 2 + day, '%a');
}

const DataPrefix = ':';
const IndexPrefix = '@';
const ScalePrefix = '%';
const SignalPrefix = '$';

function dataVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to data functions must be a string literal.');
  }

  const data = args[0].value,
        dataName = DataPrefix + data;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(dataName, params)) {
    try {
      params[dataName] = scope.getData(data).tuplesRef();
    } catch (err) {// if data set does not exist, there's nothing to track
    }
  }
}
function indataVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to indata must be a string literal.');
  if (args[1].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Second argument to indata must be a string literal.');
  const data = args[0].value,
        field = args[1].value,
        indexName = IndexPrefix + field;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(indexName, params)) {
    params[indexName] = scope.getData(data).indataRef(scope, field);
  }
}
function scaleVisitor(name, args, scope, params) {
  if (args[0].type === vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) {
    // add scale dependency
    addScaleDependency(scope, params, args[0].value);
  } else {
    // indirect scale lookup; add all scales as parameters
    for (name in scope.scales) {
      addScaleDependency(scope, params, name);
    }
  }
}

function addScaleDependency(scope, params, name) {
  const scaleName = ScalePrefix + name;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, scaleName)) {
    try {
      params[scaleName] = scope.scaleRef(name);
    } catch (err) {// TODO: error handling? warning?
    }
  }
}

function getScale(name, ctx) {
  let s;
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(name) ? name : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? (s = ctx.scales[name]) && s.value : undefined;
}
function internalScaleFunctions(codegen, fnctx, visitors) {
  // add helper method to the 'this' expression function context
  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0; // register AST visitors for internal scale functions


  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor; // resolve scale reference directly to the signal hash argument

  const ref = arg => '_[' + (arg.type === vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ScalePrefix + arg.value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ScalePrefix) + '+' + codegen(arg)) + ']'; // define and return internal scale function code generators
  // these internal functions are called by mark encoders


  return {
    _bandwidth: args => `this.__bandwidth(${ref(args[0])})`,
    _range: args => `${ref(args[0])}.range()`,
    _scale: args => `${ref(args[0])}(${codegen(args[1])})`
  };
}

function geoMethod(methodName, globalMethod) {
  return function (projection, geojson, group) {
    if (projection) {
      // projection defined, use it
      const p = getScale(projection, (group || this).context);
      return p && p.path[methodName](geojson);
    } else {
      // projection undefined, use global method
      return globalMethod(geojson);
    }
  };
}

const geoArea = geoMethod('area', d3_geo__WEBPACK_IMPORTED_MODULE_8__.default);
const geoBounds = geoMethod('bounds', d3_geo__WEBPACK_IMPORTED_MODULE_9__.default);
const geoCentroid = geoMethod('centroid', d3_geo__WEBPACK_IMPORTED_MODULE_10__.default);

function inScope (item) {
  const group = this.context.group;
  let value = false;
  if (group) while (item) {
    if (item === group) {
      value = true;
      break;
    }

    item = item.mark.group;
  }
  return value;
}

function log(df, method, args) {
  try {
    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }

  return args[args.length - 1];
}

function warn() {
  return log(this.context.dataflow, 'warn', arguments);
}
function info() {
  return log(this.context.dataflow, 'info', arguments);
}
function debug() {
  return log(this.context.dataflow, 'debug', arguments);
}

function channel_luminance_value(channelValue) {
  const val = channelValue / 255;

  if (val <= 0.03928) {
    return val / 12.92;
  }

  return Math.pow((val + 0.055) / 1.055, 2.4);
}

function luminance(color) {
  const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_11__.rgb)(color),
        r = channel_luminance_value(c.r),
        g = channel_luminance_value(c.g),
        b = channel_luminance_value(c.b);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
} // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef

function contrast(color1, color2) {
  const lum1 = luminance(color1),
        lum2 = luminance(color2),
        lumL = Math.max(lum1, lum2),
        lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}

function merge () {
  const args = [].slice.call(arguments);
  args.unshift({});
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(...args);
}

function equal(a, b) {
  return a === b || a !== a && b !== b ? true : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(a) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(b) && a.length === b.length ? equalArray(a, b) : false : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(b) ? equalObject(a, b) : false;
}

function equalArray(a, b) {
  for (let i = 0, n = a.length; i < n; ++i) {
    if (!equal(a[i], b[i])) return false;
  }

  return true;
}

function equalObject(a, b) {
  for (const key in a) {
    if (!equal(a[key], b[key])) return false;
  }

  return true;
}

function removePredicate(props) {
  return _ => equalObject(props, _);
}

function modify (name, insert, remove, toggle, modify, values) {
  const df = this.context.dataflow,
        data = this.context.data[name],
        input = data.input,
        stamp = df.stamp();
  let changes = data.changes,
      predicate,
      key;

  if (df._trigger === false || !(input.value.length || insert || toggle)) {
    // nothing to do!
    return 0;
  }

  if (!changes || changes.stamp < stamp) {
    data.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }

  if (remove) {
    predicate = remove === true ? vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(remove) || (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_2__.isTuple)(remove) ? remove : removePredicate(remove);
    changes.remove(predicate);
  }

  if (insert) {
    changes.insert(insert);
  }

  if (toggle) {
    predicate = removePredicate(toggle);

    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle);
    }
  }

  if (modify) {
    for (key in values) {
      changes.modify(modify, key, values[key]);
    }
  }

  return 1;
}

function pinchDistance(event) {
  const t = event.touches,
        dx = t[0].clientX - t[1].clientX,
        dy = t[0].clientY - t[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function pinchAngle(event) {
  const t = event.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}

const accessors = {};
function pluck (data, name) {
  const accessor = accessors[name] || (accessors[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(name));
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data) ? data.map(accessor) : accessor(data);
}

function array(seq) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(seq) || ArrayBuffer.isView(seq) ? seq : null;
}

function sequence(seq) {
  return array(seq) || ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(seq) ? seq : null);
}

function join(seq, ...args) {
  return array(seq).join(...args);
}
function indexof(seq, ...args) {
  return sequence(seq).indexOf(...args);
}
function lastindexof(seq, ...args) {
  return sequence(seq).lastIndexOf(...args);
}
function slice(seq, ...args) {
  return sequence(seq).slice(...args);
}
function replace(str, pattern, repl) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(repl)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Function argument passed to replace.');
  return String(str).replace(pattern, repl);
}
function reverse(seq) {
  return array(seq).slice().reverse();
}

function bandspace(count, paddingInner, paddingOuter) {
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.bandSpace)(count || 0, paddingInner || 0, paddingOuter || 0);
}
function bandwidth(name, group) {
  const s = getScale(name, (group || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy(name, group) {
  const s = getScale(name, (group || this).context);
  return s ? s.copy() : undefined;
}
function domain(name, group) {
  const s = getScale(name, (group || this).context);
  return s ? s.domain() : [];
}
function invert(name, range, group) {
  const s = getScale(name, (group || this).context);
  return !s ? undefined : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);
}
function range(name, group) {
  const s = getScale(name, (group || this).context);
  return s && s.range ? s.range() : [];
}
function scale(name, value, group) {
  const s = getScale(name, (group || this).context);
  return s ? s(value) : undefined;
}

function scaleGradient (scale, p0, p1, count, group) {
  scale = getScale(scale, (group || this).context);
  const gradient = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.Gradient)(p0, p1);
  let stops = scale.domain(),
      min = stops[0],
      max = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(stops),
      fraction = vega_util__WEBPACK_IMPORTED_MODULE_0__.identity;

  if (!(max - min)) {
    // expand scale if domain has zero span, fix #1479
    scale = (scale.interpolator ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('sequential')().interpolator(scale.interpolator()) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);
  } else {
    fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scaleFraction)(scale, min, max);
  }

  if (scale.ticks) {
    stops = scale.ticks(+count || 15);
    if (min !== stops[0]) stops.unshift(min);
    if (max !== (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(stops)) stops.push(max);
  }

  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));
  return gradient;
}

function geoShape(projection, geojson, group) {
  const p = getScale(projection, (group || this).context);
  return function (context) {
    return p ? p.path.context(context)(geojson) : '';
  };
}
function pathShape(path) {
  let p = null;
  return function (context) {
    return context ? (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.pathRender)(context, p = p || (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.pathParse)(path)) : path;
  };
}

const datum = d => d.data;

function treeNodes(name, context) {
  const tree = data.call(context, name);
  return tree.root && tree.root.lookup || {};
}

function treePath(name, source, target) {
  const nodes = treeNodes(name, this),
        s = nodes[source],
        t = nodes[target];
  return s && t ? s.path(t).map(datum) : undefined;
}
function treeAncestors(name, node) {
  const n = treeNodes(name, this)[node];
  return n ? n.ancestors().map(datum) : undefined;
}

const _window = () => typeof window !== 'undefined' && window || null;

function screen() {
  const w = _window();

  return w ? w.screen : {};
}
function windowSize() {
  const w = _window();

  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];
}
function containerSize() {
  const view = this.context.dataflow,
        el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];
}

function intersect (b, opt, group) {
  if (!b) return [];
  const [u, v] = b,
        box = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.Bounds().set(u[0], u[1], v[0], v[1]),
        scene = group || this.context.dataflow.scenegraph().root;
  return (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.intersect)(scene, box, filter(opt));
}

function filter(opt) {
  let p = null;

  if (opt) {
    const types = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(opt.marktype),
          names = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(opt.markname);

    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));
  }

  return p;
}

const functionContext = {
  random() {
    return (0,vega_statistics__WEBPACK_IMPORTED_MODULE_6__.random)();
  },

  // override default
  cumulativeNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeNormal,
  cumulativeLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeLogNormal,
  cumulativeUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeUniform,
  densityNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityNormal,
  densityLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityLogNormal,
  densityUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityUniform,
  quantileNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileNormal,
  quantileLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileLogNormal,
  quantileUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileUniform,
  sampleNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleNormal,
  sampleLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleLogNormal,
  sampleUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleUniform,
  isArray: vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray,
  isBoolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.isBoolean,
  isDate: vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate,

  isDefined(_) {
    return _ !== undefined;
  },

  isNumber: vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber,
  isObject: vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject,
  isRegExp: vega_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp,
  isString: vega_util__WEBPACK_IMPORTED_MODULE_0__.isString,
  isTuple: vega_dataflow__WEBPACK_IMPORTED_MODULE_2__.isTuple,

  isValid(_) {
    return _ != null && _ === _;
  },

  toBoolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean,
  toDate: vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate,
  toNumber: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  toString: vega_util__WEBPACK_IMPORTED_MODULE_0__.toString,
  indexof,
  join,
  lastindexof,
  replace,
  reverse,
  slice,
  flush: vega_util__WEBPACK_IMPORTED_MODULE_0__.flush,
  lerp: vega_util__WEBPACK_IMPORTED_MODULE_0__.lerp,
  merge,
  pad: vega_util__WEBPACK_IMPORTED_MODULE_0__.pad,
  peek: vega_util__WEBPACK_IMPORTED_MODULE_0__.peek,
  pluck,
  span: vega_util__WEBPACK_IMPORTED_MODULE_0__.span,
  inrange: vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange,
  truncate: vega_util__WEBPACK_IMPORTED_MODULE_0__.truncate,
  rgb: d3_color__WEBPACK_IMPORTED_MODULE_11__.rgb,
  lab: d3_color__WEBPACK_IMPORTED_MODULE_12__.default,
  hcl: d3_color__WEBPACK_IMPORTED_MODULE_12__.hcl,
  hsl: d3_color__WEBPACK_IMPORTED_MODULE_11__.hsl,
  luminance,
  contrast,
  sequence: d3_array__WEBPACK_IMPORTED_MODULE_13__.default,
  format,
  utcFormat,
  utcParse,
  utcOffset: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcOffset,
  utcSequence: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcSequence,
  timeFormat,
  timeParse,
  timeOffset: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeOffset,
  timeSequence: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeSequence,
  timeUnitSpecifier: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeUnitSpecifier,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter: vega_util__WEBPACK_IMPORTED_MODULE_0__.quarter,
  utcquarter: vega_util__WEBPACK_IMPORTED_MODULE_0__.utcquarter,
  week: vega_time__WEBPACK_IMPORTED_MODULE_7__.week,
  utcweek: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcweek,
  dayofyear: vega_time__WEBPACK_IMPORTED_MODULE_7__.dayofyear,
  utcdayofyear: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcdayofyear,
  warn,
  info,
  debug,
  extent: vega_util__WEBPACK_IMPORTED_MODULE_0__.extent,
  inScope,
  intersect,
  clampRange: vega_util__WEBPACK_IMPORTED_MODULE_0__.clampRange,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear: vega_util__WEBPACK_IMPORTED_MODULE_0__.panLinear,
  panLog: vega_util__WEBPACK_IMPORTED_MODULE_0__.panLog,
  panPow: vega_util__WEBPACK_IMPORTED_MODULE_0__.panPow,
  panSymlog: vega_util__WEBPACK_IMPORTED_MODULE_0__.panSymlog,
  zoomLinear: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLinear,
  zoomLog: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLog,
  zoomPow: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomPow,
  zoomSymlog: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomSymlog,
  encode,
  modify
};
const eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],
      // event functions
eventPrefix = 'event.vega.',
      // event function prefix
thisPrefix = 'this.',
      // function context prefix
astVisitors = {}; // AST visitors for dependency analysis
// export code generator parameters

const codegenParams = {
  forbidden: ['_'],
  allowed: ['datum', 'event', 'item'],
  fieldvar: 'datum',
  globalvar: id => `_[${(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(SignalPrefix + id)}]`,
  functions: buildFunctions,
  constants: vega_expression__WEBPACK_IMPORTED_MODULE_1__.constants,
  visitors: astVisitors
}; // export code generator

const codeGenerator = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.codegenExpression)(codegenParams); // Build expression function registry

function buildFunctions(codegen) {
  const fn = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.functions)(codegen);
  eventFunctions.forEach(name => fn[name] = eventPrefix + name);

  for (const name in functionContext) {
    fn[name] = thisPrefix + name;
  }

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(fn, internalScaleFunctions(codegen, functionContext, astVisitors));
  return fn;
} // Register an expression function


function expressionFunction(name, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name];
  } // register with the functionContext


  functionContext[name] = fn; // if there is an astVisitor register that, too

  if (visitor) astVisitors[name] = visitor; // if the code generator has already been initialized,
  // we need to also register the function with it

  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;
  return this;
} // register expression functions with ast visitors

expressionFunction('bandwidth', bandwidth, scaleVisitor);
expressionFunction('copy', copy, scaleVisitor);
expressionFunction('domain', domain, scaleVisitor);
expressionFunction('range', range, scaleVisitor);
expressionFunction('invert', invert, scaleVisitor);
expressionFunction('scale', scale, scaleVisitor);
expressionFunction('gradient', scaleGradient, scaleVisitor);
expressionFunction('geoArea', geoArea, scaleVisitor);
expressionFunction('geoBounds', geoBounds, scaleVisitor);
expressionFunction('geoCentroid', geoCentroid, scaleVisitor);
expressionFunction('geoShape', geoShape, scaleVisitor);
expressionFunction('indata', indata, indataVisitor);
expressionFunction('data', data, dataVisitor);
expressionFunction('treePath', treePath, dataVisitor);
expressionFunction('treeAncestors', treeAncestors, dataVisitor); // register Vega-Lite selection functions

expressionFunction('vlSelectionTest', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionTest, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionIdTest', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionIdTest, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionResolve', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionResolve, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionTuples', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionTuples);

function parser (expr, scope) {
  const params = {}; // parse the expression to an abstract syntax tree (ast)

  let ast;

  try {
    expr = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(expr) ? expr : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(expr) + '';
    ast = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(expr);
  } catch (err) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expression parse error: ' + expr);
  } // analyze ast function calls for dependencies


  ast.visit(node => {
    if (node.type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.CallExpression) return;
    const name = node.callee.name,
          visit = codegenParams.visitors[name];
    if (visit) visit(name, node.arguments, scope, params);
  }); // perform code generation

  const gen = codeGenerator(ast); // collect signal dependencies

  gen.globals.forEach(name => {
    const signalName = SignalPrefix + name;

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, signalName) && scope.getSignal(name)) {
      params[signalName] = scope.signalRef(name);
    }
  }); // return generated expression code and dependencies

  return {
    $expr: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params
  };
}




/***/ }),

/***/ "../../node_modules/vega-geo/build/vega-geo.module.js":
/*!************************************************************!*\
  !*** ../../node_modules/vega-geo/build/vega-geo.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "contour": () => (/* binding */ Contour),
/* harmony export */   "geojson": () => (/* binding */ GeoJSON),
/* harmony export */   "geopath": () => (/* binding */ GeoPath),
/* harmony export */   "geopoint": () => (/* binding */ GeoPoint),
/* harmony export */   "geoshape": () => (/* binding */ GeoShape),
/* harmony export */   "graticule": () => (/* binding */ Graticule),
/* harmony export */   "heatmap": () => (/* binding */ Heatmap),
/* harmony export */   "isocontour": () => (/* binding */ Isocontour),
/* harmony export */   "kde2d": () => (/* binding */ KDE2D),
/* harmony export */   "projection": () => (/* binding */ Projection)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/sum.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_projection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-projection */ "../../node_modules/vega-projection/build/vega-projection.module.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/graticule.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-color */ "../../node_modules/d3-color/src/color.js");
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-canvas */ "../../node_modules/vega-canvas/index.browser.js");









function noop() {}

const cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []]; // Implementation adapted from d3/d3-contour. Thanks!

function contours () {
  var dx = 1,
      dy = 1,
      smooth = smoothLinear;

  function contours(values, tz) {
    return tz.map(value => contour(values, value));
  } // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js


  function contour(values, value) {
    var polygons = [],
        holes = [];
    isorings(values, value, ring => {
      smooth(ring, values, value);
      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);
    });
    holes.forEach(hole => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: 'MultiPolygon',
      value: value,
      coordinates: polygons
    };
  } // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js


  function isorings(values, value, callback) {
    var fragmentByStart = new Array(),
        fragmentByEnd = new Array(),
        x,
        y,
        t0,
        t1,
        t2,
        t3; // Special case for the first row (y = -1, t2 = t3 = 0).

    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);

    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }

    cases[t1 << 0].forEach(stitch); // General case for the intermediate rows.

    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);

      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }

      cases[t1 | t2 << 3].forEach(stitch);
    } // Special case for the last row (y = dy - 1, t0 = t1 = 0).


    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);

    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }

    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f,
          g;

      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];

          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];

          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(point => {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];

      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }

      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function (_) {
    if (!arguments.length) return [dx, dy];

    var _0 = Math.floor(_[0]),
        _1 = Math.floor(_[1]);

    if (!(_0 >= 0 && _1 >= 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid size');
    return dx = _0, dy = _1, contours;
  };

  contours.smooth = function (_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
  };

  return contours;
}

function area(ring) {
  var i = 0,
      n = ring.length,
      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];

  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];

  return area;
}

function contains(ring, hole) {
  var i = -1,
      n = hole.length,
      c;

  while (++i < n) if (c = ringContains(ring, hole[i])) return c;

  return 0;
}

function ringContains(ring, point) {
  var x = point[0],
      y = point[1],
      contains = -1;

  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i],
        xi = pi[0],
        yi = pi[1],
        pj = ring[j],
        xj = pj[0],
        yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;
  }

  return contains;
}

function segmentContains(a, b, c) {
  var i;
  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

function quantize (k, nice, zero) {
  return function (values) {
    var ex = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extent)(values),
        start = zero ? Math.min(ex[0], 0) : ex[0],
        stop = ex[1],
        span = stop - start,
        step = nice ? (0,d3_array__WEBPACK_IMPORTED_MODULE_5__.tickStep)(start, stop, k) : span / (k + 1);
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_6__.default)(start + step, stop, step);
  };
}

/**
 * Generate isocontours (level sets) based on input raster grid data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} [params.field] - The field with raster grid
 *   data. If unspecified, the tuple itself is interpreted as a raster grid.
 * @param {Array<number>} [params.thresholds] - Contour threshold array. If
 *   specified, the levels, nice, resolve, and zero parameters are ignored.
 * @param {number} [params.levels] - The desired number of contour levels.
 * @param {boolean} [params.nice] - Boolean flag indicating if the contour
 *   threshold values should be automatically aligned to "nice"
 *   human-friendly values. Setting this flag may cause the number of
 *   thresholds to deviate from the specified levels.
 * @param {string} [params.resolve] - The method for resolving thresholds
 *   across multiple input grids. If 'independent' (the default), threshold
 *   calculation will be performed separately for each grid. If 'shared', a
 *   single set of threshold values will be used for all input grids.
 * @param {boolean} [params.zero] - Boolean flag indicating if the contour
 *   threshold values should include zero.
 * @param {boolean} [params.smooth] - Boolean flag indicating if the contour
 *   polygons should be smoothed using linear interpolation. The default is
 *   true. The parameter is ignored when using density estimation.
 * @param {boolean} [params.scale] - Optional numerical value by which to
 *   scale the output isocontour coordinates. This parameter can be useful
 *   to scale the contours to match a desired output resolution.
 * @param {string} [params.as='contour'] - The output field in which to store
 *   the generated isocontour data (default 'contour').
 */

function Isocontour(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Isocontour.Definition = {
  'type': 'Isocontour',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'thresholds',
    'type': 'number',
    'array': true
  }, {
    'name': 'levels',
    'type': 'number'
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'zero',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'scale',
    'type': 'number',
    'expr': true
  }, {
    'name': 'translate',
    'type': 'number',
    'array': true,
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'default': 'contour'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Isocontour, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }

    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        source = pulse.materialize(pulse.SOURCE).source,
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        contour = contours().smooth(_.smooth !== false),
        tz = _.thresholds || levels(source, field, _),
        as = _.as === null ? null : _.as || 'contour',
        values = [];
    source.forEach(t => {
      const grid = field(t); // generate contour paths in GeoJSON format

      const paths = contour.size([grid.width, grid.height])(grid.values, (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(tz) ? tz : tz(grid.values)); // adjust contour path coordinates as needed

      transformPaths(paths, grid, t, _); // ingest; copy source data properties to output

      paths.forEach(p => {
        values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.rederive)(t, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values;
    return out;
  }

});

function levels(values, f, _) {
  const q = quantize(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== 'shared' ? q : q(values.map(t => (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(f(t).values)));
}

function transformPaths(paths, grid, datum, _) {
  let s = _.scale || grid.scale,
      t = _.translate || grid.translate;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) s = s(datum, _);
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(t)) t = t(datum, _);
  if ((s === 1 || s == null) && !t) return;
  const sx = ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(s) ? s : s[0]) || 1,
        sy = ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(s) ? s : s[1]) || 1,
        tx = t && t[0] || 0,
        ty = t && t[1] || 0;
  paths.forEach(transform(grid, sx, sy, tx, ty));
}

function transform(grid, sx, sy, tx, ty) {
  const x1 = grid.x1 || 0,
        y1 = grid.y1 || 0,
        flip = sx * sy < 0;

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    if (flip) coordinates.reverse(); // maintain winding order

    coordinates.forEach(transformPoint);
  }

  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x1) * sx + tx;
    coordinates[1] = (coordinates[1] - y1) * sy + ty;
  }

  return function (geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}

function radius(bw, data, f) {
  const v = bw >= 0 ? bw : (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bandwidthNRD)(data, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}

function number(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(_) ? _ : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(+_);
} // Implementation adapted from d3/d3-contour. Thanks!


function density2D () {
  var x = d => d[0],
      y = d => d[1],
      weight = vega_util__WEBPACK_IMPORTED_MODULE_1__.one,
      bandwidth = [-1, -1],
      dx = 960,
      dy = 500,
      k = 2; // log2(cellSize)


  function density(data, counts) {
    const rx = radius(bandwidth[0], data, x) >> k,
          // blur x-radius
    ry = radius(bandwidth[1], data, y) >> k,
          // blur y-radius
    ox = rx ? rx + 2 : 0,
          // x-offset padding for blur
    oy = ry ? ry + 2 : 0,
          // y-offset padding for blur
    n = 2 * ox + (dx >> k),
          // grid width
    m = 2 * oy + (dy >> k),
          // grid height
    values0 = new Float32Array(n * m),
          values1 = new Float32Array(n * m);
    let values = values0;
    data.forEach(d => {
      const xi = ox + (+x(d) >> k),
            yi = oy + (+y(d) >> k);

      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += +weight(d);
      }
    });

    if (rx > 0 && ry > 0) {
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m, values0, values1, rx);
      blurX(n, m, values1, values0, rx);
      blurX(n, m, values0, values1, rx);
      values = values1;
    } else if (ry > 0) {
      blurY(n, m, values0, values1, ry);
      blurY(n, m, values1, values0, ry);
      blurY(n, m, values0, values1, ry);
      values = values1;
    } // scale density estimates
    // density in points per square pixel or probability density


    const s = counts ? Math.pow(2, -2 * k) : 1 / (0,d3_array__WEBPACK_IMPORTED_MODULE_8__.default)(values);

    for (let i = 0, sz = n * m; i < sz; ++i) values[i] *= s;

    return {
      values: values,
      scale: 1 << k,
      width: n,
      height: m,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k),
      y2: oy + (dy >> k)
    };
  }

  density.x = function (_) {
    return arguments.length ? (x = number(_), density) : x;
  };

  density.y = function (_) {
    return arguments.length ? (y = number(_), density) : y;
  };

  density.weight = function (_) {
    return arguments.length ? (weight = number(_), density) : weight;
  };

  density.size = function (_) {
    if (!arguments.length) return [dx, dy];

    var _0 = +_[0],
        _1 = +_[1];

    if (!(_0 >= 0 && _1 >= 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid size');
    return dx = _0, dy = _1, density;
  };

  density.cellSize = function (_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid cell size');
    k = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };

  density.bandwidth = function (_) {
    if (!arguments.length) return bandwidth;
    _ = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_);
    if (_.length === 1) _ = [+_[0], +_[0]];
    if (_.length !== 2) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid bandwidth');
    return bandwidth = _, density;
  };

  return density;
}

function blurX(n, m, source, target, r) {
  const w = (r << 1) + 1;

  for (let j = 0; j < m; ++j) {
    for (let i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source[i + j * n];
      }

      if (i >= r) {
        if (i >= w) {
          sr -= source[i - w + j * n];
        }

        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

function blurY(n, m, source, target, r) {
  const w = (r << 1) + 1;

  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source[i + j * n];
      }

      if (j >= r) {
        if (j >= w) {
          sr -= source[i + (j - w) * n];
        }

        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

/**
 * Perform 2D kernel-density estimation of point data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The [width, height] extent (in
 *   units of input pixels) over which to perform density estimation.
 * @param {function(object): number} params.x - The x-coordinate accessor.
 * @param {function(object): number} params.y - The y-coordinate accessor.
 * @param {function(object): number} [params.weight] - The weight accessor.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {number} [params.cellSize] - Contour density calculation cell size.
 *   This parameter determines the level of spatial approximation. For example,
 *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.
 *   A value of 1 will result in an output raster grid whose dimensions exactly
 *   matches the size parameter.
 * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,
 *   in pixels. The input can be a two-element array specifying separate
 *   x and y bandwidths, or a single-element array specifying both. If the
 *   bandwidth is unspecified or less than zero, the bandwidth will be
 *   automatically determined.
 * @param {boolean} [params.counts=false] - A boolean flag indicating if the
 *   output values should be probability estimates (false, default) or
 *   smoothed counts (true).
 * @param {string} [params.as='grid'] - The output field in which to store
 *   the generated raster grid (default 'grid').
 */

function KDE2D(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
KDE2D.Definition = {
  'type': 'KDE2D',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'weight',
    'type': 'field'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'cellSize',
    'type': 'number'
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'counts',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'grid'
  }]
};
const PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];
function params(obj, _) {
  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);
  return obj;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(KDE2D, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;
    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        source = pulse.materialize(pulse.SOURCE).source,
        groups = partition(source, _.groupby),
        names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorName),
        kde = params(density2D(), _),
        as = _.as || 'grid',
        values = [];

    function set(t, vals) {
      for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];

      return t;
    } // generate density raster grids


    values = groups.map(g => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(set({
      [as]: kde(g, _.counts)
    }, g.dims)));
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values;
    return out;
  }

});
function partition(data, groupby) {
  var groups = [],
      get = f => f(t),
      map,
      i,
      n,
      t,
      k,
      g; // partition data points into groups


  if (groupby == null) {
    groups.push(data);
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }

      g.push(t);
    }
  }

  return groups;
}

/**
 * Generate contours based on kernel-density estimation of point data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.
 *  If the values parameter is provided, this must be the dimensions of the input data.
 *  If density estimation is performed, this is the output view dimensions in pixels.
 * @param {Array<number>} [params.values] - An array of numeric values representing an
 *  width x height grid of values over which to compute contours. If unspecified, this
 *  transform will instead attempt to compute contours for the kernel density estimate
 *  using values drawn from data tuples in the input pulse.
 * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.
 * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.
 * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.
 * @param {number} [params.cellSize] - Contour density calculation cell size.
 * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.
 * @param {Array<number>} [params.thresholds] - Contour threshold array. If
 *   this parameter is set, the count and nice parameters will be ignored.
 * @param {number} [params.count] - The desired number of contours.
 * @param {boolean} [params.nice] - Boolean flag indicating if the contour
 *   threshold values should be automatically aligned to "nice"
 *   human-friendly values. Setting this flag may cause the number of
 *   thresholds to deviate from the specified count.
 * @param {boolean} [params.smooth] - Boolean flag indicating if the contour
 *   polygons should be smoothed using linear interpolation. The default is
 *   true. The parameter is ignored when using density estimation.
 */

function Contour(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Contour.Definition = {
  'type': 'Contour',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'values',
    'type': 'number',
    'array': true
  }, {
    'name': 'x',
    'type': 'field'
  }, {
    'name': 'y',
    'type': 'field'
  }, {
    'name': 'weight',
    'type': 'field'
  }, {
    'name': 'cellSize',
    'type': 'number'
  }, {
    'name': 'bandwidth',
    'type': 'number'
  }, {
    'name': 'count',
    'type': 'number'
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'thresholds',
    'type': 'number',
    'array': true
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Contour, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }

    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        contour = contours().smooth(_.smooth !== false),
        values = _.values,
        thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),
        size = _.size,
        grid,
        post;

    if (!values) {
      values = pulse.materialize(pulse.SOURCE).source;
      grid = params(density2D(), _)(values, true);
      post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values = grid.values;
    }

    thresh = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(thresh) ? thresh : thresh(values);
    values = contour.size(size)(values, thresh);
    if (post) values.forEach(post);
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = (values || []).map(vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest);
    return out;
  }

});

const Feature = 'Feature';
const FeatureCollection = 'FeatureCollection';
const MultiPoint = 'MultiPoint';

/**
 * Consolidate an array of [longitude, latitude] points or GeoJSON features
 * into a combined GeoJSON object. This transform is particularly useful for
 * combining geo data for a Projection's fit argument. The resulting GeoJSON
 * data is available as this transform's value. Input pulses are unchanged.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.fields] - A two-element array
 *   of field accessors for the longitude and latitude values.
 * @param {function(object): *} params.geojson - A field accessor for
 *   retrieving GeoJSON feature data.
 */

function GeoJSON(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoJSON.Definition = {
  'type': 'GeoJSON',
  'metadata': {},
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'length': 2
  }, {
    'name': 'geojson',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoJSON, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var features = this._features,
        points = this._points,
        fields = _.fields,
        lon = fields && fields[0],
        lat = fields && fields[1],
        geojson = _.geojson || !fields && vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        flag = pulse.ADD,
        mod;
    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(geojson)) || lon && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(lon)) || lat && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(lat));

    if (!this.value || mod) {
      flag = pulse.SOURCE;
      this._features = features = [];
      this._points = points = [];
    }

    if (geojson) {
      pulse.visit(flag, t => features.push(geojson(t)));
    }

    if (lon && lat) {
      pulse.visit(flag, t => {
        var x = lon(t),
            y = lat(t);

        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {
          points.push([x, y]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points
        }
      });
    }

    this.value = {
      type: FeatureCollection,
      features: features
    };
  }

});

/**
 * Map GeoJSON data to an SVG path string.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {function(object): *} [params.field] - The field with GeoJSON data,
 *   or null if the tuple itself is a GeoJSON feature.
 * @param {string} [params.as='path'] - The output field in which to store
 *   the generated path data (default 'path').
 */

function GeoPath(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoPath.Definition = {
  'type': 'GeoPath',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection'
  }, {
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'pointRadius',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoPath, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
        path = this.value,
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        as = _.as || 'path',
        flag = out.SOURCE;

    if (!path || _.modified()) {
      // parameters updated, reset and reflow
      this.value = path = (0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.getProjectionPath)(_.projection);
      out.materialize().reflow();
    } else {
      flag = field === vega_util__WEBPACK_IMPORTED_MODULE_1__.identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;
    }

    const prev = initPath(path, _.pointRadius);
    out.visit(flag, t => t[as] = path(field(t)));
    path.pointRadius(prev);
    return out.modifies(as);
  }

});

function initPath(path, pointRadius) {
  const prev = path.pointRadius();
  path.context(null);

  if (pointRadius != null) {
    path.pointRadius(pointRadius);
  }

  return prev;
}

/**
 * Geo-code a longitude/latitude point to an x/y coordinate.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {Array<function(object): *>} params.fields - A two-element array of
 *   field accessors for the longitude and latitude values.
 * @param {Array<string>} [params.as] - A two-element array of field names
 *   under which to store the result. Defaults to ['x','y'].
 */

function GeoPoint(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoPoint.Definition = {
  'type': 'GeoPoint',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection',
    'required': true
  }, {
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['x', 'y']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoPoint, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var proj = _.projection,
        lon = _.fields[0],
        lat = _.fields[1],
        as = _.as || ['x', 'y'],
        x = as[0],
        y = as[1],
        mod;

    function set(t) {
      const xy = proj([lon(t), lat(t)]);

      if (xy) {
        t[x] = xy[0];
        t[y] = xy[1];
      } else {
        t[x] = undefined;
        t[y] = undefined;
      }
    }

    if (_.modified()) {
      // parameters updated, reflow
      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);
    } else {
      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);
      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);
    }

    return pulse.modifies(as);
  }

});

/**
 * Annotate items with a geopath shape generator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {function(object): *} [params.field] - The field with GeoJSON data,
 *   or null if the tuple itself is a GeoJSON feature.
 * @param {string} [params.as='shape'] - The output field in which to store
 *   the generated path data (default 'shape').
 */

function GeoShape(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoShape.Definition = {
  'type': 'GeoShape',
  'metadata': {
    'modifies': true,
    'nomod': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection'
  }, {
    'name': 'field',
    'type': 'field',
    'default': 'datum'
  }, {
    'name': 'pointRadius',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'shape'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoShape, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
        shape = this.value,
        as = _.as || 'shape',
        flag = out.ADD;

    if (!shape || _.modified()) {
      // parameters updated, reset and reflow
      this.value = shape = shapeGenerator((0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.getProjectionPath)(_.projection), _.field || (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.field)('datum'), _.pointRadius);
      out.materialize().reflow();
      flag = out.SOURCE;
    }

    out.visit(flag, t => t[as] = shape);
    return out.modifies(as);
  }

});

function shapeGenerator(path, field, pointRadius) {
  const shape = pointRadius == null ? _ => path(field(_)) : _ => {
    var prev = path.pointRadius(),
        value = path.pointRadius(pointRadius)(field(_));
    path.pointRadius(prev);
    return value;
  };

  shape.context = _ => {
    path.context(_);
    return shape;
  };

  return shape;
}

/**
 * GeoJSON feature generator for creating graticules.
 * @constructor
 */

function Graticule(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
  this.generator = (0,d3_geo__WEBPACK_IMPORTED_MODULE_9__.default)();
}
Graticule.Definition = {
  'type': 'Graticule',
  'metadata': {
    'changes': true,
    'generates': true
  },
  'params': [{
    'name': 'extent',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'extentMajor',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'extentMinor',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'step',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'stepMajor',
    'type': 'number',
    'array': true,
    'length': 2,
    'default': [90, 360]
  }, {
    'name': 'stepMinor',
    'type': 'number',
    'array': true,
    'length': 2,
    'default': [10, 10]
  }, {
    'name': 'precision',
    'type': 'number',
    'default': 2.5
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Graticule, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var src = this.value,
        gen = this.generator,
        t;

    if (!src.length || _.modified()) {
      for (const prop in _) {
        if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }

    t = gen();

    if (src.length) {
      pulse.mod.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.replace)(src[0], t));
    } else {
      pulse.add.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(t));
    }

    src[0] = t;
    return pulse;
  }

});

/**
 * Render a heatmap image for input raster grid data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} [params.field] - The field with raster grid
 *   data. If unspecified, the tuple itself is interpreted as a raster grid.
 * @param {string} [params.color] - A constant color value or function for
 *   individual pixel color. If a function, it will be invoked with an input
 *   object that includes $x, $y, $value, and $max fields for the grid.
 * @param {number} [params.opacity] - A constant opacity value or function for
 *   individual pixel opacity. If a function, it will be invoked with an input
 *   object that includes $x, $y, $value, and $max fields for the grid.
 * @param {string} [params.resolve] - The method for resolving maximum values
 *   across multiple input grids. If 'independent' (the default), maximum
 *   calculation will be performed separately for each grid. If 'shared',
 *   a single global maximum will be used for all input grids.
 * @param {string} [params.as='image'] - The output field in which to store
 *   the generated bitmap canvas images (default 'image').
 */

function Heatmap(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Heatmap.Definition = {
  'type': 'heatmap',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'color',
    'type': 'string',
    'expr': true
  }, {
    'name': 'opacity',
    'type': 'number',
    'expr': true
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'image'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Heatmap, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }

    var source = pulse.materialize(pulse.SOURCE).source,
        shared = _.resolve === 'shared',
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        opacity = opacity_(_.opacity, _),
        color = color_(_.color, _),
        as = _.as || 'image',
        obj = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: shared ? (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(source.map(t => (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(field(t).values))) : 0
    };
    source.forEach(t => {
      const v = field(t); // build proxy data object

      const o = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, t, obj); // set maximum value if not globally shared

      if (!shared) o.$max = (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(v.values || []); // generate canvas image
      // optimize color/opacity if not pixel-dependent

      t[as] = toCanvas(v, o, color.dep ? color : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(color(o)), opacity.dep ? opacity : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(opacity(o)));
    });
    return pulse.reflow(true).modifies(as);
  }

}); // get image color function

function color_(color, _) {
  let f;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(color)) {
    f = obj => (0,d3_color__WEBPACK_IMPORTED_MODULE_10__.rgb)(color(obj, _));

    f.dep = dependency(color);
  } else {
    // default to mid-grey
    f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)((0,d3_color__WEBPACK_IMPORTED_MODULE_10__.rgb)(color || '#888'));
  }

  return f;
} // get image opacity function


function opacity_(opacity, _) {
  let f;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opacity)) {
    f = obj => opacity(obj, _);

    f.dep = dependency(opacity);
  } else if (opacity) {
    f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(opacity);
  } else {
    // default to [0, max] opacity gradient
    f = obj => obj.$value / obj.$max || 0;

    f.dep = true;
  }

  return f;
} // check if function depends on individual pixel data


function dependency(f) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f)) return false;
  const set = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.toSet)((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(f));
  return set.$x || set.$y || set.$value || set.$max;
} // render raster grid to canvas


function toCanvas(grid, obj, color, opacity) {
  const n = grid.width,
        m = grid.height,
        x1 = grid.x1 || 0,
        y1 = grid.y1 || 0,
        x2 = grid.x2 || n,
        y2 = grid.y2 || m,
        val = grid.values,
        value = val ? i => val[i] : vega_util__WEBPACK_IMPORTED_MODULE_1__.zero,
        can = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_4__.canvas)(x2 - x1, y2 - y1),
        ctx = can.getContext('2d'),
        img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),
        pix = img.data;

  for (let j = y1, k = 0; j < y2; ++j) {
    obj.$y = j - y1;

    for (let i = x1, r = j * n; i < x2; ++i, k += 4) {
      obj.$x = i - x1;
      obj.$value = value(i + r);
      const v = color(obj);
      pix[k + 0] = v.r;
      pix[k + 1] = v.g;
      pix[k + 2] = v.b;
      pix[k + 3] = ~~(255 * opacity(obj));
    }
  }

  ctx.putImageData(img, 0, 0);
  return can;
}

/**
 * Maintains a cartographic projection.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Projection(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Projection, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    let proj = this.value;

    if (!proj || _.modified('type')) {
      this.value = proj = create(_.type);
      vega_projection__WEBPACK_IMPORTED_MODULE_3__.projectionProperties.forEach(prop => {
        if (_[prop] != null) set(proj, prop, _[prop]);
      });
    } else {
      vega_projection__WEBPACK_IMPORTED_MODULE_3__.projectionProperties.forEach(prop => {
        if (_.modified(prop)) set(proj, prop, _[prop]);
      });
    }

    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);
    if (_.fit) fit(proj, _);
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
  }

});

function fit(proj, _) {
  const data = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;
}

function create(type) {
  const constructor = (0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.projection)((type || 'mercator').toLowerCase());
  if (!constructor) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized projection type: ' + type);
  return constructor();
}

function set(proj, key, value) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(proj[key])) proj[key](value);
}

function collectGeoJSON(data) {
  data = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(data);
  return data.length === 1 ? data[0] : {
    type: FeatureCollection,
    features: data.reduce((a, f) => a.concat(featurize(f)), [])
  };
}

function featurize(f) {
  return f.type === FeatureCollection ? f.features : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(f).filter(d => d != null).map(d => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}




/***/ }),

/***/ "../../node_modules/vega-hierarchy/build/vega-hierarchy.module.js":
/*!************************************************************************!*\
  !*** ../../node_modules/vega-hierarchy/build/vega-hierarchy.module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nest": () => (/* binding */ Nest),
/* harmony export */   "pack": () => (/* binding */ Pack),
/* harmony export */   "partition": () => (/* binding */ Partition),
/* harmony export */   "stratify": () => (/* binding */ Stratify),
/* harmony export */   "tree": () => (/* binding */ Tree),
/* harmony export */   "treelinks": () => (/* binding */ TreeLinks),
/* harmony export */   "treemap": () => (/* binding */ Treemap)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/hierarchy/index.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/pack/index.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/partition.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/stratify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/tree.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/cluster.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/treemap/binary.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/treemap/slice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/treemap/sliceDice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/treemap/squarify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/treemap/resquarify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-hierarchy */ "../../node_modules/d3-hierarchy/src/treemap/index.js");




// Build lookup table mapping tuple keys to tree node instances
function lookup (tree, key, filter) {
  const map = {};
  tree.each(node => {
    const t = node.data;
    if (filter(t)) map[key(t)] = node;
  });
  tree.lookup = map;
  return tree;
}

/**
 * Nest tuples into a tree structure, grouped by key values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.
 * @param {boolean} [params.generate=false] - A boolean flag indicating if
 *   non-leaf nodes generated by this transform should be included in the
 *   output. The default (false) includes only the input data (leaf nodes)
 *   in the data stream.
 */

function Nest(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Nest.Definition = {
  'type': 'Nest',
  'metadata': {
    'treesource': true,
    'changes': true
  },
  'params': [{
    'name': 'keys',
    'type': 'field',
    'array': true
  }, {
    'name': 'generate',
    'type': 'boolean'
  }]
};

const children = n => n.values;

(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Nest, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Nest transform requires an upstream data source.');
    }

    var gen = _.generate,
        mod = _.modified(),
        out = pulse.clone(),
        tree = this.value;

    if (!tree || mod || pulse.changed()) {
      // collect nodes to remove
      if (tree) {
        tree.each(node => {
          if (node.children && (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.isTuple)(node.data)) {
            out.rem.push(node.data);
          }
        });
      } // generate new tree structure


      this.value = tree = (0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_2__.default)({
        values: (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_.keys).reduce((n, k) => {
          n.key(k);
          return n;
        }, nest()).entries(out.source)
      }, children); // collect nodes to add

      if (gen) {
        tree.each(node => {
          if (node.children) {
            node = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(node.data);
            out.add.push(node);
            out.source.push(node);
          }
        });
      } // build lookup table


      lookup(tree, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid);
    }

    out.source.root = tree;
    return out;
  }

});

function nest() {
  const keys = [],
        nest = {
    entries: array => entries(apply(array, 0), 0),
    key: d => (keys.push(d), nest)
  };

  function apply(array, depth) {
    if (depth >= keys.length) {
      return array;
    }

    const n = array.length,
          key = keys[depth++],
          valuesByKey = {},
          result = {};
    let i = -1,
        keyValue,
        value,
        values;

    while (++i < n) {
      keyValue = key(value = array[i]) + '';

      if (values = valuesByKey[keyValue]) {
        values.push(value);
      } else {
        valuesByKey[keyValue] = [value];
      }
    }

    for (keyValue in valuesByKey) {
      result[keyValue] = apply(valuesByKey[keyValue], depth);
    }

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    const array = [];

    for (const key in map) {
      array.push({
        key,
        values: entries(map[key], depth)
      });
    }

    return array;
  }

  return nest;
}

/**
 * Abstract class for tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function HierarchyLayout(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}

const defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;

(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(HierarchyLayout, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source || !pulse.source.root) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)(this.constructor.name + ' transform requires a backing tree data source.');
    }

    const layout = this.layout(_.method),
          fields = this.fields,
          root = pulse.source.root,
          as = _.as || fields;
    if (_.field) root.sum(_.field);else root.count();
    if (_.sort) root.sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort, d => d.data));
    setParams(layout, this.params, _);

    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation : vega_util__WEBPACK_IMPORTED_MODULE_1__.one);
    }

    try {
      this.value = layout(root);
    } catch (err) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)(err);
    }

    root.each(node => setFields(node, fields, as));
    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');
  }

});

function setParams(layout, params, _) {
  for (let p, i = 0, n = params.length; i < n; ++i) {
    p = params[i];
    if (p in _) layout[p](_[p]);
  }
}

function setFields(node, fields, as) {
  const t = node.data,
        n = fields.length - 1;

  for (let i = 0; i < n; ++i) {
    t[as[i]] = node[fields[i]];
  }

  t[as[n]] = node.children ? node.children.length : 0;
}

const Output = ['x', 'y', 'r', 'depth', 'children'];
/**
 * Packed circle tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */

function Pack(params) {
  HierarchyLayout.call(this, params);
}
Pack.Definition = {
  'type': 'Pack',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'radius',
    'type': 'field',
    'default': null
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output.length,
    'default': Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Pack, HierarchyLayout, {
  layout: d3_hierarchy__WEBPACK_IMPORTED_MODULE_3__.default,
  params: ['radius', 'size', 'padding'],
  fields: Output
});

const Output$1 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];
/**
 * Partition tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */

function Partition(params) {
  HierarchyLayout.call(this, params);
}
Partition.Definition = {
  'type': 'Partition',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'round',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$1.length,
    'default': Output$1
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Partition, HierarchyLayout, {
  layout: d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__.default,
  params: ['size', 'round', 'padding'],
  fields: Output$1
});

/**
 * Stratify a collection of tuples into a tree structure based on
 * id and parent id fields.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.key - Unique key field for each tuple.
 * @param {function(object): *} params.parentKey - Field with key for parent tuple.
 */

function Stratify(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Stratify.Definition = {
  'type': 'Stratify',
  'metadata': {
    'treesource': true
  },
  'params': [{
    'name': 'key',
    'type': 'field',
    'required': true
  }, {
    'name': 'parentKey',
    'type': 'field',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Stratify, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Stratify transform requires an upstream data source.');
    }

    let tree = this.value;

    const mod = _.modified(),
          out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),
          run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution


    out.source = out.source.slice();

    if (run) {
      tree = out.source.length ? lookup((0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__.default)().id(_.key).parentId(_.parentKey)(out.source), _.key, vega_util__WEBPACK_IMPORTED_MODULE_1__.truthy) : lookup((0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__.default)()([{}]), _.key, _.key);
    }

    out.source.root = this.value = tree;
    return out;
  }

});

const Layouts = {
  tidy: d3_hierarchy__WEBPACK_IMPORTED_MODULE_6__.default,
  cluster: d3_hierarchy__WEBPACK_IMPORTED_MODULE_7__.default
};
const Output$2 = ['x', 'y', 'depth', 'children'];
/**
 * Tree layout. Depending on the method parameter, performs either
 * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Tree(params) {
  HierarchyLayout.call(this, params);
}
Tree.Definition = {
  'type': 'Tree',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'tidy',
    'values': ['tidy', 'cluster']
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'nodeSize',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'separation',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$2.length,
    'default': Output$2
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Tree, HierarchyLayout, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(method) {
    const m = method || 'tidy';
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(Layouts, m)) return Layouts[m]();else (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized Tree layout method: ' + m);
  },

  params: ['size', 'nodeSize'],
  fields: Output$2
});

/**
 * Generate tuples representing links between tree nodes.
 * The resulting tuples will contain 'source' and 'target' fields,
 * which point to parent and child node tuples, respectively.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function TreeLinks(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
}
TreeLinks.Definition = {
  'type': 'TreeLinks',
  'metadata': {
    'tree': true,
    'generates': true,
    'changes': true
  },
  'params': []
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(TreeLinks, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const links = this.value,
          tree = pulse.source && pulse.source.root,
          out = pulse.fork(pulse.NO_SOURCE),
          lut = {};
    if (!tree) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('TreeLinks transform requires a tree data source.');

    if (pulse.changed(pulse.ADD_REM)) {
      // remove previous links
      out.rem = links; // build lookup table of valid tuples

      pulse.visit(pulse.SOURCE, t => lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] = 1); // generate links for all edges incident on valid tuples

      tree.each(node => {
        const t = node.data,
              p = node.parent && node.parent.data;

        if (p && lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] && lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(p)]) {
          out.add.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
            source: p,
            target: t
          }));
        }
      });
      this.value = out.add;
    } else if (pulse.changed(pulse.MOD)) {
      // build lookup table of modified tuples
      pulse.visit(pulse.MOD, t => lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] = 1); // gather links incident on modified tuples

      links.forEach(link => {
        if (lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(link.source)] || lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(link.target)]) {
          out.mod.push(link);
        }
      });
    }

    return out;
  }

});

const Tiles = {
  binary: d3_hierarchy__WEBPACK_IMPORTED_MODULE_8__.default,
  dice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_9__.default,
  slice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_10__.default,
  slicedice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_11__.default,
  squarify: d3_hierarchy__WEBPACK_IMPORTED_MODULE_12__.default,
  resquarify: d3_hierarchy__WEBPACK_IMPORTED_MODULE_13__.default
};
const Output$3 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];
/**
 * Treemap layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */

function Treemap(params) {
  HierarchyLayout.call(this, params);
}
Treemap.Definition = {
  'type': 'Treemap',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'squarify',
    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingInner',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingOuter',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingTop',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingRight',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingBottom',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingLeft',
    'type': 'number',
    'default': 0
  }, {
    'name': 'ratio',
    'type': 'number',
    'default': 1.618033988749895
  }, {
    'name': 'round',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$3.length,
    'default': Output$3
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Treemap, HierarchyLayout, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const x = (0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_14__.default)();

    x.ratio = _ => {
      const t = x.tile();
      if (t.ratio) x.tile(t.ratio(_));
    };

    x.method = _ => {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(Tiles, _)) x.tile(Tiles[_]);else (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized Treemap layout method: ' + _);
    };

    return x;
  },

  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
  fields: Output$3
});




/***/ }),

/***/ "../../node_modules/vega-label/build/vega-label.module.js":
/*!****************************************************************!*\
  !*** ../../node_modules/vega-label/build/vega-label.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "label": () => (/* binding */ Label)
/* harmony export */ });
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-canvas */ "../../node_modules/vega-canvas/index.browser.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");





const ALPHA_MASK = 0xff000000; // alpha value equivalent to opacity 0.0625

const INSIDE_OPACITY_IN_ALPHA = 0x10000000;
const INSIDE_OPACITY = 0.0625;
function baseBitmaps($, data) {
  const bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided

  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));
  return [bitmap, undefined];
}
function markBitmaps($, avoidMarks, labelInside, isGroupArea) {
  // create canvas
  const width = $.width,
        height = $.height,
        border = labelInside || isGroupArea,
        context = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_0__.canvas)(width, height).getContext('2d'); // render all marks to be avoided into canvas

  avoidMarks.forEach(items => draw(context, items, border)); // get canvas buffer, create bitmaps

  const buffer = new Uint32Array(context.getImageData(0, 0, width, height).data.buffer),
        layer1 = $.bitmap(),
        layer2 = border && $.bitmap(); // populate bitmap layers

  let x, y, u, v, alpha;

  for (y = 0; y < height; ++y) {
    for (x = 0; x < width; ++x) {
      alpha = buffer[y * width + x] & ALPHA_MASK;

      if (alpha) {
        u = $(x);
        v = $(y);
        if (!isGroupArea) layer1.set(u, v); // update interior bitmap

        if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA) layer2.set(u, v); // update border bitmap
      }
    }
  }

  return [layer1, layer2];
}

function draw(context, items, interior) {
  if (!items.length) return;
  const type = items[0].mark.marktype;

  if (type === 'group') {
    items.forEach(group => {
      group.items.forEach(mark => draw(context, mark.items, interior));
    });
  } else {
    vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.Marks[type].draw(context, {
      items: interior ? items.map(prepare) : items
    });
  }
}
/**
 * Prepare item before drawing into canvas (setting stroke and opacity)
 * @param {object} source item to be prepared
 * @returns prepared item
 */


function prepare(source) {
  const item = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.rederive)(source, {});

  if (item.stroke) {
    item.strokeOpacity = 1;
  }

  if (item.fill) {
    item.fillOpacity = INSIDE_OPACITY;
    item.stroke = '#000';
    item.strokeOpacity = 1;
    item.strokeWidth = 2;
  }

  return item;
}

const DIV = 5,
      // bit shift from x, y index to bit vector array index
MOD = 31,
      // bit mask for index lookup within a bit vector
SIZE = 32,
      // individual bit vector size
RIGHT0 = new Uint32Array(SIZE + 1),
      // left-anchored bit vectors, full -> 0
RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full

RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];

for (let i = 1; i <= SIZE; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}

function Bitmap (w, h) {
  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));

  function _set(index, mask) {
    array[index] |= mask;
  }

  function _clear(index, mask) {
    array[index] &= mask;
  }

  return {
    array: array,
    get: (x, y) => {
      const index = y * w + x;
      return array[index >>> DIV] & 1 << (index & MOD);
    },
    set: (x, y) => {
      const index = y * w + x;

      _set(index >>> DIV, 1 << (index & MOD));
    },
    clear: (x, y) => {
      const index = y * w + x;

      _clear(index >>> DIV, ~(1 << (index & MOD)));
    },
    getRange: (x, y, x2, y2) => {
      let r = y2,
          start,
          end,
          indexStart,
          indexEnd;

      for (; r >= y; --r) {
        start = r * w + x;
        end = r * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;

        if (indexStart === indexEnd) {
          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {
            return true;
          }
        } else {
          if (array[indexStart] & RIGHT0[start & MOD]) return true;
          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;

          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array[i]) return true;
          }
        }
      }

      return false;
    },
    setRange: (x, y, x2, y2) => {
      let start, end, indexStart, indexEnd, i;

      for (; y <= y2; ++y) {
        start = y * w + x;
        end = y * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;

        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD]);

          _set(indexEnd, RIGHT1[(end & MOD) + 1]);

          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);
        }
      }
    },
    clearRange: (x, y, x2, y2) => {
      let start, end, indexStart, indexEnd, i;

      for (; y <= y2; ++y) {
        start = y * w + x;
        end = y * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;

        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD]);

          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);

          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);
        }
      }
    },
    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w
  };
}

function scaler (width, height, padding) {
  const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),
        w = ~~((width + 2 * padding + ratio) / ratio),
        h = ~~((height + 2 * padding + ratio) / ratio),
        scale = _ => ~~((_ + padding) / ratio);

  scale.invert = _ => _ * ratio - padding;

  scale.bitmap = () => Bitmap(w, h);

  scale.ratio = ratio;
  scale.padding = padding;
  scale.width = width;
  scale.height = height;
  return scale;
}

function placeAreaLabelNaive ($, bitmaps, avoidBaseMark, markIndex) {
  const width = $.width,
        height = $.height; // try to place a label within an input area mark

  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
          // area points
    n = items.length,
          // number of points
    textHeight = d.datum.fontSize,
          // label width
    textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text); // label height

    let maxAreaWidth = 0,
        x1,
        x2,
        y1,
        y2,
        x,
        y,
        areaWidth; // for each area sample point

    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2;
      x = (x1 + x2) / 2;
      y = (y1 + y2) / 2;
      areaWidth = Math.abs(x2 - x1 + y2 - y1);

      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x;
        d.y = y;
      }
    }

    x = textWidth / 2;
    y = textHeight / 2;
    x1 = d.x - x;
    x2 = d.x + x;
    y1 = d.y - y;
    y2 = d.y + y;
    d.align = 'center';

    if (x1 < 0 && x2 <= width) {
      d.align = 'left';
    } else if (0 <= x1 && width < x2) {
      d.align = 'right';
    }

    d.baseline = 'middle';

    if (y1 < 0 && y2 <= height) {
      d.baseline = 'top';
    } else if (0 <= y1 && height < y2) {
      d.baseline = 'bottom';
    }

    return true;
  };
}

function outOfBounds(x, y, textWidth, textHeight, width, height) {
  let r = textWidth / 2;
  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;
}

function _outOfBounds() {
  return false;
}

function collision($, x, y, textHeight, textWidth, h, bm0, bm1) {
  const w = textWidth * h / (textHeight * 2),
        x1 = $(x - w),
        x2 = $(x + w),
        y1 = $(y - (h = h / 2)),
        y2 = $(y + h);
  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);
}

function _collision($, x, y, textHeight, textWidth, h, bm0, bm1) {
  const w = textWidth * h / (textHeight * 2);
  let x1 = $(x - w),
      x2 = $(x + w),
      y1 = $(y - (h = h / 2)),
      y2 = $(y + h);
  x1 = x1 > 0 ? x1 : 0;
  y1 = y1 > 0 ? y1 : 0;
  x2 = x2 < $.width ? x2 : $.width - 1;
  y2 = y2 < $.height ? y2 : $.height - 1;
  return bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);
}

function getTests(infPadding) {
  return infPadding ? [_collision, _outOfBounds] : [collision, outOfBounds];
}

function placeAreaLabelReducedSearch ($, bitmaps, avoidBaseMark, markIndex, infPadding) {
  const width = $.width,
        height = $.height,
        [collision, outOfBounds] = getTests(infPadding),
        bm0 = bitmaps[0],
        // where labels have been placed
  bm1 = bitmaps[1]; // area outlines

  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {
    const x = $.invert(_x),
          y = $.invert(_y);
    let lo = maxSize,
        hi = height,
        mid;

    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
      // if the label fits at the current sample point,
      // perform binary search to find the largest font size that fits
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;

        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      } // place label if current lower bound exceeds prior max font size


      if (lo > maxSize) {
        return [x, y, lo, true];
      }
    }
  } // try to place a label within an input area mark


  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
          // area points
    n = items.length,
          // number of points
    textHeight = d.datum.fontSize,
          // label width
    textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text); // label height

    let maxSize = avoidBaseMark ? textHeight : 0,
        labelPlaced = false,
        labelPlaced2 = false,
        maxAreaWidth = 0,
        x1,
        x2,
        y1,
        y2,
        x,
        y,
        _x,
        _y,
        _x1,
        _xMid,
        _x2,
        _y1,
        _yMid,
        _y2,
        areaWidth,
        result,
        swapTmp; // for each area sample point


    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2;

      if (x1 > x2) {
        swapTmp = x1;
        x1 = x2;
        x2 = swapTmp;
      }

      if (y1 > y2) {
        swapTmp = y1;
        y1 = y2;
        y2 = swapTmp;
      }

      _x1 = $(x1);
      _x2 = $(x2);
      _xMid = ~~((_x1 + _x2) / 2);
      _y1 = $(y1);
      _y2 = $(y2);
      _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border

      for (_x = _xMid; _x >= _x1; --_x) {
        for (_y = _yMid; _y >= _y1; --_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);

          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      } // search along the line from mid point between the 2 border to upper border


      for (_x = _xMid; _x <= _x2; ++_x) {
        for (_y = _yMid; _y <= _y2; ++_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);

          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      } // place label at slice center if not placed through other means
      // and if we're not avoiding overlap with other areas


      if (!labelPlaced && !avoidBaseMark) {
        // one span is zero, hence we can add
        areaWidth = Math.abs(x2 - x1 + y2 - y1);
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2; // place label if it fits and improves the max area width

        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x;
          d.y = y;
          labelPlaced2 = true;
        }
      }
    } // record current label placement information, update label bitmap


    if (labelPlaced || labelPlaced2) {
      x = textWidth / 2;
      y = textHeight / 2;
      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));
      d.align = 'center';
      d.baseline = 'middle';
      return true;
    } else {
      return false;
    }
  };
}

const X_DIR = [-1, -1, 1, 1];
const Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill ($, bitmaps, avoidBaseMark, markIndex, infPadding) {
  const width = $.width,
        height = $.height,
        [collision, outOfBounds] = getTests(infPadding),
        bm0 = bitmaps[0],
        // where labels have been placed
  bm1 = bitmaps[1],
        // area outlines
  bm2 = $.bitmap(); // flood-fill visitations
  // try to place a label within an input area mark

  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
          // area points
    n = items.length,
          // number of points
    textHeight = d.datum.fontSize,
          // label width
    textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text),
          // label height
    stack = []; // flood fill stack

    let maxSize = avoidBaseMark ? textHeight : 0,
        labelPlaced = false,
        labelPlaced2 = false,
        maxAreaWidth = 0,
        x1,
        x2,
        y1,
        y2,
        x,
        y,
        _x,
        _y,
        lo,
        hi,
        mid,
        areaWidth; // for each area sample point


    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2; // add scaled center point to stack

      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points

      while (stack.length) {
        [_x, _y] = stack.pop(); // exit if point already marked

        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap
        // add search points for all (in bound) directions

        bm2.set(_x, _y);

        for (let j = 0; j < 4; ++j) {
          x = _x + X_DIR[j];
          y = _y + Y_DIR[j];
          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);
        } // unscale point back to x, y space


        x = $.invert(_x);
        y = $.invert(_y);
        lo = maxSize;
        hi = height; // TODO: make this bound smaller

        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          // if the label fits at the current sample point,
          // perform binary search to find the largest font size that fits
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;

            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          } // place label if current lower bound exceeds prior max font size


          if (lo > maxSize) {
            d.x = x;
            d.y = y;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      } // place label at slice center if not placed through other means
      // and if we're not avoiding overlap with other areas


      if (!labelPlaced && !avoidBaseMark) {
        // one span is zero, hence we can add
        areaWidth = Math.abs(x2 - x1 + y2 - y1);
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2; // place label if it fits and improves the max area width

        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x;
          d.y = y;
          labelPlaced2 = true;
        }
      }
    } // record current label placement information, update label bitmap


    if (labelPlaced || labelPlaced2) {
      x = textWidth / 2;
      y = textHeight / 2;
      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));
      d.align = 'center';
      d.baseline = 'middle';
      return true;
    } else {
      return false;
    }
  };
}

const Aligns = ['right', 'center', 'left'],
      Baselines = ['bottom', 'middle', 'top'];
function placeMarkLabel ($, bitmaps, anchors, offsets, infPadding) {
  const width = $.width,
        height = $.height,
        bm0 = bitmaps[0],
        bm1 = bitmaps[1],
        n = offsets.length;
  return function (d) {
    const boundary = d.boundary,
          textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound

    if (!infPadding && (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height)) {
      return false;
    }

    let textWidth = 0,
        dx,
        dy,
        isInside,
        sizeFactor,
        insideFactor,
        x1,
        x2,
        y1,
        y2,
        xc,
        yc,
        _x1,
        _x2,
        _y1,
        _y2; // for each anchor and offset


    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 0x3) - 1;
      dy = (anchors[i] >>> 0x2 & 0x3) - 1;
      isInside = dx === 0 && dy === 0 || offsets[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets[i] < 0 ? -1 : 1;
      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;
      y1 = yc - textHeight / 2;
      y2 = yc + textHeight / 2;
      _x1 = $(x1);
      _y1 = $(y1);
      _y2 = $(y2);

      if (infPadding) {
        _x1 = _x1 < 0 ? 0 : _x1;
        _y1 = _y1 < 0 ? 0 : _y1;
        _y2 = _y2 >= $.height ? $.height - 1 : _y2;
      }

      if (!textWidth) {
        // to avoid finding width of text label,
        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {
          // skip this anchor/offset option if we fail to place a label with 1px width
          continue;
        } else {
          // Otherwise, find the label width
          textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text);
        }
      }

      xc = x1 + insideFactor * textWidth * dx / 2;
      x1 = xc - textWidth / 2;
      x2 = xc + textWidth / 2;
      _x1 = $(x1);
      _x2 = $(x2);

      if (infPadding) {
        _x1 = _x1 < 0 ? 0 : _x1;
        _x2 = _x2 >= $.width ? $.width - 1 : _x2;
      }

      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {
        // place label if the position is placeable
        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x2, _y2);
        return true;
      }
    }

    return false;
  };
} // Test if a label with the given dimensions can be added without overlap

function test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x1, y1, x2, y2, boundary) : bm0.getRange(_x1, _y1, _x2, _y2)));
}

function isInMarkBound(x1, y1, x2, y2, boundary) {
  return boundary[0] <= x1 && x2 <= boundary[2] && boundary[3] <= y1 && y2 <= boundary[5];
}

const TOP = 0x0,
      MIDDLE = 0x4,
      BOTTOM = 0x8,
      LEFT = 0x0,
      CENTER = 0x1,
      RIGHT = 0x2; // Mapping from text anchor to number representation

const anchorCode = {
  'top-left': TOP + LEFT,
  'top': TOP + CENTER,
  'top-right': TOP + RIGHT,
  'left': MIDDLE + LEFT,
  'middle': MIDDLE + CENTER,
  'right': MIDDLE + RIGHT,
  'bottom-left': BOTTOM + LEFT,
  'bottom': BOTTOM + CENTER,
  'bottom-right': BOTTOM + RIGHT
};
const placeAreaLabel = {
  'naive': placeAreaLabelNaive,
  'reduced-search': placeAreaLabelReducedSearch,
  'floodfill': placeAreaLabelFloodFill
};
function labelLayout (texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {
  // early exit for empty data
  if (!texts.length) return texts;
  const positions = Math.max(offset.length, anchor.length),
        offsets = getOffsets(offset, positions),
        anchors = getAnchors(anchor, positions),
        marktype = markType(texts[0].datum),
        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,
        isGroupArea = grouptype === 'area',
        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),
        infPadding = padding === null || padding === Infinity,
        $ = scaler(size[0], size[1], infPadding ? 0 : padding),
        isNaiveGroupArea = isGroupArea && method === 'naive'; // prepare text mark data for placing

  const data = texts.map(d => ({
    datum: d,
    opacity: 0,
    x: undefined,
    y: undefined,
    align: undefined,
    baseline: undefined,
    boundary: boundary(d)
  }));
  let bitmaps;

  if (!isNaiveGroupArea) {
    // sort labels in priority order, if comparator is provided
    if (compare) {
      data.sort((a, b) => compare(a.datum, b.datum));
    } // flag indicating if label can be placed inside its base mark


    let labelInside = false;

    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      // label inside if anchor is at center
      // label inside if offset to be inside the mark bound
      labelInside = anchors[i] === 0x5 || offsets[i] < 0;
    } // extract data information from base mark when base mark is to be avoided
    // base mark is implicitly avoided if it is a group area


    if (marktype && (avoidBaseMark || isGroupArea)) {
      avoidMarks = [texts.map(d => d.datum)].concat(avoidMarks);
    } // generate bitmaps for layout calculation


    bitmaps = avoidMarks.length ? markBitmaps($, avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);
  } // generate label placement function


  const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex, infPadding) : placeMarkLabel($, bitmaps, anchors, offsets, infPadding); // place all labels

  data.forEach(d => d.opacity = +place(d));
  return data;
}

function getOffsets(_, count) {
  const offsets = new Float64Array(count),
        n = _.length;

  for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;

  for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];

  return offsets;
}

function getAnchors(_, count) {
  const anchors = new Int8Array(count),
        n = _.length;

  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];

  for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];

  return anchors;
}

function markType(item) {
  return item && item.mark && item.mark.marktype;
}
/**
 * Factory function for function for getting base mark boundary, depending
 * on mark and group type. When mark type is undefined, line or area: boundary
 * is the coordinate of each data point. When base mark is grouped line,
 * boundary is either at the beginning or end of the line depending on the
 * value of lineAnchor. Otherwise, use bounds of base mark.
 */


function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];

  if (!marktype) {
    return xy; // no reactive geometry
  } else if (marktype === 'line' || marktype === 'area') {
    return d => xy(d.datum);
  } else if (grouptype === 'line') {
    return d => {
      const items = d.datum.items[markIndex].items;
      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return d => {
      const b = d.datum.bounds;
      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];
    };
  }
}

const Output = ['x', 'y', 'opacity', 'align', 'baseline'];
const Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];
/**
 * Compute text label layout to annotate marks.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for sorting label data in priority order.
 * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.
 *   The available options are 'top-left', 'left', 'bottom-left', 'top',
 *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.
 * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.
 *   This parameter is parallel to the list of anchor points.
 * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.
 *   If this parameter is null, a label may exceed the layout size without any boundary.
 * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor
 *   position for labels. One of 'start' or 'end'.
 * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating
 *   which mark within the group should be labeled.
 * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label
 *   layout should avoid overlap.
 * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid
 *   overlap with the underlying base mark being labeled.
 * @param {string} [params.method='naive'] - For area make labels only, a method for
 *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.
 * @param {Array<string>} [params.as] - The output fields written by the transform.
 *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].
 */

function Label(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Label.Definition = {
  type: 'Label',
  metadata: {
    modifies: true
  },
  params: [{
    name: 'size',
    type: 'number',
    array: true,
    length: 2,
    required: true
  }, {
    name: 'sort',
    type: 'compare'
  }, {
    name: 'anchor',
    type: 'string',
    array: true,
    default: Anchors
  }, {
    name: 'offset',
    type: 'number',
    array: true,
    default: [1]
  }, {
    name: 'padding',
    type: 'number',
    default: 0,
    null: true
  }, {
    name: 'lineAnchor',
    type: 'string',
    values: ['start', 'end'],
    default: 'end'
  }, {
    name: 'markIndex',
    type: 'number',
    default: 0
  }, {
    name: 'avoidBaseMark',
    type: 'boolean',
    default: true
  }, {
    name: 'avoidMarks',
    type: 'data',
    array: true
  }, {
    name: 'method',
    type: 'string',
    default: 'naive'
  }, {
    name: 'as',
    type: 'string',
    array: true,
    length: Output.length,
    default: Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_3__.inherits)(Label, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    function modp(param) {
      const p = _[param];
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.isFunction)(p) && pulse.modified(p.fields);
    }

    const mod = _.modified();

    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;

    if (!_.size || _.size.length !== 2) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.error)('Size parameter should be specified as a [width, height] array.');
    }

    const as = _.as || Output; // run label layout

    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.array)(_.offset == null ? 1 : _.offset), (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.array)(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(l => {
      // write layout results to data stream
      const t = l.datum;
      t[as[0]] = l.x;
      t[as[1]] = l.y;
      t[as[2]] = l.opacity;
      t[as[3]] = l.align;
      t[as[4]] = l.baseline;
    });
    return pulse.reflow(mod).modifies(as);
  }

});




/***/ }),

/***/ "../../node_modules/vega-loader/build/vega-loader.browser.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-loader/build/vega-loader.browser.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "formats": () => (/* binding */ formats),
/* harmony export */   "inferType": () => (/* binding */ inferType),
/* harmony export */   "inferTypes": () => (/* binding */ inferTypes),
/* harmony export */   "loader": () => (/* binding */ loader),
/* harmony export */   "read": () => (/* binding */ read),
/* harmony export */   "responseType": () => (/* binding */ responseType),
/* harmony export */   "typeParsers": () => (/* binding */ typeParsers)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "../../node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! topojson-client */ "../../node_modules/topojson-client/src/index.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-format */ "../../node_modules/vega-format/build/vega-format.module.js");





//   https://...    file://...    //...

const protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/; // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://

const allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i; // eslint-disable-line no-useless-escape

const whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; // eslint-disable-line no-control-regex
// Special treatment in node.js for the file: protocol

const fileProtocol = 'file://';
/**
 * Factory for a loader constructor that provides methods for requesting
 * files from either the network or disk, and for sanitizing request URIs.
 * @param {function} fetch - The Fetch API for HTTP network requests.
 *   If null or undefined, HTTP loading will be disabled.
 * @param {object} fs - The file system interface for file loading.
 *   If null or undefined, local file loading will be disabled.
 * @return {function} A loader constructor with the following signature:
 *   param {object} [options] - Optional default loading options to use.
 *   return {object} - A new loader instance.
 */

function loaderFactory (fetch, fs) {
  return options => ({
    options: options || {},
    sanitize: sanitize,
    load: load,
    fileAccess: !!fs,
    file: fileLoader(fs),
    http: httpLoader(fetch)
  });
}
/**
 * Load an external resource, typically either from the web or from the local
 * filesystem. This function uses {@link sanitize} to first sanitize the uri,
 * then calls either {@link http} (for web requests) or {@link file} (for
 * filesystem loading).
 * @param {string} uri - The resource indicator (e.g., URL or filename).
 * @param {object} [options] - Optional loading options. These options will
 *   override any existing default options.
 * @return {Promise} - A promise that resolves to the loaded content.
 */

async function load(uri, options) {
  const opt = await this.sanitize(uri, options),
        url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options);
}
/**
 * URI sanitizer function.
 * @param {string} uri - The uri (url or filename) to check.
 * @param {object} options - An options hash.
 * @return {Promise} - A promise that resolves to an object containing
 *  sanitized uri data, or rejects it the input uri is deemed invalid.
 *  The properties of the resolved object are assumed to be
 *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be
 *  provided by the 'href' property of the returned object.
 */


async function sanitize(uri, options) {
  options = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.options, options);
  const fileAccess = this.fileAccess,
        result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));

  if (uri == null || typeof uri !== 'string' || !isAllowed) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Sanitize failure, invalid URI: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(uri));
  }

  const hasProtocol = protocol_re.test(uri); // if relative url (no protocol/host), prepend baseURL

  if ((base = options.baseURL) && !hasProtocol) {
    // Ensure that there is a slash between the baseURL (e.g. hostname) and url
    if (!uri.startsWith('/') && !base.endsWith('/')) {
      uri = '/' + uri;
    }

    uri = base + uri;
  } // should we load from file system?


  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;

  if (isFile) {
    // strip file protocol
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith('//')) {
    if (options.defaultProtocol === 'file') {
      // if is file, strip protocol and set loadFile flag
      uri = uri.slice(2);
      loadFile = true;
    } else {
      // if relative protocol (starts with '//'), prepend default protocol
      uri = (options.defaultProtocol || 'http') + ':' + uri;
    }
  } // set non-enumerable mode flag to indicate local file load


  Object.defineProperty(result, 'localFile', {
    value: !!loadFile
  }); // set uri

  result.href = uri; // set default result target, if specified

  if (options.target) {
    result.target = options.target + '';
  } // set default result rel, if specified (#1542)


  if (options.rel) {
    result.rel = options.rel + '';
  } // provide control over cross-origin image handling (#2238)
  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image


  if (options.context === 'image' && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + '';
  } // return


  return result;
}
/**
 * File system loader factory.
 * @param {object} fs - The file system interface.
 * @return {function} - A file loader with the following signature:
 *   param {string} filename - The file system path to load.
 *   param {string} filename - The file system path to load.
 *   return {Promise} A promise that resolves to the file contents.
 */


function fileLoader(fs) {
  return fs ? filename => new Promise((accept, reject) => {
    fs.readFile(filename, (error, data) => {
      if (error) reject(error);else accept(data);
    });
  }) : fileReject;
}
/**
 * Default file system loader that simply rejects.
 */


async function fileReject() {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No file system access.');
}
/**
 * HTTP request handler factory.
 * @param {function} fetch - The Fetch API method.
 * @return {function} - An http loader with the following signature:
 *   param {string} url - The url to request.
 *   param {object} options - An options hash.
 *   return {Promise} - A promise that resolves to the file contents.
 */


function httpLoader(fetch) {
  return fetch ? async function (url, options) {
    const opt = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.options.http, options),
          type = options && options.response,
          response = await fetch(url, opt);
    return !response.ok ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(response.status + '' + response.statusText) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(response[type]) ? response[type]() : response.text();
  } : httpReject;
}
/**
 * Default http request handler that simply rejects.
 */


async function httpReject() {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No HTTP fetch method available.');
}

const isValid = _ => _ != null && _ === _;

const isBoolean = _ => _ === 'true' || _ === 'false' || _ === true || _ === false;

const isDate = _ => !Number.isNaN(Date.parse(_));

const isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);

const isInteger = _ => isNumber(_) && Number.isInteger(+_);

const typeParsers = {
  boolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean,
  integer: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  number: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  date: vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate,
  string: vega_util__WEBPACK_IMPORTED_MODULE_0__.toString,
  unknown: vega_util__WEBPACK_IMPORTED_MODULE_0__.identity
};
const typeTests = [isBoolean, isInteger, isNumber, isDate];
const typeList = ['boolean', 'integer', 'number', 'date'];
function inferType(values, field) {
  if (!values || !values.length) return 'unknown';
  const n = values.length,
        m = typeTests.length,
        a = typeTests.map((_, i) => i + 1);

  for (let i = 0, t = 0, j, value; i < n; ++i) {
    value = field ? values[i][field] : values[i];

    for (j = 0; j < m; ++j) {
      if (a[j] && isValid(value) && !typeTests[j](value)) {
        a[j] = 0;
        ++t;
        if (t === typeTests.length) return 'string';
      }
    }
  }

  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes(data, fields) {
  return fields.reduce((types, field) => {
    types[field] = inferType(data, field);
    return types;
  }, {});
}

function delimitedFormat(delimiter) {
  const parse = function (data, format) {
    const delim = {
      delimiter: delimiter
    };
    return dsv(data, format ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(format, delim) : delim);
  };

  parse.responseType = 'text';
  return parse;
}
function dsv(data, format) {
  if (format.header) {
    data = format.header.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join(format.delimiter) + '\n' + data;
  }

  return (0,d3_dsv__WEBPACK_IMPORTED_MODULE_3__.default)(format.delimiter).parse(data + '');
}
dsv.responseType = 'text';

function isBuffer(_) {
  return typeof Buffer === 'function' && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}

function json(data, format) {
  const prop = format && format.property ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(format.property) : vega_util__WEBPACK_IMPORTED_MODULE_0__.identity;
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(data) && !isBuffer(data) ? parseJSON(prop(data), format) : prop(JSON.parse(data));
}
json.responseType = 'json';

function parseJSON(data, format) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isIterable)(data)) {
    data = [...data];
  }

  return format && format.copy ? JSON.parse(JSON.stringify(data)) : data;
}

const filters = {
  interior: (a, b) => a !== b,
  exterior: (a, b) => a === b
};
function topojson(data, format) {
  let method, object, property, filter;
  data = json(data, format);

  if (format && format.feature) {
    method = topojson_client__WEBPACK_IMPORTED_MODULE_1__.feature;
    property = format.feature;
  } else if (format && format.mesh) {
    method = topojson_client__WEBPACK_IMPORTED_MODULE_1__.mesh;
    property = format.mesh;
    filter = filters[format.filter];
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing TopoJSON feature or mesh parameter.');
  }

  object = (object = data.objects[property]) ? method(data, object, filter) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid TopoJSON object: ' + property);
  return object && object.features || [object];
}
topojson.responseType = 'json';

const format = {
  dsv: dsv,
  csv: delimitedFormat(','),
  tsv: delimitedFormat('\t'),
  json: json,
  topojson: topojson
};
function formats(name, reader) {
  if (arguments.length > 1) {
    format[name] = reader;
    return this;
  } else {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(format, name) ? format[name] : null;
  }
}
function responseType(type) {
  const f = formats(type);
  return f && f.responseType || 'text';
}

function read (data, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || 'json');
  if (!reader) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unknown data format type: ' + schema.type);
  data = reader(data, schema);
  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(data, 'columns')) delete data.columns;
  return data;
}

function parse(data, types, timeParser, utcParser) {
  if (!data.length) return; // early exit for empty data

  const locale = (0,vega_format__WEBPACK_IMPORTED_MODULE_2__.timeFormatDefaultLocale)();
  timeParser = timeParser || locale.timeParse;
  utcParser = utcParser || locale.utcParse;
  let fields = data.columns || Object.keys(data[0]),
      datum,
      field,
      i,
      j,
      n,
      m;
  if (types === 'auto') types = inferTypes(data, fields);
  fields = Object.keys(types);
  const parsers = fields.map(field => {
    const type = types[field];
    let parts, pattern;

    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {
      parts = type.split(/:(.+)?/, 2); // split on first :

      pattern = parts[1];

      if (pattern[0] === '\'' && pattern[pattern.length - 1] === '\'' || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }

      const parse = parts[0] === 'utc' ? utcParser : timeParser;
      return parse(pattern);
    }

    if (!typeParsers[type]) {
      throw Error('Illegal format pattern: ' + field + ':' + type);
    }

    return typeParsers[type];
  });

  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {
    datum = data[i];

    for (j = 0; j < m; ++j) {
      field = fields[j];
      datum[field] = parsers[j](datum[field]);
    }
  }
}

const loader = loaderFactory(typeof fetch !== 'undefined' && fetch, // use built-in fetch API
null // no file system access
);




/***/ }),

/***/ "../../node_modules/vega-parser/build/vega-parser.module.js":
/*!******************************************************************!*\
  !*** ../../node_modules/vega-parser/build/vega-parser.module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AxisDomainRole": () => (/* binding */ AxisDomainRole),
/* harmony export */   "AxisGridRole": () => (/* binding */ AxisGridRole),
/* harmony export */   "AxisLabelRole": () => (/* binding */ AxisLabelRole),
/* harmony export */   "AxisRole": () => (/* binding */ AxisRole),
/* harmony export */   "AxisTickRole": () => (/* binding */ AxisTickRole),
/* harmony export */   "AxisTitleRole": () => (/* binding */ AxisTitleRole),
/* harmony export */   "DataScope": () => (/* binding */ DataScope),
/* harmony export */   "FrameRole": () => (/* binding */ FrameRole),
/* harmony export */   "LegendEntryRole": () => (/* binding */ LegendEntryRole),
/* harmony export */   "LegendLabelRole": () => (/* binding */ LegendLabelRole),
/* harmony export */   "LegendRole": () => (/* binding */ LegendRole),
/* harmony export */   "LegendSymbolRole": () => (/* binding */ LegendSymbolRole),
/* harmony export */   "LegendTitleRole": () => (/* binding */ LegendTitleRole),
/* harmony export */   "MarkRole": () => (/* binding */ MarkRole),
/* harmony export */   "Scope": () => (/* binding */ Scope),
/* harmony export */   "ScopeRole": () => (/* binding */ ScopeRole),
/* harmony export */   "config": () => (/* binding */ defaults),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "signal": () => (/* binding */ parseSignal),
/* harmony export */   "signalUpdates": () => (/* binding */ parseSignalUpdates),
/* harmony export */   "stream": () => (/* binding */ parseStream)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-functions */ "../../node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_event_selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-event-selector */ "../../node_modules/vega-event-selector/build/vega-event-selector.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");






function parseAutosize (spec) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? spec : {
    type: spec || 'pad'
  };
}

const number = _ => +_ || 0;

const paddingObject = _ => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});

function parsePadding (spec) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {
    top: number(spec.top),
    bottom: number(spec.bottom),
    left: number(spec.left),
    right: number(spec.right)
  };
}

const encoder = _ => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _) : {
  value: _
};
function addEncode(object, name, value, set) {
  if (value != null) {
    const isEncoder = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) && value.length && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value[0]); // Always assign signal to update, even if the signal is from the enter block

    if (isEncoder) {
      object.update[name] = value;
    } else {
      object[set || 'enter'][name] = {
        value: value
      };
    }

    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object, enter, update) {
  for (const name in enter) {
    addEncode(object, name, enter[name]);
  }

  for (const name in update) {
    addEncode(object, name, update[name], 'update');
  }
}
function extendEncode(encode, extra, skip) {
  for (const name in extra) {
    if (skip && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(skip, name)) continue;
    encode[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(encode[name] || {}, extra[name]);
  }

  return encode;
}
function has(key, encode) {
  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);
}

const MarkRole = 'mark';
const FrameRole = 'frame';
const ScopeRole = 'scope';
const AxisRole = 'axis';
const AxisDomainRole = 'axis-domain';
const AxisGridRole = 'axis-grid';
const AxisLabelRole = 'axis-label';
const AxisTickRole = 'axis-tick';
const AxisTitleRole = 'axis-title';
const LegendRole = 'legend';
const LegendBandRole = 'legend-band';
const LegendEntryRole = 'legend-entry';
const LegendGradientRole = 'legend-gradient';
const LegendLabelRole = 'legend-label';
const LegendSymbolRole = 'legend-symbol';
const LegendTitleRole = 'legend-title';
const TitleRole = 'title';
const TitleTextRole = 'title-text';
const TitleSubtitleRole = 'title-subtitle';

function applyDefaults (encode, type, role, style, config) {
  const defaults = {},
        enter = {};
  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)

  key = 'lineBreak';

  if (type === 'text' && config[key] != null && !has(key, encode)) {
    applyDefault(defaults, key, config[key]);
  } // ignore legend and axis roles


  if (role == 'legend' || String(role).startsWith('axis')) {
    role = null;
  } // resolve mark config


  props = role === FrameRole ? config.group : role === MarkRole ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, config.mark, config[type]) : null;

  for (key in props) {
    // do not apply defaults if relevant fields are defined
    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));
    if (!skip) applyDefault(defaults, key, props[key]);
  } // resolve styles, apply with increasing precedence


  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(style).forEach(name => {
    const props = config.style && config.style[name];

    for (const key in props) {
      if (!has(key, encode)) {
        applyDefault(defaults, key, props[key]);
      }
    }
  });
  encode = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, encode); // defensive copy

  for (key in defaults) {
    props = defaults[key];

    if (props.signal) {
      (update = update || {})[key] = props;
    } else {
      enter[key] = props;
    }
  }

  encode.enter = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(enter, encode.enter);
  if (update) encode.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(update, encode.update);
  return encode;
}

function applyDefault(defaults, key, value) {
  defaults[key] = value && value.signal ? {
    signal: value.signal
  } : {
    value: value
  };
}

const scaleRef = scale => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(scale) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(scale) : scale.signal ? `(${scale.signal})` : field(scale);

function entry$1(enc) {
  if (enc.gradient != null) {
    return gradient(enc);
  }

  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(enc.value) : undefined;

  if (enc.scale != null) {
    value = scale(enc, value);
  }

  if (value === undefined) {
    value = null;
  }

  if (enc.exponent != null) {
    value = `pow(${value},${property(enc.exponent)})`;
  }

  if (enc.mult != null) {
    value += `*${property(enc.mult)}`;
  }

  if (enc.offset != null) {
    value += `+${property(enc.offset)}`;
  }

  if (enc.round) {
    value = `round(${value})`;
  }

  return value;
}

const _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;

function color(enc) {
  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;
}

function gradient(enc) {
  // map undefined to null; expression lang does not allow undefined
  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(_)); // trim null inputs from the end

  while (args.length && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(args) == null) args.pop();

  args.unshift(scaleRef(enc.gradient));
  return `gradient(${args.join(',')})`;
}

function property(property) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(property) ? '(' + entry$1(property) + ')' : property;
}

function field(ref) {
  return resolveField((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(ref) ? ref : {
    datum: ref
  });
}

function resolveField(ref) {
  let object, level, field;

  if (ref.signal) {
    object = 'datum';
    field = ref.signal;
  } else if (ref.group || ref.parent) {
    level = Math.max(1, ref.level || 1);
    object = 'item';

    while (level-- > 0) {
      object += '.mark.group';
    }

    if (ref.parent) {
      field = ref.parent;
      object += '.datum';
    } else {
      field = ref.group;
    }
  } else if (ref.datum) {
    object = 'datum';
    field = ref.datum;
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid field reference: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ref));
  }

  if (!ref.signal) {
    field = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.splitAccessPath)(field).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join('][') : resolveField(field);
  }

  return object + '[' + field + ']';
}

function scale(enc, value) {
  const scale = scaleRef(enc.scale);

  if (enc.range != null) {
    // pull value from scale range
    value = `lerp(_range(${scale}), ${+enc.range})`;
  } else {
    // run value through scale and/or pull scale bandwidth
    if (value !== undefined) value = `_scale(${scale}, ${value})`;

    if (enc.band) {
      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));

      if (enc.extra) {
        // include logic to handle extraneous elements
        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;
      }
    }

    if (value == null) value = '0';
  }

  return value;
}

function rule (enc) {
  let code = '';
  enc.forEach(rule => {
    const value = entry$1(rule);
    code += rule.test ? `(${rule.test})?${value}:` : value;
  }); // if no else clause, terminate with null (#1366)

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(code) === ':') {
    code += 'null';
  }

  return code;
}

function parseEncode (encode, type, role, style, scope, params) {
  const enc = {};
  params = params || {};
  params.encoders = {
    $encode: enc
  };
  encode = applyDefaults(encode, type, role, style, scope.config);

  for (const key in encode) {
    enc[key] = parseBlock(encode[key], type, params, scope);
  }

  return params;
}

function parseBlock(block, marktype, params, scope) {
  const channels = {},
        fields = {};

  for (const name in block) {
    if (block[name] != null) {
      // skip any null entries
      channels[name] = parse$1(expr(block[name]), scope, params, fields);
    }
  }

  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}

function expr(enc) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(enc) ? rule(enc) : entry$1(enc);
}

function parse$1(code, scope, params, fields) {
  const expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(code, scope);
  expr.$fields.forEach(name => fields[name] = 1);
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(params, expr.$params);
  return expr.$expr;
}

const OUTER = 'outer',
      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];

function outerError(prefix, name) {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(prefix + ' for "outer" push: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
}

function parseSignal (signal, scope) {
  const name = signal.name;

  if (signal.push === OUTER) {
    // signal must already be defined, raise error if not
    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition

    OUTER_INVALID.forEach(prop => {
      if (signal[prop] !== undefined) outerError('Invalid property ', prop);
    });
  } else {
    // define a new signal in the current scope
    const op = scope.addSignal(name, signal.value);
    if (signal.react === false) op.react = false;
    if (signal.bind) scope.addBinding(name, signal.bind);
  }
}

function Entry(type, value, params, parent) {
  this.id = -1;
  this.type = type;
  this.value = value;
  this.params = params;
  if (parent) this.parent = parent;
}
function entry(type, value, params, parent) {
  return new Entry(type, value, params, parent);
}
function operator(value, params) {
  return entry('operator', value, params);
} // -----

function ref(op) {
  const ref = {
    $ref: op.id
  }; // if operator not yet registered, cache ref to resolve later

  if (op.id < 0) (op.refs = op.refs || []).push(ref);
  return ref;
}
function fieldRef$1(field, name) {
  return name ? {
    $field: field,
    $name: name
  } : {
    $field: field
  };
}
const keyFieldRef = fieldRef$1('key');
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref = {
    $key: fields
  };
  if (flat) ref.$flat = true;
  return ref;
} // -----

const Ascending = 'ascending';
const Descending = 'descending';
function sortKey(sort) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);
}
function aggrField(op, field) {
  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');
} // -----

const Scope$1 = 'scope';
const View = 'view';
function isSignal(_) {
  return _ && _.signal;
}
function isExpr$1(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_)) return true;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_)) for (const key in _) {
    if (hasSignal(_[key])) return true;
  }
  return false;
}
function value(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}

const Timer = 'timer';
function parseStream(stream, scope) {
  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid stream specification: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(stream));
  return method(stream, scope);
}

function eventSource(source) {
  return source === Scope$1 ? View : source || View;
}

function mergeStream(stream, scope) {
  const list = stream.merge.map(s => parseStream(s, scope)),
        entry = streamParameters({
    merge: list
  }, stream, scope);
  return scope.addStream(entry).id;
}

function nestedStream(stream, scope) {
  const id = parseStream(stream.stream, scope),
        entry = streamParameters({
    stream: id
  }, stream, scope);
  return scope.addStream(entry).id;
}

function eventStream(stream, scope) {
  let id;

  if (stream.type === Timer) {
    id = scope.event(Timer, stream.throttle);
    stream = {
      between: stream.between,
      filter: stream.filter
    };
  } else {
    id = scope.event(eventSource(stream.source), stream.type);
  }

  const entry = streamParameters({
    stream: id
  }, stream, scope);
  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;
}

function streamParameters(entry, stream, scope) {
  let param = stream.between;

  if (param) {
    if (param.length !== 2) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Stream "between" parameter must have 2 entries: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(stream));
    }

    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];
  }

  param = stream.filter ? [].concat(stream.filter) : [];

  if (stream.marktype || stream.markname || stream.markrole) {
    // add filter for mark type, name and/or role
    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));
  }

  if (stream.source === Scope$1) {
    // add filter to limit events from sub-scope only
    param.push('inScope(event.item)');
  }

  if (param.length) {
    entry.filter = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)('(' + param.join(')&&(') + ')', scope).$expr;
  }

  if ((param = stream.throttle) != null) {
    entry.throttle = +param;
  }

  if ((param = stream.debounce) != null) {
    entry.debounce = +param;
  }

  if (stream.consume) {
    entry.consume = true;
  }

  return entry;
}

function filterMark(type, name, role) {
  const item = 'event.item';
  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\'' + type + '\'' : '') + (role ? '&&' + item + '.mark.role===\'' + role + '\'' : '') + (name ? '&&' + item + '.mark.name===\'' + name + '\'' : '');
}

const OP_VALUE_EXPR = {
  code: '_.$value',
  ast: {
    type: 'Identifier',
    value: 'value'
  }
};
function parseUpdate (spec, scope, target) {
  const encode = spec.encode,
        entry = {
    target: target
  };
  let events = spec.events,
      update = spec.update,
      sources = [];

  if (!events) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signal update missing events specification.');
  } // interpret as an event selector string


  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(events)) {
    events = (0,vega_event_selector__WEBPACK_IMPORTED_MODULE_2__.parseSelector)(events, scope.isSubscope() ? Scope$1 : View);
  } // separate event streams from signal updates


  events = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners

  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  } // merge event streams, include as source


  if (events.length) {
    sources.push(events.length > 1 ? {
      merge: events
    } : events[0]);
  }

  if (encode != null) {
    if (update) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signal encode and update are mutually exclusive.');
    update = 'encode(item(),' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(encode) + ')';
  } // resolve update value


  entry.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(update) ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update, scope) : update.expr != null ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update.signal)
    }
  } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid signal update specification.');

  if (spec.force) {
    entry.options = {
      force: true
    };
  }

  sources.forEach(source => scope.addUpdate((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(streamSource(source, scope), entry)));
}

function streamSource(stream, scope) {
  return {
    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)
  };
}

function mergeSources(sources) {
  return {
    signal: '[' + sources.map(s => s.scale ? 'scale("' + s.scale + '")' : s.signal) + ']'
  };
}

function parseSignalUpdates (signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr = signal.update;

  if (signal.init) {
    if (expr) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signals can not include both init and update expressions.');
    } else {
      expr = signal.init;
      op.initonly = true;
    }
  }

  if (expr) {
    expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(expr, scope);
    op.update = expr.$expr;
    op.params = expr.$params;
  }

  if (signal.on) {
    signal.on.forEach(_ => parseUpdate(_, scope, op.id));
  }
}

const transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);

const Aggregate = transform('aggregate');
const AxisTicks = transform('axisticks');
const Bound = transform('bound');
const Collect = transform('collect');
const Compare = transform('compare');
const DataJoin = transform('datajoin');
const Encode = transform('encode');
const Expression = transform('expression');
const Facet = transform('facet');
const Field = transform('field');
const Key = transform('key');
const LegendEntries = transform('legendentries');
const Load = transform('load');
const Mark = transform('mark');
const MultiExtent = transform('multiextent');
const MultiValues = transform('multivalues');
const Overlap = transform('overlap');
const Params = transform('params');
const PreFacet = transform('prefacet');
const Projection = transform('projection');
const Proxy = transform('proxy');
const Relay = transform('relay');
const Render = transform('render');
const Scale = transform('scale');
const Sieve = transform('sieve');
const SortItems = transform('sortitems');
const ViewLayout = transform('viewlayout');
const Values = transform('values');

let FIELD_REF_ID = 0;
const MULTIDOMAIN_SORT_OPS = {
  min: 'min',
  max: 'max',
  count: 'sum'
};
function initScale(spec, scope) {
  const type = spec.type || 'linear';

  if (!(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isValidScaleType)(type)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(type));
  }

  scope.addScale(spec.name, {
    type,
    domain: undefined
  });
}
function parseScale(spec, scope) {
  const params = scope.getScale(spec.name).params;
  let key;
  params.domain = parseScaleDomain(spec.domain, spec, scope);

  if (spec.range != null) {
    params.range = parseScaleRange(spec, scope, params);
  }

  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params);
  }

  if (spec.nice != null) {
    params.nice = parseScaleNice(spec.nice);
  }

  if (spec.bins != null) {
    params.bins = parseScaleBins(spec.bins, scope);
  }

  for (key in spec) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, key) || key === 'name') continue;
    params[key] = parseLiteral(spec[key], scope);
  }
}

function parseLiteral(v, scope) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(v) ? v : v.signal ? scope.signalRef(v.signal) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported object: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(v));
}

function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));
}

function dataLookupError(name) {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Can not find data set: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
} // -- SCALE DOMAIN ----


function parseScaleDomain(domain, spec, scope) {
  if (!domain) {
    if (spec.domainMin != null || spec.domainMax != null) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No scale domain defined for domainMin/domainMax to override.');
    }

    return; // default domain
  }

  return domain.signal ? scope.signalRef(domain.signal) : ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);
}

function explicitDomain(domain, spec, scope) {
  return domain.map(v => parseLiteral(v, scope));
}

function singularDomain(domain, spec, scope) {
  const data = scope.getData(domain.data);
  if (!data) dataLookupError(domain.data);
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isQuantile)(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);
}

function multipleDomain(domain, spec, scope) {
  const data = domain.data,
        fields = domain.fields.reduce((dom, d) => {
    d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(d) ? {
      data: data,
      field: d
    } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(d) || d.signal ? fieldRef(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return ((0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? ordinalMultipleDomain : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isQuantile)(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);
}

function fieldRef(data, scope) {
  const name = '_:vega:_' + FIELD_REF_ID++,
        coll = Collect({});

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data)) {
    coll.value = {
      $ingest: data
    };
  } else if (data.signal) {
    const code = 'setdata(' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name) + ',' + data.signal + ')';
    coll.params.input = scope.signalRef(code);
  }

  scope.addDataPipeline(name, [coll, Sieve({})]);
  return {
    data: name,
    field: 'data'
  };
}

function ordinalMultipleDomain(domain, scope, fields) {
  const sort = parseSort(domain.sort, true);
  let a, v; // get value counts for each domain field

  const counts = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.countsRef(scope, f.field, sort);
  }); // aggregate the results from each domain field

  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };

  if (sort) {
    a = sort.op || 'count';
    v = sort.field ? aggrField(a, sort.field) : 'count';
    p.ops = [MULTIDOMAIN_SORT_OPS[a]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }

  a = scope.add(Aggregate(p)); // collect aggregate output

  const c = scope.add(Collect({
    pulse: ref(a)
  })); // extract values for combined domain

  v = scope.add(Values({
    field: keyFieldRef,
    sort: scope.sortRef(sort),
    pulse: ref(c)
  }));
  return ref(v);
}

function parseSort(sort, multidomain) {
  if (sort) {
    if (!sort.field && !sort.op) {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sort)) sort.field = 'key';else sort = {
        field: 'key'
      };
    } else if (!sort.field && sort.op !== 'count') {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No field provided for sort aggregate op: ' + sort.op);
    } else if (multidomain && sort.field) {
      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Multiple domain scales can not be sorted using ' + sort.op);
      }
    }
  }

  return sort;
}

function quantileMultipleDomain(domain, scope, fields) {
  // get value arrays for each domain field
  const values = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.domainRef(scope, f.field);
  }); // combine value arrays

  return ref(scope.add(MultiValues({
    values: values
  })));
}

function numericMultipleDomain(domain, scope, fields) {
  // get extents for each domain field
  const extents = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.extentRef(scope, f.field);
  }); // combine extents

  return ref(scope.add(MultiExtent({
    extents: extents
  })));
} // -- SCALE BINS -----


function parseScaleBins(v, scope) {
  return v.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? parseArray(v, scope) : scope.objectProperty(v);
} // -- SCALE NICE -----


function parseScaleNice(nice) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(nice) ? {
    interval: parseLiteral(nice.interval),
    step: parseLiteral(nice.step)
  } : parseLiteral(nice);
} // -- SCALE INTERPOLATION -----


function parseScaleInterpolate(interpolate, params) {
  params.interpolate = parseLiteral(interpolate.type || interpolate);

  if (interpolate.gamma != null) {
    params.interpolateGamma = parseLiteral(interpolate.gamma);
  }
} // -- SCALE RANGE -----


function parseScaleRange(spec, scope, params) {
  const config = scope.config.range;
  let range = spec.range;

  if (range.signal) {
    return scope.signalRef(range.signal);
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(range)) {
    if (config && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(config, range)) {
      spec = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, spec, {
        range: config[range]
      });
      return parseScaleRange(spec, scope, params);
    } else if (range === 'width') {
      range = [0, {
        signal: 'width'
      }];
    } else if (range === 'height') {
      range = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? [0, {
        signal: 'height'
      }] : [{
        signal: 'height'
      }, 0];
    } else {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale range value: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(range));
    }
  } else if (range.scheme) {
    params.scheme = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);
    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);
    if (range.count) params.schemeCount = parseLiteral(range.count, scope);
    return;
  } else if (range.step) {
    params.rangeStep = parseLiteral(range.step, scope);
    return;
  } else if ((0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range)) {
    return parseScaleDomain(range, spec, scope);
  } else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported range type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(range));
  }

  return range.map(v => ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? parseArray : parseLiteral)(v, scope));
}

function parseProjection (proj, scope) {
  const config = scope.config.projection || {},
        params = {};

  for (const name in proj) {
    if (name === 'name') continue;
    params[name] = parseParameter$1(proj[name], name, scope);
  } // apply projection defaults from config


  for (const name in config) {
    if (params[name] == null) {
      params[name] = parseParameter$1(config[name], name, scope);
    }
  }

  scope.addProjection(proj.name, params);
}

function parseParameter$1(_, name, scope) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported parameter object: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(_));
}

const Top = 'top';
const Left = 'left';
const Right = 'right';
const Bottom = 'bottom';
const Center = 'center';
const Vertical = 'vertical';
const Start = 'start';
const Middle = 'middle';
const End = 'end';
const Index = 'index';
const Label = 'label';
const Offset = 'offset';
const Perc = 'perc';
const Perc2 = 'perc2';
const Value = 'value';
const GuideLabelStyle = 'guide-label';
const GuideTitleStyle = 'guide-title';
const GroupTitleStyle = 'group-title';
const GroupSubtitleStyle = 'group-subtitle';
const Symbols = 'symbol';
const Gradient = 'gradient';
const Discrete = 'discrete';
const Size = 'size';
const Shape = 'shape';
const Fill = 'fill';
const Stroke = 'stroke';
const StrokeWidth = 'strokeWidth';
const StrokeDash = 'strokeDash';
const Opacity = 'opacity'; // Encoding channels supported by legends
// In priority order of 'canonical' scale

const LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
const Skip = {
  name: 1,
  style: 1,
  interactive: 1
};
const zero = {
  value: 0
};
const one = {
  value: 1
};

const GroupMark = 'group';
const RectMark = 'rect';
const RuleMark = 'rule';
const SymbolMark = 'symbol';
const TextMark = 'text';

function guideGroup (mark) {
  mark.type = GroupMark;
  mark.interactive = mark.interactive || false;
  return mark;
}

function lookup(spec, config) {
  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));

  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));

  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);

  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);

  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));

  return _;
}
function getEncoding(name, encode) {
  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name, scope, style) {
  const s = scope.config.style[style];
  return s && s[name];
}
function anchorExpr(s, e, m) {
  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;
}
const alignExpr$1 = anchorExpr((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Left), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Right), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Center));
function tickBand(_) {
  const v = _('tickBand');

  let offset = _('tickOffset'),
      band,
      extra;

  if (!v) {
    // if no tick band entry, fall back on other properties
    band = _('bandPosition');
    extra = _('tickExtra');
  } else if (v.signal) {
    // if signal, augment code to interpret values
    band = {
      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`
    };
    extra = {
      signal: `(${v.signal}) === 'extent'`
    };

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(offset)) {
      offset = {
        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`
      };
    }
  } else if (v === 'extent') {
    // if constant, simply set values
    band = 1;
    extra = true;
    offset = 0;
  } else {
    band = 0.5;
    extra = false;
  }

  return {
    extra,
    band,
    offset
  };
}
function extendOffset(value, offset) {
  return !offset ? value : !value ? offset : !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? {
    value,
    offset
  } : Object.assign({}, value, {
    offset: extendOffset(value.offset, offset)
  });
}

function guideMark (mark, extras) {
  if (extras) {
    mark.name = extras.name;
    mark.style = extras.style || mark.style;
    mark.interactive = !!extras.interactive;
    mark.encode = extendEncode(mark.encode, extras, Skip);
  } else {
    mark.interactive = false;
  }

  return mark;
}

function legendGradient (spec, scale, config, userEncode) {
  const _ = lookup(spec, config),
        vertical = _.isVertical(),
        thickness = _.gradientThickness(),
        length = _.gradientLength();

  let enter, start, stop, width, height;

  if (vertical) {
    start = [0, 1];
    stop = [0, 0];
    width = thickness;
    height = length;
  } else {
    start = [0, 0];
    stop = [1, 0];
    width = length;
    height = thickness;
  }

  const encode = {
    enter: enter = {
      opacity: zero,
      x: zero,
      y: zero,
      width: encoder(width),
      height: encoder(height)
    },
    update: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one,
      fill: {
        gradient: scale,
        start: start,
        stop: stop
      }
    }),
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gradientStrokeColor'),
    strokeWidth: _('gradientStrokeWidth')
  }, {
    // update
    opacity: _('gradientOpacity')
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode
  }, userEncode);
}

function legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        vertical = _.isVertical(),
        thickness = _.gradientThickness(),
        length = _.gradientLength();

  let u,
      v,
      uu,
      vv,
      adjust = '';
  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');
  const enter = {
    opacity: zero,
    fill: {
      scale: scale,
      field: Value
    }
  };
  enter[u] = {
    signal: adjust + 'datum.' + Perc,
    mult: length
  };
  enter[v] = zero;
  enter[uu] = {
    signal: adjust + 'datum.' + Perc2,
    mult: length
  };
  enter[vv] = encoder(thickness);
  const encode = {
    enter: enter,
    update: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one
    }),
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gradientStrokeColor'),
    strokeWidth: _('gradientStrokeWidth')
  }, {
    // update
    opacity: _('gradientOpacity')
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

const alignExpr = `datum.${Perc}<=0?"${Left}":datum.${Perc}>=1?"${Right}":"${Center}"`,
      baselineExpr = `datum.${Perc}<=0?"${Bottom}":datum.${Perc}>=1?"${Top}":"${Middle}"`;
function legendGradientLabels (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        vertical = _.isVertical(),
        thickness = encoder(_.gradientThickness()),
        length = _.gradientLength();

  let overlap = _('labelOverlap'),
      enter,
      update,
      u,
      v,
      adjust = '';

  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one,
      text: {
        field: Label
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontStyle: _('labelFontStyle'),
    fontWeight: _('labelFontWeight'),
    limit: value(spec.labelLimit, config.gradientLabelLimit)
  });

  if (vertical) {
    enter.align = {
      value: 'left'
    };
    enter.baseline = update.baseline = {
      signal: baselineExpr
    };
    u = 'y';
    v = 'x';
    adjust = '1-';
  } else {
    enter.align = update.align = {
      signal: alignExpr
    };
    enter.baseline = {
      value: 'top'
    };
    u = 'x';
    v = 'y';
  }

  enter[u] = update[u] = {
    signal: adjust + 'datum.' + Perc,
    mult: length
  };
  enter[v] = update[v] = thickness;
  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _('labelSeparation'),
    method: overlap,
    order: 'datum.' + Index
  } : undefined; // type, role, style, key, dataRef, encode, extras

  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode,
    overlap
  }, userEncode);
}

function legendSymbolGroups (spec, config, userEncode, dataRef, columns) {
  const _ = lookup(spec, config),
        entries = userEncode.entries,
        interactive = !!(entries && entries.interactive),
        name = entries ? entries.name : undefined,
        height = _('clipHeight'),
        symbolOffset = _('symbolOffset'),
        valueRef = {
    data: 'value'
  },
        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,
        yEncode = height ? encoder(height) : {
    field: Size
  },
        index = `datum.${Index}`,
        ncols = `max(1, ${columns})`;

  let encode, enter, update, nrows, sort;
  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --

  encode = {
    enter: enter = {
      opacity: zero,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update = {
      opacity: one,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero
    }
  };
  let baseFill = null,
      baseStroke = null;

  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }

  addEncoders(encode, {
    fill: _('symbolFillColor', baseFill),
    shape: _('symbolType'),
    size: _('symbolSize'),
    stroke: _('symbolStrokeColor', baseStroke),
    strokeDash: _('symbolDash'),
    strokeDashOffset: _('symbolDashOffset'),
    strokeWidth: _('symbolStrokeWidth')
  }, {
    // update
    opacity: _('symbolOpacity')
  });
  LegendScales.forEach(scale => {
    if (spec[scale]) {
      update[scale] = enter[scale] = {
        scale: spec[scale],
        field: Value
      };
    }
  });
  const symbols = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height ? true : undefined,
    encode
  }, userEncode.symbols); // -- LEGEND LABELS --

  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _('labelOffset');
  encode = {
    enter: enter = {
      opacity: zero,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update = {
      opacity: one,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    align: _('labelAlign'),
    baseline: _('labelBaseline'),
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontStyle: _('labelFontStyle'),
    fontWeight: _('labelFontWeight'),
    limit: _('labelLimit')
  });
  const labels = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode
  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --

  encode = {
    enter: {
      noBound: {
        value: !height
      },
      // ignore width/height in bounds calc
      width: zero,
      height: height ? encoder(height) : zero,
      opacity: zero
    },
    exit: {
      opacity: zero
    },
    update: update = {
      opacity: one,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  }; // annotate and sort groups to ensure correct ordering

  if (_.isVertical(true)) {
    nrows = `ceil(item.mark.items.length / ${ncols})`;
    update.row.signal = `${index}%${nrows}`;
    update.column.signal = `floor(${index} / ${nrows})`;
    sort = {
      field: ['row', index]
    };
  } else {
    update.row.signal = `floor(${index} / ${ncols})`;
    update.column.signal = `${index} % ${ncols}`;
    sort = {
      field: index
    };
  } // handle zero column case (implies infinite columns)


  update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups

  dataRef = {
    facet: {
      data: dataRef,
      name: 'value',
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole,
    from: dataRef,
    encode: extendEncode(encode, entries, Skip),
    marks: [symbols, labels],
    name,
    interactive,
    sort
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup(spec, config); // layout parameters for legend entries


  return {
    align: _('gridAlign'),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _('rowPadding'),
      column: _('columnPadding')
    }
  };
}

const isL = 'item.orient === "left"',
      isR = 'item.orient === "right"',
      isLR = `(${isL} || ${isR})`,
      isVG = `datum.vgrad && ${isLR}`,
      baseline = anchorExpr('"top"', '"bottom"', '"middle"'),
      alignFlip = anchorExpr('"right"', '"left"', '"center"'),
      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`,
      exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`,
      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,
      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline}) : "top"`;
function legendTitle (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config);

  const encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: one,
      x: {
        field: {
          group: 'padding'
        }
      },
      y: {
        field: {
          group: 'padding'
        }
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    orient: _('titleOrient'),
    _anchor: _('titleAnchor'),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _('titleColor'),
    fillOpacity: _('titleOpacity'),
    font: _('titleFont'),
    fontSize: _('titleFontSize'),
    fontStyle: _('titleFontStyle'),
    fontWeight: _('titleFontWeight'),
    limit: _('titleLimit'),
    lineHeight: _('titleLineHeight')
  }, {
    // require update
    align: _('titleAlign'),
    baseline: _('titleBaseline')
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function clip (clip, scope) {
  let expr;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(clip)) {
    if (clip.signal) {
      expr = clip.signal;
    } else if (clip.path) {
      expr = 'pathShape(' + param(clip.path) + ')';
    } else if (clip.sphere) {
      expr = 'geoShape(' + param(clip.sphere) + ', {type: "Sphere"})';
    }
  }

  return expr ? scope.signalRef(expr) : !!clip;
}

function param(value) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && value.signal ? value.signal : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value);
}

function getRole (spec) {
  const role = spec.role || '';
  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;
}

function definition (spec) {
  return {
    marktype: spec.type,
    name: spec.name || undefined,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || undefined,
    aria: spec.aria,
    description: spec.description
  };
}

function interactive (spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}

/**
 * Parse a data transform specification.
 */

function parseTransform (spec, scope) {
  const def = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_4__.definition)(spec.type);
  if (!def) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized transform type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(spec.type));
  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));
  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));
  t.metadata = def.metadata || {};
  return t;
}
/**
 * Parse all parameters of a data transform.
 */

function parseParameters(def, spec, scope) {
  const params = {},
        n = def.params.length;

  for (let i = 0; i < n; ++i) {
    const pdef = def.params[i];
    params[pdef.name] = parseParameter(pdef, spec, scope);
  }

  return params;
}
/**
 * Parse a data transform parameter.
 */


function parseParameter(def, spec, scope) {
  const type = def.type,
        value = spec[def.name];

  if (type === 'index') {
    return parseIndexParameter(def, spec, scope);
  } else if (value === undefined) {
    if (def.required) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing required ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(spec.type) + ' parameter: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(def.name));
    }

    return;
  } else if (type === 'param') {
    return parseSubParameters(def, spec, scope);
  } else if (type === 'projection') {
    return scope.projectionRef(spec[def.name]);
  }

  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);
}
/**
 * Parse a single parameter value.
 */


function parameterValue(def, value, scope) {
  const type = def.type;

  if (isSignal(value)) {
    return isExpr(type) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);
  } else {
    const expr = def.expr || isField(type);
    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;
  }
}
/**
 * Parse parameter for accessing an index of another data set.
 */


function parseIndexParameter(def, spec, scope) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec.from)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Lookup "from" parameter must be a string literal.');
  }

  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
/**
 * Parse a parameter that contains one or more sub-parameter objects.
 */


function parseSubParameters(def, spec, scope) {
  const value = spec[def.name];

  if (def.array) {
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
      // signals not allowed!
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expected an array of sub-parameters. Instead: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
    }

    return value.map(v => parseSubParameter(def, v, scope));
  } else {
    return parseSubParameter(def, value, scope);
  }
}
/**
 * Parse a sub-parameter object.
 */


function parseSubParameter(def, value, scope) {
  const n = def.params.length;
  let pdef; // loop over defs to find matching key

  for (let i = 0; i < n; ++i) {
    pdef = def.params[i];

    for (const k in pdef.key) {
      if (pdef.key[k] !== value[k]) {
        pdef = null;
        break;
      }
    }

    if (pdef) break;
  } // raise error if matching key not found


  if (!pdef) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported parameter: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value)); // parse params, create Params transform, return ref

  const params = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(parseParameters(pdef, value, scope), pdef.key);
  return ref(scope.add(Params(params)));
} // -- Utilities -----


const outerExpr = _ => _ && _.expr;
const outerField = _ => _ && _.field;
const isData = _ => _ === 'data';
const isExpr = _ => _ === 'expr';
const isField = _ => _ === 'field';
const isCompare = _ => _ === 'compare';

function parseData$1 (from, group, scope) {
  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum

  if (!from) {
    dataRef = ref(scope.add(Collect(null, [{}])));
  } // if faceted, process facet specification
  else if (facet = from.facet) {
    if (!group) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Only group marks can be faceted.'); // use pre-faceted source data, if available

    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      // generate facet aggregates if no direct data specification
      if (!from.data) {
        op = parseTransform((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
          type: 'aggregate',
          groupby: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }

      key = scope.keyRef(facet.groupby, true);
    }
  } // if not yet defined, get source data reference


  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }

  return {
    key: key,
    pulse: dataRef,
    parent: parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}

function DataScope(scope, input, output, values, aggr) {
  this.scope = scope; // parent scope object

  this.input = input; // first operator in pipeline (tuple input)

  this.output = output; // last operator in pipeline (tuple output)

  this.values = values; // operator for accessing tuples (but not tuple flow)
  // last aggregate in transform pipeline

  this.aggregate = aggr; // lookup table of field indices

  this.index = {};
}

DataScope.fromEntries = function (scope, entries) {
  const n = entries.length,
        values = entries[n - 1],
        output = entries[n - 2];
  let input = entries[0],
      aggr = null,
      i = 1;

  if (input && input.type === 'load') {
    input = entries[1];
  } // add operator entries to this scope, wire up pulse chain


  scope.add(entries[0]);

  for (; i < n; ++i) {
    entries[i].params.pulse = ref(entries[i - 1]);
    scope.add(entries[i]);
    if (entries[i].type === 'aggregate') aggr = entries[i];
  }

  return new DataScope(scope, input, output, values, aggr);
};

function fieldKey(field) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field) ? field : null;
}

function addSortField(scope, p, sort) {
  const as = aggrField(sort.op, sort.field);
  let s;

  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as) return;
    }
  } else {
    p.ops = ['count'];
    p.fields = [null];
    p.as = ['count'];
  }

  if (sort.op) {
    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);
    p.fields.push(scope.fieldRef(sort.field));
    p.as.push(as);
  }
}

function cache(scope, ds, name, optype, field, counts, index) {
  const cache = ds[name] || (ds[name] = {}),
        sort = sortKey(counts);
  let k = fieldKey(field),
      v,
      op;

  if (k != null) {
    scope = ds.scope;
    k = k + (sort ? '|' + sort : '');
    v = cache[k];
  }

  if (!v) {
    const params = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field, counts)
    } : {
      field: scope.fieldRef(field),
      pulse: ref(ds.output)
    };
    if (sort) params.sort = scope.sortRef(counts);
    op = scope.add(entry(optype, undefined, params));
    if (index) ds.index[field] = op;
    v = ref(op);
    if (k != null) cache[k] = v;
  }

  return v;
}

DataScope.prototype = {
  countsRef(scope, field, sort) {
    const ds = this,
          cache = ds.counts || (ds.counts = {}),
          k = fieldKey(field);
    let v, a, p;

    if (k != null) {
      scope = ds.scope;
      v = cache[k];
    }

    if (!v) {
      p = {
        groupby: scope.fieldRef(field, 'key'),
        pulse: ref(ds.output)
      };
      if (sort && sort.field) addSortField(scope, p, sort);
      a = scope.add(Aggregate(p));
      v = scope.add(Collect({
        pulse: ref(a)
      }));
      v = {
        agg: a,
        ref: ref(v)
      };
      if (k != null) cache[k] = v;
    } else if (sort && sort.field) {
      addSortField(scope, v.agg.params, sort);
    }

    return v.ref;
  },

  tuplesRef() {
    return ref(this.values);
  },

  extentRef(scope, field) {
    return cache(scope, this, 'extent', 'extent', field, false);
  },

  domainRef(scope, field) {
    return cache(scope, this, 'domain', 'values', field, false);
  },

  valuesRef(scope, field, sort) {
    return cache(scope, this, 'vals', 'values', field, sort || true);
  },

  lookupRef(scope, field) {
    return cache(scope, this, 'lookup', 'tupleindex', field, false);
  },

  indataRef(scope, field) {
    return cache(scope, this, 'indata', 'tupleindex', field, true, true);
  }

};

function parseFacet (spec, scope, group) {
  const facet = spec.from.facet,
        name = facet.name,
        data = getDataRef(facet, scope);
  let op;

  if (!facet.name) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must have a name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  }

  if (!facet.data) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must reference a data set: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  }

  if (facet.field) {
    op = scope.add(PreFacet({
      field: scope.fieldRef(facet.field),
      pulse: data
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group.parent)),
      pulse: data
    }));
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must specify groupby or field: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  } // initialize facet subscope


  const subscope = scope.fork(),
        source = subscope.add(Collect()),
        values = subscope.add(Sieve({
    pulse: ref(source)
  }));
  subscope.addData(name, new DataScope(subscope, source, source, values));
  subscope.addSignal('parent', null); // parse faceted subflow

  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}

function parseSubflow (spec, scope, input) {
  const op = scope.add(PreFacet({
    pulse: input.pulse
  })),
        subscope = scope.fork();
  subscope.add(Sieve());
  subscope.addSignal('parent', null); // parse group mark subflow

  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}

function parseTrigger (spec, scope, name) {
  const remove = spec.remove,
        insert = spec.insert,
        toggle = spec.toggle,
        modify = spec.modify,
        values = spec.values,
        op = scope.add(operator());
  const update = 'if(' + spec.trigger + ',modify("' + name + '",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';
  const expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update, scope);
  op.update = expr.$expr;
  op.params = expr.$params;
}

function parseMark (spec, scope) {
  const role = getRole(spec),
        group = spec.type === GroupMark,
        facet = spec.from && spec.from.facet,
        overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole || role === FrameRole,
      ops,
      op,
      store,
      enc,
      name,
      layoutRef,
      boundRef;
  const nested = role === MarkRole || layout || facet; // resolve input data

  const input = parseData$1(spec.from, group, scope); // data join to map tuples to visual items

  op = scope.add(DataJoin({
    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),
    pulse: input.pulse,
    clean: !group
  }));
  const joinRef = ref(op); // collect visual items

  op = store = scope.add(Collect({
    pulse: joinRef
  })); // connect visual items to scenegraph

  op = scope.add(Mark({
    markdef: definition(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef('parent') : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op); // add visual encoders

  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  }))); // monitor parent marks to propagate changes

  op.params.parent = scope.encode(); // add post-encoding transforms, if defined

  if (spec.transform) {
    spec.transform.forEach(_ => {
      const tx = parseTransform(_, scope),
            md = tx.metadata;

      if (md.generates || md.changes) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Mark transforms should not generate new data.');
      }

      if (!md.nomod) enc.params.mod = true; // update encode mod handling

      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  } // if item sort specified, perform post-encoding


  if (spec.sort) {
    op = scope.add(SortItems({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }

  const encodeRef = ref(op); // add view layout operator if needed

  if (facet || layout) {
    layout = scope.add(ViewLayout({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  } // compute bounding boxes


  const bound = scope.add(Bound({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound); // if group mark, recurse to parse nested content

  if (group) {
    // juggle layout & bounds to ensure they run *after* any faceting transforms
    if (nested) {
      ops = scope.operators;
      ops.pop();
      if (layout) ops.pop();
    }

    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) // explicit facet
    : nested ? parseSubflow(spec, scope, input) // standard mark group
    : scope.parse(spec); // guide group, we can avoid nested scopes

    scope.popState();

    if (nested) {
      if (layout) ops.push(layout);
      ops.push(bound);
    }
  } // if requested, add overlap removal transform


  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  } // render / sieve items


  const render = scope.add(Render({
    pulse: boundRef
  })),
        sieve = scope.add(Sieve({
    pulse: ref(render)
  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry
  // add trigger updates if defined

  if (spec.name != null) {
    name = spec.name;
    scope.addData(name, new DataScope(scope, store, render, sieve));
    if (spec.on) spec.on.forEach(on => {
      if (on.insert || on.remove || on.toggle) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Marks only support modify triggers.');
      }

      parseTrigger(on, scope, name);
    });
  }
}

function parseOverlap(overlap, source, scope) {
  const method = overlap.method,
        bound = overlap.bound,
        sep = overlap.separation;
  const params = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method) ? scope.signalRef(method.signal) : method,
    pulse: source
  };

  if (overlap.order) {
    params.sort = scope.compareRef({
      field: overlap.order
    });
  }

  if (bound) {
    const tol = bound.tolerance;
    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params.boundScale = scope.scaleRef(bound.scale);
    params.boundOrient = bound.orient;
  }

  return ref(scope.add(Overlap(params)));
}

function parseLegend (spec, scope) {
  const config = scope.config.legend,
        encode = spec.encode || {},
        _ = lookup(spec, config),
        legendEncode = encode.legend || {},
        name = legendEncode.name || undefined,
        interactive = legendEncode.interactive,
        style = legendEncode.style,
        scales = {};

  let scale = 0,
      entryLayout,
      params,
      children; // resolve scales and 'canonical' scale name

  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);
  if (!scale) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)

  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group

  const datum = {
    title: spec.title != null,
    scales: scales,
    type: type,
    vgrad: type !== 'symbol' && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group

  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  }; // data source for legend values

  const entryRef = ref(scope.add(LegendEntries(params = {
    type: type,
    scale: scope.scaleRef(scale),
    count: scope.objectProperty(_('tickCount')),
    limit: scope.property(_('symbolLimit')),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  }))); // continuous gradient legend

  if (type === Gradient) {
    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length

    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
  } // discrete gradient legend
  else if (type === Discrete) {
    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];
  } // symbol legend
  else {
    // determine legend symbol group layout
    entryLayout = legendSymbolLayout(spec, config);
    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator

    params.size = sizeExpression(spec, scope, children[0].marks);
  } // generate legend marks


  children = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children,
    layout: entryLayout,
    interactive
  })]; // include legend title if defined

  if (datum.title) {
    children.push(legendTitle(spec, config, encode.title, dataRef));
  } // parse legend specification


  return parseMark(guideGroup({
    role: LegendRole,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
}

function legendType(spec, scaleType) {
  let type = spec.type || Symbols;

  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isContinuous)(scaleType) ? Gradient : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscretizing)(scaleType) ? Discrete : Symbols;
  }

  return type !== Gradient ? type : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscretizing)(scaleType) ? Discrete : Gradient;
}

function scaleCount(spec) {
  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);
}

function buildLegendEncode(_, spec, config) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    offset: _('offset'),
    padding: _('padding'),
    titlePadding: _('titlePadding'),
    cornerRadius: _('cornerRadius'),
    fill: _('fillColor'),
    stroke: _('strokeColor'),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _('legendX'),
    y: _('legendY'),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode;
}

function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel('size', spec, marks)),
        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),
        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);
}

function getChannel(name, spec, marks) {
  return spec[name] ? `scale("${spec[name]}",datum)` : getEncoding(name, marks[0].encode);
}

function getFontSize(encode, scope, style) {
  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);
}

const angleExpr = `item.orient==="${Left}"?-90:item.orient==="${Right}"?90:0`;
function parseTitle (spec, scope) {
  spec = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec) ? {
    text: spec
  } : spec;

  const _ = lookup(spec, scope.config.title),
        encode = spec.encode || {},
        userEncode = encode.group || {},
        name = userEncode.name || undefined,
        interactive = userEncode.interactive,
        style = userEncode.style,
        children = []; // single-element data source for group title


  const datum = {},
        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text

  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text

  if (spec.subtitle) {
    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));
  } // parse title specification


  return parseMark(guideGroup({
    role: TitleRole,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
} // provide backwards-compatibility for title custom encode;
// the top-level encode block has been *deprecated*.

function titleEncode(spec) {
  const encode = spec.encode;
  return encode && encode.title || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode);
}

function groupEncode(_, userEncode) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    anchor: _('anchor'),
    align: {
      signal: alignExpr$1
    },
    angle: {
      signal: angleExpr
    },
    limit: _('limit'),
    frame: _('frame'),
    offset: _('offset') || 0,
    padding: _('subtitlePadding')
  });
  return extendEncode(encode, userEncode, Skip);
}

function buildTitle(spec, _, userEncode, dataRef) {
  const zero = {
    value: 0
  },
        text = spec.text,
        encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    text: text,
    align: {
      signal: 'item.mark.group.align'
    },
    angle: {
      signal: 'item.mark.group.angle'
    },
    limit: {
      signal: 'item.mark.group.limit'
    },
    baseline: 'top',
    dx: _('dx'),
    dy: _('dy'),
    fill: _('color'),
    font: _('font'),
    fontSize: _('fontSize'),
    fontStyle: _('fontStyle'),
    fontWeight: _('fontWeight'),
    lineHeight: _('lineHeight')
  }, {
    // update
    align: _('align'),
    angle: _('angle'),
    baseline: _('baseline')
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero = {
    value: 0
  },
        text = spec.subtitle,
        encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    text: text,
    align: {
      signal: 'item.mark.group.align'
    },
    angle: {
      signal: 'item.mark.group.angle'
    },
    limit: {
      signal: 'item.mark.group.limit'
    },
    baseline: 'top',
    dx: _('dx'),
    dy: _('dy'),
    fill: _('subtitleColor'),
    font: _('subtitleFont'),
    fontSize: _('subtitleFontSize'),
    fontStyle: _('subtitleFontStyle'),
    fontWeight: _('subtitleFontWeight'),
    lineHeight: _('subtitleLineHeight')
  }, {
    // update
    align: _('align'),
    angle: _('angle'),
    baseline: _('baseline')
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function parseData(data, scope) {
  const transforms = [];

  if (data.transform) {
    data.transform.forEach(tx => {
      transforms.push(parseTransform(tx, scope));
    });
  }

  if (data.on) {
    data.on.forEach(on => {
      parseTrigger(on, scope, data.name);
    });
  }

  scope.addDataPipeline(data.name, analyze(data, scope, transforms));
}
/**
 * Analyze a data pipeline, add needed operators.
 */

function analyze(data, scope, ops) {
  const output = [];
  let source = null,
      modify = false,
      generate = false,
      upstream,
      i,
      n,
      t,
      m;

  if (data.values) {
    // hard-wired input data set
    if (isSignal(data.values) || hasSignal(data.format)) {
      // if either values is signal or format has signal, use dynamic loader
      output.push(load(scope, data));
      output.push(source = collect());
    } else {
      // otherwise, ingest upon dataflow init
      output.push(source = collect({
        $ingest: data.values,
        $format: data.format
      }));
    }
  } else if (data.url) {
    // load data from external source
    if (hasSignal(data.url) || hasSignal(data.format)) {
      // if either url or format has signal, use dynamic loader
      output.push(load(scope, data));
      output.push(source = collect());
    } else {
      // otherwise, request load upon dataflow init
      output.push(source = collect({
        $request: data.url,
        $format: data.format
      }));
    }
  } else if (data.source) {
    // derives from one or more other data sets
    source = upstream = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(data.source).map(d => ref(scope.getData(d).output));
    output.push(null); // populate later
  } // scan data transforms, add collectors as needed


  for (i = 0, n = ops.length; i < n; ++i) {
    t = ops[i];
    m = t.metadata;

    if (!source && !m.source) {
      output.push(source = collect());
    }

    output.push(t);
    if (m.generates) generate = true;
    if (m.modifies && !generate) modify = true;
    if (m.source) source = t;else if (m.changes) source = null;
  }

  if (upstream) {
    n = upstream.length - 1;
    output[0] = Relay({
      derive: modify,
      pulse: n ? upstream : upstream[0]
    });

    if (modify || n) {
      // collect derived and multi-pulse tuples
      output.splice(1, 0, collect());
    }
  }

  if (!source) output.push(collect());
  output.push(Sieve({}));
  return output;
}

function collect(values) {
  const s = Collect({}, values);
  s.metadata = {
    source: true
  };
  return s;
}

function load(scope, data) {
  return Load({
    url: data.url ? scope.property(data.url) : undefined,
    async: data.async ? scope.property(data.async) : undefined,
    values: data.values ? scope.property(data.values) : undefined,
    format: scope.objectProperty(data.format)
  });
}

const isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient


const getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction

const ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction

const ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;
const ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {
  value: a
} : {
  value: b
};
const ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {
  value: a
} : {
  value: b
};

const ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);

const ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);

const ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);

const ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);

const ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);

const ifEnc = (test, a, b) => {
  // ensure inputs are encoder objects (or null)
  a = a != null ? encoder(a) : a;
  b = b != null ? encoder(b) : b;

  if (isSimple(a) && isSimple(b)) {
    // if possible generate simple signal expression
    a = a ? a.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(a.value) : null;
    b = b ? b.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(b.value) : null;
    return {
      signal: `${test} ? (${a}) : (${b})`
    };
  } else {
    // otherwise generate rule set
    return [(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      test
    }, a)].concat(b || []);
  }
};

const isSimple = enc => enc == null || Object.keys(enc).length === 1;

const ifExpr = (test, a, b) => ({
  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`
});

const ifOrient = ($orient, t, b, l, r) => ({
  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'
});

const toExpr = v => isSignal(v) ? v.signal : v == null ? null : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(v);

const mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {
  signal: `(${sign.signal}) * ${value}`
} : {
  value: sign * value
};
const patch = (value, base) => {
  const s = value.signal;
  return s && s.endsWith('(null)') ? {
    signal: s.slice(0, -6) + base.signal
  } : value;
};

function fallback(prop, config, axisConfig, style) {
  let styleProp;

  if (config && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(config, prop)) {
    return config[prop];
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(axisConfig, prop)) {
    return axisConfig[prop];
  } else if (prop.startsWith('title')) {
    switch (prop) {
      case 'titleColor':
        styleProp = 'fill';
        break;

      case 'titleFont':
      case 'titleFontSize':
      case 'titleFontWeight':
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }

    return style[GuideTitleStyle][styleProp];
  } else if (prop.startsWith('label')) {
    switch (prop) {
      case 'labelColor':
        styleProp = 'fill';
        break;

      case 'labelFont':
      case 'labelFontSize':
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }

    return style[GuideLabelStyle][styleProp];
  }

  return null;
}

function keys(objects) {
  const map = {};

  for (const obj of objects) {
    if (!obj) continue;

    for (const key in obj) map[key] = 1;
  }

  return Object.keys(map);
}

function axisConfig (spec, scope) {
  var config = scope.config,
      style = config.style,
      axis = config.axis,
      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,
      orient = spec.orient,
      xy,
      or,
      key;

  if (isSignal(orient)) {
    const xyKeys = keys([config.axisX, config.axisY]),
          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};

    for (key of xyKeys) {
      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));
    }

    or = {};

    for (key of orientKeys) {
      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));
    }
  } else {
    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;
    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];
  }

  const result = xy || or || band ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, axis, xy, or, band) : axis;
  return result;
}

function axisDomain (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        orient = spec.orient;

  let enter, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('domainColor'),
    strokeCap: _('domainCap'),
    strokeDash: _('domainDash'),
    strokeDashOffset: _('domainDashOffset'),
    strokeWidth: _('domainWidth'),
    strokeOpacity: _('domainOpacity')
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update.x = ifX(orient, pos0, zero);
  enter.x2 = update.x2 = ifX(orient, pos1);
  enter.y = update.y = ifY(orient, pos0, zero);
  enter.y2 = update.y2 = ifY(orient, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode
  }, userEncode);
}

function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}

function axisGrid (spec, config, userEncode, dataRef, band) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        vscale = spec.gridScale,
        sign = getSign(orient, 1, -1),
        offset = offsetValue(spec.offset, sign);

  let enter, exit, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: exit = {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gridColor'),
    strokeCap: _('gridCap'),
    strokeDash: _('gridDash'),
    strokeDashOffset: _('gridDashOffset'),
    strokeOpacity: _('gridOpacity'),
    strokeWidth: _('gridWidth')
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band.band,
    extra: band.extra,
    offset: band.offset,
    round: _('tickRound')
  };
  const sz = ifX(orient, {
    signal: 'height'
  }, {
    signal: 'width'
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign,
    offset: offset
  } : {
    value: 0,
    offset: offset
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign,
    offset: offset
  } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(sz, {
    mult: sign,
    offset: offset
  });
  enter.x = update.x = ifX(orient, tickPos, gridStart);
  enter.y = update.y = ifY(orient, tickPos, gridStart);
  enter.x2 = update.x2 = ifY(orient, gridEnd);
  enter.y2 = update.y2 = ifX(orient, gridEnd);
  exit.x = ifX(orient, tickPos);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

function offsetValue(offset, sign) {
  if (sign === 1) ; else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(offset)) {
    offset = isSignal(sign) ? {
      signal: `(${sign.signal}) * (${offset || 0})`
    } : sign * (offset || 0);
  } else {
    let entry = offset = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, offset);

    while (entry.mult != null) {
      if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(entry.mult)) {
        entry.mult = isSignal(sign) // no offset if sign === 1
        ? {
          signal: `(${entry.mult}) * (${sign.signal})`
        } : entry.mult * sign;
        return offset;
      } else {
        entry = entry.mult = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, entry.mult);
      }
    }

    entry.mult = sign;
  }

  return offset;
}

function axisTicks (spec, config, userEncode, dataRef, size, band) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        sign = getSign(orient, -1, 1);

  let enter, exit, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: exit = {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('tickColor'),
    strokeCap: _('tickCap'),
    strokeDash: _('tickDash'),
    strokeDashOffset: _('tickDashOffset'),
    strokeOpacity: _('tickOpacity'),
    strokeWidth: _('tickWidth')
  });
  const tickSize = encoder(size);
  tickSize.mult = sign;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band.band,
    extra: band.extra,
    offset: band.offset,
    round: _('tickRound')
  };
  update.y = enter.y = ifX(orient, zero, tickPos);
  update.y2 = enter.y2 = ifX(orient, tickSize);
  exit.x = ifX(orient, tickPos);
  update.x = enter.x = ifY(orient, zero, tickPos);
  update.x2 = enter.x2 = ifY(orient, tickSize);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

function flushExpr(scale, threshold, a, b, c) {
  return {
    signal: 'flush(range("' + scale + '"), ' + 'scale("' + scale + '", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'
  };
}

function axisLabels (spec, config, userEncode, dataRef, size, band) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        scale = spec.scale,
        sign = getSign(orient, -1, 1),
        flush = deref(_('labelFlush')),
        flushOffset = deref(_('labelFlushOffset')),
        labelAlign = _('labelAlign'),
        labelBaseline = _('labelBaseline');

  let flushOn = flush === 0 || !!flush,
      update;
  const tickSize = encoder(size);
  tickSize.mult = sign;
  tickSize.offset = encoder(_('labelPadding') || 0);
  tickSize.offset.mult = sign;
  const tickPos = {
    scale: scale,
    field: Value,
    band: 0.5,
    offset: extendOffset(band.offset, _('labelOffset'))
  };
  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '"left"', '"right"', '"center"') : {
    value: 'center'
  }, ifRight(orient, 'left', 'right'));
  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '"top"', '"bottom"', '"middle"') : {
    value: 'middle'
  });
  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero,
    x: ifX(orient, tickPos, tickSize),
    y: ifY(orient, tickPos, tickSize)
  };
  const encode = {
    enter: enter,
    update: update = {
      opacity: one,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y,
      align,
      baseline
    },
    exit: {
      opacity: zero,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode, {
    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null
  });
  addEncoders(encode, {
    angle: _('labelAngle'),
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontWeight: _('labelFontWeight'),
    fontStyle: _('labelFontStyle'),
    limit: _('labelLimit'),
    lineHeight: _('labelLineHeight')
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });

  const bound = _('labelBound');

  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal


  overlap = overlap || bound ? {
    separation: _('labelSeparation'),
    method: overlap,
    order: 'datum.index',
    bound: bound ? {
      scale,
      orient,
      tolerance: bound
    } : null
  } : undefined;

  if (update.align !== align) {
    update.align = patch(update.align, align);
  }

  if (update.baseline !== baseline) {
    update.baseline = patch(update.baseline, baseline);
  }

  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode,
    overlap
  }, userEncode);
}

function axisTitle (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        sign = getSign(orient, -1, 1);

  let enter, update;
  const encode = {
    enter: enter = {
      opacity: zero,
      anchor: encoder(_('titleAnchor', null)),
      align: {
        signal: alignExpr$1
      }
    },
    update: update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero
    }
  };
  const titlePos = {
    signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
  };
  update.x = ifX(orient, titlePos);
  update.y = ifY(orient, titlePos);
  enter.angle = ifX(orient, zero, mult(sign, 90));
  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {
    value: Bottom
  });
  update.angle = enter.angle;
  update.baseline = enter.baseline;
  addEncoders(encode, {
    fill: _('titleColor'),
    fillOpacity: _('titleOpacity'),
    font: _('titleFont'),
    fontSize: _('titleFontSize'),
    fontStyle: _('titleFontStyle'),
    fontWeight: _('titleFontWeight'),
    limit: _('titleLimit'),
    lineHeight: _('titleLineHeight')
  }, {
    // require update
    align: _('titleAlign'),
    angle: _('titleAngle'),
    baseline: _('titleBaseline')
  });
  autoLayout(_, orient, encode, userEncode);
  encode.update.align = patch(encode.update.align, enter.align);
  encode.update.angle = patch(encode.update.angle, enter.angle);
  encode.update.baseline = patch(encode.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function autoLayout(_, orient, encode, userEncode) {
  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;

  const autoY = auto(_('titleX'), 'x'),
        autoX = auto(_('titleY'), 'y');
  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));
}

function parseAxis (spec, scope) {
  const config = axisConfig(spec, scope),
        encode = spec.encode || {},
        axisEncode = encode.axis || {},
        name = axisEncode.name || undefined,
        interactive = axisEncode.interactive,
        style = axisEncode.style,
        _ = lookup(spec, config),
        band = tickBand(_); // single-element data source for axis group


  const datum = {
    scale: spec.scale,
    ticks: !!_('ticks'),
    labels: !!_('labels'),
    grid: !!_('grid'),
    domain: !!_('domain'),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks

  const ticksRef = ref(scope.add(AxisTicks({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  }))); // generate axis marks

  const children = [];
  let size; // include axis gridlines if requested

  if (datum.grid) {
    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));
  } // include axis ticks if requested


  if (datum.ticks) {
    size = _('tickSize');
    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));
  } // include axis labels if requested


  if (datum.labels) {
    size = datum.ticks ? size : 0;
    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));
  } // include axis domain path if requested


  if (datum.domain) {
    children.push(axisDomain(spec, config, encode.domain, dataRef));
  } // include axis title if defined


  if (datum.title) {
    children.push(axisTitle(spec, config, encode.title, dataRef));
  } // parse axis specification


  return parseMark(guideGroup({
    role: AxisRole,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
}

function buildAxisEncode(_, spec) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    offset: _('offset') || 0,
    position: value(spec.position, 0),
    titlePadding: _('titlePadding'),
    minExtent: _('minExtent'),
    maxExtent: _('maxExtent'),
    range: {
      signal: `abs(span(range("${spec.scale}")))`
    },
    translate: _('translate'),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode;
}

function parseScope (spec, scope, preprocessed) {
  const signals = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.signals),
        scales = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.scales); // parse signal definitions, if not already preprocessed

  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references

  scales.forEach(_ => initScale(_, scope)); // parse data sources

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.data).forEach(_ => parseData(_, scope)); // parse scale definitions

  scales.forEach(_ => parseScale(_, scope)); // parse signal updates

  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined

  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions

  scope.parseLambdas();
  return scope;
}

const rootEncode = spec => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: 'width'
    },
    height: {
      signal: 'height'
    }
  }
}, spec);

function parseView(spec, scope) {
  const config = scope.config; // add scenegraph root

  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions

  const signals = collectSignals(spec, config);
  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration

  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale; // store root group item

  const input = scope.add(Collect()); // encode root group item

  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {
    pulse: ref(input)
  }))); // perform view layout

  const parent = scope.add(ViewLayout({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef('autosize'),
    mark: root,
    pulse: ref(encode)
  }));
  scope.operators.pop(); // parse remainder of specification

  scope.pushState(ref(encode), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent); // bound / render / sieve root item

  let op = scope.add(Bound({
    mark: root,
    pulse: ref(parent)
  }));
  op = scope.add(Render({
    pulse: ref(op)
  }));
  op = scope.add(Sieve({
    pulse: ref(op)
  })); // track metadata for root item

  scope.addData('root', new DataScope(scope, input, input, op));
  return scope;
}

function signalObject(name, value) {
  return value && value.signal ? {
    name,
    update: value.signal
  } : {
    name,
    value
  };
}
/**
 * Collect top-level signals, merging values as needed. Signals
 * defined in the config signals arrays are added only if that
 * signal is not explicitly defined in the specification.
 * Built-in signals (autosize, background, padding, width, height)
 * receive special treatment. They are initialized using the
 * top-level spec property, or, if undefined in the spec, using
 * the corresponding top-level config property. If this property
 * is a signal reference object, the signal expression maps to the
 * signal 'update' property. If the spec's top-level signal array
 * contains an entry that matches a built-in signal, that entry
 * will be merged with the built-in specification, potentially
 * overwriting existing 'value' or 'update' properties.
 */


function collectSignals(spec, config) {
  const _ = name => value(spec[name], config[name]),
        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],
        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),
        map = {}; // add spec signal array


  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.signals).forEach(s => {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(pre, s.name)) {
      // merge if built-in signal
      s = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(pre[s.name], s);
    } else {
      // otherwise add to signal list
      signals.push(s);
    }

    map[s.name] = s;
  }); // add config signal array

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(config.signals).forEach(s => {
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(map, s.name) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(pre, s.name)) {
      // add to signal list if not already defined
      signals.push(s);
    }
  });
  return signals;
}

function Scope(config, options) {
  this.config = config || {};
  this.options = options || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}

function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}

Scope.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },

  fork() {
    return new Subscope(this);
  },

  isSubscope() {
    return this._subid > 0;
  },

  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },

  id() {
    return (this._subid ? this._subid + ':' : 0) + this._id++;
  },

  add(op) {
    this.operators.push(op);
    op.id = this.id(); // if pre-registration references exist, resolve them now

    if (op.refs) {
      op.refs.forEach(ref => {
        ref.$ref = op.id;
      });
      op.refs = null;
    }

    return op;
  },

  proxy(op) {
    const vref = op instanceof Entry ? ref(op) : op;
    return this.add(Proxy({
      value: vref
    }));
  },

  addStream(stream) {
    this.streams.push(stream);
    stream.id = this.id();
    return stream;
  },

  addUpdate(update) {
    this.updates.push(update);
    return update;
  },

  // Apply metadata
  finish() {
    let name, ds; // annotate root

    if (this.root) this.root.root = true; // annotate signals

    for (name in this.signals) {
      this.signals[name].signal = name;
    } // annotate scales


    for (name in this.scales) {
      this.scales[name].scale = name;
    } // annotate data sets


    function annotate(op, name, type) {
      let data, list;

      if (op) {
        data = op.data || (op.data = {});
        list = data[name] || (data[name] = []);
        list.push(type);
      }
    }

    for (name in this.data) {
      ds = this.data[name];
      annotate(ds.input, name, 'input');
      annotate(ds.output, name, 'output');
      annotate(ds.values, name, 'values');

      for (const field in ds.index) {
        annotate(ds.index[field], name, 'index:' + field);
      }
    }

    return this;
  },

  // ----
  pushState(encode, parent, lookup) {
    this._encode.push(ref(this.add(Sieve({
      pulse: encode
    }))));

    this._parent.push(parent);

    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);

    this._markpath.push(-1);
  },

  popState() {
    this._encode.pop();

    this._parent.pop();

    this._lookup.pop();

    this._markpath.pop();
  },

  parent() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._parent);
  },

  encode() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._encode);
  },

  lookup() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._lookup);
  },

  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },

  // ----
  fieldRef(field, name) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field)) return fieldRef$1(field, name);

    if (!field.signal) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported field reference: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(field));
    }

    const s = field.signal;
    let f = this.field[s];

    if (!f) {
      const params = {
        name: this.signalRef(s)
      };
      if (name) params.as = name;
      this.field[s] = f = ref(this.add(Field(params)));
    }

    return f;
  },

  compareRef(cmp) {
    let signal = false;

    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;

    const fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(cmp.field).map(check),
          orders = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(cmp.order).map(check);
    return signal ? ref(this.add(Compare({
      fields: fields,
      orders: orders
    }))) : compareRef(fields, orders);
  },

  keyRef(fields, flat) {
    let signal = false;

    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;

    const sig = this.signals;
    fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(fields).map(check);
    return signal ? ref(this.add(Key({
      fields: fields,
      flat: flat
    }))) : keyRef(fields, flat);
  },

  sortRef(sort) {
    if (!sort) return sort; // including id ensures stable sorting

    const a = aggrField(sort.op, sort.field),
          o = sort.order || Ascending;
    return o.signal ? ref(this.add(Compare({
      fields: a,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a, o);
  },

  // ----
  event(source, type) {
    const key = source + ':' + type;

    if (!this.events[key]) {
      const id = this.id();
      this.streams.push({
        id: id,
        source: source,
        type: type
      });
      this.events[key] = id;
    }

    return this.events[key];
  },

  // ----
  hasOwnSignal(name) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.signals, name);
  },

  addSignal(name, value) {
    if (this.hasOwnSignal(name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    const op = value instanceof Entry ? value : this.add(operator(value));
    return this.signals[name] = op;
  },

  getSignal(name) {
    if (!this.signals[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.signals[name];
  },

  signalRef(s) {
    if (this.signals[s]) {
      return ref(this.signals[s]);
    } else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.lambdas, s)) {
      this.lambdas[s] = this.add(operator(null));
    }

    return ref(this.lambdas[s]);
  },

  parseLambdas() {
    const code = Object.keys(this.lambdas);

    for (let i = 0, n = code.length; i < n; ++i) {
      const s = code[i],
            e = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(s, this),
            op = this.lambdas[s];
      op.params = e.$params;
      op.update = e.$expr;
    }
  },

  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },

  objectProperty(spec) {
    return !spec || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },

  exprRef(code, name) {
    const params = {
      expr: (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(code, this)
    };
    if (name) params.expr.$name = name;
    return ref(this.add(Expression(params)));
  },

  addBinding(name, bind) {
    if (!this.bindings) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Nested signals do not support binding: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    this.bindings.push((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      signal: name
    }, bind));
  },

  // ----
  addScaleProj(name, transform) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.scales, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate scale or projection name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    this.scales[name] = this.add(transform);
  },

  addScale(name, params) {
    this.addScaleProj(name, Scale(params));
  },

  addProjection(name, params) {
    this.addScaleProj(name, Projection(params));
  },

  getScale(name) {
    if (!this.scales[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.scales[name];
  },

  scaleRef(name) {
    return ref(this.getScale(name));
  },

  scaleType(name) {
    return this.getScale(name).params.type;
  },

  projectionRef(name) {
    return this.scaleRef(name);
  },

  projectionType(name) {
    return this.scaleType(name);
  },

  // ----
  addData(name, dataScope) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.data, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.data[name] = dataScope;
  },

  getData(name) {
    if (!this.data[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Undefined data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.data[name];
  },

  addDataPipeline(name, entries) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.data, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.addData(name, DataScope.fromEntries(this, entries));
  }

};

function propertyLambda(spec) {
  return ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(spec) ? arrayLambda : objectLambda)(spec);
}

function arrayLambda(array) {
  const n = array.length;
  let code = '[';

  for (let i = 0; i < n; ++i) {
    const value = array[i];
    code += (i > 0 ? ',' : '') + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? value.signal || propertyLambda(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
  }

  return code + ']';
}

function objectLambda(obj) {
  let code = '{',
      i = 0,
      key,
      value;

  for (key in obj) {
    value = obj[key];
    code += (++i > 1 ? ',' : '') + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(key) + ':' + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? value.signal || propertyLambda(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
  }

  return code + '}';
}

/**
 * Standard configuration defaults for Vega specification parsing.
 * Users can provide their own (sub-)set of these default values
 * by passing in a config object to the top-level parse method.
 */
function defaults () {
  const defaultFont = 'sans-serif',
        defaultSymbolSize = 30,
        defaultStrokeWidth = 2,
        defaultColor = '#4c78a8',
        black = '#000',
        gray = '#888',
        lightGray = '#ddd';
  return {
    // default visualization description
    description: 'Vega visualization',
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: 'pad',
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ['wheel']
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    // style definitions
    style: {
      // axis & legend labels
      'guide-label': {
        fill: black,
        font: defaultFont,
        fontSize: 10
      },
      // axis & legend titles
      'guide-title': {
        fill: black,
        font: defaultFont,
        fontSize: 11,
        fontWeight: 'bold'
      },
      // headers, including chart title
      'group-title': {
        fill: black,
        font: defaultFont,
        fontSize: 13,
        fontWeight: 'bold'
      },
      // chart subtitle
      'group-subtitle': {
        fill: black,
        font: defaultFont,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: 'circle'
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: 'square'
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: 'transparent',
        stroke: lightGray
      }
    },
    // defaults for title
    title: {
      orient: 'top',
      anchor: 'middle',
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: 'mercator'
    },
    // defaults for legends
    legend: {
      orient: 'right',
      padding: 0,
      gridAlign: 'each',
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: 'vertical',
      gradientDirection: 'vertical',
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: 'left',
      labelBaseline: 'middle',
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: 'circle',
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: 'transparent',
      symbolBaseStrokeColor: gray,
      titleLimit: 180,
      titleOrient: 'top',
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: 'horizontal',
        left: {
          direction: 'vertical'
        },
        right: {
          direction: 'vertical'
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: 'tableau10'
      },
      ordinal: {
        scheme: 'blues'
      },
      heatmap: {
        scheme: 'yellowgreenblue'
      },
      ramp: {
        scheme: 'blues'
      },
      diverging: {
        scheme: 'blueorange',
        extent: [1, 0]
      },
      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']
    }
  };
}

function parse (spec, config, options) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Input Vega specification must be an object.');
  }

  config = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.mergeConfig)(defaults(), config, spec.config);
  return parseView(spec, new Scope(config, options)).toRuntime();
}




/***/ }),

/***/ "../../node_modules/vega-projection/build/vega-projection.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-projection/build/vega-projection.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getProjectionPath": () => (/* binding */ getProjectionPath),
/* harmony export */   "projection": () => (/* binding */ projection),
/* harmony export */   "projectionProperties": () => (/* binding */ projectionProperties)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/path/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/albersUsa.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/conicConformal.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/conicEquidistant.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/equalEarth.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/equirectangular.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/gnomonic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/identity.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/mercator.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/naturalEarth1.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/orthographic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/stereographic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-geo */ "../../node_modules/d3-geo/src/projection/transverseMercator.js");
/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-geo-projection */ "../../node_modules/d3-geo-projection/src/mollweide.js");



const defaultPath = (0,d3_geo__WEBPACK_IMPORTED_MODULE_0__.default)();
const projectionProperties = [// standard properties in d3-geo
'clipAngle', 'clipExtent', 'scale', 'translate', 'center', 'rotate', 'parallels', 'precision', 'reflectX', 'reflectY', // extended properties in d3-geo-projections
'coefficient', 'distance', 'fraction', 'lobes', 'parallel', 'radius', 'ratio', 'spacing', 'tilt'];
/**
 * Augment projections with their type and a copy method.
 */

function create(type, constructor) {
  return function projection() {
    const p = constructor();
    p.type = type;
    p.path = (0,d3_geo__WEBPACK_IMPORTED_MODULE_0__.default)().projection(p);

    p.copy = p.copy || function () {
      const c = projection();
      projectionProperties.forEach(prop => {
        if (p[prop]) c[prop](p[prop]());
      });
      c.path.pointRadius(p.path.pointRadius());
      return c;
    };

    return p;
  };
}

function projection(type, proj) {
  if (!type || typeof type !== 'string') {
    throw new Error('Projection type must be a name string.');
  }

  type = type.toLowerCase();

  if (arguments.length > 1) {
    projections[type] = create(type, proj);
    return this;
  } else {
    return projections[type] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
const projections = {
  // base d3-geo projection types
  albers: d3_geo__WEBPACK_IMPORTED_MODULE_1__.default,
  albersusa: d3_geo__WEBPACK_IMPORTED_MODULE_2__.default,
  azimuthalequalarea: d3_geo__WEBPACK_IMPORTED_MODULE_3__.default,
  azimuthalequidistant: d3_geo__WEBPACK_IMPORTED_MODULE_4__.default,
  conicconformal: d3_geo__WEBPACK_IMPORTED_MODULE_5__.default,
  conicequalarea: d3_geo__WEBPACK_IMPORTED_MODULE_6__.default,
  conicequidistant: d3_geo__WEBPACK_IMPORTED_MODULE_7__.default,
  equalEarth: d3_geo__WEBPACK_IMPORTED_MODULE_8__.default,
  equirectangular: d3_geo__WEBPACK_IMPORTED_MODULE_9__.default,
  gnomonic: d3_geo__WEBPACK_IMPORTED_MODULE_10__.default,
  identity: d3_geo__WEBPACK_IMPORTED_MODULE_11__.default,
  mercator: d3_geo__WEBPACK_IMPORTED_MODULE_12__.default,
  mollweide: d3_geo_projection__WEBPACK_IMPORTED_MODULE_13__.default,
  naturalEarth1: d3_geo__WEBPACK_IMPORTED_MODULE_14__.default,
  orthographic: d3_geo__WEBPACK_IMPORTED_MODULE_15__.default,
  stereographic: d3_geo__WEBPACK_IMPORTED_MODULE_16__.default,
  transversemercator: d3_geo__WEBPACK_IMPORTED_MODULE_17__.default
};

for (const key in projections) {
  projection(key, projections[key]);
}




/***/ }),

/***/ "../../node_modules/vega-regression/build/vega-regression.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-regression/build/vega-regression.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loess": () => (/* binding */ Loess),
/* harmony export */   "regression": () => (/* binding */ Regression)
/* harmony export */ });
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");




function partition (data, groupby) {
  var groups = [],
      get = function (f) {
    return f(t);
  },
      map,
      i,
      n,
      t,
      k,
      g; // partition data points into stack groups


  if (groupby == null) {
    groups.push(data);
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }

      g.push(t);
    }
  }

  return groups;
}

/**
 * Compute locally-weighted regression fits for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.x - An accessor for the predictor data field.
 * @param {function(object): *} params.y - An accessor for the predicted data field.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {number} [params.bandwidth=0.3] - The loess bandwidth.
 */

function Loess(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Loess.Definition = {
  'type': 'Loess',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0.3
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Loess, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
            groups = partition(source, _.groupby),
            names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName),
            m = names.length,
            as = _.as || [(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.x), (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.y)],
            values = [];
      groups.forEach(g => {
        (0,vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLoess)(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {
          const t = {};

          for (let i = 0; i < m; ++i) {
            t[names[i]] = g.dims[i];
          }

          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});

const Methods = {
  linear: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLinear,
  log: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLog,
  exp: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionExp,
  pow: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionPow,
  quad: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionQuad,
  poly: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionPoly
};

const degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;
/**
 * Compute regression fits for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.x - An accessor for the predictor data field.
 * @param {function(object): *} params.y - An accessor for the predicted data field.
 * @param {string} [params.method='linear'] - The regression method to apply.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.
 * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.
 */


function Regression(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Regression.Definition = {
  'type': 'Regression',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'method',
    'type': 'string',
    'default': 'linear',
    'values': Object.keys(Methods)
  }, {
    'name': 'order',
    'type': 'number',
    'default': 3
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'params',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Regression, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
            groups = partition(source, _.groupby),
            names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName),
            method = _.method || 'linear',
            order = _.order || 3,
            dof = degreesOfFreedom(method, order),
            as = _.as || [(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.x), (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.y)],
            fit = Methods[method],
            values = [];
      let domain = _.extent;

      if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.hasOwnProperty)(Methods, method)) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Invalid regression method: ' + method);
      }

      if (domain != null) {
        if (method === 'log' && domain[0] <= 0) {
          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');
          domain = null;
        }
      }

      groups.forEach(g => {
        const n = g.length;

        if (n <= dof) {
          pulse.dataflow.warn('Skipping regression with more parameters than data points.');
          return;
        }

        const model = fit(g, _.x, _.y, order);

        if (_.params) {
          // if parameter vectors requested return those
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }

        const dom = domain || (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.extent)(g, _.x),
              add = p => {
          const t = {};

          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }

          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        };

        if (method === 'linear') {
          // for linear regression we only need the end points
          dom.forEach(x => add([x, model.predict(x)]));
        } else {
          // otherwise return trend line sample points
          (0,vega_statistics__WEBPACK_IMPORTED_MODULE_0__.sampleCurve)(model.predict, dom, 25, 200).forEach(add);
        }
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});




/***/ }),

/***/ "../../node_modules/vega-runtime/build/vega-runtime.module.js":
/*!********************************************************************!*\
  !*** ../../node_modules/vega-runtime/build/vega-runtime.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "context": () => (/* binding */ context)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");



/**
 * Parse a serialized dataflow specification.
 */
function parse (spec) {
  const ctx = this,
        operators = spec.operators || []; // parse background

  if (spec.background) {
    ctx.background = spec.background;
  } // parse event configuration


  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  } // parse locale configuration


  if (spec.locale) {
    ctx.locale = spec.locale;
  } // parse operators


  operators.forEach(entry => ctx.parseOperator(entry)); // parse operator parameters

  operators.forEach(entry => ctx.parseOperatorParameters(entry)); // parse streams

  (spec.streams || []).forEach(entry => ctx.parseStream(entry)); // parse updates

  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));
  return ctx.resolve();
}

const Skip = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['rule']),
      Swap = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['group', 'image', 'rect']);
function adjustSpatial(encode, marktype) {
  let code = '';
  if (Skip[marktype]) return code;

  if (encode.x2) {
    if (encode.x) {
      if (Swap[marktype]) {
        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';
      }

      code += 'o.width=o.x2-o.x;';
    } else {
      code += 'o.x=o.x2-(o.width||0);';
    }
  }

  if (encode.xc) {
    code += 'o.x=o.xc-(o.width||0)/2;';
  }

  if (encode.y2) {
    if (encode.y) {
      if (Swap[marktype]) {
        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';
      }

      code += 'o.height=o.y2-o.y;';
    } else {
      code += 'o.y=o.y2-(o.height||0);';
    }
  }

  if (encode.yc) {
    code += 'o.y=o.yc-(o.height||0)/2;';
  }

  return code;
}
function canonicalType(type) {
  return (type + '').toLowerCase();
}
function isOperator(type) {
  return canonicalType(type) === 'operator';
}
function isCollect(type) {
  return canonicalType(type) === 'collect';
}

function expression(ctx, args, code) {
  // wrap code in return statement if expression does not terminate
  if (code[code.length - 1] !== ';') {
    code = 'return(' + code + ');';
  }

  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
} // generate code for comparing a single field


function _compare(u, v, lt, gt) {
  return "((u = ".concat(u, ") < (v = ").concat(v, ") || u == null) && v != null ? ").concat(lt, "\n  : (u > v || v == null) && u != null ? ").concat(gt, "\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ").concat(lt, "\n  : v !== v && u === u ? ").concat(gt, " : ");
}

var expressionCodegen = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),

  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),

  /**
   * Parse an expression applied to an event stream.
   */
  event: (ctx, expr) => expression(ctx, ['event'], expr.code),

  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (ctx, expr) => {
    const code = "var datum=event.item&&event.item.datum;return ".concat(expr.code, ";");
    return expression(ctx, ['_', 'event'], code);
  },

  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (ctx, encode) => {
    const {
      marktype,
      channels
    } = encode;
    let code = 'var o=item,datum=o.datum,m=0,$;';

    for (const name in channels) {
      const o = 'o[' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name) + ']';
      code += "$=".concat(channels[name].code, ";if(").concat(o, "!==$)").concat(o, "=$,m=1;");
    }

    code += adjustSpatial(channels, marktype);
    code += 'return m;';
    return expression(ctx, ['item', '_'], code);
  },

  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(path) {
      const ref = "[".concat(path.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join(']['), "]");
      const get = Function('_', "return _".concat(ref, ";"));
      get.path = ref;
      return get;
    },

    comparator(fields, orders) {
      let t;

      const map = (f, i) => {
        const o = orders[i];
        let u, v;

        if (f.path) {
          u = "a".concat(f.path);
          v = "b".concat(f.path);
        } else {
          (t = t || {})['f' + i] = f;
          u = "this.f".concat(i, "(a)");
          v = "this.f".concat(i, "(b)");
        }

        return _compare(u, v, -o, o);
      };

      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');
      return t ? fn.bind(t) : fn;
    }

  }
};

/**
 * Parse a dataflow operator.
 */

function parseOperator(spec) {
  const ctx = this;

  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
/**
 * Parse and assign operator parameters.
 */

function parseOperatorParameters(spec) {
  const ctx = this;

  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid operator id: ' + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}

/**
 * Parse a set of operator parameters.
 */

function parseParameters(spec, params) {
  params = params || {};
  const ctx = this;

  for (const key in spec) {
    const value = spec[key];
    params[key] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);
  }

  return params;
}
/**
 * Parse a single parameter.
 */

function parseParameter(spec, ctx, params) {
  if (!spec || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec)) return spec;

  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(spec, p.key)) {
      return p.parse(spec, ctx, params);
    }
  }

  return spec;
}
/** Reference parsers. */


var PARSERS = [{
  key: '$ref',
  parse: getOperator
}, {
  key: '$key',
  parse: getKey
}, {
  key: '$expr',
  parse: getExpression
}, {
  key: '$field',
  parse: getField
}, {
  key: '$encode',
  parse: getEncode
}, {
  key: '$compare',
  parse: getCompare
}, {
  key: '$context',
  parse: getContext
}, {
  key: '$subflow',
  parse: getSubflow
}, {
  key: '$tupleid',
  parse: getTupleId
}];
/**
 * Resolve an operator reference.
 */

function getOperator(_, ctx) {
  return ctx.get(_.$ref) || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Operator not defined: ' + _.$ref);
}
/**
 * Resolve an expression reference.
 */


function getExpression(_, ctx, params) {
  if (_.$params) {
    // parse expression parameters
    ctx.parseParameters(_.$params, params);
  }

  const k = 'e:' + _.$expr.code + '_' + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(ctx.parameterExpression(_.$expr), _.$fields, _.$name));
}
/**
 * Resolve a key accessor reference.
 */


function getKey(_, ctx) {
  const k = 'k:' + _.$key + '_' + !!_.$flat;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.key)(_.$key, _.$flat, ctx.expr.codegen));
}
/**
 * Resolve a field accessor reference.
 */


function getField(_, ctx) {
  if (!_.$field) return null;
  const k = 'f:' + _.$field + '_' + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(_.$field, _.$name, ctx.expr.codegen));
}
/**
 * Resolve a comparator function reference.
 */


function getCompare(_, ctx) {
  // As of Vega 5.5.3, $tupleid sort is no longer used.
  // Keep here for now for backwards compatibility.
  const k = 'c:' + _.$compare + '_' + _.$order,
        c = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.$compare).map(_ => _ && _.$tupleid ? vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid : _);
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.compare)(c, _.$order, ctx.expr.codegen));
}
/**
 * Resolve an encode operator reference.
 */


function getEncode(_, ctx) {
  const spec = _.$encode,
        encode = {};

  for (const name in spec) {
    const enc = spec[name];
    encode[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode[name].output = enc.$output;
  }

  return encode;
}
/**
 * Resolve a context reference.
 */


function getContext(_, ctx) {
  return ctx;
}
/**
 * Resolve a recursive subflow specification.
 */


function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function (dataflow, key, parent) {
    const subctx = ctx.fork().parse(spec),
          op = subctx.get(spec.operators[0].id),
          p = subctx.signals.parent;
    if (p) p.set(parent);

    op.detachSubflow = () => ctx.detach(subctx);

    return op;
  };
}
/**
 * Resolve a tuple id reference.
 */


function getTupleId() {
  return vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid;
}

/**
 * Parse an event stream specification.
 */

function parseStream (spec) {
  var ctx = this,
      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,
      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,
      args;

  if (spec.source) {
    stream = ctx.events(spec.source, spec.type, filter);
  } else if (spec.merge) {
    args = spec.merge.map(_ => ctx.get(_));
    stream = args[0].merge.apply(args[0], args.slice(1));
  }

  if (spec.between) {
    args = spec.between.map(_ => ctx.get(_));
    stream = stream.between(args[0], args[1]);
  }

  if (spec.filter) {
    stream = stream.filter(filter);
  }

  if (spec.throttle != null) {
    stream = stream.throttle(+spec.throttle);
  }

  if (spec.debounce != null) {
    stream = stream.debounce(+spec.debounce);
  }

  if (stream == null) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid stream definition: ' + JSON.stringify(spec));
  }

  if (spec.consume) stream.consume(true);
  ctx.stream(spec, stream);
}

/**
 * Parse an event-driven operator update.
 */

function parseUpdate (spec) {
  var ctx = this,
      srcid = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(srcid = spec.source) ? srcid.$ref : srcid,
      source = ctx.get(srcid),
      target = null,
      update = spec.update,
      params = undefined;
  if (!source) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Source not defined: ' + spec.source);
  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);

  if (update && update.$expr) {
    if (update.$params) {
      params = ctx.parseParameters(update.$params);
    }

    update = ctx.handlerExpression(update.$expr);
  }

  ctx.update(spec, source, target, update, params);
}

const SKIP = {
  skip: true
};
function getState(options) {
  var ctx = this,
      state = {};

  if (options.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach(key => {
      const op = ctx.signals[key];

      if (options.signals(key, op)) {
        signals[key] = op.value;
      }
    });
  }

  if (options.data) {
    var data = state.data = {};
    Object.keys(ctx.data).forEach(key => {
      const dataset = ctx.data[key];

      if (options.data(key, dataset)) {
        data[key] = dataset.input.value;
      }
    });
  }

  if (ctx.subcontext && options.recurse !== false) {
    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));
  }

  return state;
}
function setState(state) {
  var ctx = this,
      df = ctx.dataflow,
      data = state.data,
      signals = state.signals;
  Object.keys(signals || {}).forEach(key => {
    df.update(ctx.signals[key], signals[key], SKIP);
  });
  Object.keys(data || {}).forEach(key => {
    df.pulse(ctx.data[key].input, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(data[key]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx) subctx.setState(substate);
  });
}

/**
 * Context objects store the current parse state.
 * Enables lookup of parsed operators, event streams, accessors, etc.
 * Provides a 'fork' method for creating child contexts for subflows.
 */

function context (df, transforms, functions, expr) {
  return new Context(df, transforms, functions, expr);
}

function Context(df, transforms, functions, expr) {
  this.dataflow = df;
  this.transforms = transforms;
  this.events = df.events.bind(df);
  this.expr = expr || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};

  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}

function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);

  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}

Context.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },

  detach(ctx) {
    this.subcontext = this.subcontext.filter(c => c !== ctx); // disconnect all nodes in the subcontext
    // wipe out targets first for better efficiency

    const keys = Object.keys(ctx.nodes);

    for (const key of keys) ctx.nodes[key]._targets = null;

    for (const key of keys) ctx.nodes[key].detach();

    ctx.nodes = null;
  },

  get(id) {
    return this.nodes[id];
  },

  set(id, node) {
    return this.nodes[id] = node;
  },

  add(spec, op) {
    const ctx = this,
          df = ctx.dataflow,
          data = spec.value;
    ctx.set(spec.id, op);

    if (isCollect(spec.type) && data) {
      if (data.$ingest) {
        df.ingest(op, data.$ingest, data.$format);
      } else if (data.$request) {
        df.preload(op, data.$request, data.$format);
      } else {
        df.pulse(op, df.changeset().insert(data));
      }
    }

    if (spec.root) {
      ctx.root = op;
    }

    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);

      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }

    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }

    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }

    if (spec.data) {
      for (const name in spec.data) {
        const data = ctx.data[name] || (ctx.data[name] = {});
        spec.data[name].forEach(role => data[role] = op);
      }
    }
  },

  resolve() {
    (this.unresolved || []).forEach(fn => fn());
    delete this.unresolved;
    return this;
  },

  operator(spec, update) {
    this.add(spec, this.dataflow.add(spec.value, update));
  },

  transform(spec, type) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));
  },

  stream(spec, stream) {
    this.set(spec.id, stream);
  },

  update(spec, stream, target, update, params) {
    this.dataflow.on(stream, target, update, params, spec.options);
  },

  // expression parsing
  operatorExpression(expr) {
    return this.expr.operator(this, expr);
  },

  parameterExpression(expr) {
    return this.expr.parameter(this, expr);
  },

  eventExpression(expr) {
    return this.expr.event(this, expr);
  },

  handlerExpression(expr) {
    return this.expr.handler(this, expr);
  },

  encodeExpression(encode) {
    return this.expr.encode(this, encode);
  },

  // parse methods
  parse,
  parseOperator,
  parseOperatorParameters,
  parseParameters,
  parseStream,
  parseUpdate,
  // state methods
  getState,
  setState
};




/***/ }),

/***/ "../../node_modules/vega-scale/build/vega-scale.module.js":
/*!****************************************************************!*\
  !*** ../../node_modules/vega-scale/build/vega-scale.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scaleImplicit": () => (/* reexport safe */ d3_scale__WEBPACK_IMPORTED_MODULE_1__.implicit),
/* harmony export */   "Band": () => (/* binding */ Band),
/* harmony export */   "BinOrdinal": () => (/* binding */ BinOrdinal),
/* harmony export */   "DiscreteLegend": () => (/* binding */ DiscreteLegend),
/* harmony export */   "Diverging": () => (/* binding */ Diverging),
/* harmony export */   "GradientLegend": () => (/* binding */ GradientLegend),
/* harmony export */   "Identity": () => (/* binding */ Identity),
/* harmony export */   "Linear": () => (/* binding */ Linear),
/* harmony export */   "Log": () => (/* binding */ Log),
/* harmony export */   "Ordinal": () => (/* binding */ Ordinal),
/* harmony export */   "Point": () => (/* binding */ Point),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "Quantile": () => (/* binding */ Quantile),
/* harmony export */   "Quantize": () => (/* binding */ Quantize),
/* harmony export */   "Sequential": () => (/* binding */ Sequential),
/* harmony export */   "Sqrt": () => (/* binding */ Sqrt),
/* harmony export */   "SymbolLegend": () => (/* binding */ SymbolLegend),
/* harmony export */   "Symlog": () => (/* binding */ Symlog),
/* harmony export */   "Threshold": () => (/* binding */ Threshold),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "UTC": () => (/* binding */ UTC),
/* harmony export */   "bandSpace": () => (/* binding */ bandSpace),
/* harmony export */   "domainCaption": () => (/* binding */ domainCaption),
/* harmony export */   "interpolate": () => (/* binding */ interpolate),
/* harmony export */   "interpolateColors": () => (/* binding */ interpolateColors),
/* harmony export */   "interpolateRange": () => (/* binding */ interpolateRange),
/* harmony export */   "isContinuous": () => (/* binding */ isContinuous),
/* harmony export */   "isDiscrete": () => (/* binding */ isDiscrete),
/* harmony export */   "isDiscretizing": () => (/* binding */ isDiscretizing),
/* harmony export */   "isInterpolating": () => (/* binding */ isInterpolating),
/* harmony export */   "isLogarithmic": () => (/* binding */ isLogarithmic),
/* harmony export */   "isQuantile": () => (/* binding */ isQuantile),
/* harmony export */   "isTemporal": () => (/* binding */ isTemporal),
/* harmony export */   "isValidScaleType": () => (/* binding */ isValidScaleType),
/* harmony export */   "labelFormat": () => (/* binding */ labelFormat),
/* harmony export */   "labelFraction": () => (/* binding */ labelFraction),
/* harmony export */   "labelValues": () => (/* binding */ labelValues),
/* harmony export */   "quantizeInterpolator": () => (/* binding */ quantizeInterpolator),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleCopy": () => (/* binding */ scaleCopy),
/* harmony export */   "scaleFraction": () => (/* binding */ scaleFraction),
/* harmony export */   "scheme": () => (/* binding */ scheme),
/* harmony export */   "tickCount": () => (/* binding */ tickCount),
/* harmony export */   "tickFormat": () => (/* binding */ tickFormat),
/* harmony export */   "tickValues": () => (/* binding */ tickValues),
/* harmony export */   "validTicks": () => (/* binding */ validTicks)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/ordinal.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/tickFormat.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/identity.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/log.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/symlog.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/time.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/utcTime.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/sequential.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/diverging.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-scale */ "../../node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-interpolate */ "../../node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");








function bandSpace (count, paddingInner, paddingOuter) {
  const space = count - paddingInner + paddingOuter * 2;
  return count ? space > 0 ? space : 1 : 0;
}

const Identity = 'identity';
const Linear = 'linear';
const Log = 'log';
const Pow = 'pow';
const Sqrt = 'sqrt';
const Symlog = 'symlog';
const Time = 'time';
const UTC = 'utc';
const Sequential = 'sequential';
const Diverging = 'diverging';
const Quantile = 'quantile';
const Quantize = 'quantize';
const Threshold = 'threshold';
const Ordinal = 'ordinal';
const Point = 'point';
const Band = 'band';
const BinOrdinal = 'bin-ordinal'; // categories

const Continuous = 'continuous';
const Discrete = 'discrete';
const Discretizing = 'discretizing';
const Interpolating = 'interpolating';
const Temporal = 'temporal';

function invertRange (scale) {
  return function (_) {
    let lo = _[0],
        hi = _[1],
        t;

    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }

    return [scale.invert(lo), scale.invert(hi)];
  };
}

function invertRangeExtent (scale) {
  return function (_) {
    const range = scale.range();
    let lo = _[0],
        hi = _[1],
        min = -1,
        max,
        t,
        i,
        n;

    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }

    for (i = 0, n = range.length; i < n; ++i) {
      if (range[i] >= lo && range[i] <= hi) {
        if (min < 0) min = i;
        max = i;
      }
    }

    if (min < 0) return undefined;
    lo = scale.invertExtent(range[min]);
    hi = scale.invertExtent(range[max]);
    return [lo[0] === undefined ? lo[1] : lo[0], hi[1] === undefined ? hi[0] : hi[1]];
  };
}

function band() {
  const scale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__.default)().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range;
  let range$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;
  delete scale.unknown;

  function rescale() {
    const n = domain().length,
          reverse = range$1[1] < range$1[0],
          stop = range$1[1 - reverse],
          space = bandSpace(n, paddingInner, paddingOuter);
    let start = range$1[reverse - 0];
    step = (stop - start) / (space || 1);

    if (round) {
      step = Math.floor(step);
    }

    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);

    if (round) {
      start = Math.round(start);
      bandwidth = Math.round(bandwidth);
    }

    const values = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(n).map(i => start + step * i);
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function (_) {
    if (arguments.length) {
      domain(_);
      return rescale();
    } else {
      return domain();
    }
  };

  scale.range = function (_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };

  scale.rangeRound = function (_) {
    range$1 = [+_[0], +_[1]];
    round = true;
    return rescale();
  };

  scale.bandwidth = function () {
    return bandwidth;
  };

  scale.step = function () {
    return step;
  };

  scale.round = function (_) {
    if (arguments.length) {
      round = !!_;
      return rescale();
    } else {
      return round;
    }
  };

  scale.padding = function (_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      paddingInner = paddingOuter;
      return rescale();
    } else {
      return paddingInner;
    }
  };

  scale.paddingInner = function (_) {
    if (arguments.length) {
      paddingInner = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner;
    }
  };

  scale.paddingOuter = function (_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter;
    }
  };

  scale.align = function (_) {
    if (arguments.length) {
      align = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align;
    }
  };

  scale.invertRange = function (_) {
    // bail if range has null or undefined values
    if (_[0] == null || _[1] == null) return;
    const reverse = range$1[1] < range$1[0],
          values = reverse ? ordinalRange().reverse() : ordinalRange(),
          n = values.length - 1;
    let lo = +_[0],
        hi = +_[1],
        a,
        b,
        t; // bail if either range endpoint is invalid

    if (lo !== lo || hi !== hi) return; // order range inputs, bail if outside of scale range

    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }

    if (hi < values[0] || lo > range$1[1 - reverse]) return; // binary search to index into scale range

    a = Math.max(0, (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.bisectRight)(values, lo) - 1);
    b = lo === hi ? a : (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.bisectRight)(values, hi) - 1; // increment index a if lo is within padding gap

    if (lo - values[a] > bandwidth + 1e-10) ++a;

    if (reverse) {
      // map + swap
      t = a;
      a = n - b;
      b = n - t;
    }

    return a > b ? undefined : domain().slice(a, b + 1);
  };

  scale.invert = function (_) {
    const value = scale.invertRange([_, _]);
    return value ? value[0] : value;
  };

  scale.copy = function () {
    return band().domain(domain()).range(range$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };

  return rescale();
}

function pointish(scale) {
  const copy = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;

  scale.copy = function () {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

var map = Array.prototype.map;
function numbers(_) {
  return map.call(_, vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber);
}

const slice = Array.prototype.slice;

function scaleBinOrdinal() {
  let domain = [],
      range = [];

  function scale(x) {
    return x == null || x !== x ? undefined : range[((0,d3_array__WEBPACK_IMPORTED_MODULE_4__.default)(domain, x) - 1) % range.length];
  }

  scale.domain = function (_) {
    if (arguments.length) {
      domain = numbers(_);
      return scale;
    } else {
      return domain.slice();
    }
  };

  scale.range = function (_) {
    if (arguments.length) {
      range = slice.call(_);
      return scale;
    } else {
      return range.slice();
    }
  };

  scale.tickFormat = function (count, specifier) {
    return (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__.default)(domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(domain), count == null ? 10 : count, specifier);
  };

  scale.copy = function () {
    return scaleBinOrdinal().domain(scale.domain()).range(scale.range());
  };

  return scale;
}

const scales = {};
/**
 * Augment scales with their type and needed inverse methods.
 */

function create(type, constructor, metadata) {
  const ctr = function scale() {
    const s = constructor();

    if (!s.invertRange) {
      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : undefined;
    }

    s.type = type;
    return s;
  };

  ctr.metadata = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(metadata));
  return ctr;
}

function scale(type, scale, metadata) {
  if (arguments.length > 1) {
    scales[type] = create(type, scale, metadata);
    return this;
  } else {
    return isValidScaleType(type) ? scales[type] : undefined;
  }
} // identity scale

scale(Identity, d3_scale__WEBPACK_IMPORTED_MODULE_6__.default); // continuous scales

scale(Linear, d3_scale__WEBPACK_IMPORTED_MODULE_7__.default, Continuous);
scale(Log, d3_scale__WEBPACK_IMPORTED_MODULE_8__.default, [Continuous, Log]);
scale(Pow, d3_scale__WEBPACK_IMPORTED_MODULE_9__.default, Continuous);
scale(Sqrt, d3_scale__WEBPACK_IMPORTED_MODULE_9__.sqrt, Continuous);
scale(Symlog, d3_scale__WEBPACK_IMPORTED_MODULE_10__.default, Continuous);
scale(Time, d3_scale__WEBPACK_IMPORTED_MODULE_11__.default, [Continuous, Temporal]);
scale(UTC, d3_scale__WEBPACK_IMPORTED_MODULE_12__.default, [Continuous, Temporal]); // sequential scales

scale(Sequential, d3_scale__WEBPACK_IMPORTED_MODULE_13__.default, [Continuous, Interpolating]); // backwards compat

scale("".concat(Sequential, "-").concat(Linear), d3_scale__WEBPACK_IMPORTED_MODULE_13__.default, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Log), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialLog, [Continuous, Interpolating, Log]);
scale("".concat(Sequential, "-").concat(Pow), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialPow, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Sqrt), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialSqrt, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Symlog), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialSymlog, [Continuous, Interpolating]); // diverging scales

scale("".concat(Diverging, "-").concat(Linear), d3_scale__WEBPACK_IMPORTED_MODULE_14__.default, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Log), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingLog, [Continuous, Interpolating, Log]);
scale("".concat(Diverging, "-").concat(Pow), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingPow, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Sqrt), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingSqrt, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Symlog), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingSymlog, [Continuous, Interpolating]); // discretizing scales

scale(Quantile, d3_scale__WEBPACK_IMPORTED_MODULE_15__.default, [Discretizing, Quantile]);
scale(Quantize, d3_scale__WEBPACK_IMPORTED_MODULE_16__.default, Discretizing);
scale(Threshold, d3_scale__WEBPACK_IMPORTED_MODULE_17__.default, Discretizing); // discrete scales

scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
scale(Ordinal, d3_scale__WEBPACK_IMPORTED_MODULE_1__.default, Discrete);
scale(Band, band, Discrete);
scale(Point, point, Discrete);
function isValidScaleType(type) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(scales, type);
}

function hasType(key, type) {
  const s = scales[key];
  return s && s.metadata[type];
}

function isContinuous(key) {
  return hasType(key, Continuous);
}
function isDiscrete(key) {
  return hasType(key, Discrete);
}
function isDiscretizing(key) {
  return hasType(key, Discretizing);
}
function isLogarithmic(key) {
  return hasType(key, Log);
}
function isTemporal(key) {
  return hasType(key, Temporal);
}
function isInterpolating(key) {
  return hasType(key, Interpolating);
}
function isQuantile(key) {
  return hasType(key, Quantile);
}

const scaleProps = ['clamp', 'base', 'constant', 'exponent'];
function interpolateRange(interpolator, range) {
  const start = range[0],
        span = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(range) - start;
  return function (i) {
    return interpolator(start + i * span);
  };
}
function interpolateColors(colors, type, gamma) {
  return (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_18__.default)(interpolate(type || 'rgb', gamma), colors);
}
function quantizeInterpolator(interpolator, count) {
  const samples = new Array(count),
        n = count + 1;

  for (let i = 0; i < count;) samples[i] = interpolator(++i / n);

  return samples;
}
function scaleCopy(scale) {
  const t = scale.type,
        s = scale.copy();
  s.type = t;
  return s;
}
function scaleFraction(scale$1, min, max) {
  const delta = max - min;
  let i, t, s;

  if (!delta || !Number.isFinite(delta)) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(0.5);
  } else {
    i = (t = scale$1.type).indexOf('-');
    t = i < 0 ? t : t.slice(i + 1);
    s = scale(t)().domain([min, max]).range([0, 1]);
    scaleProps.forEach(m => scale$1[m] ? s[m](scale$1[m]()) : 0);
    return s;
  }
}
function interpolate(type, gamma) {
  const interp = d3_interpolate__WEBPACK_IMPORTED_MODULE_19__[method(type)];
  return gamma != null && interp && interp.gamma ? interp.gamma(gamma) : interp;
}

function method(type) {
  return 'interpolate' + type.toLowerCase().split('-').map(s => s[0].toUpperCase() + s.slice(1)).join('');
}

const continuous = {
  blues: 'cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90',
  greens: 'd3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429',
  greys: 'e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e',
  oranges: 'fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303',
  purples: 'e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c',
  reds: 'fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13',
  blueGreen: 'd5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429',
  bluePurple: 'ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71',
  greenBlue: 'd3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1',
  orangeRed: 'fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403',
  purpleBlue: 'dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281',
  purpleBlueGreen: 'dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353',
  purpleRed: 'dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a',
  redPurple: 'fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174',
  yellowGreen: 'e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034',
  yellowOrangeBrown: 'feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204',
  yellowOrangeRed: 'fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225',
  blueOrange: '134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07',
  brownBlueGreen: '704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147',
  purpleGreen: '5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29',
  purpleOrange: '4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07',
  redBlue: '8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85',
  redGrey: '8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434',
  yellowGreenBlue: 'eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185',
  redYellowBlue: 'a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695',
  redYellowGreen: 'a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837',
  pinkYellowGreen: '8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419',
  spectral: '9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2',
  viridis: '440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725',
  magma: '0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf',
  inferno: '0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4',
  plasma: '0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921',
  cividis: '00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647',
  rainbow: '6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa',
  sinebow: 'ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040',
  turbo: '23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00',
  browns: 'eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632',
  tealBlues: 'bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985',
  teals: 'bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667',
  warmGreys: 'dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e',
  goldGreen: 'f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36',
  goldOrange: 'f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26',
  goldRed: 'f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e',
  lightGreyRed: 'efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b',
  lightGreyTeal: 'e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc',
  lightMulti: 'e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c',
  lightOrange: 'f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b',
  lightTealBlue: 'e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988',
  darkBlue: '3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff',
  darkGold: '3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff',
  darkGreen: '3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa',
  darkMulti: '3737371f5287197d8c29a86995ce3fffe800ffffff',
  darkRed: '3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c'
};
const discrete = {
  category10: '1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf',
  category20: '1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5',
  category20b: '393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6',
  category20c: '3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9',
  tableau10: '4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac',
  tableau20: '4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5',
  accent: '7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666',
  dark2: '1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666',
  paired: 'a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928',
  pastel1: 'fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2',
  pastel2: 'b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc',
  set1: 'e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999',
  set2: '66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3',
  set3: '8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f'
};

function colors(palette) {
  const n = palette.length / 6 | 0,
        c = new Array(n);

  for (let i = 0; i < n;) {
    c[i] = '#' + palette.slice(i * 6, ++i * 6);
  }

  return c;
}

function apply(_, f) {
  for (const k in _) scheme(k, f(_[k]));
}

const schemes = {};
apply(discrete, colors);
apply(continuous, _ => interpolateColors(colors(_)));
function scheme(name, scheme) {
  name = name && name.toLowerCase();

  if (arguments.length > 1) {
    schemes[name] = scheme;
    return this;
  } else {
    return schemes[name];
  }
}

const SymbolLegend = 'symbol';
const DiscreteLegend = 'discrete';
const GradientLegend = 'gradient';

const defaultFormatter = value => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? value.map(v => String(v)) : String(value);

const ascending = (a, b) => a[1] - b[1];

const descending = (a, b) => b[1] - a[1];
/**
 * Determine the tick count or interval function.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {*} count - The desired tick count or interval specifier.
 * @param {number} minStep - The desired minimum step between tick values.
 * @return {*} - The tick count or interval function.
 */


function tickCount(scale, count, minStep) {
  let step;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(count)) {
    if (scale.bins) {
      count = Math.max(count, scale.bins.length);
    }

    if (minStep != null) {
      count = Math.min(count, Math.floor((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)(scale.domain()) / minStep || 1));
    }
  }

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(count)) {
    step = count.step;
    count = count.interval;
  }

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(count)) {
    count = scale.type === Time ? (0,vega_time__WEBPACK_IMPORTED_MODULE_2__.timeInterval)(count) : scale.type == UTC ? (0,vega_time__WEBPACK_IMPORTED_MODULE_2__.utcInterval)(count) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Only time and utc scales accept interval strings.');
    if (step) count = count.every(step);
  }

  return count;
}
/**
 * Filter a set of candidate tick values, ensuring that only tick values
 * that lie within the scale range are included.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {Array<*>} ticks - The candidate tick values.
 * @param {*} count - The tick count or interval function.
 * @return {Array<*>} - The filtered tick values.
 */

function validTicks(scale, ticks, count) {
  let range = scale.range(),
      lo = range[0],
      hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(range),
      cmp = ascending;

  if (lo > hi) {
    range = hi;
    hi = lo;
    lo = range;
    cmp = descending;
  }

  lo = Math.floor(lo);
  hi = Math.ceil(hi); // filter ticks to valid values within the range
  // additionally sort ticks in range order (#2579)

  ticks = ticks.map(v => [v, scale(v)]).filter(_ => lo <= _[1] && _[1] <= hi).sort(cmp).map(_ => _[0]);

  if (count > 0 && ticks.length > 1) {
    const endpoints = [ticks[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(ticks)];

    while (ticks.length > count && ticks.length >= 3) {
      ticks = ticks.filter((_, i) => !(i % 2));
    }

    if (ticks.length < 3) {
      ticks = endpoints;
    }
  }

  return ticks;
}
/**
 * Generate tick values for the given scale and approximate tick count or
 * interval value. If the scale has a 'ticks' method, it will be used to
 * generate the ticks, with the count argument passed as a parameter. If the
 * scale lacks a 'ticks' method, the full scale domain will be returned.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {*} [count] - The approximate number of desired ticks.
 * @return {Array<*>} - The generated tick values.
 */

function tickValues(scale, count) {
  return scale.bins ? validTicks(scale, scale.bins) : scale.ticks ? scale.ticks(count) : scale.domain();
}
/**
 * Generate a label format function for a scale. If the scale has a
 * 'tickFormat' method, it will be used to generate the formatter, with the
 * count and specifier arguments passed as parameters. If the scale lacks a
 * 'tickFormat' method, the returned formatter performs simple string coercion.
 * If the input scale is a logarithmic scale and the format specifier does not
 * indicate a desired decimal precision, a special variable precision formatter
 * that automatically trims trailing zeroes will be generated.
 * @param {Scale} scale - The scale for which to generate the label formatter.
 * @param {*} [count] - The approximate number of desired ticks.
 * @param {string} [specifier] - The format specifier. Must be a legal d3
 *   specifier string (see https://github.com/d3/d3-format#formatSpecifier) or
 *   time multi-format specifier object.
 * @return {function(*):string} - The generated label formatter.
 */

function tickFormat(locale, scale, count, specifier, formatType, noSkip) {
  const type = scale.type;
  let format = defaultFormatter;

  if (type === Time || formatType === Time) {
    format = locale.timeFormat(specifier);
  } else if (type === UTC || formatType === UTC) {
    format = locale.utcFormat(specifier);
  } else if (isLogarithmic(type)) {
    const varfmt = locale.formatFloat(specifier);

    if (noSkip || scale.bins) {
      format = varfmt;
    } else {
      const test = tickLog(scale, count, false);

      format = _ => test(_) ? varfmt(_) : '';
    }
  } else if (scale.tickFormat) {
    // if d3 scale has tickFormat, it must be continuous
    const d = scale.domain();
    format = locale.formatSpan(d[0], d[d.length - 1], count, specifier);
  } else if (specifier) {
    format = locale.format(specifier);
  }

  return format;
}
function tickLog(scale, count, values) {
  const ticks = tickValues(scale, count),
        base = scale.base(),
        logb = Math.log(base),
        k = Math.max(1, base * count / ticks.length); // apply d3-scale's log format filter criteria

  const test = d => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5) i *= base;
    return i <= k;
  };

  return values ? ticks.filter(test) : test;
}

const symbols = {
  [Quantile]: 'quantiles',
  [Quantize]: 'thresholds',
  [Threshold]: 'domain'
};
const formats = {
  [Quantile]: 'quantiles',
  [Quantize]: 'domain'
};
function labelValues(scale, count) {
  return scale.bins ? binValues(scale.bins) : scale.type === Log ? tickLog(scale, count, true) : symbols[scale.type] ? thresholdValues(scale[symbols[scale.type]]()) : tickValues(scale, count);
}
function thresholdFormat(locale, scale, specifier) {
  const _ = scale[formats[scale.type]](),
        n = _.length;

  let d = n > 1 ? _[1] - _[0] : _[0],
      i;

  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  } // tickCount = 3 ticks times 10 for increased resolution


  return locale.formatSpan(0, d, 3 * 10, specifier);
}

function thresholdValues(thresholds) {
  const values = [-Infinity].concat(thresholds);
  values.max = +Infinity;
  return values;
}

function binValues(bins) {
  const values = bins.slice(0, -1);
  values.max = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(bins);
  return values;
}

const isDiscreteRange = scale => symbols[scale.type] || scale.bins;

function labelFormat(locale, scale, count, type, specifier, formatType, noSkip) {
  const format = formats[scale.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale, scale, specifier) : tickFormat(locale, scale, count, specifier, formatType, noSkip);
  return type === SymbolLegend && isDiscreteRange(scale) ? formatRange(format) : type === DiscreteLegend ? formatDiscrete(format) : formatPoint(format);
}

const formatRange = format => (value, index, array) => {
  const limit = get(array[index + 1], get(array.max, +Infinity)),
        lo = formatValue(value, format),
        hi = formatValue(limit, format);
  return lo && hi ? lo + ' \u2013 ' + hi : hi ? '< ' + hi : '\u2265 ' + lo;
};

const get = (value, dflt) => value != null ? value : dflt;

const formatDiscrete = format => (value, index) => index ? format(value) : null;

const formatPoint = format => value => format(value);

const formatValue = (value, format) => Number.isFinite(value) ? format(value) : null;

function labelFraction(scale) {
  const domain = scale.domain(),
        count = domain.length - 1;
  let lo = +domain[0],
      hi = +(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(domain),
      span = hi - lo;

  if (scale.type === Threshold) {
    const adjust = count ? span / count : 0.1;
    lo -= adjust;
    hi += adjust;
    span = hi - lo;
  }

  return value => (value - lo) / span;
}

function format(locale, scale, specifier, formatType) {
  const type = formatType || scale.type; // replace abbreviated time specifiers to improve screen reader experience

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(specifier) && isTemporal(type)) {
    specifier = specifier.replace(/%a/g, '%A').replace(/%b/g, '%B');
  }

  return !specifier && type === Time ? locale.timeFormat('%A, %d %B %Y, %X') : !specifier && type === UTC ? locale.utcFormat('%A, %d %B %Y, %X UTC') : labelFormat(locale, scale, 5, null, specifier, formatType, true);
}

function domainCaption(locale, scale, opt) {
  opt = opt || {};
  const max = Math.max(3, opt.maxlen || 7),
        fmt = format(locale, scale, opt.format, opt.formatType); // if scale breaks domain into bins, describe boundaries

  if (isDiscretizing(scale.type)) {
    const v = labelValues(scale).slice(1).map(fmt),
          n = v.length;
    return "".concat(n, " boundar").concat(n === 1 ? 'y' : 'ies', ": ").concat(v.join(', '));
  } // if scale domain is discrete, list values
  else if (isDiscrete(scale.type)) {
      const d = scale.domain(),
            n = d.length,
            v = n > max ? d.slice(0, max - 2).map(fmt).join(', ') + ', ending with ' + d.slice(-1).map(fmt) : d.map(fmt).join(', ');
      return "".concat(n, " value").concat(n === 1 ? '' : 's', ": ").concat(v);
    } // if scale domain is continuous, describe value range
    else {
        const d = scale.domain();
        return "values from ".concat(fmt(d[0]), " to ").concat(fmt((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(d)));
      }
}




/***/ }),

/***/ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bounds": () => (/* binding */ Bounds),
/* harmony export */   "CanvasHandler": () => (/* binding */ CanvasHandler),
/* harmony export */   "CanvasRenderer": () => (/* binding */ CanvasRenderer),
/* harmony export */   "Gradient": () => (/* binding */ Gradient),
/* harmony export */   "GroupItem": () => (/* binding */ GroupItem),
/* harmony export */   "Handler": () => (/* binding */ Handler),
/* harmony export */   "Item": () => (/* binding */ Item),
/* harmony export */   "Marks": () => (/* binding */ Marks),
/* harmony export */   "RenderType": () => (/* binding */ RenderType),
/* harmony export */   "Renderer": () => (/* binding */ Renderer),
/* harmony export */   "ResourceLoader": () => (/* binding */ ResourceLoader),
/* harmony export */   "SVGHandler": () => (/* binding */ SVGHandler),
/* harmony export */   "SVGRenderer": () => (/* binding */ SVGRenderer),
/* harmony export */   "SVGStringRenderer": () => (/* binding */ SVGStringRenderer),
/* harmony export */   "Scenegraph": () => (/* binding */ Scenegraph),
/* harmony export */   "boundClip": () => (/* binding */ boundClip),
/* harmony export */   "boundContext": () => (/* binding */ boundContext),
/* harmony export */   "boundItem": () => (/* binding */ boundItem),
/* harmony export */   "boundMark": () => (/* binding */ boundMark),
/* harmony export */   "boundStroke": () => (/* binding */ boundStroke),
/* harmony export */   "domChild": () => (/* binding */ domChild),
/* harmony export */   "domClear": () => (/* binding */ domClear),
/* harmony export */   "domCreate": () => (/* binding */ domCreate),
/* harmony export */   "domFind": () => (/* binding */ domFind),
/* harmony export */   "font": () => (/* binding */ font),
/* harmony export */   "fontFamily": () => (/* binding */ fontFamily),
/* harmony export */   "fontSize": () => (/* binding */ fontSize),
/* harmony export */   "intersect": () => (/* binding */ intersect),
/* harmony export */   "intersectBoxLine": () => (/* binding */ intersectBoxLine),
/* harmony export */   "intersectPath": () => (/* binding */ intersectPath),
/* harmony export */   "intersectPoint": () => (/* binding */ intersectPoint),
/* harmony export */   "intersectRule": () => (/* binding */ intersectRule),
/* harmony export */   "lineHeight": () => (/* binding */ lineHeight),
/* harmony export */   "markup": () => (/* binding */ markup),
/* harmony export */   "multiLineOffset": () => (/* binding */ multiLineOffset),
/* harmony export */   "pathCurves": () => (/* binding */ curves),
/* harmony export */   "pathEqual": () => (/* binding */ pathEqual),
/* harmony export */   "pathParse": () => (/* binding */ pathParse),
/* harmony export */   "pathRectangle": () => (/* binding */ vg_rect),
/* harmony export */   "pathRender": () => (/* binding */ pathRender),
/* harmony export */   "pathSymbols": () => (/* binding */ symbols),
/* harmony export */   "pathTrail": () => (/* binding */ vg_trail),
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "renderModule": () => (/* binding */ renderModule),
/* harmony export */   "resetSVGClipId": () => (/* binding */ resetSVGClipId),
/* harmony export */   "resetSVGDefIds": () => (/* binding */ resetSVGDefIds),
/* harmony export */   "sceneEqual": () => (/* binding */ sceneEqual),
/* harmony export */   "sceneFromJSON": () => (/* binding */ sceneFromJSON),
/* harmony export */   "scenePickVisit": () => (/* binding */ pickVisit),
/* harmony export */   "sceneToJSON": () => (/* binding */ sceneToJSON),
/* harmony export */   "sceneVisit": () => (/* binding */ visit),
/* harmony export */   "sceneZOrder": () => (/* binding */ zorder),
/* harmony export */   "serializeXML": () => (/* binding */ serializeXML),
/* harmony export */   "textMetrics": () => (/* binding */ textMetrics)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/basis.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/bundle.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/cardinal.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/monotone.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/natural.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/curve/step.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/area.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/line.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! d3-shape */ "../../node_modules/d3-shape/src/symbol.js");
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-path */ "../../node_modules/d3-path/src/path.js");
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-canvas */ "../../node_modules/vega-canvas/index.browser.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-loader */ "../../node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");







let gradient_id = 0;
function resetSVGGradientId() {
  gradient_id = 0;
}
const patternPrefix = 'p_';
function isGradient(value) {
  return value && value.gradient;
}
function gradientRef(g, defs, base) {
  const type = g.gradient;
  let id = g.id,
      prefix = type === 'radial' ? patternPrefix : ''; // check id, assign default values as needed

  if (!id) {
    id = g.id = 'gradient_' + gradient_id++;

    if (type === 'radial') {
      g.x1 = get(g.x1, 0.5);
      g.y1 = get(g.y1, 0.5);
      g.r1 = get(g.r1, 0);
      g.x2 = get(g.x2, 0.5);
      g.y2 = get(g.y2, 0.5);
      g.r2 = get(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get(g.x1, 0);
      g.y1 = get(g.y1, 0);
      g.x2 = get(g.x2, 1);
      g.y2 = get(g.y2, 0);
    }
  } // register definition


  defs[id] = g; // return url reference

  return 'url(' + (base || '') + '#' + prefix + id + ')';
}

function get(val, def) {
  return val != null ? val : def;
}

function Gradient (p0, p1) {
  var stops = [],
      gradient;
  return gradient = {
    gradient: 'linear',
    x1: p0 ? p0[0] : 0,
    y1: p0 ? p0[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops: stops,
    stop: function (offset, color) {
      stops.push({
        offset: offset,
        color: color
      });
      return gradient;
    }
  };
}

const lookup = {
  'basis': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_4__.default
  },
  'basis-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_5__.default
  },
  'basis-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_6__.default
  },
  'bundle': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_7__.default,
    tension: 'beta',
    value: 0.85
  },
  'cardinal': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_8__.default,
    tension: 'tension',
    value: 0
  },
  'cardinal-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_9__.default,
    tension: 'tension',
    value: 0
  },
  'cardinal-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_10__.default,
    tension: 'tension',
    value: 0
  },
  'catmull-rom': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_11__.default,
    tension: 'alpha',
    value: 0.5
  },
  'catmull-rom-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_12__.default,
    tension: 'alpha',
    value: 0.5
  },
  'catmull-rom-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_13__.default,
    tension: 'alpha',
    value: 0.5
  },
  'linear': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_14__.default
  },
  'linear-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_15__.default
  },
  'monotone': {
    horizontal: d3_shape__WEBPACK_IMPORTED_MODULE_16__.monotoneY,
    vertical: d3_shape__WEBPACK_IMPORTED_MODULE_16__.monotoneX
  },
  'natural': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_17__.default
  },
  'step': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__.default
  },
  'step-after': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__.stepAfter
  },
  'step-before': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__.stepBefore
  }
};
function curves(type, orientation, tension) {
  var entry = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(lookup, type) && lookup[type],
      curve = null;

  if (entry) {
    curve = entry.curve || entry[orientation || 'vertical'];

    if (entry.tension && tension != null) {
      curve = curve[entry.tension](tension);
    }
  }

  return curve;
}

// Path parsing and rendering code adapted from fabric.js -- Thanks!
const cmdlen = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
},
      regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\.\d+)(\.\d)/g, /(\d)([-+])/g, /\s|,|###/];
function pathParse (pathstr) {
  const result = [];
  let curr, chunks, parsed, param, cmd, len, i, j, n, m; // First, break path into command sequence

  const path = pathstr.slice().replace(regexp[0], '###$1').split(regexp[1]).slice(1); // Next, parse each command in turn

  for (i = 0, n = path.length; i < n; ++i) {
    curr = path[i];
    chunks = curr.slice(1).trim().replace(regexp[2], '$1###$2').replace(regexp[3], '$1###$2').split(regexp[4]);
    cmd = curr.charAt(0);
    parsed = [cmd];

    for (j = 0, m = chunks.length; j < m; ++j) {
      if ((param = +chunks[j]) === param) {
        // not NaN
        parsed.push(param);
      }
    }

    len = cmdlen[cmd.toLowerCase()];

    if (parsed.length - 1 > len) {
      const m = parsed.length;
      j = 1;
      result.push([cmd].concat(parsed.slice(j, j += len))); // handle implicit lineTo (#2803)

      cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;

      for (; j < m; j += len) {
        result.push([cmd].concat(parsed.slice(j, j + len)));
      }
    } else {
      result.push(parsed);
    }
  }

  return result;
}

const DegToRad = Math.PI / 180;
const Epsilon = 1e-14;
const HalfPi = Math.PI / 2;
const Tau = Math.PI * 2;
const HalfSqrt3 = Math.sqrt(3) / 2;

var segmentCache = {};
var bezierCache = {};
var join = [].join; // Copied from Inkscape svgtopdf, thanks!

function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  const key = join.call(arguments);

  if (segmentCache[key]) {
    return segmentCache[key];
  }

  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / (rx * rx) + py * py / (ry * ry);

  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }

  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x0 = a00 * ox + a01 * oy;
  const y0 = a10 * ox + a11 * oy;
  const x1 = a00 * x + a01 * y;
  const y1 = a10 * x + a11 * y;
  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large) sfactor = -sfactor;
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  const th0 = Math.atan2(y0 - yc, x0 - xc);
  const th1 = Math.atan2(y1 - yc, x1 - xc);
  let th_arc = th1 - th0;

  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }

  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));
  const result = [];

  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }

  return segmentCache[key] = result;
}
function bezier(params) {
  const key = join.call(params);

  if (bezierCache[key]) {
    return bezierCache[key];
  }

  var cx = params[0],
      cy = params[1],
      th0 = params[2],
      th1 = params[3],
      rx = params[4],
      ry = params[5],
      sin_th = params[6],
      cos_th = params[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x1 = cx + cos_th0 - t * sin_th0;
  const y1 = cy + sin_th0 + t * cos_th0;
  const x3 = cx + cos_th1;
  const y3 = cy + sin_th1;
  const x2 = x3 + t * sin_th1;
  const y2 = y3 - t * cos_th1;
  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}

const temp = ['l', 0, 0, 0, 0, 0, 0, 0];

function scale$1(current, sX, sY) {
  const c = temp[0] = current[0];

  if (c === 'a' || c === 'A') {
    temp[1] = sX * current[1];
    temp[2] = sY * current[2];
    temp[3] = current[3];
    temp[4] = current[4];
    temp[5] = current[5];
    temp[6] = sX * current[6];
    temp[7] = sY * current[7];
  } else if (c === 'h' || c === 'H') {
    temp[1] = sX * current[1];
  } else if (c === 'v' || c === 'V') {
    temp[1] = sY * current[1];
  } else {
    for (var i = 1, n = current.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
    }
  }

  return temp;
}

function pathRender (context, path, l, t, sX, sY) {
  var current,
      // current instruction
  previous = null,
      x = 0,
      // current x
  y = 0,
      // current y
  controlX = 0,
      // current control point x
  controlY = 0,
      // current control point y
  tempX,
      tempY,
      tempControlX,
      tempControlY;
  if (l == null) l = 0;
  if (t == null) t = 0;
  if (sX == null) sX = 1;
  if (sY == null) sY = sX;
  if (context.beginPath) context.beginPath();

  for (var i = 0, len = path.length; i < len; ++i) {
    current = path[i];

    if (sX !== 1 || sY !== 1) {
      current = scale$1(current, sX, sY);
    }

    switch (current[0]) {
      // first letter
      case 'l':
        // lineto, relative
        x += current[1];
        y += current[2];
        context.lineTo(x + l, y + t);
        break;

      case 'L':
        // lineto, absolute
        x = current[1];
        y = current[2];
        context.lineTo(x + l, y + t);
        break;

      case 'h':
        // horizontal lineto, relative
        x += current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'H':
        // horizontal lineto, absolute
        x = current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'v':
        // vertical lineto, relative
        y += current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'V':
        // verical lineto, absolute
        y = current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'm':
        // moveTo, relative
        x += current[1];
        y += current[2];
        context.moveTo(x + l, y + t);
        break;

      case 'M':
        // moveTo, absolute
        x = current[1];
        y = current[2];
        context.moveTo(x + l, y + t);
        break;

      case 'c':
        // bezierCurveTo, relative
        tempX = x + current[5];
        tempY = y + current[6];
        controlX = x + current[3];
        controlY = y + current[4];
        context.bezierCurveTo(x + current[1] + l, // x1
        y + current[2] + t, // y1
        controlX + l, // x2
        controlY + t, // y2
        tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;

      case 'C':
        // bezierCurveTo, absolute
        x = current[5];
        y = current[6];
        controlX = current[3];
        controlY = current[4];
        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
        break;

      case 's':
        // shorthand cubic bezierCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4]; // calculate reflection of previous control points

        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t); // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.

        controlX = x + current[1];
        controlY = y + current[2];
        x = tempX;
        y = tempY;
        break;

      case 'S':
        // shorthand cubic bezierCurveTo, absolute
        tempX = current[3];
        tempY = current[4]; // calculate reflection of previous control points

        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY; // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.

        controlX = current[1];
        controlY = current[2];
        break;

      case 'q':
        // quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];
        controlX = x + current[1];
        controlY = y + current[2];
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;

      case 'Q':
        // quadraticCurveTo, absolute
        tempX = current[3];
        tempY = current[4];
        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        controlX = current[1];
        controlY = current[2];
        break;

      case 't':
        // shorthand quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[1];
        tempY = y + current[2];

        if (previous[0].match(/[QqTt]/) === null) {
          // If there is no previous command or if the previous command was not a Q, q, T or t,
          // assume the control point is coincident with the current point
          controlX = x;
          controlY = y;
        } else if (previous[0] === 't') {
          // calculate reflection of previous control points for t
          controlX = 2 * x - tempControlX;
          controlY = 2 * y - tempControlY;
        } else if (previous[0] === 'q') {
          // calculate reflection of previous control points for q
          controlX = 2 * x - controlX;
          controlY = 2 * y - controlY;
        }

        tempControlX = controlX;
        tempControlY = controlY;
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        controlX = x + current[1];
        controlY = y + current[2];
        break;

      case 'T':
        tempX = current[1];
        tempY = current[2]; // calculate reflection of previous control points

        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;

      case 'a':
        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);
        x += current[6];
        y += current[7];
        break;

      case 'A':
        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);
        x = current[6];
        y = current[7];
        break;

      case 'z':
      case 'Z':
        context.closePath();
        break;
    }

    previous = current;
  }
}

function drawArc(context, x, y, coords) {
  const seg = segments(coords[5], // end x
  coords[6], // end y
  coords[0], // radius x
  coords[1], // radius y
  coords[3], // large flag
  coords[4], // sweep flag
  coords[2], // rotation
  x, y);

  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}

const Tan30 = 0.5773502691896257;
const builtins = {
  'circle': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, Tau);
    }
  },
  'cross': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          s = r / 2.5;
      context.moveTo(-r, -s);
      context.lineTo(-r, s);
      context.lineTo(-s, s);
      context.lineTo(-s, r);
      context.lineTo(s, r);
      context.lineTo(s, s);
      context.lineTo(r, s);
      context.lineTo(r, -s);
      context.lineTo(s, -s);
      context.lineTo(s, -r);
      context.lineTo(-s, -r);
      context.lineTo(-s, -s);
      context.closePath();
    }
  },
  'diamond': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(-r, 0);
      context.lineTo(0, -r);
      context.lineTo(r, 0);
      context.lineTo(0, r);
      context.closePath();
    }
  },
  'square': {
    draw: function (context, size) {
      var w = Math.sqrt(size),
          x = -w / 2;
      context.rect(x, x, w, w);
    }
  },
  'arrow': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          s = r / 7,
          t = r / 2.5,
          v = r / 8;
      context.moveTo(-s, r);
      context.lineTo(s, r);
      context.lineTo(s, -v);
      context.lineTo(t, -v);
      context.lineTo(0, -r);
      context.lineTo(-t, -v);
      context.lineTo(-s, -v);
      context.closePath();
    }
  },
  'wedge': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r,
          o = h - r * Tan30,
          b = r / 4;
      context.moveTo(0, -h - o);
      context.lineTo(-b, h - o);
      context.lineTo(b, h - o);
      context.closePath();
    }
  },
  'triangle': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r,
          o = h - r * Tan30;
      context.moveTo(0, -h - o);
      context.lineTo(-r, h - o);
      context.lineTo(r, h - o);
      context.closePath();
    }
  },
  'triangle-up': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(0, -h);
      context.lineTo(-r, h);
      context.lineTo(r, h);
      context.closePath();
    }
  },
  'triangle-down': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(0, h);
      context.lineTo(-r, -h);
      context.lineTo(r, -h);
      context.closePath();
    }
  },
  'triangle-right': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(h, 0);
      context.lineTo(-h, -r);
      context.lineTo(-h, r);
      context.closePath();
    }
  },
  'triangle-left': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(-h, 0);
      context.lineTo(h, -r);
      context.lineTo(h, r);
      context.closePath();
    }
  },
  'stroke': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(-r, 0);
      context.lineTo(r, 0);
    }
  }
};
function symbols(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom = {};

function customSymbol(path) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(custom, path)) {
    const parsed = pathParse(path);
    custom[path] = {
      draw: function (context, size) {
        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }

  return custom[path];
}

const C = 0.448084975506; // C = 1 - c

function rectangleX(d) {
  return d.x;
}

function rectangleY(d) {
  return d.y;
}

function rectangleWidth(d) {
  return d.width;
}

function rectangleHeight(d) {
  return d.height;
}

function number(_) {
  return typeof _ === 'function' ? _ : () => +_;
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(value, max));
}

function vg_rect () {
  var x = rectangleX,
      y = rectangleY,
      width = rectangleWidth,
      height = rectangleHeight,
      crTL = number(0),
      crTR = crTL,
      crBL = crTL,
      crBR = crTL,
      context = null;

  function rectangle(_, x0, y0) {
    var buffer,
        x1 = x0 != null ? x0 : +x.call(this, _),
        y1 = y0 != null ? y0 : +y.call(this, _),
        w = +width.call(this, _),
        h = +height.call(this, _),
        s = Math.min(w, h) / 2,
        tl = clamp(+crTL.call(this, _), 0, s),
        tr = clamp(+crTR.call(this, _), 0, s),
        bl = clamp(+crBL.call(this, _), 0, s),
        br = clamp(+crBR.call(this, _), 0, s);
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_19__.default)();

    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
      context.rect(x1, y1, w, h);
    } else {
      var x2 = x1 + w,
          y2 = y1 + h;
      context.moveTo(x1 + tl, y1);
      context.lineTo(x2 - tr, y1);
      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);
      context.lineTo(x2, y2 - br);
      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);
      context.lineTo(x1 + bl, y2);
      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);
      context.lineTo(x1, y1 + tl);
      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);
      context.closePath();
    }

    if (buffer) {
      context = null;
      return buffer + '' || null;
    }
  }

  rectangle.x = function (_) {
    if (arguments.length) {
      x = number(_);
      return rectangle;
    } else {
      return x;
    }
  };

  rectangle.y = function (_) {
    if (arguments.length) {
      y = number(_);
      return rectangle;
    } else {
      return y;
    }
  };

  rectangle.width = function (_) {
    if (arguments.length) {
      width = number(_);
      return rectangle;
    } else {
      return width;
    }
  };

  rectangle.height = function (_) {
    if (arguments.length) {
      height = number(_);
      return rectangle;
    } else {
      return height;
    }
  };

  rectangle.cornerRadius = function (tl, tr, br, bl) {
    if (arguments.length) {
      crTL = number(tl);
      crTR = tr != null ? number(tr) : crTL;
      crBR = br != null ? number(br) : crTL;
      crBL = bl != null ? number(bl) : crTR;
      return rectangle;
    } else {
      return crTL;
    }
  };

  rectangle.context = function (_) {
    if (arguments.length) {
      context = _ == null ? null : _;
      return rectangle;
    } else {
      return context;
    }
  };

  return rectangle;
}

function vg_trail () {
  var x,
      y,
      size,
      defined,
      context = null,
      ready,
      x1,
      y1,
      r1;

  function point(x2, y2, w2) {
    const r2 = w2 / 2;

    if (ready) {
      var ux = y1 - y2,
          uy = x2 - x1;

      if (ux || uy) {
        // get normal vector
        var ud = Math.sqrt(ux * ux + uy * uy),
            rx = (ux /= ud) * r1,
            ry = (uy /= ud) * r1,
            t = Math.atan2(uy, ux); // draw segment

        context.moveTo(x1 - rx, y1 - ry);
        context.lineTo(x2 - ux * r2, y2 - uy * r2);
        context.arc(x2, y2, r2, t - Math.PI, t);
        context.lineTo(x1 + rx, y1 + ry);
        context.arc(x1, y1, r1, t, t + Math.PI);
      } else {
        context.arc(x2, y2, r2, 0, Tau);
      }

      context.closePath();
    } else {
      ready = 1;
    }

    x1 = x2;
    y1 = y2;
    r1 = r2;
  }

  function trail(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;
    if (context == null) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_19__.default)();

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) ready = 0;
      }

      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));
    }

    if (buffer) {
      context = null;
      return buffer + '' || null;
    }
  }

  trail.x = function (_) {
    if (arguments.length) {
      x = _;
      return trail;
    } else {
      return x;
    }
  };

  trail.y = function (_) {
    if (arguments.length) {
      y = _;
      return trail;
    } else {
      return y;
    }
  };

  trail.size = function (_) {
    if (arguments.length) {
      size = _;
      return trail;
    } else {
      return size;
    }
  };

  trail.defined = function (_) {
    if (arguments.length) {
      defined = _;
      return trail;
    } else {
      return defined;
    }
  };

  trail.context = function (_) {
    if (arguments.length) {
      if (_ == null) {
        context = null;
      } else {
        context = _;
      }

      return trail;
    } else {
      return context;
    }
  };

  return trail;
}

function value$1(a, b) {
  return a != null ? a : b;
}

const x = item => item.x || 0,
      y = item => item.y || 0,
      w = item => item.width || 0,
      h = item => item.height || 0,
      xw = item => (item.x || 0) + (item.width || 0),
      yh = item => (item.y || 0) + (item.height || 0),
      sa = item => item.startAngle || 0,
      ea = item => item.endAngle || 0,
      pa = item => item.padAngle || 0,
      ir = item => item.innerRadius || 0,
      or = item => item.outerRadius || 0,
      cr = item => item.cornerRadius || 0,
      tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,
      tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,
      br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,
      bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,
      sz = item => value$1(item.size, 64),
      ts = item => item.size || 1,
      def = item => !(item.defined === false),
      type = item => symbols(item.shape || 'circle');

const arcShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_20__.default)().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),
      areavShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_21__.default)().x(x).y1(y).y0(yh).defined(def),
      areahShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_21__.default)().y(y).x1(x).x0(xw).defined(def),
      lineShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_22__.default)().x(x).y(y).defined(def),
      rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),
      symbolShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_23__.default)().type(type).size(sz),
      trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1(context, item) {
  return arcShape.context(context)(item);
}
function area$1(context, items) {
  const item = items[0],
        interp = item.interpolate || 'linear';
  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);
}
function line$1(context, items) {
  const item = items[0],
        interp = item.interpolate || 'linear';
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);
}
function rectangle(context, item, x, y) {
  return rectShape.context(context)(item, x, y);
}
function shape$1(context, item) {
  return (item.mark.shape || item.shape).context(context)(item);
}
function symbol$1(context, item) {
  return symbolShape.context(context)(item);
}
function trail$1(context, items) {
  return trailShape.context(context)(items);
}

var clip_id = 1;
function resetSVGClipId() {
  clip_id = 1;
}
function clip$1 (renderer, item, size) {
  var clip = item.clip,
      defs = renderer._defs,
      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),
      c = defs.clipping[id] || (defs.clipping[id] = {
    id: id
  });

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    c.path = clip(null);
  } else if (hasCornerRadius(size)) {
    c.path = rectangle(null, size, 0, 0);
  } else {
    c.width = size.width || 0;
    c.height = size.height || 0;
  }

  return 'url(#' + id + ')';
}

function Bounds(b) {
  this.clear();
  if (b) this.union(b);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },

  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },

  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },

  equals(b) {
    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
  },

  set(x1, y1, x2, y2) {
    if (x2 < x1) {
      this.x2 = x1;
      this.x1 = x2;
    } else {
      this.x1 = x1;
      this.x2 = x2;
    }

    if (y2 < y1) {
      this.y2 = y1;
      this.y1 = y2;
    } else {
      this.y1 = y1;
      this.y2 = y2;
    }

    return this;
  },

  add(x, y) {
    if (x < this.x1) this.x1 = x;
    if (y < this.y1) this.y1 = y;
    if (x > this.x2) this.x2 = x;
    if (y > this.y2) this.y2 = y;
    return this;
  },

  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },

  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },

  scale(s) {
    this.x1 *= s;
    this.y1 *= s;
    this.x2 *= s;
    this.y2 *= s;
    return this;
  },

  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },

  rotate(angle, x, y) {
    const p = this.rotatedPoints(angle, x, y);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },

  rotatedPoints(angle, x, y) {
    var {
      x1,
      y1,
      x2,
      y2
    } = this,
        cos = Math.cos(angle),
        sin = Math.sin(angle),
        cx = x - x * cos + y * sin,
        cy = y - x * sin - y * cos;
    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
  },

  union(b) {
    if (b.x1 < this.x1) this.x1 = b.x1;
    if (b.y1 < this.y1) this.y1 = b.y1;
    if (b.x2 > this.x2) this.x2 = b.x2;
    if (b.y2 > this.y2) this.y2 = b.y2;
    return this;
  },

  intersect(b) {
    if (b.x1 > this.x1) this.x1 = b.x1;
    if (b.y1 > this.y1) this.y1 = b.y1;
    if (b.x2 < this.x2) this.x2 = b.x2;
    if (b.y2 < this.y2) this.y2 = b.y2;
    return this;
  },

  encloses(b) {
    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
  },

  alignsWith(b) {
    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);
  },

  intersects(b) {
    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
  },

  contains(x, y) {
    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
  },

  width() {
    return this.x2 - this.x1;
  },

  height() {
    return this.y2 - this.y1;
  }

};

function Item(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds();
}

function GroupItem(mark) {
  Item.call(this, mark);
  this.items = this.items || [];
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(GroupItem, Item);

function ResourceLoader(customLoader) {
  this._pending = 0;
  this._loader = customLoader || (0,vega_loader__WEBPACK_IMPORTED_MODULE_2__.loader)();
}

function increment(loader) {
  loader._pending += 1;
}

function decrement(loader) {
  loader._pending -= 1;
}

ResourceLoader.prototype = {
  pending() {
    return this._pending;
  },

  sanitizeURL(uri) {
    const loader = this;
    increment(loader);
    return loader._loader.sanitize(uri, {
      context: 'href'
    }).then(opt => {
      decrement(loader);
      return opt;
    }).catch(() => {
      decrement(loader);
      return null;
    });
  },

  loadImage(uri) {
    const loader = this,
          Image = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.image)();
    increment(loader);
    return loader._loader.sanitize(uri, {
      context: 'image'
    }).then(opt => {
      const url = opt.href;
      if (!url || !Image) throw {
        url: url
      };
      const img = new Image(); // set crossOrigin only if cors is defined; empty string sets anonymous mode
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin

      const cors = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';
      if (cors != null) img.crossOrigin = cors; // attempt to load image resource

      img.onload = () => decrement(loader);

      img.onerror = () => decrement(loader);

      img.src = url;
      return img;
    }).catch(e => {
      decrement(loader);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e && e.url || ''
      };
    });
  },

  ready() {
    const loader = this;
    return new Promise(accept => {
      function poll(value) {
        if (!loader.pending()) accept(value);else setTimeout(() => {
          poll(true);
        }, 10);
      }

      poll(false);
    });
  }

};

function boundStroke (bounds, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }

  return bounds;
}

function miterAdjustment(item, strokeWidth) {
  // TODO: more sophisticated adjustment? Or miter support in boundContext?
  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;
}

const circleThreshold = Tau - 1e-8;
let bounds, lx, ly, rot, ma, mb, mc, md;

const add = (x, y) => bounds.add(x, y);

const addL = (x, y) => add(lx = x, ly = y);

const addX = x => add(x, bounds.y1);

const addY = y => add(bounds.x1, y);

const px = (x, y) => ma * x + mc * y;

const py = (x, y) => mb * x + md * y;

const addp = (x, y) => add(px(x, y), py(x, y));

const addpL = (x, y) => addL(px(x, y), py(x, y));

function boundContext (_, deg) {
  bounds = _;

  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }

  return context$1;
}
const context$1 = {
  beginPath() {},

  closePath() {},

  moveTo: addpL,
  lineTo: addpL,

  rect(x, y, w, h) {
    if (rot) {
      addp(x + w, y);
      addp(x + w, y + h);
      addp(x, y + h);
      addpL(x, y);
    } else {
      add(x + w, y + h);
      addL(x, y);
    }
  },

  quadraticCurveTo(x1, y1, x2, y2) {
    const px1 = px(x1, y1),
          py1 = py(x1, y1),
          px2 = px(x2, y2),
          py2 = py(x2, y2);
    quadExtrema(lx, px1, px2, addX);
    quadExtrema(ly, py1, py2, addY);
    addL(px2, py2);
  },

  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    const px1 = px(x1, y1),
          py1 = py(x1, y1),
          px2 = px(x2, y2),
          py2 = py(x2, y2),
          px3 = px(x3, y3),
          py3 = py(x3, y3);
    cubicExtrema(lx, px1, px2, px3, addX);
    cubicExtrema(ly, py1, py2, py3, addY);
    addL(px3, py3);
  },

  arc(cx, cy, r, sa, ea, ccw) {
    sa += rot;
    ea += rot; // store last point on path

    lx = r * Math.cos(ea) + cx;
    ly = r * Math.sin(ea) + cy;

    if (Math.abs(ea - sa) > circleThreshold) {
      // treat as full circle
      add(cx - r, cy - r);
      add(cx + r, cy + r);
    } else {
      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);

      let s, i; // sample end points

      update(sa);
      update(ea); // sample interior points aligned with 90 degrees

      if (ea !== sa) {
        sa = sa % Tau;
        if (sa < 0) sa += Tau;
        ea = ea % Tau;
        if (ea < 0) ea += Tau;

        if (ea < sa) {
          ccw = !ccw; // flip direction

          s = sa;
          sa = ea;
          ea = s; // swap end-points
        }

        if (ccw) {
          ea -= Tau;
          s = sa - sa % HalfPi;

          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);
        } else {
          s = sa - sa % HalfPi + HalfPi;

          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);
        }
      }
    }
  }

};

function quadExtrema(x0, x1, x2, cb) {
  const t = (x0 - x1) / (x0 + x2 - 2 * x1);
  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);
}

function cubicExtrema(x0, x1, x2, x3, cb) {
  const a = x3 - x0 + 3 * x1 - 3 * x2,
        b = x0 + x2 - 2 * x1,
        c = x0 - x1;
  let t0 = 0,
      t1 = 0,
      r; // solve for parameter t

  if (Math.abs(a) > Epsilon) {
    // quadratic equation
    r = b * b + c * a;

    if (r >= 0) {
      r = Math.sqrt(r);
      t0 = (-b + r) / a;
      t1 = (-b - r) / a;
    }
  } else {
    // linear equation
    t0 = 0.5 * c / b;
  } // calculate position


  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));
  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));
}

function cubic(t, x0, x1, x2, x3) {
  const s = 1 - t,
        s2 = s * s,
        t2 = t * t;
  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;
}

var context = (context = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(1, 1)) ? context.getContext('2d') : null;

const b = new Bounds();
function intersectPath(draw) {
  return function (item, brush) {
    // rely on (inaccurate) bounds intersection if no context
    if (!context) return true; // add path to offscreen graphics context

    draw(context, item); // get bounds intersection region

    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1,
      y1,
      x2,
      y2
    } = b; // iterate over intersection region
    // perform fine grained inclusion test

    for (let y = y1; y <= y2; ++y) {
      for (let x = x1; x <= x2; ++x) {
        if (context.isPointInPath(x, y)) {
          return true;
        }
      }
    } // false if no hits in intersection region


    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x = item.x || 0,
        y = item.y || 0,
        w = item.width || 0,
        h = item.height || 0;
  return box.intersects(b.set(x, y, x + w, y + h));
}
function intersectRule(item, box) {
  const x = item.x || 0,
        y = item.y || 0,
        x2 = item.x2 != null ? item.x2 : x,
        y2 = item.y2 != null ? item.y2 : y;
  return intersectBoxLine(box, x, y, x2, y2);
}
function intersectBoxLine(box, x, y, u, v) {
  const {
    x1,
    y1,
    x2,
    y2
  } = box,
        dx = u - x,
        dy = v - y;
  let t0 = 0,
      t1 = 1,
      p,
      q,
      r,
      e;

  for (e = 0; e < 4; ++e) {
    if (e === 0) {
      p = -dx;
      q = -(x1 - x);
    }

    if (e === 1) {
      p = dx;
      q = x2 - x;
    }

    if (e === 2) {
      p = -dy;
      q = -(y1 - y);
    }

    if (e === 3) {
      p = dy;
      q = y2 - y;
    }

    if (Math.abs(p) < 1e-10 && q < 0) return false;
    r = q / p;

    if (p < 0) {
      if (r > t1) return false;else if (r > t0) t0 = r;
    } else if (p > 0) {
      if (r < t0) return false;else if (r < t1) t1 = r;
    }
  }

  return true;
}

function blend (context, item) {
  context.globalCompositeOperation = item.blend || 'source-over';
}

function value (value, dflt) {
  return value == null ? dflt : value;
}

function addStops(gradient, stops) {
  const n = stops.length;

  for (let i = 0; i < n; ++i) {
    gradient.addColorStop(stops[i].offset, stops[i].color);
  }

  return gradient;
}

function gradient (context, spec, bounds) {
  const w = bounds.width(),
        h = bounds.height();
  let gradient;

  if (spec.gradient === 'radial') {
    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));
  } else {
    // linear gradient
    const x1 = value(spec.x1, 0),
          y1 = value(spec.y1, 0),
          x2 = value(spec.x2, 1),
          y2 = value(spec.y2, 0);

    if (x1 === x2 || y1 === y2 || w === h) {
      // axis aligned: use normal gradient
      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);
    } else {
      // not axis aligned: render gradient into a pattern (#2365)
      // this allows us to use normalized bounding box coordinates
      const image = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(Math.ceil(w), Math.ceil(h)),
            ictx = image.getContext('2d');
      ictx.scale(w, h);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);
      ictx.fillRect(0, 0, w, h);
      return context.createPattern(image, 'no-repeat');
    }
  }

  return addStops(gradient, spec.stops);
}

function color (context, item, value) {
  return isGradient(value) ? gradient(context, value, item.bounds) : value;
}

function fill (context, item, opacity) {
  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;

  if (opacity > 0) {
    context.globalAlpha = opacity;
    context.fillStyle = color(context, item, item.fill);
    return true;
  } else {
    return false;
  }
}

var Empty = [];
function stroke (context, item, opacity) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0) return false;
  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;

  if (opacity > 0) {
    context.globalAlpha = opacity;
    context.strokeStyle = color(context, item, item.stroke);
    context.lineWidth = lw;
    context.lineCap = item.strokeCap || 'butt';
    context.lineJoin = item.strokeJoin || 'miter';
    context.miterLimit = item.strokeMiterLimit || 10;

    if (context.setLineDash) {
      context.setLineDash(item.strokeDash || Empty);
      context.lineDashOffset = item.strokeDashOffset || 0;
    }

    return true;
  } else {
    return false;
  }
}

function compare(a, b) {
  return a.zindex - b.zindex || a.index - b.index;
}

function zorder(scene) {
  if (!scene.zdirty) return scene.zitems;
  var items = scene.items,
      output = [],
      item,
      i,
      n;

  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex) output.push(item);
  }

  scene.zdirty = false;
  return scene.zitems = output.sort(compare);
}
function visit(scene, visitor) {
  var items = scene.items,
      i,
      n;
  if (!items || !items.length) return;
  const zitems = zorder(scene);

  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex) visitor(items[i]);
    }

    items = zitems;
  }

  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit(scene, visitor) {
  var items = scene.items,
      hit,
      i;
  if (!items || !items.length) return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length) items = zitems;

  for (i = items.length; --i >= 0;) {
    if (hit = visitor(items[i])) return hit;
  }

  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0;) {
      if (!items[i].zindex) {
        if (hit = visitor(items[i])) return hit;
      }
    }
  }

  return null;
}

function drawAll(path) {
  return function (context, scene, bounds) {
    visit(scene, item => {
      if (!bounds || bounds.intersects(item.bounds)) {
        drawPath(path, context, item, item);
      }
    });
  };
}
function drawOne(path) {
  return function (context, scene, bounds) {
    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {
      drawPath(path, context, scene.items[0], scene.items);
    }
  };
}

function drawPath(path, context, item, items) {
  var opacity = item.opacity == null ? 1 : item.opacity;
  if (opacity === 0) return;
  if (path(context, items)) return;
  blend(context, item);

  if (item.fill && fill(context, item, opacity)) {
    context.fill();
  }

  if (item.stroke && stroke(context, item, opacity)) {
    context.stroke();
  }
}

function pick$1(test) {
  test = test || vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy;
  return function (context, scene, x, y, gx, gy) {
    x *= context.pixelRatio;
    y *= context.pixelRatio;
    return pickVisit(scene, item => {
      const b = item.bounds; // first hit test against bounding box

      if (b && !b.contains(gx, gy) || !b) return; // if in bounding box, perform more careful test

      if (test(context, item, x, y, gx, gy)) return item;
    });
  };
}
function hitPath(path, filled) {
  return function (context, o, x, y) {
    var item = Array.isArray(o) ? o[0] : o,
        fill = filled == null ? item.fill : filled,
        stroke = item.stroke && context.isPointInStroke,
        lw,
        lc;

    if (stroke) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context.lineWidth = lw != null ? lw : 1;
      context.lineCap = lc != null ? lc : 'butt';
    }

    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);
  };
}
function pickPath(path) {
  return pick$1(hitPath(path));
}

function translate(x, y) {
  return 'translate(' + x + ',' + y + ')';
}
function rotate(a) {
  return 'rotate(' + a + ')';
}
function scale(scaleX, scaleY) {
  return 'scale(' + scaleX + ',' + scaleY + ')';
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');
}

function markItemPath (type, shape, isect) {
  function attr(emit, item) {
    emit('transform', rotateItem(item));
    emit('d', shape(null, item));
  }

  function bound(bounds, item) {
    shape(boundContext(bounds, item.angle), item);
    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);
  }

  function draw(context, item) {
    var x = item.x || 0,
        y = item.y || 0,
        a = item.angle || 0;
    context.translate(x, y);
    if (a) context.rotate(a *= DegToRad);
    context.beginPath();
    shape(context, item);
    if (a) context.rotate(-a);
    context.translate(-x, -y);
  }

  return {
    type: type,
    tag: 'path',
    nested: false,
    attr: attr,
    bound: bound,
    draw: drawAll(draw),
    pick: pickPath(draw),
    isect: isect || intersectPath(draw)
  };
}

var arc = markItemPath('arc', arc$1);

function pickArea(a, p) {
  var v = a[0].orient === 'horizontal' ? p[1] : p[0],
      z = a[0].orient === 'horizontal' ? 'y' : 'x',
      i = a.length,
      min = +Infinity,
      hit,
      d;

  while (--i >= 0) {
    if (a[i].defined === false) continue;
    d = Math.abs(a[i][z] - v);

    if (d < min) {
      min = d;
      hit = a[i];
    }
  }

  return hit;
}
function pickLine(a, p) {
  var t = Math.pow(a[0].strokeWidth || 1, 2),
      i = a.length,
      dx,
      dy,
      dd;

  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t) return a[i];
  }

  return null;
}
function pickTrail(a, p) {
  var i = a.length,
      dx,
      dy,
      dd;

  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a[i].size || 1;
    if (dd < dx * dx) return a[i];
  }

  return null;
}

function markMultiItemPath (type, shape, tip) {
  function attr(emit, item) {
    var items = item.mark.items;
    if (items.length) emit('d', shape(null, items));
  }

  function bound(bounds, mark) {
    var items = mark.items;

    if (items.length === 0) {
      return bounds;
    } else {
      shape(boundContext(bounds), items);
      return boundStroke(bounds, items[0]);
    }
  }

  function draw(context, items) {
    context.beginPath();
    shape(context, items);
  }

  const hit = hitPath(draw);

  function pick(context, scene, x, y, gx, gy) {
    var items = scene.items,
        b = scene.bounds;

    if (!items || !items.length || b && !b.contains(gx, gy)) {
      return null;
    }

    x *= context.pixelRatio;
    y *= context.pixelRatio;
    return hit(context, items, x, y) ? items[0] : null;
  }

  return {
    type: type,
    tag: 'path',
    nested: true,
    attr: attr,
    bound: bound,
    draw: drawOne(draw),
    pick: pick,
    isect: intersectPoint,
    tip: tip
  };
}

var area = markMultiItemPath('area', area$1, pickArea);

function clip (context, scene) {
  var clip = scene.clip;
  context.save();

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    context.beginPath();
    clip(context);
    context.clip();
  } else {
    clipGroup(context, scene.group);
  }
}
function clipGroup(context, group) {
  context.beginPath();
  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);
  context.clip();
}

function offset$1(item) {
  const sw = value(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}

function attr$5(emit, item) {
  emit('transform', translateItem(item));
}

function emitRectangle(emit, item) {
  const off = offset$1(item);
  emit('d', rectangle(null, item, off, off));
}

function background(emit, item) {
  emit('class', 'background');
  emit('aria-hidden', true);
  emitRectangle(emit, item);
}

function foreground(emit, item) {
  emit('class', 'foreground');
  emit('aria-hidden', true);

  if (item.strokeForeground) {
    emitRectangle(emit, item);
  } else {
    emit('d', '');
  }
}

function content(emit, item, renderer) {
  const url = item.clip ? clip$1(renderer, item, item) : null;
  emit('clip-path', url);
}

function bound$5(bounds, group) {
  if (!group.clip && group.items) {
    const items = group.items,
          m = items.length;

    for (let j = 0; j < m; ++j) {
      bounds.union(items[j].bounds);
    }
  }

  if ((group.clip || group.width || group.height) && !group.noBound) {
    bounds.add(0, 0).add(group.width || 0, group.height || 0);
  }

  boundStroke(bounds, group);
  return bounds.translate(group.x || 0, group.y || 0);
}

function rectanglePath(context, group, x, y) {
  const off = offset$1(group);
  context.beginPath();
  rectangle(context, group, (x || 0) + off, (y || 0) + off);
}

const hitBackground = hitPath(rectanglePath);
const hitForeground = hitPath(rectanglePath, false);
const hitCorner = hitPath(rectanglePath, true);

function draw$4(context, scene, bounds) {
  visit(scene, group => {
    const gx = group.x || 0,
          gy = group.y || 0,
          fore = group.strokeForeground,
          opacity = group.opacity == null ? 1 : group.opacity; // draw group background

    if ((group.stroke || group.fill) && opacity) {
      rectanglePath(context, group, gx, gy);
      blend(context, group);

      if (group.fill && fill(context, group, opacity)) {
        context.fill();
      }

      if (group.stroke && !fore && stroke(context, group, opacity)) {
        context.stroke();
      }
    } // setup graphics context, set clip and bounds


    context.save();
    context.translate(gx, gy);
    if (group.clip) clipGroup(context, group);
    if (bounds) bounds.translate(-gx, -gy); // draw group contents

    visit(group, item => {
      this.draw(context, item, bounds);
    }); // restore graphics context

    if (bounds) bounds.translate(gx, gy);
    context.restore(); // draw group foreground

    if (fore && group.stroke && opacity) {
      rectanglePath(context, group, gx, gy);
      blend(context, group);

      if (stroke(context, group, opacity)) {
        context.stroke();
      }
    }
  });
}

function pick(context, scene, x, y, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }

  const cx = x * context.pixelRatio,
        cy = y * context.pixelRatio;
  return pickVisit(scene, group => {
    let hit, dx, dy; // first hit test bounding box

    const b = group.bounds;
    if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip

    dx = group.x || 0;
    dy = group.y || 0;
    const dw = dx + (group.width || 0),
          dh = dy + (group.height || 0),
          c = group.clip;
    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return; // adjust coordinate system

    context.save();
    context.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy; // test background for rounded corner clip

    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {
      context.restore();
      return null;
    }

    const fore = group.strokeForeground,
          ix = scene.interactive !== false; // hit test against group foreground

    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {
      context.restore();
      return group;
    } // hit test against contained marks


    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null); // hit test against group background

    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {
      hit = group;
    } // restore state and return


    context.restore();
    return hit || null;
  });
}

function pickMark(mark, x, y) {
  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);
}

var group = {
  type: 'group',
  tag: 'g',
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick: pick,
  isect: intersectRect,
  content: content,
  background: background,
  foreground: foreground
};

var metadata = {
  'xmlns': 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  'version': '1.1'
};

function getImage(item, renderer) {
  var image = item.image;

  if (!image || item.url && item.url !== image.url) {
    image = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then(image => {
      item.image = image;
      item.image.url = item.url;
    });
  }

  return image;
}

function imageWidth(item, image) {
  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;
}

function imageHeight(item, image) {
  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;
}

function imageXOffset(align, w) {
  return align === 'center' ? w / 2 : align === 'right' ? w : 0;
}

function imageYOffset(baseline, h) {
  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;
}

function attr$4(emit, item, renderer) {
  const img = getImage(item, renderer),
        w = imageWidth(item, img),
        h = imageHeight(item, img),
        x = (item.x || 0) - imageXOffset(item.align, w),
        y = (item.y || 0) - imageYOffset(item.baseline, h),
        i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';
  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');
  emit('transform', translate(x, y));
  emit('width', w);
  emit('height', h);
  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');
}

function bound$4(bounds, item) {
  const img = item.image,
        w = imageWidth(item, img),
        h = imageHeight(item, img),
        x = (item.x || 0) - imageXOffset(item.align, w),
        y = (item.y || 0) - imageYOffset(item.baseline, h);
  return bounds.set(x, y, x + w, y + h);
}

function draw$3(context, scene, bounds) {
  visit(scene, item => {
    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check

    const img = getImage(item, this);
    let w = imageWidth(item, img);
    let h = imageHeight(item, img);
    if (w === 0 || h === 0) return; // early exit

    let x = (item.x || 0) - imageXOffset(item.align, w),
        y = (item.y || 0) - imageYOffset(item.baseline, h),
        opacity,
        ar0,
        ar1,
        t;

    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;

      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w / ar0;
          y += (h - t) / 2;
          h = t;
        } else {
          t = h * ar0;
          x += (w - t) / 2;
          w = t;
        }
      }
    }

    if (img.complete || img.toDataURL) {
      blend(context, item);
      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;
      context.imageSmoothingEnabled = item.smooth !== false;
      context.drawImage(img, x, y, w, h);
    }
  });
}

var image = {
  type: 'image',
  tag: 'image',
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick$1(),
  isect: vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy,
  // bounds check is sufficient
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};

var line = markMultiItemPath('line', line$1, pickLine);

function attr$3(emit, item) {
  var sx = item.scaleX || 1,
      sy = item.scaleY || 1;

  if (sx !== 1 || sy !== 1) {
    emit('vector-effect', 'non-scaling-stroke');
  }

  emit('transform', transformItem(item));
  emit('d', item.path);
}

function path$1(context, item) {
  var path = item.path;
  if (path == null) return true;
  var x = item.x || 0,
      y = item.y || 0,
      sx = item.scaleX || 1,
      sy = item.scaleY || 1,
      a = (item.angle || 0) * DegToRad,
      cache = item.pathCache;

  if (!cache || cache.path !== path) {
    (item.pathCache = cache = pathParse(path)).path = path;
  }

  if (a && context.rotate && context.translate) {
    context.translate(x, y);
    context.rotate(a);
    pathRender(context, cache, 0, 0, sx, sy);
    context.rotate(-a);
    context.translate(-x, -y);
  } else {
    pathRender(context, cache, x, y, sx, sy);
  }
}

function bound$3(bounds, item) {
  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);
}

var path$2 = {
  type: 'path',
  tag: 'path',
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(path$1),
  pick: pickPath(path$1),
  isect: intersectPath(path$1)
};

function attr$2(emit, item) {
  emit('d', rectangle(null, item));
}

function bound$2(bounds, item) {
  var x, y;
  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);
}

function draw$2(context, item) {
  context.beginPath();
  rectangle(context, item);
}

var rect = {
  type: 'rect',
  tag: 'path',
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};

function attr$1(emit, item) {
  emit('transform', translateItem(item));
  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);
}

function bound$1(bounds, item) {
  var x1, y1;
  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);
}

function path(context, item, opacity) {
  var x1, y1, x2, y2;

  if (item.stroke && stroke(context, item, opacity)) {
    x1 = item.x || 0;
    y1 = item.y || 0;
    x2 = item.x2 != null ? item.x2 : x1;
    y2 = item.y2 != null ? item.y2 : y1;
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    return true;
  }

  return false;
}

function draw$1(context, scene, bounds) {
  visit(scene, item => {
    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check

    var opacity = item.opacity == null ? 1 : item.opacity;

    if (opacity && path(context, item, opacity)) {
      blend(context, item);
      context.stroke();
    }
  });
}

function hit$1(context, item, x, y) {
  if (!context.isPointInStroke) return false;
  return path(context, item, 1) && context.isPointInStroke(x, y);
}

var rule = {
  type: 'rule',
  tag: 'line',
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick$1(hit$1),
  isect: intersectRule
};

var shape = markItemPath('shape', shape$1);

var symbol = markItemPath('symbol', symbol$1, intersectPoint);

const widthCache = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.lruCache)();
var textMetrics = {
  height: fontSize,
  measureWidth: measureWidth,
  estimateWidth: estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);

function useCanvas(use) {
  textMetrics.width = use && context ? measureWidth : estimateWidth;
} // make simple estimate if no canvas is available


function estimateWidth(item, text) {
  return _estimateWidth(textValue(item, text), fontSize(item));
}

function _estimateWidth(text, currentFontHeight) {
  return ~~(0.8 * text.length * currentFontHeight);
} // measure text width if canvas is available


function measureWidth(item, text) {
  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));
}

function _measureWidth(text, currentFont) {
  const key = `(${currentFont}) ${text}`;
  let width = widthCache.get(key);

  if (width === undefined) {
    context.font = currentFont;
    width = context.measureText(text).width;
    widthCache.set(key, width);
  }

  return width;
}

function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}

function lineArray(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.length > 1 ? _ : _[0] : _;
}

function textLines(item) {
  return lineArray(item.lineBreak && item.text && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl = textLines(item);
  return ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl) ? tl.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line) {
  const text = line == null ? '' : (line + '').trim();
  return item.limit > 0 && text.length ? truncate(item, text) : text;
}

function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    // we are using canvas
    const currentFont = font(item);
    return text => _measureWidth(text, currentFont);
  } else {
    // we are relying on estimates
    const currentFontHeight = fontSize(item);
    return text => _estimateWidth(text, currentFontHeight);
  }
}

function truncate(item, text) {
  var limit = +item.limit,
      width = widthGetter(item);
  if (width(text) < limit) return text;
  var ellipsis = item.ellipsis || '\u2026',
      rtl = item.dir === 'rtl',
      lo = 0,
      hi = text.length,
      mid;
  limit -= width(ellipsis);

  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;
    }

    return ellipsis + text.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;
    }

    return text.slice(0, lo) + ellipsis;
  }
}

function fontFamily(item, quote) {
  var font = item.font;
  return (quote && font ? String(font).replace(/"/g, '\'') : font) || 'sans-serif';
}
function font(item, quote) {
  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);
}
function offset(item) {
  // perform our own font baseline calculation
  // why? not all browsers support SVG 1.1 'alignment-baseline' :(
  // this also ensures consistent layout across renderers
  var baseline = item.baseline,
      h = fontSize(item);
  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);
}

const textAlign = {
  'left': 'start',
  'center': 'middle',
  'right': 'end'
};
const tempBounds = new Bounds();

function anchorPoint(item) {
  var x = item.x || 0,
      y = item.y || 0,
      r = item.radius || 0,
      t;

  if (r) {
    t = (item.theta || 0) - HalfPi;
    x += r * Math.cos(t);
    y += r * Math.sin(t);
  }

  tempBounds.x1 = x;
  tempBounds.y1 = y;
  return tempBounds;
}

function attr(emit, item) {
  var dx = item.dx || 0,
      dy = (item.dy || 0) + offset(item),
      p = anchorPoint(item),
      x = p.x1,
      y = p.y1,
      a = item.angle || 0,
      t;
  emit('text-anchor', textAlign[item.align] || 'start');

  if (a) {
    t = translate(x, y) + ' ' + rotate(a);
    if (dx || dy) t += ' ' + translate(dx, dy);
  } else {
    t = translate(x + dx, y + dy);
  }

  emit('transform', t);
}

function bound(bounds, item, mode) {
  var h = textMetrics.height(item),
      a = item.align,
      p = anchorPoint(item),
      x = p.x1,
      y = p.y1,
      dx = item.dx || 0,
      dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),
      // use 4/5 offset
  tl = textLines(item),
      w; // get dimensions

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
    // multi-line text
    h += lineHeight(item) * (tl.length - 1);
    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);
  } else {
    // single-line text
    w = textMetrics.width(item, tl);
  } // horizontal alignment


  if (a === 'center') {
    dx -= w / 2;
  } else if (a === 'right') {
    dx -= w;
  } else ;

  bounds.set(dx += x, dy += y, dx + w, dy + h);

  if (item.angle && !mode) {
    bounds.rotate(item.angle * DegToRad, x, y);
  } else if (mode === 2) {
    return bounds.rotatedPoints(item.angle * DegToRad, x, y);
  }

  return bounds;
}

function draw(context, scene, bounds) {
  visit(scene, item => {
    var opacity = item.opacity == null ? 1 : item.opacity,
        p,
        x,
        y,
        i,
        lh,
        tl,
        str;
    if (bounds && !bounds.intersects(item.bounds) || // bounds check
    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;
    context.font = font(item);
    context.textAlign = item.align || 'left';
    p = anchorPoint(item);
    x = p.x1, y = p.y1;

    if (item.angle) {
      context.save();
      context.translate(x, y);
      context.rotate(item.angle * DegToRad);
      x = y = 0; // reset x, y
    }

    x += item.dx || 0;
    y += (item.dy || 0) + offset(item);
    tl = textLines(item);
    blend(context, item);

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
      lh = lineHeight(item);

      for (i = 0; i < tl.length; ++i) {
        str = textValue(item, tl[i]);

        if (item.fill && fill(context, item, opacity)) {
          context.fillText(str, x, y);
        }

        if (item.stroke && stroke(context, item, opacity)) {
          context.strokeText(str, x, y);
        }

        y += lh;
      }
    } else {
      str = textValue(item, tl);

      if (item.fill && fill(context, item, opacity)) {
        context.fillText(str, x, y);
      }

      if (item.stroke && stroke(context, item, opacity)) {
        context.strokeText(str, x, y);
      }
    }

    if (item.angle) context.restore();
  });
}

function hit(context, item, x, y, gx, gy) {
  if (item.fontSize <= 0) return false;
  if (!item.angle) return true; // bounds sufficient if no rotation
  // project point into space of unrotated bounds

  var p = anchorPoint(item),
      ax = p.x1,
      ay = p.y1,
      b = bound(tempBounds, item, 1),
      a = -item.angle * DegToRad,
      cos = Math.cos(a),
      sin = Math.sin(a),
      px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),
      py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);
  return b.contains(px, py);
}

function intersectText(item, box) {
  const p = bound(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}

var text = {
  type: 'text',
  tag: 'text',
  nested: false,
  attr: attr,
  bound: bound,
  draw: draw,
  pick: pick$1(hit),
  isect: intersectText
};

var trail = markMultiItemPath('trail', trail$1, pickTrail);

var Marks = {
  arc: arc,
  area: area,
  group: group,
  image: image,
  line: line,
  path: path$2,
  rect: rect,
  rule: rule,
  shape: shape,
  symbol: symbol,
  text: text,
  trail: trail
};

function boundItem (item, func, opt) {
  var type = Marks[item.mark.marktype],
      bound = func || type.bound;
  if (type.nested) item = item.mark;
  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);
}

var DUMMY = {
  mark: null
};
function boundMark (mark, bounds, opt) {
  var type = Marks[mark.marktype],
      bound = type.bound,
      items = mark.items,
      hasItems = items && items.length,
      i,
      n,
      item,
      b;

  if (type.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      // no items, fake it
      DUMMY.mark = mark;
      item = DUMMY;
    }

    b = boundItem(item, bound, opt);
    bounds = bounds && bounds.union(b) || b;
    return bounds;
  }

  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();

  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds.union(boundItem(items[i], bound, opt));
    }
  }

  return mark.bounds = bounds;
}

const keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline', // layout
'fill', 'fillOpacity', 'opacity', 'blend', // fill
'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap', // stroke
'strokeDash', 'strokeDashOffset', // stroke dash
'strokeForeground', 'strokeOffset', // group
'startAngle', 'endAngle', 'innerRadius', 'outerRadius', // arc
'cornerRadius', 'padAngle', // arc, rect
'cornerRadiusTopLeft', 'cornerRadiusTopRight', // rect, group
'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined', // area, line
'url', 'aspect', 'smooth', // image
'path', 'scaleX', 'scaleY', // path
'x2', 'y2', // rule
'size', 'shape', // symbol
'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy', // text
'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font
'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json) {
  const scene = typeof json === 'string' ? JSON.parse(json) : json;
  return initialize(scene);
}

function initialize(scene) {
  var type = scene.marktype,
      items = scene.items,
      parent,
      i,
      n;

  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type ? 'mark' : 'group';
      items[i][parent] = scene;
      if (items[i].zindex) items[i][parent].zdirty = true;
      if ('group' === (type || parent)) initialize(items[i]);
    }
  }

  if (type) boundMark(scene);
  return scene;
}

function Scenegraph(scene) {
  if (arguments.length) {
    this.root = sceneFromJSON(scene);
  } else {
    this.root = createMark({
      marktype: 'group',
      name: 'root',
      role: 'frame'
    });
    this.root.items = [new GroupItem(this.root)];
  }
}
Scenegraph.prototype = {
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  },

  mark(markdef, group, index) {
    group = group || this.root.items[0];
    const mark = createMark(markdef, group);
    group.items[index] = mark;
    if (mark.zindex) mark.group.zdirty = true;
    return mark;
  }

};

function createMark(def, group) {
  const mark = {
    bounds: new Bounds(),
    clip: !!def.clip,
    group: group,
    interactive: def.interactive === false ? false : true,
    items: [],
    marktype: def.marktype,
    name: def.name || undefined,
    role: def.role || undefined,
    zindex: def.zindex || 0
  }; // add accessibility properties if defined

  if (def.aria != null) {
    mark.aria = def.aria;
  }

  if (def.description) {
    mark.description = def.description;
  }

  return mark;
}

// create a new DOM element
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== 'undefined' && document.createElement) {
    doc = document;
  }

  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
} // find first child element with matching tag

function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes,
      i = 0,
      n = nodes.length;

  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {
    return nodes[i];
  }
} // retrieve child element at given index
// create & insert if doesn't exist or if tags do not match

function domChild(el, index, tag, ns) {
  var a = el.childNodes[index],
      b;

  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {
    b = a || null;
    a = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a, b);
  }

  return a;
} // remove all child elements at or above the given index

function domClear(el, index) {
  var nodes = el.childNodes,
      curr = nodes.length;

  while (curr > index) el.removeChild(nodes[--curr]);

  return el;
} // generate css class name for mark

function cssClass(mark) {
  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');
}

function point (event, el) {
  const rect = el.getBoundingClientRect();
  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];
}

function resolveItem (item, event, el, origin) {
  var mark = item && item.mark,
      mdef,
      p;

  if (mark && (mdef = Marks[mark.marktype]).tip) {
    p = point(event, el);
    p[0] -= origin[0];
    p[1] -= origin[1];

    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }

    item = mdef.tip(mark.items, p);
  }

  return item;
}

/**
 * Create a new Handler instance.
 * @param {object} [customLoader] - Optional loader instance for
 *   href URL sanitization. If not specified, a standard loader
 *   instance will be generated.
 * @param {function} [customTooltip] - Optional tooltip handler
 *   function for custom tooltip display.
 * @constructor
 */

function Handler(customLoader, customTooltip) {
  this._active = null;
  this._handlers = {};
  this._loader = customLoader || (0,vega_loader__WEBPACK_IMPORTED_MODULE_2__.loader)();
  this._tooltip = customTooltip || defaultTooltip;
} // The default tooltip display handler.
// Sets the HTML title attribute on the visualization container.

function defaultTooltip(handler, event, item, value) {
  handler.element().setAttribute('title', value || '');
}

Handler.prototype = {
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  },

  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },

  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },

  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  },

  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length) return this._scene;
    this._scene = scene;
    return this;
  },

  /**
   * Add an event handler. Subclasses should override this method.
   */
  on()
  /*type, handler*/
  {},

  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off()
  /*type, handler*/
  {},

  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h, type, handler) {
    for (let i = h ? h.length : 0; --i >= 0;) {
      if (h[i].type === type && (!handler || h[i].handler === handler)) {
        return i;
      }
    }

    return -1;
  },

  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type) {
    const h = this._handlers,
          a = [];

    if (type) {
      a.push(...h[this.eventName(type)]);
    } else {
      for (const k in h) {
        a.push(...h[k]);
      }
    }

    return a;
  },

  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf('.');
    return i < 0 ? name : name.slice(0, i);
  },

  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event, item, href) {
    this._loader.sanitize(href, {
      context: 'href'
    }).then(opt => {
      const e = new MouseEvent(event.type, event),
            a = domCreate(null, 'a');

      for (const name in opt) a.setAttribute(name, opt[name]);

      a.dispatchEvent(e);
    }).catch(() => {
      /* do nothing */
    });
  },

  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event, this.canvas(), this._origin);
      const value = show && item && item.tooltip || null;

      this._tooltip.call(this._obj, this, event, item, value);
    }
  },

  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el) return;
    const rect = el.getBoundingClientRect(),
          origin = this._origin,
          bounds = item.bounds,
          width = bounds.width(),
          height = bounds.height();
    let x = bounds.x1 + origin[0] + rect.left,
        y = bounds.y1 + origin[1] + rect.top; // translate coordinate for each parent group

    while (item.mark && (item = item.mark.group)) {
      x += item.x || 0;
      y += item.y || 0;
    } // return DOMRect-compatible bounding box


    return {
      x,
      y,
      width,
      height,
      left: x,
      top: y,
      right: x + width,
      bottom: y + height
    };
  }

};

/**
 * Create a new Renderer instance.
 * @param {object} [loader] - Optional loader instance for
 *   image and href URL sanitization. If not specified, a
 *   standard loader instance will be generated.
 * @constructor
 */

function Renderer(loader) {
  this._el = null;
  this._bgcolor = null;
  this._loader = new ResourceLoader(loader);
}
Renderer.prototype = {
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width, height, origin, scaleFactor) {
    this._el = el;
    return this.resize(width, height, origin, scaleFactor);
  },

  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },

  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },

  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0) return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  },

  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width, height, origin, scaleFactor) {
    this._width = width;
    this._height = height;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  },

  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty()
  /*item*/
  {},

  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Renderer} - This renderer instance.
   */
  render(scene) {
    const r = this; // bind arguments into a render call, and cache it
    // this function may be subsequently called for async redraw

    r._call = function () {
      r._render(scene);
    }; // invoke the renderer


    r._call(); // clear the cached call for garbage collection
    // async redraws will stash their own copy


    r._call = null;
    return r;
  },

  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render()
  /*scene*/
  {// subclasses to override
  },

  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene) {
    const r = this.render(scene);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  },

  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method, uri) {
    var r = this,
        p = r._loader[method](uri);

    if (!r._ready) {
      // re-render the scene when loading completes
      const call = r._call;
      r._ready = r._loader.ready().then(redraw => {
        if (redraw) call();
        r._ready = null;
      });
    }

    return p;
  },

  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load('sanitizeURL', uri);
  },

  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load('loadImage', uri);
  }

};

const KeyDownEvent = 'keydown';
const KeyPressEvent = 'keypress';
const KeyUpEvent = 'keyup';
const DragEnterEvent = 'dragenter';
const DragLeaveEvent = 'dragleave';
const DragOverEvent = 'dragover';
const MouseDownEvent = 'mousedown';
const MouseUpEvent = 'mouseup';
const MouseMoveEvent = 'mousemove';
const MouseOutEvent = 'mouseout';
const MouseOverEvent = 'mouseover';
const ClickEvent = 'click';
const DoubleClickEvent = 'dblclick';
const WheelEvent = 'wheel';
const MouseWheelEvent = 'mousewheel';
const TouchStartEvent = 'touchstart';
const TouchMoveEvent = 'touchmove';
const TouchEndEvent = 'touchend';
const Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
const TooltipShowEvent = MouseMoveEvent;
const TooltipHideEvent = MouseOutEvent;
const HrefEvent = ClickEvent;

function CanvasHandler(loader, tooltip) {
  Handler.call(this, loader, tooltip);
  this._down = null;
  this._touch = null;
  this._first = true;
  this._events = {};
}

const eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type]; // lazily add listeners to the canvas as needed


function eventListenerCheck(handler, type) {
  eventBundle(type).forEach(_ => addEventListener(handler, _));
}

function addEventListener(handler, type) {
  const canvas = handler.canvas();

  if (canvas && !handler._events[type]) {
    handler._events[type] = 1;
    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));
  }
}

function move(moveEvent, overEvent, outEvent) {
  return function (evt) {
    const a = this._active,
          p = this.pickEvent(evt);

    if (p === a) {
      // active item and picked item are the same
      this.fire(moveEvent, evt); // fire move
    } else {
      // active item and picked item are different
      if (!a || !a.exit) {
        // fire out for prior active item
        // suppress if active item was removed from scene
        this.fire(outEvent, evt);
      }

      this._active = p; // set new active item

      this.fire(overEvent, evt); // fire over for new active item

      this.fire(moveEvent, evt); // fire move for new active item
    }
  };
}

function inactive(type) {
  return function (evt) {
    this.fire(type, evt);
    this._active = null;
  };
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CanvasHandler, Handler, {
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, 'canvas'); // add minimal events required for proper state management

    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));
    return Handler.prototype.initialize.call(this, el, origin, obj);
  },

  // return the backing canvas instance
  canvas() {
    return this._canvas;
  },

  // retrieve the current canvas context
  context() {
    return this._canvas.getContext('2d');
  },

  // supported events
  events: Events,

  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  },

  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),
  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),
  mouseout: inactive(MouseOutEvent),
  dragleave: inactive(DragLeaveEvent),

  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  },

  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  },

  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);

    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }

    this.fire(TouchStartEvent, evt, true);
  },

  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  },

  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  },

  // fire an event
  fire(type, evt, touch) {
    const a = touch ? this._touch : this._active,
          h = this._handlers[type]; // set event type relative to scenegraph items

    evt.vegaType = type; // handle hyperlinks and tooltips first

    if (type === HrefEvent && a && a.href) {
      this.handleHref(evt, a, a.href);
    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {
      this.handleTooltip(evt, a, type !== TooltipHideEvent);
    } // invoke all registered handlers


    if (h) {
      for (let i = 0, len = h.length; i < len; ++i) {
        h[i].handler.call(this._obj, evt, a);
      }
    }
  },

  // add an event handler
  on(type, handler) {
    const name = this.eventName(type),
          h = this._handlers,
          i = this._handlerIndex(h[name], type, handler);

    if (i < 0) {
      eventListenerCheck(this, type);
      (h[name] || (h[name] = [])).push({
        type: type,
        handler: handler
      });
    }

    return this;
  },

  // remove an event handler
  off(type, handler) {
    const name = this.eventName(type),
          h = this._handlers[name],
          i = this._handlerIndex(h, type, handler);

    if (i >= 0) {
      h.splice(i, 1);
    }

    return this;
  },

  pickEvent(evt) {
    const p = point(evt, this._canvas),
          o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  },

  // find the scenegraph item at the current mouse position
  // x, y -- the absolute x, y mouse coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x, y, gx, gy) {
    const g = this.context(),
          mark = Marks[scene.marktype];
    return mark.pick.call(this, g, scene, x, y, gx, gy);
  }

});

function devicePixelRatio() {
  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;
}

var pixelRatio = devicePixelRatio();
function resize (canvas, width, height, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,
        context = canvas.getContext('2d'),
        ratio = inDOM ? pixelRatio : scaleFactor;
  canvas.width = width * ratio;
  canvas.height = height * ratio;

  for (const key in opt) {
    context[key] = opt[key];
  }

  if (inDOM && ratio !== 1) {
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  context.pixelRatio = ratio;
  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}

function CanvasRenderer(loader) {
  Renderer.call(this, loader);
  this._options = {};
  this._redraw = false;
  this._dirty = new Bounds();
  this._tempb = new Bounds();
}
const base$1 = Renderer.prototype;

const viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);

function clipToBounds(g, b, origin) {
  // expand bounds by 1 pixel, then round to pixel boundaries
  b.expand(1).round(); // align to base pixel grid in case of non-integer scaling (#2425)

  if (g.pixelRatio % 1) {
    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  } // to avoid artifacts translate if origin has fractional pixels


  b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clip path

  g.beginPath();
  g.rect(b.x1, b.y1, b.width(), b.height());
  g.clip();
  return b;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CanvasRenderer, Renderer, {
  initialize(el, width, height, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(1, 1, this._options.type); // instantiate a small canvas

    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);

      this._canvas.setAttribute('class', 'marks');
    } // this method will invoke resize to size the canvas appropriately


    return base$1.initialize.call(this, el, width, height, origin, scaleFactor);
  },

  resize(width, height, origin, scaleFactor) {
    base$1.resize.call(this, width, height, origin, scaleFactor);

    if (this._canvas) {
      // configure canvas size and transform
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      // external context needs to be scaled and positioned to origin
      const ctx = this._options.externalContext;
      if (!ctx) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('CanvasRenderer is missing a valid canvas or context');
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }

    this._redraw = true;
    return this;
  },

  canvas() {
    return this._canvas;
  },

  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);
  },

  dirty(item) {
    const b = this._tempb.clear().union(item.bounds);

    let g = item.mark.group;

    while (g) {
      b.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }

    this._dirty.union(b);
  },

  _render(scene) {
    const g = this.context(),
          o = this._origin,
          w = this._width,
          h = this._height,
          db = this._dirty,
          vb = viewBounds(o, w, h); // setup

    g.save();
    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w, h); // render

    this.draw(g, scene, b); // takedown

    g.restore();
    db.clear();
    return this;
  },

  draw(ctx, scene, bounds) {
    const mark = Marks[scene.marktype];
    if (scene.clip) clip(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds);
    if (scene.clip) ctx.restore();
  },

  clear(x, y, w, h) {
    const opt = this._options,
          g = this.context();

    if (opt.type !== 'pdf' && !opt.externalContext) {
      // calling clear rect voids vector output in pdf mode
      // and could remove external context content (#2615)
      g.clearRect(x, y, w, h);
    }

    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x, y, w, h);
    }
  }

});

function SVGHandler(loader, tooltip) {
  Handler.call(this, loader, tooltip);
  const h = this;
  h._hrefHandler = listener(h, (evt, item) => {
    if (item && item.href) h.handleHref(evt, item, item.href);
  });
  h._tooltipHandler = listener(h, (evt, item) => {
    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
  });
} // wrap an event listener for the SVG DOM

const listener = (context, handler) => evt => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context._obj, evt, item);
};

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(SVGHandler, Handler, {
  initialize(el, origin, obj) {
    let svg = this._svg;

    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }

    this._svg = svg = el && domFind(el, 'svg');

    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }

    return Handler.prototype.initialize.call(this, el, origin, obj);
  },

  canvas() {
    return this._svg;
  },

  // add an event handler
  on(type, handler) {
    const name = this.eventName(type),
          h = this._handlers,
          i = this._handlerIndex(h[name], type, handler);

    if (i < 0) {
      const x = {
        type,
        handler,
        listener: listener(this, handler)
      };
      (h[name] || (h[name] = [])).push(x);

      if (this._svg) {
        this._svg.addEventListener(name, x.listener);
      }
    }

    return this;
  },

  // remove an event handler
  off(type, handler) {
    const name = this.eventName(type),
          h = this._handlers[name],
          i = this._handlerIndex(h, type, handler);

    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h[i].listener);
      }

      h.splice(i, 1);
    }

    return this;
  }

});

const ARIA_HIDDEN = 'aria-hidden';
const ARIA_LABEL = 'aria-label';
const ARIA_ROLE = 'role';
const ARIA_ROLEDESCRIPTION = 'aria-roledescription';
const GRAPHICS_OBJECT = 'graphics-object';
const GRAPHICS_SYMBOL = 'graphics-symbol';

const bundle = (role, roledesc, label) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label || undefined
}); // these roles are covered by related roles
// we can ignore them, no need to generate attributes


const AriaIgnore = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']); // aria attribute generators for guide roles

const AriaGuides = {
  'axis': {
    desc: 'axis',
    caption: axisCaption
  },
  'legend': {
    desc: 'legend',
    caption: legendCaption
  },
  'title-text': {
    desc: 'title',
    caption: item => `Title text '${titleCaption(item)}'`
  },
  'title-subtitle': {
    desc: 'subtitle',
    caption: item => `Subtitle text '${titleCaption(item)}'`
  }
}; // aria properties generated for mark item encoding channels

const AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit, item) {
  const hide = item.aria === false;
  emit(ARIA_HIDDEN, hide || undefined);

  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit(AriaEncode[prop], undefined);
    }
  } else {
    const type = item.mark.marktype;
    emit(ARIA_LABEL, item.description);
    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type} mark`);
  }
}
function ariaMarkAttributes(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
}

function ariaMark(mark) {
  const type = mark.marktype;
  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);
  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type} mark container`, mark.description);
}

function ariaGuide(mark, opt) {
  try {
    const item = mark.items[0],
          caption = opt.caption || (() => '');

    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}

function titleCaption(item) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(item.text).join(' ');
}

function axisCaption(item) {
  const datum = item.datum,
        orient = item.orient,
        title = datum.title ? extractTitle(item) : null,
        ctx = item.context,
        scale = ctx.scales[datum.scale].value,
        locale = ctx.dataflow.locale(),
        type = scale.type,
        xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';
  return `${xy}-axis` + (title ? ` titled '${title}'` : '') + ` for a ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(type) ? 'discrete' : type} scale` + ` with ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.domainCaption)(locale, scale, item)}`;
}

function legendCaption(item) {
  const datum = item.datum,
        title = datum.title ? extractTitle(item) : null,
        type = `${datum.type || ''} legend`.trim(),
        scales = datum.scales,
        props = Object.keys(scales),
        ctx = item.context,
        scale = ctx.scales[scales[props[0]]].value,
        locale = ctx.dataflow.locale();
  return capitalize(type) + (title ? ` titled '${title}'` : '') + ` for ${channelCaption(props)}` + ` with ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.domainCaption)(locale, scale, item)}`;
}

function extractTitle(item) {
  try {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(item.items).items[0].text).join(' ');
  } catch (err) {
    return null;
  }
}

function channelCaption(props) {
  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(props);
}

function capitalize(s) {
  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
}

const innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

const attrText = val => innerText(val).replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');

function markup() {
  let buf = '',
      outer = '',
      inner = '';

  const stack = [],
        clear = () => outer = inner = '',
        push = tag => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear();
    }

    stack.push(tag);
  },
        attr = (name, value) => {
    if (value != null) outer += ` ${name}="${attrText(value)}"`;
    return m;
  },
        m = {
    open(tag, ...attrs) {
      push(tag);
      outer = '<' + tag;

      for (const set of attrs) {
        for (const key in set) attr(key, set[key]);
      }

      return m;
    },

    close() {
      const tag = stack.pop();

      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : '/>');
      } else {
        buf += `</${tag}>`;
      }

      clear();
      return m;
    },

    attr,
    text: t => (inner += innerText(t), m),
    toString: () => buf
  };

  return m;
}
const serializeXML = node => _serialize(markup(), node) + '';

function _serialize(m, node) {
  m.open(node.tagName);

  if (node.hasAttributes()) {
    const attrs = node.attributes,
          n = attrs.length;

    for (let i = 0; i < n; ++i) {
      m.attr(attrs[i].name, attrs[i].value);
    }
  }

  if (node.hasChildNodes()) {
    const children = node.childNodes,
          n = children.length;

    for (let i = 0; i < n; i++) {
      const child = children[i];
      child.nodeType === 3 // text node
      ? m.text(child.nodeValue) : _serialize(m, child);
    }
  }

  return m.close();
}

const styles = {
  fill: 'fill',
  fillOpacity: 'fill-opacity',
  stroke: 'stroke',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  strokeCap: 'stroke-linecap',
  strokeJoin: 'stroke-linejoin',
  strokeDash: 'stroke-dasharray',
  strokeDashOffset: 'stroke-dashoffset',
  strokeMiterLimit: 'stroke-miterlimit',
  opacity: 'opacity',
  blend: 'mix-blend-mode'
}; // ensure miter limit default is consistent with canvas (#2498)

const rootAttributes = {
  'fill': 'none',
  'stroke-miterlimit': 10
};

const RootIndex = 0,
      xmlns = 'http://www.w3.org/2000/xmlns/',
      svgns = metadata.xmlns;
function SVGRenderer(loader) {
  Renderer.call(this, loader);
  this._dirtyID = 0;
  this._dirty = [];
  this._svg = null;
  this._root = null;
  this._defs = null;
}
const base = Renderer.prototype;
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(SVGRenderer, Renderer, {
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width, height, origin, scaleFactor) {
    // create the svg definitions cache
    this._defs = {};

    this._clearDefs();

    if (el) {
      this._svg = domChild(el, 0, 'svg', svgns);

      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);

      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);

      this._svg.setAttribute('version', metadata['version']);

      this._svg.setAttribute('class', 'marks');

      domClear(el, 1); // set the svg root group

      this._root = domChild(this._svg, RootIndex, 'g', svgns);
      setAttributes(this._root, rootAttributes); // ensure no additional child elements

      domClear(this._svg, RootIndex + 1);
    } // set background color if defined


    this.background(this._bgcolor);
    return base.initialize.call(this, el, width, height, origin, scaleFactor);
  },

  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty('background-color', bgcolor);
    }

    return base.background.apply(this, arguments);
  },

  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width, height, origin, scaleFactor) {
    base.resize.call(this, width, height, origin, scaleFactor);

    if (this._svg) {
      setAttributes(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });

      this._root.setAttribute('transform', `translate(${this._origin})`);
    }

    this._dirty = [];
    return this;
  },

  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  },

  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg,
          bg = this._bgcolor;
    if (!svg) return null;
    let node;

    if (bg) {
      svg.removeAttribute('style');
      node = domChild(svg, RootIndex, 'rect', svgns);
      setAttributes(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }

    const text = serializeXML(svg);

    if (bg) {
      svg.removeChild(node);

      this._svg.style.setProperty('background-color', bg);
    }

    return text;
  },

  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    // perform spot updates and re-render markup
    if (this._dirtyCheck()) {
      if (this._dirtyAll) this._clearDefs();
      this.mark(this._root, scene);
      domClear(this._root, 1);
    }

    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  },

  // -- Manage rendering of items marked as dirty --

  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;

      this._dirty.push(item);
    }
  },

  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;
  },

  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID) return true;
    const id = ++this._dirtyID;
    let item, mark, type, mdef, i, n, o;

    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;

      if (mark.marktype !== type) {
        // memoize mark instance lookup
        type = mark.marktype;
        mdef = Marks[type];
      }

      if (mark.zdirty && mark.dirty !== id) {
        this._dirtyAll = false;
        dirtyParents(item, id);
        mark.items.forEach(i => {
          i.dirty = id;
        });
      }

      if (mark.zdirty) continue; // handle in standard drawing pass

      if (item.exit) {
        // EXIT
        if (mdef.nested && mark.items.length) {
          // if nested mark with remaining points, update instead
          o = mark.items[0];
          if (o._svg) this._update(mdef, o._svg, o);
        } else if (item._svg) {
          // otherwise remove from DOM
          o = item._svg.parentNode;
          if (o) o.removeChild(item._svg);
        }

        item._svg = null;
        continue;
      }

      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id) continue; // already visited

      if (!item._svg || !item._svg.ownerSVGElement) {
        // ENTER
        this._dirtyAll = false;
        dirtyParents(item, id);
      } else {
        // IN-PLACE UPDATE
        this._update(mdef, item._svg, item);
      }

      item._update = id;
    }

    return !this._dirtyAll;
  },

  // -- Construct & maintain scenegraph to SVG mapping ---

  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   */
  mark(el, scene, prev) {
    if (!this.isDirty(scene)) return scene._svg;
    const svg = this._svg,
          mdef = Marks[scene.marktype],
          events = scene.interactive === false ? 'none' : null,
          isGroup = mdef.tag === 'g';
    let sibling = null,
        i = 0;
    const parent = bind(scene, el, prev, 'g', svg);
    parent.setAttribute('class', cssClass(scene)); // apply aria attributes to parent container element

    const aria = ariaMarkAttributes(scene);

    for (const key in aria) setAttribute(parent, key, aria[key]);

    if (!isGroup) {
      setAttribute(parent, 'pointer-events', events);
    }

    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);

    const process = item => {
      const dirty = this.isDirty(item),
            node = bind(item, parent, sibling, mdef.tag, svg);

      if (dirty) {
        this._update(mdef, node, item);

        if (isGroup) recurse(this, node, item);
      }

      sibling = node;
      ++i;
    };

    if (mdef.nested) {
      if (scene.items.length) process(scene.items[0]);
    } else {
      visit(scene, process);
    }

    domClear(parent, i);
    return parent;
  },

  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    // set dom element and values cache
    // provides access to emit method
    element = el;
    values = el.__values__; // apply aria-specific properties

    ariaItemAttributes(emit, item); // apply svg attributes

    mdef.attr(emit, item, this); // some marks need special treatment

    const extra = mark_extras[mdef.type];
    if (extra) extra.call(this, mdef, el, item); // apply svg style attributes
    // note: element state may have been modified by 'extra' method

    if (element) this.style(element, item);
  },

  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null) return;

    for (const prop in styles) {
      let value = prop === 'font' ? fontFamily(item) : item[prop];
      if (value === values[prop]) continue;
      const name = styles[prop];

      if (value == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient(value)) {
          value = gradientRef(value, this._defs.gradient, href());
        }

        el.setAttribute(name, value + '');
      }

      values[prop] = value;
    }
  },

  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg,
          defs = this._defs;
    let el = defs.el,
        index = 0;

    for (const id in defs.gradient) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
      index = updateGradient(el, defs.gradient[id], index);
    }

    for (const id in defs.clipping) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
      index = updateClipping(el, defs.clipping[id], index);
    } // clean-up


    if (el) {
      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);
    }
  },

  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def = this._defs;
    def.gradient = {};
    def.clipping = {};
  }

}); // mark ancestor chain with a dirty id

function dirtyParents(item, id) {
  for (; item && item.dirty !== id; item = item.mark.group) {
    item.dirty = id;

    if (item.mark && item.mark.dirty !== id) {
      item.mark.dirty = id;
    } else return;
  }
} // update gradient definitions


function updateGradient(el, grad, index) {
  let i, n, stop;

  if (grad.gradient === 'radial') {
    // SVG radial gradients automatically transform to normalized bbox
    // coordinates, in a way that is cumbersome to replicate in canvas.
    // We wrap the radial gradient in a pattern element, allowing us to
    // maintain a circular gradient that matches what canvas provides.
    let pt = domChild(el, index++, 'pattern', svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: '0,0,1,1',
      width: '100%',
      height: '100%',
      preserveAspectRatio: 'xMidYMid slice'
    });
    pt = domChild(pt, 0, 'rect', svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: `url(${href()}#${grad.id})`
    });
    el = domChild(el, index++, 'radialGradient', svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index++, 'linearGradient', svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }

  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop = domChild(el, i, 'stop', svgns);
    stop.setAttribute('offset', grad.stops[i].offset);
    stop.setAttribute('stop-color', grad.stops[i].color);
  }

  domClear(el, i);
  return index;
} // update clipping path definitions


function updateClipping(el, clip, index) {
  let mask;
  el = domChild(el, index, 'clipPath', svgns);
  el.setAttribute('id', clip.id);

  if (clip.path) {
    mask = domChild(el, 0, 'path', svgns);
    mask.setAttribute('d', clip.path);
  } else {
    mask = domChild(el, 0, 'rect', svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip.width,
      height: clip.height
    });
  }

  domClear(el, 1);
  return index + 1;
} // Recursively process group contents.


function recurse(renderer, el, group) {
  el = el.lastChild.previousSibling;
  let prev,
      idx = 0;
  visit(group, item => {
    prev = renderer.mark(el, item, prev);
    ++idx;
  }); // remove any extraneous DOM elements

  domClear(el, 1 + idx);
} // Bind a scenegraph item to an SVG DOM element.
// Create new SVG elements as needed.


function bind(item, el, sibling, tag, svg) {
  let node = item._svg,
      doc; // create a new dom node if needed

  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;

    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: 'default'
      }; // if group, create background, content, and foreground elements

      if (tag === 'g') {
        const bg = domCreate(doc, 'path', svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, 'g', svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, 'path', svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: 'default'
        };
      }
    }
  } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed


  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }

  return node;
} // check if two nodes are ordered siblings


function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same
} // -- Set attributes & styles on SVG elements ---


let element = null,
    // temp var for current SVG element
values = null; // temp var for current values hash
// Extra configuration for certain mark types

const mark_extras = {
  group(mdef, el, item) {
    const fg = element = el.childNodes[2];
    values = fg.__values__;
    mdef.foreground(emit, item, this);
    values = el.__values__; // use parent's values hash

    element = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element = el.childNodes[0];
    mdef.background(emit, item, this);
    const value = item.mark.interactive === false ? 'none' : null;

    if (value !== values.events) {
      setAttribute(fg, 'pointer-events', value);
      setAttribute(bg, 'pointer-events', value);
      values.events = value;
    }

    if (item.strokeForeground && item.stroke) {
      const fill = item.fill;
      setAttribute(fg, 'display', null); // set style of background

      this.style(bg, item);
      setAttribute(bg, 'stroke', null); // set style of foreground

      if (fill) item.fill = null;
      values = fg.__values__;
      this.style(fg, item);
      if (fill) item.fill = fill; // leave element null to prevent downstream styling

      element = null;
    } else {
      // ensure foreground is ignored
      setAttribute(fg, 'display', 'none');
    }
  },

  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, 'image-rendering', 'optimizeSpeed');
      setStyle(el, 'image-rendering', 'pixelated');
    } else {
      setStyle(el, 'image-rendering', null);
    }
  },

  text(mdef, el, item) {
    const tl = textLines(item);
    let key, value, doc, lh;

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
      // multi-line text
      value = tl.map(_ => textValue(item, _));
      key = value.join('\n'); // content cache key

      if (key !== values.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value.forEach((t, i) => {
          const ts = domCreate(doc, 'tspan', svgns);
          ts.__data__ = item; // data binding

          ts.textContent = t;

          if (i) {
            ts.setAttribute('x', 0);
            ts.setAttribute('dy', lh);
          }

          el.appendChild(ts);
        });
        values.text = key;
      }
    } else {
      // single-line text
      value = textValue(item, tl);

      if (value !== values.text) {
        el.textContent = value;
        values.text = value;
      }
    }

    setAttribute(el, 'font-family', fontFamily(item));
    setAttribute(el, 'font-size', fontSize(item) + 'px');
    setAttribute(el, 'font-style', item.fontStyle);
    setAttribute(el, 'font-variant', item.fontVariant);
    setAttribute(el, 'font-weight', item.fontWeight);
  }

};

function emit(name, value, ns) {
  // early exit if value is unchanged
  if (value === values[name]) return; // use appropriate method given namespace (ns)

  if (ns) {
    setAttributeNS(element, name, value, ns);
  } else {
    setAttribute(element, name, value);
  } // note current value for future comparison


  values[name] = value;
}

function setStyle(el, name, value) {
  if (value !== values[name]) {
    if (value == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value + '');
    }

    values[name] = value;
  }
}

function setAttributes(el, attrs) {
  for (const key in attrs) {
    setAttribute(el, key, attrs[key]);
  }
}

function setAttribute(el, name, value) {
  if (value != null) {
    // if value is provided, update DOM attribute
    el.setAttribute(name, value);
  } else {
    // else remove DOM attribute
    el.removeAttribute(name);
  }
}

function setAttributeNS(el, name, value, ns) {
  if (value != null) {
    // if value is provided, update DOM attribute
    el.setAttributeNS(ns, name, value);
  } else {
    // else remove DOM attribute
    el.removeAttributeNS(ns, name);
  }
}

function href() {
  let loc;
  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}

function SVGStringRenderer(loader) {
  Renderer.call(this, loader);
  this._text = null;
  this._defs = {
    gradient: {},
    clipping: {}
  };
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(SVGStringRenderer, Renderer, {
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  },

  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m = markup(); // svg tag

    m.open('svg', (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, metadata, {
      class: 'marks',
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    })); // background, if defined

    const bg = this._bgcolor;

    if (bg && bg !== 'transparent' && bg !== 'none') {
      m.open('rect', {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    } // root content group


    m.open('g', rootAttributes, {
      transform: 'translate(' + this._origin + ')'
    });
    this.mark(m, scene);
    m.close(); // </g>
    // defs

    this.defs(m); // get SVG text string

    this._text = m.close() + '';
    return this;
  },

  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m, scene) {
    const mdef = Marks[scene.marktype],
          tag = mdef.tag,
          attrList = [ariaItemAttributes, mdef.attr]; // render opening group tag

    m.open('g', {
      'class': cssClass(scene),
      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null
    }); // render contained elements

    const process = item => {
      const href = this.href(item);
      if (href) m.open('a', href);
      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));

      if (tag === 'text') {
        const tl = textLines(item);

        if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
          // multi-line text
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };

          for (let i = 0; i < tl.length; ++i) {
            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();
          }
        } else {
          // single-line text
          m.text(textValue(item, tl));
        }
      } else if (tag === 'g') {
        const fore = item.strokeForeground,
              fill = item.fill,
              stroke = item.stroke;

        if (fore && stroke) {
          item.stroke = null;
        }

        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close(); // recurse for group content

        m.open('g', this.attr(scene, item, mdef.content));
        visit(item, scene => this.mark(m, scene));
        m.close();

        if (fore && stroke) {
          if (fill) item.fill = null;
          item.stroke = stroke;
          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();
          if (fill) item.fill = fill;
        } else {
          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();
        }
      }

      m.close(); // </tag>

      if (href) m.close(); // </a>
    };

    if (mdef.nested) {
      if (scene.items && scene.items.length) process(scene.items[0]);
    } else {
      visit(scene, process);
    } // render closing group tag


    return m.close(); // </g>
  },

  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href = item.href;
    let attr;

    if (href) {
      if (attr = this._hrefs && this._hrefs[href]) {
        return attr;
      } else {
        this.sanitizeURL(href).then(attr => {
          // rewrite to use xlink namespace
          attr['xlink:href'] = attr.href;
          attr.href = null;
          (this._hrefs || (this._hrefs = {}))[href] = attr;
        });
      }
    }

    return null;
  },

  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object = {},
          emit = (name, value, ns, prefixed) => {
      object[prefixed || name] = value;
    }; // apply mark specific attributes


    if (Array.isArray(attrs)) {
      attrs.forEach(fn => fn(emit, item, this));
    } else {
      attrs(emit, item, this);
    } // apply style attributes


    if (tag) {
      style(object, item, scene, tag, this._defs);
    }

    return object;
  },

  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m) {
    const gradient = this._defs.gradient,
          clipping = this._defs.clipping,
          count = Object.keys(gradient).length + Object.keys(clipping).length;
    if (count === 0) return; // nothing to do

    m.open('defs');

    for (const id in gradient) {
      const def = gradient[id],
            stops = def.stops;

      if (def.gradient === 'radial') {
        // SVG radial gradients automatically transform to normalized bbox
        // coordinates, in a way that is cumbersome to replicate in canvas.
        // We wrap the radial gradient in a pattern element, allowing us to
        // maintain a circular gradient that matches what canvas provides.
        m.open('pattern', {
          id: patternPrefix + id,
          viewBox: '0,0,1,1',
          width: '100%',
          height: '100%',
          preserveAspectRatio: 'xMidYMid slice'
        });
        m.open('rect', {
          width: '1',
          height: '1',
          fill: 'url(#' + id + ')'
        }).close();
        m.close(); // </pattern>

        m.open('radialGradient', {
          id: id,
          fx: def.x1,
          fy: def.y1,
          fr: def.r1,
          cx: def.x2,
          cy: def.y2,
          r: def.r2
        });
      } else {
        m.open('linearGradient', {
          id: id,
          x1: def.x1,
          x2: def.x2,
          y1: def.y1,
          y2: def.y2
        });
      }

      for (let i = 0; i < stops.length; ++i) {
        m.open('stop', {
          offset: stops[i].offset,
          'stop-color': stops[i].color
        }).close();
      }

      m.close();
    }

    for (const id in clipping) {
      const def = clipping[id];
      m.open('clipPath', {
        id: id
      });

      if (def.path) {
        m.open('path', {
          d: def.path
        }).close();
      } else {
        m.open('rect', {
          x: 0,
          y: 0,
          width: def.width,
          height: def.height
        }).close();
      }

      m.close();
    }

    m.close();
  }

}); // Helper function for attr for style presentation attributes

function style(s, item, scene, tag, defs) {
  if (item == null) return s;

  if (tag === 'bgrect' && scene.interactive === false) {
    s['pointer-events'] = 'none';
  }

  if (tag === 'bgfore') {
    if (scene.interactive === false) {
      s['pointer-events'] = 'none';
    }

    s.display = 'none';
    if (item.fill !== null) return s;
  }

  if (tag === 'image' && item.smooth === false) {
    s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';
  }

  if (tag === 'text') {
    s['font-family'] = fontFamily(item);
    s['font-size'] = fontSize(item) + 'px';
    s['font-style'] = item.fontStyle;
    s['font-variant'] = item.fontVariant;
    s['font-weight'] = item.fontWeight;
  }

  for (const prop in styles) {
    let value = item[prop];
    const name = styles[prop];

    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {
      if (isGradient(value)) {
        value = gradientRef(value, defs.gradient, '');
      }

      s[name] = value;
    }
  }

  return s;
}

const Canvas = 'canvas';
const PNG = 'png';
const SVG = 'svg';
const None = 'none';
const RenderType = {
  Canvas: Canvas,
  PNG: PNG,
  SVG: SVG,
  None: None
};
const modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[None] = {};
function renderModule(name, _) {
  name = String(name || '').toLowerCase();

  if (arguments.length > 1) {
    modules[name] = _;
    return this;
  } else {
    return modules[name];
  }
}

function intersect(scene, bounds, filter) {
  const hits = [],
        // intersection results
  box = new Bounds().union(bounds),
        // defensive copy
  type = scene.marktype;
  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Intersect scene must be mark node or group item.');
}

function intersectMark(mark, box, filter, hits) {
  if (visitMark(mark, box, filter)) {
    const items = mark.items,
          type = mark.marktype,
          n = items.length;
    let i = 0;

    if (type === 'group') {
      for (; i < n; ++i) {
        intersectGroup(items[i], box, filter, hits);
      }
    } else {
      for (const test = Marks[type].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem(item, box, test)) hits.push(item);
      }
    }
  }

  return hits;
}

function visitMark(mark, box, filter) {
  // process if bounds intersect and if
  // (1) mark is a group mark (so we must recurse), or
  // (2) mark is interactive and passes filter
  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));
}

function intersectGroup(group, box, filter, hits) {
  // test intersect against group
  // skip groups by default unless filter says otherwise
  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {
    hits.push(group);
  } // recursively test children marks
  // translate box to group coordinate space


  const marks = group.items,
        n = marks && marks.length;

  if (n) {
    const x = group.x || 0,
          y = group.y || 0;
    box.translate(-x, -y);

    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter, hits);
    }

    box.translate(x, y);
  }

  return hits;
}

function intersectItem(item, box, test) {
  // test bounds enclosure, bounds intersection, then detailed test
  const bounds = item.bounds;
  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);
}

const clipBounds = new Bounds();
function boundClip (mark) {
  const clip = mark.clip;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    clip(boundContext(clipBounds.clear()));
  } else if (clip) {
    clipBounds.set(0, 0, mark.group.width, mark.group.height);
  } else return;

  mark.bounds.intersect(clipBounds);
}

const TOLERANCE = 1e-9;
function sceneEqual(a, b, key) {
  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(a) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(b) ? a == b : objectEqual(a, b);
}
function pathEqual(a, b) {
  return sceneEqual(pathParse(a), pathParse(b));
}

function objectEqual(a, b) {
  var ka = Object.keys(a),
      kb = Object.keys(b),
      key,
      i;
  if (ka.length !== kb.length) return false;
  ka.sort();
  kb.sort();

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) return false;
  }

  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!sceneEqual(a[key], b[key], key)) return false;
  }

  return typeof a === typeof b;
}

function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}




/***/ }),

/***/ "../../node_modules/vega-selections/build/vega-selection.module.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/vega-selections/build/vega-selection.module.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "selectionIdTest": () => (/* binding */ selectionIdTest),
/* harmony export */   "selectionResolve": () => (/* binding */ selectionResolve),
/* harmony export */   "selectionTest": () => (/* binding */ selectionTest),
/* harmony export */   "selectionTuples": () => (/* binding */ selectionTuples),
/* harmony export */   "selectionVisitor": () => (/* binding */ selectionVisitor)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-expression */ "../../node_modules/vega-expression/build/vega-expression.module.js");



function ascending (a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector (f) {
  let delta = f;
  let compare = f;

  if (f.length === 1) {
    delta = (d, x) => f(d) - x;

    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
    }

    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
    }

    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {
    left,
    center,
    right
  };
}

function ascendingComparator(f) {
  return (d, x) => ascending(f(d), x);
}

const Intersect = 'intersect';
const Union = 'union';
const VlMulti = 'vlMulti';
const VlPoint = 'vlPoint';
const Or = 'or';
const And = 'and';

const SELECTION_ID = '_vgsid_',
      TYPE_ENUM = 'E',
      TYPE_RANGE_INC = 'R',
      TYPE_RANGE_EXC = 'R-E',
      TYPE_RANGE_LE = 'R-LE',
      TYPE_RANGE_RE = 'R-RE',
      UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?

function testPoint(datum, entry) {
  var fields = entry.fields,
      values = entry.values,
      n = fields.length,
      i = 0,
      dval,
      f;

  for (; i < n; ++i) {
    f = fields[i];
    f.getter = vega_util__WEBPACK_IMPORTED_MODULE_0__.field.getter || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f.field);
    dval = f.getter(datum);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(dval)) dval = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(dval);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(values[i])) values[i] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(values[i]);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(values[i][0])) values[i] = values[i].map(vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber);

    if (f.type === TYPE_ENUM) {
      // Enumerated fields can either specify individual values (single/multi selections)
      // or an array of values (interval selections).
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i])) return false;
      } else if (f.type === TYPE_RANGE_RE) {
        // Discrete selection of bins test within the range [bin_start, bin_end).
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], true, false)) return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        // 'R-E'/'R-LE' included for completeness.
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], false, false)) return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], false, true)) return false;
      }
    }
  }

  return true;
}
/**
 * Tests if a tuple is contained within an interactive selection.
 * @param {string} name - The name of the data set representing the selection.
 *  Tuples in the dataset are of the form
 *  {unit: string, fields: array<fielddef>, values: array<*>}.
 *  Fielddef is of the form
 *  {field: string, channel: string, type: 'E' | 'R'} where
 *  'type' identifies whether tuples in the dataset enumerate
 *  values for the field, or specify a continuous range.
 * @param {object} datum - The tuple to test for inclusion.
 * @param {string} op - The set operation for combining selections.
 *   One of 'intersect' or 'union' (default).
 * @return {boolean} - True if the datum is in the selection, false otherwise.
 */


function selectionTest(name, datum, op) {
  var data = this.context.data[name],
      entries = data ? data.values.value : [],
      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,
      intersect = op === Intersect,
      n = entries.length,
      i = 0,
      entry,
      miss,
      count,
      unit,
      b;

  for (; i < n; ++i) {
    entry = entries[i];

    if (unitIdx && intersect) {
      // multi selections union within the same unit and intersect across units.
      miss = miss || {};
      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.

      if (count === -1) continue;
      b = testPoint(datum, entry);
      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true
      // if we've missed against all tuples in this unit return false

      if (b && unitIdx.size === 1) return true;
      if (!b && count === unitIdx.get(unit).count) return false;
    } else {
      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false
      // if we find a match and we don't require intersection return true

      if (intersect ^ b) return b;
    }
  } // if intersecting and we made it here, then we saw no misses
  // if not intersecting, then we saw no matches
  // if no active selections, return false


  return n && intersect;
}
const selectionId = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(SELECTION_ID),
      bisect = bisector(selectionId),
      bisectLeft = bisect.left,
      bisectRight = bisect.right;
function selectionIdTest(name, datum, op) {
  const data = this.context.data[name],
        entries = data ? data.values.value : [],
        unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,
        intersect = op === Intersect,
        value = selectionId(datum),
        index = bisectLeft(entries, value);
  if (index === entries.length) return false;
  if (selectionId(entries[index]) !== value) return false;

  if (unitIdx && intersect) {
    if (unitIdx.size === 1) return true;
    if (bisectRight(entries, value) - index < unitIdx.size) return false;
  }

  return true;
}

/**
 * Maps an array of scene graph items to an array of selection tuples.
 * @param {string} name  - The name of the dataset representing the selection.
 * @param {string} unit  - The name of the unit view.
 *
 * @returns {array} An array of selection entries for the given unit.
 */

function selectionTuples(array, base) {
  return array.map(x => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    values: base.fields.map(f => (f.getter || (f.getter = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f.field)))(x.datum))
  }, base));
}

/**
 * Resolves selection for use as a scale domain or reads via the API.
 * @param {string} name - The name of the dataset representing the selection
 * @param {string} [op='union'] - The set operation for combining selections.
 *                 One of 'intersect' or 'union' (default).
 * @param {boolean} isMulti - Identifies a "multi" selection to perform more
 *                 expensive resolution computation.
 * @param {boolean} vl5 - With Vega-Lite v5, "multi" selections are now called "point"
 *                 selections, and thus the resolved tuple should reflect this name.
 *                 This parameter allows us to reflect this change without triggering
 *                 a major version bump for Vega.
 * @returns {object} An object of selected fields and values.
 */

function selectionResolve(name, op, isMulti, vl5) {
  var data = this.context.data[name],
      entries = data ? data.values.value : [],
      resolved = {},
      multiRes = {},
      types = {},
      entry,
      fields,
      values,
      unit,
      field,
      res,
      resUnit,
      type,
      union,
      n = entries.length,
      i = 0,
      j,
      m; // First union all entries within the same unit.

  for (; i < n; ++i) {
    entry = entries[i];
    unit = entry.unit;
    fields = entry.fields;
    values = entry.values;

    for (j = 0, m = fields.length; j < m; ++j) {
      field = fields[j];
      res = resolved[field.field] || (resolved[field.field] = {});
      resUnit = res[unit] || (res[unit] = []);
      types[field.field] = type = field.type.charAt(0);
      union = ops[type + '_union'];
      res[unit] = union(resUnit, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(values[j]));
    } // If the same multi-selection is repeated over views and projected over
    // an encoding, it may operate over different fields making it especially
    // tricky to reliably resolve it. At best, we can de-dupe identical entries
    // but doing so may be more computationally expensive than it is worth.
    // Instead, for now, we simply transform our store representation into
    // a more human-friendly one.


    if (isMulti) {
      resUnit = multiRes[unit] || (multiRes[unit] = []);
      resUnit.push((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));
    }
  } // Then resolve fields across units as per the op.


  op = op || Union;
  Object.keys(resolved).forEach(field => {
    resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));
  });
  entries = Object.keys(multiRes);

  if (isMulti && entries.length) {
    const key = vl5 ? VlPoint : VlMulti;
    resolved[key] = op === Union ? {
      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])
    } : {
      [And]: entries.map(k => ({
        [Or]: multiRes[k]
      }))
    };
  }

  return resolved;
}
var ops = {
  E_union: function (base, value) {
    if (!base.length) return value;
    var i = 0,
        n = value.length;

    for (; i < n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);

    return base;
  },
  E_intersect: function (base, value) {
    return !base.length ? value : base.filter(v => value.indexOf(v) >= 0);
  },
  R_union: function (base, value) {
    var lo = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[0]),
        hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[1]);

    if (lo > hi) {
      lo = value[1];
      hi = value[0];
    }

    if (!base.length) return [lo, hi];
    if (base[0] > lo) base[0] = lo;
    if (base[1] < hi) base[1] = hi;
    return base;
  },
  R_intersect: function (base, value) {
    var lo = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[0]),
        hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[1]);

    if (lo > hi) {
      lo = value[1];
      hi = value[0];
    }

    if (!base.length) return [lo, hi];

    if (hi < base[0] || base[1] < lo) {
      return [];
    } else {
      if (base[0] < lo) base[0] = lo;
      if (base[1] > hi) base[1] = hi;
    }

    return base;
  }
};

const DataPrefix = ':',
      IndexPrefix = '@';
function selectionVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to selection functions must be a string literal.');
  const data = args[0].value,
        op = args.length >= 2 && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(args).value,
        field = 'unit',
        indexName = IndexPrefix + field,
        dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins

  if (op === Intersect && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, indexName)) {
    params[indexName] = scope.getData(data).indataRef(scope, field);
  } // eslint-disable-next-line no-prototype-builtins


  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, dataName)) {
    params[dataName] = scope.getData(data).tuplesRef();
  }
}




/***/ }),

/***/ "../../node_modules/vega-statistics/build/vega-statistics.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-statistics/build/vega-statistics.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bandwidthNRD": () => (/* binding */ estimateBandwidth),
/* harmony export */   "bin": () => (/* binding */ bin),
/* harmony export */   "bootstrapCI": () => (/* binding */ bootstrapCI),
/* harmony export */   "cumulativeLogNormal": () => (/* binding */ cumulativeLogNormal),
/* harmony export */   "cumulativeNormal": () => (/* binding */ cumulativeNormal),
/* harmony export */   "cumulativeUniform": () => (/* binding */ cumulativeUniform),
/* harmony export */   "densityLogNormal": () => (/* binding */ densityLogNormal),
/* harmony export */   "densityNormal": () => (/* binding */ densityNormal),
/* harmony export */   "densityUniform": () => (/* binding */ densityUniform),
/* harmony export */   "dotbin": () => (/* binding */ dotbin),
/* harmony export */   "quantileLogNormal": () => (/* binding */ quantileLogNormal),
/* harmony export */   "quantileNormal": () => (/* binding */ quantileNormal),
/* harmony export */   "quantileUniform": () => (/* binding */ quantileUniform),
/* harmony export */   "quantiles": () => (/* binding */ quantiles),
/* harmony export */   "quartiles": () => (/* binding */ quartiles),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "randomInteger": () => (/* binding */ integer),
/* harmony export */   "randomKDE": () => (/* binding */ kde),
/* harmony export */   "randomLCG": () => (/* binding */ lcg),
/* harmony export */   "randomLogNormal": () => (/* binding */ lognormal),
/* harmony export */   "randomMixture": () => (/* binding */ mixture),
/* harmony export */   "randomNormal": () => (/* binding */ gaussian),
/* harmony export */   "randomUniform": () => (/* binding */ uniform),
/* harmony export */   "regressionExp": () => (/* binding */ exp),
/* harmony export */   "regressionLinear": () => (/* binding */ linear),
/* harmony export */   "regressionLoess": () => (/* binding */ loess),
/* harmony export */   "regressionLog": () => (/* binding */ log),
/* harmony export */   "regressionPoly": () => (/* binding */ poly),
/* harmony export */   "regressionPow": () => (/* binding */ pow),
/* harmony export */   "regressionQuad": () => (/* binding */ quad),
/* harmony export */   "sampleCurve": () => (/* binding */ sampleCurve),
/* harmony export */   "sampleLogNormal": () => (/* binding */ sampleLogNormal),
/* harmony export */   "sampleNormal": () => (/* binding */ sampleNormal),
/* harmony export */   "sampleUniform": () => (/* binding */ sampleUniform),
/* harmony export */   "setRandom": () => (/* binding */ setRandom)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ascending.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/deviation.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/median.js");


function* numbers (values, valueof) {
  if (valueof == null) {
    for (let value of values) {
      if (value != null && value !== '' && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;

    for (let value of values) {
      value = valueof(value, ++index, values);

      if (value != null && value !== '' && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

function quantiles (array, p, f) {
  const values = Float64Array.from(numbers(array, f)); // don't depend on return value from typed array sort call
  // protects against undefined sort results in Safari (vega/vega-lite#4964)

  values.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__.default);
  return p.map(_ => (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.quantileSorted)(values, _));
}

function quartiles (array, f) {
  return quantiles(array, [0.25, 0.50, 0.75], f);
}

// Theory, Practice, and Visualization. Wiley.

function estimateBandwidth (array, f) {
  const n = array.length,
        d = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(array, f),
        q = quartiles(array, f),
        h = (q[2] - q[0]) / 1.34,
        v = Math.min(d, h) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}

function bin (_) {
  // determine range
  const maxb = _.maxbins || 20,
        base = _.base || 10,
        logb = Math.log(base),
        div = _.divide || [5, 2];
  let min = _.extent[0],
      max = _.extent[1],
      step,
      level,
      minstep,
      v,
      i,
      n;
  const span = _.span || max - min || Math.abs(min) || 1;

  if (_.step) {
    // if step size is explicitly given, use that
    step = _.step;
  } else if (_.steps) {
    // if provided, limit choice to acceptable step sizes
    v = span / maxb;

    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i);

    step = _.steps[Math.max(0, i - 1)];
  } else {
    // else use span to determine step size
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base, Math.round(Math.log(span) / logb) - level)); // increase step size if too many bins

    while (Math.ceil(span / step) > maxb) {
      step *= base;
    } // decrease step size if allowed


    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span / v <= maxb) step = v;
    }
  } // update precision, min and max


  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1,
        eps = Math.pow(base, -precision - 1);

  if (_.nice || _.nice === undefined) {
    v = Math.floor(min / step + eps) * step;
    min = min < v ? v - step : v;
    max = Math.ceil(max / step) * step;
  }

  return {
    start: min,
    stop: max === min ? min + step : max,
    step: step
  };
}

var random = Math.random;
function setRandom(r) {
  random = r;
}

function bootstrapCI (array, samples, alpha, f) {
  if (!array.length) return [undefined, undefined];
  const values = Float64Array.from(numbers(array, f)),
        n = values.length,
        m = samples;
  let a, i, j, mu;

  for (j = 0, mu = Array(m); j < m; ++j) {
    for (a = 0, i = 0; i < n; ++i) {
      a += values[~~(random() * n)];
    }

    mu[j] = a / n;
  }

  mu.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__.default);
  return [(0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(mu, alpha / 2), (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(mu, 1 - alpha / 2)];
}

// Dot density binning for dot plot construction.
// Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.
// https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf
function dotbin (array, step, smooth, f) {
  f = f || (_ => _);

  const n = array.length,
        v = new Float64Array(n);
  let i = 0,
      j = 1,
      a = f(array[0]),
      b = a,
      w = a + step,
      x;

  for (; j < n; ++j) {
    x = f(array[j]);

    if (x >= w) {
      b = (a + b) / 2;

      for (; i < j; ++i) v[i] = b;

      w = x + step;
      a = x;
    }

    b = x;
  }

  b = (a + b) / 2;

  for (; i < j; ++i) v[i] = b;

  return smooth ? smoothing(v, step + step / 4) : v;
} // perform smoothing to reduce variance
// swap points between "adjacent" stacks
// Wilkinson defines adjacent as within step/4 units

function smoothing(v, thresh) {
  const n = v.length;
  let a = 0,
      b = 1,
      c,
      d; // get left stack

  while (v[a] === v[b]) ++b;

  while (b < n) {
    // get right stack
    c = b + 1;

    while (v[b] === v[c]) ++c; // are stacks adjacent?
    // if so, compare sizes and swap as needed


    if (v[b] - v[b - 1] < thresh) {
      d = b + (a + c - b - b >> 1);

      while (d < b) v[d++] = v[b];

      while (d > b) v[d--] = v[a];
    } // update left stack indices


    a = b;
    b = c;
  }

  return v;
}

function lcg (seed) {
  // Random numbers using a Linear Congruential Generator with seed value
  // Uses glibc values from https://en.wikipedia.org/wiki/Linear_congruential_generator
  return function () {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}

function integer (min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }

  let a, b, d;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        d = b - a;
        return dist;
      } else {
        return a;
      }
    },

    max(_) {
      if (arguments.length) {
        b = _ || 0;
        d = b - a;
        return dist;
      } else {
        return b;
      }
    },

    sample() {
      return a + Math.floor(d * random());
    },

    pdf(x) {
      return x === Math.floor(x) && x >= a && x < b ? 1 / d : 0;
    },

    cdf(x) {
      const v = Math.floor(x);
      return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;
    },

    icdf(p) {
      return p >= 0 && p <= 1 ? a - 1 + Math.floor(p * d) : NaN;
    }

  };
  return dist.min(min).max(max);
}

const SQRT2PI = Math.sqrt(2 * Math.PI);
const SQRT2 = Math.SQRT2;

let nextSample = NaN;
function sampleNormal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  let x = 0,
      y = 0,
      rds,
      c;

  if (nextSample === nextSample) {
    x = nextSample;
    nextSample = NaN;
  } else {
    do {
      x = random() * 2 - 1;
      y = random() * 2 - 1;
      rds = x * x + y * y;
    } while (rds === 0 || rds > 1);

    c = Math.sqrt(-2 * Math.log(rds) / rds); // Box-Muller transform

    x *= c;
    nextSample = y * c;
  }

  return mean + x * stdev;
}
function densityNormal(value, mean, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value - (mean || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
} // Approximation from West (2009)
// Better Approximations to Cumulative Normal Functions

function cumulativeNormal(value, mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value - mean) / stdev,
        Z = Math.abs(z);
  let cd;

  if (Z > 37) {
    cd = 0;
  } else {
    const exp = Math.exp(-Z * Z / 2);
    let sum;

    if (Z < 7.07106781186547) {
      sum = 3.52624965998911e-02 * Z + 0.700383064443688;
      sum = sum * Z + 6.37396220353165;
      sum = sum * Z + 33.912866078383;
      sum = sum * Z + 112.079291497871;
      sum = sum * Z + 221.213596169931;
      sum = sum * Z + 220.206867912376;
      cd = exp * sum;
      sum = 8.83883476483184e-02 * Z + 1.75566716318264;
      sum = sum * Z + 16.064177579207;
      sum = sum * Z + 86.7807322029461;
      sum = sum * Z + 296.564248779674;
      sum = sum * Z + 637.333633378831;
      sum = sum * Z + 793.826512519948;
      sum = sum * Z + 440.413735824752;
      cd = cd / sum;
    } else {
      sum = Z + 0.65;
      sum = Z + 4 / sum;
      sum = Z + 3 / sum;
      sum = Z + 2 / sum;
      sum = Z + 1 / sum;
      cd = exp / sum / 2.506628274631;
    }
  }

  return z > 0 ? 1 - cd : cd;
} // Approximation of Probit function using inverse error function.

function quantileNormal(p, mean, stdev) {
  if (p < 0 || p > 1) return NaN;
  return (mean || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
} // Approximate inverse error function. Implementation from "Approximating
// the erfinv function" by Mike Giles, GPU Computing Gems, volume 2, 2010.
// Ported from Apache Commons Math, http://www.apache.org/licenses/LICENSE-2.0

function erfinv(x) {
  // beware that the logarithm argument must be
  // commputed as (1.0 - x) * (1.0 + x),
  // it must NOT be simplified as 1.0 - x * x as this
  // would induce rounding errors near the boundaries +/-1
  let w = -Math.log((1 - x) * (1 + x)),
      p;

  if (w < 6.25) {
    w -= 3.125;
    p = -3.6444120640178196996e-21;
    p = -1.685059138182016589e-19 + p * w;
    p = 1.2858480715256400167e-18 + p * w;
    p = 1.115787767802518096e-17 + p * w;
    p = -1.333171662854620906e-16 + p * w;
    p = 2.0972767875968561637e-17 + p * w;
    p = 6.6376381343583238325e-15 + p * w;
    p = -4.0545662729752068639e-14 + p * w;
    p = -8.1519341976054721522e-14 + p * w;
    p = 2.6335093153082322977e-12 + p * w;
    p = -1.2975133253453532498e-11 + p * w;
    p = -5.4154120542946279317e-11 + p * w;
    p = 1.051212273321532285e-09 + p * w;
    p = -4.1126339803469836976e-09 + p * w;
    p = -2.9070369957882005086e-08 + p * w;
    p = 4.2347877827932403518e-07 + p * w;
    p = -1.3654692000834678645e-06 + p * w;
    p = -1.3882523362786468719e-05 + p * w;
    p = 0.0001867342080340571352 + p * w;
    p = -0.00074070253416626697512 + p * w;
    p = -0.0060336708714301490533 + p * w;
    p = 0.24015818242558961693 + p * w;
    p = 1.6536545626831027356 + p * w;
  } else if (w < 16.0) {
    w = Math.sqrt(w) - 3.25;
    p = 2.2137376921775787049e-09;
    p = 9.0756561938885390979e-08 + p * w;
    p = -2.7517406297064545428e-07 + p * w;
    p = 1.8239629214389227755e-08 + p * w;
    p = 1.5027403968909827627e-06 + p * w;
    p = -4.013867526981545969e-06 + p * w;
    p = 2.9234449089955446044e-06 + p * w;
    p = 1.2475304481671778723e-05 + p * w;
    p = -4.7318229009055733981e-05 + p * w;
    p = 6.8284851459573175448e-05 + p * w;
    p = 2.4031110387097893999e-05 + p * w;
    p = -0.0003550375203628474796 + p * w;
    p = 0.00095328937973738049703 + p * w;
    p = -0.0016882755560235047313 + p * w;
    p = 0.0024914420961078508066 + p * w;
    p = -0.0037512085075692412107 + p * w;
    p = 0.005370914553590063617 + p * w;
    p = 1.0052589676941592334 + p * w;
    p = 3.0838856104922207635 + p * w;
  } else if (Number.isFinite(w)) {
    w = Math.sqrt(w) - 5.0;
    p = -2.7109920616438573243e-11;
    p = -2.5556418169965252055e-10 + p * w;
    p = 1.5076572693500548083e-09 + p * w;
    p = -3.7894654401267369937e-09 + p * w;
    p = 7.6157012080783393804e-09 + p * w;
    p = -1.4960026627149240478e-08 + p * w;
    p = 2.9147953450901080826e-08 + p * w;
    p = -6.7711997758452339498e-08 + p * w;
    p = 2.2900482228026654717e-07 + p * w;
    p = -9.9298272942317002539e-07 + p * w;
    p = 4.5260625972231537039e-06 + p * w;
    p = -1.9681778105531670567e-05 + p * w;
    p = 7.5995277030017761139e-05 + p * w;
    p = -0.00021503011930044477347 + p * w;
    p = -0.00013871931833623122026 + p * w;
    p = 1.0103004648645343977 + p * w;
    p = 4.8499064014085844221 + p * w;
  } else {
    p = Infinity;
  }

  return p * x;
}

function gaussian (mean, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },

    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },

    sample: () => sampleNormal(mu, sigma),
    pdf: value => densityNormal(value, mu, sigma),
    cdf: value => cumulativeNormal(value, mu, sigma),
    icdf: p => quantileNormal(p, mu, sigma)
  };
  return dist.mean(mean).stdev(stdev);
}

function kde (support, bandwidth) {
  const kernel = gaussian();
  let n = 0;
  const dist = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist.bandwidth(bandwidth);
      } else {
        return support;
      }
    },

    bandwidth(_) {
      if (!arguments.length) return bandwidth;
      bandwidth = _;
      if (!bandwidth && support) bandwidth = estimateBandwidth(support);
      return dist;
    },

    sample() {
      return support[~~(random() * n)] + bandwidth * kernel.sample();
    },

    pdf(x) {
      let y = 0,
          i = 0;

      for (; i < n; ++i) {
        y += kernel.pdf((x - support[i]) / bandwidth);
      }

      return y / bandwidth / n;
    },

    cdf(x) {
      let y = 0,
          i = 0;

      for (; i < n; ++i) {
        y += kernel.cdf((x - support[i]) / bandwidth);
      }

      return y / n;
    },

    icdf() {
      throw Error('KDE icdf not supported.');
    }

  };
  return dist.data(support);
}

function sampleLogNormal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean + sampleNormal() * stdev);
}
function densityLogNormal(value, mean, stdev) {
  if (value <= 0) return 0;
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value) - mean) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value);
}
function cumulativeLogNormal(value, mean, stdev) {
  return cumulativeNormal(Math.log(value), mean, stdev);
}
function quantileLogNormal(p, mean, stdev) {
  return Math.exp(quantileNormal(p, mean, stdev));
}
function lognormal (mean, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },

    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },

    sample: () => sampleLogNormal(mu, sigma),
    pdf: value => densityLogNormal(value, mu, sigma),
    cdf: value => cumulativeLogNormal(value, mu, sigma),
    icdf: p => quantileLogNormal(p, mu, sigma)
  };
  return dist.mean(mean).stdev(stdev);
}

function mixture (dists, weights) {
  let m = 0,
      w;

  function normalize(x) {
    const w = [];
    let sum = 0,
        i;

    for (i = 0; i < m; ++i) {
      sum += w[i] = x[i] == null ? 1 : +x[i];
    }

    for (i = 0; i < m; ++i) {
      w[i] /= sum;
    }

    return w;
  }

  const dist = {
    weights(_) {
      if (arguments.length) {
        w = normalize(weights = _ || []);
        return dist;
      }

      return weights;
    },

    distributions(_) {
      if (arguments.length) {
        if (_) {
          m = _.length;
          dists = _;
        } else {
          m = 0;
          dists = [];
        }

        return dist.weights(weights);
      }

      return dists;
    },

    sample() {
      const r = random();
      let d = dists[m - 1],
          v = w[0],
          i = 0; // first select distribution

      for (; i < m - 1; v += w[++i]) {
        if (r < v) {
          d = dists[i];
          break;
        }
      } // then sample from it


      return d.sample();
    },

    pdf(x) {
      let p = 0,
          i = 0;

      for (; i < m; ++i) {
        p += w[i] * dists[i].pdf(x);
      }

      return p;
    },

    cdf(x) {
      let p = 0,
          i = 0;

      for (; i < m; ++i) {
        p += w[i] * dists[i].cdf(x);
      }

      return p;
    },

    icdf() {
      throw Error('Mixture icdf not supported.');
    }

  };
  return dist.distributions(dists).weights(weights);
}

function sampleUniform(min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return min + (max - min) * random();
}
function densityUniform(value, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return value >= min && value <= max ? 1 / (max - min) : 0;
}
function cumulativeUniform(value, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return value < min ? 0 : value > max ? 1 : (value - min) / (max - min);
}
function quantileUniform(p, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return p >= 0 && p <= 1 ? min + p * (max - min) : NaN;
}
function uniform (min, max) {
  let a, b;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        return dist;
      } else {
        return a;
      }
    },

    max(_) {
      if (arguments.length) {
        b = _ == null ? 1 : _;
        return dist;
      } else {
        return b;
      }
    },

    sample: () => sampleUniform(a, b),
    pdf: value => densityUniform(value, a, b),
    cdf: value => cumulativeUniform(value, a, b),
    icdf: p => quantileUniform(p, a, b)
  };

  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return dist.min(min).max(max);
}

// Ordinary Least Squares
function ols (uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX,
        slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta,
        intercept = uY - slope * uX;
  return [intercept, slope];
}

function points(data, x, y, sort) {
  data = data.filter(d => {
    let u = x(d),
        v = y(d);
    return u != null && (u = +u) >= u && v != null && (v = +v) >= v;
  });

  if (sort) {
    data.sort((a, b) => x(a) - x(b));
  }

  const n = data.length,
        X = new Float64Array(n),
        Y = new Float64Array(n); // extract values, calculate means

  let i = 0,
      ux = 0,
      uy = 0,
      xv,
      yv,
      d;

  for (d of data) {
    X[i] = xv = +x(d);
    Y[i] = yv = +y(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  } // mean center the data


  for (i = 0; i < n; ++i) {
    X[i] -= ux;
    Y[i] -= uy;
  }

  return [X, Y, ux, uy];
}
function visitPoints(data, x, y, callback) {
  let i = -1,
      u,
      v;

  for (const d of data) {
    u = x(d);
    v = y(d);

    if (u != null && (u = +u) >= u && v != null && (v = +v) >= v) {
      callback(u, v, ++i);
    }
  }
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function rSquared (data, x, y, uY, predict) {
  let SSE = 0,
      SST = 0;
  visitPoints(data, x, y, (dx, dy) => {
    const sse = dy - predict(dx),
          sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function linear (data, x, y) {
  let X = 0,
      Y = 0,
      XY = 0,
      X2 = 0,
      n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n;
    X += (dx - X) / n;
    Y += (dy - Y) / n;
    XY += (dx * dy - XY) / n;
    X2 += (dx * dx - X2) / n;
  });

  const coef = ols(X, Y, XY, X2),
        predict = x => coef[0] + coef[1] * x;

  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function log (data, x, y) {
  let X = 0,
      Y = 0,
      XY = 0,
      X2 = 0,
      n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X += (dx - X) / n;
    Y += (dy - Y) / n;
    XY += (dx * dy - XY) / n;
    X2 += (dx * dx - X2) / n;
  });

  const coef = ols(X, Y, XY, X2),
        predict = x => coef[0] + coef[1] * Math.log(x);

  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

function exp (data, x, y) {
  // eslint-disable-next-line no-unused-vars
  const [xv, yv, ux, uy] = points(data, x, y);
  let YL = 0,
      XY = 0,
      XYL = 0,
      X2Y = 0,
      n = 0,
      dx,
      ly,
      xy;
  visitPoints(data, x, y, (_, dy) => {
    dx = xv[n++];
    ly = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });

  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy),
        predict = x => Math.exp(c0 + c1 * (x - ux));

  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function pow (data, x, y) {
  let X = 0,
      Y = 0,
      XY = 0,
      X2 = 0,
      YS = 0,
      n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    const lx = Math.log(dx),
          ly = Math.log(dy);
    ++n;
    X += (lx - X) / n;
    Y += (ly - Y) / n;
    XY += (lx * ly - XY) / n;
    X2 += (lx * lx - X2) / n;
    YS += (dy - YS) / n;
  });

  const coef = ols(X, Y, XY, X2),
        predict = x => coef[0] * Math.pow(x, coef[1]);

  coef[0] = Math.exp(coef[0]);
  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, YS, predict)
  };
}

function quad (data, x, y) {
  const [xv, yv, ux, uy] = points(data, x, y),
        n = xv.length;
  let X2 = 0,
      X3 = 0,
      X4 = 0,
      XY = 0,
      X2Y = 0,
      i,
      dx,
      dy,
      x2;

  for (i = 0; i < n;) {
    dx = xv[i];
    dy = yv[i++];
    x2 = dx * dx;
    X2 += (x2 - X2) / i;
    X3 += (x2 * dx - X3) / i;
    X4 += (x2 * x2 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x2 * dy - X2Y) / i;
  }

  const X2X2 = X4 - X2 * X2,
        d = X2 * X2X2 - X3 * X3,
        a = (X2Y * X2 - XY * X3) / d,
        b = (XY * X2X2 - X2Y * X3) / d,
        c = -a * X2,
        predict = x => {
    x = x - ux;
    return a * x * x + b * x + c + uy;
  }; // transform coefficients back from mean-centered space


  return {
    coef: [c - b * ux + a * ux * ux + uy, b - 2 * a * ux, a],
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE
// ... which was adapted from regression-js by Tom Alexander
// Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246
// License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE

function poly (data, x, y, order) {
  // use more efficient methods for lower orders
  if (order === 1) return linear(data, x, y);
  if (order === 2) return quad(data, x, y);
  const [xv, yv, ux, uy] = points(data, x, y),
        n = xv.length,
        lhs = [],
        rhs = [],
        k = order + 1;
  let i, j, l, v, c;

  for (i = 0; i < k; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }

    lhs.push(v);
    c = new Float64Array(k);

    for (j = 0; j < k; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }

      c[j] = v;
    }

    rhs.push(c);
  }

  rhs.push(lhs);

  const coef = gaussianElimination(rhs),
        predict = x => {
    x -= ux;
    let y = uy + coef[0] + coef[1] * x + coef[2] * x * x;

    for (i = 3; i < k; ++i) y += coef[i] * Math.pow(x, i);

    return y;
  };

  return {
    coef: uncenter(k, coef, -ux, uy),
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

function uncenter(k, a, x, y) {
  const z = Array(k);
  let i, j, v, c; // initialize to zero

  for (i = 0; i < k; ++i) z[i] = 0; // polynomial expansion


  for (i = k - 1; i >= 0; --i) {
    v = a[i];
    c = 1;
    z[i] += v;

    for (j = 1; j <= i; ++j) {
      c *= (i + 1 - j) / j; // binomial coefficent

      z[i - j] += v * Math.pow(x, j) * c;
    }
  } // bias term


  z[0] += y;
  return z;
} // Given an array for a two-dimensional matrix and the polynomial order,
// solve A * x = b using Gaussian elimination.


function gaussianElimination(matrix) {
  const n = matrix.length - 1,
        coef = [];
  let i, j, k, r, t;

  for (i = 0; i < n; ++i) {
    r = i; // max row

    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }

    for (k = i; k < n + 1; ++k) {
      t = matrix[k][i];
      matrix[k][i] = matrix[k][r];
      matrix[k][r] = t;
    }

    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }

  for (j = n - 1; j >= 0; --j) {
    t = 0;

    for (k = j + 1; k < n; ++k) {
      t += matrix[k][j] * coef[k];
    }

    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }

  return coef;
}

const maxiters = 2,
      epsilon = 1e-12; // Adapted from science.js by Jason Davies
// Source: https://github.com/jasondavies/science.js/blob/master/src/stats/loess.js
// License: https://github.com/jasondavies/science.js/blob/master/LICENSE

function loess (data, x, y, bandwidth) {
  const [xv, yv, ux, uy] = points(data, x, y, true),
        n = xv.length,
        bw = Math.max(2, ~~(bandwidth * n)),
        // # nearest neighbors
  yhat = new Float64Array(n),
        residuals = new Float64Array(n),
        robustWeights = new Float64Array(n).fill(1);

  for (let iter = -1; ++iter <= maxiters;) {
    const interval = [0, bw - 1];

    for (let i = 0; i < n; ++i) {
      const dx = xv[i],
            i0 = interval[0],
            i1 = interval[1],
            edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0,
          X = 0,
          Y = 0,
          XY = 0,
          X2 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1); // avoid singularity!

      for (let k = i0; k <= i1; ++k) {
        const xk = xv[k],
              yk = yv[k],
              w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],
              xkw = xk * w;
        W += w;
        X += xkw;
        Y += yk * w;
        XY += yk * xkw;
        X2 += xk * xkw;
      } // linear regression fit


      const [a, b] = ols(X / W, Y / W, XY / W, X2 / W);
      yhat[i] = a + b * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval);
    }

    if (iter === maxiters) {
      break;
    }

    const medianResidual = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(residuals);
    if (Math.abs(medianResidual) < epsilon) break;

    for (let i = 0, arg, w; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual); // default to epsilon (rather than zero) for large deviations
      // keeping weights tiny but non-zero prevents singularites

      robustWeights[i] = arg >= 1 ? epsilon : (w = 1 - arg * arg) * w;
    }
  }

  return output(xv, yhat, ux, uy);
} // weighting kernel for local regression

function tricube(x) {
  return (x = 1 - x * x * x) * x * x;
} // advance sliding window interval of nearest neighbors


function updateInterval(xv, i, interval) {
  const val = xv[i];
  let left = interval[0],
      right = interval[1] + 1;
  if (right >= xv.length) return; // step right if distance to new right edge is <= distance to old left edge
  // step when distance is equal to ensure movement over duplicate x values

  while (i > left && xv[right] - val <= val - xv[left]) {
    interval[0] = ++left;
    interval[1] = right;
    ++right;
  }
} // generate smoothed output points
// average points with repeated x values


function output(xv, yhat, ux, uy) {
  const n = xv.length,
        out = [];
  let i = 0,
      cnt = 0,
      prev = [],
      v;

  for (; i < n; ++i) {
    v = xv[i] + ux;

    if (prev[0] === v) {
      // average output values via online update
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      // add new output point
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }

  prev[1] += uy;
  return out;
}

// subdivide up to accuracy of 0.5 degrees
const MIN_RADIANS = 0.5 * Math.PI / 180; // Adaptively sample an interpolated function over a domain extent

function sampleCurve (f, extent, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);

  const point = x => [x, f(x)],
        minX = extent[0],
        maxX = extent[1],
        span = maxX - minX,
        stop = span / maxSteps,
        prev = [point(minX)],
        next = [];

  if (minSteps === maxSteps) {
    // no adaptation, sample uniform grid directly and return
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point(minX + i / minSteps * span));
    }

    prev.push(point(maxX));
    return prev;
  } else {
    // sample minimum points on uniform grid
    // then move on to perform adaptive refinement
    next.push(point(maxX));

    for (let i = minSteps; --i > 0;) {
      next.push(point(minX + i / minSteps * span));
    }
  }

  let p0 = prev[0];
  let p1 = next[next.length - 1];
  const sx = 1 / span;
  const sy = scaleY(p0[1], next);

  while (p1) {
    // midpoint for potential curve subdivision
    const pm = point((p0[0] + p1[0]) / 2);
    const dx = pm[0] - p0[0] >= stop;

    if (dx && angleDelta(p0, pm, p1, sx, sy) > MIN_RADIANS) {
      // maximum resolution has not yet been met, and
      // subdivision midpoint is sufficiently different from endpoint
      // save subdivision, push midpoint onto the visitation stack
      next.push(pm);
    } else {
      // subdivision midpoint sufficiently similar to endpoint
      // skip subdivision, store endpoint, move to next point on the stack
      p0 = p1;
      prev.push(p1);
      next.pop();
    }

    p1 = next[next.length - 1];
  }

  return prev;
}

function scaleY(init, points) {
  let ymin = init;
  let ymax = init;
  const n = points.length;

  for (let i = 0; i < n; ++i) {
    const y = points[i][1];
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;
  }

  return 1 / (ymax - ymin);
}

function angleDelta(p, q, r, sx, sy) {
  const a0 = Math.atan2(sy * (r[1] - p[1]), sx * (r[0] - p[0])),
        a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}




/***/ }),

/***/ "../../node_modules/vega-time/build/vega-time.module.js":
/*!**************************************************************!*\
  !*** ../../node_modules/vega-time/build/vega-time.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DATE": () => (/* binding */ DATE),
/* harmony export */   "DAY": () => (/* binding */ DAY),
/* harmony export */   "DAYOFYEAR": () => (/* binding */ DAYOFYEAR),
/* harmony export */   "HOURS": () => (/* binding */ HOURS),
/* harmony export */   "MILLISECONDS": () => (/* binding */ MILLISECONDS),
/* harmony export */   "MINUTES": () => (/* binding */ MINUTES),
/* harmony export */   "MONTH": () => (/* binding */ MONTH),
/* harmony export */   "QUARTER": () => (/* binding */ QUARTER),
/* harmony export */   "SECONDS": () => (/* binding */ SECONDS),
/* harmony export */   "TIME_UNITS": () => (/* binding */ TIME_UNITS),
/* harmony export */   "WEEK": () => (/* binding */ WEEK),
/* harmony export */   "YEAR": () => (/* binding */ YEAR),
/* harmony export */   "dayofyear": () => (/* binding */ dayofyear),
/* harmony export */   "timeBin": () => (/* binding */ bin),
/* harmony export */   "timeFloor": () => (/* binding */ timeFloor),
/* harmony export */   "timeInterval": () => (/* binding */ timeInterval),
/* harmony export */   "timeOffset": () => (/* binding */ timeOffset),
/* harmony export */   "timeSequence": () => (/* binding */ timeSequence),
/* harmony export */   "timeUnitSpecifier": () => (/* binding */ timeUnitSpecifier),
/* harmony export */   "timeUnits": () => (/* binding */ timeUnits),
/* harmony export */   "utcFloor": () => (/* binding */ utcFloor),
/* harmony export */   "utcInterval": () => (/* binding */ utcInterval),
/* harmony export */   "utcOffset": () => (/* binding */ utcOffset),
/* harmony export */   "utcSequence": () => (/* binding */ utcSequence),
/* harmony export */   "utcdayofyear": () => (/* binding */ utcdayofyear),
/* harmony export */   "utcweek": () => (/* binding */ utcweek),
/* harmony export */   "week": () => (/* binding */ week)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/month.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/hour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/minute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/millisecond.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcYear.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcHour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-time */ "../../node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisector.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");




const YEAR = 'year';
const QUARTER = 'quarter';
const MONTH = 'month';
const WEEK = 'week';
const DATE = 'date';
const DAY = 'day';
const DAYOFYEAR = 'dayofyear';
const HOURS = 'hours';
const MINUTES = 'minutes';
const SECONDS = 'seconds';
const MILLISECONDS = 'milliseconds';
const TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
const UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {});
function timeUnits(units) {
  const u = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(units).slice(),
        m = {}; // check validity

  if (!u.length) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing time unit.');
  u.forEach(unit => {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(UNITS, unit)) {
      m[unit] = 1;
    } else {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)("Invalid time unit: ".concat(unit, "."));
    }
  });
  const numTypes = (m[WEEK] || m[DAY] ? 1 : 0) + (m[QUARTER] || m[MONTH] || m[DATE] ? 1 : 0) + (m[DAYOFYEAR] ? 1 : 0);

  if (numTypes > 1) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)("Incompatible time units: ".concat(units));
  } // ensure proper sort order


  u.sort((a, b) => UNITS[a] - UNITS[b]);
  return u;
}
const defaultSpecifiers = {
  [YEAR]: '%Y ',
  [QUARTER]: 'Q%q ',
  [MONTH]: '%b ',
  [DATE]: '%d ',
  [WEEK]: 'W%U ',
  [DAY]: '%a ',
  [DAYOFYEAR]: '%j ',
  [HOURS]: '%H:00',
  [MINUTES]: '00:%M',
  [SECONDS]: ':%S',
  [MILLISECONDS]: '.%L',
  ["".concat(YEAR, "-").concat(MONTH)]: '%Y-%m ',
  ["".concat(YEAR, "-").concat(MONTH, "-").concat(DATE)]: '%Y-%m-%d ',
  ["".concat(HOURS, "-").concat(MINUTES)]: '%H:%M'
};
function timeUnitSpecifier(units, specifiers) {
  const s = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultSpecifiers, specifiers),
        u = timeUnits(units),
        n = u.length;
  let fmt = '',
      start = 0,
      end,
      key;

  for (start = 0; start < n;) {
    for (end = u.length; end > start; --end) {
      key = u.slice(start, end).join('-');

      if (s[key] != null) {
        fmt += s[key];
        start = end;
        break;
      }
    }
  }

  return fmt.trim();
}

const t0 = new Date();

function localYear(y) {
  t0.setFullYear(y);
  t0.setMonth(0);
  t0.setDate(1);
  t0.setHours(0, 0, 0, 0);
  return t0;
}

function dayofyear(d) {
  return localDayOfYear(new Date(d));
}
function week(d) {
  return localWeekNum(new Date(d));
}
function localDayOfYear(d) {
  return d3_time__WEBPACK_IMPORTED_MODULE_1__.default.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y) {
  return localYear(y).getDay();
}
function localDate(y, m, d, H, M, S, L) {
  if (0 <= y && y < 100) {
    const date = new Date(-1, m, d, H, M, S, L);
    date.setFullYear(y);
    return date;
  }

  return new Date(y, m, d, H, M, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear(new Date(d));
}
function utcweek(d) {
  return utcWeekNum(new Date(d));
}
function utcDayOfYear(d) {
  const y = Date.UTC(d.getUTCFullYear(), 0, 1);
  return d3_time__WEBPACK_IMPORTED_MODULE_3__.default.count(y - 1, d);
}
function utcWeekNum(d) {
  const y = Date.UTC(d.getUTCFullYear(), 0, 1);
  return d3_time__WEBPACK_IMPORTED_MODULE_4__.utcSunday.count(y - 1, d);
}
function utcFirst(y) {
  t0.setTime(Date.UTC(y, 0, 1));
  return t0.getUTCDay();
}
function utcDate(y, m, d, H, M, S, L) {
  if (0 <= y && y < 100) {
    const date = new Date(Date.UTC(-1, m, d, H, M, S, L));
    date.setUTCFullYear(d.y);
    return date;
  }

  return new Date(Date.UTC(y, m, d, H, M, S, L));
}

function floor(units, step, get, inv, newDate) {
  const s = step || 1,
        b = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(units),
        _ = (unit, p, key) => {
    key = key || unit;
    return getUnit(get[key], inv[key], unit === b && s, p);
  };

  const t = new Date(),
        u = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(units),
        y = u[YEAR] ? _(YEAR) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(2012),
        m = u[MONTH] ? _(MONTH) : u[QUARTER] ? _(QUARTER) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        d = u[WEEK] && u[DAY] ? _(DAY, 1, WEEK + DAY) : u[WEEK] ? _(WEEK, 1) : u[DAY] ? _(DAY, 1) : u[DATE] ? _(DATE, 1) : u[DAYOFYEAR] ? _(DAYOFYEAR, 1) : vega_util__WEBPACK_IMPORTED_MODULE_0__.one,
        H = u[HOURS] ? _(HOURS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        M = u[MINUTES] ? _(MINUTES) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        S = u[SECONDS] ? _(SECONDS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        L = u[MILLISECONDS] ? _(MILLISECONDS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero;
  return function (v) {
    t.setTime(+v);
    const year = y(t);
    return newDate(year, m(t), d(t, year), H(t), M(t), S(t), L(t));
  };
}

function getUnit(f, inv, step, phase) {
  const u = step <= 1 ? f : phase ? (d, y) => phase + step * Math.floor((f(d, y) - phase) / step) : (d, y) => step * Math.floor(f(d, y) / step);
  return inv ? (d, y) => inv(u(d, y), y) : u;
} // returns the day of the year based on week number, day of week,
// and the day of the week for the first day of the year


function weekday(week, day, firstDay) {
  return day + week * 7 - (firstDay + 6) % 7;
} // -- LOCAL TIME --


const localGet = {
  [YEAR]: d => d.getFullYear(),
  [QUARTER]: d => Math.floor(d.getMonth() / 3),
  [MONTH]: d => d.getMonth(),
  [DATE]: d => d.getDate(),
  [HOURS]: d => d.getHours(),
  [MINUTES]: d => d.getMinutes(),
  [SECONDS]: d => d.getSeconds(),
  [MILLISECONDS]: d => d.getMilliseconds(),
  [DAYOFYEAR]: d => localDayOfYear(d),
  [WEEK]: d => localWeekNum(d),
  [WEEK + DAY]: (d, y) => weekday(localWeekNum(d), d.getDay(), localFirst(y)),
  [DAY]: (d, y) => weekday(1, d.getDay(), localFirst(y))
};
const localInv = {
  [QUARTER]: q => 3 * q,
  [WEEK]: (w, y) => weekday(w, 0, localFirst(y))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet, localInv, localDate);
} // -- UTC TIME --

const utcGet = {
  [YEAR]: d => d.getUTCFullYear(),
  [QUARTER]: d => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: d => d.getUTCMonth(),
  [DATE]: d => d.getUTCDate(),
  [HOURS]: d => d.getUTCHours(),
  [MINUTES]: d => d.getUTCMinutes(),
  [SECONDS]: d => d.getUTCSeconds(),
  [MILLISECONDS]: d => d.getUTCMilliseconds(),
  [DAYOFYEAR]: d => utcDayOfYear(d),
  [WEEK]: d => utcWeekNum(d),
  [DAY]: (d, y) => weekday(1, d.getUTCDay(), utcFirst(y)),
  [WEEK + DAY]: (d, y) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y))
};
const utcInv = {
  [QUARTER]: q => 3 * q,
  [WEEK]: (w, y) => weekday(w, 0, utcFirst(y))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet, utcInv, utcDate);
}

const timeIntervals = {
  [YEAR]: d3_time__WEBPACK_IMPORTED_MODULE_5__.default,
  [QUARTER]: d3_time__WEBPACK_IMPORTED_MODULE_6__.default.every(3),
  [MONTH]: d3_time__WEBPACK_IMPORTED_MODULE_6__.default,
  [WEEK]: d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday,
  [DATE]: d3_time__WEBPACK_IMPORTED_MODULE_1__.default,
  [DAY]: d3_time__WEBPACK_IMPORTED_MODULE_1__.default,
  [DAYOFYEAR]: d3_time__WEBPACK_IMPORTED_MODULE_1__.default,
  [HOURS]: d3_time__WEBPACK_IMPORTED_MODULE_7__.default,
  [MINUTES]: d3_time__WEBPACK_IMPORTED_MODULE_8__.default,
  [SECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_9__.default,
  [MILLISECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_10__.default
};
const utcIntervals = {
  [YEAR]: d3_time__WEBPACK_IMPORTED_MODULE_11__.default,
  [QUARTER]: d3_time__WEBPACK_IMPORTED_MODULE_12__.default.every(3),
  [MONTH]: d3_time__WEBPACK_IMPORTED_MODULE_12__.default,
  [WEEK]: d3_time__WEBPACK_IMPORTED_MODULE_4__.utcSunday,
  [DATE]: d3_time__WEBPACK_IMPORTED_MODULE_3__.default,
  [DAY]: d3_time__WEBPACK_IMPORTED_MODULE_3__.default,
  [DAYOFYEAR]: d3_time__WEBPACK_IMPORTED_MODULE_3__.default,
  [HOURS]: d3_time__WEBPACK_IMPORTED_MODULE_13__.default,
  [MINUTES]: d3_time__WEBPACK_IMPORTED_MODULE_14__.default,
  [SECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_9__.default,
  [MILLISECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_10__.default
};
function timeInterval(unit) {
  return timeIntervals[unit];
}
function utcInterval(unit) {
  return utcIntervals[unit];
}

function offset(ival, date, step) {
  return ival ? ival.offset(date, step) : undefined;
}

function timeOffset(unit, date, step) {
  return offset(timeInterval(unit), date, step);
}
function utcOffset(unit, date, step) {
  return offset(utcInterval(unit), date, step);
}

function sequence(ival, start, stop, step) {
  return ival ? ival.range(start, stop, step) : undefined;
}

function timeSequence(unit, start, stop, step) {
  return sequence(timeInterval(unit), start, stop, step);
}
function utcSequence(unit, start, stop, step) {
  return sequence(utcInterval(unit), start, stop, step);
}

const durationSecond = 1000,
      durationMinute = durationSecond * 60,
      durationHour = durationMinute * 60,
      durationDay = durationHour * 24,
      durationWeek = durationDay * 7,
      durationMonth = durationDay * 30,
      durationYear = durationDay * 365;
const Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS],
      Seconds = Milli.slice(0, -1),
      Minutes = Seconds.slice(0, -1),
      Hours = Minutes.slice(0, -1),
      Day = Hours.slice(0, -1),
      Week = [YEAR, WEEK],
      Month = [YEAR, MONTH],
      Year = [YEAR];
const intervals = [[Seconds, 1, durationSecond], [Seconds, 5, 5 * durationSecond], [Seconds, 15, 15 * durationSecond], [Seconds, 30, 30 * durationSecond], [Minutes, 1, durationMinute], [Minutes, 5, 5 * durationMinute], [Minutes, 15, 15 * durationMinute], [Minutes, 30, 30 * durationMinute], [Hours, 1, durationHour], [Hours, 3, 3 * durationHour], [Hours, 6, 6 * durationHour], [Hours, 12, 12 * durationHour], [Day, 1, durationDay], [Week, 1, durationWeek], [Month, 1, durationMonth], [Month, 3, 3 * durationMonth], [Year, 1, durationYear]];
function bin (opt) {
  const ext = opt.extent,
        max = opt.maxbins || 40,
        target = Math.abs((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)(ext)) / max;
  let i = (0,d3_array__WEBPACK_IMPORTED_MODULE_15__.default)(i => i[2]).right(intervals, target),
      units,
      step;

  if (i === intervals.length) {
    units = Year, step = (0,d3_array__WEBPACK_IMPORTED_MODULE_16__.tickStep)(ext[0] / durationYear, ext[1] / durationYear, max);
  } else if (i) {
    i = intervals[target / intervals[i - 1][2] < intervals[i][2] / target ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli;
    step = Math.max((0,d3_array__WEBPACK_IMPORTED_MODULE_16__.tickStep)(ext[0], ext[1], max), 1);
  }

  return {
    units,
    step
  };
}




/***/ }),

/***/ "../../node_modules/vega-transforms/build/vega-transforms.module.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/vega-transforms/build/vega-transforms.module.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "aggregate": () => (/* binding */ Aggregate),
/* harmony export */   "bin": () => (/* binding */ Bin),
/* harmony export */   "collect": () => (/* binding */ Collect),
/* harmony export */   "compare": () => (/* binding */ Compare),
/* harmony export */   "countpattern": () => (/* binding */ CountPattern),
/* harmony export */   "cross": () => (/* binding */ Cross),
/* harmony export */   "density": () => (/* binding */ Density),
/* harmony export */   "dotbin": () => (/* binding */ DotBin),
/* harmony export */   "expression": () => (/* binding */ Expression),
/* harmony export */   "extent": () => (/* binding */ Extent),
/* harmony export */   "facet": () => (/* binding */ Facet),
/* harmony export */   "field": () => (/* binding */ Field),
/* harmony export */   "filter": () => (/* binding */ Filter),
/* harmony export */   "flatten": () => (/* binding */ Flatten),
/* harmony export */   "fold": () => (/* binding */ Fold),
/* harmony export */   "formula": () => (/* binding */ Formula),
/* harmony export */   "generate": () => (/* binding */ Generate),
/* harmony export */   "impute": () => (/* binding */ Impute),
/* harmony export */   "joinaggregate": () => (/* binding */ JoinAggregate),
/* harmony export */   "kde": () => (/* binding */ KDE),
/* harmony export */   "key": () => (/* binding */ Key),
/* harmony export */   "load": () => (/* binding */ Load),
/* harmony export */   "lookup": () => (/* binding */ Lookup),
/* harmony export */   "multiextent": () => (/* binding */ MultiExtent),
/* harmony export */   "multivalues": () => (/* binding */ MultiValues),
/* harmony export */   "params": () => (/* binding */ Params),
/* harmony export */   "pivot": () => (/* binding */ Pivot),
/* harmony export */   "prefacet": () => (/* binding */ PreFacet),
/* harmony export */   "project": () => (/* binding */ Project),
/* harmony export */   "proxy": () => (/* binding */ Proxy),
/* harmony export */   "quantile": () => (/* binding */ Quantile),
/* harmony export */   "relay": () => (/* binding */ Relay),
/* harmony export */   "sample": () => (/* binding */ Sample),
/* harmony export */   "sequence": () => (/* binding */ Sequence),
/* harmony export */   "sieve": () => (/* binding */ Sieve),
/* harmony export */   "subflow": () => (/* binding */ Subflow),
/* harmony export */   "timeunit": () => (/* binding */ TimeUnit),
/* harmony export */   "tupleindex": () => (/* binding */ TupleIndex),
/* harmony export */   "values": () => (/* binding */ Values),
/* harmony export */   "window": () => (/* binding */ Window)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/median.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/mean.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/bisector.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");






function multikey(f) {
  return x => {
    const n = f.length;
    let i = 1,
        k = String(f[0](x));

    for (; i < n; ++i) {
      k += '|' + f[i](x);
    }

    return k;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function () {
    return '';
  } : fields.length === 1 ? fields[0] : multikey(fields);
}

function measureName(op, field, as) {
  return as || op + (!field ? '' : '_' + field);
}

const noop = () => {};

const base_op = {
  init: noop,
  add: noop,
  rem: noop,
  idx: 0
};
const AggregateOps = {
  values: {
    init: m => m.cell.store = true,
    value: m => m.cell.data.values(),
    idx: -1
  },
  count: {
    value: m => m.cell.num
  },
  __count__: {
    value: m => m.missing + m.valid
  },
  missing: {
    value: m => m.missing
  },
  valid: {
    value: m => m.valid
  },
  sum: {
    init: m => m.sum = 0,
    value: m => m.sum,
    add: (m, v) => m.sum += +v,
    rem: (m, v) => m.sum -= v
  },
  product: {
    init: m => m.product = 1,
    value: m => m.valid ? m.product : undefined,
    add: (m, v) => m.product *= v,
    rem: (m, v) => m.product /= v
  },
  mean: {
    init: m => m.mean = 0,
    value: m => m.valid ? m.mean : undefined,
    add: (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),
    rem: (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)
  },
  average: {
    value: m => m.valid ? m.mean : undefined,
    req: ['mean'],
    idx: 1
  },
  variance: {
    init: m => m.dev = 0,
    value: m => m.valid > 1 ? m.dev / (m.valid - 1) : undefined,
    add: (m, v) => m.dev += m.mean_d * (v - m.mean),
    rem: (m, v) => m.dev -= m.mean_d * (v - m.mean),
    req: ['mean'],
    idx: 1
  },
  variancep: {
    value: m => m.valid > 1 ? m.dev / m.valid : undefined,
    req: ['variance'],
    idx: 2
  },
  stdev: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : undefined,
    req: ['variance'],
    idx: 2
  },
  stdevp: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : undefined,
    req: ['variance'],
    idx: 2
  },
  stderr: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : undefined,
    req: ['variance'],
    idx: 2
  },
  distinct: {
    value: m => m.cell.data.distinct(m.get),
    req: ['values'],
    idx: 3
  },
  ci0: {
    value: m => m.cell.data.ci0(m.get),
    req: ['values'],
    idx: 3
  },
  ci1: {
    value: m => m.cell.data.ci1(m.get),
    req: ['values'],
    idx: 3
  },
  median: {
    value: m => m.cell.data.q2(m.get),
    req: ['values'],
    idx: 3
  },
  q1: {
    value: m => m.cell.data.q1(m.get),
    req: ['values'],
    idx: 3
  },
  q3: {
    value: m => m.cell.data.q3(m.get),
    req: ['values'],
    idx: 3
  },
  min: {
    init: m => m.min = undefined,
    value: m => m.min = Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min,
    add: (m, v) => {
      if (v < m.min || m.min === undefined) m.min = v;
    },
    rem: (m, v) => {
      if (v <= m.min) m.min = NaN;
    },
    req: ['values'],
    idx: 4
  },
  max: {
    init: m => m.max = undefined,
    value: m => m.max = Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max,
    add: (m, v) => {
      if (v > m.max || m.max === undefined) m.max = v;
    },
    rem: (m, v) => {
      if (v >= m.max) m.max = NaN;
    },
    req: ['values'],
    idx: 4
  },
  argmin: {
    init: m => m.argmin = undefined,
    value: m => m.argmin || m.cell.data.argmin(m.get),
    add: (m, v, t) => {
      if (v < m.min) m.argmin = t;
    },
    rem: (m, v) => {
      if (v <= m.min) m.argmin = undefined;
    },
    req: ['min', 'values'],
    idx: 3
  },
  argmax: {
    init: m => m.argmax = undefined,
    value: m => m.argmax || m.cell.data.argmax(m.get),
    add: (m, v, t) => {
      if (v > m.max) m.argmax = t;
    },
    rem: (m, v) => {
      if (v >= m.max) m.argmax = undefined;
    },
    req: ['max', 'values'],
    idx: 3
  }
};
const ValidAggregateOps = Object.keys(AggregateOps);

function measure(key, value) {
  return out => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    name: key,
    out: out || key
  }, base_op, value);
}

ValidAggregateOps.forEach(key => {
  AggregateOps[key] = measure(key, AggregateOps[key]);
});
function createMeasure(op, name) {
  return AggregateOps[op](name);
}

function compareIndex(a, b) {
  return a.idx - b.idx;
}

function resolve(agg) {
  const map = {};
  agg.forEach(a => map[a.name] = a);

  const getreqs = a => {
    if (!a.req) return;
    a.req.forEach(key => {
      if (!map[key]) getreqs(map[key] = AggregateOps[key]());
    });
  };

  agg.forEach(getreqs);
  return Object.values(map).sort(compareIndex);
}

function init() {
  this.valid = 0;
  this.missing = 0;

  this._ops.forEach(op => op.init(this));
}

function add(v, t) {
  if (v == null || v === '') {
    ++this.missing;
    return;
  }

  if (v !== v) return;
  ++this.valid;

  this._ops.forEach(op => op.add(this, v, t));
}

function rem(v, t) {
  if (v == null || v === '') {
    --this.missing;
    return;
  }

  if (v !== v) return;
  --this.valid;

  this._ops.forEach(op => op.rem(this, v, t));
}

function set(t) {
  this._out.forEach(op => t[op.out] = op.value(this));

  return t;
}

function compileMeasures(agg, field) {
  const get = field || vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,
        ops = resolve(agg),
        out = agg.slice().sort(compareIndex);

  function ctr(cell) {
    this._ops = ops;
    this._out = out;
    this.cell = cell;
    this.init();
  }

  ctr.prototype.init = init;
  ctr.prototype.add = add;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set;
  ctr.prototype.get = get;
  ctr.fields = agg.map(op => op.out);
  return ctr;
}

function TupleStore(key) {
  this._key = key ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(key) : vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid;
  this.reset();
}
const prototype$1 = TupleStore.prototype;

prototype$1.reset = function () {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};

prototype$1.add = function (v) {
  this._add.push(v);
};

prototype$1.rem = function (v) {
  this._rem.push(v);
};

prototype$1.values = function () {
  this._get = null;
  if (this._rem.length === 0) return this._add;
  const a = this._add,
        r = this._rem,
        k = this._key,
        n = a.length,
        m = r.length,
        x = Array(n - m),
        map = {};
  let i, j, v; // use unique key field to clear removed values

  for (i = 0; i < m; ++i) {
    map[k(r[i])] = 1;
  }

  for (i = 0, j = 0; i < n; ++i) {
    if (map[k(v = a[i])]) {
      map[k(v)] = 0;
    } else {
      x[j++] = v;
    }
  }

  this._rem = [];
  return this._add = x;
}; // memoizing statistics methods


prototype$1.distinct = function (get) {
  const v = this.values(),
        map = {};
  let n = v.length,
      count = 0,
      s;

  while (--n >= 0) {
    s = get(v[n]) + '';

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(map, s)) {
      map[s] = 1;
      ++count;
    }
  }

  return count;
};

prototype$1.extent = function (get) {
  if (this._get !== get || !this._ext) {
    const v = this.values(),
          i = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extentIndex)(v, get);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get;
  }

  return this._ext;
};

prototype$1.argmin = function (get) {
  return this.extent(get)[0] || {};
};

prototype$1.argmax = function (get) {
  return this.extent(get)[1] || {};
};

prototype$1.min = function (get) {
  const m = this.extent(get)[0];
  return m != null ? get(m) : undefined;
};

prototype$1.max = function (get) {
  const m = this.extent(get)[1];
  return m != null ? get(m) : undefined;
};

prototype$1.quartile = function (get) {
  if (this._get !== get || !this._q) {
    this._q = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.quartiles)(this.values(), get);
    this._get = get;
  }

  return this._q;
};

prototype$1.q1 = function (get) {
  return this.quartile(get)[0];
};

prototype$1.q2 = function (get) {
  return this.quartile(get)[1];
};

prototype$1.q3 = function (get) {
  return this.quartile(get)[2];
};

prototype$1.ci = function (get) {
  if (this._get !== get || !this._ci) {
    this._ci = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bootstrapCI)(this.values(), 1000, 0.05, get);
    this._get = get;
  }

  return this._ci;
};

prototype$1.ci0 = function (get) {
  return this.ci(get)[0];
};

prototype$1.ci1 = function (get) {
  return this.ci(get)[1];
};

/**
 * Group-by aggregation operator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.
 * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.
 * @param {Array<string>} [params.as] - An array of output field names for aggregated values.
 * @param {boolean} [params.cross=false] - A flag indicating that the full
 *   cross-product of groupby values should be generated, including empty cells.
 *   If true, the drop parameter is ignored and empty cells are retained.
 * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.
 */

function Aggregate(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
  this._adds = []; // array of added output tuples

  this._mods = []; // array of modified output tuples

  this._alen = 0; // number of active added tuples

  this._mlen = 0; // number of active modified tuples

  this._drop = true; // should empty aggregation cells be removed

  this._cross = false; // produce full cross-product of group-by values

  this._dims = []; // group-by dimension accessors

  this._dnames = []; // group-by dimension names

  this._measures = []; // collection of aggregation monoids

  this._countOnly = false; // flag indicating only count aggregation

  this._counts = null; // collection of count fields

  this._prev = null; // previous aggregation cells

  this._inputs = null; // array of dependent input tuple field names

  this._outputs = null; // array of output tuple field names
}
Aggregate.Definition = {
  'type': 'Aggregate',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidAggregateOps
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'drop',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'cross',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Aggregate, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const aggr = this,
          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
          mod = _.modified();

    aggr.stamp = out.stamp;

    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : {};
      pulse.visit(pulse.SOURCE, t => aggr.add(t));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse.visit(pulse.REM, t => aggr.rem(t));
      pulse.visit(pulse.ADD, t => aggr.add(t));
    } // Indicate output fields and return aggregate tuples.


    out.modifies(aggr._outputs); // Should empty cells be dropped?

    aggr._drop = _.drop !== false; // If domain cross-product requested, generate empty cells as needed
    // and ensure that empty cells are not dropped

    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }

    if (pulse.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }

    return aggr.changes(out);
  },

  cross() {
    const aggr = this,
          curr = aggr.value,
          dims = aggr._dnames,
          vals = dims.map(() => ({})),
          n = dims.length; // collect all group-by domain values

    function collect(cells) {
      let key, i, t, v;

      for (key in cells) {
        t = cells[key].tuple;

        for (i = 0; i < n; ++i) {
          vals[i][v = t[dims[i]]] = v;
        }
      }
    }

    collect(aggr._prev);
    collect(curr); // iterate over key cross-product, create cells as needed

    function generate(base, tuple, index) {
      const name = dims[index],
            v = vals[index++];

      for (const k in v) {
        const key = base ? base + '|' + k : k;
        tuple[name] = v[k];
        if (index < n) generate(key, tuple, index);else if (!curr[key]) aggr.cell(key, tuple);
      }
    }

    generate('', {}, 0);
  },

  init(_) {
    // initialize input and output fields
    const inputs = this._inputs = [],
          outputs = this._outputs = [],
          inputMap = {};

    function inputVisit(get) {
      const fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(get)),
            n = fields.length;
      let i = 0,
          f;

      for (; i < n; ++i) {
        if (!inputMap[f = fields[i]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    } // initialize group-by dimensions


    this._dims = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.groupby);
    this._dnames = this._dims.map(d => {
      const dname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims); // initialize aggregate measures

    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null],
          ops = _.ops || ['count'],
          as = _.as || [],
          n = fields.length,
          map = {};
    let field, op, m, mname, outname, i;

    if (n !== ops.length) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unmatched number of fields and aggregate ops.');
    }

    for (i = 0; i < n; ++i) {
      field = fields[i];
      op = ops[i];

      if (field == null && op !== 'count') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Null aggregate field specified.');
      }

      mname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);

      if (op === 'count') {
        this._counts.push(outname);

        continue;
      }

      m = map[mname];

      if (!m) {
        inputVisit(field);
        m = map[mname] = [];
        m.field = field;

        this._measures.push(m);
      }

      if (op !== 'count') this._countOnly = false;
      m.push(createMeasure(op, outname));
    }

    this._measures = this._measures.map(m => compileMeasures(m, m.field));
    return {}; // aggregation cells (this.value)
  },

  // -- Cell Management -----
  cellkey: groupkey(),

  cell(key, t) {
    let cell = this.value[key];

    if (!cell) {
      cell = this.value[key] = this.newcell(key, t);
      this._adds[this._alen++] = cell;
    } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {
      cell.stamp = this.stamp;
      this._adds[this._alen++] = cell;
    } else if (cell.stamp < this.stamp) {
      cell.stamp = this.stamp;
      this._mods[this._mlen++] = cell;
    }

    return cell;
  },

  newcell(key, t) {
    const cell = {
      key: key,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[key]),
      stamp: this.stamp,
      store: false
    };

    if (!this._countOnly) {
      const measures = this._measures,
            n = measures.length;
      cell.agg = Array(n);

      for (let i = 0; i < n; ++i) {
        cell.agg[i] = new measures[i](cell);
      }
    }

    if (cell.store) {
      cell.data = new TupleStore();
    }

    return cell;
  },

  newtuple(t, p) {
    const names = this._dnames,
          dims = this._dims,
          n = dims.length,
          x = {};

    for (let i = 0; i < n; ++i) {
      x[names[i]] = dims[i](t);
    }

    return p ? (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.replace)(p.tuple, x) : (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(x);
  },

  clean() {
    const cells = this.value;

    for (const key in cells) {
      if (cells[key].num === 0) {
        delete cells[key];
      }
    }
  },

  // -- Process Tuples -----
  add(t) {
    const key = this.cellkey(t),
          cell = this.cell(key, t);
    cell.num += 1;
    if (this._countOnly) return;
    if (cell.store) cell.data.add(t);
    const agg = cell.agg;

    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t), t);
    }
  },

  rem(t) {
    const key = this.cellkey(t),
          cell = this.cell(key, t);
    cell.num -= 1;
    if (this._countOnly) return;
    if (cell.store) cell.data.rem(t);
    const agg = cell.agg;

    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t), t);
    }
  },

  celltuple(cell) {
    const tuple = cell.tuple,
          counts = this._counts; // consolidate stored values

    if (cell.store) {
      cell.data.values();
    } // update tuple properties


    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell.num;
    }

    if (!this._countOnly) {
      const agg = cell.agg;

      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }

    return tuple;
  },

  changes(out) {
    const adds = this._adds,
          mods = this._mods,
          prev = this._prev,
          drop = this._drop,
          add = out.add,
          rem = out.rem,
          mod = out.mod;
    let cell, key, i, n;
    if (prev) for (key in prev) {
      cell = prev[key];
      if (!drop || cell.num) rem.push(cell.tuple);
    }

    for (i = 0, n = this._alen; i < n; ++i) {
      add.push(this.celltuple(adds[i]));
      adds[i] = null; // for garbage collection
    }

    for (i = 0, n = this._mlen; i < n; ++i) {
      cell = mods[i];
      (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));
      mods[i] = null; // for garbage collection
    }

    this._alen = this._mlen = 0; // reset list of active cells

    this._prev = null;
    return out;
  }

});

const EPSILON$1 = 1e-14;
/**
 * Generates a binning function for discretizing data.
 * @constructor
 * @param {object} params - The parameters for this operator. The
 *   provided values should be valid options for the {@link bin} function.
 * @param {function(object): *} params.field - The data field to bin.
 */

function Bin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Bin.Definition = {
  'type': 'Bin',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'interval',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'anchor',
    'type': 'number'
  }, {
    'name': 'maxbins',
    'type': 'number',
    'default': 20
  }, {
    'name': 'base',
    'type': 'number',
    'default': 10
  }, {
    'name': 'divide',
    'type': 'number',
    'array': true,
    'default': [5, 2]
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'span',
    'type': 'number'
  }, {
    'name': 'step',
    'type': 'number'
  }, {
    'name': 'steps',
    'type': 'number',
    'array': true
  }, {
    'name': 'minstep',
    'type': 'number',
    'default': 0
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'name',
    'type': 'string'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['bin0', 'bin1']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Bin, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const band = _.interval !== false,
          bins = this._bins(_),
          start = bins.start,
          step = bins.step,
          as = _.as || ['bin0', 'bin1'],
          b0 = as[0],
          b1 = as[1];

    let flag;

    if (_.modified()) {
      pulse = pulse.reflow(true);
      flag = pulse.SOURCE;
    } else {
      flag = pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(_.field)) ? pulse.ADD_MOD : pulse.ADD;
    }

    pulse.visit(flag, band ? t => {
      const v = bins(t); // minimum bin value (inclusive)

      t[b0] = v; // maximum bin value (exclusive)
      // use convoluted math for better floating point agreement
      // see https://github.com/vega/vega/issues/830
      // infinite values propagate through this formula! #2227

      t[b1] = v == null ? null : start + step * (1 + (v - start) / step);
    } : t => t[b0] = bins(t));
    return pulse.modifies(band ? as : b0);
  },

  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }

    const field = _.field,
          bins = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bin)(_),
          step = bins.step;
    let start = bins.start,
        stop = start + Math.ceil((bins.stop - start) / step) * step,
        a,
        d;

    if ((a = _.anchor) != null) {
      d = a - (start + step * Math.floor((a - start) / step));
      start += d;
      stop += d;
    }

    const f = function (t) {
      let v = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(field(t));
      return v == null ? null : v < start ? -Infinity : v > stop ? +Infinity : (v = Math.max(start, Math.min(v, stop - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));
    };

    f.start = start;
    f.stop = bins.stop;
    f.step = step;
    return this.value = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(f, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field), _.name || 'bin_' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field));
  }

});

function SortedList (idFunc, source, input) {
  const $ = idFunc;
  let data = source || [],
      add = input || [],
      rem = {},
      cnt = 0;
  return {
    add: t => add.push(t),
    remove: t => rem[$(t)] = ++cnt,
    size: () => data.length,
    data: (compare, resort) => {
      if (cnt) {
        data = data.filter(t => !rem[$(t)]);
        rem = {};
        cnt = 0;
      }

      if (resort && compare) {
        data.sort(compare);
      }

      if (add.length) {
        data = compare ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.merge)(compare, data, add.sort(compare)) : data.concat(add);
        add = [];
      }

      return data;
    }
  };
}

/**
 * Collects all data tuples that pass through this operator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for additionally sorting the collected tuples.
 */

function Collect(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Collect.Definition = {
  'type': 'Collect',
  'metadata': {
    'source': true
  },
  'params': [{
    'name': 'sort',
    'type': 'compare'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Collect, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.ALL),
          list = SortedList(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid, this.value, out.materialize(out.ADD).add),
          sort = _.sort,
          mod = pulse.changed() || sort && (_.modified('sort') || pulse.modified(sort.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(sort), mod); // propagate tree root if defined

    if (pulse.source && pulse.source.root) {
      this.value.root = pulse.source.root;
    }

    return out;
  }

});

/**
 * Generates a comparator function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<string|function>} params.fields - The fields to compare.
 * @param {Array<string>} [params.orders] - The sort orders.
 *   Each entry should be one of "ascending" (default) or "descending".
 */

function Compare(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$5, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Compare, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$5(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.compare)(_.fields, _.orders);
}

/**
 * Count regexp-defined pattern occurrences in a text field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - An accessor for the text field.
 * @param {string} [params.pattern] - RegExp string defining the text pattern.
 * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.
 * @param {string} [params.stopwords] - RegExp string of words to ignore.
 */

function CountPattern(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
CountPattern.Definition = {
  'type': 'CountPattern',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'case',
    'type': 'enum',
    'values': ['upper', 'lower', 'mixed'],
    'default': 'mixed'
  }, {
    'name': 'pattern',
    'type': 'string',
    'default': '[\\w"]+'
  }, {
    'name': 'stopwords',
    'type': 'string',
    'default': ''
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['text', 'count']
  }]
};

function tokenize(text, tcase, match) {
  switch (tcase) {
    case 'upper':
      text = text.toUpperCase();
      break;

    case 'lower':
      text = text.toLowerCase();
      break;
  }

  return text.match(match);
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CountPattern, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const process = update => tuple => {
      var tokens = tokenize(get(tuple), _.case, match) || [],
          t;

      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop.test(t = tokens[i])) update(t);
      }
    };

    const init = this._parameterCheck(_, pulse),
          counts = this._counts,
          match = this._match,
          stop = this._stop,
          get = _.field,
          as = _.as || ['text', 'count'],
          add = process(t => counts[t] = 1 + (counts[t] || 0)),
          rem = process(t => counts[t] -= 1);

    if (init) {
      pulse.visit(pulse.SOURCE, add);
    } else {
      pulse.visit(pulse.ADD, add);
      pulse.visit(pulse.REM, rem);
    }

    return this._finish(pulse, as); // generate output tuples
  },

  _parameterCheck(_, pulse) {
    let init = false;

    if (_.modified('stopwords') || !this._stop) {
      this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');
      init = true;
    }

    if (_.modified('pattern') || !this._match) {
      this._match = new RegExp(_.pattern || '[\\w\']+', 'g');
      init = true;
    }

    if (_.modified('field') || pulse.modified(_.field.fields)) {
      init = true;
    }

    if (init) this._counts = {};
    return init;
  },

  _finish(pulse, as) {
    const counts = this._counts,
          tuples = this._tuples || (this._tuples = {}),
          text = as[0],
          count = as[1],
          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    let w, t, c;

    for (w in counts) {
      t = tuples[w];
      c = counts[w] || 0;

      if (!t && c) {
        tuples[w] = t = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({});
        t[text] = w;
        t[count] = c;
        out.add.push(t);
      } else if (c === 0) {
        if (t) out.rem.push(t);
        counts[w] = null;
        tuples[w] = null;
      } else if (t[count] !== c) {
        t[count] = c;
        out.mod.push(t);
      }
    }

    return out.modifies(as);
  }

});

/**
 * Perform a cross-product of a tuple stream with itself.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object):boolean} [params.filter] - An optional filter
 *   function for selectively including tuples in the cross product.
 * @param {Array<string>} [params.as] - The names of the output fields.
 */

function Cross(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Cross.Definition = {
  'type': 'Cross',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'filter',
    'type': 'expr'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['a', 'b']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Cross, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          as = _.as || ['a', 'b'],
          a = as[0],
          b = as[1],
          reset = !this.value || pulse.changed(pulse.ADD_REM) || _.modified('as') || _.modified('filter');

    let data = this.value;

    if (reset) {
      if (data) out.rem = data;
      data = pulse.materialize(pulse.SOURCE).source;
      out.add = this.value = cross(data, a, b, _.filter || vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy);
    } else {
      out.mod = data;
    }

    out.source = this.value;
    return out.modifies(as);
  }

});

function cross(input, a, b, filter) {
  var data = [],
      t = {},
      n = input.length,
      i = 0,
      j,
      left;

  for (; i < n; ++i) {
    t[a] = left = input[i];

    for (j = 0; j < n; ++j) {
      t[b] = input[j];

      if (filter(t)) {
        data.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        t = {};
        t[a] = left;
      }
    }
  }

  return data;
}

const Distributions = {
  kde: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomKDE,
  mixture: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomMixture,
  normal: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomNormal,
  lognormal: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomLogNormal,
  uniform: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomUniform
};
const DISTRIBUTIONS = 'distributions',
      FUNCTION = 'function',
      FIELD = 'field';
/**
 * Parse a parameter object for a probability distribution.
 * @param {object} def - The distribution parameter object.
 * @param {function():Array<object>} - A method for requesting
 *   source data. Used for distributions (such as KDE) that
 *   require sample data points. This method will only be
 *   invoked if the 'from' parameter for a target data source
 *   is not provided. Typically this method returns backing
 *   source data for a Pulse object.
 * @return {object} - The output distribution object.
 */

function parse(def, data) {
  const func = def[FUNCTION];

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(Distributions, func)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unknown distribution function: ' + func);
  }

  const d = Distributions[func]();

  for (const name in def) {
    // if data field, extract values
    if (name === FIELD) {
      d.data((def.from || data()).map(def[name]));
    } // if distribution mixture, recurse to parse each definition
    else if (name === DISTRIBUTIONS) {
        d[name](def[name].map(_ => parse(_, data)));
      } // otherwise, simply set the parameter
      else if (typeof d[name] === FUNCTION) {
          d[name](def[name]);
        }
  }

  return d;
}

/**
 * Grid sample points for a probability density. Given a distribution and
 * a sampling extent, will generate points suitable for plotting either
 * PDF (probability density function) or CDF (cumulative distribution
 * function) curves.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.distribution - The probability distribution. This
 *   is an object parameter dependent on the distribution type.
 * @param {string} [params.method='pdf'] - The distribution method to sample.
 *   One of 'pdf' or 'cdf'.
 * @param {Array<number>} [params.extent] - The [min, max] extent over which
 *   to sample the distribution. This argument is required in most cases, but
 *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method
 *   that returns numerical sample points from which the extent can be deduced.
 * @param {number} [params.minsteps=25] - The minimum number of curve samples
 *   for plotting the density.
 * @param {number} [params.maxsteps=200] - The maximum number of curve samples
 *   for plotting the density.
 * @param {number} [params.steps] - The exact number of curve samples for
 *   plotting the density. If specified, overrides both minsteps and maxsteps
 *   to set an exact number of uniform samples. Useful in conjunction with
 *   a fixed extent to ensure consistent sample points for stacked densities.
 */

function Density(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
const distributions = [{
  'key': {
    'function': 'normal'
  },
  'params': [{
    'name': 'mean',
    'type': 'number',
    'default': 0
  }, {
    'name': 'stdev',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'lognormal'
  },
  'params': [{
    'name': 'mean',
    'type': 'number',
    'default': 0
  }, {
    'name': 'stdev',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'uniform'
  },
  'params': [{
    'name': 'min',
    'type': 'number',
    'default': 0
  }, {
    'name': 'max',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'kde'
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'from',
    'type': 'data'
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0
  }]
}];
const mixture = {
  'key': {
    'function': 'mixture'
  },
  'params': [{
    'name': 'distributions',
    'type': 'param',
    'array': true,
    'params': distributions
  }, {
    'name': 'weights',
    'type': 'number',
    'array': true
  }]
};
Density.Definition = {
  'type': 'Density',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'steps',
    'type': 'number'
  }, {
    'name': 'minsteps',
    'type': 'number',
    'default': 25
  }, {
    'name': 'maxsteps',
    'type': 'number',
    'default': 200
  }, {
    'name': 'method',
    'type': 'string',
    'default': 'pdf',
    'values': ['pdf', 'cdf']
  }, {
    'name': 'distribution',
    'type': 'param',
    'params': distributions.concat(mixture)
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['value', 'density']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Density, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const dist = parse(_.distribution, source(pulse)),
            minsteps = _.steps || _.minsteps || 25,
            maxsteps = _.steps || _.maxsteps || 200;
      let method = _.method || 'pdf';

      if (method !== 'pdf' && method !== 'cdf') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid density method: ' + method);
      }

      if (!_.extent && !dist.data) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing density extent parameter.');
      }

      method = dist[method];
      const as = _.as || ['value', 'density'],
            domain = _.extent || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(dist.data()),
            values = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.sampleCurve)(method, domain, minsteps, maxsteps).map(v => {
        const tuple = {};
        tuple[as[0]] = v[0];
        tuple[as[1]] = v[1];
        return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(tuple);
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});

function source(pulse) {
  return () => pulse.materialize(pulse.SOURCE).source;
}

function fieldNames(fields, as) {
  if (!fields) return null;
  return fields.map((f, i) => as[i] || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(f));
}
function partition$1(data, groupby, field) {
  const groups = [],
        get = f => f(t);

  let map, i, n, t, k, g; // partition data points into groups

  if (groupby == null) {
    groups.push(data.map(field));
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }

      g.push(field(t));
    }
  }

  return groups;
}

const Output = 'bin';
/**
 * Dot density binning for dot plot construction.
 * Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.
 * https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to bin.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {number} [params.step] - The step size (bin width) within which dots should be
 *   stacked. Defaults to 1/30 of the extent of the data *field*.
 * @param {boolean} [params.smooth=false] - A boolean flag indicating if dot density
 *   stacks should be smoothed to reduce variance.
 */

function DotBin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
DotBin.Definition = {
  'type': 'DotBin',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'step',
    'type': 'number'
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'default': Output
  }]
};

const autostep = (data, field) => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(data, field)) / 30;

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(DotBin, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (this.value && !(_.modified() || pulse.changed())) {
      return pulse; // early exit
    }

    const source = pulse.materialize(pulse.SOURCE).source,
          groups = partition$1(pulse.source, _.groupby, vega_util__WEBPACK_IMPORTED_MODULE_0__.identity),
          smooth = _.smooth || false,
          field = _.field,
          step = _.step || autostep(source, field),
          sort = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)((a, b) => field(a) - field(b)),
          as = _.as || Output,
          n = groups.length; // compute dotplot bins per group

    let min = Infinity,
        max = -Infinity,
        i = 0,
        j;

    for (; i < n; ++i) {
      const g = groups[i].sort(sort);
      j = -1;

      for (const v of (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.dotbin)(g, step, smooth, field)) {
        if (v < min) min = v;
        if (v > max) max = v;
        g[++j][as] = v;
      }
    }

    this.value = {
      start: min,
      stop: max,
      step: step
    };
    return pulse.reflow(true).modifies(as);
  }

});

/**
 * Wraps an expression function with access to external parameters.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function} params.expr - The expression function. The
 *  function should accept both a datum and a parameter object.
 *  This operator's value will be a new function that wraps the
 *  expression function with access to this operator's parameters.
 */

function Expression(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$4, params);
  this.modified(true);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Expression, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$4(_) {
  const expr = _.expr;
  return this.value && !_.modified('expr') ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(datum => expr(datum, _), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(expr), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(expr));
}

/**
 * Computes extents (min/max) for a data field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The field over which to compute extends.
 */

function Extent(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [undefined, undefined], params);
}
Extent.Definition = {
  'type': 'Extent',
  'metadata': {},
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Extent, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const extent = this.value,
          field = _.field,
          mod = pulse.changed() || pulse.modified(field.fields) || _.modified('field');

    let min = extent[0],
        max = extent[1];

    if (mod || min == null) {
      min = +Infinity;
      max = -Infinity;
    }

    pulse.visit(mod ? pulse.SOURCE : pulse.ADD, t => {
      const v = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(field(t));

      if (v != null) {
        // NaNs will fail all comparisons!
        if (v < min) min = v;
        if (v > max) max = v;
      }
    });

    if (!Number.isFinite(min) || !Number.isFinite(max)) {
      let name = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field);
      if (name) name = ` for field "${name}"`;
      pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);
      min = max = undefined;
    }

    this.value = [min, max];
  }

});

/**
 * Provides a bridge between a parent transform and a target subflow that
 * consumes only a subset of the tuples that pass through the parent.
 * @constructor
 * @param {Pulse} pulse - A pulse to use as the value of this operator.
 * @param {Transform} parent - The parent transform (typically a Facet instance).
 */

function Subflow(pulse, parent) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, pulse);
  this.parent = parent;
  this.count = 0;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Subflow, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(target) {
    this.detachSubflow = target.detachSubflow;
    this.targets().add(target);
    return target.source = this;
  },

  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(t) {
    this.count += 1;
    this.value.add.push(t);
  },

  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(t) {
    this.count -= 1;
    this.value.rem.push(t);
  },

  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(t) {
    this.value.mod.push(t);
  },

  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(pulse) {
    this.value.init(pulse, pulse.NO_SOURCE);
  },

  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    // assert: this.value.stamp === pulse.stamp
    return this.value;
  }

});

/**
 * Facets a dataflow into a set of subflows based on a key.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Dataflow, string): Operator} params.subflow - A function
 *   that generates a subflow of operators and returns its root operator.
 * @param {function(object): *} params.key - The key field to facet by.
 */

function Facet(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
  this._keys = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(); // cache previously calculated key values
  // keep track of active subflows, use as targets array for listeners
  // this allows us to limit propagation to only updated subflows

  const a = this._targets = [];
  a.active = 0;

  a.forEach = f => {
    for (let i = 0, n = a.active; i < n; ++i) {
      f(a[i], i, a);
    }
  };
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Facet, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },

  // parent argument provided by PreFacet subclass
  subflow(key, flow, pulse, parent) {
    const flows = this.value;
    let sf = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(flows, key) && flows[key],
        df,
        p;

    if (!sf) {
      p = parent || (p = this._group[key]) && p.tuple;
      df = pulse.dataflow;
      sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key, p));
      flows[key] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse.stamp) {
      sf.init(pulse);
      this.activate(sf);
    }

    return sf;
  },

  clean() {
    const flows = this.value;
    let detached = 0;

    for (const key in flows) {
      if (flows[key].count === 0) {
        const detach = flows[key].detachSubflow;
        if (detach) detach();
        delete flows[key];
        ++detached;
      }
    } // remove inactive targets from the active targets array


    if (detached) {
      const active = this._targets.filter(sf => sf && sf.count > 0);

      this.initTargets(active);
    }
  },

  initTargets(act) {
    const a = this._targets,
          n = a.length,
          m = act ? act.length : 0;
    let i = 0;

    for (; i < m; ++i) {
      a[i] = act[i];
    }

    for (; i < n && a[i] != null; ++i) {
      a[i] = null; // ensure old flows can be garbage collected
    }

    a.active = m;
  },

  transform(_, pulse) {
    const df = pulse.dataflow,
          key = _.key,
          flow = _.subflow,
          cache = this._keys,
          rekey = _.modified('key'),
          subflow = key => this.subflow(key, flow, pulse);

    this._group = _.group || {};
    this.initTargets(); // reset list of active subflows

    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
            k = cache.get(id);

      if (k !== undefined) {
        cache.delete(id);
        subflow(k).rem(t);
      }
    });
    pulse.visit(pulse.ADD, t => {
      const k = key(t);
      cache.set((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), k);
      subflow(k).add(t);
    });

    if (rekey || pulse.modified(key.fields)) {
      pulse.visit(pulse.MOD, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
              k0 = cache.get(id),
              k1 = key(t);

        if (k0 === k1) {
          subflow(k1).mod(t);
        } else {
          cache.set(id, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    } else if (pulse.changed(pulse.MOD)) {
      pulse.visit(pulse.MOD, t => {
        subflow(cache.get((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t))).mod(t);
      });
    }

    if (rekey) {
      pulse.visit(pulse.REFLOW, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
              k0 = cache.get(id),
              k1 = key(t);

        if (k0 !== k1) {
          cache.set(id, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    }

    if (pulse.clean()) {
      df.runAfter(() => {
        this.clean();
        cache.clean();
      });
    } else if (cache.empty > df.cleanThreshold) {
      df.runAfter(cache.clean);
    }

    return pulse;
  }

});

/**
 * Generates one or more field accessor functions.
 * If the 'name' parameter is an array, an array of field accessors
 * will be created and the 'as' parameter will be ignored.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.name - The field name(s) to access.
 * @param {string} params.as - The accessor function name.
 */

function Field(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$3, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Field, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$3(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_.name) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.name).map(f => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f)) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(_.name, _.as);
}

/**
 * Filters data tuples according to a predicate function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.expr - The predicate expression function
 *   that determines a tuple's filter status. Truthy values pass the filter.
 */

function Filter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(), params);
}
Filter.Definition = {
  'type': 'Filter',
  'metadata': {
    'changes': true
  },
  'params': [{
    'name': 'expr',
    'type': 'expr',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Filter, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow,
          cache = this.value,
          // cache ids of filtered tuples
    output = pulse.fork(),
          add = output.add,
          rem = output.rem,
          mod = output.mod,
          test = _.expr;
    let isMod = true;
    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
      if (!cache.has(id)) rem.push(t);else cache.delete(id);
    });
    pulse.visit(pulse.ADD, t => {
      if (test(t, _)) add.push(t);else cache.set((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), 1);
    });

    function revisit(t) {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
            b = test(t, _),
            s = cache.get(id);

      if (b && s) {
        cache.delete(id);
        add.push(t);
      } else if (!b && !s) {
        cache.set(id, 1);
        rem.push(t);
      } else if (isMod && b && !s) {
        mod.push(t);
      }
    }

    pulse.visit(pulse.MOD, revisit);

    if (_.modified()) {
      isMod = false;
      pulse.visit(pulse.REFLOW, revisit);
    }

    if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);
    return output;
  }

});

/**
 * Flattens array-typed field values into new data objects.
 * If multiple fields are specified, they are treated as parallel arrays,
 * with output values included for each matching index (or null if missing).
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.fields - An array of field
 *   accessors for the tuple fields that should be flattened.
 * @param {string} [params.index] - Optional output field name for index
 *   value. If unspecified, no index field is included in the output.
 * @param {Array<string>} [params.as] - Output field names for flattened
 *   array fields. Any unspecified fields will use the field name provided
 *   by the fields accessors.
 */

function Flatten(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Flatten.Definition = {
  'type': 'Flatten',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'index',
    'type': 'string'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Flatten, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          fields = _.fields,
          as = fieldNames(fields, _.as || []),
          index = _.index || null,
          m = as.length; // remove any previous results

    out.rem = this.value; // generate flattened tuples

    pulse.visit(pulse.SOURCE, t => {
      const arrays = fields.map(f => f(t)),
            maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);
      let i = 0,
          j,
          d,
          v;

      for (; i < maxlen; ++i) {
        d = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);

        for (j = 0; j < m; ++j) {
          d[as[j]] = (v = arrays[j][i]) == null ? null : v;
        }

        if (index) {
          d[index] = i;
        }

        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index) out.modifies(index);
    return out.modifies(as);
  }

});

/**
 * Folds one more tuple fields into multiple tuples in which the field
 * name and values are available under new 'key' and 'value' fields.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.fields - An array of field accessors
 *   for the tuple fields that should be folded.
 * @param {Array<string>} [params.as] - Output field names for folded key
 *   and value fields, defaults to ['key', 'value'].
 */

function Fold(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Fold.Definition = {
  'type': 'Fold',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['key', 'value']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Fold, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          fields = _.fields,
          fnames = fields.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
          as = _.as || ['key', 'value'],
          k = as[0],
          v = as[1],
          n = fields.length;
    out.rem = this.value;
    pulse.visit(pulse.SOURCE, t => {
      for (let i = 0, d; i < n; ++i) {
        d = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);
        d[k] = fnames[i];
        d[v] = fields[i](t);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }

});

/**
 * Invokes a function for each data tuple and saves the results as a new field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.expr - The formula function to invoke for each tuple.
 * @param {string} params.as - The field name under which to save the result.
 * @param {boolean} [params.initonly=false] - If true, the formula is applied to
 *   added tuples only, and does not update in response to modifications.
 */

function Formula(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Formula.Definition = {
  'type': 'Formula',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'expr',
    'type': 'expr',
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'required': true
  }, {
    'name': 'initonly',
    'type': 'boolean'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Formula, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const func = _.expr,
          as = _.as,
          mod = _.modified(),
          flag = _.initonly ? pulse.ADD : mod ? pulse.SOURCE : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD : pulse.ADD;

    if (mod) {
      // parameters updated, need to reflow
      pulse = pulse.materialize().reflow(true);
    }

    if (!_.initonly) {
      pulse.modifies(as);
    }

    return pulse.visit(flag, t => t[as] = func(t, _));
  }

});

/**
 * Generates data tuples using a provided generator function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Parameters): object} params.generator - A tuple generator
 *   function. This function is given the operator parameters as input.
 *   Changes to any additional parameters will not trigger re-calculation
 *   of previously generated tuples. Only future tuples are affected.
 * @param {number} params.size - The number of tuples to produce.
 */

function Generate(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Generate, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.ALL),
          gen = _.generator;
    let data = this.value,
        num = _.size - data.length,
        add,
        rem,
        t;

    if (num > 0) {
      // need more tuples, generate and add
      for (add = []; --num >= 0;) {
        add.push(t = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(gen(_)));
        data.push(t);
      }

      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add) : add;
    } else {
      // need fewer tuples, remove
      rem = data.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem) : rem;
      data = data.slice(-num);
    }

    out.source = this.value = data;
    return out;
  }

});

const Methods = {
  value: 'value',
  median: d3_array__WEBPACK_IMPORTED_MODULE_4__.default,
  mean: d3_array__WEBPACK_IMPORTED_MODULE_5__.default,
  min: d3_array__WEBPACK_IMPORTED_MODULE_6__.default,
  max: d3_array__WEBPACK_IMPORTED_MODULE_7__.default
};
const Empty = [];
/**
 * Impute missing values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to impute.
 * @param {Array<function(object): *>} [params.groupby] - An array of
 *   accessors to determine series within which to perform imputation.
 * @param {function(object): *} params.key - An accessor for a key value.
 *   Each key value should be unique within a group. New tuples will be
 *   imputed for any key values that are not found within a group.
 * @param {Array<*>} [params.keyvals] - Optional array of required key
 *   values. New tuples will be imputed for any key values that are not
 *   found within a group. In addition, these values will be automatically
 *   augmented with the key values observed in the input data.
 * @param {string} [method='value'] - The imputation method to use. One of
 *   'value', 'mean', 'median', 'max', 'min'.
 * @param {*} [value=0] - The constant value to use for imputation
 *   when using method 'value'.
 */

function Impute(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Impute.Definition = {
  'type': 'Impute',
  'metadata': {
    'changes': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'key',
    'type': 'field',
    'required': true
  }, {
    'name': 'keyvals',
    'array': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'value',
    'values': ['value', 'mean', 'median', 'max', 'min']
  }, {
    'name': 'value',
    'default': 0
  }]
};

function getValue(_) {
  var m = _.method || Methods.value,
      v;

  if (Methods[m] == null) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized imputation method: ' + m);
  } else if (m === Methods.value) {
    v = _.value !== undefined ? _.value : 0;
    return () => v;
  } else {
    return Methods[m];
  }
}

function getField(_) {
  const f = _.field;
  return t => t ? f(t) : NaN;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Impute, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
        impute = getValue(_),
        field = getField(_),
        fName = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(_.field),
        kName = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(_.key),
        gNames = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
        groups = partition(pulse.source, _.groupby, _.key, _.keyvals),
        curr = [],
        prev = this.value,
        m = groups.domain.length,
        group,
        value,
        gVals,
        kVal,
        g,
        i,
        j,
        l,
        n,
        t;

    for (g = 0, l = groups.length; g < l; ++g) {
      group = groups[g];
      gVals = group.values;
      value = NaN; // add tuples for missing values

      for (j = 0; j < m; ++j) {
        if (group[j] != null) continue;
        kVal = groups.domain[j];
        t = {
          _impute: true
        };

        for (i = 0, n = gVals.length; i < n; ++i) t[gNames[i]] = gVals[i];

        t[kName] = kVal;
        t[fName] = Number.isNaN(value) ? value = impute(group, field) : value;
        curr.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
      }
    } // update pulse with imputed tuples


    if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);
    this.value = curr;
    return out;
  }

});

function partition(data, groupby, key, keyvals) {
  var get = f => f(t),
      groups = [],
      domain = keyvals ? keyvals.slice() : [],
      kMap = {},
      gMap = {},
      gVals,
      gKey,
      group,
      i,
      j,
      k,
      n,
      t;

  domain.forEach((k, i) => kMap[k] = i + 1);

  for (i = 0, n = data.length; i < n; ++i) {
    t = data[i];
    k = key(t);
    j = kMap[k] || (kMap[k] = domain.push(k));
    gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';

    if (!(group = gMap[gKey])) {
      group = gMap[gKey] = [];
      groups.push(group);
      group.values = gVals;
    }

    group[j - 1] = t;
  }

  groups.domain = domain;
  return groups;
}

/**
 * Extend input tuples with aggregate values.
 * Calcuates aggregate values and joins them with the input stream.
 * @constructor
 */

function JoinAggregate(params) {
  Aggregate.call(this, params);
}
JoinAggregate.Definition = {
  'type': 'JoinAggregate',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidAggregateOps
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(JoinAggregate, Aggregate, {
  transform(_, pulse) {
    const aggr = this,
          mod = _.modified();

    let cells; // process all input tuples to calculate aggregates

    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse.visit(pulse.SOURCE, t => aggr.add(t));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse.visit(pulse.REM, t => aggr.rem(t));
      pulse.visit(pulse.ADD, t => aggr.add(t));
    } // update aggregation cells


    aggr.changes(); // write aggregate values to input tuples

    pulse.visit(pulse.SOURCE, t => {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(t, cells[aggr.cellkey(t)].tuple);
    });
    return pulse.reflow(mod).modifies(this._outputs);
  },

  changes() {
    const adds = this._adds,
          mods = this._mods;
    let i, n;

    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null; // for garbage collection
    }

    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null; // for garbage collection
    }

    this._alen = this._mlen = 0; // reset list of active cells
  }

});

/**
 * Compute kernel density estimates (KDE) for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {function(object): *} params.field - An accessor for the data field
 *   to estimate.
 * @param {number} [params.bandwidth=0] - The KDE kernel bandwidth.
 *   If zero or unspecified, the bandwidth is automatically determined.
 * @param {boolean} [params.counts=false] - A boolean flag indicating if the
 *   output values should be probability estimates (false, default) or
 *   smoothed counts (true).
 * @param {string} [params.cumulative=false] - A boolean flag indicating if a
 *   density (false) or cumulative distribution (true) should be generated.
 * @param {Array<number>} [params.extent] - The domain extent over which to
 *   plot the density. If unspecified, the [min, max] data extent is used.
 * @param {string} [params.resolve='independent'] - Indicates how parameters for
 *   multiple densities should be resolved. If "independent" (the default), each
 *   density may have its own domain extent and dynamic number of curve sample
 *   steps. If "shared", the KDE transform will ensure that all densities are
 *   defined over a shared domain and curve steps, enabling stacking.
 * @param {number} [params.minsteps=25] - The minimum number of curve samples
 *   for plotting the density.
 * @param {number} [params.maxsteps=200] - The maximum number of curve samples
 *   for plotting the density.
 * @param {number} [params.steps] - The exact number of curve samples for
 *   plotting the density. If specified, overrides both minsteps and maxsteps
 *   to set an exact number of uniform samples. Useful in conjunction with
 *   a fixed extent to ensure consistent sample points for stacked densities.
 */

function KDE(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
KDE.Definition = {
  'type': 'KDE',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'cumulative',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'counts',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'steps',
    'type': 'number'
  }, {
    'name': 'minsteps',
    'type': 'number',
    'default': 25
  }, {
    'name': 'maxsteps',
    'type': 'number',
    'default': 200
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['value', 'density']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(KDE, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
            groups = partition$1(source, _.groupby, _.field),
            names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
            bandwidth = _.bandwidth,
            method = _.cumulative ? 'cdf' : 'pdf',
            as = _.as || ['value', 'density'],
            values = [];
      let domain = _.extent,
          minsteps = _.steps || _.minsteps || 25,
          maxsteps = _.steps || _.maxsteps || 200;

      if (method !== 'pdf' && method !== 'cdf') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid density method: ' + method);
      }

      if (_.resolve === 'shared') {
        if (!domain) domain = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(source, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }

      groups.forEach(g => {
        const density = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomKDE)(g, bandwidth)[method],
              scale = _.counts ? g.length : 1,
              local = domain || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(g);
        (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.sampleCurve)(density, local, minsteps, maxsteps).forEach(v => {
          const t = {};

          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }

          t[as[0]] = v[0];
          t[as[1]] = v[1] * scale;
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});

/**
 * Generates a key function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<string>} params.fields - The field name(s) for the key function.
 * @param {boolean} params.flat - A boolean flag indicating if the field names
 *  should be treated as flat property names, side-stepping nested field
 *  lookups normally indicated by dot or bracket notation.
 */

function Key(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$2, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Key, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$2(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.key)(_.fields, _.flat);
}

/**
 * Load and parse data from an external source. Marshalls parameter
 * values and then invokes the Dataflow request method.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.url - The URL to load from.
 * @param {object} params.format - The data format options.
 */

function Load(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
  this._pending = null;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Load, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow;

    if (this._pending) {
      // update state and return pulse
      return output(this, pulse, this._pending);
    }

    if (stop(_)) return pulse.StopPropagation;

    if (_.values) {
      // parse and ingest values, return output pulse
      return output(this, pulse, df.parse(_.values, _.format));
    } else if (_.async) {
      // return promise for non-blocking async loading
      const p = df.request(_.url, _.format).then(res => {
        this._pending = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(res.data);
        return df => df.touch(this);
      });
      return {
        async: p
      };
    } else {
      // return promise for synchronous loading
      return df.request(_.url, _.format).then(res => output(this, pulse, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(res.data)));
    }
  }

});

function stop(_) {
  return _.modified('async') && !(_.modified('values') || _.modified('url') || _.modified('format'));
}

function output(op, pulse, data) {
  data.forEach(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest);
  const out = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data;
  op._pending = null;
  if (out.rem.length) out.clean(true);
  return out;
}

/**
 * Extend tuples by joining them with values from a lookup table.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Map} params.index - The lookup table map.
 * @param {Array<function(object): *} params.fields - The fields to lookup.
 * @param {Array<string>} params.as - Output field names for each lookup value.
 * @param {*} [params.default] - A default value to use if lookup fails.
 */

function Lookup(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
}
Lookup.Definition = {
  'type': 'Lookup',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'index',
    'type': 'index',
    'params': [{
      'name': 'from',
      'type': 'data',
      'required': true
    }, {
      'name': 'key',
      'type': 'field',
      'required': true
    }]
  }, {
    'name': 'values',
    'type': 'field',
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }, {
    'name': 'default',
    'default': null
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Lookup, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const keys = _.fields,
          index = _.index,
          values = _.values,
          defaultValue = _.default == null ? null : _.default,
          reset = _.modified(),
          n = keys.length;

    let flag = reset ? pulse.SOURCE : pulse.ADD,
        out = pulse,
        as = _.as,
        set,
        m,
        mods;

    if (values) {
      m = values.length;

      if (n > 1 && !as) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Multi-field lookup requires explicit "as" parameter.');
      }

      if (as && as.length !== n * m) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('The "as" parameter has too few output field names.');
      }

      as = as || values.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName);

      set = function (t) {
        for (var i = 0, k = 0, j, v; i < n; ++i) {
          v = index.get(keys[i](t));
          if (v == null) for (j = 0; j < m; ++j, ++k) t[as[k]] = defaultValue;else for (j = 0; j < m; ++j, ++k) t[as[k]] = values[j](v);
        }
      };
    } else {
      if (!as) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing output field names.');
      }

      set = function (t) {
        for (var i = 0, v; i < n; ++i) {
          v = index.get(keys[i](t));
          t[as[i]] = v == null ? defaultValue : v;
        }
      };
    }

    if (reset) {
      out = pulse.reflow(true);
    } else {
      mods = keys.some(k => pulse.modified(k.fields));
      flag |= mods ? pulse.MOD : 0;
    }

    pulse.visit(flag, set);
    return out.modifies(as);
  }

});

/**
 * Computes global min/max extents over a collection of extents.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<Array<number>>} params.extents - The input extents.
 */

function MultiExtent(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$1, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiExtent, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }

  const ext = _.extents,
        n = ext.length;
  let min = +Infinity,
      max = -Infinity,
      i,
      e;

  for (i = 0; i < n; ++i) {
    e = ext[i];
    if (e[0] < min) min = e[0];
    if (e[1] > max) max = e[1];
  }

  return [min, max];
}

/**
 * Merge a collection of value arrays.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<Array<*>>} params.values - The input value arrrays.
 */

function MultiValues(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiValues, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data, _) => data.concat(_), []);
}

/**
 * Operator whose value is simply its parameter hash. This operator is
 * useful for enabling reactive updates to values of nested objects.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Params(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Params, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.modified(_.modified());
    this.value = _;
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples
  }

});

/**
 * Aggregate and pivot selected field values to become new fields.
 * This operator is useful to construction cross-tabulations.
 * @constructor
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *  to groupby. These fields act just like groupby fields of an Aggregate transform.
 * @param {function(object): *} params.field - The field to pivot on. The unique
 *  values of this field become new field names in the output stream.
 * @param {function(object): *} params.value - The field to populate pivoted fields.
 *  The aggregate values of this field become the values of the new pivoted fields.
 * @param {string} [params.op] - The aggregation operation for the value field,
 *  applied per cell in the output stream. The default is "sum".
 * @param {number} [params.limit] - An optional parameter indicating the maximum
 *  number of pivoted fields to generate. The pivoted field names are sorted in
 *  ascending order prior to enforcing the limit.
 */

function Pivot(params) {
  Aggregate.call(this, params);
}
Pivot.Definition = {
  'type': 'Pivot',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'value',
    'type': 'field',
    'required': true
  }, {
    'name': 'op',
    'type': 'enum',
    'values': ValidAggregateOps,
    'default': 'sum'
  }, {
    'name': 'limit',
    'type': 'number',
    'default': 0
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Pivot, Aggregate, {
  _transform: Aggregate.prototype.transform,

  transform(_, pulse) {
    return this._transform(aggregateParams(_, pulse), pulse);
  }

}); // Shoehorn a pivot transform into an aggregate transform!
// First collect all unique pivot field values.
// Then generate aggregate fields for each output pivot field.

function aggregateParams(_, pulse) {
  const key = _.field,
        value = _.value,
        op = (_.op === 'count' ? '__count__' : _.op) || 'sum',
        fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(key).concat((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(value)),
        keys = pivotKeys(key, _.limit || 0, pulse); // if data stream content changes, pivot fields may change
  // flag parameter modification to ensure re-initialization

  if (pulse.changed()) _.set('__pivot__', null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys.map(() => op),
    fields: keys.map(k => get(k, key, value, fields)),
    as: keys.map(k => k + ''),
    modified: _.modified.bind(_)
  };
} // Generate aggregate field accessor.
// Output NaN for non-existent values; aggregator will ignore!


function get(k, key, value, fields) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(d => key(d) === k ? value(d) : NaN, fields, k + '');
} // Collect (and optionally limit) all unique pivot values.


function pivotKeys(key, limit, pulse) {
  const map = {},
        list = [];
  pulse.visit(pulse.SOURCE, t => {
    const k = key(t);

    if (!map[k]) {
      map[k] = 1;
      list.push(k);
    }
  });
  list.sort(vega_util__WEBPACK_IMPORTED_MODULE_0__.ascending);
  return limit ? list.slice(0, limit) : list;
}

/**
 * Partitions pre-faceted data into tuple subflows.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Dataflow, string): Operator} params.subflow - A function
 *   that generates a subflow of operators and returns its root operator.
 * @param {function(object): Array<object>} params.field - The field
 *   accessor for an array of subflow tuple objects.
 */

function PreFacet(params) {
  Facet.call(this, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(PreFacet, Facet, {
  transform(_, pulse) {
    const flow = _.subflow,
          field = _.field,
          subflow = t => this.subflow((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), flow, pulse, t);

    if (_.modified('field') || field && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field))) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('PreFacet does not support field modification.');
    }

    this.initTargets(); // reset list of active subflows

    if (field) {
      pulse.visit(pulse.MOD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.mod(_));
      });
      pulse.visit(pulse.ADD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.add((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(_)));
      });
      pulse.visit(pulse.REM, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.rem(_));
      });
    } else {
      pulse.visit(pulse.MOD, t => subflow(t).mod(t));
      pulse.visit(pulse.ADD, t => subflow(t).add(t));
      pulse.visit(pulse.REM, t => subflow(t).rem(t));
    }

    if (pulse.clean()) {
      pulse.runAfter(() => this.clean());
    }

    return pulse;
  }

});

/**
 * Performs a relational projection, copying selected fields from source
 * tuples to a new set of derived tuples.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *} params.fields - The fields to project,
 *   as an array of field accessors. If unspecified, all fields will be
 *   copied with names unchanged.
 * @param {Array<string>} [params.as] - Output field names for each projected
 *   field. Any unspecified fields will use the field name provided by
 *   the field accessor.
 */

function Project(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Project.Definition = {
  'type': 'Project',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Project, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          fields = _.fields,
          as = fieldNames(_.fields, _.as || []),
          derive = fields ? (s, t) => project(s, t, fields, as) : vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.rederive;
    let lut;

    if (this.value) {
      lut = this.value;
    } else {
      pulse = pulse.addAll();
      lut = this.value = {};
    }

    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
      out.rem.push(lut[id]);
      lut[id] = null;
    });
    pulse.visit(pulse.ADD, t => {
      const dt = derive(t, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({}));
      lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = dt;
      out.add.push(dt);
    });
    pulse.visit(pulse.MOD, t => {
      out.mod.push(derive(t, lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]));
    });
    return out;
  }

});

function project(s, t, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t[as[i]] = fields[i](s);
  }

  return t;
}

/**
 * Proxy the value of another operator as a pure signal value.
 * Ensures no tuples are propagated.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {*} params.value - The value to proxy, becomes the value of this operator.
 */

function Proxy(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Proxy, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.value = _.value;
    return _.modified('value') ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
  }

});

/**
 * Generates sample quantile values from an input data stream.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - An accessor for the data field
 *   over which to calculate quantile values.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {Array<number>} [params.probs] - An array of probabilities in
 *   the range (0, 1) for which to compute quantile values. If not specified,
 *   the *step* parameter will be used.
 * @param {Array<number>} [params.step=0.01] - A probability step size for
 *   sampling quantile values. All values from one-half the step size up to
 *   1 (exclusive) will be sampled. This parameter is only used if the
 *   *quantiles* parameter is not provided.
 */

function Quantile(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Quantile.Definition = {
  'type': 'Quantile',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'probs',
    'type': 'number',
    'array': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 0.01
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['prob', 'value']
  }]
};
const EPSILON = 1e-14;
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Quantile, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
          as = _.as || ['prob', 'value'];

    if (this.value && !_.modified() && !pulse.changed()) {
      out.source = this.value;
      return out;
    }

    const source = pulse.materialize(pulse.SOURCE).source,
          groups = partition$1(source, _.groupby, _.field),
          names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
          values = [],
          step = _.step || 0.01,
          p = _.probs || (0,d3_array__WEBPACK_IMPORTED_MODULE_8__.default)(step / 2, 1 - EPSILON, step),
          n = p.length;
    groups.forEach(g => {
      const q = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.quantiles)(g, p);

      for (let i = 0; i < n; ++i) {
        const t = {};

        for (let i = 0; i < names.length; ++i) {
          t[names[i]] = g.dims[i];
        }

        t[as[0]] = p[i];
        t[as[1]] = q[i];
        values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
      }
    });
    if (this.value) out.rem = this.value;
    this.value = out.add = out.source = values;
    return out;
  }

});

/**
 * Relays a data stream between data processing pipelines.
 * If the derive parameter is set, this transform will create derived
 * copies of observed tuples. This provides derived data streams in which
 * modifications to the tuples do not pollute an upstream data source.
 * @param {object} params - The parameters for this operator.
 * @param {number} [params.derive=false] - Boolean flag indicating if
 *   the transform should make derived copies of incoming tuples.
 * @constructor
 */

function Relay(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Relay, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    let out, lut;

    if (this.value) {
      lut = this.value;
    } else {
      out = pulse = pulse.addAll();
      lut = this.value = {};
    }

    if (_.derive) {
      out = pulse.fork(pulse.NO_SOURCE);
      pulse.visit(pulse.REM, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
        out.rem.push(lut[id]);
        lut[id] = null;
      });
      pulse.visit(pulse.ADD, t => {
        const dt = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);
        lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = dt;
        out.add.push(dt);
      });
      pulse.visit(pulse.MOD, t => {
        const dt = lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)];

        for (const k in t) {
          dt[k] = t[k]; // down stream writes may overwrite re-derived tuples
          // conservatively mark all source fields as modified

          out.modifies(k);
        }

        out.mod.push(dt);
      });
    }

    return out;
  }

});

/**
 * Samples tuples passing through this operator.
 * Uses reservoir sampling to maintain a representative sample.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {number} [params.size=1000] - The maximum number of samples.
 */

function Sample(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
  this.count = 0;
}
Sample.Definition = {
  'type': 'Sample',
  'metadata': {},
  'params': [{
    'name': 'size',
    'type': 'number',
    'default': 1000
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sample, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          mod = _.modified('size'),
          num = _.size,
          map = this.value.reduce((m, t) => (m[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = 1, m), {});

    let res = this.value,
        cnt = this.count,
        cap = 0; // sample reservoir update function

    function update(t) {
      let p, idx;

      if (res.length < num) {
        res.push(t);
      } else {
        idx = ~~((cnt + 1) * (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.random)());

        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(p)]) out.rem.push(p); // eviction

          res[idx] = t;
        }
      }

      ++cnt;
    }

    if (pulse.rem.length) {
      // find all tuples that should be removed, add to output
      pulse.visit(pulse.REM, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);

        if (map[id]) {
          map[id] = -1;
          out.rem.push(t);
        }

        --cnt;
      }); // filter removed tuples out of the sample reservoir

      res = res.filter(t => map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] !== -1);
    }

    if ((pulse.rem.length || mod) && res.length < num && pulse.source) {
      // replenish sample if backing data source is available
      cap = cnt = res.length;
      pulse.visit(pulse.SOURCE, t => {
        // update, but skip previously sampled tuples
        if (!map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]) update(t);
      });
      cap = -1;
    }

    if (mod && res.length > num) {
      const n = res.length - num;

      for (let i = 0; i < n; ++i) {
        map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(res[i])] = -1;
        out.rem.push(res[i]);
      }

      res = res.slice(n);
    }

    if (pulse.mod.length) {
      // propagate modified tuples in the sample reservoir
      pulse.visit(pulse.MOD, t => {
        if (map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]) out.mod.push(t);
      });
    }

    if (pulse.add.length) {
      // update sample reservoir
      pulse.visit(pulse.ADD, update);
    }

    if (pulse.add.length || cap < 0) {
      // output newly added tuples
      out.add = res.filter(t => !map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]);
    }

    this.count = cnt;
    this.value = out.source = res;
    return out;
  }

});

/**
 * Generates data tuples for a specified sequence range of numbers.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {number} params.start - The first number in the sequence.
 * @param {number} params.stop - The last number (exclusive) in the sequence.
 * @param {number} [params.step=1] - The step size between numbers in the sequence.
 */

function Sequence(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Sequence.Definition = {
  'type': 'Sequence',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'start',
    'type': 'number',
    'required': true
  }, {
    'name': 'stop',
    'type': 'number',
    'required': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 1
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'data'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sequence, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (this.value && !_.modified()) return;
    const out = pulse.materialize().fork(pulse.MOD),
          as = _.as || 'data';
    out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;
    this.value = (0,d3_array__WEBPACK_IMPORTED_MODULE_8__.default)(_.start, _.stop, _.step || 1).map(v => {
      const t = {};
      t[as] = v;
      return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t);
    });
    out.add = pulse.add.concat(this.value);
    return out;
  }

});

/**
 * Propagates a new pulse without any tuples so long as the input
 * pulse contains some added, removed or modified tuples.
 * @param {object} params - The parameters for this operator.
 * @constructor
 */

function Sieve(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sieve, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.value = pulse.source;
    return pulse.changed() ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
  }

});

/**
 * Discretize dates to specific time units.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The data field containing date/time values.
 */

function TimeUnit(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
const OUTPUT = ['unit0', 'unit1'];
TimeUnit.Definition = {
  'type': 'TimeUnit',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'interval',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'units',
    'type': 'enum',
    'values': vega_time__WEBPACK_IMPORTED_MODULE_3__.TIME_UNITS,
    'array': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 1
  }, {
    'name': 'maxbins',
    'type': 'number',
    'default': 40
  }, {
    'name': 'extent',
    'type': 'date',
    'array': true
  }, {
    'name': 'timezone',
    'type': 'enum',
    'default': 'local',
    'values': ['local', 'utc']
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': OUTPUT
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(TimeUnit, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const field = _.field,
          band = _.interval !== false,
          utc = _.timezone === 'utc',
          floor = this._floor(_, pulse),
          offset = (utc ? vega_time__WEBPACK_IMPORTED_MODULE_3__.utcInterval : vega_time__WEBPACK_IMPORTED_MODULE_3__.timeInterval)(floor.unit).offset,
          as = _.as || OUTPUT,
          u0 = as[0],
          u1 = as[1],
          step = floor.step;

    let min = floor.start || Infinity,
        max = floor.stop || -Infinity,
        flag = pulse.ADD;

    if (_.modified() || pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field))) {
      pulse = pulse.reflow(true);
      flag = pulse.SOURCE;
      min = Infinity;
      max = -Infinity;
    }

    pulse.visit(flag, t => {
      const v = field(t);
      let a, b;

      if (v == null) {
        t[u0] = null;
        if (band) t[u1] = null;
      } else {
        t[u0] = a = b = floor(v);
        if (band) t[u1] = b = offset(a, step);
        if (a < min) min = a;
        if (b > max) max = b;
      }
    });
    floor.start = min;
    floor.stop = max;
    return pulse.modifies(band ? as : u0);
  },

  _floor(_, pulse) {
    const utc = _.timezone === 'utc'; // get parameters

    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : (0,vega_time__WEBPACK_IMPORTED_MODULE_3__.timeBin)({
      extent: _.extent || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(pulse.materialize(pulse.SOURCE).source, _.field),
      maxbins: _.maxbins
    }); // check / standardize time units

    const tunits = (0,vega_time__WEBPACK_IMPORTED_MODULE_3__.timeUnits)(units),
          prev = this.value || {},
          floor = (utc ? vega_time__WEBPACK_IMPORTED_MODULE_3__.utcFloor : vega_time__WEBPACK_IMPORTED_MODULE_3__.timeFloor)(tunits, step);
    floor.unit = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(tunits);
    floor.units = tunits;
    floor.step = step;
    floor.start = prev.start;
    floor.stop = prev.stop;
    return this.value = floor;
  }

});

/**
 * An index that maps from unique, string-coerced, field values to tuples.
 * Assumes that the field serves as a unique key with no duplicate values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The field accessor to index.
 */

function TupleIndex(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(), params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(TupleIndex, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow,
          field = _.field,
          index = this.value,
          set = t => index.set(field(t), t);

    let mod = true;

    if (_.modified('field') || pulse.modified(field.fields)) {
      index.clear();
      pulse.visit(pulse.SOURCE, set);
    } else if (pulse.changed()) {
      pulse.visit(pulse.REM, t => index.delete(field(t)));
      pulse.visit(pulse.ADD, set);
    } else {
      mod = false;
    }

    this.modified(mod);
    if (index.empty > df.cleanThreshold) df.runAfter(index.clean);
    return pulse.fork();
  }

});

/**
 * Extracts an array of values. Assumes the source data has already been
 * reduced as needed (e.g., by an upstream Aggregate transform).
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The domain field to extract.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for sorting the values. The comparator will be
 *   applied to backing tuples prior to value extraction.
 */

function Values(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Values, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const run = !this.value || _.modified('field') || _.modified('sort') || pulse.changed() || _.sort && pulse.modified(_.sort.fields);

    if (run) {
      this.value = (_.sort ? pulse.source.slice().sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(_.sort)) : pulse.source).map(_.field);
    }
  }

});

function WindowOp(op, field, param, as) {
  const fn = WindowOps[op](field, param);
  return {
    init: fn.init || vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
    update: function (w, t) {
      t[as] = fn.next(w);
    }
  };
}
const WindowOps = {
  row_number: function () {
    return {
      next: w => w.index + 1
    };
  },
  rank: function () {
    let rank;
    return {
      init: () => rank = 1,
      next: w => {
        const i = w.index,
              data = w.data;
        return i && w.compare(data[i - 1], data[i]) ? rank = i + 1 : rank;
      }
    };
  },
  dense_rank: function () {
    let drank;
    return {
      init: () => drank = 1,
      next: w => {
        const i = w.index,
              d = w.data;
        return i && w.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function () {
    const rank = WindowOps.rank(),
          next = rank.next;
    return {
      init: rank.init,
      next: w => (next(w) - 1) / (w.data.length - 1)
    };
  },
  cume_dist: function () {
    let cume;
    return {
      init: () => cume = 0,
      next: w => {
        const d = w.data,
              c = w.compare;
        let i = w.index;

        if (cume < i) {
          while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;

          cume = i;
        }

        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function (field, num) {
    num = +num;
    if (!(num > 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('ntile num must be greater than zero.');
    const cume = WindowOps.cume_dist(),
          next = cume.next;
    return {
      init: cume.init,
      next: w => Math.ceil(num * next(w))
    };
  },
  lag: function (field, offset) {
    offset = +offset || 1;
    return {
      next: w => {
        const i = w.index - offset;
        return i >= 0 ? field(w.data[i]) : null;
      }
    };
  },
  lead: function (field, offset) {
    offset = +offset || 1;
    return {
      next: w => {
        const i = w.index + offset,
              d = w.data;
        return i < d.length ? field(d[i]) : null;
      }
    };
  },
  first_value: function (field) {
    return {
      next: w => field(w.data[w.i0])
    };
  },
  last_value: function (field) {
    return {
      next: w => field(w.data[w.i1 - 1])
    };
  },
  nth_value: function (field, nth) {
    nth = +nth;
    if (!(nth > 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('nth_value nth must be greater than zero.');
    return {
      next: w => {
        const i = w.i0 + (nth - 1);
        return i < w.i1 ? field(w.data[i]) : null;
      }
    };
  },
  prev_value: function (field) {
    let prev;
    return {
      init: () => prev = null,
      next: w => {
        const v = field(w.data[w.index]);
        return v != null ? prev = v : prev;
      }
    };
  },
  next_value: function (field) {
    let v, i;
    return {
      init: () => (v = null, i = -1),
      next: w => {
        const d = w.data;
        return w.index <= i ? v : (i = find(field, d, w.index)) < 0 ? (i = d.length, v = null) : v = field(d[i]);
      }
    };
  }
};

function find(field, data, index) {
  for (let n = data.length; index < n; ++index) {
    const v = field(data[index]);
    if (v != null) return index;
  }

  return -1;
}

const ValidWindowOps = Object.keys(WindowOps);

function WindowState(_) {
  const ops = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.ops),
        fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.fields),
        params = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.params),
        as = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.as),
        outputs = this.outputs = [],
        windows = this.windows = [],
        inputs = {},
        map = {},
        counts = [],
        measures = [];
  let countOnly = true;

  function visitInputs(f) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(f)).forEach(_ => inputs[_] = 1);
  }

  visitInputs(_.sort);
  ops.forEach((op, i) => {
    const field = fields[i],
          mname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field),
          name = measureName(op, mname, as[i]);
    visitInputs(field);
    outputs.push(name); // Window operation

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(WindowOps, op)) {
      windows.push(WindowOp(op, fields[i], params[i], name));
    } // Aggregate operation
    else {
        if (field == null && op !== 'count') {
          (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Null aggregate field specified.');
        }

        if (op === 'count') {
          counts.push(name);
          return;
        }

        countOnly = false;
        let m = map[mname];

        if (!m) {
          m = map[mname] = [];
          m.field = field;
          measures.push(m);
        }

        m.push(createMeasure(op, name));
      }
  });

  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }

  this.inputs = Object.keys(inputs);
}
const prototype = WindowState.prototype;

prototype.init = function () {
  this.windows.forEach(_ => _.init());
  if (this.cell) this.cell.init();
};

prototype.update = function (w, t) {
  const cell = this.cell,
        wind = this.windows,
        data = w.data,
        m = wind && wind.length;
  let j;

  if (cell) {
    for (j = w.p0; j < w.i0; ++j) cell.rem(data[j]);

    for (j = w.p1; j < w.i1; ++j) cell.add(data[j]);

    cell.set(t);
  }

  for (j = 0; j < m; ++j) wind[j].update(w, t);
};

function cell(measures, counts, countOnly) {
  measures = measures.map(m => compileMeasures(m, m.field));
  const cell = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };

  if (!countOnly) {
    var n = measures.length,
        a = cell.agg = Array(n),
        i = 0;

    for (; i < n; ++i) a[i] = new measures[i](cell);
  }

  if (cell.store) {
    var store = cell.data = new TupleStore();
  }

  cell.add = function (t) {
    cell.num += 1;
    if (countOnly) return;
    if (store) store.add(t);

    for (let i = 0; i < n; ++i) {
      a[i].add(a[i].get(t), t);
    }
  };

  cell.rem = function (t) {
    cell.num -= 1;
    if (countOnly) return;
    if (store) store.rem(t);

    for (let i = 0; i < n; ++i) {
      a[i].rem(a[i].get(t), t);
    }
  };

  cell.set = function (t) {
    let i, n; // consolidate stored values

    if (store) store.values(); // update tuple properties

    for (i = 0, n = counts.length; i < n; ++i) t[counts[i]] = cell.num;

    if (!countOnly) for (i = 0, n = a.length; i < n; ++i) a[i].set(t);
  };

  cell.init = function () {
    cell.num = 0;
    if (store) store.reset();

    for (let i = 0; i < n; ++i) a[i].init();
  };

  return cell;
}

/**
 * Perform window calculations and write results to the input stream.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.
 * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.
 * @param {Array<function(object): *>} [params.fields] - An array of accessors
 *   for data fields to use as inputs to window operations.
 * @param {Array<*>} [params.params] - An array of parameter values for window operations.
 * @param {Array<string>} [params.as] - An array of output field names for window operations.
 * @param {Array<number>} [params.frame] - Window frame definition as two-element array.
 * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row
 *   number alone, ignoring peers with identical sort values. If false (default),
 *   the window boundaries will be adjusted to include peer values.
 */

function Window(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  'type': 'Window',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidWindowOps.concat(ValidAggregateOps)
  }, {
    'name': 'params',
    'type': 'number',
    'null': true,
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'frame',
    'type': 'number',
    'null': true,
    'array': true,
    'length': 2,
    'default': [null, 0]
  }, {
    'name': 'ignorePeers',
    'type': 'boolean',
    'default': false
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Window, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.stamp = pulse.stamp;

    const mod = _.modified(),
          cmp = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(_.sort),
          key = groupkey(_.groupby),
          group = t => this.group(key(t)); // initialize window state


    let state = this.state;

    if (!state || mod) {
      state = this.state = new WindowState(_);
    } // partition input tuples


    if (mod || pulse.modified(state.inputs)) {
      this.value = {};
      pulse.visit(pulse.SOURCE, t => group(t).add(t));
    } else {
      pulse.visit(pulse.REM, t => group(t).remove(t));
      pulse.visit(pulse.ADD, t => group(t).add(t));
    } // perform window calculations for each modified partition


    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp, _);
    }

    this._mlen = 0;
    this._mods = []; // TODO don't reflow everything?

    return pulse.reflow(mod).modifies(state.outputs);
  },

  group(key) {
    let group = this.value[key];

    if (!group) {
      group = this.value[key] = SortedList(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid);
      group.stamp = -1;
    }

    if (group.stamp < this.stamp) {
      group.stamp = this.stamp;
      this._mods[this._mlen++] = group;
    }

    return group;
  }

});

function processPartition(list, state, cmp, _) {
  const sort = _.sort,
        range = sort && !_.ignorePeers,
        frame = _.frame || [null, 0],
        data = list.data(cmp),
        // use cmp for stable sort
  n = data.length,
        b = range ? (0,d3_array__WEBPACK_IMPORTED_MODULE_9__.default)(sort) : null,
        w = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data,
    compare: sort || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(-1)
  };
  state.init();

  for (let i = 0; i < n; ++i) {
    setWindow(w, frame, i, n);
    if (range) adjustRange(w, b);
    state.update(w, data[i]);
  }
}

function setWindow(w, f, i, n) {
  w.p0 = w.i0;
  w.p1 = w.i1;
  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w.index = i;
} // if frame type is 'range', adjust window for peer values


function adjustRange(w, bisect) {
  const r0 = w.i0,
        r1 = w.i1 - 1,
        c = w.compare,
        d = w.data,
        n = d.length - 1;
  if (r0 > 0 && !c(d[r0], d[r0 - 1])) w.i0 = bisect.left(d, d[r0]);
  if (r1 < n && !c(d[r1], d[r1 + 1])) w.i1 = bisect.right(d, d[r1]);
}




/***/ }),

/***/ "../../node_modules/vega-view-transforms/build/vega-view-transforms.module.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/vega-view-transforms/build/vega-view-transforms.module.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bound": () => (/* binding */ Bound),
/* harmony export */   "identifier": () => (/* binding */ Identifier),
/* harmony export */   "mark": () => (/* binding */ Mark),
/* harmony export */   "overlap": () => (/* binding */ Overlap),
/* harmony export */   "render": () => (/* binding */ Render),
/* harmony export */   "viewlayout": () => (/* binding */ ViewLayout)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");




const Top = 'top';
const Left = 'left';
const Right = 'right';
const Bottom = 'bottom';
const TopLeft = 'top-left';
const TopRight = 'top-right';
const BottomLeft = 'bottom-left';
const BottomRight = 'bottom-right';
const Start = 'start';
const Middle = 'middle';
const End = 'end';
const X = 'x';
const Y = 'y';
const Group = 'group';
const AxisRole = 'axis';
const TitleRole = 'title';
const FrameRole = 'frame';
const ScopeRole = 'scope';
const LegendRole = 'legend';
const RowHeader = 'row-header';
const RowFooter = 'row-footer';
const RowTitle = 'row-title';
const ColHeader = 'column-header';
const ColFooter = 'column-footer';
const ColTitle = 'column-title';
const Padding = 'padding';
const Symbols = 'symbol';
const Fit = 'fit';
const FitX = 'fit-x';
const FitY = 'fit-y';
const Pad = 'pad';
const None = 'none';
const All = 'all';
const Each = 'each';
const Flush = 'flush';
const Column = 'column';
const Row = 'row';

/**
 * Calculate bounding boxes for scenegraph items.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.mark - The scenegraph mark instance to bound.
 */

function Bound(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Bound, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow,
          mark = _.mark,
          type = mark.marktype,
          entry = vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Marks[type],
          bound = entry.bound;
    let markBounds = mark.bounds,
        rebound;

    if (entry.nested) {
      // multi-item marks have a single bounds instance
      if (mark.items.length) view.dirty(mark.items[0]);
      markBounds = boundItem(mark, bound);
      mark.items.forEach(item => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type === Group || _.modified()) {
      // operator parameters modified -> re-bound all items
      // updates group bounds in response to modified group content
      pulse.visit(pulse.MOD, item => view.dirty(item));
      markBounds.clear();
      mark.items.forEach(item => markBounds.union(boundItem(item, bound))); // force reflow for axes/legends/titles to propagate any layout changes

      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          pulse.reflow();
      }
    } else {
      // incrementally update bounds, re-bound mark as needed
      rebound = pulse.changed(pulse.REM);
      pulse.visit(pulse.ADD, item => {
        markBounds.union(boundItem(item, bound));
      });
      pulse.visit(pulse.MOD, item => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem(item, bound));
      });

      if (rebound) {
        markBounds.clear();
        mark.items.forEach(item => markBounds.union(item.bounds));
      }
    } // ensure mark bounds do not exceed any clipping region


    (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundClip)(mark);
    return pulse.modifies('bounds');
  }

});

function boundItem(item, bound, opt) {
  return bound(item.bounds.clear(), item, opt);
}

const COUNTER_NAME = ':vega_identifier:';
/**
 * Adds a unique identifier to all added tuples.
 * This transform creates a new signal that serves as an id counter.
 * As a result, the id counter is shared across all instances of this
 * transform, generating unique ids across multiple data streams. In
 * addition, this signal value can be included in a snapshot of the
 * dataflow state, enabling correct resumption of id allocation.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.as - The field name for the generated identifier.
 */

function Identifier(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, 0, params);
}
Identifier.Definition = {
  'type': 'Identifier',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'as',
    'type': 'string',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Identifier, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const counter = getCounter(pulse.dataflow),
          as = _.as;
    let id = counter.value;
    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);
    counter.set(this.value = id);
    return pulse;
  }

});

function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}

/**
 * Bind scenegraph items to a scenegraph mark instance.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.markdef - The mark definition for creating the mark.
 *   This is an object of legal scenegraph mark properties which *must* include
 *   the 'marktype' property.
 */

function Mark(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Mark, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    let mark = this.value; // acquire mark on first invocation, bind context and group

    if (!mark) {
      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);
      mark.group.context = _.context;
      if (!_.context.group) _.context.group = mark.group;
      mark.source = this.source; // point to upstream collector

      mark.clip = _.clip;
      mark.interactive = _.interactive;
      this.value = mark;
    } // initialize entering items


    const Init = mark.marktype === Group ? vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.GroupItem : vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Item;
    pulse.visit(pulse.ADD, item => Init.call(item, mark)); // update clipping and/or interactive status

    if (_.modified('clip') || _.modified('interactive')) {
      mark.clip = _.clip;
      mark.interactive = !!_.interactive;
      mark.zdirty = true; // force scenegraph re-eval

      pulse.reflow();
    } // bind items array to scenegraph mark


    mark.items = pulse.source;
    return pulse;
  }

});

function lookup(_) {
  const g = _.groups,
        p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}

/**
 * Analyze items for overlap, changing opacity to hide items with
 * overlapping bounding boxes. This transform will preserve at least
 * two items (e.g., first and last) even if overlap persists.
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator
 *   function for sorting items.
 * @param {object} [params.method] - The overlap removal method to apply.
 *   One of 'parity' (default, hide every other item until there is no
 *   more overlap) or 'greedy' (sequentially scan and hide and items that
 *   overlap with the last visible item).
 * @param {object} [params.boundScale] - A scale whose range should be used
 *   to bound the items. Items exceeding the bounds of the scale range
 *   will be treated as overlapping. If null or undefined, no bounds check
 *   will be applied.
 * @param {object} [params.boundOrient] - The orientation of the scale
 *   (top, bottom, left, or right) used to bound items. This parameter is
 *   ignored if boundScale is null or undefined.
 * @param {object} [params.boundTolerance] - The tolerance in pixels for
 *   bound inclusion testing (default 1). This specifies by how many pixels
 *   an item's bounds may exceed the scale range bounds and not be culled.
 * @constructor
 */

function Overlap(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
const methods = {
  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items, sep) => {
    let a;
    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);
  }
}; // compute bounding box intersection
// including padding pixels of separation

const intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);

const hasOverlap = (items, pad) => {
  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {
    if (intersect(a, b = items[i].bounds, pad)) return true;
  }
};

const hasBounds = item => {
  const b = item.bounds;
  return b.width() > 1 && b.height() > 1;
};

const boundTest = (scale, orient, tolerance) => {
  var range = scale.range(),
      b = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds();

  if (orient === Top || orient === Bottom) {
    b.set(range[0], -Infinity, range[1], +Infinity);
  } else {
    b.set(-Infinity, range[0], +Infinity, range[1]);
  }

  b.expand(tolerance || 1);
  return item => b.encloses(item.bounds);
}; // reset all items to be fully opaque


const reset = source => {
  source.forEach(item => item.opacity = 1);
  return source;
}; // add all tuples to mod, fork pulse if parameters were modified
// fork prevents cross-stream tuple pollution (e.g., pulse from scale)


const reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');

(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Overlap, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const reduce = methods[_.method] || methods.parity,
          sep = _.separation || 0;
    let source = pulse.materialize(pulse.SOURCE).source,
        items,
        test;
    if (!source || !source.length) return;

    if (!_.method) {
      // early exit if method is falsy
      if (_.modified('method')) {
        reset(source);
        pulse = reflow(pulse, _);
      }

      return pulse;
    } // skip labels with no content


    source = source.filter(hasBounds); // early exit, nothing to do

    if (!source.length) return;

    if (_.sort) {
      source = source.slice().sort(_.sort);
    }

    items = reset(source);
    pulse = reflow(pulse, _);

    if (items.length >= 3 && hasOverlap(items, sep)) {
      do {
        items = reduce(items, sep);
      } while (items.length >= 3 && hasOverlap(items, sep));

      if (items.length < 3 && !(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(source).opacity) {
        if (items.length > 1) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(items).opacity = 0;
        (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(source).opacity = 1;
      }
    }

    if (_.boundScale && _.boundTolerance >= 0) {
      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source.forEach(item => {
        if (!test(item)) item.opacity = 0;
      });
    } // re-calculate mark bounds


    const bounds = items[0].mark.bounds.clear();
    source.forEach(item => {
      if (item.opacity) bounds.union(item.bounds);
    });
    return pulse;
  }

});

/**
 * Queue modified scenegraph items for rendering.
 * @constructor
 */

function Render(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Render, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow;
    pulse.visit(pulse.ALL, item => view.dirty(item)); // set z-index dirty flag as needed

    if (pulse.fields && pulse.fields['zindex']) {
      const item = pulse.source && pulse.source[0];
      if (item) item.mark.zdirty = true;
    }
  }

});

const tempBounds = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds();
function set(item, property, value) {
  return item[property] === value ? 0 : (item[property] = value, 1);
}

function isYAxis(mark) {
  var orient = mark.items[0].orient;
  return orient === Left || orient === Right;
}

function axisIndices(datum) {
  let index = +datum.grid;
  return [datum.ticks ? index++ : -1, // ticks index
  datum.labels ? index++ : -1, // labels index
  index + +datum.domain // title index
  ];
}

function axisLayout(view, axis, width, height) {
  var item = axis.items[0],
      datum = item.datum,
      delta = item.translate != null ? item.translate : 0.5,
      orient = item.orient,
      indices = axisIndices(datum),
      range = item.range,
      offset = item.offset,
      position = item.position,
      minExtent = item.minExtent,
      maxExtent = item.maxExtent,
      title = datum.title && item.items[indices[2]].items[0],
      titlePadding = item.titlePadding,
      bounds = item.bounds,
      dl = title && (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.multiLineOffset)(title),
      x = 0,
      y = 0,
      i,
      s;
  tempBounds.clear().union(bounds);
  bounds.clear();
  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);
  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds); // position axis group and title

  switch (orient) {
    case Top:
      x = position || 0;
      y = -offset;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));
      bounds.add(0, -s).add(range, 0);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);
      break;

    case Left:
      x = -offset;
      y = position || 0;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));
      bounds.add(-s, 0).add(0, range);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);
      break;

    case Right:
      x = width + offset;
      y = position || 0;
      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));
      bounds.add(0, 0).add(s, range);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);
      break;

    case Bottom:
      x = position || 0;
      y = height + offset;
      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));
      bounds.add(0, 0).add(range, s);
      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);
      break;

    default:
      x = item.x;
      y = item.y;
  } // update bounds


  (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundStroke)(bounds.translate(x, y), item);

  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {
    item.bounds = tempBounds;
    view.dirty(item);
    item.bounds = bounds;
    view.dirty(item);
  }

  return item.mark.bounds.clear().union(bounds);
}

function axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {
  const b = title.bounds;

  if (title.auto) {
    const v = sign * (offset + dl + pad);
    let dx = 0,
        dy = 0;
    view.dirty(title);
    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);
    title.mark.bounds.clear().union(b.translate(-dx, -dy));
    view.dirty(title);
  }

  bounds.union(b);
}

const min = (a, b) => Math.floor(Math.min(a, b));

const max = (a, b) => Math.ceil(Math.max(a, b));

function gridLayoutGroups(group) {
  var groups = group.items,
      n = groups.length,
      i = 0,
      mark,
      items;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  }; // layout axes, gather legends, collect bounds

  for (; i < n; ++i) {
    mark = groups[i];
    items = mark.items;

    if (mark.marktype === Group) {
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;

        case RowHeader:
          views.rowheaders.push(...items);
          break;

        case RowFooter:
          views.rowfooters.push(...items);
          break;

        case ColHeader:
          views.colheaders.push(...items);
          break;

        case ColFooter:
          views.colfooters.push(...items);
          break;

        case RowTitle:
          views.rowtitle = items[0];
          break;

        case ColTitle:
          views.coltitle = items[0];
          break;

        default:
          views.marks.push(...items);
      }
    }
  }

  return views;
}

function bboxFlush(item) {
  return new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds().set(0, 0, item.width || 0, item.height || 0);
}

function bboxFull(item) {
  const b = item.bounds.clone();
  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));
}

function get(opt, key, d) {
  const v = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(opt) ? opt[key] : opt;
  return v != null ? v : d !== undefined ? d : 0;
}

function offsetValue(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}

function gridLayout(view, groups, opt) {
  var dirty = !opt.nodirty,
      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,
      bounds = tempBounds.set(0, 0, 0, 0),
      alignCol = get(opt.align, Column),
      alignRow = get(opt.align, Row),
      padCol = get(opt.padding, Column),
      padRow = get(opt.padding, Row),
      ncols = opt.columns || groups.length,
      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),
      n = groups.length,
      xOffset = Array(n),
      xExtent = Array(ncols),
      xMax = 0,
      yOffset = Array(n),
      yExtent = Array(nrows),
      yMax = 0,
      dx = Array(n),
      dy = Array(n),
      boxes = Array(n),
      m,
      i,
      c,
      r,
      b,
      g,
      px,
      py,
      x,
      y,
      offset;

  for (i = 0; i < ncols; ++i) xExtent[i] = 0;

  for (i = 0; i < nrows; ++i) yExtent[i] = 0; // determine offsets for each group


  for (i = 0; i < n; ++i) {
    g = groups[i];
    b = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c = i % ncols;
    r = ~~(i / ncols);
    xMax = Math.max(xMax, px = Math.ceil(b.x2));
    yMax = Math.max(yMax, py = Math.ceil(b.y2));
    xExtent[c] = Math.max(xExtent[c], px);
    yExtent[r] = Math.max(yExtent[r], py);
    xOffset[i] = padCol + offsetValue(b.x1);
    yOffset[i] = padRow + offsetValue(b.y1);
    if (dirty) view.dirty(groups[i]);
  } // set initial alignment offsets


  for (i = 0; i < n; ++i) {
    if (i % ncols === 0) xOffset[i] = 0;
    if (i < ncols) yOffset[i] = 0;
  } // enforce column alignment constraints


  if (alignCol === Each) {
    for (c = 1; c < ncols; ++c) {
      for (offset = 0, i = c; i < n; i += ncols) {
        if (offset < xOffset[i]) offset = xOffset[i];
      }

      for (i = c; i < n; i += ncols) {
        xOffset[i] = offset + xExtent[c - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];
    }

    for (i = 0; i < n; ++i) {
      if (i % ncols) xOffset[i] = offset + xMax;
    }
  } else {
    for (alignCol = false, c = 1; c < ncols; ++c) {
      for (i = c; i < n; i += ncols) {
        xOffset[i] += xExtent[c - 1];
      }
    }
  } // enforce row alignment constraints


  if (alignRow === Each) {
    for (r = 1; r < nrows; ++r) {
      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {
        if (offset < yOffset[i]) offset = yOffset[i];
      }

      for (i = r * ncols; i < m; ++i) {
        yOffset[i] = offset + yExtent[r - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset = 0, i = ncols; i < n; ++i) {
      if (offset < yOffset[i]) offset = yOffset[i];
    }

    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset + yMax;
    }
  } else {
    for (alignRow = false, r = 1; r < nrows; ++r) {
      for (i = r * ncols, m = i + ncols; i < m; ++i) {
        yOffset[i] += yExtent[r - 1];
      }
    }
  } // perform horizontal grid layout


  for (x = 0, i = 0; i < n; ++i) {
    x = xOffset[i] + (i % ncols ? x : 0);
    dx[i] += x - groups[i].x;
  } // perform vertical grid layout


  for (c = 0; c < ncols; ++c) {
    for (y = 0, i = c; i < n; i += ncols) {
      y += yOffset[i];
      dy[i] += y - groups[i].y;
    }
  } // perform horizontal centering


  if (alignCol && get(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b = alignCol === All ? xMax : xExtent[i % ncols];
      x = b - boxes[i].x2 - groups[i].x - dx[i];
      if (x > 0) dx[i] += x / 2;
    }
  } // perform vertical centering


  if (alignRow && get(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y = b - boxes[i].y2 - groups[i].y - dy[i];
      if (y > 0) dy[i] += y / 2;
    }
  } // position grid relative to anchor


  for (i = 0; i < n; ++i) {
    bounds.union(boxes[i].translate(dx[i], dy[i]));
  }

  x = get(opt.anchor, X);
  y = get(opt.anchor, Y);

  switch (get(opt.anchor, Column)) {
    case End:
      x -= bounds.width();
      break;

    case Middle:
      x -= bounds.width() / 2;
  }

  switch (get(opt.anchor, Row)) {
    case End:
      y -= bounds.height();
      break;

    case Middle:
      y -= bounds.height() / 2;
  }

  x = Math.round(x);
  y = Math.round(y); // update mark positions, bounds, dirty

  bounds.clear();

  for (i = 0; i < n; ++i) {
    groups[i].mark.bounds.clear();
  }

  for (i = 0; i < n; ++i) {
    g = groups[i];
    g.x += dx[i] += x;
    g.y += dy[i] += y;
    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty) view.dirty(g);
  }

  return bounds;
}
function trellisLayout(view, group, opt) {
  var views = gridLayoutGroups(group),
      groups = views.marks,
      bbox = opt.bounds === Flush ? boundFlush : boundFull,
      off = opt.offset,
      ncols = opt.columns || groups.length,
      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),
      cells = nrows * ncols,
      x,
      y,
      x2,
      y2,
      anchor,
      band,
      offset; // -- initial grid layout

  const bounds = gridLayout(view, groups, opt);
  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid
  // -- layout grid headers and footers --
  // perform row header layout

  if (views.rowheaders) {
    band = get(opt.headerBand, Row, null);
    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);
  } // perform column header layout


  if (views.colheaders) {
    band = get(opt.headerBand, Column, null);
    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);
  } // perform row footer layout


  if (views.rowfooters) {
    band = get(opt.footerBand, Row, null);
    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);
  } // perform column footer layout


  if (views.colfooters) {
    band = get(opt.footerBand, Column, null);
    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);
  } // perform row title layout


  if (views.rowtitle) {
    anchor = get(opt.titleAnchor, Row);
    offset = get(off, 'rowTitle');
    offset = anchor === End ? x2 + offset : x - offset;
    band = get(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);
  } // perform column title layout


  if (views.coltitle) {
    anchor = get(opt.titleAnchor, Column);
    offset = get(off, 'columnTitle');
    offset = anchor === End ? y2 + offset : y - offset;
    band = get(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset, 1, bounds, band);
  }
}

function boundFlush(item, field) {
  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;
}

function boundFull(item, field) {
  return item.bounds[field];
}

function layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {
  var n = groups.length,
      init = 0,
      edge = 0,
      i,
      j,
      k,
      m,
      b,
      h,
      g,
      x,
      y; // if no groups, early exit and return 0

  if (!n) return init; // compute margin

  for (i = start; i < n; i += stride) {
    if (groups[i]) init = agg(init, bound(groups[i], bf));
  } // if no headers, return margin calculation


  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns

  if (headers.length > limit) {
    view.warn('Grid headers exceed limit: ' + limit);
    headers = headers.slice(0, limit);
  } // apply offset


  init += offset; // clear mark bounds for all headers

  for (j = 0, m = headers.length; j < m; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  } // layout each header


  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {
    h = headers[j];
    b = h.mark.bounds; // search for nearest group to align to
    // necessary if table has empty cells

    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back); // assign coordinates and update bounds


    if (isX) {
      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());
      y = init;
    } else {
      x = init;
      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());
    }

    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));
    h.x = x;
    h.y = y;
    view.dirty(h); // update current edge of layout bounds

    edge = agg(edge, b[bf]);
  }

  return edge;
}

function layoutTitle(view, g, offset, isX, bounds, band) {
  if (!g) return;
  view.dirty(g); // compute title coordinates

  var x = offset,
      y = offset;
  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds

  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x;
  g.y = y; // queue title for redraw

  view.dirty(g);
}

function lookup$1(config, orient) {
  const opt = config[orient] || {};
  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;
} // if legends specify offset directly, use the maximum specified value


function offsets(legends, value) {
  let max = -Infinity;
  legends.forEach(item => {
    if (item.offset != null) max = Math.max(max, item.offset);
  });
  return max > -Infinity ? max : value;
}

function legendParams(g, orient, config, xb, yb, w, h) {
  const _ = lookup$1(config, orient),
        offset = offsets(g, _('offset', 0)),
        anchor = _('anchor', Start),
        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;

  const p = {
    align: Each,
    bounds: _('bounds', Flush),
    columns: _('direction') === 'vertical' ? 1 : g.length,
    padding: _('margin', 8),
    center: _('center'),
    nodirty: true
  };

  switch (orient) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset,
        column: End,
        y: mult * (h || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;

    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset,
        y: mult * (h || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;

    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset,
        row: End,
        x: mult * (w || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;

    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset,
        x: mult * (w || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;

    case TopLeft:
      p.anchor = {
        x: offset,
        y: offset
      };
      break;

    case TopRight:
      p.anchor = {
        x: w - offset,
        y: offset,
        column: End
      };
      break;

    case BottomLeft:
      p.anchor = {
        x: offset,
        y: h - offset,
        row: End
      };
      break;

    case BottomRight:
      p.anchor = {
        x: w - offset,
        y: h - offset,
        column: End,
        row: End
      };
      break;
  }

  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0],
      datum = item.datum,
      orient = item.orient,
      bounds = item.bounds,
      x = item.x,
      y = item.y,
      w,
      h; // cache current bounds for later comparison

  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();
  bounds.clear(); // adjust legend to accommodate padding and title

  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin

  bounds = legendBounds(item, bounds);
  w = 2 * item.padding;
  h = 2 * item.padding;

  if (!bounds.empty()) {
    w = Math.ceil(bounds.width() + w);
    h = Math.ceil(bounds.height() + h);
  }

  if (datum.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }

  if (orient !== None) {
    item.x = x = 0;
    item.y = y = 0;
  }

  item.width = w;
  item.height = h;
  (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundStroke)(bounds.set(x, y, x + w, y + h), item);
  item.mark.bounds.clear().union(bounds);
  return item;
}

function legendBounds(item, b) {
  // aggregate item bounds
  item.items.forEach(_ => b.union(_.bounds)); // anchor to legend origin

  b.x1 = item.padding;
  b.y1 = item.padding;
  return b;
}

function legendGroupLayout(view, item, entry) {
  var pad = item.padding,
      ex = pad - entry.x,
      ey = pad - entry.y;

  if (!item.datum.title) {
    if (ex || ey) translate(view, entry, ex, ey);
  } else {
    var title = item.items[1].items[0],
        anchor = title.anchor,
        tpad = item.titlePadding || 0,
        tx = pad - title.x,
        ty = pad - title.y;

    switch (title.orient) {
      case Left:
        ex += Math.ceil(title.bounds.width()) + tpad;
        break;

      case Right:
      case Bottom:
        break;

      default:
        ey += title.bounds.height() + tpad;
    }

    if (ex || ey) translate(view, entry, ex, ey);

    switch (title.orient) {
      case Left:
        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);
        break;

      case Right:
        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);
        break;

      case Bottom:
        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);
        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;
        break;

      default:
        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);
    }

    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates

    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {
      translate(view, entry, -tx, 0);
      translate(view, title, -tx, 0);
    }
  }
}

function legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {
  const grad = item.datum.type !== 'symbol',
        vgrad = title.datum.vgrad,
        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,
        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,
        u = vgrad && lr ? s : 0,
        v = vgrad && lr ? 0 : s,
        o = y <= 0 ? 0 : (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.multiLineOffset)(title);
  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));
}

function translate(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}

function legendEntryLayout(entries) {
  // get max widths for each column
  const widths = entries.reduce((w, g) => {
    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);
    return w;
  }, {}); // set dimensions of legend entry groups

  entries.forEach(g => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}

function titleLayout(view, mark, width, height, viewBounds) {
  var group = mark.items[0],
      frame = group.frame,
      orient = group.orient,
      anchor = group.anchor,
      offset = group.offset,
      padding = group.padding,
      title = group.items[0].items[0],
      subtitle = group.items[1] && group.items[1].items[0],
      end = orient === Left || orient === Right ? height : width,
      start = 0,
      x = 0,
      y = 0,
      sx = 0,
      sy = 0,
      pos;

  if (frame !== Group) {
    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);
  } else if (orient === Left) {
    start = height, end = 0;
  }

  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;

  if (subtitle && subtitle.text) {
    // position subtitle
    switch (orient) {
      case Top:
      case Bottom:
        sy = title.bounds.height() + padding;
        break;

      case Left:
        sx = title.bounds.width() + padding;
        break;

      case Right:
        sx = -title.bounds.width() - padding;
        break;
    }

    tempBounds.clear().union(subtitle.bounds);
    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));

    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds);
      subtitle.mark.bounds.clear().union(tempBounds);
      view.dirty(subtitle);
    }

    tempBounds.clear().union(subtitle.bounds);
  } else {
    tempBounds.clear();
  }

  tempBounds.union(title.bounds); // position title group

  switch (orient) {
    case Top:
      x = pos;
      y = viewBounds.y1 - tempBounds.height() - offset;
      break;

    case Left:
      x = viewBounds.x1 - tempBounds.width() - offset;
      y = pos;
      break;

    case Right:
      x = viewBounds.x2 + tempBounds.width() + offset;
      y = pos;
      break;

    case Bottom:
      x = pos;
      y = viewBounds.y2 + offset;
      break;

    default:
      x = group.x;
      y = group.y;
  }

  if (set(group, 'x', x) | set(group, 'y', y)) {
    tempBounds.translate(x, y);
    view.dirty(group);
    group.bounds.clear().union(tempBounds);
    mark.bounds.clear().union(tempBounds);
    view.dirty(group);
  }

  return group.bounds;
}

/**
 * Layout view elements such as axes and legends.
 * Also performs size adjustments.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.mark - Scenegraph mark of groups to layout.
 */

function ViewLayout(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(ViewLayout, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow;

    _.mark.items.forEach(group => {
      if (_.layout) trellisLayout(view, group, _.layout);
      layoutGroup(view, group, _);
    });

    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;
  }

});

function shouldReflow(group) {
  // We typically should reflow if layout is invoked (#2568), as child items
  // may have resized and reflow ensures group bounds are re-calculated.
  // However, legend entries have a special exception to avoid instability.
  // For example, if a selected legend symbol gains a stroke on hover,
  // we don't want to re-position subsequent elements in the legend.
  return group && group.mark.role !== 'legend-entry';
}

function layoutGroup(view, group, _) {
  var items = group.items,
      width = Math.max(0, group.width || 0),
      height = Math.max(0, group.height || 0),
      viewBounds = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds().set(0, 0, width, height),
      xBounds = viewBounds.clone(),
      yBounds = viewBounds.clone(),
      legends = [],
      title,
      mark,
      orient,
      b,
      i,
      n; // layout axes, gather legends, collect bounds

  for (i = 0, n = items.length; i < n; ++i) {
    mark = items[i];

    switch (mark.role) {
      case AxisRole:
        b = isYAxis(mark) ? xBounds : yBounds;
        b.union(axisLayout(view, mark, width, height));
        break;

      case TitleRole:
        title = mark;
        break;

      case LegendRole:
        legends.push(legendLayout(view, mark));
        break;

      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark.bounds);
        yBounds.union(mark.bounds);
        break;

      default:
        viewBounds.union(mark.bounds);
    }
  } // layout legends, adjust viewBounds


  if (legends.length) {
    // group legends by orient
    const l = {};
    legends.forEach(item => {
      orient = item.orient || Right;
      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);
    }); // perform grid layout for each orient group

    for (const orient in l) {
      const g = l[orient];
      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));
    } // update view bounds


    legends.forEach(item => {
      const b = item.bounds;

      if (!b.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item); // dirty previous location

        item.bounds = b;
        view.dirty(item);
      }

      if (_.autosize && _.autosize.type === Fit) {
        // For autosize fit, incorporate the orthogonal dimension only.
        // Legends that overrun the chart area will then be clipped;
        // otherwise the chart area gets reduced to nothing!
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds.add(b.x1, 0).add(b.x2, 0);
            break;

          case Top:
          case Bottom:
            viewBounds.add(0, b.y1).add(0, b.y2);
        }
      } else {
        viewBounds.union(b);
      }
    });
  } // combine bounding boxes


  viewBounds.union(xBounds).union(yBounds); // layout title, adjust bounds

  if (title) {
    viewBounds.union(titleLayout(view, title, width, height, viewBounds));
  } // override aggregated view bounds if content is clipped


  if (group.clip) {
    viewBounds.set(0, 0, group.width || 0, group.height || 0);
  } // perform size adjustment


  viewSizeLayout(view, group, viewBounds, _);
}

function viewSizeLayout(view, group, viewBounds, _) {
  const auto = _.autosize || {},
        type = auto.type;
  if (view._autosize < 1 || !type) return;
  let viewWidth = view._width,
      viewHeight = view._height,
      width = Math.max(0, group.width || 0),
      left = Math.max(0, Math.ceil(-viewBounds.x1)),
      height = Math.max(0, group.height || 0),
      top = Math.max(0, Math.ceil(-viewBounds.y1));
  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),
        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));

  if (auto.contains === Padding) {
    const padding = view.padding();
    viewWidth -= padding.left + padding.right;
    viewHeight -= padding.top + padding.bottom;
  }

  if (type === None) {
    left = 0;
    top = 0;
    width = viewWidth;
    height = viewHeight;
  } else if (type === Fit) {
    width = Math.max(0, viewWidth - left - right);
    height = Math.max(0, viewHeight - top - bottom);
  } else if (type === FitX) {
    width = Math.max(0, viewWidth - left - right);
    viewHeight = height + top + bottom;
  } else if (type === FitY) {
    viewWidth = width + left + right;
    height = Math.max(0, viewHeight - top - bottom);
  } else if (type === Pad) {
    viewWidth = width + left + right;
    viewHeight = height + top + bottom;
  }

  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);
}




/***/ }),

/***/ "../../node_modules/vega-view/build/vega-view.module.js":
/*!**************************************************************!*\
  !*** ../../node_modules/vega-view/build/vega-view.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "View": () => (/* binding */ View)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "../../node_modules/d3-array/src/ticks.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-functions */ "../../node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-runtime */ "../../node_modules/vega-runtime/build/vega-runtime.module.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-timer */ "../../node_modules/d3-timer/src/interval.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-format */ "../../node_modules/vega-format/build/vega-format.module.js");









// initialize aria role and label attributes
function initializeAria(view) {
  const el = view.container();

  if (el) {
    el.setAttribute('role', 'graphics-document');
    el.setAttribute('aria-roleDescription', 'visualization');
    ariaLabel(el, view.description());
  }
} // update aria-label if we have a DOM container element

function ariaLabel(el, desc) {
  if (el) desc == null ? el.removeAttribute('aria-label') : el.setAttribute('aria-label', desc);
}

function background (view) {
  // respond to background signal
  view.add(null, _ => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}

const Default = 'default';
function cursor (view) {
  // get cursor signal, add to dataflow if needed
  const cursor = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  })); // evaluate cursor on each mousemove event

  view.on(view.events('view', 'mousemove'), cursor, (_, event) => {
    const value = cursor.value,
          user = value ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(value) ? value : value.user : Default,
          item = event.item && event.item.cursor || null;
    return value && user === value.user && item == value.item ? value : {
      user: user,
      item: item
    };
  }); // when cursor signal updates, set visible cursor

  view.add(null, function (_) {
    let user = _.cursor,
        item = this.value;

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(user)) {
      item = user.item;
      user = user.user;
    }

    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor
  });
}
function setCursor(view, cursor) {
  const el = view.globalCursor() ? typeof document !== 'undefined' && document.body : view.container();

  if (el) {
    return cursor == null ? el.style.removeProperty('cursor') : el.style.cursor = cursor;
  }
}

function dataref(view, name) {
  var data = view._runtime.data;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(data, name)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized data set: ' + name);
  }

  return data[name];
}
function data(name, values) {
  return arguments.length < 2 ? dataref(this, name).values.value : change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(values));
}
function change(name, changes) {
  if (!(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.isChangeSet)(changes)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Second argument to changes must be a changeset.');
  }

  const dataset = dataref(this, name);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name, _) {
  return change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().insert(_));
}
function remove(name, _) {
  return change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().remove(_));
}

function width(view) {
  var padding = view.padding();
  return Math.max(0, view._viewWidth + padding.left + padding.right);
}
function height(view) {
  var padding = view.padding();
  return Math.max(0, view._viewHeight + padding.top + padding.bottom);
}
function offset(view) {
  var padding = view.padding(),
      origin = view._origin;
  return [padding.left + origin[0], padding.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset(view),
      w = width(view),
      h = height(view);

  view._renderer.background(view.background());

  view._renderer.resize(w, h, origin);

  view._handler.origin(origin);

  view._resizeListeners.forEach(handler => {
    try {
      handler(w, h);
    } catch (error) {
      view.error(error);
    }
  });
}

/**
 * Extend an event with additional view-specific methods.
 * Adds a new property ('vega') to an event that provides a number
 * of methods for querying information about the current interaction.
 * The vega object provides the following methods:
 *   view - Returns the backing View instance.
 *   item - Returns the currently active scenegraph item (if any).
 *   group - Returns the currently active scenegraph group (if any).
 *     This method accepts a single string-typed argument indicating the name
 *     of the desired parent group. The scenegraph will be traversed from
 *     the item up towards the root to search for a matching group. If no
 *     argument is provided the enclosing group for the active item is
 *     returned, unless the item it itself a group, in which case it is
 *     returned directly.
 *   xy - Returns a two-element array containing the x and y coordinates for
 *     mouse or touch events. For touch events, this is based on the first
 *     elements in the changedTouches array. This method accepts a single
 *     argument: either an item instance or mark name that should serve as
 *     the reference coordinate system. If no argument is provided the
 *     top-level view coordinate system is assumed.
 *   x - Returns the current x-coordinate, accepts the same arguments as xy.
 *   y - Returns the current y-coordinate, accepts the same arguments as xy.
 * @param {Event} event - The input event to extend.
 * @param {Item} item - The currently active scenegraph item (if any).
 * @return {Event} - The extended input event.
 */

function eventExtend (view, event, item) {
  var r = view._renderer,
      el = r && r.canvas(),
      p,
      e,
      translate;

  if (el) {
    translate = offset(view);
    e = event.changedTouches ? event.changedTouches[0] : event;
    p = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.point)(e, el);
    p[0] -= translate[0];
    p[1] -= translate[1];
  }

  event.dataflow = view;
  event.item = item;
  event.vega = extension(view, item, p);
  return event;
}

function extension(view, item, point) {
  const itemGroup = item ? item.mark.marktype === 'group' ? item : item.mark.group : null;

  function group(name) {
    var g = itemGroup,
        i;
    if (name) for (i = item; i; i = i.mark.group) {
      if (i.mark.name === name) {
        g = i;
        break;
      }
    }
    return g && g.mark && g.mark.interactive ? g : {};
  }

  function xy(item) {
    if (!item) return point;
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(item)) item = group(item);
    const p = point.slice();

    while (item) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
      item = item.mark && item.mark.group;
    }

    return p;
  }

  return {
    view: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(view),
    item: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(item || {}),
    group: group,
    xy: xy,
    x: item => xy(item)[0],
    y: item => xy(item)[1]
  };
}

const VIEW = 'view',
      TIMER = 'timer',
      WINDOW = 'window',
      NO_TRAP = {
  trap: false
};
/**
 * Initialize event handling configuration.
 * @param {object} config - The configuration settings.
 * @return {object}
 */

function initializeEventConfig(config) {
  const events = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    defaults: {}
  }, config);

  const unpack = (obj, keys) => {
    keys.forEach(k => {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(obj[k])) obj[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(obj[k]);
    });
  };

  unpack(events.defaults, ['prevent', 'allow']);
  unpack(events, ['view', 'window', 'selector']);
  return events;
}
function trackEventListener(view, sources, type, handler) {
  view._eventListeners.push({
    type: type,
    sources: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(sources),
    handler: handler
  });
}

function prevent(view, type) {
  var def = view._eventConfig.defaults,
      prevent = def.prevent,
      allow = def.allow;
  return prevent === false || allow === true ? false : prevent === true || allow === false ? true : prevent ? prevent[type] : allow ? !allow[type] : view.preventDefault();
}

function permit(view, key, type) {
  const rule = view._eventConfig && view._eventConfig[key];

  if (rule === false || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(rule) && !rule[type]) {
    view.warn(`Blocked ${key} ${type} event listener.`);
    return false;
  }

  return true;
}
/**
 * Create a new event stream from an event source.
 * @param {object} source - The event source to monitor.
 * @param {string} type - The event type.
 * @param {function(object): boolean} [filter] - Event filter function.
 * @return {EventStream}
 */


function events(source, type, filter) {
  var view = this,
      s = new vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.EventStream(filter),
      send = function (e, item) {
    view.runAsync(null, () => {
      if (source === VIEW && prevent(view, type)) {
        e.preventDefault();
      }

      s.receive(eventExtend(view, e, item));
    });
  },
      sources;

  if (source === TIMER) {
    if (permit(view, 'timer', type)) {
      view.timer(send, type);
    }
  } else if (source === VIEW) {
    if (permit(view, 'view', type)) {
      // send traps errors, so use {trap: false} option
      view.addEventListener(type, send, NO_TRAP);
    }
  } else {
    if (source === WINDOW) {
      if (permit(view, 'window', type) && typeof window !== 'undefined') {
        sources = [window];
      }
    } else if (typeof document !== 'undefined') {
      if (permit(view, 'selector', type)) {
        sources = document.querySelectorAll(source);
      }
    }

    if (!sources) {
      view.warn('Can not resolve event source: ' + source);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type, send);
      }

      trackEventListener(view, sources, type, send);
    }
  }

  return s;
}

function itemFilter(event) {
  return event.item;
}

function markTarget(event) {
  // grab upstream collector feeding the mark operator
  return event.item.mark.source;
}

function invoke(name) {
  return function (_, event) {
    return event.vega.view().changeset().encode(event.item, name);
  };
}

function hover (hoverSet, leaveSet) {
  hoverSet = [hoverSet || 'hover'];
  leaveSet = [leaveSet || 'update', hoverSet[0]]; // invoke hover set upon mouseover

  this.on(this.events('view', 'mouseover', itemFilter), markTarget, invoke(hoverSet)); // invoke leave set upon mouseout

  this.on(this.events('view', 'mouseout', itemFilter), markTarget, invoke(leaveSet));
  return this;
}

/**
 * Finalize a View instance that is being removed.
 * Cancel any running timers.
 * Remove all external event listeners.
 * Remove any currently displayed tooltip.
 */
function finalize () {
  var tooltip = this._tooltip,
      timers = this._timers,
      listeners = this._eventListeners,
      n,
      m,
      e;
  n = timers.length;

  while (--n >= 0) {
    timers[n].stop();
  }

  n = listeners.length;

  while (--n >= 0) {
    e = listeners[n];
    m = e.sources.length;

    while (--m >= 0) {
      e.sources[m].removeEventListener(e.type, e.handler);
    }
  }

  if (tooltip) {
    tooltip.call(this, this._handler, null, null, null);
  }

  return this;
}

function element (tag, attr, text) {
  const el = document.createElement(tag);

  for (const key in attr) el.setAttribute(key, attr[key]);

  if (text != null) el.textContent = text;
  return el;
}

const BindClass = 'vega-bind',
      NameClass = 'vega-bind-name',
      RadioClass = 'vega-bind-radio';
/**
 * Bind a signal to an external HTML input element. The resulting two-way
 * binding will propagate input changes to signals, and propagate signal
 * changes to the input element state. If this view instance has no parent
 * element, we assume the view is headless and no bindings are created.
 * @param {Element|string} el - The parent DOM element to which the input
 *   element should be appended as a child. If string-valued, this argument
 *   will be treated as a CSS selector. If null or undefined, the parent
 *   element of this view will be used as the element.
 * @param {object} param - The binding parameters which specify the signal
 *   to bind to, the input element type, and type-specific configuration.
 * @return {View} - This view instance.
 */

function bind (view, el, binding) {
  if (!el) return;
  const param = binding.param;
  let bind = binding.state;

  if (!bind) {
    bind = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: value => {
        if (value != view.signal(param.signal)) {
          view.runAsync(null, () => {
            bind.source = true;
            view.signal(param.signal, value);
          });
        }
      }
    };

    if (param.debounce) {
      bind.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(param.debounce, bind.update);
    }
  }

  const create = param.input == null && param.element ? target : generate;
  create(bind, el, param, view);

  if (!bind.active) {
    view.on(view._signals[param.signal], null, () => {
      bind.source ? bind.source = false : bind.set(view.signal(param.signal));
    });
    bind.active = true;
  }

  return bind;
}
/**
 * Bind the signal to an external EventTarget.
 */

function target(bind, node, param, view) {
  const type = param.event || 'input';

  const handler = () => bind.update(node.value); // initialize signal value to external input value


  view.signal(param.signal, node.value); // listen for changes on the element

  node.addEventListener(type, handler); // register with view, so we can remove it upon finalization

  trackEventListener(view, node, type, handler); // propagate change to element

  bind.set = value => {
    node.value = value;
    node.dispatchEvent(event(type));
  };
}

function event(type) {
  return typeof Event !== 'undefined' ? new Event(type) : {
    type
  };
}
/**
 * Generate an HTML input form element and bind it to a signal.
 */


function generate(bind, el, param, view) {
  const value = view.signal(param.signal);
  const div = element('div', {
    'class': BindClass
  });
  const wrapper = param.input === 'radio' ? div : div.appendChild(element('label'));
  wrapper.appendChild(element('span', {
    'class': NameClass
  }, param.name || param.signal));
  el.appendChild(div);
  let input = form;

  switch (param.input) {
    case 'checkbox':
      input = checkbox;
      break;

    case 'select':
      input = select;
      break;

    case 'radio':
      input = radio;
      break;

    case 'range':
      input = range;
      break;
  }

  input(bind, wrapper, param, value);
}
/**
 * Generates an arbitrary input form element.
 * The input type is controlled via user-provided parameters.
 */


function form(bind, el, param, value) {
  const node = element('input');

  for (const key in param) {
    if (key !== 'signal' && key !== 'element') {
      node.setAttribute(key === 'input' ? 'type' : key, param[key]);
    }
  }

  node.setAttribute('name', param.signal);
  node.value = value;
  el.appendChild(node);
  node.addEventListener('input', () => bind.update(node.value));
  bind.elements = [node];

  bind.set = value => node.value = value;
}
/**
 * Generates a checkbox input element.
 */


function checkbox(bind, el, param, value) {
  const attr = {
    type: 'checkbox',
    name: param.signal
  };
  if (value) attr.checked = true;
  const node = element('input', attr);
  el.appendChild(node);
  node.addEventListener('change', () => bind.update(node.checked));
  bind.elements = [node];

  bind.set = value => node.checked = !!value || null;
}
/**
 * Generates a selection list input element.
 */


function select(bind, el, param, value) {
  const node = element('select', {
    name: param.signal
  }),
        labels = param.labels || [];
  param.options.forEach((option, i) => {
    const attr = {
      value: option
    };
    if (valuesEqual(option, value)) attr.selected = true;
    node.appendChild(element('option', attr, (labels[i] || option) + ''));
  });
  el.appendChild(node);
  node.addEventListener('change', () => {
    bind.update(param.options[node.selectedIndex]);
  });
  bind.elements = [node];

  bind.set = value => {
    for (let i = 0, n = param.options.length; i < n; ++i) {
      if (valuesEqual(param.options[i], value)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}
/**
 * Generates a radio button group.
 */


function radio(bind, el, param, value) {
  const group = element('span', {
    'class': RadioClass
  }),
        labels = param.labels || [];
  el.appendChild(group);
  bind.elements = param.options.map((option, i) => {
    const attr = {
      type: 'radio',
      name: param.signal,
      value: option
    };
    if (valuesEqual(option, value)) attr.checked = true;
    const input = element('input', attr);
    input.addEventListener('change', () => bind.update(option));
    const label = element('label', {}, (labels[i] || option) + '');
    label.prepend(input);
    group.appendChild(label);
    return input;
  });

  bind.set = value => {
    const nodes = bind.elements,
          n = nodes.length;

    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value)) nodes[i].checked = true;
    }
  };
}
/**
 * Generates a slider input element.
 */


function range(bind, el, param, value) {
  value = value !== undefined ? value : (+param.max + +param.min) / 2;
  const max = param.max != null ? param.max : Math.max(100, +value) || 100,
        min = param.min || Math.min(0, max, +value) || 0,
        step = param.step || (0,d3_array__WEBPACK_IMPORTED_MODULE_6__.tickStep)(min, max, 100);
  const node = element('input', {
    type: 'range',
    name: param.signal,
    min: min,
    max: max,
    step: step
  });
  node.value = value;
  const span = element('span', {}, +value);
  el.appendChild(node);
  el.appendChild(span);

  const update = () => {
    span.textContent = node.value;
    bind.update(+node.value);
  }; // subscribe to both input and change


  node.addEventListener('input', update);
  node.addEventListener('change', update);
  bind.elements = [node];

  bind.set = value => {
    node.value = value;
    span.textContent = value;
  };
}

function valuesEqual(a, b) {
  return a === b || a + '' === b + '';
}

function initializeRenderer (view, r, el, constructor, scaleFactor, opt) {
  r = r || new constructor(view.loader());
  return r.initialize(el, width(view), height(view), offset(view), scaleFactor, opt).background(view.background());
}

function trap (view, fn) {
  return !fn ? null : function () {
    try {
      fn.apply(this, arguments);
    } catch (error) {
      view.error(error);
    }
  };
}

function initializeHandler (view, prevHandler, el, constructor) {
  // instantiate scenegraph handler
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset(view), view); // transfer event handlers

  if (prevHandler) {
    prevHandler.handlers().forEach(h => {
      handler.on(h.type, h.handler);
    });
  }

  return handler;
}

function initialize (el, elBind) {
  const view = this,
        type = view._renderType,
        config = view._eventConfig.bind,
        module = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type); // containing dom element

  el = view._el = el ? lookup(view, el, true) : null; // initialize aria attributes

  initializeAria(view); // select appropriate renderer & handler

  if (!module) view.error('Unrecognized renderer type: ' + type);
  const Handler = module.handler || vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.CanvasHandler,
        Renderer = el ? module.renderer : module.headless; // initialize renderer and input handler

  view._renderer = !Renderer ? null : initializeRenderer(view, view._renderer, el, Renderer);
  view._handler = initializeHandler(view, view._handler, el, Handler);
  view._redraw = true; // initialize signal bindings

  if (el && config !== 'none') {
    elBind = elBind ? view._elBind = lookup(view, elBind, true) : el.appendChild(element('form', {
      'class': 'vega-bindings'
    }));

    view._bind.forEach(_ => {
      if (_.param.element && config !== 'container') {
        _.element = lookup(view, _.param.element, !!_.param.input);
      }
    });

    view._bind.forEach(_ => {
      bind(view, _.element || elBind, _);
    });
  }

  return view;
}

function lookup(view, el, clear) {
  if (typeof el === 'string') {
    if (typeof document !== 'undefined') {
      el = document.querySelector(el);

      if (!el) {
        view.error('Signal bind element not found: ' + el);
        return null;
      }
    } else {
      view.error('DOM document instance not found.');
      return null;
    }
  }

  if (el && clear) {
    try {
      el.innerHTML = '';
    } catch (e) {
      el = null;
      view.error(e);
    }
  }

  return el;
}

const number = _ => +_ || 0;

const paddingObject = _ => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});

function padding (_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) ? {
    top: number(_.top),
    bottom: number(_.bottom),
    left: number(_.left),
    right: number(_.right)
  } : paddingObject(number(_));
}

/**
 * Render the current scene in a headless fashion.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A Promise that resolves to a renderer.
 */

async function renderHeadless (view, type, scaleFactor, opt) {
  const module = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type),
        ctr = module && module.headless;
  if (!ctr) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized renderer type: ' + type);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}

/**
 * Produce an image URL for the visualization. Depending on the type
 * parameter, the generated URL contains data for either a PNG or SVG image.
 * The URL can be used (for example) to download images of the visualization.
 * This method is asynchronous, returning a Promise instance.
 * @param {string} type - The image type. One of 'svg', 'png' or 'canvas'.
 *   The 'canvas' and 'png' types are synonyms for a PNG image.
 * @return {Promise} - A promise that resolves to an image URL.
 */

async function renderToImageURL (type, scaleFactor) {
  if (type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas && type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG && type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.PNG) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized image type: ' + type);
  }

  const r = await renderHeadless(this, type, scaleFactor);
  return type === vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG ? toBlobURL(r.svg(), 'image/svg+xml') : r.canvas().toDataURL('image/png');
}

function toBlobURL(data, mime) {
  const blob = new Blob([data], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}

/**
 * Produce a Canvas instance containing a rendered visualization.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A promise that resolves to a Canvas instance.
 */

async function renderToCanvas (scaleFactor, opt) {
  const r = await renderHeadless(this, vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas, scaleFactor, opt);
  return r.canvas();
}

/**
 * Produce a rendered SVG string of the visualization.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A promise that resolves to an SVG string.
 */

async function renderToSVG (scaleFactor) {
  const r = await renderHeadless(this, vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG, scaleFactor);
  return r.svg();
}

function runtime (view, spec, expr) {
  return (0,vega_runtime__WEBPACK_IMPORTED_MODULE_4__.context)(view, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms, vega_functions__WEBPACK_IMPORTED_MODULE_3__.functionContext, expr).parse(spec);
}

function scale(name) {
  var scales = this._runtime.scales;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(scales, name)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale or projection: ' + name);
  }

  return scales[name].value;
}

var Width = 'width',
    Height = 'height',
    Padding = 'padding',
    Skip = {
  skip: true
};
function viewWidth(view, width) {
  var a = view.autosize(),
      p = view.padding();
  return width - (a && a.contains === Padding ? p.left + p.right : 0);
}
function viewHeight(view, height) {
  var a = view.autosize(),
      p = view.padding();
  return height - (a && a.contains === Padding ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s = view._signals,
      w = s[Width],
      h = s[Height],
      p = s[Padding];

  function resetSize() {
    view._autosize = view._resize = 1;
  } // respond to width signal


  view._resizeWidth = view.add(null, _ => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w
  }); // respond to height signal

  view._resizeHeight = view.add(null, _ => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h
  }); // respond to padding signal

  const resizePadding = view.add(null, resetSize, {
    pad: p
  }); // set rank to run immediately after source signal

  view._resizeWidth.rank = w.rank + 1;
  view._resizeHeight.rank = h.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth, viewHeight, width, height, origin, auto) {
  this.runAfter(view => {
    let rerun = 0; // reset autosize flag

    view._autosize = 0; // width value changed: update signal, skip resize op

    if (view.width() !== width) {
      rerun = 1;
      view.signal(Width, width, Skip); // set width, skip update calc

      view._resizeWidth.skip(true); // skip width resize handler

    } // height value changed: update signal, skip resize op


    if (view.height() !== height) {
      rerun = 1;
      view.signal(Height, height, Skip); // set height, skip update calc

      view._resizeHeight.skip(true); // skip height resize handler

    } // view width changed: update view property, set resize flag


    if (view._viewWidth !== viewWidth) {
      view._resize = 1;
      view._viewWidth = viewWidth;
    } // view height changed: update view property, set resize flag


    if (view._viewHeight !== viewHeight) {
      view._resize = 1;
      view._viewHeight = viewHeight;
    } // origin changed: update view property, set resize flag


    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    } // run dataflow on width/height signal change


    if (rerun) view.run('enter');
    if (auto) view.runAfter(v => v.resize());
  }, false, 1);
}

/**
 * Get the current view state, consisting of signal values and/or data sets.
 * @param {object} [options] - Options flags indicating which state to export.
 *   If unspecified, all signals and data sets will be exported.
 * @param {function(string, Operator):boolean} [options.signals] - Optional
 *   predicate function for testing if a signal should be included in the
 *   exported state. If unspecified, all signals will be included, except for
 *   those named 'parent' or those which refer to a Transform value.
 * @param {function(string, object):boolean} [options.data] - Optional
 *   predicate function for testing if a data set's input should be included
 *   in the exported state. If unspecified, all data sets that have been
 *   explicitly modified will be included.
 * @param {boolean} [options.recurse=true] - Flag indicating if the exported
 *   state should recursively include state from group mark sub-contexts.
 * @return {object} - An object containing the exported state values.
 */

function getState(options) {
  return this._runtime.getState(options || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}

function dataTest(name, data) {
  return data.modified && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data.input.value) && name.indexOf('_:vega:_');
}

function signalTest(name, op) {
  return !(name === 'parent' || op instanceof vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms.proxy);
}
/**
 * Sets the current view state and updates the view by invoking run.
 * @param {object} state - A state object containing signal and/or
 *   data set values, following the format used by the getState method.
 * @return {View} - This view instance.
 */


function setState(state) {
  this.runAsync(null, v => {
    v._trigger = false;

    v._runtime.setState(state);
  }, v => {
    v._trigger = true;
  });
  return this;
}

function timer (callback, delay) {
  function tick(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed: elapsed
    });
  }

  this._timers.push((0,d3_timer__WEBPACK_IMPORTED_MODULE_7__.default)(tick, delay));
}

function defaultTooltip (handler, event, item, value) {
  const el = handler.element();
  if (el) el.setAttribute('title', formatTooltip(value));
}

function formatTooltip(value) {
  return value == null ? '' : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? formatArray(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(value) ? formatObject(value) : value + '';
}

function formatObject(obj) {
  return Object.keys(obj).map(key => {
    const v = obj[key];
    return key + ': ' + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? formatArray(v) : formatValue(v));
  }).join('\n');
}

function formatArray(value) {
  return '[' + value.map(formatValue).join(', ') + ']';
}

function formatValue(value) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? '[\u2026]' : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(value) ? '{\u2026}' : value;
}

/**
 * Create a new View instance from a Vega dataflow runtime specification.
 * The generated View will not immediately be ready for display. Callers
 * should also invoke the initialize method (e.g., to set the parent
 * DOM element in browser-based deployment) and then invoke the run
 * method to evaluate the dataflow graph. Rendering will automatically
 * be performed upon dataflow runs.
 * @constructor
 * @param {object} spec - The Vega dataflow runtime specification.
 */

function View(spec, options) {
  const view = this;
  options = options || {};
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.call(view);
  if (options.loader) view.loader(options.loader);
  if (options.logger) view.logger(options.logger);
  if (options.logLevel != null) view.logLevel(options.logLevel);

  if (options.locale || spec.locale) {
    const loc = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, spec.locale, options.locale);
    view.locale((0,vega_format__WEBPACK_IMPORTED_MODULE_5__.locale)(loc.number, loc.time));
  }

  view._el = null;
  view._elBind = null;
  view._renderType = options.renderer || vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas;
  view._scenegraph = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.Scenegraph();
  const root = view._scenegraph.root; // initialize renderer, handler and event management

  view._renderer = null;
  view._tooltip = options.tooltip || defaultTooltip, view._redraw = true;
  view._handler = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.CanvasHandler().scene(root);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = []; // initialize event configuration

  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor); // initialize dataflow graph

  const ctx = runtime(view, spec, options.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map(_ => ({
    state: null,
    param: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _)
  })); // initialize scenegraph

  if (ctx.root) ctx.root.set(root);
  root.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root.items)); // initialize view size

  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view); // initialize background color

  background(view); // initialize cursor

  cursor(view); // initialize view description

  view.description(spec.description); // initialize hover proessing, if requested

  if (options.hover) view.hover(); // initialize DOM container(s) and renderer

  if (options.container) view.initialize(options.container, options.bind);
}

function lookupSignal(view, name) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(view._signals, name) ? view._signals[name] : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
}

function findOperatorHandler(op, handler) {
  const h = (op._targets || []).filter(op => op._update && op._update.handler === handler);
  return h.length ? h[0] : null;
}

function addOperatorListener(view, name, op, handler) {
  let h = findOperatorHandler(op, handler);

  if (!h) {
    h = trap(view, () => handler(name, op.value));
    h.handler = handler;
    view.on(op, null, h);
  }

  return view;
}

function removeOperatorListener(view, op, handler) {
  const h = findOperatorHandler(op, handler);
  if (h) op._targets.remove(h);
  return view;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(View, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(encode, prerun, postrun) {
    // evaluate dataflow and prerun
    await vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.prototype.evaluate.call(this, encode, prerun); // render as needed

    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }

          await this._renderer.renderAsync(this._scenegraph.root);
        }

        this._redraw = false;
      } catch (e) {
        this.error(e);
      }
    } // evaluate postrun


    if (postrun) (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.asyncCallback)(this, postrun);
    return this;
  },

  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },

  // -- GET / SET ----
  description(text) {
    if (arguments.length) {
      const desc = text != null ? text + '' : null;
      if (desc !== this._desc) ariaLabel(this._el, this._desc = desc);
      return this;
    }

    return this._desc;
  },

  container() {
    return this._el;
  },

  scenegraph() {
    return this._scenegraph;
  },

  origin() {
    return this._origin.slice();
  },

  signal(name, value, options) {
    const op = lookupSignal(this, name);
    return arguments.length === 1 ? op.value : this.update(op, value, options);
  },

  width(_) {
    return arguments.length ? this.signal('width', _) : this.signal('width');
  },

  height(_) {
    return arguments.length ? this.signal('height', _) : this.signal('height');
  },

  padding(_) {
    return arguments.length ? this.signal('padding', padding(_)) : padding(this.signal('padding'));
  },

  autosize(_) {
    return arguments.length ? this.signal('autosize', _) : this.signal('autosize');
  },

  background(_) {
    return arguments.length ? this.signal('background', _) : this.signal('background');
  },

  renderer(type) {
    if (!arguments.length) return this._renderType;
    if (!(0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized renderer type: ' + type);

    if (type !== this._renderType) {
      this._renderType = type;

      this._resetRenderer();
    }

    return this;
  },

  tooltip(handler) {
    if (!arguments.length) return this._tooltip;

    if (handler !== this._tooltip) {
      this._tooltip = handler;

      this._resetRenderer();
    }

    return this;
  },

  loader(loader) {
    if (!arguments.length) return this._loader;

    if (loader !== this._loader) {
      vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.prototype.loader.call(this, loader);

      this._resetRenderer();
    }

    return this;
  },

  resize() {
    // set flag to perform autosize
    this._autosize = 1; // touch autosize signal to ensure top-level ViewLayout runs

    return this.touch(lookupSignal(this, 'autosize'));
  },

  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },

  // -- SIZING ----
  _resizeView: resizeView,

  // -- EVENT HANDLING ----
  addEventListener(type, handler, options) {
    let callback = handler;

    if (!(options && options.trap === false)) {
      // wrap callback in error handler
      callback = trap(this, handler);
      callback.raw = handler;
    }

    this._handler.on(type, callback);

    return this;
  },

  removeEventListener(type, handler) {
    var handlers = this._handler.handlers(type),
        i = handlers.length,
        h,
        t; // search registered handlers, remove if match found


    while (--i >= 0) {
      t = handlers[i].type;
      h = handlers[i].handler;

      if (type === t && (handler === h || handler === h.raw)) {
        this._handler.off(t, h);

        break;
      }
    }

    return this;
  },

  addResizeListener(handler) {
    const l = this._resizeListeners;

    if (l.indexOf(handler) < 0) {
      // add handler if it isn't already registered
      // note: error trapping handled elsewhere, so
      // no need to wrap handlers here
      l.push(handler);
    }

    return this;
  },

  removeResizeListener(handler) {
    var l = this._resizeListeners,
        i = l.indexOf(handler);

    if (i >= 0) {
      l.splice(i, 1);
    }

    return this;
  },

  addSignalListener(name, handler) {
    return addOperatorListener(this, name, lookupSignal(this, name), handler);
  },

  removeSignalListener(name, handler) {
    return removeOperatorListener(this, lookupSignal(this, name), handler);
  },

  addDataListener(name, handler) {
    return addOperatorListener(this, name, dataref(this, name).values, handler);
  },

  removeDataListener(name, handler) {
    return removeOperatorListener(this, dataref(this, name).values, handler);
  },

  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev = setCursor(this, null); // clear previous cursor

        this._globalCursor = !!_;
        if (prev) setCursor(this, prev); // swap cursor
      }

      return this;
    } else {
      return this._globalCursor;
    }
  },

  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },

  timer,
  events,
  finalize,
  hover,
  // -- DATA ----
  data,
  change,
  insert,
  remove,
  // -- SCALES --
  scale,
  // -- INITIALIZATION ----
  initialize,
  // -- HEADLESS RENDERING ----
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  // -- SAVE / RESTORE STATE ----
  getState,
  setState
});




/***/ }),

/***/ "../../node_modules/vega-voronoi/build/vega-voronoi.module.js":
/*!********************************************************************!*\
  !*** ../../node_modules/vega-voronoi/build/vega-voronoi.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "voronoi": () => (/* binding */ Voronoi)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_delaunay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-delaunay */ "../../node_modules/d3-delaunay/src/delaunay.js");




function Voronoi(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Voronoi.Definition = {
  'type': 'Voronoi',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'extent',
    'type': 'array',
    'array': true,
    'length': 2,
    'default': [[-1e5, -1e5], [1e5, 1e5]],
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
const defaultExtent = [-1e5, -1e5, 1e5, 1e5];
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Voronoi, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const as = _.as || 'path',
          data = pulse.source; // nothing to do if no data

    if (!data || !data.length) return pulse; // configure and construct voronoi diagram

    let s = _.size;
    s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
    const voronoi = this.value = d3_delaunay__WEBPACK_IMPORTED_MODULE_2__.default.from(data, _.x, _.y).voronoi(s); // map polygons to paths

    for (let i = 0, n = data.length; i < n; ++i) {
      const polygon = voronoi.cellPolygon(i);
      data[i][as] = polygon ? toPathString(polygon) : null;
    }

    return pulse.reflow(_.modified()).modifies(as);
  }

}); // suppress duplicated end point vertices

function toPathString(p) {
  const x = p[0][0],
        y = p[0][1];
  let n = p.length - 1;

  for (; p[n][0] === x && p[n][1] === y; --n);

  return 'M' + p.slice(0, n + 1).join('L') + 'Z';
}




/***/ }),

/***/ "../../node_modules/vega-wordcloud/build/vega-wordcloud.module.js":
/*!************************************************************************!*\
  !*** ../../node_modules/vega-wordcloud/build/vega-wordcloud.module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wordcloud": () => (/* binding */ Wordcloud)
/* harmony export */ });
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-canvas */ "../../node_modules/vega-canvas/index.browser.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");






/*
Copyright (c) 2013, Jason Davies.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  * The name Jason Davies may not be used to endorse or promote products
    derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/
// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf

var cloudRadians = Math.PI / 180,
    cw = 1 << 11 >> 5,
    ch = 1 << 11;
function cloud () {
  var size = [256, 256],
      text,
      font,
      fontSize,
      fontStyle,
      fontWeight,
      rotate,
      padding,
      spiral = archimedeanSpiral,
      words = [],
      random = Math.random,
      cloud = {};

  cloud.layout = function () {
    var contextAndRatio = getContext((0,vega_canvas__WEBPACK_IMPORTED_MODULE_0__.canvas)()),
        board = zeroArray((size[0] >> 5) * size[1]),
        bounds = null,
        n = words.length,
        i = -1,
        tags = [],
        data = words.map(d => ({
      text: text(d),
      font: font(d),
      style: fontStyle(d),
      weight: fontWeight(d),
      rotate: rotate(d),
      size: ~~(fontSize(d) + 1e-14),
      padding: padding(d),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d
    })).sort((a, b) => b.size - a.size);

    while (++i < n) {
      var d = data[i];
      d.x = size[0] * (random() + .5) >> 1;
      d.y = size[1] * (random() + .5) >> 1;
      cloudSprite(contextAndRatio, d, data, i);

      if (d.hasText && place(board, d, bounds)) {
        tags.push(d);
        if (bounds) cloudBounds(bounds, d);else bounds = [{
          x: d.x + d.x0,
          y: d.y + d.y0
        }, {
          x: d.x + d.x1,
          y: d.y + d.y1
        }]; // Temporary hack

        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }

    return tags;
  };

  function getContext(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context = canvas.getContext('2d');
    context.fillStyle = context.strokeStyle = 'red';
    context.textAlign = 'center';
    return {
      context: context,
      ratio: ratio
    };
  }

  function place(board, tag, bounds) {
    var startX = tag.x,
        startY = tag.y,
        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
        s = spiral(size),
        dt = random() < .5 ? 1 : -1,
        t = -dt,
        dxdy,
        dx,
        dy;

    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue; // TODO only check for collisions within current bounds.

      if (!bounds || !cloudCollide(tag, board, size[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite,
              w = tag.width >> 5,
              sw = size[0] >> 5,
              lx = tag.x - (w << 4),
              sx = lx & 0x7f,
              msx = 32 - sx,
              h = tag.y1 - tag.y0,
              x = (tag.y + tag.y0) * sw + (lx >> 5),
              last;

          for (var j = 0; j < h; j++) {
            last = 0;

            for (var i = 0; i <= w; i++) {
              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
            }

            x += sw;
          }

          tag.sprite = null;
          return true;
        }
      }
    }

    return false;
  }

  cloud.words = function (_) {
    if (arguments.length) {
      words = _;
      return cloud;
    } else {
      return words;
    }
  };

  cloud.size = function (_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud;
    } else {
      return size;
    }
  };

  cloud.font = function (_) {
    if (arguments.length) {
      font = functor(_);
      return cloud;
    } else {
      return font;
    }
  };

  cloud.fontStyle = function (_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud;
    } else {
      return fontStyle;
    }
  };

  cloud.fontWeight = function (_) {
    if (arguments.length) {
      fontWeight = functor(_);
      return cloud;
    } else {
      return fontWeight;
    }
  };

  cloud.rotate = function (_) {
    if (arguments.length) {
      rotate = functor(_);
      return cloud;
    } else {
      return rotate;
    }
  };

  cloud.text = function (_) {
    if (arguments.length) {
      text = functor(_);
      return cloud;
    } else {
      return text;
    }
  };

  cloud.spiral = function (_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud;
    } else {
      return spiral;
    }
  };

  cloud.fontSize = function (_) {
    if (arguments.length) {
      fontSize = functor(_);
      return cloud;
    } else {
      return fontSize;
    }
  };

  cloud.padding = function (_) {
    if (arguments.length) {
      padding = functor(_);
      return cloud;
    } else {
      return padding;
    }
  };

  cloud.random = function (_) {
    if (arguments.length) {
      random = _;
      return cloud;
    } else {
      return random;
    }
  };

  return cloud;
} // Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.

function cloudSprite(contextAndRatio, d, data, di) {
  if (d.sprite) return;
  var c = contextAndRatio.context,
      ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0,
      y = 0,
      maxh = 0,
      n = data.length,
      w,
      w32,
      h,
      i,
      j;
  --di;

  while (++di < n) {
    d = data[di];
    c.save();
    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;
    w = c.measureText(d.text + 'm').width * ratio;
    h = d.size << 1;

    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians),
          cr = Math.cos(d.rotate * cloudRadians),
          wcr = w * cr,
          wsr = w * sr,
          hcr = h * cr,
          hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 0x1f >> 5 << 5;
    }

    if (h > maxh) maxh = h;

    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }

    if (y + h >= ch) break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate) c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);

    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }

    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }

  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
      sprite = [];

  while (--di >= 0) {
    d = data[di];
    if (!d.hasText) continue;
    w = d.width;
    w32 = w >> 5;
    h = d.y1 - d.y0; // Zero the buffer

    for (i = 0; i < h * w32; i++) sprite[i] = 0;

    x = d.xoff;
    if (x == null) return;
    y = d.yoff;
    var seen = 0,
        seenRow = -1;

    for (j = 0; j < h; j++) {
      for (i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5),
            m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }

      if (seen) seenRow = j;else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }

    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
} // Use mask-based collision detection.


function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite,
      w = tag.width >> 5,
      lx = tag.x - (w << 4),
      sx = lx & 0x7f,
      msx = 32 - sx,
      h = tag.y1 - tag.y0,
      x = (tag.y + tag.y0) * sw + (lx >> 5),
      last;

  for (var j = 0; j < h; j++) {
    last = 0;

    for (var i = 0; i <= w; i++) {
      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
    }

    x += sw;
  }

  return false;
}

function cloudBounds(bounds, d) {
  var b0 = bounds[0],
      b1 = bounds[1];
  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}

function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}

function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function (t) {
    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
  };
}

function rectangularSpiral(size) {
  var dy = 4,
      dx = dy * size[0] / size[1],
      x = 0,
      y = 0;
  return function (t) {
    var sign = t < 0 ? -1 : 1; // See triangular numbers: T_n = n * (n + 1) / 2.

    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;

      case 1:
        y += dy;
        break;

      case 2:
        x -= dx;
        break;

      default:
        y -= dy;
        break;
    }

    return [x, y];
  };
} // TODO reuse arrays?


function zeroArray(n) {
  var a = [],
      i = -1;

  while (++i < n) a[i] = 0;

  return a;
}

function functor(d) {
  return typeof d === 'function' ? d : function () {
    return d;
  };
}

var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};

const Output = ['x', 'y', 'font', 'fontSize', 'fontStyle', 'fontWeight', 'angle'];
const Params = ['text', 'font', 'rotate', 'fontSize', 'fontStyle', 'fontWeight'];
function Wordcloud(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, cloud(), params);
}
Wordcloud.Definition = {
  'type': 'Wordcloud',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'font',
    'type': 'string',
    'expr': true,
    'default': 'sans-serif'
  }, {
    'name': 'fontStyle',
    'type': 'string',
    'expr': true,
    'default': 'normal'
  }, {
    'name': 'fontWeight',
    'type': 'string',
    'expr': true,
    'default': 'normal'
  }, {
    'name': 'fontSize',
    'type': 'number',
    'expr': true,
    'default': 14
  }, {
    'name': 'fontSizeRange',
    'type': 'number',
    'array': 'nullable',
    'default': [10, 50]
  }, {
    'name': 'rotate',
    'type': 'number',
    'expr': true,
    'default': 0
  }, {
    'name': 'text',
    'type': 'field'
  }, {
    'name': 'spiral',
    'type': 'string',
    'values': ['archimedean', 'rectangular']
  }, {
    'name': 'padding',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 7,
    'default': Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Wordcloud, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (_.size && !(_.size[0] && _.size[1])) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Wordcloud size dimensions must be non-zero.');
    }

    function modp(param) {
      const p = _[param];
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(p) && pulse.modified(p.fields);
    }

    const mod = _.modified();

    if (!(mod || pulse.changed(pulse.ADD_REM) || Params.some(modp))) return;
    const data = pulse.materialize(pulse.SOURCE).source,
          layout = this.value,
          as = _.as || Output;
    let fontSize = _.fontSize || 14,
        range;
    (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(fontSize) ? range = _.fontSizeRange : fontSize = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.constant)(fontSize); // create font size scaling function as needed

    if (range) {
      const fsize = fontSize,
            sizeScale = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('sqrt')().domain((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.extent)(data, fsize)).range(range);

      fontSize = x => sizeScale(fsize(x));
    }

    data.forEach(t => {
      t[as[0]] = NaN;
      t[as[1]] = NaN;
      t[as[3]] = 0;
    }); // configure layout

    const words = layout.words(data).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || 'archimedean').rotate(_.rotate || 0).font(_.font || 'sans-serif').fontStyle(_.fontStyle || 'normal').fontWeight(_.fontWeight || 'normal').fontSize(fontSize).random(vega_statistics__WEBPACK_IMPORTED_MODULE_4__.random).layout();
    const size = layout.size(),
          dx = size[0] >> 1,
          dy = size[1] >> 1,
          n = words.length;

    for (let i = 0, w, t; i < n; ++i) {
      w = words[i];
      t = w.datum;
      t[as[0]] = w.x + dx;
      t[as[1]] = w.y + dy;
      t[as[2]] = w.font;
      t[as[3]] = w.size;
      t[as[4]] = w.style;
      t[as[5]] = w.weight;
      t[as[6]] = w.rotate;
    }

    return pulse.reflow(mod).modifies(as);
  }

});




/***/ }),

/***/ "../../node_modules/vega/build/vega.module.js":
/*!****************************************************!*\
  !*** ../../node_modules/vega/build/vega.module.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debug": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Debug),
/* harmony export */   "Error": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Error),
/* harmony export */   "Info": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Info),
/* harmony export */   "None": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.None),
/* harmony export */   "Warn": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Warn),
/* harmony export */   "accessor": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor),
/* harmony export */   "accessorFields": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields),
/* harmony export */   "accessorName": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
/* harmony export */   "array": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.array),
/* harmony export */   "ascending": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.ascending),
/* harmony export */   "clampRange": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.clampRange),
/* harmony export */   "compare": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.compare),
/* harmony export */   "constant": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.constant),
/* harmony export */   "debounce": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce),
/* harmony export */   "error": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.error),
/* harmony export */   "extend": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extend),
/* harmony export */   "extent": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extent),
/* harmony export */   "extentIndex": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extentIndex),
/* harmony export */   "falsy": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.falsy),
/* harmony export */   "fastmap": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap),
/* harmony export */   "field": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.field),
/* harmony export */   "flush": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.flush),
/* harmony export */   "hasOwnProperty": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty),
/* harmony export */   "id": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.id),
/* harmony export */   "identity": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.identity),
/* harmony export */   "inherits": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits),
/* harmony export */   "inrange": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange),
/* harmony export */   "isArray": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray),
/* harmony export */   "isBoolean": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isBoolean),
/* harmony export */   "isDate": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate),
/* harmony export */   "isFunction": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction),
/* harmony export */   "isIterable": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isIterable),
/* harmony export */   "isNumber": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber),
/* harmony export */   "isObject": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject),
/* harmony export */   "isRegExp": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp),
/* harmony export */   "isString": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isString),
/* harmony export */   "key": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.key),
/* harmony export */   "lerp": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.lerp),
/* harmony export */   "logger": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.logger),
/* harmony export */   "lruCache": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.lruCache),
/* harmony export */   "merge": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.merge),
/* harmony export */   "mergeConfig": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.mergeConfig),
/* harmony export */   "one": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.one),
/* harmony export */   "pad": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.pad),
/* harmony export */   "panLinear": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panLinear),
/* harmony export */   "panLog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panLog),
/* harmony export */   "panPow": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panPow),
/* harmony export */   "panSymlog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panSymlog),
/* harmony export */   "peek": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.peek),
/* harmony export */   "quarter": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.quarter),
/* harmony export */   "repeat": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.repeat),
/* harmony export */   "span": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.span),
/* harmony export */   "splitAccessPath": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.splitAccessPath),
/* harmony export */   "stringValue": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue),
/* harmony export */   "toBoolean": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean),
/* harmony export */   "toDate": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate),
/* harmony export */   "toNumber": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber),
/* harmony export */   "toSet": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet),
/* harmony export */   "toString": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toString),
/* harmony export */   "truncate": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.truncate),
/* harmony export */   "truthy": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy),
/* harmony export */   "utcquarter": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.utcquarter),
/* harmony export */   "visitArray": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray),
/* harmony export */   "writeConfig": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.writeConfig),
/* harmony export */   "zero": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zero),
/* harmony export */   "zoomLinear": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLinear),
/* harmony export */   "zoomLog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLog),
/* harmony export */   "zoomPow": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomPow),
/* harmony export */   "zoomSymlog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomSymlog),
/* harmony export */   "Dataflow": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow),
/* harmony export */   "EventStream": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.EventStream),
/* harmony export */   "MultiPulse": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.MultiPulse),
/* harmony export */   "Operator": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator),
/* harmony export */   "Parameters": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Parameters),
/* harmony export */   "Pulse": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Pulse),
/* harmony export */   "Transform": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   "changeset": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset),
/* harmony export */   "definition": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.definition),
/* harmony export */   "ingest": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest),
/* harmony export */   "isTuple": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.isTuple),
/* harmony export */   "transform": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transform),
/* harmony export */   "transforms": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms),
/* harmony export */   "tupleid": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid),
/* harmony export */   "bandwidthNRD": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bandwidthNRD),
/* harmony export */   "bin": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bin),
/* harmony export */   "bootstrapCI": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bootstrapCI),
/* harmony export */   "cumulativeLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeLogNormal),
/* harmony export */   "cumulativeNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeNormal),
/* harmony export */   "cumulativeUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeUniform),
/* harmony export */   "densityLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityLogNormal),
/* harmony export */   "densityNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityNormal),
/* harmony export */   "densityUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityUniform),
/* harmony export */   "dotbin": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.dotbin),
/* harmony export */   "quantileLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileLogNormal),
/* harmony export */   "quantileNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileNormal),
/* harmony export */   "quantileUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileUniform),
/* harmony export */   "quantiles": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantiles),
/* harmony export */   "quartiles": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quartiles),
/* harmony export */   "random": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.random),
/* harmony export */   "randomInteger": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomInteger),
/* harmony export */   "randomKDE": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomKDE),
/* harmony export */   "randomLCG": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomLCG),
/* harmony export */   "randomLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomLogNormal),
/* harmony export */   "randomMixture": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomMixture),
/* harmony export */   "randomNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomNormal),
/* harmony export */   "randomUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomUniform),
/* harmony export */   "regressionExp": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionExp),
/* harmony export */   "regressionLinear": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLinear),
/* harmony export */   "regressionLoess": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLoess),
/* harmony export */   "regressionLog": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLog),
/* harmony export */   "regressionPoly": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionPoly),
/* harmony export */   "regressionPow": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionPow),
/* harmony export */   "regressionQuad": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionQuad),
/* harmony export */   "sampleCurve": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleCurve),
/* harmony export */   "sampleLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleLogNormal),
/* harmony export */   "sampleNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleNormal),
/* harmony export */   "sampleUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleUniform),
/* harmony export */   "setRandom": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.setRandom),
/* harmony export */   "DATE": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DATE),
/* harmony export */   "DAY": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DAY),
/* harmony export */   "DAYOFYEAR": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DAYOFYEAR),
/* harmony export */   "HOURS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.HOURS),
/* harmony export */   "MILLISECONDS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MILLISECONDS),
/* harmony export */   "MINUTES": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MINUTES),
/* harmony export */   "MONTH": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MONTH),
/* harmony export */   "QUARTER": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.QUARTER),
/* harmony export */   "SECONDS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.SECONDS),
/* harmony export */   "TIME_UNITS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.TIME_UNITS),
/* harmony export */   "WEEK": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.WEEK),
/* harmony export */   "YEAR": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.YEAR),
/* harmony export */   "dayofyear": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.dayofyear),
/* harmony export */   "timeBin": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeBin),
/* harmony export */   "timeFloor": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeFloor),
/* harmony export */   "timeInterval": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeInterval),
/* harmony export */   "timeOffset": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeOffset),
/* harmony export */   "timeSequence": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeSequence),
/* harmony export */   "timeUnitSpecifier": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeUnitSpecifier),
/* harmony export */   "timeUnits": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeUnits),
/* harmony export */   "utcFloor": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcFloor),
/* harmony export */   "utcInterval": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcInterval),
/* harmony export */   "utcOffset": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcOffset),
/* harmony export */   "utcSequence": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcSequence),
/* harmony export */   "utcdayofyear": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcdayofyear),
/* harmony export */   "utcweek": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcweek),
/* harmony export */   "week": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.week),
/* harmony export */   "format": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.format),
/* harmony export */   "formats": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.formats),
/* harmony export */   "inferType": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.inferType),
/* harmony export */   "inferTypes": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.inferTypes),
/* harmony export */   "loader": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.loader),
/* harmony export */   "read": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.read),
/* harmony export */   "responseType": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.responseType),
/* harmony export */   "typeParsers": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.typeParsers),
/* harmony export */   "Bounds": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Bounds),
/* harmony export */   "CanvasHandler": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.CanvasHandler),
/* harmony export */   "CanvasRenderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.CanvasRenderer),
/* harmony export */   "Gradient": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Gradient),
/* harmony export */   "GroupItem": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.GroupItem),
/* harmony export */   "Handler": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Handler),
/* harmony export */   "Item": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Item),
/* harmony export */   "Marks": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Marks),
/* harmony export */   "RenderType": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.RenderType),
/* harmony export */   "Renderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Renderer),
/* harmony export */   "ResourceLoader": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.ResourceLoader),
/* harmony export */   "SVGHandler": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGHandler),
/* harmony export */   "SVGRenderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGRenderer),
/* harmony export */   "SVGStringRenderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGStringRenderer),
/* harmony export */   "Scenegraph": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Scenegraph),
/* harmony export */   "boundClip": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundClip),
/* harmony export */   "boundContext": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundContext),
/* harmony export */   "boundItem": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundItem),
/* harmony export */   "boundMark": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundMark),
/* harmony export */   "boundStroke": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundStroke),
/* harmony export */   "domChild": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domChild),
/* harmony export */   "domClear": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domClear),
/* harmony export */   "domCreate": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domCreate),
/* harmony export */   "domFind": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domFind),
/* harmony export */   "font": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.font),
/* harmony export */   "fontFamily": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.fontFamily),
/* harmony export */   "fontSize": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.fontSize),
/* harmony export */   "intersect": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersect),
/* harmony export */   "intersectBoxLine": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectBoxLine),
/* harmony export */   "intersectPath": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectPath),
/* harmony export */   "intersectPoint": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectPoint),
/* harmony export */   "intersectRule": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectRule),
/* harmony export */   "lineHeight": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.lineHeight),
/* harmony export */   "markup": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.markup),
/* harmony export */   "multiLineOffset": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.multiLineOffset),
/* harmony export */   "pathCurves": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathCurves),
/* harmony export */   "pathEqual": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathEqual),
/* harmony export */   "pathParse": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathParse),
/* harmony export */   "pathRectangle": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathRectangle),
/* harmony export */   "pathRender": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathRender),
/* harmony export */   "pathSymbols": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathSymbols),
/* harmony export */   "pathTrail": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathTrail),
/* harmony export */   "point": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.point),
/* harmony export */   "renderModule": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.renderModule),
/* harmony export */   "resetSVGClipId": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.resetSVGClipId),
/* harmony export */   "resetSVGDefIds": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.resetSVGDefIds),
/* harmony export */   "sceneEqual": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneEqual),
/* harmony export */   "sceneFromJSON": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneFromJSON),
/* harmony export */   "scenePickVisit": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.scenePickVisit),
/* harmony export */   "sceneToJSON": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneToJSON),
/* harmony export */   "sceneVisit": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneVisit),
/* harmony export */   "sceneZOrder": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneZOrder),
/* harmony export */   "serializeXML": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.serializeXML),
/* harmony export */   "textMetrics": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.textMetrics),
/* harmony export */   "interpolate": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolate),
/* harmony export */   "interpolateColors": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolateColors),
/* harmony export */   "interpolateRange": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolateRange),
/* harmony export */   "quantizeInterpolator": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.quantizeInterpolator),
/* harmony export */   "scale": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.scale),
/* harmony export */   "scheme": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.scheme),
/* harmony export */   "projection": () => (/* reexport safe */ vega_projection__WEBPACK_IMPORTED_MODULE_18__.projection),
/* harmony export */   "View": () => (/* reexport safe */ vega_view__WEBPACK_IMPORTED_MODULE_19__.View),
/* harmony export */   "defaultLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.defaultLocale),
/* harmony export */   "formatLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.numberFormatDefaultLocale),
/* harmony export */   "locale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.locale),
/* harmony export */   "resetDefaultLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.resetDefaultLocale),
/* harmony export */   "timeFormatLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.timeFormatDefaultLocale),
/* harmony export */   "expressionFunction": () => (/* reexport safe */ vega_functions__WEBPACK_IMPORTED_MODULE_21__.expressionFunction),
/* harmony export */   "parse": () => (/* reexport safe */ vega_parser__WEBPACK_IMPORTED_MODULE_22__.parse),
/* harmony export */   "runtimeContext": () => (/* reexport safe */ vega_runtime__WEBPACK_IMPORTED_MODULE_23__.context),
/* harmony export */   "codegenExpression": () => (/* reexport safe */ vega_expression__WEBPACK_IMPORTED_MODULE_24__.codegenExpression),
/* harmony export */   "parseExpression": () => (/* reexport safe */ vega_expression__WEBPACK_IMPORTED_MODULE_24__.parseExpression),
/* harmony export */   "parseSelector": () => (/* reexport safe */ vega_event_selector__WEBPACK_IMPORTED_MODULE_25__.parseSelector),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "../../node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "../../node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_transforms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-transforms */ "../../node_modules/vega-transforms/build/vega-transforms.module.js");
/* harmony import */ var vega_view_transforms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-view-transforms */ "../../node_modules/vega-view-transforms/build/vega-view-transforms.module.js");
/* harmony import */ var vega_encode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-encode */ "../../node_modules/vega-encode/build/vega-encode.module.js");
/* harmony import */ var vega_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-geo */ "../../node_modules/vega-geo/build/vega-geo.module.js");
/* harmony import */ var vega_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-force */ "../../node_modules/vega-force/build/vega-force.module.js");
/* harmony import */ var vega_hierarchy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-hierarchy */ "../../node_modules/vega-hierarchy/build/vega-hierarchy.module.js");
/* harmony import */ var vega_label__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vega-label */ "../../node_modules/vega-label/build/vega-label.module.js");
/* harmony import */ var vega_regression__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vega-regression */ "../../node_modules/vega-regression/build/vega-regression.module.js");
/* harmony import */ var vega_voronoi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vega-voronoi */ "../../node_modules/vega-voronoi/build/vega-voronoi.module.js");
/* harmony import */ var vega_wordcloud__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! vega-wordcloud */ "../../node_modules/vega-wordcloud/build/vega-wordcloud.module.js");
/* harmony import */ var vega_crossfilter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! vega-crossfilter */ "../../node_modules/vega-crossfilter/build/vega-crossfilter.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! vega-statistics */ "../../node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! vega-time */ "../../node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! vega-loader */ "../../node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! vega-scenegraph */ "../../node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! vega-scale */ "../../node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_projection__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! vega-projection */ "../../node_modules/vega-projection/build/vega-projection.module.js");
/* harmony import */ var vega_view__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! vega-view */ "../../node_modules/vega-view/build/vega-view.module.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! vega-format */ "../../node_modules/vega-format/build/vega-format.module.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! vega-functions */ "../../node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_parser__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! vega-parser */ "../../node_modules/vega-parser/build/vega-parser.module.js");
/* harmony import */ var vega_runtime__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! vega-runtime */ "../../node_modules/vega-runtime/build/vega-runtime.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! vega-expression */ "../../node_modules/vega-expression/build/vega-expression.module.js");
/* harmony import */ var vega_event_selector__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! vega-event-selector */ "../../node_modules/vega-event-selector/build/vega-event-selector.module.js");





























var name = "vega";
var version$1 = "5.21.0";
var description = "The Vega visualization grammar.";
var keywords = [
	"vega",
	"visualization",
	"interaction",
	"dataflow",
	"library",
	"data",
	"d3"
];
var license = "BSD-3-Clause";
var author = "UW Interactive Data Lab (http://idl.cs.washington.edu)";
var main = "build/vega-node.js";
var module = "build/vega.module.js";
var unpkg = "build/vega.min.js";
var jsdelivr = "build/vega.min.js";
var types = "index.d.ts";
var repository = "vega/vega";
var scripts = {
	bundle: "rollup -c --config-bundle",
	prebuild: "rimraf build && rimraf build-es5",
	build: "rollup -c --config-core --config-bundle --config-ie",
	postbuild: "node schema-copy",
	pretest: "yarn build --config-test",
	test: "TZ=America/Los_Angeles tape 'test/**/*-test.js'",
	prepublishOnly: "yarn test && yarn build",
	postpublish: "./schema-deploy.sh"
};
var dependencies = {
	"vega-crossfilter": "~4.0.5",
	"vega-dataflow": "~5.7.4",
	"vega-encode": "~4.8.3",
	"vega-event-selector": "~3.0.0",
	"vega-expression": "~5.0.0",
	"vega-force": "~4.0.7",
	"vega-format": "~1.0.4",
	"vega-functions": "~5.12.1",
	"vega-geo": "~4.3.8",
	"vega-hierarchy": "~4.0.9",
	"vega-label": "~1.1.0",
	"vega-loader": "~4.4.1",
	"vega-parser": "~6.1.4",
	"vega-projection": "~1.4.5",
	"vega-regression": "~1.0.9",
	"vega-runtime": "~6.1.3",
	"vega-scale": "~7.1.1",
	"vega-scenegraph": "~4.9.4",
	"vega-statistics": "~1.7.10",
	"vega-time": "~2.0.4",
	"vega-transforms": "~4.9.4",
	"vega-typings": "~0.22.0",
	"vega-util": "~1.17.0",
	"vega-view": "~5.10.1",
	"vega-view-transforms": "~4.5.8",
	"vega-voronoi": "~4.1.5",
	"vega-wordcloud": "~4.1.3"
};
var devDependencies = {
	"vega-schema": "*"
};
var gitHead = "774165e29850b66ec8b79ba52a7955f1ab936ea6";
var pkg = {
	name: name,
	version: version$1,
	description: description,
	keywords: keywords,
	license: license,
	author: author,
	main: main,
	module: module,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	types: types,
	repository: repository,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	gitHead: gitHead
};

// -- Transforms -----
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms, vega_transforms__WEBPACK_IMPORTED_MODULE_2__, vega_view_transforms__WEBPACK_IMPORTED_MODULE_3__, vega_encode__WEBPACK_IMPORTED_MODULE_4__, vega_geo__WEBPACK_IMPORTED_MODULE_5__, vega_force__WEBPACK_IMPORTED_MODULE_6__, vega_label__WEBPACK_IMPORTED_MODULE_8__, vega_hierarchy__WEBPACK_IMPORTED_MODULE_7__, vega_regression__WEBPACK_IMPORTED_MODULE_9__, vega_voronoi__WEBPACK_IMPORTED_MODULE_10__, vega_wordcloud__WEBPACK_IMPORTED_MODULE_11__, vega_crossfilter__WEBPACK_IMPORTED_MODULE_12__); // -- Exports -----

const version = pkg.version;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9hc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2RldmlhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9mc3VtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21heC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZWFuLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21lZGlhbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3Blcm11dGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcXVhbnRpbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcXVpY2tzZWxlY3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc3VtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3RpY2tzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3ZhcmlhbmNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2NvbG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL2N1YmVoZWxpeC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvbGFiLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtY29sb3Ivc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1kZWxhdW5heS9zcmMvZGVsYXVuYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1kZWxhdW5heS9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWRlbGF1bmF5L3NyYy9wb2x5Z29uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZGVsYXVuYXkvc3JjL3Zvcm9ub2kuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1kaXNwYXRjaC9zcmMvZGlzcGF0Y2guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1kc3Yvc3JjL2Rzdi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jZW50ZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvY29sbGlkZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9qaWdnbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvbGNnLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL2xpbmsuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvbWFueUJvZHkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvc2ltdWxhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy94LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2V4cG9uZW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXREZWNpbWFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRHcm91cC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0TnVtZXJhbHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFByZWZpeEF1dG8uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFJvdW5kZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFNwZWNpZmllci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHJpbS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHlwZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9sb2NhbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvbkZpeGVkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9wcmVjaXNpb25QcmVmaXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvblJvdW5kLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9zcmMvbW9sbHdlaWRlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9hcmVhLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9ib3VuZHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NhcnRlc2lhbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9hbnRpbWVyaWRpYW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvYnVmZmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL2NpcmNsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9saW5lLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jbGlwL3JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9yZWpvaW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9ncmF0aWN1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9tYXRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9ub29wLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2FyZWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvYm91bmRzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2NlbnRyb2lkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BhdGgvbWVhc3VyZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BvaW50RXF1YWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3BvbHlnb25Db250YWlucy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hbGJlcnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vYWxiZXJzVXNhLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2F6aW11dGhhbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hemltdXRoYWxFcXVhbEFyZWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vYXppbXV0aGFsRXF1aWRpc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vY29uaWMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vY29uaWNDb25mb3JtYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vY29uaWNFcXVhbEFyZWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vY29uaWNFcXVpZGlzdGFudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9jeWxpbmRyaWNhbEVxdWFsQXJlYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9lcXVhbEVhcnRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2VxdWlyZWN0YW5ndWxhci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9maXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vZ25vbW9uaWMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vbWVyY2F0b3IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vbmF0dXJhbEVhcnRoMS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9vcnRob2dyYXBoaWMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vcmVzYW1wbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vc3RlcmVvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi90cmFuc3ZlcnNlTWVyY2F0b3IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3JvdGF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvYWNjZXNzb3JzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvY2x1c3Rlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9hbmNlc3RvcnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9jb3VudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2Rlc2NlbmRhbnRzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvZWFjaC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2VhY2hBZnRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2VhY2hCZWZvcmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9maW5kLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2xlYXZlcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2xpbmtzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvcGF0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L3NvcnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9zdW0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3BhY2svZW5jbG9zZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvcGFjay9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvcGFjay9zaWJsaW5ncy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvcGFydGl0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9zdHJhdGlmeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3RyZWVtYXAvZGljZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9yZXNxdWFyaWZ5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL3JvdW5kLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL3NsaWNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL3NsaWNlRGljZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9zcXVhcmlmeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9iYXNpc0Nsb3NlZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jdWJlaGVsaXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvZGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9kaXNjcmV0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9oY2wuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvaHNsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2h1ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL251bWJlckFycmF5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL29iamVjdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9waWVjZXdpc2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcXVhbnRpemUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcmdiLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3JvdW5kLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3N0cmluZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vZGVjb21wb3NlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3RyYW5zZm9ybS9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vcGFyc2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdmFsdWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvem9vbS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXBhdGgvc3JjL3BhdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvYWRkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2NvdmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2RhdGEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZXh0ZW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9xdWFkdHJlZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcm9vdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9zaXplLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Zpc2l0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Zpc2l0QWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMveC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy95LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnRpbnVvdXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvZGl2ZXJnaW5nLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2luaXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbGluZWFyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2xvZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9uaWNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9vcmRpbmFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3Bvdy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGlsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGl6ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3N5bWxvZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy90aHJlc2hvbGQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGlja0Zvcm1hdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy90aW1lLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3V0Y1RpbWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJjLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FyZWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXNDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXNPcGVuLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2J1bmRsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbENsb3NlZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbE9wZW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2F0bXVsbFJvbS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tQ2xvc2VkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb21PcGVuLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXJDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvbW9ub3RvbmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvbmF0dXJhbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9zdGVwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2xpbmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9ub29wLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3BvaW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY2lyY2xlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9jcm9zcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvZGlhbW9uZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC9zdGFyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL3N5bWJvbC90cmlhbmdsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvd3llLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvc3JjL2RlZmF1bHRMb2NhbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lLWZvcm1hdC9zcmMvbG9jYWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvZGF5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvZHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9ob3VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvaW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9taWxsaXNlY29uZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL21pbnV0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL21vbnRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvc2Vjb25kLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdGlja3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNEYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNIb3VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjTWludXRlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjTW9udGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNXZWVrLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjWWVhci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3dlZWsuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy95ZWFyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL2ludGVydmFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvZGVsYXVuYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvYmJveC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvYmlzZWN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9mZWF0dXJlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL21lcmdlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9tZXNoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9uZWlnaGJvcnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL3F1YW50aXplLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9yZXZlcnNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9zdGl0Y2guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvdW50cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWNhbnZhcy9pbmRleC5icm93c2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1jYW52YXMvc3JjL2RvbUNhbnZhcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtY3Jvc3NmaWx0ZXIvYnVpbGQvdmVnYS1jcm9zc2ZpbHRlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L2J1aWxkL3ZlZ2EtZGF0YWZsb3cubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1lbmNvZGUvYnVpbGQvdmVnYS1lbmNvZGUubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1ldmVudC1zZWxlY3Rvci9idWlsZC92ZWdhLWV2ZW50LXNlbGVjdG9yLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9idWlsZC92ZWdhLWV4cHJlc3Npb24ubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1mb3JjZS9idWlsZC92ZWdhLWZvcmNlLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9ybWF0L2J1aWxkL3ZlZ2EtZm9ybWF0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZnVuY3Rpb25zL2J1aWxkL3ZlZ2EtZnVuY3Rpb25zLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtZ2VvL2J1aWxkL3ZlZ2EtZ2VvLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L2J1aWxkL3ZlZ2EtaGllcmFyY2h5Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtbGFiZWwvYnVpbGQvdmVnYS1sYWJlbC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLWxvYWRlci9idWlsZC92ZWdhLWxvYWRlci5icm93c2VyLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtcGFyc2VyL2J1aWxkL3ZlZ2EtcGFyc2VyLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtcHJvamVjdGlvbi9idWlsZC92ZWdhLXByb2plY3Rpb24ubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS1yZWdyZXNzaW9uL2J1aWxkL3ZlZ2EtcmVncmVzc2lvbi5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXJ1bnRpbWUvYnVpbGQvdmVnYS1ydW50aW1lLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NhbGUvYnVpbGQvdmVnYS1zY2FsZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXNjZW5lZ3JhcGgvYnVpbGQvdmVnYS1zY2VuZWdyYXBoLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2VsZWN0aW9ucy9idWlsZC92ZWdhLXNlbGVjdGlvbi5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXN0YXRpc3RpY3MvYnVpbGQvdmVnYS1zdGF0aXN0aWNzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2EtdGltZS9idWlsZC92ZWdhLXRpbWUubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS10cmFuc2Zvcm1zL2J1aWxkL3ZlZ2EtdHJhbnNmb3Jtcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXZpZXctdHJhbnNmb3Jtcy9idWlsZC92ZWdhLXZpZXctdHJhbnNmb3Jtcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uLy4uL25vZGVfbW9kdWxlcy92ZWdhLXZpZXcvYnVpbGQvdmVnYS12aWV3Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vLi4vbm9kZV9tb2R1bGVzL3ZlZ2Etdm9yb25vaS9idWlsZC92ZWdhLXZvcm9ub2kubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS13b3JkY2xvdWQvYnVpbGQvdmVnYS13b3JkY2xvdWQubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi8uLi9ub2RlX21vZHVsZXMvdmVnYS9idWlsZC92ZWdhLm1vZHVsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0Z1QztBQUNGO0FBQ0o7O0FBRWpDLHdCQUF3QixxREFBUSxDQUFDLGtEQUFTO0FBQ25DO0FBQ0E7QUFDQSxxQkFBcUIscURBQVEsQ0FBQywrQ0FBTTtBQUMzQyxpRUFBZSxXQUFXLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUlk7O0FBRXZDLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLG1CQUFtQixzREFBUztBQUM1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3Q3FDOztBQUV0QjtBQUNmLFlBQVkscURBQVE7QUFDcEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTEE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFD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QUVwQzs7QUFFQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBTSxXQUFXLGtEQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQU0sV0FBVyxrREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xYMkM7QUFDeUI7QUFDekI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBRyxPQUFPLHFEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZDQUFPO0FBQ3pDO0FBQ0E7O0FBRWU7QUFDZjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBTSx1QkFBdUIsa0RBQU0sQ0FBQyw0Q0FBSztBQUN6QztBQUNBLG9CQUFvQiwrQ0FBUSxZQUFZLCtDQUFRO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLDZDQUFNLFlBQVksNkNBQU07QUFDNUM7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpREFBaUQsNkNBQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURELDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUMkM7QUFDTztBQUNQOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFHLE9BQU8scURBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRWU7QUFDZjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBTSxXQUFXLGtEQUFNLENBQUMsNENBQUs7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBTztBQUN4QztBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQU87QUFDdkI7QUFDQTs7QUFFQSxtREFBTSxXQUFXLGtEQUFNLENBQUMsNENBQUs7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUhNO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRDZCO0FBQ1A7QUFDTTtBQUNBOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQjtBQUMzQixpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0NBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQ0FBVTtBQUN2QyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFPO0FBQ3RCO0FBQ0E7QUFDQSxXQUFXLDJEQUEyRDs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQXdEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDZDQUFJO0FBQ3ZELFdBQVcsNkJBQTZCO0FBQ3hDLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNkNBQUk7QUFDdkQsV0FBVyxPQUFPO0FBQ2xCLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDZDQUFJO0FBQ3ZELFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNkNBQUk7QUFDdkQsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuUEE7O0FBRWU7QUFDZjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUIsR0FBRyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLEdBQUcsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRyxHQUFHLEdBQUc7QUFDbEQ7QUFDQTtBQUNBLGtCQUFrQixFQUFFLEdBQUcsRUFBRSxTQUFTLE1BQU0sR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsU0FBUyxjQUFjLEdBQUcsY0FBYztBQUMvRjtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDcENlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCNkI7QUFDTTs7QUFFcEI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVcsd0JBQXdCLFVBQVU7O0FBRXhEO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw2Q0FBSTtBQUN2RCxXQUFXLFdBQVcseUJBQXlCLHlCQUF5QjtBQUN4RTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNkNBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNkNBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXLFFBQVE7QUFDOUIsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdELHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEIsK0JBQStCO0FBQ3BFO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0MsK0RBQStELE9BQU87QUFDdEUsaUNBQWlDLFVBQVU7QUFDM0MsK0RBQStELE9BQU87QUFDdEUsaUNBQWlDLFVBQVU7QUFDM0MsK0RBQStELE9BQU87QUFDdEUsaUNBQWlDLFVBQVU7QUFDM0MsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUssbUJBQW1CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSyxtQkFBbUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDL1RBLFlBQVk7O0FBRVo7QUFDQSw4Q0FBOEMsSUFBSSxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0ZBQWtGLE9BQU87QUFDekY7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RCxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTs7QUFFQSxpRUFBZSxRQUFRLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRnhCLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsR0FBRyxnQkFBZ0I7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWSx5Q0FBeUM7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWSx5Q0FBeUM7QUFDckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuS0EsNkJBQWUsb0NBQVM7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkNxQztBQUNBO0FBQ0o7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMscURBQVE7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQyxhQUFhLG9EQUFRO0FBQ3JCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbURBQU07QUFDbkMsNkJBQTZCLG1EQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0UscURBQVE7QUFDOUU7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ25HQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0pBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUnFDO0FBQ0o7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRCx1REFBdUQsT0FBTztBQUM5RDtBQUNBLDJEQUEyRCxtREFBTTtBQUNqRSwyREFBMkQsbURBQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLHFEQUFRO0FBQ2hGOztBQUVBO0FBQ0Esd0VBQXdFLHFEQUFRO0FBQ2hGOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEhxQztBQUNBO0FBQ0o7QUFDSTs7QUFFckMsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msb0RBQVEsUUFBUSw2Q0FBQyxFQUFFLDZDQUFDO0FBQ3hELDBCQUEwQixPQUFPO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSx5QkFBeUIsbURBQU07QUFDL0IseUJBQXlCLG1EQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBLHVCQUF1QixtREFBTTtBQUM3Qix1QkFBdUIsbURBQU07QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLHFEQUFRO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25IcUM7QUFDTjtBQUNKOztBQUVwQjtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQUs7QUFDckIsY0FBYyxvREFBUTtBQUN0QixlQUFlLGdEQUFHOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNKcUM7O0FBRXJDLDZCQUFlLG9DQUFTO0FBQ3hCLGlCQUFpQixxREFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLHFEQUFROztBQUUzQztBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RSxxREFBUTtBQUNoRjs7QUFFQTtBQUNBLGlFQUFpRSxxREFBUTtBQUN6RTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDcUM7O0FBRXJDLDZCQUFlLG9DQUFTO0FBQ3hCLGlCQUFpQixxREFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLHFEQUFROztBQUUzQztBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RSxxREFBUTtBQUNoRjs7QUFFQTtBQUNBLGlFQUFpRSxxREFBUTtBQUN6RTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEN1Qzs7QUFFdkM7QUFDTztBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFYztBQUNmLFdBQVcsbURBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJzRDs7QUFFdEQsNkJBQWUsb0NBQVM7QUFDeEIsYUFBYSxxRUFBa0I7QUFDL0I7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUCwrRkFBK0Y7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05zRDs7QUFFL0M7O0FBRVAsNkJBQWUsb0NBQVM7QUFDeEIsVUFBVSxxRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxRUFBa0IsK0JBQStCO0FBQzdGOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2ZzRDs7QUFFdEQsNkJBQWUsb0NBQVM7QUFDeEIsVUFBVSxxRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHNEQUFzRDs7QUFFL0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzlDQTtBQUNBLDZCQUFlLG9DQUFTO0FBQ3hCLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0EsNEJBQTRCO0FBQzVCLHFDQUFxQyxRQUFRO0FBQzdDLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWK0M7QUFDTTtBQUNOOztBQUUvQyxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0RBQWE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWE7QUFDOUIsT0FBTyxzREFBYTtBQUNwQixPQUFPLHlEQUFnQjtBQUN2QjtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDbEJGLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZxQztBQUNNO0FBQ007QUFDRTtBQUNWO0FBQ0U7QUFDVTtBQUNoQjs7QUFFckM7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QixnRkFBZ0YsaURBQVEsR0FBRyx3REFBVztBQUN0RztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaURBQVEsR0FBRywyREFBYztBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsNERBQWU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9EQUFXOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBVztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLHVEQUFVOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsZ0VBQWM7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUscUlBQXFJO0FBQ3JJLHFFQUFxRTtBQUNyRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDREQUFlO0FBQ2xELGdEQUFnRCxxREFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuSnFDOztBQUVyQyw2QkFBZSxvQ0FBUztBQUN4QixzQkFBc0IscURBQVE7QUFDOUI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSnFDOztBQUVyQyw2QkFBZSxvQ0FBUztBQUN4Qix5REFBeUQscURBQVEscUJBQXFCLHFEQUFRO0FBQzlGOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0pxQzs7QUFFckMsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQSxxQkFBcUIscURBQVEsUUFBUSxxREFBUTtBQUM3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUNBQW1DO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRG1EO0FBQ3VCOztBQUVuRTtBQUNQLHNCQUFzQiw2Q0FBRztBQUN6QiwyQkFBMkIsNkNBQUcseUJBQXlCLDZDQUFHO0FBQzFELFNBQVMsNkNBQUcsVUFBVSw2Q0FBTztBQUM3QjtBQUNBOztBQUVPOztBQUVQO0FBQ0EsMEJBQTBCLDZDQUFHLDZDQUE2Qyw2Q0FBRztBQUM3RTs7QUFFQTtBQUNBLGVBQWUsOENBQUkscUJBQXFCLDZDQUFHLE1BQU0sOENBQUksVUFBVSw2Q0FBRztBQUNsRTs7QUFFQTtBQUNBOztBQUVPLHVDQUF1QywyQ0FBSyxHQUFHLDRDQUFNLEVBQUUsMkNBQUssRUFBRSx3Q0FBRTs7QUFFdkUsNkJBQWUsc0NBQVc7QUFDMUIsU0FBUywrQ0FBVTtBQUNuQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUIrQjtBQUNvQztBQUN0QztBQUNJOztBQUUxQixzQkFBc0IsMkNBQUs7O0FBRWxDOztBQUVBLGtCQUFrQiwyQ0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsU0FBUyw2Q0FBSTtBQUNiLGFBQWEsNkNBQUk7QUFDakIsV0FBVyw2Q0FBSTtBQUNmO0FBQ0Esc0JBQXNCLDJDQUFLO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQix5Q0FBRztBQUNsQyxpREFBaUQsNkNBQUk7QUFDckQsR0FBRztBQUNIO0FBQ0EsZ0JBQWdCLHlDQUFHO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFPLFNBQVMsNkNBQU87QUFDbkMsOEJBQThCLDZDQUFHLGlCQUFpQiwrQ0FBUyxhQUFhLDZDQUFHO0FBQzNFOztBQUVBO0FBQ0EsWUFBWSw2Q0FBTyxTQUFTLDZDQUFPO0FBQ25DLGtCQUFrQiwrQ0FBUyxDQUFDOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFHO0FBQ2xCLGVBQWUsNkNBQUc7QUFDbEI7QUFDQSxpQ0FBaUMsNkNBQUc7QUFDcEMseUJBQXlCLDZDQUFHO0FBQzVCLGtCQUFrQiwrQ0FBSzs7QUFFdkI7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCLGdCQUFnQiwyQ0FBSztBQUNyQixFQUFFLG1EQUFNO0FBQ1I7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0UrQjtBQUNtQjtBQUM2QztBQUN0QztBQUN4Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQ0FBSztBQUN4QixJQUFJLDZEQUF1QjtBQUMzQixHQUFHO0FBQ0g7QUFDQSxJQUFJLDJEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlEQUFXO0FBQ25CLHdCQUF3Qiw2Q0FBTztBQUMvQix5QkFBeUIsNkNBQU87QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsd0RBQVMsV0FBVyw2Q0FBTyxRQUFRLDZDQUFPO0FBQ3BEO0FBQ0EsaUJBQWlCLDZEQUFjO0FBQy9CO0FBQ0EscUJBQXFCLDZEQUFjO0FBQ25DLElBQUksd0VBQXlCO0FBQzdCLGlCQUFpQix3REFBUztBQUMxQjtBQUNBO0FBQ0Esa0NBQWtDLDZDQUFPO0FBQ3pDO0FBQ0EsdUJBQXVCLDZDQUFHO0FBQzFCO0FBQ0EsNkJBQTZCLDZDQUFPO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLDhCQUE4Qiw2Q0FBTztBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFHO0FBQ3BCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSxzREFBZ0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLEVBQUUsMERBQW9CO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxFQUFFLHdEQUFrQjtBQUNwQixNQUFNLDZDQUFHLGFBQWEsNkNBQU87QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxFQUFFLG1EQUFNOztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFLFFBQVE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbExzRDs7QUFFL0M7QUFDUCxVQUFVLCtDQUFLLDhCQUE4Qiw4Q0FBSTtBQUNqRDs7QUFFTztBQUNQLDBEQUEwRCw2Q0FBRztBQUM3RCxtQkFBbUIsNkNBQUcsbUJBQW1CLDZDQUFHLFVBQVUsNkNBQUc7QUFDekQ7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDTztBQUNQLFVBQVUsOENBQUk7QUFDZDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDK0I7QUFDbUU7QUFDckU7QUFDSTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQSxVQUFVLDZDQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksNkNBQU8sU0FBUyw2Q0FBTztBQUNuQyxlQUFlLDZDQUFHO0FBQ2xCLGtDQUFrQyw2Q0FBRyxtQkFBbUIsNkNBQUcsVUFBVSw2Q0FBRztBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2Q0FBTyxTQUFTLDZDQUFPO0FBQ25DLGVBQWUsNkNBQUc7QUFDbEIsZ0JBQWdCLDZDQUFHO0FBQ25CLGdCQUFnQiw2Q0FBRztBQUNuQixPQUFPLDZDQUFHO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2Q0FBTyxTQUFTLDZDQUFPO0FBQ25DLGVBQWUsNkNBQUc7QUFDbEIsbUJBQW1CLDZDQUFHO0FBQ3RCLG1CQUFtQiw2Q0FBRztBQUN0QixVQUFVLDZDQUFHO0FBQ2IsVUFBVSwrQ0FBSyxDQUFDLDhDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBTyxTQUFTLDZDQUFPO0FBQ25DO0FBQ0EsZUFBZSw2Q0FBRztBQUNsQixnQkFBZ0IsNkNBQUc7QUFDbkIsZ0JBQWdCLDZDQUFHO0FBQ25CLE9BQU8sNkNBQUc7QUFDVjtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2Q0FBTyxTQUFTLDZDQUFPO0FBQ25DLGVBQWUsNkNBQUc7QUFDbEIsbUJBQW1CLDZDQUFHO0FBQ3RCLG1CQUFtQiw2Q0FBRztBQUN0QixVQUFVLDZDQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBSztBQUNmLFVBQVUsOENBQUk7QUFDZCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkNBQUs7QUFDaEIsV0FBVywyQ0FBSztBQUNoQixXQUFXLDJDQUFLO0FBQ2hCLEVBQUUsbURBQU07O0FBRVI7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBSzs7QUFFZjtBQUNBLFVBQVUsOENBQVE7QUFDbEI7QUFDQTtBQUNBLGFBQWEsNkNBQU87QUFDcEIsUUFBUSwrQ0FBSztBQUNiO0FBQ0EsWUFBWSw4Q0FBUTtBQUNwQjs7QUFFQSxVQUFVLCtDQUFLLFNBQVMsNkNBQU8sRUFBRSw4Q0FBSSxVQUFVLDZDQUFPO0FBQ3REOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5SStFO0FBQzFDO0FBQ29DO0FBQzdCOztBQUU1QztBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsNkNBQUc7QUFDckIsa0JBQWtCLDZDQUFHO0FBQ3JCO0FBQ0E7QUFDQSw4QkFBOEIseUNBQUc7QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZEQUE2RCx5Q0FBRztBQUNoRTtBQUNBLHlCQUF5QixpQ0FBaUM7QUFDMUQsWUFBWSx3REFBUywwQkFBMEIsNkNBQUcsa0JBQWtCLDZDQUFHO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx3REFBUztBQUNuQixFQUFFLHdFQUF5QjtBQUMzQixlQUFlLDhDQUFJO0FBQ25CLCtDQUErQyx5Q0FBRyxHQUFHLDZDQUFPLElBQUkseUNBQUc7QUFDbkU7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUIsZUFBZSxxREFBUTtBQUN2QixlQUFlLHFEQUFRO0FBQ3ZCLGtCQUFrQixxREFBUTtBQUMxQjtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0EsWUFBWSw2Q0FBTyxVQUFVLDZDQUFPO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsNkNBQU87QUFDbkQsK0NBQStDLDZDQUFPO0FBQ3REO0FBQ0EsYUFBYSwyREFBYSxTQUFTLDZDQUFPLFVBQVUsNkNBQU87QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFLHFEQUFRO0FBQzlFOztBQUVBO0FBQ0Esc0VBQXNFLHFEQUFRO0FBQzlFOztBQUVBO0FBQ0EseUVBQXlFLHFEQUFRO0FBQ2pGOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZFOEI7QUFDc0M7O0FBRXBFLGlFQUFlLGtEQUFJO0FBQ25CLGNBQWMsYUFBYSxFQUFFO0FBQzdCO0FBQ0E7QUFDQSxJQUFJLHdDQUFFLEdBQUcsNENBQU07QUFDZixDQUFDLEVBQUM7O0FBRUY7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDLHdDQUFFLElBQUksd0NBQUU7QUFDeEMsa0JBQWtCLDZDQUFHO0FBQ3JCLFVBQVUsNkNBQUcsU0FBUyx3Q0FBRSxJQUFJLDZDQUFPLEdBQUc7QUFDdEMsNkRBQTZELDRDQUFNLElBQUksNENBQU07QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzQ0FBc0Msd0NBQUUsR0FBRztBQUNsRCxZQUFZLDZDQUFHLG9CQUFvQiw2Q0FBTyxxQkFBcUIsNkNBQU8sQ0FBQztBQUN2RSxZQUFZLDZDQUFHLG9CQUFvQiw2Q0FBTyxxQkFBcUIsNkNBQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFHO0FBQzdCLFNBQVMsNkNBQUcsc0JBQXNCLDZDQUFPO0FBQ3pDLFFBQVEsOENBQUksRUFBRSw2Q0FBRyxvQkFBb0IsNkNBQUcsVUFBVSw2Q0FBRztBQUNyRCxZQUFZLDZDQUFHLG9CQUFvQiw2Q0FBRyxVQUFVLDZDQUFHO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQU07QUFDNUIsa0JBQWtCLHdDQUFFO0FBQ3BCO0FBQ0EsaUJBQWlCLHdDQUFFO0FBQ25CLGlCQUFpQix3Q0FBRTtBQUNuQixpQkFBaUIsd0NBQUU7QUFDbkI7QUFDQSxrQkFBa0Isd0NBQUU7QUFDcEIsa0JBQWtCLHdDQUFFO0FBQ3BCLGtCQUFrQix3Q0FBRTtBQUNwQixHQUFHLFVBQVUsNkNBQUcsb0JBQW9CLDZDQUFPO0FBQzNDLG1DQUFtQyx3Q0FBRSxJQUFJLHdDQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzRjhCOztBQUU5Qiw2QkFBZSxzQ0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYSw2Q0FBSTtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCd0g7QUFDOUU7QUFDc0I7QUFDdEI7QUFDWjs7QUFFOUIsNkJBQWUsb0NBQVM7QUFDeEIsV0FBVyw2Q0FBRztBQUNkLGtCQUFrQiw2Q0FBTztBQUN6QjtBQUNBLHNCQUFzQiw2Q0FBRyxPQUFPLDZDQUFPLENBQUM7O0FBRXhDO0FBQ0EsSUFBSSx3REFBWTtBQUNoQjs7QUFFQTtBQUNBLFdBQVcsNkNBQUcsV0FBVyw2Q0FBRztBQUM1Qjs7QUFFQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsd0NBQUUsSUFBSSx3Q0FBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQVUsb0JBQW9CLHVEQUFVO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdURBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx3REFBUztBQUN0QixhQUFhLHdEQUFTOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFjO0FBQzNCLGVBQWUsMkRBQVk7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQWM7QUFDOUIsWUFBWSw2REFBYztBQUMxQixZQUFZLDZEQUFjO0FBQzFCLElBQUksa0VBQW1COztBQUV2QjtBQUNBO0FBQ0EsWUFBWSwyREFBWTtBQUN4QixhQUFhLDJEQUFZO0FBQ3pCLDJCQUEyQiwyREFBWTs7QUFFdkM7O0FBRUEsWUFBWSw4Q0FBSTtBQUNoQixZQUFZLDZEQUFjO0FBQzFCLElBQUksa0VBQW1CO0FBQ3ZCLFFBQVEsd0RBQVM7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQiw2Q0FBRyxTQUFTLHdDQUFFLElBQUksNkNBQU87QUFDekMsb0NBQW9DLDZDQUFPOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkNBQUcsbUJBQW1CLDZDQUFPO0FBQ25FO0FBQ0Esa0JBQWtCLHdDQUFFO0FBQ3BCLGVBQWUsNkRBQWM7QUFDN0IsTUFBTSxrRUFBbUI7QUFDekIsaUJBQWlCLHdEQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdDQUFFO0FBQ3JDO0FBQ0EsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUEsU0FBUyxrREFBSSxnRUFBZ0Usd0NBQUUsV0FBVyx3Q0FBRTtBQUM1Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaExxQztBQUNBO0FBQ007QUFDUztBQUNyQjs7QUFFL0IsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBLHFCQUFxQixtREFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFLO0FBQ3hCLDBCQUEwQiw0REFBZTtBQUN6QztBQUNBO0FBQ0EsVUFBVSxtREFBVTtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0Q0FBTSxHQUFHLDZDQUFPLEdBQUcsNENBQU07QUFDN0Qsb0NBQW9DLDRDQUFNLEdBQUcsNkNBQU8sR0FBRyw0Q0FBTTtBQUM3RDs7Ozs7Ozs7Ozs7Ozs7OztBQ2xJQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUR3QztBQUNIO0FBQ0o7QUFDSTtBQUNOOztBQUUvQjs7QUFFQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDZDQUFHLGNBQWMsNkNBQU87QUFDbkMsVUFBVSw2Q0FBRyxjQUFjLDZDQUFPO0FBQ2xDLFVBQVUsNkNBQUcsY0FBYyw2Q0FBTztBQUNsQyxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hELGtIQUFrSCxPQUFPO0FBQ3pIO0FBQ0EseUJBQXlCLHlFQUF5RTtBQUNsRyxnQkFBZ0IsMEVBQTBFO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaURBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbURBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2SzBDO0FBQ1A7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBVTtBQUNsQjtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkNBQU87QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdEdBLDZCQUFlLG9DQUFTOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNYQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0orQjtBQUNjOztBQUU3QztBQUNBLFVBQVUsaURBQUssVUFBVSw2Q0FBTztBQUNoQyxzQkFBc0IsMkJBQTJCLGVBQWUsRUFBRSxFQUFFO0FBQ3BFOztBQUVBO0FBQ0EsVUFBVSxpREFBSyxVQUFVLDZDQUFPO0FBQ2hDLHNCQUFzQiwyQkFBMkIsZUFBZSxFQUFFLEVBQUU7QUFDcEU7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0EsV0FBVyxpREFBSyxDQUFDLDhDQUFJO0FBQ3JCLGdCQUFnQixpREFBSyxDQUFDLDhDQUFJO0FBQzFCLGdCQUFnQixpREFBSyxDQUFDLDhDQUFJLDRDQUE0QyxRQUFRLDZDQUFHLFdBQVcsNkNBQU8sQ0FBQyxFQUFFO0FBQ3RHLGdCQUFnQixpREFBSyxDQUFDLDhDQUFJLDRDQUE0QyxRQUFRLDZDQUFHLFdBQVcsNkNBQU8sQ0FBQyxFQUFFO0FBQ3RHOztBQUVBO0FBQ0EsOENBQThDLFNBQVMsOENBQThDLEVBQUU7QUFDdkc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyw2Q0FBTyxjQUFjLDZDQUFPO0FBQzdELGlDQUFpQyw2Q0FBTyxjQUFjLDZDQUFPO0FBQzdEOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHQSxpRUFBZSxNQUFNLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1DQUFtQztBQUN4RTtBQUNBOztBQUVBO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbkNlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQWdCO0FBQ0E7QUFDRDs7QUFFOUIsa0JBQWtCLDJDQUFLO0FBQ3ZCLHNCQUFzQiwyQ0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsNkNBQUk7QUFDYixhQUFhLDZDQUFJO0FBQ2pCLFdBQVcsNkNBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtRUFBbUUsNkNBQUk7QUFDdkUsZ0JBQWdCLDZDQUFHO0FBQ25CLHNCQUFzQiwyQ0FBSztBQUMzQixHQUFHO0FBQ0g7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBSztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxVQUFVLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakRJOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBSTtBQUNqQixXQUFXLDZDQUFJO0FBQ2YsZ0JBQWdCLDZDQUFJO0FBQ3BCLGNBQWMsNkNBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxZQUFZLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0JJOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLDhDQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBSTs7QUFFZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGNBQWMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkdDO0FBQ0Q7O0FBRWY7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5Q0FBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVSw2Q0FBSTtBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1Q3NDO0FBQ0o7QUFDRDtBQUNJO0FBQ0k7QUFDRjtBQUNBO0FBQ0Y7O0FBRXJDLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1EQUFNO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxtREFBTSwwQkFBMEIsNkNBQVE7QUFDNUMsV0FBVyxvREFBZTtBQUMxQjs7QUFFQTtBQUNBLElBQUksbURBQU0sMEJBQTBCLGdEQUFXO0FBQy9DLFdBQVcsdURBQWtCO0FBQzdCOztBQUVBO0FBQ0EsSUFBSSxtREFBTSwwQkFBMEIsK0NBQVU7QUFDOUMsV0FBVyxzREFBaUI7QUFDNUI7O0FBRUE7QUFDQSxJQUFJLG1EQUFNLDBCQUEwQixpREFBWTtBQUNoRCxXQUFXLHdEQUFtQjtBQUM5Qjs7QUFFQTtBQUNBLGtGQUFrRixpREFBUTtBQUMxRjs7QUFFQTtBQUNBO0FBQ0EscURBQXFELCtDQUFVLFFBQVEsZ0RBQVc7QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVEK0I7QUFDQztBQUNGOztBQUU5QixvQkFBb0IsMkNBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsNkNBQUk7QUFDYjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQUk7QUFDN0IsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFLO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFJO0FBQ3BCO0FBQ0E7O0FBRUEsaUVBQWUsWUFBWSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUNiO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUR1Qzs7QUFFdkMsNkJBQWUsb0NBQVM7QUFDeEIsU0FBUyw2Q0FBRyxnQkFBZ0IsNkNBQU8sSUFBSSw2Q0FBRyxnQkFBZ0IsNkNBQU87QUFDakU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKK0I7QUFDcUQ7QUFDc0I7O0FBRTFHO0FBQ0EsTUFBTSw2Q0FBRyxjQUFjLHdDQUFFO0FBQ3pCO0FBQ0E7QUFDQSxXQUFXLDhDQUFJLGVBQWUsNkNBQUcsYUFBYSx3Q0FBRSxJQUFJLHlDQUFHLEdBQUcsd0NBQUU7QUFDNUQ7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBLGVBQWUsNkNBQUc7QUFDbEIsZ0JBQWdCLDZDQUFHLFdBQVcsNkNBQUc7QUFDakM7QUFDQTs7QUFFQSxnQkFBZ0IsMkNBQUs7O0FBRXJCLDBCQUEwQiw0Q0FBTSxHQUFHLDZDQUFPO0FBQzFDLGlDQUFpQyw0Q0FBTSxHQUFHLDZDQUFPOztBQUVqRCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtDQUFTO0FBQ3hDLGtCQUFrQiw2Q0FBRztBQUNyQixrQkFBa0IsNkNBQUc7O0FBRXJCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQSxpQ0FBaUMsK0NBQVM7QUFDMUMsb0JBQW9CLDZDQUFHO0FBQ3ZCLG9CQUFvQiw2Q0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0NBQUU7QUFDdEM7O0FBRUEsY0FBYywrQ0FBSyxZQUFZLDZDQUFHLG9DQUFvQyw2Q0FBRztBQUN6RSw2Q0FBNkMseUNBQUc7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2REFBYyxDQUFDLHdEQUFTLFVBQVUsd0RBQVM7QUFDN0QsUUFBUSx3RUFBeUI7QUFDakMsMkJBQTJCLDZEQUFjO0FBQ3pDLFFBQVEsd0VBQXlCO0FBQ2pDLDREQUE0RCw4Q0FBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDZDQUFPLFlBQVksNkNBQU8sV0FBVyw4Q0FBUTtBQUNoRTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1RWlEOztBQUVqRCw2QkFBZSxzQ0FBVztBQUMxQixTQUFTLDJEQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUbUM7QUFDRjtBQUNnQjtBQUNnQjs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZLHdDQUF3QyxFQUFFO0FBQ2pGLHdCQUF3QixZQUFZLHFDQUFxQyxFQUFFO0FBQzNFLDJCQUEyQixZQUFZLHdDQUF3QyxFQUFFO0FBQ2pGLHlCQUF5QixZQUFZLHNDQUFzQyxFQUFFO0FBQzdFLDhCQUE4QixZQUFZLDJDQUEyQyxFQUFFO0FBQ3ZGLDRCQUE0QixZQUFZLHlDQUF5QztBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBZSxzQ0FBVztBQUMxQjtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFNO0FBQ3RCLGVBQWUsMkRBQWM7QUFDN0IsZUFBZSwyREFBYztBQUM3Qiw0QkFBNEIsdUJBQXVCLGdCQUFnQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsNkNBQU8sa0JBQWtCLDZDQUFPLG9CQUFvQiw2Q0FBTyxrQkFBa0IsNkNBQU87QUFDMUg7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyw2Q0FBTyxrQkFBa0IsNkNBQU8sb0JBQW9CLDZDQUFPLGtCQUFrQiw2Q0FBTztBQUMxSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrREFBUztBQUNwQjs7QUFFQTtBQUNBLFdBQVcsZ0RBQU87QUFDbEI7O0FBRUE7QUFDQSxXQUFXLGlEQUFRO0FBQ25COztBQUVBO0FBQ0EsV0FBVyxrREFBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5R3VEOztBQUVoRDtBQUNQO0FBQ0EsYUFBYSw2Q0FBRztBQUNoQixhQUFhLDZDQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQUc7QUFDbEIsVUFBVSw2Q0FBRztBQUNiO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsWUFBWSw4Q0FBSTtBQUNoQjtBQUNBLGFBQWEsNkNBQUc7QUFDaEIsYUFBYSw2Q0FBRztBQUNoQjtBQUNBLE1BQU0sK0NBQUs7QUFDWCxNQUFNLDhDQUFJO0FBQ1Y7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCc0M7QUFDdUI7QUFDekI7O0FBRTdCLDRCQUE0QiwyREFBWTtBQUMvQyxTQUFTLDhDQUFJO0FBQ2IsQ0FBQzs7QUFFRCwrQkFBK0IsOERBQWU7QUFDOUMsYUFBYSw4Q0FBSTtBQUNqQixDQUFDOztBQUVELDZCQUFlLHNDQUFXO0FBQzFCLFNBQVMsa0RBQVU7QUFDbkI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCcUM7QUFDd0I7QUFDekI7O0FBRTdCLDhCQUE4QiwyREFBWTtBQUNqRCxjQUFjLDhDQUFJLFlBQVksNkNBQUc7QUFDakMsQ0FBQzs7QUFFRCxpQ0FBaUMsOERBQWU7QUFDaEQ7QUFDQSxDQUFDOztBQUVELDZCQUFlLHNDQUFXO0FBQzFCLFNBQVMsa0RBQVU7QUFDbkI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQmdEO0FBQ0g7O0FBRXRDO0FBQ1A7QUFDQSxhQUFhLHdDQUFFO0FBQ2YsVUFBVSw0REFBaUI7QUFDM0I7O0FBRUE7QUFDQSw4Q0FBOEMsNkNBQU8sZ0JBQWdCLDZDQUFPLFlBQVksNkNBQU8sU0FBUyw2Q0FBTztBQUMvRzs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2RzRztBQUMzRDtBQUNEOztBQUUxQztBQUNBLFNBQVMsNkNBQUcsRUFBRSw0Q0FBTTtBQUNwQjs7QUFFTztBQUNQLFlBQVksNkNBQUc7QUFDZixzQkFBc0IsNkNBQUcsT0FBTyw2Q0FBRyxPQUFPLDZDQUFHLFFBQVEsNkNBQUc7QUFDeEQsZ0JBQWdCLDZDQUFHOztBQUVuQixpQkFBaUIscURBQVc7O0FBRTVCO0FBQ0EsZ0JBQWdCLFVBQVUsNENBQU0sR0FBRyw2Q0FBTyxPQUFPLDRDQUFNLEdBQUcsNkNBQU8sQ0FBQztBQUNsRSxVQUFVLFNBQVMsNENBQU0sR0FBRyw2Q0FBTyxNQUFNLDRDQUFNLEdBQUcsNkNBQU8sQ0FBQztBQUMxRCxnQkFBZ0IsNkNBQUc7QUFDbkIsZ0JBQWdCLDZDQUFHLGlCQUFpQiw2Q0FBRztBQUN2Qzs7QUFFQTtBQUNBLHdCQUF3Qiw4Q0FBSSxNQUFNLDhDQUFJO0FBQ3RDLFVBQVUsK0NBQUssSUFBSSw2Q0FBRyxRQUFRLDhDQUFJO0FBQ2xDO0FBQ0EsV0FBVyx3Q0FBRSxHQUFHLDhDQUFJLE1BQU0sOENBQUk7QUFDOUIsdUJBQXVCLDhDQUFJLENBQUMsNkNBQUcsa0JBQWtCLDRDQUFNO0FBQ3ZEOztBQUVBO0FBQ0E7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUIsU0FBUywwREFBZTtBQUN4QjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckMrRTtBQUNwQztBQUN1Qjs7QUFFM0Q7QUFDUCxZQUFZLDZDQUFHLGlCQUFpQiw2Q0FBRzs7QUFFbkM7QUFDQSxNQUFNLDZDQUFHLE1BQU0sNkNBQU8sU0FBUyxpRkFBdUI7O0FBRXRELHdDQUF3Qyw4Q0FBSTs7QUFFNUM7QUFDQSxZQUFZLDhDQUFJLGFBQWEsNkNBQUc7QUFDaEMsZ0JBQWdCLDZDQUFHLG1CQUFtQiw2Q0FBRztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBSyxJQUFJLDZDQUFHLFNBQVMsOENBQUk7QUFDckM7QUFDQSxXQUFXLHdDQUFFLEdBQUcsOENBQUksTUFBTSw4Q0FBSTtBQUM5QixtQkFBbUIsOENBQUk7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQSw2QkFBZSxzQ0FBVztBQUMxQixTQUFTLDBEQUFlO0FBQ3hCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ3lFO0FBQzlCO0FBQ2E7O0FBRWpEO0FBQ1AsWUFBWSw2Q0FBRztBQUNmLHNCQUFzQiw2Q0FBRyxjQUFjLDZDQUFHO0FBQzFDOztBQUVBLE1BQU0sNkNBQUcsTUFBTSw2Q0FBTyxTQUFTLG1FQUFrQjs7QUFFakQ7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBRyxlQUFlLDZDQUFHO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxZQUFZLCtDQUFLLElBQUksNkNBQUcsUUFBUSw4Q0FBSTtBQUNwQztBQUNBLFdBQVcsd0NBQUUsR0FBRyw4Q0FBSSxNQUFNLDhDQUFJO0FBQzlCLHVCQUF1Qiw4Q0FBSSxNQUFNLDhDQUFJO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUIsU0FBUywwREFBZTtBQUN4QjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0IwQzs7QUFFbkM7QUFDUCxnQkFBZ0IsNkNBQUc7O0FBRW5CO0FBQ0EsOEJBQThCLDZDQUFHO0FBQ2pDOztBQUVBO0FBQ0EseUJBQXlCLDhDQUFJO0FBQzdCOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkb0M7QUFDMkI7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBSTtBQUNaOztBQUVPO0FBQ1AsVUFBVSw4Q0FBSSxLQUFLLDZDQUFHO0FBQ3RCO0FBQ0EsYUFBYSw2Q0FBRztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2Q0FBRyxVQUFVLDhDQUFRO0FBQzdCO0FBQ0E7QUFDQSwrREFBK0QsNkNBQUc7QUFDbEUsSUFBSSw4Q0FBSSxDQUFDLDZDQUFHO0FBQ1o7QUFDQTs7QUFFQSw2QkFBZSxzQ0FBVztBQUMxQixTQUFTLGtEQUFVO0FBQ25CO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25Db0M7O0FBRTdCO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSw2QkFBZSxzQ0FBVztBQUMxQixTQUFTLGtEQUFVO0FBQ25CO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1hrRDtBQUNMOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbURBQVMsMkJBQTJCLG9EQUFZO0FBQ2xELFlBQVksMkRBQW1CO0FBQy9CO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5QzBDO0FBQ0s7QUFDWDs7QUFFN0I7QUFDUCxXQUFXLDZDQUFHLFNBQVMsNkNBQUc7QUFDMUIsZUFBZSw2Q0FBRyxTQUFTLDZDQUFHO0FBQzlCOztBQUVBLHFCQUFxQiw4REFBZSxDQUFDLDBDQUFJOztBQUV6Qyw2QkFBZSxzQ0FBVztBQUMxQixTQUFTLGtEQUFVO0FBQ25CO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZmlEO0FBQ1g7QUFDTTtBQUNxQjtBQUNYOztBQUV0RCw2QkFBZSxzQ0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxpQkFBaUIsaURBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixpREFBUSxJQUFJLDJEQUFhO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNkNBQU8sT0FBTyw2Q0FBRyxjQUFjLDZDQUFHLDRCQUE0Qiw2Q0FBTztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrREFBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxnREFBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxpREFBUTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxrREFBUztBQUNwQjs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRnVEO0FBQ1o7QUFDTTtBQUNiO0FBQ0U7QUFDc0I7QUFDZjtBQUNEO0FBQ3FCO0FBQzVCOztBQUVyQyx1QkFBdUIsMERBQVc7QUFDbEM7QUFDQSwwQkFBMEIsNkNBQU8sTUFBTSw2Q0FBTztBQUM5QztBQUNBLENBQUM7O0FBRUQ7QUFDQSxTQUFTLDBEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBRztBQUNwQixpQkFBaUIsNkNBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZix1Q0FBdUMsZ0JBQWdCLEVBQUU7QUFDekQ7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUFnQjtBQUM5Qyx3Q0FBd0MsaURBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLDZDQUFPLGFBQWEsNkNBQU87QUFDeEU7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyw2Q0FBTyxhQUFhLDZDQUFPO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLHdEQUFVLGFBQWEsNkNBQU8sbUJBQW1CLDBEQUFnQixzQkFBc0IsNkNBQU87QUFDNUk7O0FBRUE7QUFDQSxpRkFBaUYsaURBQVEsSUFBSSwyREFBYTtBQUMxRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELDZDQUFPLHFCQUFxQiw2Q0FBTywwQkFBMEIsNkNBQU8sUUFBUSw2Q0FBTztBQUN4STs7QUFFQTtBQUNBLDBEQUEwRCw2Q0FBTywwQkFBMEIsNkNBQU8sMkNBQTJDLDZDQUFPLG1DQUFtQyw2Q0FBTyxhQUFhLDZDQUFPLGVBQWUsNkNBQU87QUFDeE87O0FBRUE7QUFDQSxpREFBaUQsNkNBQU8sd0JBQXdCLDZDQUFPO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQscURBQVEsK0NBQStDLDhDQUFJO0FBQzVHOztBQUVBO0FBQ0EsV0FBVyxrREFBUztBQUNwQjs7QUFFQTtBQUNBLFdBQVcsZ0RBQU87QUFDbEI7O0FBRUE7QUFDQSxXQUFXLGlEQUFRO0FBQ25COztBQUVBO0FBQ0EsV0FBVyxrREFBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJEQUFhO0FBQzFCLHVCQUF1QixvREFBTztBQUM5Qiw2QkFBNkIsb0RBQU87QUFDcEMsc0JBQXNCLHFEQUFRO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoTGdFO0FBQzFCO0FBQ0Y7O0FBRTdCO0FBQ1Asa0JBQWtCLDZDQUFHLENBQUMsNkNBQUcsRUFBRSw0Q0FBTTtBQUNqQzs7QUFFQTtBQUNBLGlCQUFpQiw4Q0FBSSxDQUFDLDZDQUFHLE9BQU8sNENBQU07QUFDdEM7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQSxtQkFBbUIseUNBQUc7QUFDdEI7O0FBRU87QUFDUCxVQUFVLGtEQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHdDQUFFO0FBQ2QsY0FBYyxxREFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRG9DO0FBQ0k7O0FBRWpDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsUUFBUSw2Q0FBRyxVQUFVLDZDQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUIsU0FBUyxrREFBVTtBQUNuQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCbUQ7QUFDSjtBQUNYOztBQUU3QjtBQUNQLFVBQVUsNkNBQUcsTUFBTSw2Q0FBRyxLQUFLLDZDQUFHO0FBQzlCOztBQUVBLHlCQUF5Qiw4REFBZSxDQUFDLDBDQUFJOztBQUU3Qyw2QkFBZSxzQ0FBVztBQUMxQixTQUFTLGtEQUFVO0FBQ25CO0FBQ0Esc0JBQXNCLDZDQUFPO0FBQzdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZDBDO0FBQytCO0FBQzdCOztBQUU1QztBQUNBLHFCQUFxQiw2Q0FBRyxNQUFNLDZDQUFPLEVBQUU7O0FBRXZDLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDBEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUFJO0FBQ2xCLGlCQUFpQiw4Q0FBSTtBQUNyQixvQkFBb0IsNkNBQUcsQ0FBQyw2Q0FBRyxXQUFXLDZDQUFPLElBQUksNkNBQUcsc0JBQXNCLDZDQUFPLDZCQUE2QiwrQ0FBSztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQUc7QUFDaEIsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QixzQ0FBc0MsRUFBRTtBQUMvRiw4QkFBOEIscUJBQXFCLHNDQUFzQztBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx3REFBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyRzBDO0FBQ0s7QUFDWDs7QUFFN0I7QUFDUCxXQUFXLDZDQUFHLGFBQWEsNkNBQUc7QUFDOUIsZUFBZSw2Q0FBRyxTQUFTLDZDQUFHO0FBQzlCOztBQUVBLDBCQUEwQiw4REFBZTtBQUN6QyxhQUFhLDhDQUFJO0FBQ2pCLENBQUM7O0FBRUQsNkJBQWUsc0NBQVc7QUFDMUIsU0FBUyxrREFBVTtBQUNuQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQnVEO0FBQ047O0FBRTFDO0FBQ1AsVUFBVSw2Q0FBRyxDQUFDLDZDQUFHLEVBQUUsNENBQU07QUFDekI7O0FBRUE7QUFDQSxrQkFBa0IsOENBQUksQ0FBQyw2Q0FBRyxPQUFPLDRDQUFNO0FBQ3ZDOztBQUVBLDZCQUFlLHNDQUFXO0FBQzFCLFVBQVUsZ0VBQWtCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQm1DO0FBQzZDOztBQUVoRjtBQUNBLFVBQVUsNkNBQUcsV0FBVyx3Q0FBRSxpQ0FBaUMseUNBQUcsSUFBSSx5Q0FBRztBQUNyRTs7QUFFQTs7QUFFTztBQUNQLHlCQUF5Qix5Q0FBRyw4QkFBOEIsb0RBQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qyx3Q0FBRSxZQUFZLHlDQUFHLGFBQWEsd0NBQUUsWUFBWSx5Q0FBRztBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsNkNBQUc7QUFDdkIsb0JBQW9CLDZDQUFHO0FBQ3ZCLHNCQUFzQiw2Q0FBRztBQUN6QixzQkFBc0IsNkNBQUc7O0FBRXpCO0FBQ0EsaUJBQWlCLDZDQUFHO0FBQ3BCLFlBQVksNkNBQUc7QUFDZixZQUFZLDZDQUFHO0FBQ2YsWUFBWSw2Q0FBRztBQUNmO0FBQ0E7QUFDQSxNQUFNLCtDQUFLO0FBQ1gsTUFBTSw4Q0FBSTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsNkNBQUc7QUFDcEIsWUFBWSw2Q0FBRztBQUNmLFlBQVksNkNBQUc7QUFDZixZQUFZLDZDQUFHO0FBQ2Y7QUFDQTtBQUNBLE1BQU0sK0NBQUs7QUFDWCxNQUFNLDhDQUFJO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUFlLG9DQUFTO0FBQ3hCLHFDQUFxQyw2Q0FBTyxjQUFjLDZDQUFPLGtDQUFrQyw2Q0FBTzs7QUFFMUc7QUFDQSwwQ0FBMEMsNkNBQU8sbUJBQW1CLDZDQUFPO0FBQzNFLDZCQUE2Qiw2Q0FBTyxvQkFBb0IsNkNBQU87QUFDL0Q7O0FBRUE7QUFDQSxpREFBaUQsNkNBQU8sbUJBQW1CLDZDQUFPO0FBQ2xGLDZCQUE2Qiw2Q0FBTyxvQkFBb0IsNkNBQU87QUFDL0Q7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QixFQUFFO0FBQ3BELHNCQUFzQixzQkFBc0IsRUFBRTtBQUM5Qyx5QkFBeUIseUJBQXlCLEVBQUU7QUFDcEQsdUJBQXVCLHVCQUF1QixFQUFFO0FBQ2hELDRCQUE0Qiw0QkFBNEIsRUFBRTtBQUMxRCwwQkFBMEIsMEJBQTBCO0FBQ3BEOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUEEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxzQ0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkZPO0FBQ1A7QUFDQTs7QUFFQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ1JBLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ1hBLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2RBLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDWEEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQb0M7QUFDRjtBQUNZO0FBQ0Y7QUFDVjtBQUNGO0FBQ0U7QUFDQTtBQUNVO0FBQ0k7QUFDVjtBQUNGO0FBQ007O0FBRTNCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsOENBQVU7QUFDbkIsUUFBUSw2Q0FBUztBQUNqQixhQUFhLGtEQUFjO0FBQzNCLGNBQWMsbURBQWU7QUFDN0IsUUFBUSw2Q0FBUztBQUNqQixPQUFPLDRDQUFRO0FBQ2YsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCLGFBQWEsa0RBQWM7QUFDM0IsZUFBZSxvREFBZ0I7QUFDL0IsVUFBVSxnREFBVztBQUNyQixTQUFTLCtDQUFVO0FBQ25CO0FBQ0EscUJBQXFCLGtEQUFhO0FBQ2xDOzs7Ozs7Ozs7Ozs7Ozs7O0FDMUZBLDZCQUFlLHVDQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7O0FDYkEsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDUkEsNkJBQWUsc0NBQVc7QUFDMUI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QkEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUm9DOztBQUVwQyw2QkFBZSxvQ0FBUztBQUN4Qiw0QkFBNEIsa0RBQU87O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckgwQztBQUNEO0FBQ2E7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxzQ0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVk7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxzREFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHVEQUFRO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RSxxREFBUTtBQUMvRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0IsVUFBVSx5REFBVztBQUNyQix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlFZ0M7QUFDRzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsdUJBQXVCLGtEQUFLOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix3Q0FBd0MsS0FBSyxvREFBTzs7QUFFdkU7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7O0FBRUEsNkJBQWUsb0NBQVM7QUFDeEI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0SDJDO0FBQ0M7O0FBRTVDLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNEQUFTO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRHdDO0FBQ2lCOztBQUV6RCxlQUFlLFVBQVU7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBZSxzQ0FBVztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCLDBDQUEwQyxxREFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0Msb0NBQW9DLEtBQUssRUFBRSxhQUFhLDhEQUFhO0FBQ3pHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyx1REFBUTtBQUM1Qzs7QUFFQTtBQUNBLDBDQUEwQyx1REFBUTtBQUNsRDs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzFFMEM7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiOztBQUVBLG1DQUFtQywrREFBYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUFlLHNDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNU9BLDZCQUFlLG9DQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJxQzs7QUFFdkM7QUFDTztBQUNBO0FBQ0E7QUFDQTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVjO0FBQ2YsV0FBVyxtREFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1EQUFjLFNBQVMsa0RBQVM7QUFDeEUsaUJBQWlCLG1EQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxnREFBZSxTQUFTLCtDQUFVO0FBQzFFLGlCQUFpQixtREFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEIsb0NBQW9DOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFMEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hOcUM7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FB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O0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVzs7QUFFWCxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBO0FB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QTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1EQUFRLFFBQVEsb0RBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7OztBQUdwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQixnREFBSztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaURBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLGdEQUFLO0FBQzdCLHNCQUFzQjtBQUN0QixHQUFHOzs7QUFHSCw2QkFBNkIsT0FBTztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDBEQUEwRDs7O0FBRzFELG9JQUFvSTs7QUFFcEksbUdBQW1HOztBQUVuRztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUSxRQUFRLElBQUksT0FBTyxRQUFRLFFBQVEsT0FBTzs7QUFFN0YsMkNBQTJDLFFBQVEsUUFBUSxJQUFJLE9BQU8sUUFBUSxRQUFRLE9BQU87O0FBRTdGLG1EQUFtRCxRQUFRLFFBQVEsS0FBSyxPQUFPLFFBQVEsUUFBUSxJQUFJOztBQUVuRywrQ0FBK0MsUUFBUSxRQUFRLElBQUk7O0FBRW5FLGlEQUFpRCxRQUFRLFFBQVEsTUFBTTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixzREFBVztBQUNuQyx3QkFBd0Isc0RBQVc7QUFDbkM7QUFDQSxpQkFBaUIsS0FBSyxNQUFNLEVBQUUsT0FBTyxFQUFFO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIO0FBQ0EsWUFBWSxpREFBTTtBQUNsQjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxLQUFLLE1BQU0sVUFBVSxPQUFPLFVBQVU7QUFDbkQsQ0FBQzs7QUFFRDtBQUNBLDBCQUEwQixRQUFRLFFBQVEsS0FBSyxPQUFPLFVBQVUsOEJBQThCLFFBQVEsUUFBUSxPQUFPLE9BQU8sVUFBVSw4QkFBOEIsUUFBUSxRQUFRLE1BQU0sT0FBTyxVQUFVLDhCQUE4QixRQUFRLFFBQVEsSUFBSSxPQUFPLFVBQVU7QUFDOVEsQ0FBQzs7QUFFRCxnRUFBZ0Usc0RBQVc7O0FBRTNFO0FBQ0EsY0FBYyxZQUFZLE1BQU0sTUFBTTtBQUN0QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLHlEQUFjO0FBQzlCO0FBQ0EsR0FBRyxVQUFVLHlEQUFjO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxpREFBTSxHQUFHO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRyxpREFBTTtBQUNaO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsbUJBQW1CLFdBQVcsbURBQVE7QUFDdEM7QUFDQSxrQkFBa0IsWUFBWSxPQUFPLFlBQVk7QUFDakQsS0FBSztBQUNMLEdBQUc7QUFDSCx5QkFBeUIsaURBQU0sR0FBRzs7QUFFbEM7QUFDQSxXQUFXLG1EQUFRO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVyxPQUFPLFlBQVk7QUFDcEQsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLDZCQUE2QixpREFBTSxHQUFHO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQSxrQ0FBa0M7OztBQUdsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0ws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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DLDhCQUE4QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVYsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RDs7QUFFNUQsb0JBQW9CLHFEQUFXO0FBQy9CLHdCQUF3QixxREFBVyxpQkFBaUI7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLCtDQUFRO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxpREFBTTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpREFBWSxZQUFZLCtDQUFJO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnREFBSyxDQUFDLGdEQUFLO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0JBQWdCLDZDQUFhLEVBQUU7O0FBRS9CLGNBQWMsNkNBQVc7QUFDekIsV0FBVyw2Q0FBUTtBQUNuQixXQUFXLDZDQUFRO0FBQ25CLFlBQVksMENBQVM7QUFDckIsY0FBYyw4Q0FBVztBQUN6QixZQUFZLDhDQUFTO0FBQ3JCLFdBQVcsOENBQVEsMEJBQTBCOztBQUU3QyxrQkFBa0IsOENBQWUsK0JBQStCOztBQUVoRSxpREFBaUQsOENBQWU7QUFDaEUsOENBQThDLG9EQUFrQjtBQUNoRSw4Q0FBOEMsb0RBQWtCO0FBQ2hFLCtDQUErQyxxREFBbUI7QUFDbEUsaURBQWlELHVEQUFxQiwrQkFBK0I7O0FBRXJHLGdEQUFnRCw4Q0FBYztBQUM5RCw2Q0FBNkMsbURBQWlCO0FBQzlELDZDQUE2QyxtREFBaUI7QUFDOUQsOENBQThDLG9EQUFrQjtBQUNoRSxnREFBZ0Qsc0RBQW9CLCtCQUErQjs7QUFFbkcsZ0JBQWdCLDhDQUFhO0FBQzdCLGdCQUFnQiw4Q0FBYTtBQUM3QixpQkFBaUIsOENBQWMsZ0JBQWdCOztBQUUvQztBQUNBLGVBQWUsNkNBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBYztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQ0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsV0FBVzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsbURBQVE7QUFDbkIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNENBQUM7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxrREFBTzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQixZQUFZLEVBQUU7QUFDZDs7O0FBR0E7QUFDQTs7QUFFQSxNQUFNLG1EQUFRO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLCtDQUFJO0FBQzdDO0FBQ0E7O0FBRUEsTUFBTSxtREFBUTtBQUNkO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLG1EQUFRO0FBQ2Qsa0NBQWtDLHVEQUFZLDhCQUE4QixzREFBVyxVQUFVLGdEQUFLO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsWUFBWSxTQUFTO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0NBQUk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUMsK0NBQUk7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLEVBQUU7QUFDYixZQUFZLFNBQVM7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsK0NBQUk7QUFDbkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFJO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QyxNQUFNLG1EQUFRO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUVBQW1FLCtDQUFJO0FBQ3ZFO0FBQ0E7O0FBRTRoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDanpCelk7QUFDa1A7QUFDNVY7QUFDYztBQUNsQjtBQUNrQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNkNBQVU7QUFDckIsR0FBRztBQUNIO0FBQ0EsV0FBVyw2Q0FBZ0I7QUFDM0IsR0FBRztBQUNIO0FBQ0EsV0FBVyw2Q0FBYztBQUN6QixHQUFHO0FBQ0g7QUFDQSxXQUFXLDZDQUFXO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLDZDQUFhO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLDZDQUFpQjtBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyw4Q0FBbUI7QUFDOUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsOENBQWU7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsOENBQXFCO0FBQ2hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLDhDQUFtQjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyw4Q0FBVztBQUN0QixHQUFHO0FBQ0g7QUFDQSxXQUFXLDhDQUFpQjtBQUM1QixHQUFHO0FBQ0g7QUFDQSxnQkFBZ0IsZ0RBQWM7QUFDOUIsY0FBYyxnREFBYztBQUM1QixHQUFHO0FBQ0g7QUFDQSxXQUFXLDhDQUFZO0FBQ3ZCLEdBQUc7QUFDSDtBQUNBLFdBQVcsOENBQVM7QUFDcEIsR0FBRztBQUNIO0FBQ0EsV0FBVyxnREFBYztBQUN6QixHQUFHO0FBQ0g7QUFDQSxXQUFXLGlEQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGNBQWMseURBQWM7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RCxxRkFBcUY7O0FBRXJGLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDs7QUFFQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxTQUFTO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQWM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLE9BQU8seURBQWM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQU07O0FBRTNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpREFBTTs7QUFFbEQsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtEQUFLO0FBQ3RCLG1CQUFtQixrREFBTTtBQUN6QixtQkFBbUIsa0RBQU07QUFDekIsa0JBQWtCLGtEQUFNO0FBQ3hCO0FBQ0Esb0JBQW9CLGtEQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILE1BQU0scURBQVU7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQVE7O0FBRVI7QUFDQTtBQUNBLGlDQUFpQyxtREFBTTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IsbURBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBOztBQUVBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsNkNBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLGlEQUFpRDs7QUFFakQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLHFEQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsbURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWSxJQUFJLEtBQUs7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsa0RBQU87QUFDaEI7O0FBRUE7QUFDQSxtREFBbUQsa0RBQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrREFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLE1BQU0sa0RBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsa0RBQU87QUFDZjs7QUFFQSxpQkFBaUIsZUFBZTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQywyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIOzs7QUFHQSxtQkFBbUIsZ0RBQUssb0xBQW9MOztBQUU1TTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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Q0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdILGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixpREFBTTtBQUN0QjtBQUNBO0FBQ0EsR0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxTQUFTLDZEQUFZLFFBQVEsZ0RBQUs7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLHlFQUE4Qjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFZTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3gzQzBCO0FBQ0w7QUFDRTs7QUFFdkM7QUFDQSxFQUFFLHlEQUFjO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbURBQVEsVUFBVSxvREFBUztBQUMzQjtBQUNBO0FBQ0EsOEJBQThCOztBQUU5Qiw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQSxpQ0FBaUMscURBQWEsNEJBQTRCOztBQUUxRSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxnQ0FBZ0M7O0FBRXhDO0FBQ0E7O0FBRThCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRU87QUFDSztBQUNnQztBQUN2QztBQUNNOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxtREFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVMsRUFBRTs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSDs7QUFFckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsT0FBTztBQUNoQzs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQU0sQ0FBQyxxREFBVSxFQUFFLDRDQUFFLEVBQUUsaURBQUcsRUFBRSx3Q0FBTSxFQUFFLHFDQUFHLEVBQUUsdUNBQUssRUFBRSx1Q0FBSyxFQUFFLDJDQUFJLEVBQUUsNENBQUcsRUFBRSwwQ0FBTyxFQUFFLDRDQUFTLEVBQUUsOENBQUUsRUFBRTs7QUFFMUY7O0FBRW1CIiwiZmlsZSI6InZlbmRvcnMtbm9kZV9tb2R1bGVzX3ZlZ2FfYnVpbGRfdmVnYV9tb2R1bGVfanMuMzkyNDQzZDY3NDdkOGY0MGNiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5pbXBvcnQgYmlzZWN0b3IgZnJvbSBcIi4vYmlzZWN0b3IuanNcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbmNvbnN0IGFzY2VuZGluZ0Jpc2VjdCA9IGJpc2VjdG9yKGFzY2VuZGluZyk7XG5leHBvcnQgY29uc3QgYmlzZWN0UmlnaHQgPSBhc2NlbmRpbmdCaXNlY3QucmlnaHQ7XG5leHBvcnQgY29uc3QgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xuZXhwb3J0IGNvbnN0IGJpc2VjdENlbnRlciA9IGJpc2VjdG9yKG51bWJlcikuY2VudGVyO1xuZXhwb3J0IGRlZmF1bHQgYmlzZWN0UmlnaHQ7XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihmKSB7XG4gIGxldCBkZWx0YSA9IGY7XG4gIGxldCBjb21wYXJlID0gZjtcblxuICBpZiAoZi5sZW5ndGggPT09IDEpIHtcbiAgICBkZWx0YSA9IChkLCB4KSA9PiBmKGQpIC0geDtcbiAgICBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlZnQoYSwgeCwgbG8sIGhpKSB7XG4gICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtcbiAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJpZ2h0KGEsIHgsIGxvLCBoaSkge1xuICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIGNvbnN0IG1pZCA9IChsbyArIGhpKSA+Pj4gMTtcbiAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKSBoaSA9IG1pZDtcbiAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiBjZW50ZXIoYSwgeCwgbG8sIGhpKSB7XG4gICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICBjb25zdCBpID0gbGVmdChhLCB4LCBsbywgaGkgLSAxKTtcbiAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgY2VudGVyLCByaWdodH07XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZ0NvbXBhcmF0b3IoZikge1xuICByZXR1cm4gKGQsIHgpID0+IGFzY2VuZGluZyhmKGQpLCB4KTtcbn1cbiIsImltcG9ydCB2YXJpYW5jZSBmcm9tIFwiLi92YXJpYW5jZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXZpYXRpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGNvbnN0IHYgPSB2YXJpYW5jZSh2YWx1ZXMsIHZhbHVlb2YpO1xuICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcHl0aG9uL2NweXRob24vYmxvYi9hNzRlZWEyMzhmNWJhYmExNTc5N2UyZThiNTcwZDE1M2JjODY5MGE3L01vZHVsZXMvbWF0aG1vZHVsZS5jI0wxNDIzXG5leHBvcnQgY2xhc3MgQWRkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXJ0aWFscyA9IG5ldyBGbG9hdDY0QXJyYXkoMzIpO1xuICAgIHRoaXMuX24gPSAwO1xuICB9XG4gIGFkZCh4KSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX3BhcnRpYWxzO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX24gJiYgaiA8IDMyOyBqKyspIHtcbiAgICAgIGNvbnN0IHkgPSBwW2pdLFxuICAgICAgICBoaSA9IHggKyB5LFxuICAgICAgICBsbyA9IE1hdGguYWJzKHgpIDwgTWF0aC5hYnMoeSkgPyB4IC0gKGhpIC0geSkgOiB5IC0gKGhpIC0geCk7XG4gICAgICBpZiAobG8pIHBbaSsrXSA9IGxvO1xuICAgICAgeCA9IGhpO1xuICAgIH1cbiAgICBwW2ldID0geDtcbiAgICB0aGlzLl9uID0gaSArIDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fcGFydGlhbHM7XG4gICAgbGV0IG4gPSB0aGlzLl9uLCB4LCB5LCBsbywgaGkgPSAwO1xuICAgIGlmIChuID4gMCkge1xuICAgICAgaGkgPSBwWy0tbl07XG4gICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgeCA9IGhpO1xuICAgICAgICB5ID0gcFstLW5dO1xuICAgICAgICBoaSA9IHggKyB5O1xuICAgICAgICBsbyA9IHkgLSAoaGkgLSB4KTtcbiAgICAgICAgaWYgKGxvKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuID4gMCAmJiAoKGxvIDwgMCAmJiBwW24gLSAxXSA8IDApIHx8IChsbyA+IDAgJiYgcFtuIC0gMV0gPiAwKSkpIHtcbiAgICAgICAgeSA9IGxvICogMjtcbiAgICAgICAgeCA9IGhpICsgeTtcbiAgICAgICAgaWYgKHkgPT0geCAtIGhpKSBoaSA9IHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgY29uc3QgYWRkZXIgPSBuZXcgQWRkZXIoKTtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlKSB7XG4gICAgICAgIGFkZGVyLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpIHtcbiAgICAgICAgYWRkZXIuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICthZGRlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZjdW1zdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGNvbnN0IGFkZGVyID0gbmV3IEFkZGVyKCk7XG4gIGxldCBpbmRleCA9IC0xO1xuICByZXR1cm4gRmxvYXQ2NEFycmF5LmZyb20odmFsdWVzLCB2YWx1ZW9mID09PSB1bmRlZmluZWRcbiAgICAgID8gdiA9PiBhZGRlci5hZGQoK3YgfHwgMClcbiAgICAgIDogdiA9PiBhZGRlci5hZGQoK3ZhbHVlb2YodiwgKytpbmRleCwgdmFsdWVzKSB8fCAwKVxuICApO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWF4KHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWF4O1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1heCA8IHZhbHVlIHx8IChtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVhbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IHN1bSA9IDA7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgKytjb3VudCwgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgKytjb3VudCwgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY291bnQpIHJldHVybiBzdW0gLyBjb3VudDtcbn1cbiIsImltcG9ydCBxdWFudGlsZSBmcm9tIFwiLi9xdWFudGlsZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgcmV0dXJuIHF1YW50aWxlKHZhbHVlcywgMC41LCB2YWx1ZW9mKTtcbn1cbiIsImZ1bmN0aW9uKiBmbGF0dGVuKGFycmF5cykge1xuICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgIHlpZWxkKiBhcnJheTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZShhcnJheXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZmxhdHRlbihhcnJheXMpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IG1pbjtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbFxuICAgICAgICAgICYmIChtaW4gPiB2YWx1ZSB8fCAobWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbFxuICAgICAgICAgICYmIChtaW4gPiB2YWx1ZSB8fCAobWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSkge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBudW1iZXJzKHZhbHVlcywgdmFsdWVvZikge1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzb3VyY2UsIGtleXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oa2V5cywga2V5ID0+IHNvdXJjZVtrZXldKTtcbn1cbiIsImltcG9ydCBtYXggZnJvbSBcIi4vbWF4LmpzXCI7XG5pbXBvcnQgbWluIGZyb20gXCIuL21pbi5qc1wiO1xuaW1wb3J0IHF1aWNrc2VsZWN0IGZyb20gXCIuL3F1aWNrc2VsZWN0LmpzXCI7XG5pbXBvcnQgbnVtYmVyLCB7bnVtYmVyc30gZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aWxlKHZhbHVlcywgcCwgdmFsdWVvZikge1xuICB2YWx1ZXMgPSBGbG9hdDY0QXJyYXkuZnJvbShudW1iZXJzKHZhbHVlcywgdmFsdWVvZikpO1xuICBpZiAoIShuID0gdmFsdWVzLmxlbmd0aCkpIHJldHVybjtcbiAgaWYgKChwID0gK3ApIDw9IDAgfHwgbiA8IDIpIHJldHVybiBtaW4odmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuIG1heCh2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9IG1heChxdWlja3NlbGVjdCh2YWx1ZXMsIGkwKS5zdWJhcnJheSgwLCBpMCArIDEpKSxcbiAgICAgIHZhbHVlMSA9IG1pbih2YWx1ZXMuc3ViYXJyYXkoaTAgKyAxKSk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpbGVTb3J0ZWQodmFsdWVzLCBwLCB2YWx1ZW9mID0gbnVtYmVyKSB7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBpZiAoKHAgPSArcCkgPD0gMCB8fCBuIDwgMikgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1swXSwgMCwgdmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1tuIC0gMV0sIG4gLSAxLCB2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9ICt2YWx1ZW9mKHZhbHVlc1tpMF0sIGkwLCB2YWx1ZXMpLFxuICAgICAgdmFsdWUxID0gK3ZhbHVlb2YodmFsdWVzW2kwICsgMV0sIGkwICsgMSwgdmFsdWVzKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZy5qc1wiO1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9xdWlja3NlbGVjdFxuLy8gSVNDIGxpY2Vuc2UsIENvcHlyaWdodCAyMDE4IFZsYWRpbWlyIEFnYWZvbmtpbi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFycmF5LCBrLCBsZWZ0ID0gMCwgcmlnaHQgPSBhcnJheS5sZW5ndGggLSAxLCBjb21wYXJlID0gYXNjZW5kaW5nKSB7XG4gIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICBjb25zdCBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgIGNvbnN0IG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICBjb25zdCB6ID0gTWF0aC5sb2cobik7XG4gICAgICBjb25zdCBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgIGNvbnN0IHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgY29uc3QgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICBjb25zdCBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xuICAgICAgcXVpY2tzZWxlY3QoYXJyYXksIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ID0gYXJyYXlba107XG4gICAgbGV0IGkgPSBsZWZ0O1xuICAgIGxldCBqID0gcmlnaHQ7XG5cbiAgICBzd2FwKGFycmF5LCBsZWZ0LCBrKTtcbiAgICBpZiAoY29tcGFyZShhcnJheVtyaWdodF0sIHQpID4gMCkgc3dhcChhcnJheSwgbGVmdCwgcmlnaHQpO1xuXG4gICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICBzd2FwKGFycmF5LCBpLCBqKSwgKytpLCAtLWo7XG4gICAgICB3aGlsZSAoY29tcGFyZShhcnJheVtpXSwgdCkgPCAwKSArK2k7XG4gICAgICB3aGlsZSAoY29tcGFyZShhcnJheVtqXSwgdCkgPiAwKSAtLWo7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBhcmUoYXJyYXlbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFycmF5LCBsZWZ0LCBqKTtcbiAgICBlbHNlICsraiwgc3dhcChhcnJheSwgaiwgcmlnaHQpO1xuXG4gICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBzd2FwKGFycmF5LCBpLCBqKSB7XG4gIGNvbnN0IHQgPSBhcnJheVtpXTtcbiAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgYXJyYXlbal0gPSB0O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuXG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3VtKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgc3VtID0gMDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlKSB7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkge1xuICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG4iLCJ2YXIgZTEwID0gTWF0aC5zcXJ0KDUwKSxcbiAgICBlNSA9IE1hdGguc3FydCgxMCksXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgcmV2ZXJzZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4sXG4gICAgICB0aWNrcyxcbiAgICAgIHN0ZXA7XG5cbiAgc3RvcCA9ICtzdG9wLCBzdGFydCA9ICtzdGFydCwgY291bnQgPSArY291bnQ7XG4gIGlmIChzdGFydCA9PT0gc3RvcCAmJiBjb3VudCA+IDApIHJldHVybiBbc3RhcnRdO1xuICBpZiAocmV2ZXJzZSA9IHN0b3AgPCBzdGFydCkgbiA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBuO1xuICBpZiAoKHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkpID09PSAwIHx8ICFpc0Zpbml0ZShzdGVwKSkgcmV0dXJuIFtdO1xuXG4gIGlmIChzdGVwID4gMCkge1xuICAgIGxldCByMCA9IE1hdGgucm91bmQoc3RhcnQgLyBzdGVwKSwgcjEgPSBNYXRoLnJvdW5kKHN0b3AgLyBzdGVwKTtcbiAgICBpZiAocjAgKiBzdGVwIDwgc3RhcnQpICsrcjA7XG4gICAgaWYgKHIxICogc3RlcCA+IHN0b3ApIC0tcjE7XG4gICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IHIxIC0gcjAgKyAxKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGlja3NbaV0gPSAocjAgKyBpKSAqIHN0ZXA7XG4gIH0gZWxzZSB7XG4gICAgc3RlcCA9IC1zdGVwO1xuICAgIGxldCByMCA9IE1hdGgucm91bmQoc3RhcnQgKiBzdGVwKSwgcjEgPSBNYXRoLnJvdW5kKHN0b3AgKiBzdGVwKTtcbiAgICBpZiAocjAgLyBzdGVwIDwgc3RhcnQpICsrcjA7XG4gICAgaWYgKHIxIC8gc3RlcCA+IHN0b3ApIC0tcjE7XG4gICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IHIxIC0gcjAgKyAxKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGlja3NbaV0gPSAocjAgKyBpKSAvIHN0ZXA7XG4gIH1cblxuICBpZiAocmV2ZXJzZSkgdGlja3MucmV2ZXJzZSgpO1xuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcCkgLyBNYXRoLkxOMTApLFxuICAgICAgZXJyb3IgPSBzdGVwIC8gTWF0aC5wb3coMTAsIHBvd2VyKTtcbiAgcmV0dXJuIHBvd2VyID49IDBcbiAgICAgID8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSkgKiBNYXRoLnBvdygxMCwgcG93ZXIpXG4gICAgICA6IC1NYXRoLnBvdygxMCwgLXBvd2VyKSAvIChlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwMCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBzdGVwMSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXAwKSAvIE1hdGguTE4xMCkpLFxuICAgICAgZXJyb3IgPSBzdGVwMCAvIHN0ZXAxO1xuICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwMSAqPSAxMDtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpIHN0ZXAxICo9IDU7XG4gIGVsc2UgaWYgKGVycm9yID49IGUyKSBzdGVwMSAqPSAyO1xuICByZXR1cm4gc3RvcCA8IHN0YXJ0ID8gLXN0ZXAxIDogc3RlcDE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2YXJpYW5jZSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGRlbHRhO1xuICBsZXQgbWVhbiA9IDA7XG4gIGxldCBzdW0gPSAwO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKytjb3VudDtcbiAgICAgICAgc3VtICs9IGRlbHRhICogKHZhbHVlIC0gbWVhbik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICBkZWx0YSA9IHZhbHVlIC0gbWVhbjtcbiAgICAgICAgbWVhbiArPSBkZWx0YSAvICsrY291bnQ7XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY291bnQgPiAxKSByZXR1cm4gc3VtIC8gKGNvdW50IC0gMSk7XG59XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENvbG9yKCkge31cblxuZXhwb3J0IHZhciBkYXJrZXIgPSAwLjc7XG5leHBvcnQgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLFxuICAgIHJlTiA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsXG4gICAgcmVQID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXG4gICAgcmVIZXggPSAvXiMoWzAtOWEtZl17Myw4fSkkLyxcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVJLCByZUksIHJlSV0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZUksIHJlSSwgcmVJLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiICsgW3JlTiwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgY29weTogZnVuY3Rpb24oY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcywgY2hhbm5lbHMpO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgfSxcbiAgaGV4OiBjb2xvcl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogY29sb3JfZm9ybWF0SGV4LFxuICBmb3JtYXRIc2w6IGNvbG9yX2Zvcm1hdEhzbCxcbiAgZm9ybWF0UmdiOiBjb2xvcl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiBjb2xvcl9mb3JtYXRSZ2Jcbn0pO1xuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIc2woKSB7XG4gIHJldHVybiBoc2xDb252ZXJ0KHRoaXMpLmZvcm1hdEhzbCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRSZ2IoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdFJnYigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG0sIGw7XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXguZXhlYyhmb3JtYXQpKSA/IChsID0gbVsxXS5sZW5ndGgsIG0gPSBwYXJzZUludChtWzFdLCAxNiksIGwgPT09IDYgPyByZ2JuKG0pIC8vICNmZjAwMDBcbiAgICAgIDogbCA9PT0gMyA/IG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkgLy8gI2YwMFxuICAgICAgOiBsID09PSA4ID8gcmdiYShtID4+IDI0ICYgMHhmZiwgbSA+PiAxNiAmIDB4ZmYsIG0gPj4gOCAmIDB4ZmYsIChtICYgMHhmZikgLyAweGZmKSAvLyAjZmYwMDAwMDBcbiAgICAgIDogbCA9PT0gNCA/IHJnYmEoKG0gPj4gMTIgJiAweGYpIHwgKG0gPj4gOCAmIDB4ZjApLCAobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkgLyAweGZmKSAvLyAjZjAwMFxuICAgICAgOiBudWxsKSAvLyBpbnZhbGlkIGhleFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYkNvbnZlcnQobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBSZ2I7XG4gIG8gPSBvLnJnYigpO1xuICByZXR1cm4gbmV3IFJnYihvLnIsIG8uZywgby5iLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoLTAuNSA8PSB0aGlzLnIgJiYgdGhpcy5yIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuZyAmJiB0aGlzLmcgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5iICYmIHRoaXMuYiA8IDI1NS41KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBoZXg6IHJnYl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogcmdiX2Zvcm1hdEhleCxcbiAgZm9ybWF0UmdiOiByZ2JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogcmdiX2Zvcm1hdFJnYlxufSkpO1xuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gXCIjXCIgKyBoZXgodGhpcy5yKSArIGhleCh0aGlzLmcpICsgaGV4KHRoaXMuYik7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRSZ2IoKSB7XG4gIHZhciBhID0gdGhpcy5vcGFjaXR5OyBhID0gaXNOYU4oYSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpO1xuICByZXR1cm4gKGEgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIilcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmcpIHx8IDApKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5iKSB8fCAwKSlcbiAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIGhleCh2YWx1ZSkge1xuICB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xuICByZXR1cm4gKHZhbHVlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdmFsdWUudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG5ldyBIc2woby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgSHNsO1xuICBpZiAobyBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIG87XG4gIG8gPSBvLnJnYigpO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGggPSBOYU4sXG4gICAgICBzID0gbWF4IC0gbWluLFxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKHMpIHtcbiAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHMgKyAoZyA8IGIpICogNjtcbiAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcyArIDI7XG4gICAgZWxzZSBoID0gKHIgLSBnKSAvIHMgKyA0O1xuICAgIHMgLz0gbCA8IDAuNSA/IG1heCArIG1pbiA6IDIgLSBtYXggLSBtaW47XG4gICAgaCAqPSA2MDtcbiAgfSBlbHNlIHtcbiAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgfVxuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSHNsLCBoc2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGZvcm1hdEhzbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gICAgcmV0dXJuIChhID09PSAxID8gXCJoc2woXCIgOiBcImhzbGEoXCIpXG4gICAgICAgICsgKHRoaXMuaCB8fCAwKSArIFwiLCBcIlxuICAgICAgICArICh0aGlzLnMgfHwgMCkgKiAxMDAgKyBcIiUsIFwiXG4gICAgICAgICsgKHRoaXMubCB8fCAwKSAqIDEwMCArIFwiJVwiXG4gICAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG4gIH1cbn0pKTtcblxuLyogRnJvbSBGdkQgMTMuMzcsIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgMyAqL1xuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgOiBoIDwgMTgwID8gbTJcbiAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgIDogbTEpICogMjU1O1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5pbXBvcnQge0NvbG9yLCByZ2JDb252ZXJ0LCBSZ2IsIGRhcmtlciwgYnJpZ2h0ZXJ9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5pbXBvcnQge2RlZ3JlZXMsIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcblxudmFyIEEgPSAtMC4xNDg2MSxcbiAgICBCID0gKzEuNzgyNzcsXG4gICAgQyA9IC0wLjI5MjI3LFxuICAgIEQgPSAtMC45MDY0OSxcbiAgICBFID0gKzEuOTcyOTQsXG4gICAgRUQgPSBFICogRCxcbiAgICBFQiA9IEUgKiBCLFxuICAgIEJDX0RBID0gQiAqIEMgLSBEICogQTtcblxuZnVuY3Rpb24gY3ViZWhlbGl4Q29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgQ3ViZWhlbGl4KSByZXR1cm4gbmV3IEN1YmVoZWxpeChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKSxcbiAgICAgIGJsID0gYiAtIGwsXG4gICAgICBrID0gKEUgKiAoZyAtIGwpIC0gQyAqIGJsKSAvIEQsXG4gICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKSwgLy8gTmFOIGlmIGw9MCBvciBsPTFcbiAgICAgIGggPSBzID8gTWF0aC5hdGFuMihrLCBibCkgKiBkZWdyZWVzIC0gMTIwIDogTmFOO1xuICByZXR1cm4gbmV3IEN1YmVoZWxpeChoIDwgMCA/IGggKyAzNjAgOiBoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGN1YmVoZWxpeENvbnZlcnQoaCkgOiBuZXcgQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoQ3ViZWhlbGl4LCBjdWJlaGVsaXgsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogcmFkaWFucyxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoQyAqIGNvc2ggKyBEICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEUgKiBjb3NoKSksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuaW1wb3J0IHtDb2xvciwgcmdiQ29udmVydCwgUmdifSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuaW1wb3J0IHtkZWdyZWVzLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbi8vIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svbGFiLWFuZC1yZ2JcbmNvbnN0IEsgPSAxOCxcbiAgICBYbiA9IDAuOTY0MjIsXG4gICAgWW4gPSAxLFxuICAgIFpuID0gMC44MjUyMSxcbiAgICB0MCA9IDQgLyAyOSxcbiAgICB0MSA9IDYgLyAyOSxcbiAgICB0MiA9IDMgKiB0MSAqIHQxLFxuICAgIHQzID0gdDEgKiB0MSAqIHQxO1xuXG5mdW5jdGlvbiBsYWJDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBMYWIpIHJldHVybiBuZXcgTGFiKG8ubCwgby5hLCBvLmIsIG8ub3BhY2l0eSk7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gaGNsMmxhYihvKTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IHJnYjJscmdiKG8uciksXG4gICAgICBnID0gcmdiMmxyZ2Ioby5nKSxcbiAgICAgIGIgPSByZ2IybHJnYihvLmIpLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBnICsgMC4wNjA2MTY5ICogYikgLyBZbiksIHgsIHo7XG4gIGlmIChyID09PSBnICYmIGcgPT09IGIpIHggPSB6ID0geTsgZWxzZSB7XG4gICAgeCA9IHh5ejJsYWIoKDAuNDM2MDc0NyAqIHIgKyAwLjM4NTA2NDkgKiBnICsgMC4xNDMwODA0ICogYikgLyBYbik7XG4gICAgeiA9IHh5ejJsYWIoKDAuMDEzOTMyMiAqIHIgKyAwLjA5NzEwNDUgKiBnICsgMC43MTQxNzMzICogYikgLyBabik7XG4gIH1cbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheShsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBuZXcgTGFiKGwsIDAsIDAsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBsYWJDb252ZXJ0KGwpIDogbmV3IExhYihsLCBhLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5hID0gK2E7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKExhYiwgbGFiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeSA9ICh0aGlzLmwgKyAxNikgLyAxMTYsXG4gICAgICAgIHggPSBpc05hTih0aGlzLmEpID8geSA6IHkgKyB0aGlzLmEgLyA1MDAsXG4gICAgICAgIHogPSBpc05hTih0aGlzLmIpID8geSA6IHkgLSB0aGlzLmIgLyAyMDA7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBscmdiMnJnYiggMy4xMzM4NTYxICogeCAtIDEuNjE2ODY2NyAqIHkgLSAwLjQ5MDYxNDYgKiB6KSxcbiAgICAgIGxyZ2IycmdiKC0wLjk3ODc2ODQgKiB4ICsgMS45MTYxNDE1ICogeSArIDAuMDMzNDU0MCAqIHopLFxuICAgICAgbHJnYjJyZ2IoIDAuMDcxOTQ1MyAqIHggLSAwLjIyODk5MTQgKiB5ICsgMS40MDUyNDI3ICogeiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xuICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cblxuZnVuY3Rpb24gbHJnYjJyZ2IoeCkge1xuICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbn1cblxuZnVuY3Rpb24gcmdiMmxyZ2IoeCkge1xuICByZXR1cm4gKHggLz0gMjU1KSA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gaGNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gbmV3IEhjbChvLmgsIG8uYywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgTGFiKSkgbyA9IGxhYkNvbnZlcnQobyk7XG4gIGlmIChvLmEgPT09IDAgJiYgby5iID09PSAwKSByZXR1cm4gbmV3IEhjbChOYU4sIDAgPCBvLmwgJiYgby5sIDwgMTAwID8gMCA6IE5hTiwgby5sLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IE1hdGguYXRhbjIoby5iLCBvLmEpICogZGVncmVlcztcbiAgcmV0dXJuIG5ldyBIY2woaCA8IDAgPyBoICsgMzYwIDogaCwgTWF0aC5zcXJ0KG8uYSAqIG8uYSArIG8uYiAqIG8uYiksIG8ubCwgby5vcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxjaChsLCBjLCBoLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChsKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5jID0gK2M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZnVuY3Rpb24gaGNsMmxhYihvKSB7XG4gIGlmIChpc05hTihvLmgpKSByZXR1cm4gbmV3IExhYihvLmwsIDAsIDAsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gby5oICogcmFkaWFucztcbiAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XG59XG5cbmRlZmluZShIY2wsIGhjbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGhjbDJsYWIodGhpcykucmdiKCk7XG4gIH1cbn0pKTtcbiIsImV4cG9ydCBjb25zdCByYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcbiIsImltcG9ydCBEZWxhdW5hdG9yIGZyb20gXCJkZWxhdW5hdG9yXCI7XG5pbXBvcnQgUGF0aCBmcm9tIFwiLi9wYXRoLmpzXCI7XG5pbXBvcnQgUG9seWdvbiBmcm9tIFwiLi9wb2x5Z29uLmpzXCI7XG5pbXBvcnQgVm9yb25vaSBmcm9tIFwiLi92b3Jvbm9pLmpzXCI7XG5cbmNvbnN0IHRhdSA9IDIgKiBNYXRoLlBJLCBwb3cgPSBNYXRoLnBvdztcblxuZnVuY3Rpb24gcG9pbnRYKHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmZ1bmN0aW9uIHBvaW50WShwKSB7XG4gIHJldHVybiBwWzFdO1xufVxuXG4vLyBBIHRyaWFuZ3VsYXRpb24gaXMgY29sbGluZWFyIGlmIGFsbCBpdHMgdHJpYW5nbGVzIGhhdmUgYSBub24tbnVsbCBhcmVhXG5mdW5jdGlvbiBjb2xsaW5lYXIoZCkge1xuICBjb25zdCB7dHJpYW5nbGVzLCBjb29yZHN9ID0gZDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjb25zdCBhID0gMiAqIHRyaWFuZ2xlc1tpXSxcbiAgICAgICAgICBiID0gMiAqIHRyaWFuZ2xlc1tpICsgMV0sXG4gICAgICAgICAgYyA9IDIgKiB0cmlhbmdsZXNbaSArIDJdLFxuICAgICAgICAgIGNyb3NzID0gKGNvb3Jkc1tjXSAtIGNvb3Jkc1thXSkgKiAoY29vcmRzW2IgKyAxXSAtIGNvb3Jkc1thICsgMV0pXG4gICAgICAgICAgICAgICAgLSAoY29vcmRzW2JdIC0gY29vcmRzW2FdKSAqIChjb29yZHNbYyArIDFdIC0gY29vcmRzW2EgKyAxXSk7XG4gICAgaWYgKGNyb3NzID4gMWUtMTApIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaml0dGVyKHgsIHksIHIpIHtcbiAgcmV0dXJuIFt4ICsgTWF0aC5zaW4oeCArIHkpICogciwgeSArIE1hdGguY29zKHggLSB5KSAqIHJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWxhdW5heSB7XG4gIHN0YXRpYyBmcm9tKHBvaW50cywgZnggPSBwb2ludFgsIGZ5ID0gcG9pbnRZLCB0aGF0KSB7XG4gICAgcmV0dXJuIG5ldyBEZWxhdW5heShcImxlbmd0aFwiIGluIHBvaW50c1xuICAgICAgICA/IGZsYXRBcnJheShwb2ludHMsIGZ4LCBmeSwgdGhhdClcbiAgICAgICAgOiBGbG9hdDY0QXJyYXkuZnJvbShmbGF0SXRlcmFibGUocG9pbnRzLCBmeCwgZnksIHRoYXQpKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocG9pbnRzKSB7XG4gICAgdGhpcy5fZGVsYXVuYXRvciA9IG5ldyBEZWxhdW5hdG9yKHBvaW50cyk7XG4gICAgdGhpcy5pbmVkZ2VzID0gbmV3IEludDMyQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgIHRoaXMuX2h1bGxJbmRleCA9IG5ldyBJbnQzMkFycmF5KHBvaW50cy5sZW5ndGggLyAyKTtcbiAgICB0aGlzLnBvaW50cyA9IHRoaXMuX2RlbGF1bmF0b3IuY29vcmRzO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fZGVsYXVuYXRvci51cGRhdGUoKTtcbiAgICB0aGlzLl9pbml0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgY29uc3QgZCA9IHRoaXMuX2RlbGF1bmF0b3IsIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXG4gICAgLy8gY2hlY2sgZm9yIGNvbGxpbmVhclxuICAgIGlmIChkLmh1bGwgJiYgZC5odWxsLmxlbmd0aCA+IDIgJiYgY29sbGluZWFyKGQpKSB7XG4gICAgICB0aGlzLmNvbGxpbmVhciA9IEludDMyQXJyYXkuZnJvbSh7bGVuZ3RoOiBwb2ludHMubGVuZ3RoLzJ9LCAoXyxpKSA9PiBpKVxuICAgICAgICAuc29ydCgoaSwgaikgPT4gcG9pbnRzWzIgKiBpXSAtIHBvaW50c1syICogal0gfHwgcG9pbnRzWzIgKiBpICsgMV0gLSBwb2ludHNbMiAqIGogKyAxXSk7IC8vIGZvciBleGFjdCBuZWlnaGJvcnNcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmNvbGxpbmVhclswXSwgZiA9IHRoaXMuY29sbGluZWFyW3RoaXMuY29sbGluZWFyLmxlbmd0aCAtIDFdLFxuICAgICAgICBib3VuZHMgPSBbIHBvaW50c1syICogZV0sIHBvaW50c1syICogZSArIDFdLCBwb2ludHNbMiAqIGZdLCBwb2ludHNbMiAqIGYgKyAxXSBdLFxuICAgICAgICByID0gMWUtOCAqIE1hdGguaHlwb3QoYm91bmRzWzNdIC0gYm91bmRzWzFdLCBib3VuZHNbMl0gLSBib3VuZHNbMF0pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoIC8gMjsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCBwID0gaml0dGVyKHBvaW50c1syICogaV0sIHBvaW50c1syICogaSArIDFdLCByKTtcbiAgICAgICAgcG9pbnRzWzIgKiBpXSA9IHBbMF07XG4gICAgICAgIHBvaW50c1syICogaSArIDFdID0gcFsxXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RlbGF1bmF0b3IgPSBuZXcgRGVsYXVuYXRvcihwb2ludHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5jb2xsaW5lYXI7XG4gICAgfVxuXG4gICAgY29uc3QgaGFsZmVkZ2VzID0gdGhpcy5oYWxmZWRnZXMgPSB0aGlzLl9kZWxhdW5hdG9yLmhhbGZlZGdlcztcbiAgICBjb25zdCBodWxsID0gdGhpcy5odWxsID0gdGhpcy5fZGVsYXVuYXRvci5odWxsO1xuICAgIGNvbnN0IHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzID0gdGhpcy5fZGVsYXVuYXRvci50cmlhbmdsZXM7XG4gICAgY29uc3QgaW5lZGdlcyA9IHRoaXMuaW5lZGdlcy5maWxsKC0xKTtcbiAgICBjb25zdCBodWxsSW5kZXggPSB0aGlzLl9odWxsSW5kZXguZmlsbCgtMSk7XG5cbiAgICAvLyBDb21wdXRlIGFuIGluZGV4IGZyb20gZWFjaCBwb2ludCB0byBhbiAoYXJiaXRyYXJ5KSBpbmNvbWluZyBoYWxmZWRnZVxuICAgIC8vIFVzZWQgdG8gZ2l2ZSB0aGUgZmlyc3QgbmVpZ2hib3Igb2YgZWFjaCBwb2ludDsgZm9yIHRoaXMgcmVhc29uLFxuICAgIC8vIG9uIHRoZSBodWxsIHdlIGdpdmUgcHJpb3JpdHkgdG8gZXh0ZXJpb3IgaGFsZmVkZ2VzXG4gICAgZm9yIChsZXQgZSA9IDAsIG4gPSBoYWxmZWRnZXMubGVuZ3RoOyBlIDwgbjsgKytlKSB7XG4gICAgICBjb25zdCBwID0gdHJpYW5nbGVzW2UgJSAzID09PSAyID8gZSAtIDIgOiBlICsgMV07XG4gICAgICBpZiAoaGFsZmVkZ2VzW2VdID09PSAtMSB8fCBpbmVkZ2VzW3BdID09PSAtMSkgaW5lZGdlc1twXSA9IGU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gaHVsbC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGh1bGxJbmRleFtodWxsW2ldXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gZGVnZW5lcmF0ZSBjYXNlOiAxIG9yIDIgKGRpc3RpbmN0KSBwb2ludHNcbiAgICBpZiAoaHVsbC5sZW5ndGggPD0gMiAmJiBodWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMudHJpYW5nbGVzID0gbmV3IEludDMyQXJyYXkoMykuZmlsbCgtMSk7XG4gICAgICB0aGlzLmhhbGZlZGdlcyA9IG5ldyBJbnQzMkFycmF5KDMpLmZpbGwoLTEpO1xuICAgICAgdGhpcy50cmlhbmdsZXNbMF0gPSBodWxsWzBdO1xuICAgICAgdGhpcy50cmlhbmdsZXNbMV0gPSBodWxsWzFdO1xuICAgICAgdGhpcy50cmlhbmdsZXNbMl0gPSBodWxsWzFdO1xuICAgICAgaW5lZGdlc1todWxsWzBdXSA9IDE7XG4gICAgICBpZiAoaHVsbC5sZW5ndGggPT09IDIpIGluZWRnZXNbaHVsbFsxXV0gPSAwO1xuICAgIH1cbiAgfVxuICB2b3Jvbm9pKGJvdW5kcykge1xuICAgIHJldHVybiBuZXcgVm9yb25vaSh0aGlzLCBib3VuZHMpO1xuICB9XG4gICpuZWlnaGJvcnMoaSkge1xuICAgIGNvbnN0IHtpbmVkZ2VzLCBodWxsLCBfaHVsbEluZGV4LCBoYWxmZWRnZXMsIHRyaWFuZ2xlcywgY29sbGluZWFyfSA9IHRoaXM7XG5cbiAgICAvLyBkZWdlbmVyYXRlIGNhc2Ugd2l0aCBzZXZlcmFsIGNvbGxpbmVhciBwb2ludHNcbiAgICBpZiAoY29sbGluZWFyKSB7XG4gICAgICBjb25zdCBsID0gY29sbGluZWFyLmluZGV4T2YoaSk7XG4gICAgICBpZiAobCA+IDApIHlpZWxkIGNvbGxpbmVhcltsIC0gMV07XG4gICAgICBpZiAobCA8IGNvbGxpbmVhci5sZW5ndGggLSAxKSB5aWVsZCBjb2xsaW5lYXJbbCArIDFdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGUwID0gaW5lZGdlc1tpXTtcbiAgICBpZiAoZTAgPT09IC0xKSByZXR1cm47IC8vIGNvaW5jaWRlbnQgcG9pbnRcbiAgICBsZXQgZSA9IGUwLCBwMCA9IC0xO1xuICAgIGRvIHtcbiAgICAgIHlpZWxkIHAwID0gdHJpYW5nbGVzW2VdO1xuICAgICAgZSA9IGUgJSAzID09PSAyID8gZSAtIDIgOiBlICsgMTtcbiAgICAgIGlmICh0cmlhbmdsZXNbZV0gIT09IGkpIHJldHVybjsgLy8gYmFkIHRyaWFuZ3VsYXRpb25cbiAgICAgIGUgPSBoYWxmZWRnZXNbZV07XG4gICAgICBpZiAoZSA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgcCA9IGh1bGxbKF9odWxsSW5kZXhbaV0gKyAxKSAlIGh1bGwubGVuZ3RoXTtcbiAgICAgICAgaWYgKHAgIT09IHAwKSB5aWVsZCBwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAoZSAhPT0gZTApO1xuICB9XG4gIGZpbmQoeCwgeSwgaSA9IDApIHtcbiAgICBpZiAoKHggPSAreCwgeCAhPT0geCkgfHwgKHkgPSAreSwgeSAhPT0geSkpIHJldHVybiAtMTtcbiAgICBjb25zdCBpMCA9IGk7XG4gICAgbGV0IGM7XG4gICAgd2hpbGUgKChjID0gdGhpcy5fc3RlcChpLCB4LCB5KSkgPj0gMCAmJiBjICE9PSBpICYmIGMgIT09IGkwKSBpID0gYztcbiAgICByZXR1cm4gYztcbiAgfVxuICBfc3RlcChpLCB4LCB5KSB7XG4gICAgY29uc3Qge2luZWRnZXMsIGh1bGwsIF9odWxsSW5kZXgsIGhhbGZlZGdlcywgdHJpYW5nbGVzLCBwb2ludHN9ID0gdGhpcztcbiAgICBpZiAoaW5lZGdlc1tpXSA9PT0gLTEgfHwgIXBvaW50cy5sZW5ndGgpIHJldHVybiAoaSArIDEpICUgKHBvaW50cy5sZW5ndGggPj4gMSk7XG4gICAgbGV0IGMgPSBpO1xuICAgIGxldCBkYyA9IHBvdyh4IC0gcG9pbnRzW2kgKiAyXSwgMikgKyBwb3coeSAtIHBvaW50c1tpICogMiArIDFdLCAyKTtcbiAgICBjb25zdCBlMCA9IGluZWRnZXNbaV07XG4gICAgbGV0IGUgPSBlMDtcbiAgICBkbyB7XG4gICAgICBsZXQgdCA9IHRyaWFuZ2xlc1tlXTtcbiAgICAgIGNvbnN0IGR0ID0gcG93KHggLSBwb2ludHNbdCAqIDJdLCAyKSArIHBvdyh5IC0gcG9pbnRzW3QgKiAyICsgMV0sIDIpO1xuICAgICAgaWYgKGR0IDwgZGMpIGRjID0gZHQsIGMgPSB0O1xuICAgICAgZSA9IGUgJSAzID09PSAyID8gZSAtIDIgOiBlICsgMTtcbiAgICAgIGlmICh0cmlhbmdsZXNbZV0gIT09IGkpIGJyZWFrOyAvLyBiYWQgdHJpYW5ndWxhdGlvblxuICAgICAgZSA9IGhhbGZlZGdlc1tlXTtcbiAgICAgIGlmIChlID09PSAtMSkge1xuICAgICAgICBlID0gaHVsbFsoX2h1bGxJbmRleFtpXSArIDEpICUgaHVsbC5sZW5ndGhdO1xuICAgICAgICBpZiAoZSAhPT0gdCkge1xuICAgICAgICAgIGlmIChwb3coeCAtIHBvaW50c1tlICogMl0sIDIpICsgcG93KHkgLSBwb2ludHNbZSAqIDIgKyAxXSwgMikgPCBkYykgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoZSAhPT0gZTApO1xuICAgIHJldHVybiBjO1xuICB9XG4gIHJlbmRlcihjb250ZXh0KSB7XG4gICAgY29uc3QgYnVmZmVyID0gY29udGV4dCA9PSBudWxsID8gY29udGV4dCA9IG5ldyBQYXRoIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHtwb2ludHMsIGhhbGZlZGdlcywgdHJpYW5nbGVzfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBoYWxmZWRnZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBqID0gaGFsZmVkZ2VzW2ldO1xuICAgICAgaWYgKGogPCBpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHRpID0gdHJpYW5nbGVzW2ldICogMjtcbiAgICAgIGNvbnN0IHRqID0gdHJpYW5nbGVzW2pdICogMjtcbiAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1t0aV0sIHBvaW50c1t0aSArIDFdKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1t0al0sIHBvaW50c1t0aiArIDFdKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJIdWxsKGNvbnRleHQpO1xuICAgIHJldHVybiBidWZmZXIgJiYgYnVmZmVyLnZhbHVlKCk7XG4gIH1cbiAgcmVuZGVyUG9pbnRzKGNvbnRleHQsIHIgPSAyKSB7XG4gICAgY29uc3QgYnVmZmVyID0gY29udGV4dCA9PSBudWxsID8gY29udGV4dCA9IG5ldyBQYXRoIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHtwb2ludHN9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSBwb2ludHNbaV0sIHkgPSBwb2ludHNbaSArIDFdO1xuICAgICAgY29udGV4dC5tb3ZlVG8oeCArIHIsIHkpO1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgciwgMCwgdGF1KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlciAmJiBidWZmZXIudmFsdWUoKTtcbiAgfVxuICByZW5kZXJIdWxsKGNvbnRleHQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBjb250ZXh0ID09IG51bGwgPyBjb250ZXh0ID0gbmV3IFBhdGggOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qge2h1bGwsIHBvaW50c30gPSB0aGlzO1xuICAgIGNvbnN0IGggPSBodWxsWzBdICogMiwgbiA9IGh1bGwubGVuZ3RoO1xuICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1toXSwgcG9pbnRzW2ggKyAxXSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGggPSAyICogaHVsbFtpXTtcbiAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1toXSwgcG9pbnRzW2ggKyAxXSk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuIGJ1ZmZlciAmJiBidWZmZXIudmFsdWUoKTtcbiAgfVxuICBodWxsUG9seWdvbigpIHtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb247XG4gICAgdGhpcy5yZW5kZXJIdWxsKHBvbHlnb24pO1xuICAgIHJldHVybiBwb2x5Z29uLnZhbHVlKCk7XG4gIH1cbiAgcmVuZGVyVHJpYW5nbGUoaSwgY29udGV4dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQgPT0gbnVsbCA/IGNvbnRleHQgPSBuZXcgUGF0aCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7cG9pbnRzLCB0cmlhbmdsZXN9ID0gdGhpcztcbiAgICBjb25zdCB0MCA9IHRyaWFuZ2xlc1tpICo9IDNdICogMjtcbiAgICBjb25zdCB0MSA9IHRyaWFuZ2xlc1tpICsgMV0gKiAyO1xuICAgIGNvbnN0IHQyID0gdHJpYW5nbGVzW2kgKyAyXSAqIDI7XG4gICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzW3QwXSwgcG9pbnRzW3QwICsgMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHBvaW50c1t0MV0sIHBvaW50c1t0MSArIDFdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbdDJdLCBwb2ludHNbdDIgKyAxXSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm4gYnVmZmVyICYmIGJ1ZmZlci52YWx1ZSgpO1xuICB9XG4gICp0cmlhbmdsZVBvbHlnb25zKCkge1xuICAgIGNvbnN0IHt0cmlhbmdsZXN9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRyaWFuZ2xlcy5sZW5ndGggLyAzOyBpIDwgbjsgKytpKSB7XG4gICAgICB5aWVsZCB0aGlzLnRyaWFuZ2xlUG9seWdvbihpKTtcbiAgICB9XG4gIH1cbiAgdHJpYW5nbGVQb2x5Z29uKGkpIHtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb247XG4gICAgdGhpcy5yZW5kZXJUcmlhbmdsZShpLCBwb2x5Z29uKTtcbiAgICByZXR1cm4gcG9seWdvbi52YWx1ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXRBcnJheShwb2ludHMsIGZ4LCBmeSwgdGhhdCkge1xuICBjb25zdCBuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgYXJyYXkgPSBuZXcgRmxvYXQ2NEFycmF5KG4gKiAyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBwID0gcG9pbnRzW2ldO1xuICAgIGFycmF5W2kgKiAyXSA9IGZ4LmNhbGwodGhhdCwgcCwgaSwgcG9pbnRzKTtcbiAgICBhcnJheVtpICogMiArIDFdID0gZnkuY2FsbCh0aGF0LCBwLCBpLCBwb2ludHMpO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24qIGZsYXRJdGVyYWJsZShwb2ludHMsIGZ4LCBmeSwgdGhhdCkge1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgcCBvZiBwb2ludHMpIHtcbiAgICB5aWVsZCBmeC5jYWxsKHRoYXQsIHAsIGksIHBvaW50cyk7XG4gICAgeWllbGQgZnkuY2FsbCh0aGF0LCBwLCBpLCBwb2ludHMpO1xuICAgICsraTtcbiAgfVxufVxuIiwiY29uc3QgZXBzaWxvbiA9IDFlLTY7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3kwID0gLy8gc3RhcnQgb2YgY3VycmVudCBzdWJwYXRoXG4gICAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICB0aGlzLl8gPSBcIlwiO1xuICB9XG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy5fICs9IGBNJHt0aGlzLl94MCA9IHRoaXMuX3gxID0gK3h9LCR7dGhpcy5feTAgPSB0aGlzLl95MSA9ICt5fWA7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuXyArPSBcIlpcIjtcbiAgICB9XG4gIH1cbiAgbGluZVRvKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gYEwke3RoaXMuX3gxID0gK3h9LCR7dGhpcy5feTEgPSAreX1gO1xuICB9XG4gIGFyYyh4LCB5LCByKSB7XG4gICAgeCA9ICt4LCB5ID0gK3ksIHIgPSArcjtcbiAgICBjb25zdCB4MCA9IHggKyByO1xuICAgIGNvbnN0IHkwID0geTtcbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1c1wiKTtcbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHRoaXMuXyArPSBgTSR7eDB9LCR7eTB9YDtcbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHgwKSA+IGVwc2lsb24gfHwgTWF0aC5hYnModGhpcy5feTEgLSB5MCkgPiBlcHNpbG9uKSB0aGlzLl8gKz0gXCJMXCIgKyB4MCArIFwiLFwiICsgeTA7XG4gICAgaWYgKCFyKSByZXR1cm47XG4gICAgdGhpcy5fICs9IGBBJHtyfSwke3J9LDAsMSwxLCR7eCAtIHJ9LCR7eX1BJHtyfSwke3J9LDAsMSwxLCR7dGhpcy5feDEgPSB4MH0sJHt0aGlzLl95MSA9IHkwfWA7XG4gIH1cbiAgcmVjdCh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IGBNJHt0aGlzLl94MCA9IHRoaXMuX3gxID0gK3h9LCR7dGhpcy5feTAgPSB0aGlzLl95MSA9ICt5fWgkeyt3fXYkeytofWgkey13fVpgO1xuICB9XG4gIHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl8gfHwgbnVsbDtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuXyA9IFtdO1xuICB9XG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy5fLnB1c2goW3gsIHldKTtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5fLnB1c2godGhpcy5fWzBdLnNsaWNlKCkpO1xuICB9XG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgdGhpcy5fLnB1c2goW3gsIHldKTtcbiAgfVxuICB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fLmxlbmd0aCA/IHRoaXMuXyA6IG51bGw7XG4gIH1cbn1cbiIsImltcG9ydCBQYXRoIGZyb20gXCIuL3BhdGguanNcIjtcbmltcG9ydCBQb2x5Z29uIGZyb20gXCIuL3BvbHlnb24uanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVm9yb25vaSB7XG4gIGNvbnN0cnVjdG9yKGRlbGF1bmF5LCBbeG1pbiwgeW1pbiwgeG1heCwgeW1heF0gPSBbMCwgMCwgOTYwLCA1MDBdKSB7XG4gICAgaWYgKCEoKHhtYXggPSAreG1heCkgPj0gKHhtaW4gPSAreG1pbikpIHx8ICEoKHltYXggPSAreW1heCkgPj0gKHltaW4gPSAreW1pbikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJvdW5kc1wiKTtcbiAgICB0aGlzLmRlbGF1bmF5ID0gZGVsYXVuYXk7XG4gICAgdGhpcy5fY2lyY3VtY2VudGVycyA9IG5ldyBGbG9hdDY0QXJyYXkoZGVsYXVuYXkucG9pbnRzLmxlbmd0aCAqIDIpO1xuICAgIHRoaXMudmVjdG9ycyA9IG5ldyBGbG9hdDY0QXJyYXkoZGVsYXVuYXkucG9pbnRzLmxlbmd0aCAqIDIpO1xuICAgIHRoaXMueG1heCA9IHhtYXgsIHRoaXMueG1pbiA9IHhtaW47XG4gICAgdGhpcy55bWF4ID0geW1heCwgdGhpcy55bWluID0geW1pbjtcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuZGVsYXVuYXkudXBkYXRlKCk7XG4gICAgdGhpcy5faW5pdCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9pbml0KCkge1xuICAgIGNvbnN0IHtkZWxhdW5heToge3BvaW50cywgaHVsbCwgdHJpYW5nbGVzfSwgdmVjdG9yc30gPSB0aGlzO1xuXG4gICAgLy8gQ29tcHV0ZSBjaXJjdW1jZW50ZXJzLlxuICAgIGNvbnN0IGNpcmN1bWNlbnRlcnMgPSB0aGlzLmNpcmN1bWNlbnRlcnMgPSB0aGlzLl9jaXJjdW1jZW50ZXJzLnN1YmFycmF5KDAsIHRyaWFuZ2xlcy5sZW5ndGggLyAzICogMik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBuID0gdHJpYW5nbGVzLmxlbmd0aCwgeCwgeTsgaSA8IG47IGkgKz0gMywgaiArPSAyKSB7XG4gICAgICBjb25zdCB0MSA9IHRyaWFuZ2xlc1tpXSAqIDI7XG4gICAgICBjb25zdCB0MiA9IHRyaWFuZ2xlc1tpICsgMV0gKiAyO1xuICAgICAgY29uc3QgdDMgPSB0cmlhbmdsZXNbaSArIDJdICogMjtcbiAgICAgIGNvbnN0IHgxID0gcG9pbnRzW3QxXTtcbiAgICAgIGNvbnN0IHkxID0gcG9pbnRzW3QxICsgMV07XG4gICAgICBjb25zdCB4MiA9IHBvaW50c1t0Ml07XG4gICAgICBjb25zdCB5MiA9IHBvaW50c1t0MiArIDFdO1xuICAgICAgY29uc3QgeDMgPSBwb2ludHNbdDNdO1xuICAgICAgY29uc3QgeTMgPSBwb2ludHNbdDMgKyAxXTtcblxuICAgICAgY29uc3QgZHggPSB4MiAtIHgxO1xuICAgICAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICAgICAgY29uc3QgZXggPSB4MyAtIHgxO1xuICAgICAgY29uc3QgZXkgPSB5MyAtIHkxO1xuICAgICAgY29uc3QgYmwgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGNvbnN0IGNsID0gZXggKiBleCArIGV5ICogZXk7XG4gICAgICBjb25zdCBhYiA9IChkeCAqIGV5IC0gZHkgKiBleCkgKiAyO1xuXG4gICAgICBpZiAoIWFiKSB7XG4gICAgICAgIC8vIGRlZ2VuZXJhdGUgY2FzZSAoY29sbGluZWFyIGRpYWdyYW0pXG4gICAgICAgIHggPSAoeDEgKyB4MykgLyAyIC0gMWU4ICogZXk7XG4gICAgICAgIHkgPSAoeTEgKyB5MykgLyAyICsgMWU4ICogZXg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChNYXRoLmFicyhhYikgPCAxZS04KSB7XG4gICAgICAgIC8vIGFsbW9zdCBlcXVhbCBwb2ludHMgKGRlZ2VuZXJhdGUgdHJpYW5nbGUpXG4gICAgICAgIHggPSAoeDEgKyB4MykgLyAyO1xuICAgICAgICB5ID0gKHkxICsgeTMpIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGQgPSAxIC8gYWI7XG4gICAgICAgIHggPSB4MSArIChleSAqIGJsIC0gZHkgKiBjbCkgKiBkO1xuICAgICAgICB5ID0geTEgKyAoZHggKiBjbCAtIGV4ICogYmwpICogZDtcbiAgICAgIH1cbiAgICAgIGNpcmN1bWNlbnRlcnNbal0gPSB4O1xuICAgICAgY2lyY3VtY2VudGVyc1tqICsgMV0gPSB5O1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgZXh0ZXJpb3IgY2VsbCByYXlzLlxuICAgIGxldCBoID0gaHVsbFtodWxsLmxlbmd0aCAtIDFdO1xuICAgIGxldCBwMCwgcDEgPSBoICogNDtcbiAgICBsZXQgeDAsIHgxID0gcG9pbnRzWzIgKiBoXTtcbiAgICBsZXQgeTAsIHkxID0gcG9pbnRzWzIgKiBoICsgMV07XG4gICAgdmVjdG9ycy5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaHVsbC5sZW5ndGg7ICsraSkge1xuICAgICAgaCA9IGh1bGxbaV07XG4gICAgICBwMCA9IHAxLCB4MCA9IHgxLCB5MCA9IHkxO1xuICAgICAgcDEgPSBoICogNCwgeDEgPSBwb2ludHNbMiAqIGhdLCB5MSA9IHBvaW50c1syICogaCArIDFdO1xuICAgICAgdmVjdG9yc1twMCArIDJdID0gdmVjdG9yc1twMV0gPSB5MCAtIHkxO1xuICAgICAgdmVjdG9yc1twMCArIDNdID0gdmVjdG9yc1twMSArIDFdID0geDEgLSB4MDtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBjb250ZXh0ID09IG51bGwgPyBjb250ZXh0ID0gbmV3IFBhdGggOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qge2RlbGF1bmF5OiB7aGFsZmVkZ2VzLCBpbmVkZ2VzLCBodWxsfSwgY2lyY3VtY2VudGVycywgdmVjdG9yc30gPSB0aGlzO1xuICAgIGlmIChodWxsLmxlbmd0aCA8PSAxKSByZXR1cm4gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGhhbGZlZGdlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGogPSBoYWxmZWRnZXNbaV07XG4gICAgICBpZiAoaiA8IGkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGkgPSBNYXRoLmZsb29yKGkgLyAzKSAqIDI7XG4gICAgICBjb25zdCB0aiA9IE1hdGguZmxvb3IoaiAvIDMpICogMjtcbiAgICAgIGNvbnN0IHhpID0gY2lyY3VtY2VudGVyc1t0aV07XG4gICAgICBjb25zdCB5aSA9IGNpcmN1bWNlbnRlcnNbdGkgKyAxXTtcbiAgICAgIGNvbnN0IHhqID0gY2lyY3VtY2VudGVyc1t0al07XG4gICAgICBjb25zdCB5aiA9IGNpcmN1bWNlbnRlcnNbdGogKyAxXTtcbiAgICAgIHRoaXMuX3JlbmRlclNlZ21lbnQoeGksIHlpLCB4aiwgeWosIGNvbnRleHQpO1xuICAgIH1cbiAgICBsZXQgaDAsIGgxID0gaHVsbFtodWxsLmxlbmd0aCAtIDFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaHVsbC5sZW5ndGg7ICsraSkge1xuICAgICAgaDAgPSBoMSwgaDEgPSBodWxsW2ldO1xuICAgICAgY29uc3QgdCA9IE1hdGguZmxvb3IoaW5lZGdlc1toMV0gLyAzKSAqIDI7XG4gICAgICBjb25zdCB4ID0gY2lyY3VtY2VudGVyc1t0XTtcbiAgICAgIGNvbnN0IHkgPSBjaXJjdW1jZW50ZXJzW3QgKyAxXTtcbiAgICAgIGNvbnN0IHYgPSBoMCAqIDQ7XG4gICAgICBjb25zdCBwID0gdGhpcy5fcHJvamVjdCh4LCB5LCB2ZWN0b3JzW3YgKyAyXSwgdmVjdG9yc1t2ICsgM10pO1xuICAgICAgaWYgKHApIHRoaXMuX3JlbmRlclNlZ21lbnQoeCwgeSwgcFswXSwgcFsxXSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIgJiYgYnVmZmVyLnZhbHVlKCk7XG4gIH1cbiAgcmVuZGVyQm91bmRzKGNvbnRleHQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBjb250ZXh0ID09IG51bGwgPyBjb250ZXh0ID0gbmV3IFBhdGggOiB1bmRlZmluZWQ7XG4gICAgY29udGV4dC5yZWN0KHRoaXMueG1pbiwgdGhpcy55bWluLCB0aGlzLnhtYXggLSB0aGlzLnhtaW4sIHRoaXMueW1heCAtIHRoaXMueW1pbik7XG4gICAgcmV0dXJuIGJ1ZmZlciAmJiBidWZmZXIudmFsdWUoKTtcbiAgfVxuICByZW5kZXJDZWxsKGksIGNvbnRleHQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBjb250ZXh0ID09IG51bGwgPyBjb250ZXh0ID0gbmV3IFBhdGggOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2xpcChpKTtcbiAgICBpZiAocG9pbnRzID09PSBudWxsIHx8ICFwb2ludHMubGVuZ3RoKSByZXR1cm47XG4gICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgIGxldCBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAocG9pbnRzWzBdID09PSBwb2ludHNbbi0yXSAmJiBwb2ludHNbMV0gPT09IHBvaW50c1tuLTFdICYmIG4gPiAxKSBuIC09IDI7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgIGlmIChwb2ludHNbaV0gIT09IHBvaW50c1tpLTJdIHx8IHBvaW50c1tpKzFdICE9PSBwb2ludHNbaS0xXSlcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm4gYnVmZmVyICYmIGJ1ZmZlci52YWx1ZSgpO1xuICB9XG4gICpjZWxsUG9seWdvbnMoKSB7XG4gICAgY29uc3Qge2RlbGF1bmF5OiB7cG9pbnRzfX0gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCAvIDI7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmNlbGxQb2x5Z29uKGkpO1xuICAgICAgaWYgKGNlbGwpIGNlbGwuaW5kZXggPSBpLCB5aWVsZCBjZWxsO1xuICAgIH1cbiAgfVxuICBjZWxsUG9seWdvbihpKSB7XG4gICAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uO1xuICAgIHRoaXMucmVuZGVyQ2VsbChpLCBwb2x5Z29uKTtcbiAgICByZXR1cm4gcG9seWdvbi52YWx1ZSgpO1xuICB9XG4gIF9yZW5kZXJTZWdtZW50KHgwLCB5MCwgeDEsIHkxLCBjb250ZXh0KSB7XG4gICAgbGV0IFM7XG4gICAgY29uc3QgYzAgPSB0aGlzLl9yZWdpb25jb2RlKHgwLCB5MCk7XG4gICAgY29uc3QgYzEgPSB0aGlzLl9yZWdpb25jb2RlKHgxLCB5MSk7XG4gICAgaWYgKGMwID09PSAwICYmIGMxID09PSAwKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICB9IGVsc2UgaWYgKFMgPSB0aGlzLl9jbGlwU2VnbWVudCh4MCwgeTAsIHgxLCB5MSwgYzAsIGMxKSkge1xuICAgICAgY29udGV4dC5tb3ZlVG8oU1swXSwgU1sxXSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhTWzJdLCBTWzNdKTtcbiAgICB9XG4gIH1cbiAgY29udGFpbnMoaSwgeCwgeSkge1xuICAgIGlmICgoeCA9ICt4LCB4ICE9PSB4KSB8fCAoeSA9ICt5LCB5ICE9PSB5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmRlbGF1bmF5Ll9zdGVwKGksIHgsIHkpID09PSBpO1xuICB9XG4gICpuZWlnaGJvcnMoaSkge1xuICAgIGNvbnN0IGNpID0gdGhpcy5fY2xpcChpKTtcbiAgICBpZiAoY2kpIGZvciAoY29uc3QgaiBvZiB0aGlzLmRlbGF1bmF5Lm5laWdoYm9ycyhpKSkge1xuICAgICAgY29uc3QgY2ogPSB0aGlzLl9jbGlwKGopO1xuICAgICAgLy8gZmluZCB0aGUgY29tbW9uIGVkZ2VcbiAgICAgIGlmIChjaikgbG9vcDogZm9yIChsZXQgYWkgPSAwLCBsaSA9IGNpLmxlbmd0aDsgYWkgPCBsaTsgYWkgKz0gMikge1xuICAgICAgICBmb3IgKGxldCBhaiA9IDAsIGxqID0gY2oubGVuZ3RoOyBhaiA8IGxqOyBhaiArPSAyKSB7XG4gICAgICAgICAgaWYgKGNpW2FpXSA9PSBjalthal1cbiAgICAgICAgICAmJiBjaVthaSArIDFdID09IGNqW2FqICsgMV1cbiAgICAgICAgICAmJiBjaVsoYWkgKyAyKSAlIGxpXSA9PSBjalsoYWogKyBsaiAtIDIpICUgbGpdXG4gICAgICAgICAgJiYgY2lbKGFpICsgMykgJSBsaV0gPT0gY2pbKGFqICsgbGogLSAxKSAlIGxqXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgeWllbGQgajtcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jZWxsKGkpIHtcbiAgICBjb25zdCB7Y2lyY3VtY2VudGVycywgZGVsYXVuYXk6IHtpbmVkZ2VzLCBoYWxmZWRnZXMsIHRyaWFuZ2xlc319ID0gdGhpcztcbiAgICBjb25zdCBlMCA9IGluZWRnZXNbaV07XG4gICAgaWYgKGUwID09PSAtMSkgcmV0dXJuIG51bGw7IC8vIGNvaW5jaWRlbnQgcG9pbnRcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBsZXQgZSA9IGUwO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHQgPSBNYXRoLmZsb29yKGUgLyAzKTtcbiAgICAgIHBvaW50cy5wdXNoKGNpcmN1bWNlbnRlcnNbdCAqIDJdLCBjaXJjdW1jZW50ZXJzW3QgKiAyICsgMV0pO1xuICAgICAgZSA9IGUgJSAzID09PSAyID8gZSAtIDIgOiBlICsgMTtcbiAgICAgIGlmICh0cmlhbmdsZXNbZV0gIT09IGkpIGJyZWFrOyAvLyBiYWQgdHJpYW5ndWxhdGlvblxuICAgICAgZSA9IGhhbGZlZGdlc1tlXTtcbiAgICB9IHdoaWxlIChlICE9PSBlMCAmJiBlICE9PSAtMSk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBfY2xpcChpKSB7XG4gICAgLy8gZGVnZW5lcmF0ZSBjYXNlICgxIHZhbGlkIHBvaW50OiByZXR1cm4gdGhlIGJveClcbiAgICBpZiAoaSA9PT0gMCAmJiB0aGlzLmRlbGF1bmF5Lmh1bGwubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gW3RoaXMueG1heCwgdGhpcy55bWluLCB0aGlzLnhtYXgsIHRoaXMueW1heCwgdGhpcy54bWluLCB0aGlzLnltYXgsIHRoaXMueG1pbiwgdGhpcy55bWluXTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2VsbChpKTtcbiAgICBpZiAocG9pbnRzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB7dmVjdG9yczogVn0gPSB0aGlzO1xuICAgIGNvbnN0IHYgPSBpICogNDtcbiAgICByZXR1cm4gVlt2XSB8fCBWW3YgKyAxXVxuICAgICAgICA/IHRoaXMuX2NsaXBJbmZpbml0ZShpLCBwb2ludHMsIFZbdl0sIFZbdiArIDFdLCBWW3YgKyAyXSwgVlt2ICsgM10pXG4gICAgICAgIDogdGhpcy5fY2xpcEZpbml0ZShpLCBwb2ludHMpO1xuICB9XG4gIF9jbGlwRmluaXRlKGksIHBvaW50cykge1xuICAgIGNvbnN0IG4gPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCBQID0gbnVsbDtcbiAgICBsZXQgeDAsIHkwLCB4MSA9IHBvaW50c1tuIC0gMl0sIHkxID0gcG9pbnRzW24gLSAxXTtcbiAgICBsZXQgYzAsIGMxID0gdGhpcy5fcmVnaW9uY29kZSh4MSwgeTEpO1xuICAgIGxldCBlMCwgZTE7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyBqICs9IDIpIHtcbiAgICAgIHgwID0geDEsIHkwID0geTEsIHgxID0gcG9pbnRzW2pdLCB5MSA9IHBvaW50c1tqICsgMV07XG4gICAgICBjMCA9IGMxLCBjMSA9IHRoaXMuX3JlZ2lvbmNvZGUoeDEsIHkxKTtcbiAgICAgIGlmIChjMCA9PT0gMCAmJiBjMSA9PT0gMCkge1xuICAgICAgICBlMCA9IGUxLCBlMSA9IDA7XG4gICAgICAgIGlmIChQKSBQLnB1c2goeDEsIHkxKTtcbiAgICAgICAgZWxzZSBQID0gW3gxLCB5MV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgUywgc3gwLCBzeTAsIHN4MSwgc3kxO1xuICAgICAgICBpZiAoYzAgPT09IDApIHtcbiAgICAgICAgICBpZiAoKFMgPSB0aGlzLl9jbGlwU2VnbWVudCh4MCwgeTAsIHgxLCB5MSwgYzAsIGMxKSkgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgIFtzeDAsIHN5MCwgc3gxLCBzeTFdID0gUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKFMgPSB0aGlzLl9jbGlwU2VnbWVudCh4MSwgeTEsIHgwLCB5MCwgYzEsIGMwKSkgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgIFtzeDEsIHN5MSwgc3gwLCBzeTBdID0gUztcbiAgICAgICAgICBlMCA9IGUxLCBlMSA9IHRoaXMuX2VkZ2Vjb2RlKHN4MCwgc3kwKTtcbiAgICAgICAgICBpZiAoZTAgJiYgZTEpIHRoaXMuX2VkZ2UoaSwgZTAsIGUxLCBQLCBQLmxlbmd0aCk7XG4gICAgICAgICAgaWYgKFApIFAucHVzaChzeDAsIHN5MCk7XG4gICAgICAgICAgZWxzZSBQID0gW3N4MCwgc3kwXTtcbiAgICAgICAgfVxuICAgICAgICBlMCA9IGUxLCBlMSA9IHRoaXMuX2VkZ2Vjb2RlKHN4MSwgc3kxKTtcbiAgICAgICAgaWYgKGUwICYmIGUxKSB0aGlzLl9lZGdlKGksIGUwLCBlMSwgUCwgUC5sZW5ndGgpO1xuICAgICAgICBpZiAoUCkgUC5wdXNoKHN4MSwgc3kxKTtcbiAgICAgICAgZWxzZSBQID0gW3N4MSwgc3kxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFApIHtcbiAgICAgIGUwID0gZTEsIGUxID0gdGhpcy5fZWRnZWNvZGUoUFswXSwgUFsxXSk7XG4gICAgICBpZiAoZTAgJiYgZTEpIHRoaXMuX2VkZ2UoaSwgZTAsIGUxLCBQLCBQLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbnRhaW5zKGksICh0aGlzLnhtaW4gKyB0aGlzLnhtYXgpIC8gMiwgKHRoaXMueW1pbiArIHRoaXMueW1heCkgLyAyKSkge1xuICAgICAgcmV0dXJuIFt0aGlzLnhtYXgsIHRoaXMueW1pbiwgdGhpcy54bWF4LCB0aGlzLnltYXgsIHRoaXMueG1pbiwgdGhpcy55bWF4LCB0aGlzLnhtaW4sIHRoaXMueW1pbl07XG4gICAgfVxuICAgIHJldHVybiBQO1xuICB9XG4gIF9jbGlwU2VnbWVudCh4MCwgeTAsIHgxLCB5MSwgYzAsIGMxKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChjMCA9PT0gMCAmJiBjMSA9PT0gMCkgcmV0dXJuIFt4MCwgeTAsIHgxLCB5MV07XG4gICAgICBpZiAoYzAgJiBjMSkgcmV0dXJuIG51bGw7XG4gICAgICBsZXQgeCwgeSwgYyA9IGMwIHx8IGMxO1xuICAgICAgaWYgKGMgJiAwYjEwMDApIHggPSB4MCArICh4MSAtIHgwKSAqICh0aGlzLnltYXggLSB5MCkgLyAoeTEgLSB5MCksIHkgPSB0aGlzLnltYXg7XG4gICAgICBlbHNlIGlmIChjICYgMGIwMTAwKSB4ID0geDAgKyAoeDEgLSB4MCkgKiAodGhpcy55bWluIC0geTApIC8gKHkxIC0geTApLCB5ID0gdGhpcy55bWluO1xuICAgICAgZWxzZSBpZiAoYyAmIDBiMDAxMCkgeSA9IHkwICsgKHkxIC0geTApICogKHRoaXMueG1heCAtIHgwKSAvICh4MSAtIHgwKSwgeCA9IHRoaXMueG1heDtcbiAgICAgIGVsc2UgeSA9IHkwICsgKHkxIC0geTApICogKHRoaXMueG1pbiAtIHgwKSAvICh4MSAtIHgwKSwgeCA9IHRoaXMueG1pbjtcbiAgICAgIGlmIChjMCkgeDAgPSB4LCB5MCA9IHksIGMwID0gdGhpcy5fcmVnaW9uY29kZSh4MCwgeTApO1xuICAgICAgZWxzZSB4MSA9IHgsIHkxID0geSwgYzEgPSB0aGlzLl9yZWdpb25jb2RlKHgxLCB5MSk7XG4gICAgfVxuICB9XG4gIF9jbGlwSW5maW5pdGUoaSwgcG9pbnRzLCB2eDAsIHZ5MCwgdnhuLCB2eW4pIHtcbiAgICBsZXQgUCA9IEFycmF5LmZyb20ocG9pbnRzKSwgcDtcbiAgICBpZiAocCA9IHRoaXMuX3Byb2plY3QoUFswXSwgUFsxXSwgdngwLCB2eTApKSBQLnVuc2hpZnQocFswXSwgcFsxXSk7XG4gICAgaWYgKHAgPSB0aGlzLl9wcm9qZWN0KFBbUC5sZW5ndGggLSAyXSwgUFtQLmxlbmd0aCAtIDFdLCB2eG4sIHZ5bikpIFAucHVzaChwWzBdLCBwWzFdKTtcbiAgICBpZiAoUCA9IHRoaXMuX2NsaXBGaW5pdGUoaSwgUCkpIHtcbiAgICAgIGZvciAobGV0IGogPSAwLCBuID0gUC5sZW5ndGgsIGMwLCBjMSA9IHRoaXMuX2VkZ2Vjb2RlKFBbbiAtIDJdLCBQW24gLSAxXSk7IGogPCBuOyBqICs9IDIpIHtcbiAgICAgICAgYzAgPSBjMSwgYzEgPSB0aGlzLl9lZGdlY29kZShQW2pdLCBQW2ogKyAxXSk7XG4gICAgICAgIGlmIChjMCAmJiBjMSkgaiA9IHRoaXMuX2VkZ2UoaSwgYzAsIGMxLCBQLCBqKSwgbiA9IFAubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5jb250YWlucyhpLCAodGhpcy54bWluICsgdGhpcy54bWF4KSAvIDIsICh0aGlzLnltaW4gKyB0aGlzLnltYXgpIC8gMikpIHtcbiAgICAgIFAgPSBbdGhpcy54bWluLCB0aGlzLnltaW4sIHRoaXMueG1heCwgdGhpcy55bWluLCB0aGlzLnhtYXgsIHRoaXMueW1heCwgdGhpcy54bWluLCB0aGlzLnltYXhdO1xuICAgIH1cbiAgICByZXR1cm4gUDtcbiAgfVxuICBfZWRnZShpLCBlMCwgZTEsIFAsIGopIHtcbiAgICB3aGlsZSAoZTAgIT09IGUxKSB7XG4gICAgICBsZXQgeCwgeTtcbiAgICAgIHN3aXRjaCAoZTApIHtcbiAgICAgICAgY2FzZSAwYjAxMDE6IGUwID0gMGIwMTAwOyBjb250aW51ZTsgLy8gdG9wLWxlZnRcbiAgICAgICAgY2FzZSAwYjAxMDA6IGUwID0gMGIwMTEwLCB4ID0gdGhpcy54bWF4LCB5ID0gdGhpcy55bWluOyBicmVhazsgLy8gdG9wXG4gICAgICAgIGNhc2UgMGIwMTEwOiBlMCA9IDBiMDAxMDsgY29udGludWU7IC8vIHRvcC1yaWdodFxuICAgICAgICBjYXNlIDBiMDAxMDogZTAgPSAwYjEwMTAsIHggPSB0aGlzLnhtYXgsIHkgPSB0aGlzLnltYXg7IGJyZWFrOyAvLyByaWdodFxuICAgICAgICBjYXNlIDBiMTAxMDogZTAgPSAwYjEwMDA7IGNvbnRpbnVlOyAvLyBib3R0b20tcmlnaHRcbiAgICAgICAgY2FzZSAwYjEwMDA6IGUwID0gMGIxMDAxLCB4ID0gdGhpcy54bWluLCB5ID0gdGhpcy55bWF4OyBicmVhazsgLy8gYm90dG9tXG4gICAgICAgIGNhc2UgMGIxMDAxOiBlMCA9IDBiMDAwMTsgY29udGludWU7IC8vIGJvdHRvbS1sZWZ0XG4gICAgICAgIGNhc2UgMGIwMDAxOiBlMCA9IDBiMDEwMSwgeCA9IHRoaXMueG1pbiwgeSA9IHRoaXMueW1pbjsgYnJlYWs7IC8vIGxlZnRcbiAgICAgIH1cbiAgICAgIGlmICgoUFtqXSAhPT0geCB8fCBQW2ogKyAxXSAhPT0geSkgJiYgdGhpcy5jb250YWlucyhpLCB4LCB5KSkge1xuICAgICAgICBQLnNwbGljZShqLCAwLCB4LCB5KSwgaiArPSAyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoUC5sZW5ndGggPiA0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFAubGVuZ3RoOyBpKz0gMikge1xuICAgICAgICBjb25zdCBqID0gKGkgKyAyKSAlIFAubGVuZ3RoLCBrID0gKGkgKyA0KSAlIFAubGVuZ3RoO1xuICAgICAgICBpZiAoUFtpXSA9PT0gUFtqXSAmJiBQW2pdID09PSBQW2tdXG4gICAgICAgIHx8IFBbaSArIDFdID09PSBQW2ogKyAxXSAmJiBQW2ogKyAxXSA9PT0gUFtrICsgMV0pXG4gICAgICAgICAgUC5zcGxpY2UoaiwgMiksIGkgLT0gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGo7XG4gIH1cbiAgX3Byb2plY3QoeDAsIHkwLCB2eCwgdnkpIHtcbiAgICBsZXQgdCA9IEluZmluaXR5LCBjLCB4LCB5O1xuICAgIGlmICh2eSA8IDApIHsgLy8gdG9wXG4gICAgICBpZiAoeTAgPD0gdGhpcy55bWluKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICgoYyA9ICh0aGlzLnltaW4gLSB5MCkgLyB2eSkgPCB0KSB5ID0gdGhpcy55bWluLCB4ID0geDAgKyAodCA9IGMpICogdng7XG4gICAgfSBlbHNlIGlmICh2eSA+IDApIHsgLy8gYm90dG9tXG4gICAgICBpZiAoeTAgPj0gdGhpcy55bWF4KSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICgoYyA9ICh0aGlzLnltYXggLSB5MCkgLyB2eSkgPCB0KSB5ID0gdGhpcy55bWF4LCB4ID0geDAgKyAodCA9IGMpICogdng7XG4gICAgfVxuICAgIGlmICh2eCA+IDApIHsgLy8gcmlnaHRcbiAgICAgIGlmICh4MCA+PSB0aGlzLnhtYXgpIHJldHVybiBudWxsO1xuICAgICAgaWYgKChjID0gKHRoaXMueG1heCAtIHgwKSAvIHZ4KSA8IHQpIHggPSB0aGlzLnhtYXgsIHkgPSB5MCArICh0ID0gYykgKiB2eTtcbiAgICB9IGVsc2UgaWYgKHZ4IDwgMCkgeyAvLyBsZWZ0XG4gICAgICBpZiAoeDAgPD0gdGhpcy54bWluKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICgoYyA9ICh0aGlzLnhtaW4gLSB4MCkgLyB2eCkgPCB0KSB4ID0gdGhpcy54bWluLCB5ID0geTAgKyAodCA9IGMpICogdnk7XG4gICAgfVxuICAgIHJldHVybiBbeCwgeV07XG4gIH1cbiAgX2VkZ2Vjb2RlKHgsIHkpIHtcbiAgICByZXR1cm4gKHggPT09IHRoaXMueG1pbiA/IDBiMDAwMVxuICAgICAgICA6IHggPT09IHRoaXMueG1heCA/IDBiMDAxMCA6IDBiMDAwMClcbiAgICAgICAgfCAoeSA9PT0gdGhpcy55bWluID8gMGIwMTAwXG4gICAgICAgIDogeSA9PT0gdGhpcy55bWF4ID8gMGIxMDAwIDogMGIwMDAwKTtcbiAgfVxuICBfcmVnaW9uY29kZSh4LCB5KSB7XG4gICAgcmV0dXJuICh4IDwgdGhpcy54bWluID8gMGIwMDAxXG4gICAgICAgIDogeCA+IHRoaXMueG1heCA/IDBiMDAxMCA6IDBiMDAwMClcbiAgICAgICAgfCAoeSA8IHRoaXMueW1pbiA/IDBiMDEwMFxuICAgICAgICA6IHkgPiB0aGlzLnltYXggPyAwYjEwMDAgOiAwYjAwMDApO1xuICB9XG59XG4iLCJ2YXIgbm9vcCA9IHt2YWx1ZTogKCkgPT4ge319O1xuXG5mdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBfID0ge30sIHQ7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoISh0ID0gYXJndW1lbnRzW2ldICsgXCJcIikgfHwgKHQgaW4gXykgfHwgL1tcXHMuXS8udGVzdCh0KSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xufVxuXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gIHRoaXMuXyA9IF87XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgdCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkaXNwYXRjaDtcbiIsInZhciBFT0wgPSB7fSxcbiAgICBFT0YgPSB7fSxcbiAgICBRVU9URSA9IDM0LFxuICAgIE5FV0xJTkUgPSAxMCxcbiAgICBSRVRVUk4gPSAxMztcblxuZnVuY3Rpb24gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpIHtcbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImRcIiwgXCJyZXR1cm4ge1wiICsgY29sdW1ucy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXSB8fCBcXFwiXFxcIlwiO1xuICB9KS5qb2luKFwiLFwiKSArIFwifVwiKTtcbn1cblxuZnVuY3Rpb24gY3VzdG9tQ29udmVydGVyKGNvbHVtbnMsIGYpIHtcbiAgdmFyIG9iamVjdCA9IG9iamVjdENvbnZlcnRlcihjb2x1bW5zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgIHJldHVybiBmKG9iamVjdChyb3cpLCBpLCBjb2x1bW5zKTtcbiAgfTtcbn1cblxuLy8gQ29tcHV0ZSB1bmlxdWUgY29sdW1ucyBpbiBvcmRlciBvZiBkaXNjb3ZlcnkuXG5mdW5jdGlvbiBpbmZlckNvbHVtbnMocm93cykge1xuICB2YXIgY29sdW1uU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGNvbHVtbnMgPSBbXTtcblxuICByb3dzLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgZm9yICh2YXIgY29sdW1uIGluIHJvdykge1xuICAgICAgaWYgKCEoY29sdW1uIGluIGNvbHVtblNldCkpIHtcbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtblNldFtjb2x1bW5dID0gY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb2x1bW5zO1xufVxuXG5mdW5jdGlvbiBwYWQodmFsdWUsIHdpZHRoKSB7XG4gIHZhciBzID0gdmFsdWUgKyBcIlwiLCBsZW5ndGggPSBzLmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbigwKSArIHMgOiBzO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRZZWFyKHllYXIpIHtcbiAgcmV0dXJuIHllYXIgPCAwID8gXCItXCIgKyBwYWQoLXllYXIsIDYpXG4gICAgOiB5ZWFyID4gOTk5OSA/IFwiK1wiICsgcGFkKHllYXIsIDYpXG4gICAgOiBwYWQoeWVhciwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCksXG4gICAgICBtaW51dGVzID0gZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICBzZWNvbmRzID0gZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgICBtaWxsaXNlY29uZHMgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBcIkludmFsaWQgRGF0ZVwiXG4gICAgICA6IGZvcm1hdFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCA0KSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsIDIpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENEYXRlKCksIDIpXG4gICAgICArIChtaWxsaXNlY29uZHMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiOlwiICsgcGFkKHNlY29uZHMsIDIpICsgXCIuXCIgKyBwYWQobWlsbGlzZWNvbmRzLCAzKSArIFwiWlwiXG4gICAgICA6IHNlY29uZHMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiOlwiICsgcGFkKHNlY29uZHMsIDIpICsgXCJaXCJcbiAgICAgIDogbWludXRlcyB8fCBob3VycyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCJaXCJcbiAgICAgIDogXCJcIik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRlbGltaXRlcikge1xuICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKFwiW1xcXCJcIiArIGRlbGltaXRlciArIFwiXFxuXFxyXVwiKSxcbiAgICAgIERFTElNSVRFUiA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHRleHQsIGYpIHtcbiAgICB2YXIgY29udmVydCwgY29sdW1ucywgcm93cyA9IHBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgIGlmIChjb252ZXJ0KSByZXR1cm4gY29udmVydChyb3csIGkgLSAxKTtcbiAgICAgIGNvbHVtbnMgPSByb3csIGNvbnZlcnQgPSBmID8gY3VzdG9tQ29udmVydGVyKHJvdywgZikgOiBvYmplY3RDb252ZXJ0ZXIocm93KTtcbiAgICB9KTtcbiAgICByb3dzLmNvbHVtbnMgPSBjb2x1bW5zIHx8IFtdO1xuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSb3dzKHRleHQsIGYpIHtcbiAgICB2YXIgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICBOID0gdGV4dC5sZW5ndGgsXG4gICAgICAgIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICBuID0gMCwgLy8gY3VycmVudCBsaW5lIG51bWJlclxuICAgICAgICB0LCAvLyBjdXJyZW50IHRva2VuXG4gICAgICAgIGVvZiA9IE4gPD0gMCwgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0Y/XG4gICAgICAgIGVvbCA9IGZhbHNlOyAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPTD9cblxuICAgIC8vIFN0cmlwIHRoZSB0cmFpbGluZyBuZXdsaW5lLlxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBORVdMSU5FKSAtLU47XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IFJFVFVSTikgLS1OO1xuXG4gICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICBpZiAoZW9mKSByZXR1cm4gRU9GO1xuICAgICAgaWYgKGVvbCkgcmV0dXJuIGVvbCA9IGZhbHNlLCBFT0w7XG5cbiAgICAgIC8vIFVuZXNjYXBlIHF1b3Rlcy5cbiAgICAgIHZhciBpLCBqID0gSSwgYztcbiAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IFFVT1RFKSB7XG4gICAgICAgIHdoaWxlIChJKysgPCBOICYmIHRleHQuY2hhckNvZGVBdChJKSAhPT0gUVVPVEUgfHwgdGV4dC5jaGFyQ29kZUF0KCsrSSkgPT09IFFVT1RFKTtcbiAgICAgICAgaWYgKChpID0gSSkgPj0gTikgZW9mID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkgLSAxKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGRlbGltaXRlciBvciBuZXdsaW5lLlxuICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChpID0gSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gREVMSU1JVEVSKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBsYXN0IHRva2VuIGJlZm9yZSBFT0YuXG4gICAgICByZXR1cm4gZW9mID0gdHJ1ZSwgdGV4dC5zbGljZShqLCBOKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICB2YXIgcm93ID0gW107XG4gICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikgcm93LnB1c2godCksIHQgPSB0b2tlbigpO1xuICAgICAgaWYgKGYgJiYgKHJvdyA9IGYocm93LCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgIH1cblxuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2NvbHVtbl0pO1xuICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBbY29sdW1ucy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3dzKHJvd3MpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xuICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIlxuICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGZvcm1hdERhdGUodmFsdWUpXG4gICAgICAgIDogcmVGb3JtYXQudGVzdCh2YWx1ZSArPSBcIlwiKSA/IFwiXFxcIlwiICsgdmFsdWUucmVwbGFjZSgvXCIvZywgXCJcXFwiXFxcIlwiKSArIFwiXFxcIlwiXG4gICAgICAgIDogdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBwYXJzZVJvd3M6IHBhcnNlUm93cyxcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXRCb2R5OiBmb3JtYXRCb2R5LFxuICAgIGZvcm1hdFJvd3M6IGZvcm1hdFJvd3MsXG4gICAgZm9ybWF0Um93OiBmb3JtYXRSb3csXG4gICAgZm9ybWF0VmFsdWU6IGZvcm1hdFZhbHVlXG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBub2Rlcywgc3RyZW5ndGggPSAxO1xuXG4gIGlmICh4ID09IG51bGwpIHggPSAwO1xuICBpZiAoeSA9PSBudWxsKSB5ID0gMDtcblxuICBmdW5jdGlvbiBmb3JjZSgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgc3ggPSAwLFxuICAgICAgICBzeSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIHN4ICs9IG5vZGUueCwgc3kgKz0gbm9kZS55O1xuICAgIH1cblxuICAgIGZvciAoc3ggPSAoc3ggLyBuIC0geCkgKiBzdHJlbmd0aCwgc3kgPSAoc3kgLyBuIC0geSkgKiBzdHJlbmd0aCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54IC09IHN4LCBub2RlLnkgLT0gc3k7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gK18sIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSArXywgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IHtxdWFkdHJlZX0gZnJvbSBcImQzLXF1YWR0cmVlXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBqaWdnbGUgZnJvbSBcIi4vamlnZ2xlLmpzXCI7XG5cbmZ1bmN0aW9uIHgoZCkge1xuICByZXR1cm4gZC54ICsgZC52eDtcbn1cblxuZnVuY3Rpb24geShkKSB7XG4gIHJldHVybiBkLnkgKyBkLnZ5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYWRpdXMpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgcmFkaWksXG4gICAgICByYW5kb20sXG4gICAgICBzdHJlbmd0aCA9IDEsXG4gICAgICBpdGVyYXRpb25zID0gMTtcblxuICBpZiAodHlwZW9mIHJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSByYWRpdXMgPSBjb25zdGFudChyYWRpdXMgPT0gbnVsbCA/IDEgOiArcmFkaXVzKTtcblxuICBmdW5jdGlvbiBmb3JjZSgpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgeGksXG4gICAgICAgIHlpLFxuICAgICAgICByaSxcbiAgICAgICAgcmkyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIHRyZWUgPSBxdWFkdHJlZShub2RlcywgeCwgeSkudmlzaXRBZnRlcihwcmVwYXJlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICByaSA9IHJhZGlpW25vZGUuaW5kZXhdLCByaTIgPSByaSAqIHJpO1xuICAgICAgICB4aSA9IG5vZGUueCArIG5vZGUudng7XG4gICAgICAgIHlpID0gbm9kZS55ICsgbm9kZS52eTtcbiAgICAgICAgdHJlZS52aXNpdChhcHBseSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkocXVhZCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgIHZhciBkYXRhID0gcXVhZC5kYXRhLCByaiA9IHF1YWQuciwgciA9IHJpICsgcmo7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5pbmRleCA+IG5vZGUuaW5kZXgpIHtcbiAgICAgICAgICB2YXIgeCA9IHhpIC0gZGF0YS54IC0gZGF0YS52eCxcbiAgICAgICAgICAgICAgeSA9IHlpIC0gZGF0YS55IC0gZGF0YS52eSxcbiAgICAgICAgICAgICAgbCA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgICAgaWYgKGwgPCByICogcikge1xuICAgICAgICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUocmFuZG9tKSwgbCArPSB4ICogeDtcbiAgICAgICAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geSAqIHk7XG4gICAgICAgICAgICBsID0gKHIgLSAobCA9IE1hdGguc3FydChsKSkpIC8gbCAqIHN0cmVuZ3RoO1xuICAgICAgICAgICAgbm9kZS52eCArPSAoeCAqPSBsKSAqIChyID0gKHJqICo9IHJqKSAvIChyaTIgKyByaikpO1xuICAgICAgICAgICAgbm9kZS52eSArPSAoeSAqPSBsKSAqIHI7XG4gICAgICAgICAgICBkYXRhLnZ4IC09IHggKiAociA9IDEgLSByKTtcbiAgICAgICAgICAgIGRhdGEudnkgLT0geSAqIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4MCA+IHhpICsgciB8fCB4MSA8IHhpIC0gciB8fCB5MCA+IHlpICsgciB8fCB5MSA8IHlpIC0gcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlKHF1YWQpIHtcbiAgICBpZiAocXVhZC5kYXRhKSByZXR1cm4gcXVhZC5yID0gcmFkaWlbcXVhZC5kYXRhLmluZGV4XTtcbiAgICBmb3IgKHZhciBpID0gcXVhZC5yID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKHF1YWRbaV0gJiYgcXVhZFtpXS5yID4gcXVhZC5yKSB7XG4gICAgICAgIHF1YWQuciA9IHF1YWRbaV0ucjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICByYWRpaSA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHJhZGlpW25vZGUuaW5kZXhdID0gK3JhZGl1cyhub2RlLCBpLCBub2Rlcyk7XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oX25vZGVzLCBfcmFuZG9tKSB7XG4gICAgbm9kZXMgPSBfbm9kZXM7XG4gICAgcmFuZG9tID0gX3JhbmRvbTtcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSArXywgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHJhZGl1cztcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhbmRvbSkge1xuICByZXR1cm4gKHJhbmRvbSgpIC0gMC41KSAqIDFlLTY7XG59XG4iLCIvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfY29uZ3J1ZW50aWFsX2dlbmVyYXRvciNQYXJhbWV0ZXJzX2luX2NvbW1vbl91c2VcbmNvbnN0IGEgPSAxNjY0NTI1O1xuY29uc3QgYyA9IDEwMTM5MDQyMjM7XG5jb25zdCBtID0gNDI5NDk2NzI5NjsgLy8gMl4zMlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgbGV0IHMgPSAxO1xuICByZXR1cm4gKCkgPT4gKHMgPSAoYSAqIHMgKyBjKSAlIG0pIC8gbTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGppZ2dsZSBmcm9tIFwiLi9qaWdnbGUuanNcIjtcblxuZnVuY3Rpb24gaW5kZXgoZCkge1xuICByZXR1cm4gZC5pbmRleDtcbn1cblxuZnVuY3Rpb24gZmluZChub2RlQnlJZCwgbm9kZUlkKSB7XG4gIHZhciBub2RlID0gbm9kZUJ5SWQuZ2V0KG5vZGVJZCk7XG4gIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKFwibm9kZSBub3QgZm91bmQ6IFwiICsgbm9kZUlkKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGxpbmtzKSB7XG4gIHZhciBpZCA9IGluZGV4LFxuICAgICAgc3RyZW5ndGggPSBkZWZhdWx0U3RyZW5ndGgsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICBkaXN0YW5jZSA9IGNvbnN0YW50KDMwKSxcbiAgICAgIGRpc3RhbmNlcyxcbiAgICAgIG5vZGVzLFxuICAgICAgY291bnQsXG4gICAgICBiaWFzLFxuICAgICAgcmFuZG9tLFxuICAgICAgaXRlcmF0aW9ucyA9IDE7XG5cbiAgaWYgKGxpbmtzID09IG51bGwpIGxpbmtzID0gW107XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFN0cmVuZ3RoKGxpbmspIHtcbiAgICByZXR1cm4gMSAvIE1hdGgubWluKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSwgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgayA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaW5rLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgbCwgYjsgaSA8IG47ICsraSkge1xuICAgICAgICBsaW5rID0gbGlua3NbaV0sIHNvdXJjZSA9IGxpbmsuc291cmNlLCB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgeCA9IHRhcmdldC54ICsgdGFyZ2V0LnZ4IC0gc291cmNlLnggLSBzb3VyY2UudnggfHwgamlnZ2xlKHJhbmRvbSk7XG4gICAgICAgIHkgPSB0YXJnZXQueSArIHRhcmdldC52eSAtIHNvdXJjZS55IC0gc291cmNlLnZ5IHx8IGppZ2dsZShyYW5kb20pO1xuICAgICAgICBsID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICBsID0gKGwgLSBkaXN0YW5jZXNbaV0pIC8gbCAqIGFscGhhICogc3RyZW5ndGhzW2ldO1xuICAgICAgICB4ICo9IGwsIHkgKj0gbDtcbiAgICAgICAgdGFyZ2V0LnZ4IC09IHggKiAoYiA9IGJpYXNbaV0pO1xuICAgICAgICB0YXJnZXQudnkgLT0geSAqIGI7XG4gICAgICAgIHNvdXJjZS52eCArPSB4ICogKGIgPSAxIC0gYik7XG4gICAgICAgIHNvdXJjZS52eSArPSB5ICogYjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBtID0gbGlua3MubGVuZ3RoLFxuICAgICAgICBub2RlQnlJZCA9IG5ldyBNYXAobm9kZXMubWFwKChkLCBpKSA9PiBbaWQoZCwgaSwgbm9kZXMpLCBkXSkpLFxuICAgICAgICBsaW5rO1xuXG4gICAgZm9yIChpID0gMCwgY291bnQgPSBuZXcgQXJyYXkobik7IGkgPCBtOyArK2kpIHtcbiAgICAgIGxpbmsgPSBsaW5rc1tpXSwgbGluay5pbmRleCA9IGk7XG4gICAgICBpZiAodHlwZW9mIGxpbmsuc291cmNlICE9PSBcIm9iamVjdFwiKSBsaW5rLnNvdXJjZSA9IGZpbmQobm9kZUJ5SWQsIGxpbmsuc291cmNlKTtcbiAgICAgIGlmICh0eXBlb2YgbGluay50YXJnZXQgIT09IFwib2JqZWN0XCIpIGxpbmsudGFyZ2V0ID0gZmluZChub2RlQnlJZCwgbGluay50YXJnZXQpO1xuICAgICAgY291bnRbbGluay5zb3VyY2UuaW5kZXhdID0gKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSB8fCAwKSArIDE7XG4gICAgICBjb3VudFtsaW5rLnRhcmdldC5pbmRleF0gPSAoY291bnRbbGluay50YXJnZXQuaW5kZXhdIHx8IDApICsgMTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBiaWFzID0gbmV3IEFycmF5KG0pOyBpIDwgbTsgKytpKSB7XG4gICAgICBsaW5rID0gbGlua3NbaV0sIGJpYXNbaV0gPSBjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gLyAoY291bnRbbGluay5zb3VyY2UuaW5kZXhdICsgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcbiAgICB9XG5cbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobSksIGluaXRpYWxpemVTdHJlbmd0aCgpO1xuICAgIGRpc3RhbmNlcyA9IG5ldyBBcnJheShtKSwgaW5pdGlhbGl6ZURpc3RhbmNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplU3RyZW5ndGgoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9ICtzdHJlbmd0aChsaW5rc1tpXSwgaSwgbGlua3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVEaXN0YW5jZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgZGlzdGFuY2VzW2ldID0gK2Rpc3RhbmNlKGxpbmtzW2ldLCBpLCBsaW5rcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF9ub2RlcywgX3JhbmRvbSkge1xuICAgIG5vZGVzID0gX25vZGVzO1xuICAgIHJhbmRvbSA9IF9yYW5kb207XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLmxpbmtzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGxpbmtzID0gXywgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBsaW5rcztcbiAgfTtcblxuICBmb3JjZS5pZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpZCA9IF8sIGZvcmNlKSA6IGlkO1xuICB9O1xuXG4gIGZvcmNlLml0ZXJhdGlvbnMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaXRlcmF0aW9ucyA9ICtfLCBmb3JjZSkgOiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemVTdHJlbmd0aCgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkaXN0YW5jZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplRGlzdGFuY2UoKSwgZm9yY2UpIDogZGlzdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IHtxdWFkdHJlZX0gZnJvbSBcImQzLXF1YWR0cmVlXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBqaWdnbGUgZnJvbSBcIi4vamlnZ2xlLmpzXCI7XG5pbXBvcnQge3gsIHl9IGZyb20gXCIuL3NpbXVsYXRpb24uanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlcyxcbiAgICAgIG5vZGUsXG4gICAgICByYW5kb20sXG4gICAgICBhbHBoYSxcbiAgICAgIHN0cmVuZ3RoID0gY29uc3RhbnQoLTMwKSxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIGRpc3RhbmNlTWluMiA9IDEsXG4gICAgICBkaXN0YW5jZU1heDIgPSBJbmZpbml0eSxcbiAgICAgIHRoZXRhMiA9IDAuODE7XG5cbiAgZnVuY3Rpb24gZm9yY2UoXykge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCB0cmVlID0gcXVhZHRyZWUobm9kZXMsIHgsIHkpLnZpc2l0QWZ0ZXIoYWNjdW11bGF0ZSk7XG4gICAgZm9yIChhbHBoYSA9IF8sIGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHRyZWUudmlzaXQoYXBwbHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgc3RyZW5ndGhzW25vZGUuaW5kZXhdID0gK3N0cmVuZ3RoKG5vZGUsIGksIG5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY3VtdWxhdGUocXVhZCkge1xuICAgIHZhciBzdHJlbmd0aCA9IDAsIHEsIGMsIHdlaWdodCA9IDAsIHgsIHksIGk7XG5cbiAgICAvLyBGb3IgaW50ZXJuYWwgbm9kZXMsIGFjY3VtdWxhdGUgZm9yY2VzIGZyb20gY2hpbGQgcXVhZHJhbnRzLlxuICAgIGlmIChxdWFkLmxlbmd0aCkge1xuICAgICAgZm9yICh4ID0geSA9IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgIGlmICgocSA9IHF1YWRbaV0pICYmIChjID0gTWF0aC5hYnMocS52YWx1ZSkpKSB7XG4gICAgICAgICAgc3RyZW5ndGggKz0gcS52YWx1ZSwgd2VpZ2h0ICs9IGMsIHggKz0gYyAqIHEueCwgeSArPSBjICogcS55O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWFkLnggPSB4IC8gd2VpZ2h0O1xuICAgICAgcXVhZC55ID0geSAvIHdlaWdodDtcbiAgICB9XG5cbiAgICAvLyBGb3IgbGVhZiBub2RlcywgYWNjdW11bGF0ZSBmb3JjZXMgZnJvbSBjb2luY2lkZW50IHF1YWRyYW50cy5cbiAgICBlbHNlIHtcbiAgICAgIHEgPSBxdWFkO1xuICAgICAgcS54ID0gcS5kYXRhLng7XG4gICAgICBxLnkgPSBxLmRhdGEueTtcbiAgICAgIGRvIHN0cmVuZ3RoICs9IHN0cmVuZ3Roc1txLmRhdGEuaW5kZXhdO1xuICAgICAgd2hpbGUgKHEgPSBxLm5leHQpO1xuICAgIH1cblxuICAgIHF1YWQudmFsdWUgPSBzdHJlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5KHF1YWQsIHgxLCBfLCB4Mikge1xuICAgIGlmICghcXVhZC52YWx1ZSkgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgeCA9IHF1YWQueCAtIG5vZGUueCxcbiAgICAgICAgeSA9IHF1YWQueSAtIG5vZGUueSxcbiAgICAgICAgdyA9IHgyIC0geDEsXG4gICAgICAgIGwgPSB4ICogeCArIHkgKiB5O1xuXG4gICAgLy8gQXBwbHkgdGhlIEJhcm5lcy1IdXQgYXBwcm94aW1hdGlvbiBpZiBwb3NzaWJsZS5cbiAgICAvLyBMaW1pdCBmb3JjZXMgZm9yIHZlcnkgY2xvc2Ugbm9kZXM7IHJhbmRvbWl6ZSBkaXJlY3Rpb24gaWYgY29pbmNpZGVudC5cbiAgICBpZiAodyAqIHcgLyB0aGV0YTIgPCBsKSB7XG4gICAgICBpZiAobCA8IGRpc3RhbmNlTWF4Mikge1xuICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZShyYW5kb20pLCBsICs9IHggKiB4O1xuICAgICAgICBpZiAoeSA9PT0gMCkgeSA9IGppZ2dsZShyYW5kb20pLCBsICs9IHkgKiB5O1xuICAgICAgICBpZiAobCA8IGRpc3RhbmNlTWluMikgbCA9IE1hdGguc3FydChkaXN0YW5jZU1pbjIgKiBsKTtcbiAgICAgICAgbm9kZS52eCArPSB4ICogcXVhZC52YWx1ZSAqIGFscGhhIC8gbDtcbiAgICAgICAgbm9kZS52eSArPSB5ICogcXVhZC52YWx1ZSAqIGFscGhhIC8gbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBwb2ludHMgZGlyZWN0bHkuXG4gICAgZWxzZSBpZiAocXVhZC5sZW5ndGggfHwgbCA+PSBkaXN0YW5jZU1heDIpIHJldHVybjtcblxuICAgIC8vIExpbWl0IGZvcmNlcyBmb3IgdmVyeSBjbG9zZSBub2RlczsgcmFuZG9taXplIGRpcmVjdGlvbiBpZiBjb2luY2lkZW50LlxuICAgIGlmIChxdWFkLmRhdGEgIT09IG5vZGUgfHwgcXVhZC5uZXh0KSB7XG4gICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZShyYW5kb20pLCBsICs9IHggKiB4O1xuICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUocmFuZG9tKSwgbCArPSB5ICogeTtcbiAgICAgIGlmIChsIDwgZGlzdGFuY2VNaW4yKSBsID0gTWF0aC5zcXJ0KGRpc3RhbmNlTWluMiAqIGwpO1xuICAgIH1cblxuICAgIGRvIGlmIChxdWFkLmRhdGEgIT09IG5vZGUpIHtcbiAgICAgIHcgPSBzdHJlbmd0aHNbcXVhZC5kYXRhLmluZGV4XSAqIGFscGhhIC8gbDtcbiAgICAgIG5vZGUudnggKz0geCAqIHc7XG4gICAgICBub2RlLnZ5ICs9IHkgKiB3O1xuICAgIH0gd2hpbGUgKHF1YWQgPSBxdWFkLm5leHQpO1xuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF9ub2RlcywgX3JhbmRvbSkge1xuICAgIG5vZGVzID0gX25vZGVzO1xuICAgIHJhbmRvbSA9IF9yYW5kb207XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2VNaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2VNaW4yID0gXyAqIF8sIGZvcmNlKSA6IE1hdGguc3FydChkaXN0YW5jZU1pbjIpO1xuICB9O1xuXG4gIGZvcmNlLmRpc3RhbmNlTWF4ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlTWF4MiA9IF8gKiBfLCBmb3JjZSkgOiBNYXRoLnNxcnQoZGlzdGFuY2VNYXgyKTtcbiAgfTtcblxuICBmb3JjZS50aGV0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGV0YTIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KHRoZXRhMik7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3RpbWVyfSBmcm9tIFwiZDMtdGltZXJcIjtcbmltcG9ydCBsY2cgZnJvbSBcIi4vbGNnLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkoZCkge1xuICByZXR1cm4gZC55O1xufVxuXG52YXIgaW5pdGlhbFJhZGl1cyA9IDEwLFxuICAgIGluaXRpYWxBbmdsZSA9IE1hdGguUEkgKiAoMyAtIE1hdGguc3FydCg1KSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGVzKSB7XG4gIHZhciBzaW11bGF0aW9uLFxuICAgICAgYWxwaGEgPSAxLFxuICAgICAgYWxwaGFNaW4gPSAwLjAwMSxcbiAgICAgIGFscGhhRGVjYXkgPSAxIC0gTWF0aC5wb3coYWxwaGFNaW4sIDEgLyAzMDApLFxuICAgICAgYWxwaGFUYXJnZXQgPSAwLFxuICAgICAgdmVsb2NpdHlEZWNheSA9IDAuNixcbiAgICAgIGZvcmNlcyA9IG5ldyBNYXAoKSxcbiAgICAgIHN0ZXBwZXIgPSB0aW1lcihzdGVwKSxcbiAgICAgIGV2ZW50ID0gZGlzcGF0Y2goXCJ0aWNrXCIsIFwiZW5kXCIpLFxuICAgICAgcmFuZG9tID0gbGNnKCk7XG5cbiAgaWYgKG5vZGVzID09IG51bGwpIG5vZGVzID0gW107XG5cbiAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICB0aWNrKCk7XG4gICAgZXZlbnQuY2FsbChcInRpY2tcIiwgc2ltdWxhdGlvbik7XG4gICAgaWYgKGFscGhhIDwgYWxwaGFNaW4pIHtcbiAgICAgIHN0ZXBwZXIuc3RvcCgpO1xuICAgICAgZXZlbnQuY2FsbChcImVuZFwiLCBzaW11bGF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGl0ZXJhdGlvbnMpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcblxuICAgIGlmIChpdGVyYXRpb25zID09PSB1bmRlZmluZWQpIGl0ZXJhdGlvbnMgPSAxO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGFscGhhICs9IChhbHBoYVRhcmdldCAtIGFscGhhKSAqIGFscGhhRGVjYXk7XG5cbiAgICAgIGZvcmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIGZvcmNlKGFscGhhKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuZnggPT0gbnVsbCkgbm9kZS54ICs9IG5vZGUudnggKj0gdmVsb2NpdHlEZWNheTtcbiAgICAgICAgZWxzZSBub2RlLnggPSBub2RlLmZ4LCBub2RlLnZ4ID0gMDtcbiAgICAgICAgaWYgKG5vZGUuZnkgPT0gbnVsbCkgbm9kZS55ICs9IG5vZGUudnkgKj0gdmVsb2NpdHlEZWNheTtcbiAgICAgICAgZWxzZSBub2RlLnkgPSBub2RlLmZ5LCBub2RlLnZ5ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2ltdWxhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVOb2RlcygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLmluZGV4ID0gaTtcbiAgICAgIGlmIChub2RlLmZ4ICE9IG51bGwpIG5vZGUueCA9IG5vZGUuZng7XG4gICAgICBpZiAobm9kZS5meSAhPSBudWxsKSBub2RlLnkgPSBub2RlLmZ5O1xuICAgICAgaWYgKGlzTmFOKG5vZGUueCkgfHwgaXNOYU4obm9kZS55KSkge1xuICAgICAgICB2YXIgcmFkaXVzID0gaW5pdGlhbFJhZGl1cyAqIE1hdGguc3FydCgwLjUgKyBpKSwgYW5nbGUgPSBpICogaW5pdGlhbEFuZ2xlO1xuICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hTihub2RlLnZ4KSB8fCBpc05hTihub2RlLnZ5KSkge1xuICAgICAgICBub2RlLnZ4ID0gbm9kZS52eSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZUZvcmNlKGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlLmluaXRpYWxpemUpIGZvcmNlLmluaXRpYWxpemUobm9kZXMsIHJhbmRvbSk7XG4gICAgcmV0dXJuIGZvcmNlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZU5vZGVzKCk7XG5cbiAgcmV0dXJuIHNpbXVsYXRpb24gPSB7XG4gICAgdGljazogdGljayxcblxuICAgIHJlc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0ZXBwZXIucmVzdGFydChzdGVwKSwgc2ltdWxhdGlvbjtcbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcHBlci5zdG9wKCksIHNpbXVsYXRpb247XG4gICAgfSxcblxuICAgIG5vZGVzOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlcyA9IF8sIGluaXRpYWxpemVOb2RlcygpLCBmb3JjZXMuZm9yRWFjaChpbml0aWFsaXplRm9yY2UpLCBzaW11bGF0aW9uKSA6IG5vZGVzO1xuICAgIH0sXG5cbiAgICBhbHBoYTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYTtcbiAgICB9LFxuXG4gICAgYWxwaGFNaW46IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhTWluID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGFNaW47XG4gICAgfSxcblxuICAgIGFscGhhRGVjYXk6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhRGVjYXkgPSArXywgc2ltdWxhdGlvbikgOiArYWxwaGFEZWNheTtcbiAgICB9LFxuXG4gICAgYWxwaGFUYXJnZXQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhVGFyZ2V0ID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGFUYXJnZXQ7XG4gICAgfSxcblxuICAgIHZlbG9jaXR5RGVjYXk6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZlbG9jaXR5RGVjYXkgPSAxIC0gXywgc2ltdWxhdGlvbikgOiAxIC0gdmVsb2NpdHlEZWNheTtcbiAgICB9LFxuXG4gICAgcmFuZG9tU291cmNlOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5kb20gPSBfLCBmb3JjZXMuZm9yRWFjaChpbml0aWFsaXplRm9yY2UpLCBzaW11bGF0aW9uKSA6IHJhbmRvbTtcbiAgICB9LFxuXG4gICAgZm9yY2U6IGZ1bmN0aW9uKG5hbWUsIF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICgoXyA9PSBudWxsID8gZm9yY2VzLmRlbGV0ZShuYW1lKSA6IGZvcmNlcy5zZXQobmFtZSwgaW5pdGlhbGl6ZUZvcmNlKF8pKSksIHNpbXVsYXRpb24pIDogZm9yY2VzLmdldChuYW1lKTtcbiAgICB9LFxuXG4gICAgZmluZDogZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeSxcbiAgICAgICAgICBkMixcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGNsb3Nlc3Q7XG5cbiAgICAgIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gICAgICBlbHNlIHJhZGl1cyAqPSByYWRpdXM7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBkeCA9IHggLSBub2RlLng7XG4gICAgICAgIGR5ID0geSAtIG5vZGUueTtcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgaWYgKGQyIDwgcmFkaXVzKSBjbG9zZXN0ID0gbm9kZSwgcmFkaXVzID0gZDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZXN0O1xuICAgIH0sXG5cbiAgICBvbjogZnVuY3Rpb24obmFtZSwgXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gKGV2ZW50Lm9uKG5hbWUsIF8pLCBzaW11bGF0aW9uKSA6IGV2ZW50Lm9uKG5hbWUpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBub2RlcyxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHh6O1xuXG4gIGlmICh0eXBlb2YgeCAhPT0gXCJmdW5jdGlvblwiKSB4ID0gY29uc3RhbnQoeCA9PSBudWxsID8gMCA6ICt4KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnggKz0gKHh6W2ldIC0gbm9kZS54KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB4eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih4eltpXSA9ICt4KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQoMC4xKSxcbiAgICAgIG5vZGVzLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgeXo7XG5cbiAgaWYgKHR5cGVvZiB5ICE9PSBcImZ1bmN0aW9uXCIpIHkgPSBjb25zdGFudCh5ID09IG51bGwgPyAwIDogK3kpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS52eSArPSAoeXpbaV0gLSBub2RlLnkpICogc3RyZW5ndGhzW2ldICogYWxwaGE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIHl6ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHl6W2ldID0gK3kobm9kZXNbaV0sIGksIG5vZGVzKSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogeTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJpbXBvcnQgZm9ybWF0TG9jYWxlIGZyb20gXCIuL2xvY2FsZS5qc1wiO1xuXG52YXIgbG9jYWxlO1xuZXhwb3J0IHZhciBmb3JtYXQ7XG5leHBvcnQgdmFyIGZvcm1hdFByZWZpeDtcblxuZGVmYXVsdExvY2FsZSh7XG4gIHRob3VzYW5kczogXCIsXCIsXG4gIGdyb3VwaW5nOiBbM10sXG4gIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZm9ybWF0UHJlZml4ID0gbG9jYWxlLmZvcm1hdFByZWZpeDtcbiAgcmV0dXJuIGxvY2FsZTtcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsUGFydHMoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggPSBNYXRoLnJvdW5kKHgpKSA+PSAxZTIxXG4gICAgICA/IHgudG9Mb2NhbGVTdHJpbmcoXCJlblwiKS5yZXBsYWNlKC8sL2csIFwiXCIpXG4gICAgICA6IHgudG9TdHJpbmcoMTApO1xufVxuXG4vLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4vLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbi8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsUGFydHMoMS4yMykgcmV0dXJucyBbXCIxMjNcIiwgMF0uXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApIHtcbiAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XG4gIHZhciBpLCBjb2VmZmljaWVudCA9IHguc2xpY2UoMCwgaSk7XG5cbiAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xuICAvLyAoZS5nLiwgMS4yZSszKSBvciB0aGUgZm9ybSBcXGRlWy0rXVxcZCsgKGUuZy4sIDFlKzMpLlxuICByZXR1cm4gW1xuICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXG4gICAgK3guc2xpY2UoaSArIDEpXG4gIF07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihncm91cGluZywgdGhvdXNhbmRzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgdCA9IFtdLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obnVtZXJhbHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBudW1lcmFsc1sraV07XG4gICAgfSk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Zvcm1hdERlY2ltYWxQYXJ0c30gZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuXG5leHBvcnQgdmFyIHByZWZpeEV4cG9uZW50O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbFBhcnRzKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsUGFydHMoeCwgTWF0aC5tYXgoMCwgcCArIGkgLSAxKSlbMF07IC8vIGxlc3MgdGhhbiAxeSFcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG59XG4iLCIvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW35dW3R5cGVdXG52YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyh+KT8oW2EteiVdKT8kL2k7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuICB2YXIgbWF0Y2g7XG4gIHJldHVybiBuZXcgRm9ybWF0U3BlY2lmaWVyKHtcbiAgICBmaWxsOiBtYXRjaFsxXSxcbiAgICBhbGlnbjogbWF0Y2hbMl0sXG4gICAgc2lnbjogbWF0Y2hbM10sXG4gICAgc3ltYm9sOiBtYXRjaFs0XSxcbiAgICB6ZXJvOiBtYXRjaFs1XSxcbiAgICB3aWR0aDogbWF0Y2hbNl0sXG4gICAgY29tbWE6IG1hdGNoWzddLFxuICAgIHByZWNpc2lvbjogbWF0Y2hbOF0gJiYgbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgdHJpbTogbWF0Y2hbOV0sXG4gICAgdHlwZTogbWF0Y2hbMTBdXG4gIH0pO1xufVxuXG5mb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlID0gRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZTsgLy8gaW5zdGFuY2VvZlxuXG5leHBvcnQgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICB0aGlzLmZpbGwgPSBzcGVjaWZpZXIuZmlsbCA9PT0gdW5kZWZpbmVkID8gXCIgXCIgOiBzcGVjaWZpZXIuZmlsbCArIFwiXCI7XG4gIHRoaXMuYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24gPT09IHVuZGVmaW5lZCA/IFwiPlwiIDogc3BlY2lmaWVyLmFsaWduICsgXCJcIjtcbiAgdGhpcy5zaWduID0gc3BlY2lmaWVyLnNpZ24gPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogc3BlY2lmaWVyLnNpZ24gKyBcIlwiO1xuICB0aGlzLnN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIuc3ltYm9sICsgXCJcIjtcbiAgdGhpcy56ZXJvID0gISFzcGVjaWZpZXIuemVybztcbiAgdGhpcy53aWR0aCA9IHNwZWNpZmllci53aWR0aCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci53aWR0aDtcbiAgdGhpcy5jb21tYSA9ICEhc3BlY2lmaWVyLmNvbW1hO1xuICB0aGlzLnByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIucHJlY2lzaW9uO1xuICB0aGlzLnRyaW0gPSAhIXNwZWNpZmllci50cmltO1xuICB0aGlzLnR5cGUgPSBzcGVjaWZpZXIudHlwZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci50eXBlICsgXCJcIjtcbn1cblxuRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWxsXG4gICAgICArIHRoaXMuYWxpZ25cbiAgICAgICsgdGhpcy5zaWduXG4gICAgICArIHRoaXMuc3ltYm9sXG4gICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgKyAodGhpcy50cmltID8gXCJ+XCIgOiBcIlwiKVxuICAgICAgKyB0aGlzLnR5cGU7XG59O1xuIiwiLy8gVHJpbXMgaW5zaWduaWZpY2FudCB6ZXJvcywgZS5nLiwgcmVwbGFjZXMgMS4yMDAwayB3aXRoIDEuMmsuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzKSB7XG4gIG91dDogZm9yICh2YXIgbiA9IHMubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKHNbaV0pIHtcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogaWYgKCErc1tpXSkgYnJlYWsgb3V0OyBpZiAoaTAgPiAwKSBpMCA9IDA7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTAgPiAwID8gcy5zbGljZSgwLCBpMCkgKyBzLnNsaWNlKGkxICsgMSkgOiBzO1xufVxuIiwiaW1wb3J0IGZvcm1hdERlY2ltYWwgZnJvbSBcIi4vZm9ybWF0RGVjaW1hbC5qc1wiO1xuaW1wb3J0IGZvcm1hdFByZWZpeEF1dG8gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGZvcm1hdFJvdW5kZWQgZnJvbSBcIi4vZm9ybWF0Um91bmRlZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFwiJVwiOiAoeCwgcCkgPT4gKHggKiAxMDApLnRvRml4ZWQocCksXG4gIFwiYlwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKSxcbiAgXCJjXCI6ICh4KSA9PiB4ICsgXCJcIixcbiAgXCJkXCI6IGZvcm1hdERlY2ltYWwsXG4gIFwiZVwiOiAoeCwgcCkgPT4geC50b0V4cG9uZW50aWFsKHApLFxuICBcImZcIjogKHgsIHApID0+IHgudG9GaXhlZChwKSxcbiAgXCJnXCI6ICh4LCBwKSA9PiB4LnRvUHJlY2lzaW9uKHApLFxuICBcIm9cIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCksXG4gIFwicFwiOiAoeCwgcCkgPT4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKSxcbiAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gIFwic1wiOiBmb3JtYXRQcmVmaXhBdXRvLFxuICBcIlhcIjogKHgpID0+IE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksXG4gIFwieFwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNilcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5pbXBvcnQgZm9ybWF0R3JvdXAgZnJvbSBcIi4vZm9ybWF0R3JvdXAuanNcIjtcbmltcG9ydCBmb3JtYXROdW1lcmFscyBmcm9tIFwiLi9mb3JtYXROdW1lcmFscy5qc1wiO1xuaW1wb3J0IGZvcm1hdFNwZWNpZmllciBmcm9tIFwiLi9mb3JtYXRTcGVjaWZpZXIuanNcIjtcbmltcG9ydCBmb3JtYXRUcmltIGZyb20gXCIuL2Zvcm1hdFRyaW0uanNcIjtcbmltcG9ydCBmb3JtYXRUeXBlcyBmcm9tIFwiLi9mb3JtYXRUeXBlcy5qc1wiO1xuaW1wb3J0IHtwcmVmaXhFeHBvbmVudH0gZnJvbSBcIi4vZm9ybWF0UHJlZml4QXV0by5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5LmpzXCI7XG5cbnZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLFxuICAgIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obG9jYWxlKSB7XG4gIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyA9PT0gdW5kZWZpbmVkIHx8IGxvY2FsZS50aG91c2FuZHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0R3JvdXAobWFwLmNhbGwobG9jYWxlLmdyb3VwaW5nLCBOdW1iZXIpLCBsb2NhbGUudGhvdXNhbmRzICsgXCJcIiksXG4gICAgICBjdXJyZW5jeVByZWZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVswXSArIFwiXCIsXG4gICAgICBjdXJyZW5jeVN1ZmZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVsxXSArIFwiXCIsXG4gICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwgPT09IHVuZGVmaW5lZCA/IFwiLlwiIDogbG9jYWxlLmRlY2ltYWwgKyBcIlwiLFxuICAgICAgbnVtZXJhbHMgPSBsb2NhbGUubnVtZXJhbHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0TnVtZXJhbHMobWFwLmNhbGwobG9jYWxlLm51bWVyYWxzLCBTdHJpbmcpKSxcbiAgICAgIHBlcmNlbnQgPSBsb2NhbGUucGVyY2VudCA9PT0gdW5kZWZpbmVkID8gXCIlXCIgOiBsb2NhbGUucGVyY2VudCArIFwiXCIsXG4gICAgICBtaW51cyA9IGxvY2FsZS5taW51cyA9PT0gdW5kZWZpbmVkID8gXCLiiJJcIiA6IGxvY2FsZS5taW51cyArIFwiXCIsXG4gICAgICBuYW4gPSBsb2NhbGUubmFuID09PSB1bmRlZmluZWQgPyBcIk5hTlwiIDogbG9jYWxlLm5hbiArIFwiXCI7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllcikge1xuICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuXG4gICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgIHNpZ24gPSBzcGVjaWZpZXIuc2lnbixcbiAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICB3aWR0aCA9IHNwZWNpZmllci53aWR0aCxcbiAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgIHRyaW0gPSBzcGVjaWZpZXIudHJpbSxcbiAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gVGhlIFwiXCIgdHlwZSwgYW5kIGFueSBpbnZhbGlkIHR5cGUsIGlzIGFuIGFsaWFzIGZvciBcIi4xMn5nXCIuXG4gICAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCAmJiAocHJlY2lzaW9uID0gMTIpLCB0cmltID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5UHJlZml4IDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lTdWZmaXggOiAvWyVwXS8udGVzdCh0eXBlKSA/IHBlcmNlbnQgOiBcIlwiO1xuXG4gICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgIG1heWJlU3VmZml4ID0gL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNlxuICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeCxcbiAgICAgICAgICBpLCBuLCBjO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpZ24uIC0wIGlzIG5vdCBsZXNzIHRoYW4gMCwgYnV0IDEgLyAtMCBpcyFcbiAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSB2YWx1ZSA8IDAgfHwgMSAvIHZhbHVlIDwgMDtcblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgIHZhbHVlID0gaXNOYU4odmFsdWUpID8gbmFuIDogZm9ybWF0VHlwZShNYXRoLmFicyh2YWx1ZSksIHByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gVHJpbSBpbnNpZ25pZmljYW50IHplcm9zLlxuICAgICAgICBpZiAodHJpbSkgdmFsdWUgPSBmb3JtYXRUcmltKHZhbHVlKTtcblxuICAgICAgICAvLyBJZiBhIG5lZ2F0aXZlIHZhbHVlIHJvdW5kcyB0byB6ZXJvIGFmdGVyIGZvcm1hdHRpbmcsIGFuZCBubyBleHBsaWNpdCBwb3NpdGl2ZSBzaWduIGlzIHJlcXVlc3RlZCwgaGlkZSB0aGUgc2lnbi5cbiAgICAgICAgaWYgKHZhbHVlTmVnYXRpdmUgJiYgK3ZhbHVlID09PSAwICYmIHNpZ24gIT09IFwiK1wiKSB2YWx1ZU5lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogbWludXMpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgdmFsdWVTdWZmaXggPSAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgdmFsdWVTdWZmaXggKyAodmFsdWVOZWdhdGl2ZSAmJiBzaWduID09PSBcIihcIiA/IFwiKVwiIDogXCJcIik7XG5cbiAgICAgICAgLy8gQnJlYWsgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBpbnRlZ2VyIOKAnHZhbHVl4oCdIHBhcnQgdGhhdCBjYW4gYmVcbiAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgIGlmIChtYXliZVN1ZmZpeCkge1xuICAgICAgICAgIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gKGMgPT09IDQ2ID8gZGVjaW1hbCArIHZhbHVlLnNsaWNlKGkgKyAxKSA6IHZhbHVlLnNsaWNlKGkpKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIG5vdCBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBiZWZvcmUgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwYWRkaW5nLlxuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlUHJlZml4Lmxlbmd0aCArIHZhbHVlLmxlbmd0aCArIHZhbHVlU3VmZml4Lmxlbmd0aCxcbiAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGFmdGVyIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgemVybykgdmFsdWUgPSBncm91cChwYWRkaW5nICsgdmFsdWUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSB2YWx1ZVN1ZmZpeC5sZW5ndGggOiBJbmZpbml0eSksIHBhZGRpbmcgPSBcIlwiO1xuXG4gICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSBcIjxcIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nOyBicmVhaztcbiAgICAgICAgY2FzZSBcIj1cIjogdmFsdWUgPSB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgICAgY2FzZSBcIl5cIjogdmFsdWUgPSBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdmFsdWUgPSBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4OyBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bWVyYWxzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3JtYXQudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzcGVjaWZpZXIgKyBcIlwiO1xuICAgIH07XG5cbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpIHtcbiAgICB2YXIgZiA9IG5ld0Zvcm1hdCgoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciksIHNwZWNpZmllci50eXBlID0gXCJmXCIsIHNwZWNpZmllcikpLFxuICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxuICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1s4ICsgZSAvIDNdO1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IG5ld0Zvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICB9O1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0ZXApIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xufVxuIiwiaW1wb3J0IGV4cG9uZW50IGZyb20gXCIuL2V4cG9uZW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0ZXAsIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RlcCwgbWF4KSB7XG4gIHN0ZXAgPSBNYXRoLmFicyhzdGVwKSwgbWF4ID0gTWF0aC5hYnMobWF4KSAtIHN0ZXA7XG4gIHJldHVybiBNYXRoLm1heCgwLCBleHBvbmVudChtYXgpIC0gZXhwb25lbnQoc3RlcCkpICsgMTtcbn1cbiIsImV4cG9ydCB2YXIgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgdmFyIGF0YW4gPSBNYXRoLmF0YW47XG5leHBvcnQgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbmV4cG9ydCB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbmV4cG9ydCB2YXIgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgdmFyIGV4cCA9IE1hdGguZXhwO1xuZXhwb3J0IHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5leHBvcnQgdmFyIGxvZyA9IE1hdGgubG9nO1xuZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHBvdyA9IE1hdGgucG93O1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5leHBvcnQgdmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7IH07XG5leHBvcnQgdmFyIHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IHZhciB0YW4gPSBNYXRoLnRhbjtcblxuZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtNjtcbmV4cG9ydCB2YXIgZXBzaWxvbjIgPSAxZS0xMjtcbmV4cG9ydCB2YXIgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IHZhciBoYWxmUGkgPSBwaSAvIDI7XG5leHBvcnQgdmFyIHF1YXJ0ZXJQaSA9IHBpIC8gNDtcbmV4cG9ydCB2YXIgc3FydDFfMiA9IE1hdGguU1FSVDFfMjtcbmV4cG9ydCB2YXIgc3FydDIgPSBzcXJ0KDIpO1xuZXhwb3J0IHZhciBzcXJ0UGkgPSBzcXJ0KHBpKTtcbmV4cG9ydCB2YXIgdGF1ID0gcGkgKiAyO1xuZXhwb3J0IHZhciBkZWdyZWVzID0gMTgwIC8gcGk7XG5leHBvcnQgdmFyIHJhZGlhbnMgPSBwaSAvIDE4MDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmNpKHgpIHtcbiAgcmV0dXJuIHggPyB4IC8gTWF0aC5zaW4oeCkgOiAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID4gMSA/IGhhbGZQaSA6IHggPCAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3FydCh4KSB7XG4gIHJldHVybiB4ID4gMCA/IE1hdGguc3FydCh4KSA6IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgeCA9IGV4cCgyICogeCk7XG4gIHJldHVybiAoeCAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKGV4cCh4KSAtIGV4cCgteCkpIC8gMjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gKGV4cCh4KSArIGV4cCgteCkpIC8gMjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyc2luaCh4KSB7XG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmNvc2goeCkge1xuICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMSkpO1xufVxuIiwiaW1wb3J0IHtnZW9Qcm9qZWN0aW9uIGFzIHByb2plY3Rpb259IGZyb20gXCJkMy1nZW9cIjtcbmltcG9ydCB7YWJzLCBhc2luLCBjb3MsIGVwc2lsb24sIGhhbGZQaSwgcGksIHNpbiwgc3FydDJ9IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vbGx3ZWlkZUJyb21sZXlUaGV0YShjcCwgcGhpKSB7XG4gIHZhciBjcHNpblBoaSA9IGNwICogc2luKHBoaSksIGkgPSAzMCwgZGVsdGE7XG4gIGRvIHBoaSAtPSBkZWx0YSA9IChwaGkgKyBzaW4ocGhpKSAtIGNwc2luUGhpKSAvICgxICsgY29zKHBoaSkpO1xuICB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gIHJldHVybiBwaGkgLyAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9sbHdlaWRlQnJvbWxleVJhdyhjeCwgY3ksIGNwKSB7XG5cbiAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBbY3ggKiBsYW1iZGEgKiBjb3MocGhpID0gbW9sbHdlaWRlQnJvbWxleVRoZXRhKGNwLCBwaGkpKSwgY3kgKiBzaW4ocGhpKV07XG4gIH1cblxuICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geSA9IGFzaW4oeSAvIGN5KSwgW3ggLyAoY3ggKiBjb3MoeSkpLCBhc2luKCgyICogeSArIHNpbigyICogeSkpIC8gY3ApXTtcbiAgfTtcblxuICByZXR1cm4gZm9yd2FyZDtcbn1cblxuZXhwb3J0IHZhciBtb2xsd2VpZGVSYXcgPSBtb2xsd2VpZGVCcm9tbGV5UmF3KHNxcnQyIC8gaGFsZlBpLCBzcXJ0MiwgcGkpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24obW9sbHdlaWRlUmF3KVxuICAgICAgLnNjYWxlKDE2OS41MjkpO1xufVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2F0YW4yLCBjb3MsIHF1YXJ0ZXJQaSwgcmFkaWFucywgc2luLCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuL25vb3AuanNcIjtcbmltcG9ydCBzdHJlYW0gZnJvbSBcIi4vc3RyZWFtLmpzXCI7XG5cbmV4cG9ydCB2YXIgYXJlYVJpbmdTdW0gPSBuZXcgQWRkZXIoKTtcblxuLy8gaGVsbG8/XG5cbnZhciBhcmVhU3VtID0gbmV3IEFkZGVyKCksXG4gICAgbGFtYmRhMDAsXG4gICAgcGhpMDAsXG4gICAgbGFtYmRhMCxcbiAgICBjb3NQaGkwLFxuICAgIHNpblBoaTA7XG5cbmV4cG9ydCB2YXIgYXJlYVN0cmVhbSA9IHtcbiAgcG9pbnQ6IG5vb3AsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBhcmVhUmluZ1N1bSA9IG5ldyBBZGRlcigpO1xuICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydDtcbiAgICBhcmVhU3RyZWFtLmxpbmVFbmQgPSBhcmVhUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWFSaW5nID0gK2FyZWFSaW5nU3VtO1xuICAgIGFyZWFTdW0uYWRkKGFyZWFSaW5nIDwgMCA/IHRhdSArIGFyZWFSaW5nIDogYXJlYVJpbmcpO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kID0gdGhpcy5wb2ludCA9IG5vb3A7XG4gIH0sXG4gIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN1bS5hZGQodGF1KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXJlYVJpbmdTdGFydCgpIHtcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBhcmVhUmluZ0VuZCgpIHtcbiAgYXJlYVBvaW50KGxhbWJkYTAwLCBwaGkwMCk7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnQ7XG4gIGxhbWJkYTAwID0gbGFtYmRhLCBwaGkwMCA9IHBoaTtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zKHBoaSA9IHBoaSAvIDIgKyBxdWFydGVyUGkpLCBzaW5QaGkwID0gc2luKHBoaSk7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHBoaSA9IHBoaSAvIDIgKyBxdWFydGVyUGk7IC8vIGhhbGYgdGhlIGFuZ3VsYXIgZGlzdGFuY2UgZnJvbSBzb3V0aCBwb2xlXG5cbiAgLy8gU3BoZXJpY2FsIGV4Y2VzcyBFIGZvciBhIHNwaGVyaWNhbCB0cmlhbmdsZSB3aXRoIHZlcnRpY2VzOiBzb3V0aCBwb2xlLFxuICAvLyBwcmV2aW91cyBwb2ludCwgY3VycmVudCBwb2ludC4gIFVzZXMgYSBmb3JtdWxhIGRlcml2ZWQgZnJvbSBDYWdub2xp4oCZc1xuICAvLyB0aGVvcmVtLiAgU2VlIFRvZGh1bnRlciwgU3BoZXJpY2FsIFRyaWcuICgxODcxKSwgU2VjLiAxMDMsIEVxLiAoMikuXG4gIHZhciBkTGFtYmRhID0gbGFtYmRhIC0gbGFtYmRhMCxcbiAgICAgIHNkTGFtYmRhID0gZExhbWJkYSA+PSAwID8gMSA6IC0xLFxuICAgICAgYWRMYW1iZGEgPSBzZExhbWJkYSAqIGRMYW1iZGEsXG4gICAgICBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIHNpblBoaSA9IHNpbihwaGkpLFxuICAgICAgayA9IHNpblBoaTAgKiBzaW5QaGksXG4gICAgICB1ID0gY29zUGhpMCAqIGNvc1BoaSArIGsgKiBjb3MoYWRMYW1iZGEpLFxuICAgICAgdiA9IGsgKiBzZExhbWJkYSAqIHNpbihhZExhbWJkYSk7XG4gIGFyZWFSaW5nU3VtLmFkZChhdGFuMih2LCB1KSk7XG5cbiAgLy8gQWR2YW5jZSB0aGUgcHJldmlvdXMgcG9pbnRzLlxuICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zUGhpLCBzaW5QaGkwID0gc2luUGhpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmplY3QpIHtcbiAgYXJlYVN1bSA9IG5ldyBBZGRlcigpO1xuICBzdHJlYW0ob2JqZWN0LCBhcmVhU3RyZWFtKTtcbiAgcmV0dXJuIGFyZWFTdW0gKiAyO1xufVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2FyZWFTdHJlYW0sIGFyZWFSaW5nU3VtfSBmcm9tIFwiLi9hcmVhLmpzXCI7XG5pbXBvcnQge2NhcnRlc2lhbiwgY2FydGVzaWFuQ3Jvc3MsIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UsIHNwaGVyaWNhbH0gZnJvbSBcIi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2FicywgZGVncmVlcywgZXBzaWxvbiwgcmFkaWFuc30gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IHN0cmVhbSBmcm9tIFwiLi9zdHJlYW0uanNcIjtcblxudmFyIGxhbWJkYTAsIHBoaTAsIGxhbWJkYTEsIHBoaTEsIC8vIGJvdW5kc1xuICAgIGxhbWJkYTIsIC8vIHByZXZpb3VzIGxhbWJkYS1jb29yZGluYXRlXG4gICAgbGFtYmRhMDAsIHBoaTAwLCAvLyBmaXJzdCBwb2ludFxuICAgIHAwLCAvLyBwcmV2aW91cyAzRCBwb2ludFxuICAgIGRlbHRhU3VtLFxuICAgIHJhbmdlcyxcbiAgICByYW5nZTtcblxudmFyIGJvdW5kc1N0cmVhbSA9IHtcbiAgcG9pbnQ6IGJvdW5kc1BvaW50LFxuICBsaW5lU3RhcnQ6IGJvdW5kc0xpbmVTdGFydCxcbiAgbGluZUVuZDogYm91bmRzTGluZUVuZCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNSaW5nUG9pbnQ7XG4gICAgYm91bmRzU3RyZWFtLmxpbmVTdGFydCA9IGJvdW5kc1JpbmdTdGFydDtcbiAgICBib3VuZHNTdHJlYW0ubGluZUVuZCA9IGJvdW5kc1JpbmdFbmQ7XG4gICAgZGVsdGFTdW0gPSBuZXcgQWRkZXIoKTtcbiAgICBhcmVhU3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNQb2ludDtcbiAgICBib3VuZHNTdHJlYW0ubGluZVN0YXJ0ID0gYm91bmRzTGluZVN0YXJ0O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lRW5kID0gYm91bmRzTGluZUVuZDtcbiAgICBpZiAoYXJlYVJpbmdTdW0gPCAwKSBsYW1iZGEwID0gLShsYW1iZGExID0gMTgwKSwgcGhpMCA9IC0ocGhpMSA9IDkwKTtcbiAgICBlbHNlIGlmIChkZWx0YVN1bSA+IGVwc2lsb24pIHBoaTEgPSA5MDtcbiAgICBlbHNlIGlmIChkZWx0YVN1bSA8IC1lcHNpbG9uKSBwaGkwID0gLTkwO1xuICAgIHJhbmdlWzBdID0gbGFtYmRhMCwgcmFuZ2VbMV0gPSBsYW1iZGExO1xuICB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgIGxhbWJkYTAgPSAtKGxhbWJkYTEgPSAxODApLCBwaGkwID0gLShwaGkxID0gOTApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBib3VuZHNQb2ludChsYW1iZGEsIHBoaSkge1xuICByYW5nZXMucHVzaChyYW5nZSA9IFtsYW1iZGEwID0gbGFtYmRhLCBsYW1iZGExID0gbGFtYmRhXSk7XG4gIGlmIChwaGkgPCBwaGkwKSBwaGkwID0gcGhpO1xuICBpZiAocGhpID4gcGhpMSkgcGhpMSA9IHBoaTtcbn1cblxuZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIHZhciBwID0gY2FydGVzaWFuKFtsYW1iZGEgKiByYWRpYW5zLCBwaGkgKiByYWRpYW5zXSk7XG4gIGlmIChwMCkge1xuICAgIHZhciBub3JtYWwgPSBjYXJ0ZXNpYW5Dcm9zcyhwMCwgcCksXG4gICAgICAgIGVxdWF0b3JpYWwgPSBbbm9ybWFsWzFdLCAtbm9ybWFsWzBdLCAwXSxcbiAgICAgICAgaW5mbGVjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKGVxdWF0b3JpYWwsIG5vcm1hbCk7XG4gICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbmZsZWN0aW9uKTtcbiAgICBpbmZsZWN0aW9uID0gc3BoZXJpY2FsKGluZmxlY3Rpb24pO1xuICAgIHZhciBkZWx0YSA9IGxhbWJkYSAtIGxhbWJkYTIsXG4gICAgICAgIHNpZ24gPSBkZWx0YSA+IDAgPyAxIDogLTEsXG4gICAgICAgIGxhbWJkYWkgPSBpbmZsZWN0aW9uWzBdICogZGVncmVlcyAqIHNpZ24sXG4gICAgICAgIHBoaWksXG4gICAgICAgIGFudGltZXJpZGlhbiA9IGFicyhkZWx0YSkgPiAxODA7XG4gICAgaWYgKGFudGltZXJpZGlhbiBeIChzaWduICogbGFtYmRhMiA8IGxhbWJkYWkgJiYgbGFtYmRhaSA8IHNpZ24gKiBsYW1iZGEpKSB7XG4gICAgICBwaGlpID0gaW5mbGVjdGlvblsxXSAqIGRlZ3JlZXM7XG4gICAgICBpZiAocGhpaSA+IHBoaTEpIHBoaTEgPSBwaGlpO1xuICAgIH0gZWxzZSBpZiAobGFtYmRhaSA9IChsYW1iZGFpICsgMzYwKSAlIDM2MCAtIDE4MCwgYW50aW1lcmlkaWFuIF4gKHNpZ24gKiBsYW1iZGEyIDwgbGFtYmRhaSAmJiBsYW1iZGFpIDwgc2lnbiAqIGxhbWJkYSkpIHtcbiAgICAgIHBoaWkgPSAtaW5mbGVjdGlvblsxXSAqIGRlZ3JlZXM7XG4gICAgICBpZiAocGhpaSA8IHBoaTApIHBoaTAgPSBwaGlpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGhpIDwgcGhpMCkgcGhpMCA9IHBoaTtcbiAgICAgIGlmIChwaGkgPiBwaGkxKSBwaGkxID0gcGhpO1xuICAgIH1cbiAgICBpZiAoYW50aW1lcmlkaWFuKSB7XG4gICAgICBpZiAobGFtYmRhIDwgbGFtYmRhMikge1xuICAgICAgICBpZiAoYW5nbGUobGFtYmRhMCwgbGFtYmRhKSA+IGFuZ2xlKGxhbWJkYTAsIGxhbWJkYTEpKSBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYSwgbGFtYmRhMSkgPiBhbmdsZShsYW1iZGEwLCBsYW1iZGExKSkgbGFtYmRhMCA9IGxhbWJkYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxhbWJkYTEgPj0gbGFtYmRhMCkge1xuICAgICAgICBpZiAobGFtYmRhIDwgbGFtYmRhMCkgbGFtYmRhMCA9IGxhbWJkYTtcbiAgICAgICAgaWYgKGxhbWJkYSA+IGxhbWJkYTEpIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGFtYmRhID4gbGFtYmRhMikge1xuICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEwLCBsYW1iZGEpID4gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkpIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYSwgbGFtYmRhMSkgPiBhbmdsZShsYW1iZGEwLCBsYW1iZGExKSkgbGFtYmRhMCA9IGxhbWJkYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByYW5nZXMucHVzaChyYW5nZSA9IFtsYW1iZGEwID0gbGFtYmRhLCBsYW1iZGExID0gbGFtYmRhXSk7XG4gIH1cbiAgaWYgKHBoaSA8IHBoaTApIHBoaTAgPSBwaGk7XG4gIGlmIChwaGkgPiBwaGkxKSBwaGkxID0gcGhpO1xuICBwMCA9IHAsIGxhbWJkYTIgPSBsYW1iZGE7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0xpbmVTdGFydCgpIHtcbiAgYm91bmRzU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xufVxuXG5mdW5jdGlvbiBib3VuZHNMaW5lRW5kKCkge1xuICByYW5nZVswXSA9IGxhbWJkYTAsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUG9pbnQ7XG4gIHAwID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYm91bmRzUmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGlmIChwMCkge1xuICAgIHZhciBkZWx0YSA9IGxhbWJkYSAtIGxhbWJkYTI7XG4gICAgZGVsdGFTdW0uYWRkKGFicyhkZWx0YSkgPiAxODAgPyBkZWx0YSArIChkZWx0YSA+IDAgPyAzNjAgOiAtMzYwKSA6IGRlbHRhKTtcbiAgfSBlbHNlIHtcbiAgICBsYW1iZGEwMCA9IGxhbWJkYSwgcGhpMDAgPSBwaGk7XG4gIH1cbiAgYXJlYVN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gIGxpbmVQb2ludChsYW1iZGEsIHBoaSk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc1JpbmdTdGFydCgpIHtcbiAgYXJlYVN0cmVhbS5saW5lU3RhcnQoKTtcbn1cblxuZnVuY3Rpb24gYm91bmRzUmluZ0VuZCgpIHtcbiAgYm91bmRzUmluZ1BvaW50KGxhbWJkYTAwLCBwaGkwMCk7XG4gIGFyZWFTdHJlYW0ubGluZUVuZCgpO1xuICBpZiAoYWJzKGRlbHRhU3VtKSA+IGVwc2lsb24pIGxhbWJkYTAgPSAtKGxhbWJkYTEgPSAxODApO1xuICByYW5nZVswXSA9IGxhbWJkYTAsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgcDAgPSBudWxsO1xufVxuXG4vLyBGaW5kcyB0aGUgbGVmdC1yaWdodCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBsb25naXR1ZGVzLlxuLy8gVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgKGxhbWJkYTEgLSBsYW1iZGEwICsgMzYwwrApICUgMzYwwrAsIGV4Y2VwdCB0aGF0IHdlIHdhbnRcbi8vIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIMKxMTgwwrAgdG8gYmUgMzYwwrAuXG5mdW5jdGlvbiBhbmdsZShsYW1iZGEwLCBsYW1iZGExKSB7XG4gIHJldHVybiAobGFtYmRhMSAtPSBsYW1iZGEwKSA8IDAgPyBsYW1iZGExICsgMzYwIDogbGFtYmRhMTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VDb21wYXJlKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdO1xufVxuXG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zKHJhbmdlLCB4KSB7XG4gIHJldHVybiByYW5nZVswXSA8PSByYW5nZVsxXSA/IHJhbmdlWzBdIDw9IHggJiYgeCA8PSByYW5nZVsxXSA6IHggPCByYW5nZVswXSB8fCByYW5nZVsxXSA8IHg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgdmFyIGksIG4sIGEsIGIsIG1lcmdlZCwgZGVsdGFNYXgsIGRlbHRhO1xuXG4gIHBoaTEgPSBsYW1iZGExID0gLShsYW1iZGEwID0gcGhpMCA9IEluZmluaXR5KTtcbiAgcmFuZ2VzID0gW107XG4gIHN0cmVhbShmZWF0dXJlLCBib3VuZHNTdHJlYW0pO1xuXG4gIC8vIEZpcnN0LCBzb3J0IHJhbmdlcyBieSB0aGVpciBtaW5pbXVtIGxvbmdpdHVkZXMuXG4gIGlmIChuID0gcmFuZ2VzLmxlbmd0aCkge1xuICAgIHJhbmdlcy5zb3J0KHJhbmdlQ29tcGFyZSk7XG5cbiAgICAvLyBUaGVuLCBtZXJnZSBhbnkgcmFuZ2VzIHRoYXQgb3ZlcmxhcC5cbiAgICBmb3IgKGkgPSAxLCBhID0gcmFuZ2VzWzBdLCBtZXJnZWQgPSBbYV07IGkgPCBuOyArK2kpIHtcbiAgICAgIGIgPSByYW5nZXNbaV07XG4gICAgICBpZiAocmFuZ2VDb250YWlucyhhLCBiWzBdKSB8fCByYW5nZUNvbnRhaW5zKGEsIGJbMV0pKSB7XG4gICAgICAgIGlmIChhbmdsZShhWzBdLCBiWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzFdID0gYlsxXTtcbiAgICAgICAgaWYgKGFuZ2xlKGJbMF0sIGFbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpIGFbMF0gPSBiWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VkLnB1c2goYSA9IGIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIGZpbmQgdGhlIGxhcmdlc3QgZ2FwIGJldHdlZW4gdGhlIG1lcmdlZCByYW5nZXMuXG4gICAgLy8gVGhlIGZpbmFsIGJvdW5kaW5nIGJveCB3aWxsIGJlIHRoZSBpbnZlcnNlIG9mIHRoaXMgZ2FwLlxuICAgIGZvciAoZGVsdGFNYXggPSAtSW5maW5pdHksIG4gPSBtZXJnZWQubGVuZ3RoIC0gMSwgaSA9IDAsIGEgPSBtZXJnZWRbbl07IGkgPD0gbjsgYSA9IGIsICsraSkge1xuICAgICAgYiA9IG1lcmdlZFtpXTtcbiAgICAgIGlmICgoZGVsdGEgPSBhbmdsZShhWzFdLCBiWzBdKSkgPiBkZWx0YU1heCkgZGVsdGFNYXggPSBkZWx0YSwgbGFtYmRhMCA9IGJbMF0sIGxhbWJkYTEgPSBhWzFdO1xuICAgIH1cbiAgfVxuXG4gIHJhbmdlcyA9IHJhbmdlID0gbnVsbDtcblxuICByZXR1cm4gbGFtYmRhMCA9PT0gSW5maW5pdHkgfHwgcGhpMCA9PT0gSW5maW5pdHlcbiAgICAgID8gW1tOYU4sIE5hTl0sIFtOYU4sIE5hTl1dXG4gICAgICA6IFtbbGFtYmRhMCwgcGhpMF0sIFtsYW1iZGExLCBwaGkxXV07XG59XG4iLCJpbXBvcnQge2FzaW4sIGF0YW4yLCBjb3MsIHNpbiwgc3FydH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICByZXR1cm4gW2F0YW4yKGNhcnRlc2lhblsxXSwgY2FydGVzaWFuWzBdKSwgYXNpbihjYXJ0ZXNpYW5bMl0pXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgdmFyIGxhbWJkYSA9IHNwaGVyaWNhbFswXSwgcGhpID0gc3BoZXJpY2FsWzFdLCBjb3NQaGkgPSBjb3MocGhpKTtcbiAgcmV0dXJuIFtjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbkRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5Dcm9zcyhhLCBiKSB7XG4gIHJldHVybiBbYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXV07XG59XG5cbi8vIFRPRE8gcmV0dXJuIGFcbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5BZGRJblBsYWNlKGEsIGIpIHtcbiAgYVswXSArPSBiWzBdLCBhWzFdICs9IGJbMV0sIGFbMl0gKz0gYlsyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICByZXR1cm4gW3ZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGtdO1xufVxuXG4vLyBUT0RPIHJldHVybiBkXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShkKSB7XG4gIHZhciBsID0gc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICBkWzBdIC89IGwsIGRbMV0gLz0gbCwgZFsyXSAvPSBsO1xufVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2FzaW4sIGF0YW4yLCBjb3MsIGRlZ3JlZXMsIGVwc2lsb24sIGVwc2lsb24yLCBoeXBvdCwgcmFkaWFucywgc2luLCBzcXJ0fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi9ub29wLmpzXCI7XG5pbXBvcnQgc3RyZWFtIGZyb20gXCIuL3N0cmVhbS5qc1wiO1xuXG52YXIgVzAsIFcxLFxuICAgIFgwLCBZMCwgWjAsXG4gICAgWDEsIFkxLCBaMSxcbiAgICBYMiwgWTIsIFoyLFxuICAgIGxhbWJkYTAwLCBwaGkwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICB4MCwgeTAsIHowOyAvLyBwcmV2aW91cyBwb2ludFxuXG52YXIgY2VudHJvaWRTdHJlYW0gPSB7XG4gIHNwaGVyZTogbm9vcCxcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQsXG4gIGxpbmVTdGFydDogY2VudHJvaWRMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZFJpbmdTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICB9XG59O1xuXG4vLyBBcml0aG1ldGljIG1lYW4gb2YgQ2FydGVzaWFuIHZlY3RvcnMuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKGNvc1BoaSAqIGNvcyhsYW1iZGEpLCBjb3NQaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgsIHksIHopIHtcbiAgKytXMDtcbiAgWDAgKz0gKHggLSBYMCkgLyBXMDtcbiAgWTAgKz0gKHkgLSBZMCkgLyBXMDtcbiAgWjAgKz0gKHogLSBaMCkgLyBXMDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgejAgPSBzaW4ocGhpKTtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludDtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICB4ID0gY29zUGhpICogY29zKGxhbWJkYSksXG4gICAgICB5ID0gY29zUGhpICogc2luKGxhbWJkYSksXG4gICAgICB6ID0gc2luKHBoaSksXG4gICAgICB3ID0gYXRhbjIoc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICBXMSArPSB3O1xuICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVFbmQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuLy8gU2VlIEouIEUuIEJyb2NrLCBUaGUgSW5lcnRpYSBUZW5zb3IgZm9yIGEgU3BoZXJpY2FsIFRyaWFuZ2xlLFxuLy8gSi4gQXBwbGllZCBNZWNoYW5pY3MgNDIsIDIzOSAoMTk3NSkuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQoKSB7XG4gIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYTAwLCBwaGkwMCk7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEwMCA9IGxhbWJkYSwgcGhpMDAgPSBwaGk7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludDtcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICB4MCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpO1xuICB5MCA9IGNvc1BoaSAqIHNpbihsYW1iZGEpO1xuICB6MCA9IHNpbihwaGkpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIHggPSBjb3NQaGkgKiBjb3MobGFtYmRhKSxcbiAgICAgIHkgPSBjb3NQaGkgKiBzaW4obGFtYmRhKSxcbiAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgIGN4ID0geTAgKiB6IC0gejAgKiB5LFxuICAgICAgY3kgPSB6MCAqIHggLSB4MCAqIHosXG4gICAgICBjeiA9IHgwICogeSAtIHkwICogeCxcbiAgICAgIG0gPSBoeXBvdChjeCwgY3ksIGN6KSxcbiAgICAgIHcgPSBhc2luKG0pLCAvLyBsaW5lIHdlaWdodCA9IGFuZ2xlXG4gICAgICB2ID0gbSAmJiAtdyAvIG07IC8vIGFyZWEgd2VpZ2h0IG11bHRpcGxpZXJcbiAgWDIuYWRkKHYgKiBjeCk7XG4gIFkyLmFkZCh2ICogY3kpO1xuICBaMi5hZGQodiAqIGN6KTtcbiAgVzEgKz0gdztcbiAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqZWN0KSB7XG4gIFcwID0gVzEgPVxuICBYMCA9IFkwID0gWjAgPVxuICBYMSA9IFkxID0gWjEgPSAwO1xuICBYMiA9IG5ldyBBZGRlcigpO1xuICBZMiA9IG5ldyBBZGRlcigpO1xuICBaMiA9IG5ldyBBZGRlcigpO1xuICBzdHJlYW0ob2JqZWN0LCBjZW50cm9pZFN0cmVhbSk7XG5cbiAgdmFyIHggPSArWDIsXG4gICAgICB5ID0gK1kyLFxuICAgICAgeiA9ICtaMixcbiAgICAgIG0gPSBoeXBvdCh4LCB5LCB6KTtcblxuICAvLyBJZiB0aGUgYXJlYS13ZWlnaHRlZCBjY2VudHJvaWQgaXMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbGVuZ3RoLXdlaWdodGVkIGNjZW50cm9pZC5cbiAgaWYgKG0gPCBlcHNpbG9uMikge1xuICAgIHggPSBYMSwgeSA9IFkxLCB6ID0gWjE7XG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgaGFzIHplcm8gbGVuZ3RoLCBmYWxsIGJhY2sgdG8gYXJpdGhtZXRpYyBtZWFuIG9mIHBvaW50IHZlY3RvcnMuXG4gICAgaWYgKFcxIDwgZXBzaWxvbikgeCA9IFgwLCB5ID0gWTAsIHogPSBaMDtcbiAgICBtID0gaHlwb3QoeCwgeSwgeik7XG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgc3RpbGwgaGFzIGFuIHVuZGVmaW5lZCBjY2VudHJvaWQsIHRoZW4gcmV0dXJuLlxuICAgIGlmIChtIDwgZXBzaWxvbjIpIHJldHVybiBbTmFOLCBOYU5dO1xuICB9XG5cbiAgcmV0dXJuIFthdGFuMih5LCB4KSAqIGRlZ3JlZXMsIGFzaW4oeiAvIG0pICogZGVncmVlc107XG59XG4iLCJpbXBvcnQge2NhcnRlc2lhbiwgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZSwgc3BoZXJpY2FsfSBmcm9tIFwiLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IHthY29zLCBjb3MsIGRlZ3JlZXMsIGVwc2lsb24sIHJhZGlhbnMsIHNpbiwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQge3JvdGF0ZVJhZGlhbnN9IGZyb20gXCIuL3JvdGF0aW9uLmpzXCI7XG5cbi8vIEdlbmVyYXRlcyBhIGNpcmNsZSBjZW50ZXJlZCBhdCBbMMKwLCAwwrBdLCB3aXRoIGEgZ2l2ZW4gcmFkaXVzIGFuZCBwcmVjaXNpb24uXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCB0MCwgdDEpIHtcbiAgaWYgKCFkZWx0YSkgcmV0dXJuO1xuICB2YXIgY29zUmFkaXVzID0gY29zKHJhZGl1cyksXG4gICAgICBzaW5SYWRpdXMgPSBzaW4ocmFkaXVzKSxcbiAgICAgIHN0ZXAgPSBkaXJlY3Rpb24gKiBkZWx0YTtcbiAgaWYgKHQwID09IG51bGwpIHtcbiAgICB0MCA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIHRhdTtcbiAgICB0MSA9IHJhZGl1cyAtIHN0ZXAgLyAyO1xuICB9IGVsc2Uge1xuICAgIHQwID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDApO1xuICAgIHQxID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDEpO1xuICAgIGlmIChkaXJlY3Rpb24gPiAwID8gdDAgPCB0MSA6IHQwID4gdDEpIHQwICs9IGRpcmVjdGlvbiAqIHRhdTtcbiAgfVxuICBmb3IgKHZhciBwb2ludCwgdCA9IHQwOyBkaXJlY3Rpb24gPiAwID8gdCA+IHQxIDogdCA8IHQxOyB0IC09IHN0ZXApIHtcbiAgICBwb2ludCA9IHNwaGVyaWNhbChbY29zUmFkaXVzLCAtc2luUmFkaXVzICogY29zKHQpLCAtc2luUmFkaXVzICogc2luKHQpXSk7XG4gICAgc3RyZWFtLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgc2lnbmVkIGFuZ2xlIG9mIGEgY2FydGVzaWFuIHBvaW50IHJlbGF0aXZlIHRvIFtjb3NSYWRpdXMsIDAsIDBdLlxuZnVuY3Rpb24gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgcG9pbnQpIHtcbiAgcG9pbnQgPSBjYXJ0ZXNpYW4ocG9pbnQpLCBwb2ludFswXSAtPSBjb3NSYWRpdXM7XG4gIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UocG9pbnQpO1xuICB2YXIgcmFkaXVzID0gYWNvcygtcG9pbnRbMV0pO1xuICByZXR1cm4gKCgtcG9pbnRbMl0gPCAwID8gLXJhZGl1cyA6IHJhZGl1cykgKyB0YXUgLSBlcHNpbG9uKSAlIHRhdTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBjZW50ZXIgPSBjb25zdGFudChbMCwgMF0pLFxuICAgICAgcmFkaXVzID0gY29uc3RhbnQoOTApLFxuICAgICAgcHJlY2lzaW9uID0gY29uc3RhbnQoNiksXG4gICAgICByaW5nLFxuICAgICAgcm90YXRlLFxuICAgICAgc3RyZWFtID0ge3BvaW50OiBwb2ludH07XG5cbiAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcbiAgICB4WzBdICo9IGRlZ3JlZXMsIHhbMV0gKj0gZGVncmVlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgICB2YXIgYyA9IGNlbnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByID0gcmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zLFxuICAgICAgICBwID0gcHJlY2lzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zO1xuICAgIHJpbmcgPSBbXTtcbiAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKC1jWzBdICogcmFkaWFucywgLWNbMV0gKiByYWRpYW5zLCAwKS5pbnZlcnQ7XG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgciwgcCwgMSk7XG4gICAgYyA9IHt0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IFtyaW5nXX07XG4gICAgcmluZyA9IHJvdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBjaXJjbGUuY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoWytfWzBdLCArX1sxXV0pLCBjaXJjbGUpIDogY2VudGVyO1xuICB9O1xuXG4gIGNpcmNsZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgY2lyY2xlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjaXNpb24gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgY2lyY2xlKSA6IHByZWNpc2lvbjtcbiAgfTtcblxuICByZXR1cm4gY2lyY2xlO1xufVxuIiwiaW1wb3J0IGNsaXAgZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7YWJzLCBhdGFuLCBjb3MsIGVwc2lsb24sIGhhbGZQaSwgcGksIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xpcChcbiAgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LFxuICBjbGlwQW50aW1lcmlkaWFuTGluZSxcbiAgY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlLFxuICBbLXBpLCAtaGFsZlBpXVxuKTtcblxuLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlczogMCAtIHRoZXJlIHdlcmVcbi8vIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm8gaW50ZXJzZWN0aW9uczsgMiAtIHRoZXJlIHdlcmVcbi8vIGludGVyc2VjdGlvbnMsIGFuZCB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgc2hvdWxkIGJlIHJlam9pbmVkLlxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkxpbmUoc3RyZWFtKSB7XG4gIHZhciBsYW1iZGEwID0gTmFOLFxuICAgICAgcGhpMCA9IE5hTixcbiAgICAgIHNpZ24wID0gTmFOLFxuICAgICAgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcblxuICByZXR1cm4ge1xuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICBjbGVhbiA9IDE7XG4gICAgfSxcbiAgICBwb2ludDogZnVuY3Rpb24obGFtYmRhMSwgcGhpMSkge1xuICAgICAgdmFyIHNpZ24xID0gbGFtYmRhMSA+IDAgPyBwaSA6IC1waSxcbiAgICAgICAgICBkZWx0YSA9IGFicyhsYW1iZGExIC0gbGFtYmRhMCk7XG4gICAgICBpZiAoYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbikgeyAvLyBsaW5lIGNyb3NzZXMgYSBwb2xlXG4gICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwLCBwaGkwID0gKHBoaTAgKyBwaGkxKSAvIDIgPiAwID8gaGFsZlBpIDogLWhhbGZQaSk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTEsIHBoaTApO1xuICAgICAgICBjbGVhbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24wICE9PSBzaWduMSAmJiBkZWx0YSA+PSBwaSkgeyAvLyBsaW5lIGNyb3NzZXMgYW50aW1lcmlkaWFuXG4gICAgICAgIGlmIChhYnMobGFtYmRhMCAtIHNpZ24wKSA8IGVwc2lsb24pIGxhbWJkYTAgLT0gc2lnbjAgKiBlcHNpbG9uOyAvLyBoYW5kbGUgZGVnZW5lcmFjaWVzXG4gICAgICAgIGlmIChhYnMobGFtYmRhMSAtIHNpZ24xKSA8IGVwc2lsb24pIGxhbWJkYTEgLT0gc2lnbjEgKiBlcHNpbG9uO1xuICAgICAgICBwaGkwID0gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICBjbGVhbiA9IDA7XG4gICAgICB9XG4gICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCA9IGxhbWJkYTEsIHBoaTAgPSBwaGkxKTtcbiAgICAgIHNpZ24wID0gc2lnbjE7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICBsYW1iZGEwID0gcGhpMCA9IE5hTjtcbiAgICB9LFxuICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAyIC0gY2xlYW47IC8vIGlmIGludGVyc2VjdGlvbnMsIHJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKSB7XG4gIHZhciBjb3NQaGkwLFxuICAgICAgY29zUGhpMSxcbiAgICAgIHNpbkxhbWJkYTBMYW1iZGExID0gc2luKGxhbWJkYTAgLSBsYW1iZGExKTtcbiAgcmV0dXJuIGFicyhzaW5MYW1iZGEwTGFtYmRhMSkgPiBlcHNpbG9uXG4gICAgICA/IGF0YW4oKHNpbihwaGkwKSAqIChjb3NQaGkxID0gY29zKHBoaTEpKSAqIHNpbihsYW1iZGExKVxuICAgICAgICAgIC0gc2luKHBoaTEpICogKGNvc1BoaTAgPSBjb3MocGhpMCkpICogc2luKGxhbWJkYTApKVxuICAgICAgICAgIC8gKGNvc1BoaTAgKiBjb3NQaGkxICogc2luTGFtYmRhMExhbWJkYTEpKVxuICAgICAgOiAocGhpMCArIHBoaTEpIC8gMjtcbn1cblxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICB2YXIgcGhpO1xuICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgcGhpID0gZGlyZWN0aW9uICogaGFsZlBpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChwaSwgMCk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgMCk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgfSBlbHNlIGlmIChhYnMoZnJvbVswXSAtIHRvWzBdKSA+IGVwc2lsb24pIHtcbiAgICB2YXIgbGFtYmRhID0gZnJvbVswXSA8IHRvWzBdID8gcGkgOiAtcGk7XG4gICAgcGhpID0gZGlyZWN0aW9uICogbGFtYmRhIC8gMjtcbiAgICBzdHJlYW0ucG9pbnQoLWxhbWJkYSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQobGFtYmRhLCBwaGkpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICB9XG59XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmVzID0gW10sXG4gICAgICBsaW5lO1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5LCBtKSB7XG4gICAgICBsaW5lLnB1c2goW3gsIHksIG1dKTtcbiAgICB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBsaW5lcy5wdXNoKGxpbmUgPSBbXSk7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBub29wLFxuICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkgbGluZXMucHVzaChsaW5lcy5wb3AoKS5jb25jYXQobGluZXMuc2hpZnQoKSkpO1xuICAgIH0sXG4gICAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsaW5lcztcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBsaW5lID0gbnVsbDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbkFkZEluUGxhY2UsIGNhcnRlc2lhbkNyb3NzLCBjYXJ0ZXNpYW5Eb3QsIGNhcnRlc2lhblNjYWxlLCBzcGhlcmljYWx9IGZyb20gXCIuLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7Y2lyY2xlU3RyZWFtfSBmcm9tIFwiLi4vY2lyY2xlLmpzXCI7XG5pbXBvcnQge2FicywgY29zLCBlcHNpbG9uLCBwaSwgcmFkaWFucywgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBwb2ludEVxdWFsIGZyb20gXCIuLi9wb2ludEVxdWFsLmpzXCI7XG5pbXBvcnQgY2xpcCBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYWRpdXMpIHtcbiAgdmFyIGNyID0gY29zKHJhZGl1cyksXG4gICAgICBkZWx0YSA9IDYgKiByYWRpYW5zLFxuICAgICAgc21hbGxSYWRpdXMgPSBjciA+IDAsXG4gICAgICBub3RIZW1pc3BoZXJlID0gYWJzKGNyKSA+IGVwc2lsb247IC8vIFRPRE8gb3B0aW1pc2UgZm9yIHRoaXMgY29tbW9uIGNhc2VcblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIGZyb20sIHRvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGUobGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gY29zKGxhbWJkYSkgKiBjb3MocGhpKSA+IGNyO1xuICB9XG5cbiAgLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlcyB1c2VkIGZvciBwb2x5Z29uXG4gIC8vIGNsaXBwaW5nOiAwIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vXG4gIC8vIGludGVyc2VjdGlvbnMgMiAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAvLyBzaG91bGQgYmUgcmVqb2luZWQuXG4gIGZ1bmN0aW9uIGNsaXBMaW5lKHN0cmVhbSkge1xuICAgIHZhciBwb2ludDAsIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGMwLCAvLyBjb2RlIGZvciBwcmV2aW91cyBwb2ludFxuICAgICAgICB2MCwgLy8gdmlzaWJpbGl0eSBvZiBwcmV2aW91cyBwb2ludFxuICAgICAgICB2MDAsIC8vIHZpc2liaWxpdHkgb2YgZmlyc3QgcG9pbnRcbiAgICAgICAgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdjAwID0gdjAgPSBmYWxzZTtcbiAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgcG9pbnQxID0gW2xhbWJkYSwgcGhpXSxcbiAgICAgICAgICAgIHBvaW50MixcbiAgICAgICAgICAgIHYgPSB2aXNpYmxlKGxhbWJkYSwgcGhpKSxcbiAgICAgICAgICAgIGMgPSBzbWFsbFJhZGl1c1xuICAgICAgICAgICAgICA/IHYgPyAwIDogY29kZShsYW1iZGEsIHBoaSlcbiAgICAgICAgICAgICAgOiB2ID8gY29kZShsYW1iZGEgKyAobGFtYmRhIDwgMCA/IHBpIDogLXBpKSwgcGhpKSA6IDA7XG4gICAgICAgIGlmICghcG9pbnQwICYmICh2MDAgPSB2MCA9IHYpKSBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgaWYgKCFwb2ludDIgfHwgcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MikgfHwgcG9pbnRFcXVhbChwb2ludDEsIHBvaW50MikpXG4gICAgICAgICAgICBwb2ludDFbMl0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgLy8gb3V0c2lkZSBnb2luZyBpblxuICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluc2lkZSBnb2luZyBvdXRcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0sIDIpO1xuICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICB9IGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgIHZhciB0O1xuICAgICAgICAgIC8vIElmIHRoZSBjb2RlcyBmb3IgdHdvIHBvaW50cyBhcmUgZGlmZmVyZW50LCBvciBhcmUgYm90aCB6ZXJvLFxuICAgICAgICAgIC8vIGFuZCB0aGVyZSB0aGlzIHNlZ21lbnQgaW50ZXJzZWN0cyB3aXRoIHRoZSBzbWFsbCBjaXJjbGUuXG4gICAgICAgICAgaWYgKCEoYyAmIGMwKSAmJiAodCA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICBpZiAoc21hbGxSYWRpdXMpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQxKSkpIHtcbiAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh2MCkgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgcG9pbnQwID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAvLyBSZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgaWYgdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIGFuZCBsYXN0IHBvaW50cyB3ZXJlIHZpc2libGUuXG4gICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjbGVhbiB8ICgodjAwICYmIHYwKSA8PCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJzZWN0cyB0aGUgZ3JlYXQgY2lyY2xlIGJldHdlZW4gYSBhbmQgYiB3aXRoIHRoZSBjbGlwIGNpcmNsZS5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xuICAgIHZhciBwYSA9IGNhcnRlc2lhbihhKSxcbiAgICAgICAgcGIgPSBjYXJ0ZXNpYW4oYik7XG5cbiAgICAvLyBXZSBoYXZlIHR3byBwbGFuZXMsIG4xLnAgPSBkMSBhbmQgbjIucCA9IGQyLlxuICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIGxpbmUgcCh0KSA9IGMxIG4xICsgYzIgbjIgKyB0IChuMSDiqK8gbjIpLlxuICAgIHZhciBuMSA9IFsxLCAwLCAwXSwgLy8gbm9ybWFsXG4gICAgICAgIG4yID0gY2FydGVzaWFuQ3Jvc3MocGEsIHBiKSxcbiAgICAgICAgbjJuMiA9IGNhcnRlc2lhbkRvdChuMiwgbjIpLFxuICAgICAgICBuMW4yID0gbjJbMF0sIC8vIGNhcnRlc2lhbkRvdChuMSwgbjIpLFxuICAgICAgICBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcblxuICAgIC8vIFR3byBwb2xhciBwb2ludHMuXG4gICAgaWYgKCFkZXRlcm1pbmFudCkgcmV0dXJuICF0d28gJiYgYTtcblxuICAgIHZhciBjMSA9ICBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCxcbiAgICAgICAgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsXG4gICAgICAgIG4xeG4yID0gY2FydGVzaWFuQ3Jvc3MobjEsIG4yKSxcbiAgICAgICAgQSA9IGNhcnRlc2lhblNjYWxlKG4xLCBjMSksXG4gICAgICAgIEIgPSBjYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgIGNhcnRlc2lhbkFkZEluUGxhY2UoQSwgQik7XG5cbiAgICAvLyBTb2x2ZSB8cCh0KXxeMiA9IDEuXG4gICAgdmFyIHUgPSBuMXhuMixcbiAgICAgICAgdyA9IGNhcnRlc2lhbkRvdChBLCB1KSxcbiAgICAgICAgdXUgPSBjYXJ0ZXNpYW5Eb3QodSwgdSksXG4gICAgICAgIHQyID0gdyAqIHcgLSB1dSAqIChjYXJ0ZXNpYW5Eb3QoQSwgQSkgLSAxKTtcblxuICAgIGlmICh0MiA8IDApIHJldHVybjtcblxuICAgIHZhciB0ID0gc3FydCh0MiksXG4gICAgICAgIHEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgLSB0KSAvIHV1KTtcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHEsIEEpO1xuICAgIHEgPSBzcGhlcmljYWwocSk7XG5cbiAgICBpZiAoIXR3bykgcmV0dXJuIHE7XG5cbiAgICAvLyBUd28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICB2YXIgbGFtYmRhMCA9IGFbMF0sXG4gICAgICAgIGxhbWJkYTEgPSBiWzBdLFxuICAgICAgICBwaGkwID0gYVsxXSxcbiAgICAgICAgcGhpMSA9IGJbMV0sXG4gICAgICAgIHo7XG5cbiAgICBpZiAobGFtYmRhMSA8IGxhbWJkYTApIHogPSBsYW1iZGEwLCBsYW1iZGEwID0gbGFtYmRhMSwgbGFtYmRhMSA9IHo7XG5cbiAgICB2YXIgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCxcbiAgICAgICAgcG9sYXIgPSBhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uLFxuICAgICAgICBtZXJpZGlhbiA9IHBvbGFyIHx8IGRlbHRhIDwgZXBzaWxvbjtcblxuICAgIGlmICghcG9sYXIgJiYgcGhpMSA8IHBoaTApIHogPSBwaGkwLCBwaGkwID0gcGhpMSwgcGhpMSA9IHo7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBmaXJzdCBwb2ludCBpcyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgaWYgKG1lcmlkaWFuXG4gICAgICAgID8gcG9sYXJcbiAgICAgICAgICA/IHBoaTAgKyBwaGkxID4gMCBeIHFbMV0gPCAoYWJzKHFbMF0gLSBsYW1iZGEwKSA8IGVwc2lsb24gPyBwaGkwIDogcGhpMSlcbiAgICAgICAgICA6IHBoaTAgPD0gcVsxXSAmJiBxWzFdIDw9IHBoaTFcbiAgICAgICAgOiBkZWx0YSA+IHBpIF4gKGxhbWJkYTAgPD0gcVswXSAmJiBxWzBdIDw9IGxhbWJkYTEpKSB7XG4gICAgICB2YXIgcTEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcbiAgICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocTEsIEEpO1xuICAgICAgcmV0dXJuIFtxLCBzcGhlcmljYWwocTEpXTtcbiAgICB9XG4gIH1cblxuICAvLyBHZW5lcmF0ZXMgYSA0LWJpdCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHBvaW50IHJlbGF0aXZlIHRvXG4gIC8vIHRoZSBzbWFsbCBjaXJjbGUncyBib3VuZGluZyBib3guXG4gIGZ1bmN0aW9uIGNvZGUobGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgciA9IHNtYWxsUmFkaXVzID8gcmFkaXVzIDogcGkgLSByYWRpdXMsXG4gICAgICAgIGNvZGUgPSAwO1xuICAgIGlmIChsYW1iZGEgPCAtcikgY29kZSB8PSAxOyAvLyBsZWZ0XG4gICAgZWxzZSBpZiAobGFtYmRhID4gcikgY29kZSB8PSAyOyAvLyByaWdodFxuICAgIGlmIChwaGkgPCAtcikgY29kZSB8PSA0OyAvLyBiZWxvd1xuICAgIGVsc2UgaWYgKHBoaSA+IHIpIGNvZGUgfD0gODsgLy8gYWJvdmVcbiAgICByZXR1cm4gY29kZTtcbiAgfVxuXG4gIHJldHVybiBjbGlwKHZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc21hbGxSYWRpdXMgPyBbMCwgLXJhZGl1c10gOiBbLXBpLCByYWRpdXMgLSBwaV0pO1xufVxuIiwiaW1wb3J0IGNsaXBCdWZmZXIgZnJvbSBcIi4vYnVmZmVyLmpzXCI7XG5pbXBvcnQgY2xpcFJlam9pbiBmcm9tIFwiLi9yZWpvaW4uanNcIjtcbmltcG9ydCB7ZXBzaWxvbiwgaGFsZlBpfSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHBvbHlnb25Db250YWlucyBmcm9tIFwiLi4vcG9seWdvbkNvbnRhaW5zLmpzXCI7XG5pbXBvcnQge21lcmdlfSBmcm9tIFwiZDMtYXJyYXlcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHN0YXJ0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzaW5rKSB7XG4gICAgdmFyIGxpbmUgPSBjbGlwTGluZShzaW5rKSxcbiAgICAgICAgcmluZ0J1ZmZlciA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgcmluZ1NpbmsgPSBjbGlwTGluZShyaW5nQnVmZmVyKSxcbiAgICAgICAgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgcG9seWdvbixcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHJpbmc7XG5cbiAgICB2YXIgY2xpcCA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludFJpbmc7XG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGNsaXAubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIHNlZ21lbnRzID0gbWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uQ29udGFpbnMocG9seWdvbiwgc3RhcnQpO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc2luayk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRJbnNpZGUpIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgc2luay5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICBpZiAocG9pbnRWaXNpYmxlKGxhbWJkYSwgcGhpKSkgc2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKGxhbWJkYSwgcGhpKSB7XG4gICAgICBsaW5lLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBjbGlwLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgICAgbGluZS5saW5lU3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgbGluZS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRSaW5nKGxhbWJkYSwgcGhpKSB7XG4gICAgICByaW5nLnB1c2goW2xhbWJkYSwgcGhpXSk7XG4gICAgICByaW5nU2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgcmluZ1NpbmsubGluZVN0YXJ0KCk7XG4gICAgICByaW5nID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgIHBvaW50UmluZyhyaW5nWzBdWzBdLCByaW5nWzBdWzFdKTtcbiAgICAgIHJpbmdTaW5rLmxpbmVFbmQoKTtcblxuICAgICAgdmFyIGNsZWFuID0gcmluZ1NpbmsuY2xlYW4oKSxcbiAgICAgICAgICByaW5nU2VnbWVudHMgPSByaW5nQnVmZmVyLnJlc3VsdCgpLFxuICAgICAgICAgIGksIG4gPSByaW5nU2VnbWVudHMubGVuZ3RoLCBtLFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgcG9pbnQ7XG5cbiAgICAgIHJpbmcucG9wKCk7XG4gICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgICByaW5nID0gbnVsbDtcblxuICAgICAgaWYgKCFuKSByZXR1cm47XG5cbiAgICAgIC8vIE5vIGludGVyc2VjdGlvbnMuXG4gICAgICBpZiAoY2xlYW4gJiAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSByaW5nU2VnbWVudHNbMF07XG4gICAgICAgIGlmICgobSA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPiAwKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc2luay5wb2ludCgocG9pbnQgPSBzZWdtZW50W2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVqb2luIGNvbm5lY3RlZCBzZWdtZW50cy5cbiAgICAgIC8vIFRPRE8gcmV1c2UgcmluZ0J1ZmZlci5yZWpvaW4oKT9cbiAgICAgIGlmIChuID4gMSAmJiBjbGVhbiAmIDIpIHJpbmdTZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5wb3AoKS5jb25jYXQocmluZ1NlZ21lbnRzLnNoaWZ0KCkpKTtcblxuICAgICAgc2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMuZmlsdGVyKHZhbGlkU2VnbWVudCkpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudC5sZW5ndGggPiAxO1xufVxuXG4vLyBJbnRlcnNlY3Rpb25zIGFyZSBzb3J0ZWQgYWxvbmcgdGhlIGNsaXAgZWRnZS4gRm9yIGJvdGggYW50aW1lcmlkaWFuIGN1dHRpbmdcbi8vIGFuZCBjaXJjbGUgY2xpcHBpbmcsIHRoZSBzYW1lIGNvbXBhcmlzb24gaXMgdXNlZC5cbmZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICByZXR1cm4gKChhID0gYS54KVswXSA8IDAgPyBhWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGFbMV0pXG4gICAgICAgLSAoKGIgPSBiLngpWzBdIDwgMCA/IGJbMV0gLSBoYWxmUGkgLSBlcHNpbG9uIDogaGFsZlBpIC0gYlsxXSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiLCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgdDAgPSAwLFxuICAgICAgdDEgPSAxLFxuICAgICAgZHggPSBieCAtIGF4LFxuICAgICAgZHkgPSBieSAtIGF5LFxuICAgICAgcjtcblxuICByID0geDAgLSBheDtcbiAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHgxIC0gYXg7XG4gIGlmICghZHggJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIHIgPSB5MCAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geTEgLSBheTtcbiAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgaWYgKHQwID4gMCkgYVswXSA9IGF4ICsgdDAgKiBkeCwgYVsxXSA9IGF5ICsgdDAgKiBkeTtcbiAgaWYgKHQxIDwgMSkgYlswXSA9IGF4ICsgdDEgKiBkeCwgYlsxXSA9IGF5ICsgdDEgKiBkeTtcbiAgcmV0dXJuIHRydWU7XG59XG4iLCJpbXBvcnQge2FicywgZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBjbGlwQnVmZmVyIGZyb20gXCIuL2J1ZmZlci5qc1wiO1xuaW1wb3J0IGNsaXBMaW5lIGZyb20gXCIuL2xpbmUuanNcIjtcbmltcG9ydCBjbGlwUmVqb2luIGZyb20gXCIuL3Jlam9pbi5qc1wiO1xuaW1wb3J0IHttZXJnZX0gZnJvbSBcImQzLWFycmF5XCI7XG5cbnZhciBjbGlwTWF4ID0gMWU5LCBjbGlwTWluID0gLWNsaXBNYXg7XG5cbi8vIFRPRE8gVXNlIGQzLXBvbHlnb27igJlzIHBvbHlnb25Db250YWlucyBoZXJlIGZvciB0aGUgcmluZyBjaGVjaz9cbi8vIFRPRE8gRWxpbWluYXRlIGR1cGxpY2F0ZSBidWZmZXJpbmcgaW4gY2xpcEJ1ZmZlciBhbmQgcG9seWdvbi5wdXNoP1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjbGlwUmVjdGFuZ2xlKHgwLCB5MCwgeDEsIHkxKSB7XG5cbiAgZnVuY3Rpb24gdmlzaWJsZSh4LCB5KSB7XG4gICAgcmV0dXJuIHgwIDw9IHggJiYgeCA8PSB4MSAmJiB5MCA8PSB5ICYmIHkgPD0geTE7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICB2YXIgYSA9IDAsIGExID0gMDtcbiAgICBpZiAoZnJvbSA9PSBudWxsXG4gICAgICAgIHx8IChhID0gY29ybmVyKGZyb20sIGRpcmVjdGlvbikpICE9PSAoYTEgPSBjb3JuZXIodG8sIGRpcmVjdGlvbikpXG4gICAgICAgIHx8IGNvbXBhcmVQb2ludChmcm9tLCB0bykgPCAwIF4gZGlyZWN0aW9uID4gMCkge1xuICAgICAgZG8gc3RyZWFtLnBvaW50KGEgPT09IDAgfHwgYSA9PT0gMyA/IHgwIDogeDEsIGEgPiAxID8geTEgOiB5MCk7XG4gICAgICB3aGlsZSAoKGEgPSAoYSArIGRpcmVjdGlvbiArIDQpICUgNCkgIT09IGExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29ybmVyKHAsIGRpcmVjdGlvbikge1xuICAgIHJldHVybiBhYnMocFswXSAtIHgwKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMCA6IDNcbiAgICAgICAgOiBhYnMocFswXSAtIHgxKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMiA6IDFcbiAgICAgICAgOiBhYnMocFsxXSAtIHkwKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMSA6IDBcbiAgICAgICAgOiBkaXJlY3Rpb24gPiAwID8gMyA6IDI7IC8vIGFicyhwWzFdIC0geTEpIDwgZXBzaWxvblxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVQb2ludChhLngsIGIueCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlUG9pbnQoYSwgYikge1xuICAgIHZhciBjYSA9IGNvcm5lcihhLCAxKSxcbiAgICAgICAgY2IgPSBjb3JuZXIoYiwgMSk7XG4gICAgcmV0dXJuIGNhICE9PSBjYiA/IGNhIC0gY2JcbiAgICAgICAgOiBjYSA9PT0gMCA/IGJbMV0gLSBhWzFdXG4gICAgICAgIDogY2EgPT09IDEgPyBhWzBdIC0gYlswXVxuICAgICAgICA6IGNhID09PSAyID8gYVsxXSAtIGJbMV1cbiAgICAgICAgOiBiWzBdIC0gYVswXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgYWN0aXZlU3RyZWFtID0gc3RyZWFtLFxuICAgICAgICBidWZmZXJTdHJlYW0gPSBjbGlwQnVmZmVyKCksXG4gICAgICAgIHNlZ21lbnRzLFxuICAgICAgICBwb2x5Z29uLFxuICAgICAgICByaW5nLFxuICAgICAgICB4X18sIHlfXywgdl9fLCAvLyBmaXJzdCBwb2ludFxuICAgICAgICB4XywgeV8sIHZfLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICBmaXJzdCxcbiAgICAgICAgY2xlYW47XG5cbiAgICB2YXIgY2xpcFN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogcG9seWdvblN0YXJ0LFxuICAgICAgcG9seWdvbkVuZDogcG9seWdvbkVuZFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICBpZiAodmlzaWJsZSh4LCB5KSkgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb25JbnNpZGUoKSB7XG4gICAgICB2YXIgd2luZGluZyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgcmluZyA9IHBvbHlnb25baV0sIGogPSAxLCBtID0gcmluZy5sZW5ndGgsIHBvaW50ID0gcmluZ1swXSwgYTAsIGExLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgYTAgPSBiMCwgYTEgPSBiMSwgcG9pbnQgPSByaW5nW2pdLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdO1xuICAgICAgICAgIGlmIChhMSA8PSB5MSkgeyBpZiAoYjEgPiB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPiAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpICsrd2luZGluZzsgfVxuICAgICAgICAgIGVsc2UgeyBpZiAoYjEgPD0geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpIDwgKGIxIC0gYTEpICogKHgwIC0gYTApKSAtLXdpbmRpbmc7IH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2luZGluZztcbiAgICB9XG5cbiAgICAvLyBCdWZmZXIgZ2VvbWV0cnkgd2l0aGluIGEgcG9seWdvbiBhbmQgdGhlbiBjbGlwIGl0IGVuIG1hc3NlLlxuICAgIGZ1bmN0aW9uIHBvbHlnb25TdGFydCgpIHtcbiAgICAgIGFjdGl2ZVN0cmVhbSA9IGJ1ZmZlclN0cmVhbSwgc2VnbWVudHMgPSBbXSwgcG9seWdvbiA9IFtdLCBjbGVhbiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbkVuZCgpIHtcbiAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25JbnNpZGUoKSxcbiAgICAgICAgICBjbGVhbkluc2lkZSA9IGNsZWFuICYmIHN0YXJ0SW5zaWRlLFxuICAgICAgICAgIHZpc2libGUgPSAoc2VnbWVudHMgPSBtZXJnZShzZWdtZW50cykpLmxlbmd0aDtcbiAgICAgIGlmIChjbGVhbkluc2lkZSB8fCB2aXNpYmxlKSB7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgaWYgKGNsZWFuSW5zaWRlKSB7XG4gICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHN0cmVhbSk7XG4gICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgICAgYWN0aXZlU3RyZWFtID0gc3RyZWFtLCBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgdl8gPSBmYWxzZTtcbiAgICAgIHhfID0geV8gPSBOYU47XG4gICAgfVxuXG4gICAgLy8gVE9ETyByYXRoZXIgdGhhbiBzcGVjaWFsLWNhc2UgcG9seWdvbnMsIHNpbXBseSBoYW5kbGUgdGhlbSBzZXBhcmF0ZWx5LlxuICAgIC8vIElkZWFsbHksIGNvaW5jaWRlbnQgaW50ZXJzZWN0aW9uIHBvaW50cyBzaG91bGQgYmUgaml0dGVyZWQgdG8gYXZvaWRcbiAgICAvLyBjbGlwcGluZyBpc3N1ZXMuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICBpZiAodl9fICYmIHZfKSBidWZmZXJTdHJlYW0ucmVqb2luKCk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyU3RyZWFtLnJlc3VsdCgpKTtcbiAgICAgIH1cbiAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIGlmICh2XykgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgdmFyIHYgPSB2aXNpYmxlKHgsIHkpO1xuICAgICAgaWYgKHBvbHlnb24pIHJpbmcucHVzaChbeCwgeV0pO1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgJiYgdl8pIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGEgPSBbeF8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4XykpLCB5XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHlfKSldLFxuICAgICAgICAgICAgICBiID0gW3ggPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4KSksIHkgPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5KSldO1xuICAgICAgICAgIGlmIChjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkpIHtcbiAgICAgICAgICAgIGlmICghdl8pIHtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYVswXSwgYVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYlswXSwgYlsxXSk7XG4gICAgICAgICAgICBpZiAoIXYpIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodikge1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBTdHJlYW07XG4gIH07XG59XG4iLCJpbXBvcnQgcG9pbnRFcXVhbCBmcm9tIFwiLi4vcG9pbnRFcXVhbC5qc1wiO1xuaW1wb3J0IHtlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBJbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gIHRoaXMueCA9IHBvaW50O1xuICB0aGlzLnogPSBwb2ludHM7XG4gIHRoaXMubyA9IG90aGVyOyAvLyBhbm90aGVyIGludGVyc2VjdGlvblxuICB0aGlzLmUgPSBlbnRyeTsgLy8gaXMgYW4gZW50cnk/XG4gIHRoaXMudiA9IGZhbHNlOyAvLyB2aXNpdGVkXG4gIHRoaXMubiA9IHRoaXMucCA9IG51bGw7IC8vIG5leHQgJiBwcmV2aW91c1xufVxuXG4vLyBBIGdlbmVyYWxpemVkIHBvbHlnb24gY2xpcHBpbmcgYWxnb3JpdGhtOiBnaXZlbiBhIHBvbHlnb24gdGhhdCBoYXMgYmVlbiBjdXRcbi8vIGludG8gaXRzIHZpc2libGUgbGluZSBzZWdtZW50cywgYW5kIHJlam9pbnMgdGhlIHNlZ21lbnRzIGJ5IGludGVycG9sYXRpbmdcbi8vIGFsb25nIHRoZSBjbGlwIGVkZ2UuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzdHJlYW0pIHtcbiAgdmFyIHN1YmplY3QgPSBbXSxcbiAgICAgIGNsaXAgPSBbXSxcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgIGlmICgobiA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPD0gMCkgcmV0dXJuO1xuICAgIHZhciBuLCBwMCA9IHNlZ21lbnRbMF0sIHAxID0gc2VnbWVudFtuXSwgeDtcblxuICAgIGlmIChwb2ludEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgIGlmICghcDBbMl0gJiYgIXAxWzJdKSB7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgc3RyZWFtLnBvaW50KChwMCA9IHNlZ21lbnRbaV0pWzBdLCBwMFsxXSk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBkZWdlbmVyYXRlIGNhc2VzIGJ5IG1vdmluZyB0aGUgcG9pbnRcbiAgICAgIHAxWzBdICs9IDIgKiBlcHNpbG9uO1xuICAgIH1cblxuICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSkpO1xuICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBudWxsLCB4LCBmYWxzZSkpO1xuICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMSwgc2VnbWVudCwgbnVsbCwgZmFsc2UpKTtcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMSwgbnVsbCwgeCwgdHJ1ZSkpO1xuICB9KTtcblxuICBpZiAoIXN1YmplY3QubGVuZ3RoKSByZXR1cm47XG5cbiAgY2xpcC5zb3J0KGNvbXBhcmVJbnRlcnNlY3Rpb24pO1xuICBsaW5rKHN1YmplY3QpO1xuICBsaW5rKGNsaXApO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBjbGlwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNsaXBbaV0uZSA9IHN0YXJ0SW5zaWRlID0gIXN0YXJ0SW5zaWRlO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSxcbiAgICAgIHBvaW50cyxcbiAgICAgIHBvaW50O1xuXG4gIHdoaWxlICgxKSB7XG4gICAgLy8gRmluZCBmaXJzdCB1bnZpc2l0ZWQgaW50ZXJzZWN0aW9uLlxuICAgIHZhciBjdXJyZW50ID0gc3RhcnQsXG4gICAgICAgIGlzU3ViamVjdCA9IHRydWU7XG4gICAgd2hpbGUgKGN1cnJlbnQudikgaWYgKChjdXJyZW50ID0gY3VycmVudC5uKSA9PT0gc3RhcnQpIHJldHVybjtcbiAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnQudiA9IGN1cnJlbnQuby52ID0gdHJ1ZTtcbiAgICAgIGlmIChjdXJyZW50LmUpIHtcbiAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICBmb3IgKGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm87XG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICBpc1N1YmplY3QgPSAhaXNTdWJqZWN0O1xuICAgIH0gd2hpbGUgKCFjdXJyZW50LnYpO1xuICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGluayhhcnJheSkge1xuICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgYSA9IGFycmF5WzBdLFxuICAgICAgYjtcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBhLm4gPSBiID0gYXJyYXlbaV07XG4gICAgYi5wID0gYTtcbiAgICBhID0gYjtcbiAgfVxuICBhLm4gPSBiID0gYXJyYXlbMF07XG4gIGIucCA9IGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG5cbiAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBhKHgsIHkpLCBiKHhbMF0sIHhbMV0pO1xuICB9XG5cbiAgaWYgKGEuaW52ZXJ0ICYmIGIuaW52ZXJ0KSBjb21wb3NlLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA9IGIuaW52ZXJ0KHgsIHkpLCB4ICYmIGEuaW52ZXJ0KHhbMF0sIHhbMV0pO1xuICB9O1xuXG4gIHJldHVybiBjb21wb3NlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQge3JhbmdlfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7YWJzLCBjZWlsLCBlcHNpbG9ufSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZVgoeTAsIHkxLCBkeSkge1xuICB2YXIgeSA9IHJhbmdlKHkwLCB5MSAtIGVwc2lsb24sIGR5KS5jb25jYXQoeTEpO1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4geS5tYXAoZnVuY3Rpb24oeSkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbn1cblxuZnVuY3Rpb24gZ3JhdGljdWxlWSh4MCwgeDEsIGR4KSB7XG4gIHZhciB4ID0gcmFuZ2UoeDAsIHgxIC0gZXBzaWxvbiwgZHgpLmNvbmNhdCh4MSk7XG4gIHJldHVybiBmdW5jdGlvbih5KSB7IHJldHVybiB4Lm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBbeCwgeV07IH0pOyB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gIHZhciB4MSwgeDAsIFgxLCBYMCxcbiAgICAgIHkxLCB5MCwgWTEsIFkwLFxuICAgICAgZHggPSAxMCwgZHkgPSBkeCwgRFggPSA5MCwgRFkgPSAzNjAsXG4gICAgICB4LCB5LCBYLCBZLFxuICAgICAgcHJlY2lzaW9uID0gMi41O1xuXG4gIGZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcbiAgICByZXR1cm4ge3R5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBsaW5lcygpfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgIHJldHVybiByYW5nZShjZWlsKFgwIC8gRFgpICogRFgsIFgxLCBEWCkubWFwKFgpXG4gICAgICAgIC5jb25jYXQocmFuZ2UoY2VpbChZMCAvIERZKSAqIERZLCBZMSwgRFkpLm1hcChZKSlcbiAgICAgICAgLmNvbmNhdChyYW5nZShjZWlsKHgwIC8gZHgpICogZHgsIHgxLCBkeCkuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGFicyh4ICUgRFgpID4gZXBzaWxvbjsgfSkubWFwKHgpKVxuICAgICAgICAuY29uY2F0KHJhbmdlKGNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24oeSkgeyByZXR1cm4gYWJzKHkgJSBEWSkgPiBlcHNpbG9uOyB9KS5tYXAoeSkpO1xuICB9XG5cbiAgZ3JhdGljdWxlLmxpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpbmVzKCkubWFwKGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7IHJldHVybiB7dHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307IH0pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5vdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgWChYMCkuY29uY2F0KFxuICAgICAgICBZKFkxKS5zbGljZSgxKSxcbiAgICAgICAgWChYMSkucmV2ZXJzZSgpLnNsaWNlKDEpLFxuICAgICAgICBZKFkwKS5yZXZlcnNlKCkuc2xpY2UoMSkpXG4gICAgICBdXG4gICAgfTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNaW5vcigpO1xuICAgIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWFqb3IoXykuZXh0ZW50TWlub3IoXyk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudE1ham9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtbWDAsIFkwXSwgW1gxLCBZMV1dO1xuICAgIFgwID0gK19bMF1bMF0sIFgxID0gK19bMV1bMF07XG4gICAgWTAgPSArX1swXVsxXSwgWTEgPSArX1sxXVsxXTtcbiAgICBpZiAoWDAgPiBYMSkgXyA9IFgwLCBYMCA9IFgxLCBYMSA9IF87XG4gICAgaWYgKFkwID4gWTEpIF8gPSBZMCwgWTAgPSBZMSwgWTEgPSBfO1xuICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudE1pbm9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgIHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF07XG4gICAgeTAgPSArX1swXVsxXSwgeTEgPSArX1sxXVsxXTtcbiAgICBpZiAoeDAgPiB4MSkgXyA9IHgwLCB4MCA9IHgxLCB4MSA9IF87XG4gICAgaWYgKHkwID4geTEpIF8gPSB5MCwgeTAgPSB5MSwgeTEgPSBfO1xuICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNaW5vcigpO1xuICAgIHJldHVybiBncmF0aWN1bGUuc3RlcE1ham9yKF8pLnN0ZXBNaW5vcihfKTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcE1ham9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtEWCwgRFldO1xuICAgIERYID0gK19bMF0sIERZID0gK19bMV07XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcE1pbm9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtkeCwgZHldO1xuICAgIGR4ID0gK19bMF0sIGR5ID0gK19bMV07XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICBncmF0aWN1bGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICBwcmVjaXNpb24gPSArXztcbiAgICB4ID0gZ3JhdGljdWxlWCh5MCwgeTEsIDkwKTtcbiAgICB5ID0gZ3JhdGljdWxlWSh4MCwgeDEsIHByZWNpc2lvbik7XG4gICAgWCA9IGdyYXRpY3VsZVgoWTAsIFkxLCA5MCk7XG4gICAgWSA9IGdyYXRpY3VsZVkoWDAsIFgxLCBwcmVjaXNpb24pO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgcmV0dXJuIGdyYXRpY3VsZVxuICAgICAgLmV4dGVudE1ham9yKFtbLTE4MCwgLTkwICsgZXBzaWxvbl0sIFsxODAsIDkwIC0gZXBzaWxvbl1dKVxuICAgICAgLmV4dGVudE1pbm9yKFtbLTE4MCwgLTgwIC0gZXBzaWxvbl0sIFsxODAsIDgwICsgZXBzaWxvbl1dKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXRpY3VsZTEwKCkge1xuICByZXR1cm4gZ3JhdGljdWxlKCkoKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4geDtcbiIsImV4cG9ydCB2YXIgZXBzaWxvbiA9IDFlLTY7XG5leHBvcnQgdmFyIGVwc2lsb24yID0gMWUtMTI7XG5leHBvcnQgdmFyIHBpID0gTWF0aC5QSTtcbmV4cG9ydCB2YXIgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IHZhciBxdWFydGVyUGkgPSBwaSAvIDQ7XG5leHBvcnQgdmFyIHRhdSA9IHBpICogMjtcblxuZXhwb3J0IHZhciBkZWdyZWVzID0gMTgwIC8gcGk7XG5leHBvcnQgdmFyIHJhZGlhbnMgPSBwaSAvIDE4MDtcblxuZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbmV4cG9ydCB2YXIgZXhwID0gTWF0aC5leHA7XG5leHBvcnQgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbmV4cG9ydCB2YXIgaHlwb3QgPSBNYXRoLmh5cG90O1xuZXhwb3J0IHZhciBsb2cgPSBNYXRoLmxvZztcbmV4cG9ydCB2YXIgcG93ID0gTWF0aC5wb3c7XG5leHBvcnQgdmFyIHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IHZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xuZXhwb3J0IHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuZXhwb3J0IHZhciB0YW4gPSBNYXRoLnRhbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhdmVyc2luKHgpIHtcbiAgcmV0dXJuICh4ID0gc2luKHggLyAyKSkgKiB4O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7YWJzfSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxudmFyIGFyZWFTdW0gPSBuZXcgQWRkZXIoKSxcbiAgICBhcmVhUmluZ1N1bSA9IG5ldyBBZGRlcigpLFxuICAgIHgwMCxcbiAgICB5MDAsXG4gICAgeDAsXG4gICAgeTA7XG5cbnZhciBhcmVhU3RyZWFtID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBub29wLFxuICBsaW5lRW5kOiBub29wLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydDtcbiAgICBhcmVhU3RyZWFtLmxpbmVFbmQgPSBhcmVhUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN0cmVhbS5saW5lU3RhcnQgPSBhcmVhU3RyZWFtLmxpbmVFbmQgPSBhcmVhU3RyZWFtLnBvaW50ID0gbm9vcDtcbiAgICBhcmVhU3VtLmFkZChhYnMoYXJlYVJpbmdTdW0pKTtcbiAgICBhcmVhUmluZ1N1bSA9IG5ldyBBZGRlcigpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmVhID0gYXJlYVN1bSAvIDI7XG4gICAgYXJlYVN1bSA9IG5ldyBBZGRlcigpO1xuICAgIHJldHVybiBhcmVhO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcmVhUmluZ1N0YXJ0KCkge1xuICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0KHgsIHkpIHtcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludDtcbiAgeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHk7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludCh4LCB5KSB7XG4gIGFyZWFSaW5nU3VtLmFkZCh5MCAqIHggLSB4MCAqIHkpO1xuICB4MCA9IHgsIHkwID0geTtcbn1cblxuZnVuY3Rpb24gYXJlYVJpbmdFbmQoKSB7XG4gIGFyZWFQb2ludCh4MDAsIHkwMCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFyZWFTdHJlYW07XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG52YXIgeDAgPSBJbmZpbml0eSxcbiAgICB5MCA9IHgwLFxuICAgIHgxID0gLXgwLFxuICAgIHkxID0geDE7XG5cbnZhciBib3VuZHNTdHJlYW0gPSB7XG4gIHBvaW50OiBib3VuZHNQb2ludCxcbiAgbGluZVN0YXJ0OiBub29wLFxuICBsaW5lRW5kOiBub29wLFxuICBwb2x5Z29uU3RhcnQ6IG5vb3AsXG4gIHBvbHlnb25FbmQ6IG5vb3AsXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvdW5kcyA9IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgIHgxID0geTEgPSAtKHkwID0geDAgPSBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxufTtcblxuZnVuY3Rpb24gYm91bmRzUG9pbnQoeCwgeSkge1xuICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gIGlmICh4ID4geDEpIHgxID0geDtcbiAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICBpZiAoeSA+IHkxKSB5MSA9IHk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJvdW5kc1N0cmVhbTtcbiIsImltcG9ydCB7c3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuLy8gVE9ETyBFbmZvcmNlIHBvc2l0aXZlIGFyZWEgZm9yIGV4dGVyaW9yLCBuZWdhdGl2ZSBhcmVhIGZvciBpbnRlcmlvcj9cblxudmFyIFgwID0gMCxcbiAgICBZMCA9IDAsXG4gICAgWjAgPSAwLFxuICAgIFgxID0gMCxcbiAgICBZMSA9IDAsXG4gICAgWjEgPSAwLFxuICAgIFgyID0gMCxcbiAgICBZMiA9IDAsXG4gICAgWjIgPSAwLFxuICAgIHgwMCxcbiAgICB5MDAsXG4gICAgeDAsXG4gICAgeTA7XG5cbnZhciBjZW50cm9pZFN0cmVhbSA9IHtcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQsXG4gIGxpbmVTdGFydDogY2VudHJvaWRMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZFJpbmdTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZDtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2VudHJvaWQgPSBaMiA/IFtYMiAvIFoyLCBZMiAvIFoyXVxuICAgICAgICA6IFoxID8gW1gxIC8gWjEsIFkxIC8gWjFdXG4gICAgICAgIDogWjAgPyBbWDAgLyBaMCwgWTAgLyBaMF1cbiAgICAgICAgOiBbTmFOLCBOYU5dO1xuICAgIFgwID0gWTAgPSBaMCA9XG4gICAgWDEgPSBZMSA9IFoxID1cbiAgICBYMiA9IFkyID0gWjIgPSAwO1xuICAgIHJldHVybiBjZW50cm9pZDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludCh4LCB5KSB7XG4gIFgwICs9IHg7XG4gIFkwICs9IHk7XG4gICsrWjA7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnRGaXJzdExpbmU7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdExpbmUoeCwgeSkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnRMaW5lO1xuICBjZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludExpbmUoeCwgeSkge1xuICB2YXIgZHggPSB4IC0geDAsIGR5ID0geSAtIHkwLCB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gIFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gIFoxICs9IHo7XG4gIGNlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVFbmQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0UmluZztcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kKCkge1xuICBjZW50cm9pZFBvaW50UmluZyh4MDAsIHkwMCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdFJpbmcoeCwgeSkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnRSaW5nO1xuICBjZW50cm9pZFBvaW50KHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5KTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludFJpbmcoeCwgeSkge1xuICB2YXIgZHggPSB4IC0geDAsXG4gICAgICBkeSA9IHkgLSB5MCxcbiAgICAgIHogPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICBYMSArPSB6ICogKHgwICsgeCkgLyAyO1xuICBZMSArPSB6ICogKHkwICsgeSkgLyAyO1xuICBaMSArPSB6O1xuXG4gIHogPSB5MCAqIHggLSB4MCAqIHk7XG4gIFgyICs9IHogKiAoeDAgKyB4KTtcbiAgWTIgKz0geiAqICh5MCArIHkpO1xuICBaMiArPSB6ICogMztcbiAgY2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNlbnRyb2lkU3RyZWFtO1xuIiwiaW1wb3J0IHt0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYXRoQ29udGV4dChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5QYXRoQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gIF9yYWRpdXM6IDQuNSxcbiAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gdGhpcy5fcmFkaXVzID0gXywgdGhpcztcbiAgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lID09PSAwKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX3BvaW50ID0gTmFOO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHggKyB0aGlzLl9yYWRpdXMsIHkpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmFyYyh4LCB5LCB0aGlzLl9yYWRpdXMsIDAsIHRhdSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVzdWx0OiBub29wXG59O1xuIiwiaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuLi9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHN0cmVhbSBmcm9tIFwiLi4vc3RyZWFtLmpzXCI7XG5pbXBvcnQgcGF0aEFyZWEgZnJvbSBcIi4vYXJlYS5qc1wiO1xuaW1wb3J0IHBhdGhCb3VuZHMgZnJvbSBcIi4vYm91bmRzLmpzXCI7XG5pbXBvcnQgcGF0aENlbnRyb2lkIGZyb20gXCIuL2NlbnRyb2lkLmpzXCI7XG5pbXBvcnQgUGF0aENvbnRleHQgZnJvbSBcIi4vY29udGV4dC5qc1wiO1xuaW1wb3J0IHBhdGhNZWFzdXJlIGZyb20gXCIuL21lYXN1cmUuanNcIjtcbmltcG9ydCBQYXRoU3RyaW5nIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwcm9qZWN0aW9uLCBjb250ZXh0KSB7XG4gIHZhciBwb2ludFJhZGl1cyA9IDQuNSxcbiAgICAgIHByb2plY3Rpb25TdHJlYW0sXG4gICAgICBjb250ZXh0U3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHBhdGgob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtwb2ludFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oY29udGV4dFN0cmVhbSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFN0cmVhbS5yZXN1bHQoKTtcbiAgfVxuXG4gIHBhdGguYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0ocGF0aEFyZWEpKTtcbiAgICByZXR1cm4gcGF0aEFyZWEucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5tZWFzdXJlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoTWVhc3VyZSkpO1xuICAgIHJldHVybiBwYXRoTWVhc3VyZS5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0ocGF0aEJvdW5kcykpO1xuICAgIHJldHVybiBwYXRoQm91bmRzLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGguY2VudHJvaWQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKHBhdGhDZW50cm9pZCkpO1xuICAgIHJldHVybiBwYXRoQ2VudHJvaWQucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3Rpb25TdHJlYW0gPSBfID09IG51bGwgPyAocHJvamVjdGlvbiA9IG51bGwsIGlkZW50aXR5KSA6IChwcm9qZWN0aW9uID0gXykuc3RyZWFtLCBwYXRoKSA6IHByb2plY3Rpb247XG4gIH07XG5cbiAgcGF0aC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgY29udGV4dFN0cmVhbSA9IF8gPT0gbnVsbCA/IChjb250ZXh0ID0gbnVsbCwgbmV3IFBhdGhTdHJpbmcpIDogbmV3IFBhdGhDb250ZXh0KGNvbnRleHQgPSBfKTtcbiAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMocG9pbnRSYWRpdXMpO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIHBhdGgucG9pbnRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcG9pbnRSYWRpdXM7XG4gICAgcG9pbnRSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IChjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtfKSwgK18pO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIHJldHVybiBwYXRoLnByb2plY3Rpb24ocHJvamVjdGlvbikuY29udGV4dChjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxudmFyIGxlbmd0aFN1bSA9IG5ldyBBZGRlcigpLFxuICAgIGxlbmd0aFJpbmcsXG4gICAgeDAwLFxuICAgIHkwMCxcbiAgICB4MCxcbiAgICB5MDtcblxudmFyIGxlbmd0aFN0cmVhbSA9IHtcbiAgcG9pbnQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoUG9pbnRGaXJzdDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKGxlbmd0aFJpbmcpIGxlbmd0aFBvaW50KHgwMCwgeTAwKTtcbiAgICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBub29wO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFJpbmcgPSB0cnVlO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhSaW5nID0gbnVsbDtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gK2xlbmd0aFN1bTtcbiAgICBsZW5ndGhTdW0gPSBuZXcgQWRkZXIoKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsZW5ndGhQb2ludEZpcnN0KHgsIHkpIHtcbiAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoUG9pbnQ7XG4gIHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5O1xufVxuXG5mdW5jdGlvbiBsZW5ndGhQb2ludCh4LCB5KSB7XG4gIHgwIC09IHgsIHkwIC09IHk7XG4gIGxlbmd0aFN1bS5hZGQoc3FydCh4MCAqIHgwICsgeTAgKiB5MCkpO1xuICB4MCA9IHgsIHkwID0geTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGVuZ3RoU3RyZWFtO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGF0aFN0cmluZygpIHtcbiAgdGhpcy5fc3RyaW5nID0gW107XG59XG5cblBhdGhTdHJpbmcucHJvdG90eXBlID0ge1xuICBfcmFkaXVzOiA0LjUsXG4gIF9jaXJjbGU6IGNpcmNsZSg0LjUpLFxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgIGlmICgoXyA9ICtfKSAhPT0gdGhpcy5fcmFkaXVzKSB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzLl9jaXJjbGUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgPT09IDApIHRoaXMuX3N0cmluZy5wdXNoKFwiWlwiKTtcbiAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIkxcIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX2NpcmNsZSA9PSBudWxsKSB0aGlzLl9jaXJjbGUgPSBjaXJjbGUodGhpcy5fcmFkaXVzKTtcbiAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5LCB0aGlzLl9jaXJjbGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3N0cmluZy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zdHJpbmcuam9pbihcIlwiKTtcbiAgICAgIHRoaXMuX3N0cmluZyA9IFtdO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjaXJjbGUocmFkaXVzKSB7XG4gIHJldHVybiBcIm0wLFwiICsgcmFkaXVzXG4gICAgICArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgLTIgKiByYWRpdXNcbiAgICAgICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAyICogcmFkaXVzXG4gICAgICArIFwielwiO1xufVxuIiwiaW1wb3J0IHthYnMsIGVwc2lsb259IGZyb20gXCIuL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYWJzKGFbMF0gLSBiWzBdKSA8IGVwc2lsb24gJiYgYWJzKGFbMV0gLSBiWzFdKSA8IGVwc2lsb247XG59XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Y2FydGVzaWFuLCBjYXJ0ZXNpYW5Dcm9zcywgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZX0gZnJvbSBcIi4vY2FydGVzaWFuLmpzXCI7XG5pbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgZXBzaWxvbjIsIGhhbGZQaSwgcGksIHF1YXJ0ZXJQaSwgc2lnbiwgc2luLCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcblxuZnVuY3Rpb24gbG9uZ2l0dWRlKHBvaW50KSB7XG4gIGlmIChhYnMocG9pbnRbMF0pIDw9IHBpKVxuICAgIHJldHVybiBwb2ludFswXTtcbiAgZWxzZVxuICAgIHJldHVybiBzaWduKHBvaW50WzBdKSAqICgoYWJzKHBvaW50WzBdKSArIHBpKSAlIHRhdSAtIHBpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocG9seWdvbiwgcG9pbnQpIHtcbiAgdmFyIGxhbWJkYSA9IGxvbmdpdHVkZShwb2ludCksXG4gICAgICBwaGkgPSBwb2ludFsxXSxcbiAgICAgIHNpblBoaSA9IHNpbihwaGkpLFxuICAgICAgbm9ybWFsID0gW3NpbihsYW1iZGEpLCAtY29zKGxhbWJkYSksIDBdLFxuICAgICAgYW5nbGUgPSAwLFxuICAgICAgd2luZGluZyA9IDA7XG5cbiAgdmFyIHN1bSA9IG5ldyBBZGRlcigpO1xuXG4gIGlmIChzaW5QaGkgPT09IDEpIHBoaSA9IGhhbGZQaSArIGVwc2lsb247XG4gIGVsc2UgaWYgKHNpblBoaSA9PT0gLTEpIHBoaSA9IC1oYWxmUGkgLSBlcHNpbG9uO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoIShtID0gKHJpbmcgPSBwb2x5Z29uW2ldKS5sZW5ndGgpKSBjb250aW51ZTtcbiAgICB2YXIgcmluZyxcbiAgICAgICAgbSxcbiAgICAgICAgcG9pbnQwID0gcmluZ1ttIC0gMV0sXG4gICAgICAgIGxhbWJkYTAgPSBsb25naXR1ZGUocG9pbnQwKSxcbiAgICAgICAgcGhpMCA9IHBvaW50MFsxXSAvIDIgKyBxdWFydGVyUGksXG4gICAgICAgIHNpblBoaTAgPSBzaW4ocGhpMCksXG4gICAgICAgIGNvc1BoaTAgPSBjb3MocGhpMCk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG07ICsraiwgbGFtYmRhMCA9IGxhbWJkYTEsIHNpblBoaTAgPSBzaW5QaGkxLCBjb3NQaGkwID0gY29zUGhpMSwgcG9pbnQwID0gcG9pbnQxKSB7XG4gICAgICB2YXIgcG9pbnQxID0gcmluZ1tqXSxcbiAgICAgICAgICBsYW1iZGExID0gbG9uZ2l0dWRlKHBvaW50MSksXG4gICAgICAgICAgcGhpMSA9IHBvaW50MVsxXSAvIDIgKyBxdWFydGVyUGksXG4gICAgICAgICAgc2luUGhpMSA9IHNpbihwaGkxKSxcbiAgICAgICAgICBjb3NQaGkxID0gY29zKHBoaTEpLFxuICAgICAgICAgIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsXG4gICAgICAgICAgc2lnbiA9IGRlbHRhID49IDAgPyAxIDogLTEsXG4gICAgICAgICAgYWJzRGVsdGEgPSBzaWduICogZGVsdGEsXG4gICAgICAgICAgYW50aW1lcmlkaWFuID0gYWJzRGVsdGEgPiBwaSxcbiAgICAgICAgICBrID0gc2luUGhpMCAqIHNpblBoaTE7XG5cbiAgICAgIHN1bS5hZGQoYXRhbjIoayAqIHNpZ24gKiBzaW4oYWJzRGVsdGEpLCBjb3NQaGkwICogY29zUGhpMSArIGsgKiBjb3MoYWJzRGVsdGEpKSk7XG4gICAgICBhbmdsZSArPSBhbnRpbWVyaWRpYW4gPyBkZWx0YSArIHNpZ24gKiB0YXUgOiBkZWx0YTtcblxuICAgICAgLy8gQXJlIHRoZSBsb25naXR1ZGVzIGVpdGhlciBzaWRlIG9mIHRoZSBwb2ludOKAmXMgbWVyaWRpYW4gKGxhbWJkYSksXG4gICAgICAvLyBhbmQgYXJlIHRoZSBsYXRpdHVkZXMgc21hbGxlciB0aGFuIHRoZSBwYXJhbGxlbCAocGhpKT9cbiAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiBsYW1iZGEwID49IGxhbWJkYSBeIGxhbWJkYTEgPj0gbGFtYmRhKSB7XG4gICAgICAgIHZhciBhcmMgPSBjYXJ0ZXNpYW5Dcm9zcyhjYXJ0ZXNpYW4ocG9pbnQwKSwgY2FydGVzaWFuKHBvaW50MSkpO1xuICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGFyYyk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhub3JtYWwsIGFyYyk7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgdmFyIHBoaUFyYyA9IChhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gLTEgOiAxKSAqIGFzaW4oaW50ZXJzZWN0aW9uWzJdKTtcbiAgICAgICAgaWYgKHBoaSA+IHBoaUFyYyB8fCBwaGkgPT09IHBoaUFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcbiAgICAgICAgICB3aW5kaW5nICs9IGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCwgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIFNvdXRoIHBvbGUgaXMgaW5zaWRlIG9yIG91dHNpZGU6XG4gIC8vXG4gIC8vIEl0IGlzIGluc2lkZSBpZjpcbiAgLy8gKiB0aGUgcG9seWdvbiB3aW5kcyBhcm91bmQgaXQgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uLlxuICAvLyAqIHRoZSBwb2x5Z29uIGRvZXMgbm90IChjdW11bGF0aXZlbHkpIHdpbmQgYXJvdW5kIGl0LCBidXQgaGFzIGEgbmVnYXRpdmVcbiAgLy8gICAoY291bnRlci1jbG9ja3dpc2UpIGFyZWEuXG4gIC8vXG4gIC8vIFNlY29uZCwgY291bnQgdGhlIChzaWduZWQpIG51bWJlciBvZiB0aW1lcyBhIHNlZ21lbnQgY3Jvc3NlcyBhIGxhbWJkYVxuICAvLyBmcm9tIHRoZSBwb2ludCB0byB0aGUgU291dGggcG9sZS4gIElmIGl0IGlzIHplcm8sIHRoZW4gdGhlIHBvaW50IGlzIHRoZVxuICAvLyBzYW1lIHNpZGUgYXMgdGhlIFNvdXRoIHBvbGUuXG5cbiAgcmV0dXJuIChhbmdsZSA8IC1lcHNpbG9uIHx8IGFuZ2xlIDwgZXBzaWxvbiAmJiBzdW0gPCAtZXBzaWxvbjIpIF4gKHdpbmRpbmcgJiAxKTtcbn1cbiIsImltcG9ydCBjb25pY0VxdWFsQXJlYSBmcm9tIFwiLi9jb25pY0VxdWFsQXJlYS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNvbmljRXF1YWxBcmVhKClcbiAgICAgIC5wYXJhbGxlbHMoWzI5LjUsIDQ1LjVdKVxuICAgICAgLnNjYWxlKDEwNzApXG4gICAgICAudHJhbnNsYXRlKFs0ODAsIDI1MF0pXG4gICAgICAucm90YXRlKFs5NiwgMF0pXG4gICAgICAuY2VudGVyKFstMC42LCAzOC43XSk7XG59XG4iLCJpbXBvcnQge2Vwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgYWxiZXJzIGZyb20gXCIuL2FsYmVycy5qc1wiO1xuaW1wb3J0IGNvbmljRXF1YWxBcmVhIGZyb20gXCIuL2NvbmljRXF1YWxBcmVhLmpzXCI7XG5pbXBvcnQge2ZpdEV4dGVudCwgZml0U2l6ZSwgZml0V2lkdGgsIGZpdEhlaWdodH0gZnJvbSBcIi4vZml0LmpzXCI7XG5cbi8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuLy8gYXMgdGhpcyB3aWxsIGF2b2lkIGVtaXR0aW5nIGludGVybGVhdmluZyBsaW5lcyBhbmQgcG9seWdvbnMuXG5mdW5jdGlvbiBtdWx0aXBsZXgoc3RyZWFtcykge1xuICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLnBvaW50KHgsIHkpOyB9LFxuICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLnNwaGVyZSgpOyB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLmxpbmVTdGFydCgpOyB9LFxuICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5saW5lRW5kKCk7IH0sXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7IH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLnBvbHlnb25FbmQoKTsgfVxuICB9O1xufVxuXG4vLyBBIGNvbXBvc2l0ZSBwcm9qZWN0aW9uIGZvciB0aGUgVW5pdGVkIFN0YXRlcywgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvclxuLy8gOTYww5c1MDAuIFRoZSBwcm9qZWN0aW9uIGFsc28gd29ya3MgcXVpdGUgd2VsbCBhdCA5NjDDlzYwMCBpZiB5b3UgY2hhbmdlIHRoZVxuLy8gc2NhbGUgdG8gMTI4NSBhbmQgYWRqdXN0IHRoZSB0cmFuc2xhdGUgYWNjb3JkaW5nbHkuIFRoZSBzZXQgb2Ygc3RhbmRhcmRcbi8vIHBhcmFsbGVscyBmb3IgZWFjaCByZWdpb24gY29tZXMgZnJvbSBVU0dTLCB3aGljaCBpcyBwdWJsaXNoZWQgaGVyZTpcbi8vIGh0dHA6Ly9lZ3NjLnVzZ3MuZ292L2lzYi9wdWJzL01hcFByb2plY3Rpb25zL3Byb2plY3Rpb25zLmh0bWwjYWxiZXJzXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW0sXG4gICAgICBsb3dlcjQ4ID0gYWxiZXJzKCksIGxvd2VyNDhQb2ludCxcbiAgICAgIGFsYXNrYSA9IGNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTQsIDBdKS5jZW50ZXIoWy0yLCA1OC41XSkucGFyYWxsZWxzKFs1NSwgNjVdKSwgYWxhc2thUG9pbnQsIC8vIEVQU0c6MzMzOFxuICAgICAgaGF3YWlpID0gY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NywgMF0pLmNlbnRlcihbLTMsIDE5LjldKS5wYXJhbGxlbHMoWzgsIDE4XSksIGhhd2FpaVBvaW50LCAvLyBFU1JJOjEwMjAwN1xuICAgICAgcG9pbnQsIHBvaW50U3RyZWFtID0ge3BvaW50OiBmdW5jdGlvbih4LCB5KSB7IHBvaW50ID0gW3gsIHldOyB9fTtcblxuICBmdW5jdGlvbiBhbGJlcnNVc2EoY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgKGxvd2VyNDhQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgIHx8IChhbGFza2FQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgIHx8IChoYXdhaWlQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICB9XG5cbiAgYWxiZXJzVXNhLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksXG4gICAgICAgIHQgPSBsb3dlcjQ4LnRyYW5zbGF0ZSgpLFxuICAgICAgICB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLFxuICAgICAgICB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgIHJldHVybiAoeSA+PSAwLjEyMCAmJiB5IDwgMC4yMzQgJiYgeCA+PSAtMC40MjUgJiYgeCA8IC0wLjIxNCA/IGFsYXNrYVxuICAgICAgICA6IHkgPj0gMC4xNjYgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuMjE0ICYmIHggPCAtMC4xMTUgPyBoYXdhaWlcbiAgICAgICAgOiBsb3dlcjQ4KS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgoW2xvd2VyNDguc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgYWxhc2thLnN0cmVhbShzdHJlYW0pLCBoYXdhaWkuc3RyZWFtKHN0cmVhbSldKTtcbiAgfTtcblxuICBhbGJlcnNVc2EucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgucHJlY2lzaW9uKCk7XG4gICAgbG93ZXI0OC5wcmVjaXNpb24oXyksIGFsYXNrYS5wcmVjaXNpb24oXyksIGhhd2FpaS5wcmVjaXNpb24oXyk7XG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDguc2NhbGUoKTtcbiAgICBsb3dlcjQ4LnNjYWxlKF8pLCBhbGFza2Euc2NhbGUoXyAqIDAuMzUpLCBoYXdhaWkuc2NhbGUoXyk7XG4gICAgcmV0dXJuIGFsYmVyc1VzYS50cmFuc2xhdGUobG93ZXI0OC50cmFuc2xhdGUoKSk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnRyYW5zbGF0ZSgpO1xuICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcblxuICAgIGxvd2VyNDhQb2ludCA9IGxvd2VyNDhcbiAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQ1NSAqIGssIHkgLSAwLjIzOCAqIGtdLCBbeCArIDAuNDU1ICogaywgeSArIDAuMjM4ICoga11dKVxuICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcblxuICAgIGFsYXNrYVBvaW50ID0gYWxhc2thXG4gICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjMwNyAqIGssIHkgKyAwLjIwMSAqIGtdKVxuICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQyNSAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xMjAgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4yMTQgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjM0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG5cbiAgICBoYXdhaWlQb2ludCA9IGhhd2FpaVxuICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4yMDUgKiBrLCB5ICsgMC4yMTIgKiBrXSlcbiAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4yMTQgKiBrICsgZXBzaWxvbiwgeSArIDAuMTY2ICogayArIGVwc2lsb25dLCBbeCAtIDAuMTE1ICogayAtIGVwc2lsb24sIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuXG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLmZpdEV4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEV4dGVudChhbGJlcnNVc2EsIGV4dGVudCwgb2JqZWN0KTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRTaXplKGFsYmVyc1VzYSwgc2l6ZSwgb2JqZWN0KTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0V2lkdGggPSBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFdpZHRoKGFsYmVyc1VzYSwgd2lkdGgsIG9iamVjdCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLmZpdEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEhlaWdodChhbGJlcnNVc2EsIGhlaWdodCwgb2JqZWN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gYWxiZXJzVXNhO1xuICB9XG5cbiAgcmV0dXJuIGFsYmVyc1VzYS5zY2FsZSgxMDcwKTtcbn1cbiIsImltcG9ydCB7YXNpbiwgYXRhbjIsIGNvcywgc2luLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gYXppbXV0aGFsUmF3KHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGN4ID0gY29zKHgpLFxuICAgICAgICBjeSA9IGNvcyh5KSxcbiAgICAgICAgayA9IHNjYWxlKGN4ICogY3kpO1xuICAgICAgICBpZiAoayA9PT0gSW5maW5pdHkpIHJldHVybiBbMiwgMF07XG4gICAgcmV0dXJuIFtcbiAgICAgIGsgKiBjeSAqIHNpbih4KSxcbiAgICAgIGsgKiBzaW4oeSlcbiAgICBdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhemltdXRoYWxJbnZlcnQoYW5nbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgeiA9IHNxcnQoeCAqIHggKyB5ICogeSksXG4gICAgICAgIGMgPSBhbmdsZSh6KSxcbiAgICAgICAgc2MgPSBzaW4oYyksXG4gICAgICAgIGNjID0gY29zKGMpO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih4ICogc2MsIHogKiBjYyksXG4gICAgICBhc2luKHogJiYgeSAqIHNjIC8geilcbiAgICBdO1xuICB9XG59XG4iLCJpbXBvcnQge2FzaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge2F6aW11dGhhbFJhdywgYXppbXV0aGFsSW52ZXJ0fSBmcm9tIFwiLi9hemltdXRoYWwuanNcIjtcbmltcG9ydCBwcm9qZWN0aW9uIGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCB2YXIgYXppbXV0aGFsRXF1YWxBcmVhUmF3ID0gYXppbXV0aGFsUmF3KGZ1bmN0aW9uKGN4Y3kpIHtcbiAgcmV0dXJuIHNxcnQoMiAvICgxICsgY3hjeSkpO1xufSk7XG5cbmF6aW11dGhhbEVxdWFsQXJlYVJhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24oeikge1xuICByZXR1cm4gMiAqIGFzaW4oeiAvIDIpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihhemltdXRoYWxFcXVhbEFyZWFSYXcpXG4gICAgICAuc2NhbGUoMTI0Ljc1KVxuICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbn1cbiIsImltcG9ydCB7YWNvcywgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHthemltdXRoYWxSYXcsIGF6aW11dGhhbEludmVydH0gZnJvbSBcIi4vYXppbXV0aGFsLmpzXCI7XG5pbXBvcnQgcHJvamVjdGlvbiBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgdmFyIGF6aW11dGhhbEVxdWlkaXN0YW50UmF3ID0gYXppbXV0aGFsUmF3KGZ1bmN0aW9uKGMpIHtcbiAgcmV0dXJuIChjID0gYWNvcyhjKSkgJiYgYyAvIHNpbihjKTtcbn0pO1xuXG5hemltdXRoYWxFcXVpZGlzdGFudFJhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24oeikge1xuICByZXR1cm4gejtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcpXG4gICAgICAuc2NhbGUoNzkuNDE4OClcbiAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG59XG4iLCJpbXBvcnQge2RlZ3JlZXMsIHBpLCByYWRpYW5zfSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtwcm9qZWN0aW9uTXV0YXRvcn0gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmljUHJvamVjdGlvbihwcm9qZWN0QXQpIHtcbiAgdmFyIHBoaTAgPSAwLFxuICAgICAgcGhpMSA9IHBpIC8gMyxcbiAgICAgIG0gPSBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpLFxuICAgICAgcCA9IG0ocGhpMCwgcGhpMSk7XG5cbiAgcC5wYXJhbGxlbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBtKHBoaTAgPSBfWzBdICogcmFkaWFucywgcGhpMSA9IF9bMV0gKiByYWRpYW5zKSA6IFtwaGkwICogZGVncmVlcywgcGhpMSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHJldHVybiBwO1xufVxuIiwiaW1wb3J0IHthYnMsIGF0YW4sIGF0YW4yLCBjb3MsIGVwc2lsb24sIGhhbGZQaSwgbG9nLCBwaSwgcG93LCBzaWduLCBzaW4sIHNxcnQsIHRhbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7Y29uaWNQcm9qZWN0aW9ufSBmcm9tIFwiLi9jb25pYy5qc1wiO1xuaW1wb3J0IHttZXJjYXRvclJhd30gZnJvbSBcIi4vbWVyY2F0b3IuanNcIjtcblxuZnVuY3Rpb24gdGFueSh5KSB7XG4gIHJldHVybiB0YW4oKGhhbGZQaSArIHkpIC8gMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25pY0NvbmZvcm1hbFJhdyh5MCwgeTEpIHtcbiAgdmFyIGN5MCA9IGNvcyh5MCksXG4gICAgICBuID0geTAgPT09IHkxID8gc2luKHkwKSA6IGxvZyhjeTAgLyBjb3MoeTEpKSAvIGxvZyh0YW55KHkxKSAvIHRhbnkoeTApKSxcbiAgICAgIGYgPSBjeTAgKiBwb3codGFueSh5MCksIG4pIC8gbjtcblxuICBpZiAoIW4pIHJldHVybiBtZXJjYXRvclJhdztcblxuICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICBpZiAoZiA+IDApIHsgaWYgKHkgPCAtaGFsZlBpICsgZXBzaWxvbikgeSA9IC1oYWxmUGkgKyBlcHNpbG9uOyB9XG4gICAgZWxzZSB7IGlmICh5ID4gaGFsZlBpIC0gZXBzaWxvbikgeSA9IGhhbGZQaSAtIGVwc2lsb247IH1cbiAgICB2YXIgciA9IGYgLyBwb3codGFueSh5KSwgbik7XG4gICAgcmV0dXJuIFtyICogc2luKG4gKiB4KSwgZiAtIHIgKiBjb3MobiAqIHgpXTtcbiAgfVxuXG4gIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBmeSA9IGYgLSB5LCByID0gc2lnbihuKSAqIHNxcnQoeCAqIHggKyBmeSAqIGZ5KSxcbiAgICAgIGwgPSBhdGFuMih4LCBhYnMoZnkpKSAqIHNpZ24oZnkpO1xuICAgIGlmIChmeSAqIG4gPCAwKVxuICAgICAgbCAtPSBwaSAqIHNpZ24oeCkgKiBzaWduKGZ5KTtcbiAgICByZXR1cm4gW2wgLyBuLCAyICogYXRhbihwb3coZiAvIHIsIDEgLyBuKSkgLSBoYWxmUGldO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0NvbmZvcm1hbFJhdylcbiAgICAgIC5zY2FsZSgxMDkuNSlcbiAgICAgIC5wYXJhbGxlbHMoWzMwLCAzMF0pO1xufVxuIiwiaW1wb3J0IHthYnMsIGFzaW4sIGF0YW4yLCBjb3MsIGVwc2lsb24sIHBpLCBzaWduLCBzaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge2NvbmljUHJvamVjdGlvbn0gZnJvbSBcIi4vY29uaWMuanNcIjtcbmltcG9ydCB7Y3lsaW5kcmljYWxFcXVhbEFyZWFSYXd9IGZyb20gXCIuL2N5bGluZHJpY2FsRXF1YWxBcmVhLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25pY0VxdWFsQXJlYVJhdyh5MCwgeTEpIHtcbiAgdmFyIHN5MCA9IHNpbih5MCksIG4gPSAoc3kwICsgc2luKHkxKSkgLyAyO1xuXG4gIC8vIEFyZSB0aGUgcGFyYWxsZWxzIHN5bW1ldHJpY2FsIGFyb3VuZCB0aGUgRXF1YXRvcj9cbiAgaWYgKGFicyhuKSA8IGVwc2lsb24pIHJldHVybiBjeWxpbmRyaWNhbEVxdWFsQXJlYVJhdyh5MCk7XG5cbiAgdmFyIGMgPSAxICsgc3kwICogKDIgKiBuIC0gc3kwKSwgcjAgPSBzcXJ0KGMpIC8gbjtcblxuICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICB2YXIgciA9IHNxcnQoYyAtIDIgKiBuICogc2luKHkpKSAvIG47XG4gICAgcmV0dXJuIFtyICogc2luKHggKj0gbiksIHIwIC0gciAqIGNvcyh4KV07XG4gIH1cblxuICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgcjB5ID0gcjAgLSB5LFxuICAgICAgICBsID0gYXRhbjIoeCwgYWJzKHIweSkpICogc2lnbihyMHkpO1xuICAgIGlmIChyMHkgKiBuIDwgMClcbiAgICAgIGwgLT0gcGkgKiBzaWduKHgpICogc2lnbihyMHkpO1xuICAgIHJldHVybiBbbCAvIG4sIGFzaW4oKGMgLSAoeCAqIHggKyByMHkgKiByMHkpICogbiAqIG4pIC8gKDIgKiBuKSldO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0VxdWFsQXJlYVJhdylcbiAgICAgIC5zY2FsZSgxNTUuNDI0KVxuICAgICAgLmNlbnRlcihbMCwgMzMuNjQ0Ml0pO1xufVxuIiwiaW1wb3J0IHthYnMsIGF0YW4yLCBjb3MsIGVwc2lsb24sIHBpLCBzaWduLCBzaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge2NvbmljUHJvamVjdGlvbn0gZnJvbSBcIi4vY29uaWMuanNcIjtcbmltcG9ydCB7ZXF1aXJlY3Rhbmd1bGFyUmF3fSBmcm9tIFwiLi9lcXVpcmVjdGFuZ3VsYXIuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmljRXF1aWRpc3RhbnRSYXcoeTAsIHkxKSB7XG4gIHZhciBjeTAgPSBjb3MoeTApLFxuICAgICAgbiA9IHkwID09PSB5MSA/IHNpbih5MCkgOiAoY3kwIC0gY29zKHkxKSkgLyAoeTEgLSB5MCksXG4gICAgICBnID0gY3kwIC8gbiArIHkwO1xuXG4gIGlmIChhYnMobikgPCBlcHNpbG9uKSByZXR1cm4gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuXG4gIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgIHZhciBneSA9IGcgLSB5LCBueCA9IG4gKiB4O1xuICAgIHJldHVybiBbZ3kgKiBzaW4obngpLCBnIC0gZ3kgKiBjb3MobngpXTtcbiAgfVxuXG4gIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBneSA9IGcgLSB5LFxuICAgICAgICBsID0gYXRhbjIoeCwgYWJzKGd5KSkgKiBzaWduKGd5KTtcbiAgICBpZiAoZ3kgKiBuIDwgMClcbiAgICAgIGwgLT0gcGkgKiBzaWduKHgpICogc2lnbihneSk7XG4gICAgcmV0dXJuIFtsIC8gbiwgZyAtIHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZ3kgKiBneSldO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0VxdWlkaXN0YW50UmF3KVxuICAgICAgLnNjYWxlKDEzMS4xNTQpXG4gICAgICAuY2VudGVyKFswLCAxMy45Mzg5XSk7XG59XG4iLCJpbXBvcnQge2FzaW4sIGNvcywgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY3lsaW5kcmljYWxFcXVhbEFyZWFSYXcocGhpMCkge1xuICB2YXIgY29zUGhpMCA9IGNvcyhwaGkwKTtcblxuICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIFtsYW1iZGEgKiBjb3NQaGkwLCBzaW4ocGhpKSAvIGNvc1BoaTBdO1xuICB9XG5cbiAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFt4IC8gY29zUGhpMCwgYXNpbih5ICogY29zUGhpMCldO1xuICB9O1xuXG4gIHJldHVybiBmb3J3YXJkO1xufVxuIiwiaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7YWJzLCBhc2luLCBjb3MsIGVwc2lsb24yLCBzaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbnZhciBBMSA9IDEuMzQwMjY0LFxuICAgIEEyID0gLTAuMDgxMTA2LFxuICAgIEEzID0gMC4wMDA4OTMsXG4gICAgQTQgPSAwLjAwMzc5NixcbiAgICBNID0gc3FydCgzKSAvIDIsXG4gICAgaXRlcmF0aW9ucyA9IDEyO1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxFYXJ0aFJhdyhsYW1iZGEsIHBoaSkge1xuICB2YXIgbCA9IGFzaW4oTSAqIHNpbihwaGkpKSwgbDIgPSBsICogbCwgbDYgPSBsMiAqIGwyICogbDI7XG4gIHJldHVybiBbXG4gICAgbGFtYmRhICogY29zKGwpIC8gKE0gKiAoQTEgKyAzICogQTIgKiBsMiArIGw2ICogKDcgKiBBMyArIDkgKiBBNCAqIGwyKSkpLFxuICAgIGwgKiAoQTEgKyBBMiAqIGwyICsgbDYgKiAoQTMgKyBBNCAqIGwyKSlcbiAgXTtcbn1cblxuZXF1YWxFYXJ0aFJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBsID0geSwgbDIgPSBsICogbCwgbDYgPSBsMiAqIGwyICogbDI7XG4gIGZvciAodmFyIGkgPSAwLCBkZWx0YSwgZnksIGZweTsgaSA8IGl0ZXJhdGlvbnM7ICsraSkge1xuICAgIGZ5ID0gbCAqIChBMSArIEEyICogbDIgKyBsNiAqIChBMyArIEE0ICogbDIpKSAtIHk7XG4gICAgZnB5ID0gQTEgKyAzICogQTIgKiBsMiArIGw2ICogKDcgKiBBMyArIDkgKiBBNCAqIGwyKTtcbiAgICBsIC09IGRlbHRhID0gZnkgLyBmcHksIGwyID0gbCAqIGwsIGw2ID0gbDIgKiBsMiAqIGwyO1xuICAgIGlmIChhYnMoZGVsdGEpIDwgZXBzaWxvbjIpIGJyZWFrO1xuICB9XG4gIHJldHVybiBbXG4gICAgTSAqIHggKiAoQTEgKyAzICogQTIgKiBsMiArIGw2ICogKDcgKiBBMyArIDkgKiBBNCAqIGwyKSkgLyBjb3MobCksXG4gICAgYXNpbihzaW4obCkgLyBNKVxuICBdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKGVxdWFsRWFydGhSYXcpXG4gICAgICAuc2NhbGUoMTc3LjE1OCk7XG59XG4iLCJpbXBvcnQgcHJvamVjdGlvbiBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1aXJlY3Rhbmd1bGFyUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbbGFtYmRhLCBwaGldO1xufVxuXG5lcXVpcmVjdGFuZ3VsYXJSYXcuaW52ZXJ0ID0gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oZXF1aXJlY3Rhbmd1bGFyUmF3KVxuICAgICAgLnNjYWxlKDE1Mi42Myk7XG59XG4iLCJpbXBvcnQge2RlZmF1bHQgYXMgZ2VvU3RyZWFtfSBmcm9tIFwiLi4vc3RyZWFtLmpzXCI7XG5pbXBvcnQgYm91bmRzU3RyZWFtIGZyb20gXCIuLi9wYXRoL2JvdW5kcy5qc1wiO1xuXG5mdW5jdGlvbiBmaXQocHJvamVjdGlvbiwgZml0Qm91bmRzLCBvYmplY3QpIHtcbiAgdmFyIGNsaXAgPSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgJiYgcHJvamVjdGlvbi5jbGlwRXh0ZW50KCk7XG4gIHByb2plY3Rpb24uc2NhbGUoMTUwKS50cmFuc2xhdGUoWzAsIDBdKTtcbiAgaWYgKGNsaXAgIT0gbnVsbCkgcHJvamVjdGlvbi5jbGlwRXh0ZW50KG51bGwpO1xuICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uLnN0cmVhbShib3VuZHNTdHJlYW0pKTtcbiAgZml0Qm91bmRzKGJvdW5kc1N0cmVhbS5yZXN1bHQoKSk7XG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChjbGlwKTtcbiAgcmV0dXJuIHByb2plY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIHcgPSBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0sXG4gICAgICAgIGggPSBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV0sXG4gICAgICAgIGsgPSBNYXRoLm1pbih3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSwgaCAvIChiWzFdWzFdIC0gYlswXVsxXSkpLFxuICAgICAgICB4ID0gK2V4dGVudFswXVswXSArICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMixcbiAgICAgICAgeSA9ICtleHRlbnRbMF1bMV0gKyAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgW1swLCAwXSwgc2l6ZV0sIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciB3ID0gK3dpZHRoLFxuICAgICAgICBrID0gdyAvIChiWzFdWzBdIC0gYlswXVswXSksXG4gICAgICAgIHggPSAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsXG4gICAgICAgIHkgPSAtayAqIGJbMF1bMV07XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgaCA9ICtoZWlnaHQsXG4gICAgICAgIGsgPSBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSxcbiAgICAgICAgeCA9IC1rICogYlswXVswXSxcbiAgICAgICAgeSA9IChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuIiwiaW1wb3J0IHthdGFuLCBjb3MsIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7YXppbXV0aGFsSW52ZXJ0fSBmcm9tIFwiLi9hemltdXRoYWwuanNcIjtcbmltcG9ydCBwcm9qZWN0aW9uIGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnbm9tb25pY1Jhdyh4LCB5KSB7XG4gIHZhciBjeSA9IGNvcyh5KSwgayA9IGNvcyh4KSAqIGN5O1xuICByZXR1cm4gW2N5ICogc2luKHgpIC8gaywgc2luKHkpIC8ga107XG59XG5cbmdub21vbmljUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChhdGFuKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKGdub21vbmljUmF3KVxuICAgICAgLnNjYWxlKDE0NC4wNDkpXG4gICAgICAuY2xpcEFuZ2xlKDYwKTtcbn1cbiIsImltcG9ydCBjbGlwUmVjdGFuZ2xlIGZyb20gXCIuLi9jbGlwL3JlY3RhbmdsZS5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuLi9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHt0cmFuc2Zvcm1lcn0gZnJvbSBcIi4uL3RyYW5zZm9ybS5qc1wiO1xuaW1wb3J0IHtmaXRFeHRlbnQsIGZpdFNpemUsIGZpdFdpZHRoLCBmaXRIZWlnaHR9IGZyb20gXCIuL2ZpdC5qc1wiO1xuaW1wb3J0IHtjb3MsIGRlZ3JlZXMsIHJhZGlhbnMsIHNpbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBrID0gMSwgdHggPSAwLCB0eSA9IDAsIHN4ID0gMSwgc3kgPSAxLCAvLyBzY2FsZSwgdHJhbnNsYXRlIGFuZCByZWZsZWN0XG4gICAgICBhbHBoYSA9IDAsIGNhLCBzYSwgLy8gYW5nbGVcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgLy8gY2xpcCBleHRlbnRcbiAgICAgIGt4ID0gMSwga3kgPSAxLFxuICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtZXIoe1xuICAgICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgIHZhciBwID0gcHJvamVjdGlvbihbeCwgeV0pXG4gICAgICAgICAgdGhpcy5zdHJlYW0ucG9pbnQocFswXSwgcFsxXSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcG9zdGNsaXAgPSBpZGVudGl0eSxcbiAgICAgIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW07XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAga3ggPSBrICogc3g7XG4gICAga3kgPSBrICogc3k7XG4gICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgcmV0dXJuIHByb2plY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBwcm9qZWN0aW9uIChwKSB7XG4gICAgdmFyIHggPSBwWzBdICoga3gsIHkgPSBwWzFdICoga3k7XG4gICAgaWYgKGFscGhhKSB7XG4gICAgICB2YXIgdCA9IHkgKiBjYSAtIHggKiBzYTtcbiAgICAgIHggPSB4ICogY2EgKyB5ICogc2E7XG4gICAgICB5ID0gdDtcbiAgICB9ICAgIFxuICAgIHJldHVybiBbeCArIHR4LCB5ICsgdHldO1xuICB9XG4gIHByb2plY3Rpb24uaW52ZXJ0ID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciB4ID0gcFswXSAtIHR4LCB5ID0gcFsxXSAtIHR5O1xuICAgIGlmIChhbHBoYSkge1xuICAgICAgdmFyIHQgPSB5ICogY2EgKyB4ICogc2E7XG4gICAgICB4ID0geCAqIGNhIC0geSAqIHNhO1xuICAgICAgeSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBbeCAvIGt4LCB5IC8ga3ldO1xuICB9O1xuICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybShwb3N0Y2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpO1xuICB9O1xuICBwcm9qZWN0aW9uLnBvc3RjbGlwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXywgeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCByZXNldCgpKSA6IHBvc3RjbGlwO1xuICB9O1xuICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG4gIHByb2plY3Rpb24uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoayA9ICtfLCByZXNldCgpKSA6IGs7XG4gIH07XG4gIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR4ID0gK19bMF0sIHR5ID0gK19bMV0sIHJlc2V0KCkpIDogW3R4LCB0eV07XG4gIH1cbiAgcHJvamVjdGlvbi5hbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9IF8gJSAzNjAgKiByYWRpYW5zLCBzYSA9IHNpbihhbHBoYSksIGNhID0gY29zKGFscGhhKSwgcmVzZXQoKSkgOiBhbHBoYSAqIGRlZ3JlZXM7XG4gIH07XG4gIHByb2plY3Rpb24ucmVmbGVjdFggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ggPSBfID8gLTEgOiAxLCByZXNldCgpKSA6IHN4IDwgMDtcbiAgfTtcbiAgcHJvamVjdGlvbi5yZWZsZWN0WSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeSA9IF8gPyAtMSA6IDEsIHJlc2V0KCkpIDogc3kgPCAwO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdEV4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCk7XG4gIH07XG4gIHByb2plY3Rpb24uZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCk7XG4gIH07XG4gIHByb2plY3Rpb24uZml0V2lkdGggPSBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpO1xuICB9O1xuICBwcm9qZWN0aW9uLmZpdEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCk7XG4gIH07XG5cbiAgcmV0dXJuIHByb2plY3Rpb247XG59XG4iLCJpbXBvcnQgY2xpcEFudGltZXJpZGlhbiBmcm9tIFwiLi4vY2xpcC9hbnRpbWVyaWRpYW4uanNcIjtcbmltcG9ydCBjbGlwQ2lyY2xlIGZyb20gXCIuLi9jbGlwL2NpcmNsZS5qc1wiO1xuaW1wb3J0IGNsaXBSZWN0YW5nbGUgZnJvbSBcIi4uL2NsaXAvcmVjdGFuZ2xlLmpzXCI7XG5pbXBvcnQgY29tcG9zZSBmcm9tIFwiLi4vY29tcG9zZS5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuLi9pZGVudGl0eS5qc1wiO1xuaW1wb3J0IHtjb3MsIGRlZ3JlZXMsIHJhZGlhbnMsIHNpbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7cm90YXRlUmFkaWFuc30gZnJvbSBcIi4uL3JvdGF0aW9uLmpzXCI7XG5pbXBvcnQge3RyYW5zZm9ybWVyfSBmcm9tIFwiLi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQge2ZpdEV4dGVudCwgZml0U2l6ZSwgZml0V2lkdGgsIGZpdEhlaWdodH0gZnJvbSBcIi4vZml0LmpzXCI7XG5pbXBvcnQgcmVzYW1wbGUgZnJvbSBcIi4vcmVzYW1wbGUuanNcIjtcblxudmFyIHRyYW5zZm9ybVJhZGlhbnMgPSB0cmFuc2Zvcm1lcih7XG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5zdHJlYW0ucG9pbnQoeCAqIHJhZGlhbnMsIHkgKiByYWRpYW5zKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVJvdGF0ZShyb3RhdGUpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIHIgPSByb3RhdGUoeCwgeSk7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucG9pbnQoclswXSwgclsxXSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2NhbGVUcmFuc2xhdGUoaywgZHgsIGR5LCBzeCwgc3kpIHtcbiAgZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHkpIHtcbiAgICB4ICo9IHN4OyB5ICo9IHN5O1xuICAgIHJldHVybiBbZHggKyBrICogeCwgZHkgLSBrICogeV07XG4gIH1cbiAgdHJhbnNmb3JtLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gWyh4IC0gZHgpIC8gayAqIHN4LCAoZHkgLSB5KSAvIGsgKiBzeV07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIGR4LCBkeSwgc3gsIHN5LCBhbHBoYSkge1xuICBpZiAoIWFscGhhKSByZXR1cm4gc2NhbGVUcmFuc2xhdGUoaywgZHgsIGR5LCBzeCwgc3kpO1xuICB2YXIgY29zQWxwaGEgPSBjb3MoYWxwaGEpLFxuICAgICAgc2luQWxwaGEgPSBzaW4oYWxwaGEpLFxuICAgICAgYSA9IGNvc0FscGhhICogayxcbiAgICAgIGIgPSBzaW5BbHBoYSAqIGssXG4gICAgICBhaSA9IGNvc0FscGhhIC8gayxcbiAgICAgIGJpID0gc2luQWxwaGEgLyBrLFxuICAgICAgY2kgPSAoc2luQWxwaGEgKiBkeSAtIGNvc0FscGhhICogZHgpIC8gayxcbiAgICAgIGZpID0gKHNpbkFscGhhICogZHggKyBjb3NBbHBoYSAqIGR5KSAvIGs7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybSh4LCB5KSB7XG4gICAgeCAqPSBzeDsgeSAqPSBzeTtcbiAgICByZXR1cm4gW2EgKiB4IC0gYiAqIHkgKyBkeCwgZHkgLSBiICogeCAtIGEgKiB5XTtcbiAgfVxuICB0cmFuc2Zvcm0uaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbc3ggKiAoYWkgKiB4IC0gYmkgKiB5ICsgY2kpLCBzeSAqIChmaSAtIGJpICogeCAtIGFpICogeSldO1xuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgcmV0dXJuIHByb2plY3Rpb25NdXRhdG9yKGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvamVjdDsgfSkoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCkge1xuICB2YXIgcHJvamVjdCxcbiAgICAgIGsgPSAxNTAsIC8vIHNjYWxlXG4gICAgICB4ID0gNDgwLCB5ID0gMjUwLCAvLyB0cmFuc2xhdGVcbiAgICAgIGxhbWJkYSA9IDAsIHBoaSA9IDAsIC8vIGNlbnRlclxuICAgICAgZGVsdGFMYW1iZGEgPSAwLCBkZWx0YVBoaSA9IDAsIGRlbHRhR2FtbWEgPSAwLCByb3RhdGUsIC8vIHByZS1yb3RhdGVcbiAgICAgIGFscGhhID0gMCwgLy8gcG9zdC1yb3RhdGUgYW5nbGVcbiAgICAgIHN4ID0gMSwgLy8gcmVmbGVjdFhcbiAgICAgIHN5ID0gMSwgLy8gcmVmbGVjdFhcbiAgICAgIHRoZXRhID0gbnVsbCwgcHJlY2xpcCA9IGNsaXBBbnRpbWVyaWRpYW4sIC8vIHByZS1jbGlwIGFuZ2xlXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTEsIHBvc3RjbGlwID0gaWRlbnRpdHksIC8vIHBvc3QtY2xpcCBleHRlbnRcbiAgICAgIGRlbHRhMiA9IDAuNSwgLy8gcHJlY2lzaW9uXG4gICAgICBwcm9qZWN0UmVzYW1wbGUsXG4gICAgICBwcm9qZWN0VHJhbnNmb3JtLFxuICAgICAgcHJvamVjdFJvdGF0ZVRyYW5zZm9ybSxcbiAgICAgIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW07XG5cbiAgZnVuY3Rpb24gcHJvamVjdGlvbihwb2ludCkge1xuICAgIHJldHVybiBwcm9qZWN0Um90YXRlVHJhbnNmb3JtKHBvaW50WzBdICogcmFkaWFucywgcG9pbnRbMV0gKiByYWRpYW5zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydChwb2ludCkge1xuICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZVRyYW5zZm9ybS5pbnZlcnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICByZXR1cm4gcG9pbnQgJiYgW3BvaW50WzBdICogZGVncmVlcywgcG9pbnRbMV0gKiBkZWdyZWVzXTtcbiAgfVxuXG4gIHByb2plY3Rpb24uc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gdHJhbnNmb3JtUmFkaWFucyh0cmFuc2Zvcm1Sb3RhdGUocm90YXRlKShwcmVjbGlwKHByb2plY3RSZXNhbXBsZShwb3N0Y2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpKSkpO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucHJlY2xpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gXywgdGhldGEgPSB1bmRlZmluZWQsIHJlc2V0KCkpIDogcHJlY2xpcDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnBvc3RjbGlwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXywgeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCByZXNldCgpKSA6IHBvc3RjbGlwO1xuICB9O1xuXG4gIHByb2plY3Rpb24uY2xpcEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNsaXAgPSArXyA/IGNsaXBDaXJjbGUodGhldGEgPSBfICogcmFkaWFucykgOiAodGhldGEgPSBudWxsLCBjbGlwQW50aW1lcmlkaWFuKSwgcmVzZXQoKSkgOiB0aGV0YSAqIGRlZ3JlZXM7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkpIDogY2xpcFJlY3RhbmdsZSh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVzZXQoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICB9O1xuXG4gIHByb2plY3Rpb24uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoayA9ICtfLCByZWNlbnRlcigpKSA6IGs7XG4gIH07XG5cbiAgcHJvamVjdGlvbi50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9ICtfWzBdLCB5ID0gK19bMV0sIHJlY2VudGVyKCkpIDogW3gsIHldO1xuICB9O1xuXG4gIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBwaGkgPSBfWzFdICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBbbGFtYmRhICogZGVncmVlcywgcGhpICogZGVncmVlc107XG4gIH07XG5cbiAgcHJvamVjdGlvbi5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVsdGFMYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgZGVsdGFQaGkgPSBfWzFdICUgMzYwICogcmFkaWFucywgZGVsdGFHYW1tYSA9IF8ubGVuZ3RoID4gMiA/IF9bMl0gJSAzNjAgKiByYWRpYW5zIDogMCwgcmVjZW50ZXIoKSkgOiBbZGVsdGFMYW1iZGEgKiBkZWdyZWVzLCBkZWx0YVBoaSAqIGRlZ3JlZXMsIGRlbHRhR2FtbWEgKiBkZWdyZWVzXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhID0gXyAlIDM2MCAqIHJhZGlhbnMsIHJlY2VudGVyKCkpIDogYWxwaGEgKiBkZWdyZWVzO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucmVmbGVjdFggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ggPSBfID8gLTEgOiAxLCByZWNlbnRlcigpKSA6IHN4IDwgMDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJlZmxlY3RZID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN5ID0gXyA/IC0xIDogMSwgcmVjZW50ZXIoKSkgOiBzeSA8IDA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyID0gXyAqIF8pLCByZXNldCgpKSA6IHNxcnQoZGVsdGEyKTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdEV4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRTaXplID0gZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdFdpZHRoID0gZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjZW50ZXIoKSB7XG4gICAgdmFyIGNlbnRlciA9IHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIDAsIDAsIHN4LCBzeSwgYWxwaGEpLmFwcGx5KG51bGwsIHByb2plY3QobGFtYmRhLCBwaGkpKSxcbiAgICAgICAgdHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgeCAtIGNlbnRlclswXSwgeSAtIGNlbnRlclsxXSwgc3gsIHN5LCBhbHBoYSk7XG4gICAgcm90YXRlID0gcm90YXRlUmFkaWFucyhkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGRlbHRhR2FtbWEpO1xuICAgIHByb2plY3RUcmFuc2Zvcm0gPSBjb21wb3NlKHByb2plY3QsIHRyYW5zZm9ybSk7XG4gICAgcHJvamVjdFJvdGF0ZVRyYW5zZm9ybSA9IGNvbXBvc2Uocm90YXRlLCBwcm9qZWN0VHJhbnNmb3JtKTtcbiAgICBwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIpO1xuICAgIHJldHVybiByZXNldCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgcmV0dXJuIHByb2plY3Rpb247XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcHJvamVjdCA9IHByb2plY3RBdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHByb2plY3Rpb24uaW52ZXJ0ID0gcHJvamVjdC5pbnZlcnQgJiYgaW52ZXJ0O1xuICAgIHJldHVybiByZWNlbnRlcigpO1xuICB9O1xufVxuIiwiaW1wb3J0IHthdGFuLCBleHAsIGhhbGZQaSwgbG9nLCBwaSwgdGFuLCB0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgcm90YXRpb24gZnJvbSBcIi4uL3JvdGF0aW9uLmpzXCI7XG5pbXBvcnQgcHJvamVjdGlvbiBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyY2F0b3JSYXcobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFtsYW1iZGEsIGxvZyh0YW4oKGhhbGZQaSArIHBoaSkgLyAyKSldO1xufVxuXG5tZXJjYXRvclJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiBbeCwgMiAqIGF0YW4oZXhwKHkpKSAtIGhhbGZQaV07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG1lcmNhdG9yUHJvamVjdGlvbihtZXJjYXRvclJhdylcbiAgICAgIC5zY2FsZSg5NjEgLyB0YXUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyY2F0b3JQcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgdmFyIG0gPSBwcm9qZWN0aW9uKHByb2plY3QpLFxuICAgICAgY2VudGVyID0gbS5jZW50ZXIsXG4gICAgICBzY2FsZSA9IG0uc2NhbGUsXG4gICAgICB0cmFuc2xhdGUgPSBtLnRyYW5zbGF0ZSxcbiAgICAgIGNsaXBFeHRlbnQgPSBtLmNsaXBFeHRlbnQsXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTE7IC8vIGNsaXAgZXh0ZW50XG5cbiAgbS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZShfKSwgcmVjbGlwKCkpIDogc2NhbGUoKTtcbiAgfTtcblxuICBtLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGUoXyksIHJlY2xpcCgpKSA6IHRyYW5zbGF0ZSgpO1xuICB9O1xuXG4gIG0uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlcihfKSwgcmVjbGlwKCkpIDogY2VudGVyKCk7XG4gIH07XG5cbiAgbS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChfID09IG51bGwgPyB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwgOiAoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSkpLCByZWNsaXAoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlY2xpcCgpIHtcbiAgICB2YXIgayA9IHBpICogc2NhbGUoKSxcbiAgICAgICAgdCA9IG0ocm90YXRpb24obS5yb3RhdGUoKSkuaW52ZXJ0KFswLCAwXSkpO1xuICAgIHJldHVybiBjbGlwRXh0ZW50KHgwID09IG51bGxcbiAgICAgICAgPyBbW3RbMF0gLSBrLCB0WzFdIC0ga10sIFt0WzBdICsgaywgdFsxXSArIGtdXSA6IHByb2plY3QgPT09IG1lcmNhdG9yUmF3XG4gICAgICAgID8gW1tNYXRoLm1heCh0WzBdIC0gaywgeDApLCB5MF0sIFtNYXRoLm1pbih0WzBdICsgaywgeDEpLCB5MV1dXG4gICAgICAgIDogW1t4MCwgTWF0aC5tYXgodFsxXSAtIGssIHkwKV0sIFt4MSwgTWF0aC5taW4odFsxXSArIGssIHkxKV1dKTtcbiAgfVxuXG4gIHJldHVybiByZWNsaXAoKTtcbn1cbiIsImltcG9ydCBwcm9qZWN0aW9uIGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQge2FicywgZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5hdHVyYWxFYXJ0aDFSYXcobGFtYmRhLCBwaGkpIHtcbiAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgcmV0dXJuIFtcbiAgICBsYW1iZGEgKiAoMC44NzA3IC0gMC4xMzE5NzkgKiBwaGkyICsgcGhpNCAqICgtMC4wMTM3OTEgKyBwaGk0ICogKDAuMDAzOTcxICogcGhpMiAtIDAuMDAxNTI5ICogcGhpNCkpKSxcbiAgICBwaGkgKiAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICsgcGhpNCAqICgtMC4wNDQ0NzUgKyAwLjAyODg3NCAqIHBoaTIgLSAwLjAwNTkxNiAqIHBoaTQpKSlcbiAgXTtcbn1cblxubmF0dXJhbEVhcnRoMVJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBwaGkgPSB5LCBpID0gMjUsIGRlbHRhO1xuICBkbyB7XG4gICAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgICBwaGkgLT0gZGVsdGEgPSAocGhpICogKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSArIHBoaTQgKiAoLTAuMDQ0NDc1ICsgMC4wMjg4NzQgKiBwaGkyIC0gMC4wMDU5MTYgKiBwaGk0KSkpIC0geSkgL1xuICAgICAgICAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICogMyArIHBoaTQgKiAoLTAuMDQ0NDc1ICogNyArIDAuMDI4ODc0ICogOSAqIHBoaTIgLSAwLjAwNTkxNiAqIDExICogcGhpNCkpKTtcbiAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gIHJldHVybiBbXG4gICAgeCAvICgwLjg3MDcgKyAocGhpMiA9IHBoaSAqIHBoaSkgKiAoLTAuMTMxOTc5ICsgcGhpMiAqICgtMC4wMTM3OTEgKyBwaGkyICogcGhpMiAqIHBoaTIgKiAoMC4wMDM5NzEgLSAwLjAwMTUyOSAqIHBoaTIpKSkpLFxuICAgIHBoaVxuICBdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKG5hdHVyYWxFYXJ0aDFSYXcpXG4gICAgICAuc2NhbGUoMTc1LjI5NSk7XG59XG4iLCJpbXBvcnQge2FzaW4sIGNvcywgZXBzaWxvbiwgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHthemltdXRoYWxJbnZlcnR9IGZyb20gXCIuL2F6aW11dGhhbC5qc1wiO1xuaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvZ3JhcGhpY1Jhdyh4LCB5KSB7XG4gIHJldHVybiBbY29zKHkpICogc2luKHgpLCBzaW4oeSldO1xufVxuXG5vcnRob2dyYXBoaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGFzaW4pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24ob3J0aG9ncmFwaGljUmF3KVxuICAgICAgLnNjYWxlKDI0OS41KVxuICAgICAgLmNsaXBBbmdsZSg5MCArIGVwc2lsb24pO1xufVxuIiwiaW1wb3J0IHtjYXJ0ZXNpYW59IGZyb20gXCIuLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7YWJzLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCByYWRpYW5zLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHt0cmFuc2Zvcm1lcn0gZnJvbSBcIi4uL3RyYW5zZm9ybS5qc1wiO1xuXG52YXIgbWF4RGVwdGggPSAxNiwgLy8gbWF4aW11bSBkZXB0aCBvZiBzdWJkaXZpc2lvblxuICAgIGNvc01pbkRpc3RhbmNlID0gY29zKDMwICogcmFkaWFucyk7IC8vIGNvcyhtaW5pbXVtIGFuZ3VsYXIgZGlzdGFuY2UpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHByb2plY3QsIGRlbHRhMikge1xuICByZXR1cm4gK2RlbHRhMiA/IHJlc2FtcGxlKHByb2plY3QsIGRlbHRhMikgOiByZXNhbXBsZU5vbmUocHJvamVjdCk7XG59XG5cbmZ1bmN0aW9uIHJlc2FtcGxlTm9uZShwcm9qZWN0KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzYW1wbGUocHJvamVjdCwgZGVsdGEyKSB7XG5cbiAgZnVuY3Rpb24gcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pIHtcbiAgICB2YXIgZHggPSB4MSAtIHgwLFxuICAgICAgICBkeSA9IHkxIC0geTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgaWYgKGQyID4gNCAqIGRlbHRhMiAmJiBkZXB0aC0tKSB7XG4gICAgICB2YXIgYSA9IGEwICsgYTEsXG4gICAgICAgICAgYiA9IGIwICsgYjEsXG4gICAgICAgICAgYyA9IGMwICsgYzEsXG4gICAgICAgICAgbSA9IHNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSxcbiAgICAgICAgICBwaGkyID0gYXNpbihjIC89IG0pLFxuICAgICAgICAgIGxhbWJkYTIgPSBhYnMoYWJzKGMpIC0gMSkgPCBlcHNpbG9uIHx8IGFicyhsYW1iZGEwIC0gbGFtYmRhMSkgPCBlcHNpbG9uID8gKGxhbWJkYTAgKyBsYW1iZGExKSAvIDIgOiBhdGFuMihiLCBhKSxcbiAgICAgICAgICBwID0gcHJvamVjdChsYW1iZGEyLCBwaGkyKSxcbiAgICAgICAgICB4MiA9IHBbMF0sXG4gICAgICAgICAgeTIgPSBwWzFdLFxuICAgICAgICAgIGR4MiA9IHgyIC0geDAsXG4gICAgICAgICAgZHkyID0geTIgLSB5MCxcbiAgICAgICAgICBkeiA9IGR5ICogZHgyIC0gZHggKiBkeTI7XG4gICAgICBpZiAoZHogKiBkeiAvIGQyID4gZGVsdGEyIC8vIHBlcnBlbmRpY3VsYXIgcHJvamVjdGVkIGRpc3RhbmNlXG4gICAgICAgICAgfHwgYWJzKChkeCAqIGR4MiArIGR5ICogZHkyKSAvIGQyIC0gMC41KSA+IDAuMyAvLyBtaWRwb2ludCBjbG9zZSB0byBhbiBlbmRcbiAgICAgICAgICB8fCBhMCAqIGExICsgYjAgKiBiMSArIGMwICogYzEgPCBjb3NNaW5EaXN0YW5jZSkgeyAvLyBhbmd1bGFyIGRpc3RhbmNlXG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDIsIHkyLCBsYW1iZGEyLCBhIC89IG0sIGIgLz0gbSwgYywgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4MiwgeTIpO1xuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MiwgeTIsIGxhbWJkYTIsIGEsIGIsIGMsIHgxLCB5MSwgbGFtYmRhMSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgbGFtYmRhMDAsIHgwMCwgeTAwLCBhMDAsIGIwMCwgYzAwLCAvLyBmaXJzdCBwb2ludFxuICAgICAgICBsYW1iZGEwLCB4MCwgeTAsIGEwLCBiMCwgYzA7IC8vIHByZXZpb3VzIHBvaW50XG5cbiAgICB2YXIgcmVzYW1wbGVTdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkgeyBzdHJlYW0ucG9seWdvblN0YXJ0KCk7IHJlc2FtcGxlU3RyZWFtLmxpbmVTdGFydCA9IHJpbmdTdGFydDsgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyBzdHJlYW0ucG9seWdvbkVuZCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7IH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgeDAgPSBOYU47XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgIHZhciBjID0gY2FydGVzaWFuKFtsYW1iZGEsIHBoaV0pLCBwID0gcHJvamVjdChsYW1iZGEsIHBoaSk7XG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwID0gcFswXSwgeTAgPSBwWzFdLCBsYW1iZGEwID0gbGFtYmRhLCBhMCA9IGNbMF0sIGIwID0gY1sxXSwgYzAgPSBjWzJdLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgIHN0cmVhbS5wb2ludCh4MCwgeTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICBsaW5lU3RhcnQoKTtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICBsaW5lUG9pbnQobGFtYmRhMDAgPSBsYW1iZGEsIHBoaSksIHgwMCA9IHgwLCB5MDAgPSB5MCwgYTAwID0gYTAsIGIwMCA9IGIwLCBjMDAgPSBjMDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwMCwgeTAwLCBsYW1iZGEwMCwgYTAwLCBiMDAsIGMwMCwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgIGxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzYW1wbGVTdHJlYW07XG4gIH07XG59XG4iLCJpbXBvcnQge2F0YW4sIGNvcywgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHthemltdXRoYWxJbnZlcnR9IGZyb20gXCIuL2F6aW11dGhhbC5qc1wiO1xuaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXJlb2dyYXBoaWNSYXcoeCwgeSkge1xuICB2YXIgY3kgPSBjb3MoeSksIGsgPSAxICsgY29zKHgpICogY3k7XG4gIHJldHVybiBbY3kgKiBzaW4oeCkgLyBrLCBzaW4oeSkgLyBrXTtcbn1cblxuc3RlcmVvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24oeikge1xuICByZXR1cm4gMiAqIGF0YW4oeik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKHN0ZXJlb2dyYXBoaWNSYXcpXG4gICAgICAuc2NhbGUoMjUwKVxuICAgICAgLmNsaXBBbmdsZSgxNDIpO1xufVxuIiwiaW1wb3J0IHthdGFuLCBleHAsIGhhbGZQaSwgbG9nLCB0YW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge21lcmNhdG9yUHJvamVjdGlvbn0gZnJvbSBcIi4vbWVyY2F0b3IuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zdmVyc2VNZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2xvZyh0YW4oKGhhbGZQaSArIHBoaSkgLyAyKSksIC1sYW1iZGFdO1xufVxuXG50cmFuc3ZlcnNlTWVyY2F0b3JSYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gWy15LCAyICogYXRhbihleHAoeCkpIC0gaGFsZlBpXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbSA9IG1lcmNhdG9yUHJvamVjdGlvbih0cmFuc3ZlcnNlTWVyY2F0b3JSYXcpLFxuICAgICAgY2VudGVyID0gbS5jZW50ZXIsXG4gICAgICByb3RhdGUgPSBtLnJvdGF0ZTtcblxuICBtLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGNlbnRlcihbLV9bMV0sIF9bMF1dKSA6IChfID0gY2VudGVyKCksIFtfWzFdLCAtX1swXV0pO1xuICB9O1xuXG4gIG0ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcm90YXRlKFtfWzBdLCBfWzFdLCBfLmxlbmd0aCA+IDIgPyBfWzJdICsgOTAgOiA5MF0pIDogKF8gPSByb3RhdGUoKSwgW19bMF0sIF9bMV0sIF9bMl0gLSA5MF0pO1xuICB9O1xuXG4gIHJldHVybiByb3RhdGUoWzAsIDAsIDkwXSlcbiAgICAgIC5zY2FsZSgxNTkuMTU1KTtcbn1cbiIsImltcG9ydCBjb21wb3NlIGZyb20gXCIuL2NvbXBvc2UuanNcIjtcbmltcG9ydCB7YWJzLCBhc2luLCBhdGFuMiwgY29zLCBkZWdyZWVzLCBwaSwgcmFkaWFucywgc2luLCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcblxuZnVuY3Rpb24gcm90YXRpb25JZGVudGl0eShsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2FicyhsYW1iZGEpID4gcGkgPyBsYW1iZGEgKyBNYXRoLnJvdW5kKC1sYW1iZGEgLyB0YXUpICogdGF1IDogbGFtYmRhLCBwaGldO1xufVxuXG5yb3RhdGlvbklkZW50aXR5LmludmVydCA9IHJvdGF0aW9uSWRlbnRpdHk7XG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICByZXR1cm4gKGRlbHRhTGFtYmRhICU9IHRhdSkgPyAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IGNvbXBvc2Uocm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpLCByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSlcbiAgICA6IHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSlcbiAgICA6IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSlcbiAgICA6IHJvdGF0aW9uSWRlbnRpdHkpO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIGxhbWJkYSArPSBkZWx0YUxhbWJkYSwgW2xhbWJkYSA+IHBpID8gbGFtYmRhIC0gdGF1IDogbGFtYmRhIDwgLXBpID8gbGFtYmRhICsgdGF1IDogbGFtYmRhLCBwaGldO1xuICB9O1xufVxuXG5mdW5jdGlvbiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICB2YXIgcm90YXRpb24gPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpO1xuICByb3RhdGlvbi5pbnZlcnQgPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoLWRlbHRhTGFtYmRhKTtcbiAgcmV0dXJuIHJvdGF0aW9uO1xufVxuXG5mdW5jdGlvbiByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHZhciBjb3NEZWx0YVBoaSA9IGNvcyhkZWx0YVBoaSksXG4gICAgICBzaW5EZWx0YVBoaSA9IHNpbihkZWx0YVBoaSksXG4gICAgICBjb3NEZWx0YUdhbW1hID0gY29zKGRlbHRhR2FtbWEpLFxuICAgICAgc2luRGVsdGFHYW1tYSA9IHNpbihkZWx0YUdhbW1hKTtcblxuICBmdW5jdGlvbiByb3RhdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgICAgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgICAgayA9IHogKiBjb3NEZWx0YVBoaSArIHggKiBzaW5EZWx0YVBoaTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgLSBrICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpIC0geiAqIHNpbkRlbHRhUGhpKSxcbiAgICAgIGFzaW4oayAqIGNvc0RlbHRhR2FtbWEgKyB5ICogc2luRGVsdGFHYW1tYSlcbiAgICBdO1xuICB9XG5cbiAgcm90YXRpb24uaW52ZXJ0ID0gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICAgIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB6ID0gc2luKHBoaSksXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFHYW1tYSAtIHkgKiBzaW5EZWx0YUdhbW1hO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSArIHogKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgKyBrICogc2luRGVsdGFQaGkpLFxuICAgICAgYXNpbihrICogY29zRGVsdGFQaGkgLSB4ICogc2luRGVsdGFQaGkpXG4gICAgXTtcbiAgfTtcblxuICByZXR1cm4gcm90YXRpb247XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJvdGF0ZSkge1xuICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKHJvdGF0ZVswXSAqIHJhZGlhbnMsIHJvdGF0ZVsxXSAqIHJhZGlhbnMsIHJvdGF0ZS5sZW5ndGggPiAyID8gcm90YXRlWzJdICogcmFkaWFucyA6IDApO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmQoY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICB9XG5cbiAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICB9O1xuXG4gIHJldHVybiBmb3J3YXJkO1xufVxuIiwiZnVuY3Rpb24gc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cnksIHN0cmVhbSkge1xuICBpZiAoZ2VvbWV0cnkgJiYgc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59XG5cbnZhciBzdHJlYW1PYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgfSxcbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59O1xuXG52YXIgc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICBTcGhlcmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtLnNwaGVyZSgpO1xuICB9LFxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBvYmplY3QgPSBvYmplY3QuY29vcmRpbmF0ZXM7XG4gICAgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0sIDApO1xuICB9LFxuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMCk7XG4gIH0sXG4gIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSk7XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgc3RyZWFtKTtcbiAgfSxcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBzdHJlYW0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzLCBzdHJlYW0sIGNsb3NlZCkge1xuICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgc3RyZWFtLmxpbmVFbmQoKTtcbn1cblxuZnVuY3Rpb24gc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgc3RyZWFtKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMSk7XG4gIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gIGlmIChvYmplY3QgJiYgc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICBzdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0LCBzdHJlYW0pO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtZXRob2RzKSB7XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiB0cmFuc2Zvcm1lcihtZXRob2RzKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtZXIobWV0aG9kcykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSBzW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbSgpIHt9XG5cblRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm1TdHJlYW0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpOyB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5zcGhlcmUoKTsgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7IH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lRW5kKCk7IH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpOyB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpOyB9XG59O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsKGYpIHtcbiAgcmV0dXJuIGYgPT0gbnVsbCA/IG51bGwgOiByZXF1aXJlZChmKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVkKGYpIHtcbiAgaWYgKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGY7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIHhcbiAgICA/IHggLy8gQXJyYXksIFR5cGVkQXJyYXksIE5vZGVMaXN0LCBhcnJheS1saWtlXG4gICAgOiBBcnJheS5mcm9tKHgpOyAvLyBNYXAsIFNldCwgaXRlcmFibGUsIHN0cmluZywgb3IgYW55dGhpbmcgZWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICB2YXIgbSA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHQsXG4gICAgICBpO1xuXG4gIHdoaWxlIChtKSB7XG4gICAgaSA9IE1hdGgucmFuZG9tKCkgKiBtLS0gfCAwO1xuICAgIHQgPSBhcnJheVttXTtcbiAgICBhcnJheVttXSA9IGFycmF5W2ldO1xuICAgIGFycmF5W2ldID0gdDtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cbiIsImZ1bmN0aW9uIGRlZmF1bHRTZXBhcmF0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyO1xufVxuXG5mdW5jdGlvbiBtZWFuWChjaGlsZHJlbikge1xuICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKG1lYW5YUmVkdWNlLCAwKSAvIGNoaWxkcmVuLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gbWVhblhSZWR1Y2UoeCwgYykge1xuICByZXR1cm4geCArIGMueDtcbn1cblxuZnVuY3Rpb24gbWF4WShjaGlsZHJlbikge1xuICByZXR1cm4gMSArIGNoaWxkcmVuLnJlZHVjZShtYXhZUmVkdWNlLCAwKTtcbn1cblxuZnVuY3Rpb24gbWF4WVJlZHVjZSh5LCBjKSB7XG4gIHJldHVybiBNYXRoLm1heCh5LCBjLnkpO1xufVxuXG5mdW5jdGlvbiBsZWFmTGVmdChub2RlKSB7XG4gIHZhciBjaGlsZHJlbjtcbiAgd2hpbGUgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgbm9kZSA9IGNoaWxkcmVuWzBdO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gbGVhZlJpZ2h0KG5vZGUpIHtcbiAgdmFyIGNoaWxkcmVuO1xuICB3aGlsZSAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSBub2RlID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIHJldHVybiBub2RlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbixcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIG5vZGVTaXplID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2x1c3Rlcihyb290KSB7XG4gICAgdmFyIHByZXZpb3VzTm9kZSxcbiAgICAgICAgeCA9IDA7XG5cbiAgICAvLyBGaXJzdCB3YWxrLCBjb21wdXRpbmcgdGhlIGluaXRpYWwgeCAmIHkgdmFsdWVzLlxuICAgIHJvb3QuZWFjaEFmdGVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgbm9kZS54ID0gbWVhblgoY2hpbGRyZW4pO1xuICAgICAgICBub2RlLnkgPSBtYXhZKGNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUueCA9IHByZXZpb3VzTm9kZSA/IHggKz0gc2VwYXJhdGlvbihub2RlLCBwcmV2aW91c05vZGUpIDogMDtcbiAgICAgICAgbm9kZS55ID0gMDtcbiAgICAgICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBsZWZ0ID0gbGVhZkxlZnQocm9vdCksXG4gICAgICAgIHJpZ2h0ID0gbGVhZlJpZ2h0KHJvb3QpLFxuICAgICAgICB4MCA9IGxlZnQueCAtIHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMixcbiAgICAgICAgeDEgPSByaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyO1xuXG4gICAgLy8gU2Vjb25kIHdhbGssIG5vcm1hbGl6aW5nIHggJiB5IHRvIHRoZSBkZXNpcmVkIHNpemUuXG4gICAgcmV0dXJuIHJvb3QuZWFjaEFmdGVyKG5vZGVTaXplID8gZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHJvb3QueCkgKiBkeDtcbiAgICAgIG5vZGUueSA9IChyb290LnkgLSBub2RlLnkpICogZHk7XG4gICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUueCA9IChub2RlLnggLSB4MCkgLyAoeDEgLSB4MCkgKiBkeDtcbiAgICAgIG5vZGUueSA9ICgxIC0gKHJvb3QueSA/IG5vZGUueSAvIHJvb3QueSA6IDEpKSAqIGR5O1xuICAgIH0pO1xuICB9XG5cbiAgY2x1c3Rlci5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNlcGFyYXRpb24gPSB4LCBjbHVzdGVyKSA6IHNlcGFyYXRpb247XG4gIH07XG5cbiAgY2x1c3Rlci5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gZmFsc2UsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIGNsdXN0ZXIpIDogKG5vZGVTaXplID8gbnVsbCA6IFtkeCwgZHldKTtcbiAgfTtcblxuICBjbHVzdGVyLm5vZGVTaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gdHJ1ZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgY2x1c3RlcikgOiAobm9kZVNpemUgPyBbZHgsIGR5XSA6IG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBjbHVzdGVyO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNvbnN0YW50WmVybygpIHtcbiAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV07XG4gIHdoaWxlIChub2RlID0gbm9kZS5wYXJlbnQpIHtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbiIsImZ1bmN0aW9uIGNvdW50KG5vZGUpIHtcbiAgdmFyIHN1bSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sXG4gICAgICBpID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAoIWkpIHN1bSA9IDE7XG4gIGVsc2Ugd2hpbGUgKC0taSA+PSAwKSBzdW0gKz0gY2hpbGRyZW5baV0udmFsdWU7XG4gIG5vZGUudmFsdWUgPSBzdW07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoY291bnQpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIHRoYXQpIHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzKSB7XG4gICAgY2FsbGJhY2suY2FsbCh0aGF0LCBub2RlLCArK2luZGV4LCB0aGlzKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGF0KSB7XG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIG5leHQgPSBbXSwgY2hpbGRyZW4sIGksIG4sIGluZGV4ID0gLTE7XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBuZXh0LnB1c2gobm9kZSk7XG4gICAgaWYgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgd2hpbGUgKG5vZGUgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2suY2FsbCh0aGF0LCBub2RlLCArK2luZGV4LCB0aGlzKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGF0KSB7XG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIGNoaWxkcmVuLCBpLCBpbmRleCA9IC0xO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgY2FsbGJhY2suY2FsbCh0aGF0LCBub2RlLCArK2luZGV4LCB0aGlzKTtcbiAgICBpZiAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgdGhhdCkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMpIHtcbiAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGF0LCBub2RlLCArK2luZGV4LCB0aGlzKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgbm9kZV9jb3VudCBmcm9tIFwiLi9jb3VudC5qc1wiO1xuaW1wb3J0IG5vZGVfZWFjaCBmcm9tIFwiLi9lYWNoLmpzXCI7XG5pbXBvcnQgbm9kZV9lYWNoQmVmb3JlIGZyb20gXCIuL2VhY2hCZWZvcmUuanNcIjtcbmltcG9ydCBub2RlX2VhY2hBZnRlciBmcm9tIFwiLi9lYWNoQWZ0ZXIuanNcIjtcbmltcG9ydCBub2RlX2ZpbmQgZnJvbSBcIi4vZmluZC5qc1wiO1xuaW1wb3J0IG5vZGVfc3VtIGZyb20gXCIuL3N1bS5qc1wiO1xuaW1wb3J0IG5vZGVfc29ydCBmcm9tIFwiLi9zb3J0LmpzXCI7XG5pbXBvcnQgbm9kZV9wYXRoIGZyb20gXCIuL3BhdGguanNcIjtcbmltcG9ydCBub2RlX2FuY2VzdG9ycyBmcm9tIFwiLi9hbmNlc3RvcnMuanNcIjtcbmltcG9ydCBub2RlX2Rlc2NlbmRhbnRzIGZyb20gXCIuL2Rlc2NlbmRhbnRzLmpzXCI7XG5pbXBvcnQgbm9kZV9sZWF2ZXMgZnJvbSBcIi4vbGVhdmVzLmpzXCI7XG5pbXBvcnQgbm9kZV9saW5rcyBmcm9tIFwiLi9saW5rcy5qc1wiO1xuaW1wb3J0IG5vZGVfaXRlcmF0b3IgZnJvbSBcIi4vaXRlcmF0b3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGllcmFyY2h5KGRhdGEsIGNoaWxkcmVuKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgZGF0YSA9IFt1bmRlZmluZWQsIGRhdGFdO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSBjaGlsZHJlbiA9IG1hcENoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcbiAgICBjaGlsZHJlbiA9IG9iamVjdENoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBuZXcgTm9kZShkYXRhKSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlcyA9IFtyb290XSxcbiAgICAgIGNoaWxkLFxuICAgICAgY2hpbGRzLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGlmICgoY2hpbGRzID0gY2hpbGRyZW4obm9kZS5kYXRhKSkgJiYgKG4gPSAoY2hpbGRzID0gQXJyYXkuZnJvbShjaGlsZHMpKS5sZW5ndGgpKSB7XG4gICAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRzO1xuICAgICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGQgPSBjaGlsZHNbaV0gPSBuZXcgTm9kZShjaGlsZHNbaV0pKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgY2hpbGQuZGVwdGggPSBub2RlLmRlcHRoICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdC5lYWNoQmVmb3JlKGNvbXB1dGVIZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBub2RlX2NvcHkoKSB7XG4gIHJldHVybiBoaWVyYXJjaHkodGhpcykuZWFjaEJlZm9yZShjb3B5RGF0YSk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENoaWxkcmVuKGQpIHtcbiAgcmV0dXJuIGQuY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZCkgPyBkWzFdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY29weURhdGEobm9kZSkge1xuICBpZiAobm9kZS5kYXRhLnZhbHVlICE9PSB1bmRlZmluZWQpIG5vZGUudmFsdWUgPSBub2RlLmRhdGEudmFsdWU7XG4gIG5vZGUuZGF0YSA9IG5vZGUuZGF0YS5kYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhlaWdodChub2RlKSB7XG4gIHZhciBoZWlnaHQgPSAwO1xuICBkbyBub2RlLmhlaWdodCA9IGhlaWdodDtcbiAgd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnQpICYmIChub2RlLmhlaWdodCA8ICsraGVpZ2h0KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBOb2RlKGRhdGEpIHtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5kZXB0aCA9XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xufVxuXG5Ob2RlLnByb3RvdHlwZSA9IGhpZXJhcmNoeS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBOb2RlLFxuICBjb3VudDogbm9kZV9jb3VudCxcbiAgZWFjaDogbm9kZV9lYWNoLFxuICBlYWNoQWZ0ZXI6IG5vZGVfZWFjaEFmdGVyLFxuICBlYWNoQmVmb3JlOiBub2RlX2VhY2hCZWZvcmUsXG4gIGZpbmQ6IG5vZGVfZmluZCxcbiAgc3VtOiBub2RlX3N1bSxcbiAgc29ydDogbm9kZV9zb3J0LFxuICBwYXRoOiBub2RlX3BhdGgsXG4gIGFuY2VzdG9yczogbm9kZV9hbmNlc3RvcnMsXG4gIGRlc2NlbmRhbnRzOiBub2RlX2Rlc2NlbmRhbnRzLFxuICBsZWF2ZXM6IG5vZGVfbGVhdmVzLFxuICBsaW5rczogbm9kZV9saW5rcyxcbiAgY29weTogbm9kZV9jb3B5LFxuICBbU3ltYm9sLml0ZXJhdG9yXTogbm9kZV9pdGVyYXRvclxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBjdXJyZW50LCBuZXh0ID0gW25vZGVdLCBjaGlsZHJlbiwgaSwgbjtcbiAgZG8ge1xuICAgIGN1cnJlbnQgPSBuZXh0LnJldmVyc2UoKSwgbmV4dCA9IFtdO1xuICAgIHdoaWxlIChub2RlID0gY3VycmVudC5wb3AoKSkge1xuICAgICAgeWllbGQgbm9kZTtcbiAgICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIG5leHQucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKG5leHQubGVuZ3RoKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbGVhdmVzID0gW107XG4gIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBsZWF2ZXMucHVzaChub2RlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGVhdmVzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciByb290ID0gdGhpcywgbGlua3MgPSBbXTtcbiAgcm9vdC5lYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAhPT0gcm9vdCkgeyAvLyBEb27igJl0IGluY2x1ZGUgdGhlIHJvb3TigJlzIHBhcmVudCwgaWYgYW55LlxuICAgICAgbGlua3MucHVzaCh7c291cmNlOiBub2RlLnBhcmVudCwgdGFyZ2V0OiBub2RlfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxpbmtzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZW5kKSB7XG4gIHZhciBzdGFydCA9IHRoaXMsXG4gICAgICBhbmNlc3RvciA9IGxlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhcnQsIGVuZCksXG4gICAgICBub2RlcyA9IFtzdGFydF07XG4gIHdoaWxlIChzdGFydCAhPT0gYW5jZXN0b3IpIHtcbiAgICBzdGFydCA9IHN0YXJ0LnBhcmVudDtcbiAgICBub2Rlcy5wdXNoKHN0YXJ0KTtcbiAgfVxuICB2YXIgayA9IG5vZGVzLmxlbmd0aDtcbiAgd2hpbGUgKGVuZCAhPT0gYW5jZXN0b3IpIHtcbiAgICBub2Rlcy5zcGxpY2UoaywgMCwgZW5kKTtcbiAgICBlbmQgPSBlbmQucGFyZW50O1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxuZnVuY3Rpb24gbGVhc3RDb21tb25BbmNlc3RvcihhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gYTtcbiAgdmFyIGFOb2RlcyA9IGEuYW5jZXN0b3JzKCksXG4gICAgICBiTm9kZXMgPSBiLmFuY2VzdG9ycygpLFxuICAgICAgYyA9IG51bGw7XG4gIGEgPSBhTm9kZXMucG9wKCk7XG4gIGIgPSBiTm9kZXMucG9wKCk7XG4gIHdoaWxlIChhID09PSBiKSB7XG4gICAgYyA9IGE7XG4gICAgYSA9IGFOb2Rlcy5wb3AoKTtcbiAgICBiID0gYk5vZGVzLnBvcCgpO1xuICB9XG4gIHJldHVybiBjO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICByZXR1cm4gdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBzdW0gPSArdmFsdWUobm9kZS5kYXRhKSB8fCAwLFxuICAgICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sXG4gICAgICAgIGkgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUgKC0taSA+PSAwKSBzdW0gKz0gY2hpbGRyZW5baV0udmFsdWU7XG4gICAgbm9kZS52YWx1ZSA9IHN1bTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge3NodWZmbGV9IGZyb20gXCIuLi9hcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjaXJjbGVzKSB7XG4gIHZhciBpID0gMCwgbiA9IChjaXJjbGVzID0gc2h1ZmZsZShBcnJheS5mcm9tKGNpcmNsZXMpKSkubGVuZ3RoLCBCID0gW10sIHAsIGU7XG5cbiAgd2hpbGUgKGkgPCBuKSB7XG4gICAgcCA9IGNpcmNsZXNbaV07XG4gICAgaWYgKGUgJiYgZW5jbG9zZXNXZWFrKGUsIHApKSArK2k7XG4gICAgZWxzZSBlID0gZW5jbG9zZUJhc2lzKEIgPSBleHRlbmRCYXNpcyhCLCBwKSksIGkgPSAwO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZEJhc2lzKEIsIHApIHtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGVuY2xvc2VzV2Vha0FsbChwLCBCKSkgcmV0dXJuIFtwXTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbGVtZW50LlxuICBmb3IgKGkgPSAwOyBpIDwgQi5sZW5ndGg7ICsraSkge1xuICAgIGlmIChlbmNsb3Nlc05vdChwLCBCW2ldKVxuICAgICAgICAmJiBlbmNsb3Nlc1dlYWtBbGwoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQikpIHtcbiAgICAgIHJldHVybiBbQltpXSwgcF07XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBCIG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gZWxlbWVudHMuXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgQi5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGVuY2xvc2VzTm90KGVuY2xvc2VCYXNpczIoQltpXSwgQltqXSksIHApXG4gICAgICAgICAgJiYgZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQltqXSlcbiAgICAgICAgICAmJiBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbal0sIHApLCBCW2ldKVxuICAgICAgICAgICYmIGVuY2xvc2VzV2Vha0FsbChlbmNsb3NlQmFzaXMzKEJbaV0sIEJbal0sIHApLCBCKSkge1xuICAgICAgICByZXR1cm4gW0JbaV0sIEJbal0sIHBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gc29tZXRoaW5nIGlzIHZlcnkgd3JvbmcuXG4gIHRocm93IG5ldyBFcnJvcjtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNOb3QoYSwgYikge1xuICB2YXIgZHIgPSBhLnIgLSBiLnIsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIGRyIDwgMCB8fCBkciAqIGRyIDwgZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VzV2VhayhhLCBiKSB7XG4gIHZhciBkciA9IGEuciAtIGIuciArIE1hdGgubWF4KGEuciwgYi5yLCAxKSAqIDFlLTksIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIGRyID4gMCAmJiBkciAqIGRyID4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VzV2Vha0FsbChhLCBCKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQi5sZW5ndGg7ICsraSkge1xuICAgIGlmICghZW5jbG9zZXNXZWFrKGEsIEJbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMoQikge1xuICBzd2l0Y2ggKEIubGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZW5jbG9zZUJhc2lzMShCWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBlbmNsb3NlQmFzaXMyKEJbMF0sIEJbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGVuY2xvc2VCYXNpczMoQlswXSwgQlsxXSwgQlsyXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzMShhKSB7XG4gIHJldHVybiB7XG4gICAgeDogYS54LFxuICAgIHk6IGEueSxcbiAgICByOiBhLnJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzMihhLCBiKSB7XG4gIHZhciB4MSA9IGEueCwgeTEgPSBhLnksIHIxID0gYS5yLFxuICAgICAgeDIgPSBiLngsIHkyID0gYi55LCByMiA9IGIucixcbiAgICAgIHgyMSA9IHgyIC0geDEsIHkyMSA9IHkyIC0geTEsIHIyMSA9IHIyIC0gcjEsXG4gICAgICBsID0gTWF0aC5zcXJ0KHgyMSAqIHgyMSArIHkyMSAqIHkyMSk7XG4gIHJldHVybiB7XG4gICAgeDogKHgxICsgeDIgKyB4MjEgLyBsICogcjIxKSAvIDIsXG4gICAgeTogKHkxICsgeTIgKyB5MjEgLyBsICogcjIxKSAvIDIsXG4gICAgcjogKGwgKyByMSArIHIyKSAvIDJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzMyhhLCBiLCBjKSB7XG4gIHZhciB4MSA9IGEueCwgeTEgPSBhLnksIHIxID0gYS5yLFxuICAgICAgeDIgPSBiLngsIHkyID0gYi55LCByMiA9IGIucixcbiAgICAgIHgzID0gYy54LCB5MyA9IGMueSwgcjMgPSBjLnIsXG4gICAgICBhMiA9IHgxIC0geDIsXG4gICAgICBhMyA9IHgxIC0geDMsXG4gICAgICBiMiA9IHkxIC0geTIsXG4gICAgICBiMyA9IHkxIC0geTMsXG4gICAgICBjMiA9IHIyIC0gcjEsXG4gICAgICBjMyA9IHIzIC0gcjEsXG4gICAgICBkMSA9IHgxICogeDEgKyB5MSAqIHkxIC0gcjEgKiByMSxcbiAgICAgIGQyID0gZDEgLSB4MiAqIHgyIC0geTIgKiB5MiArIHIyICogcjIsXG4gICAgICBkMyA9IGQxIC0geDMgKiB4MyAtIHkzICogeTMgKyByMyAqIHIzLFxuICAgICAgYWIgPSBhMyAqIGIyIC0gYTIgKiBiMyxcbiAgICAgIHhhID0gKGIyICogZDMgLSBiMyAqIGQyKSAvIChhYiAqIDIpIC0geDEsXG4gICAgICB4YiA9IChiMyAqIGMyIC0gYjIgKiBjMykgLyBhYixcbiAgICAgIHlhID0gKGEzICogZDIgLSBhMiAqIGQzKSAvIChhYiAqIDIpIC0geTEsXG4gICAgICB5YiA9IChhMiAqIGMzIC0gYTMgKiBjMikgLyBhYixcbiAgICAgIEEgPSB4YiAqIHhiICsgeWIgKiB5YiAtIDEsXG4gICAgICBCID0gMiAqIChyMSArIHhhICogeGIgKyB5YSAqIHliKSxcbiAgICAgIEMgPSB4YSAqIHhhICsgeWEgKiB5YSAtIHIxICogcjEsXG4gICAgICByID0gLShBID8gKEIgKyBNYXRoLnNxcnQoQiAqIEIgLSA0ICogQSAqIEMpKSAvICgyICogQSkgOiBDIC8gQik7XG4gIHJldHVybiB7XG4gICAgeDogeDEgKyB4YSArIHhiICogcixcbiAgICB5OiB5MSArIHlhICsgeWIgKiByLFxuICAgIHI6IHJcbiAgfTtcbn1cbiIsImltcG9ydCB7cGFja0VuY2xvc2V9IGZyb20gXCIuL3NpYmxpbmdzLmpzXCI7XG5pbXBvcnQge29wdGlvbmFsfSBmcm9tIFwiLi4vYWNjZXNzb3JzLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQsIHtjb25zdGFudFplcm99IGZyb20gXCIuLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBkZWZhdWx0UmFkaXVzKGQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkLnZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciByYWRpdXMgPSBudWxsLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgcGFkZGluZyA9IGNvbnN0YW50WmVybztcblxuICBmdW5jdGlvbiBwYWNrKHJvb3QpIHtcbiAgICByb290LnggPSBkeCAvIDIsIHJvb3QueSA9IGR5IC8gMjtcbiAgICBpZiAocmFkaXVzKSB7XG4gICAgICByb290LmVhY2hCZWZvcmUocmFkaXVzTGVhZihyYWRpdXMpKVxuICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKHBhZGRpbmcsIDAuNSkpXG4gICAgICAgICAgLmVhY2hCZWZvcmUodHJhbnNsYXRlQ2hpbGQoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LmVhY2hCZWZvcmUocmFkaXVzTGVhZihkZWZhdWx0UmFkaXVzKSlcbiAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihjb25zdGFudFplcm8sIDEpKVxuICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKHBhZGRpbmcsIHJvb3QuciAvIE1hdGgubWluKGR4LCBkeSkpKVxuICAgICAgICAgIC5lYWNoQmVmb3JlKHRyYW5zbGF0ZUNoaWxkKE1hdGgubWluKGR4LCBkeSkgLyAoMiAqIHJvb3QucikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBwYWNrLnJhZGl1cyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSBvcHRpb25hbCh4KSwgcGFjaykgOiByYWRpdXM7XG4gIH07XG5cbiAgcGFjay5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHBhY2spIDogW2R4LCBkeV07XG4gIH07XG5cbiAgcGFjay5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgcGFjaykgOiBwYWRkaW5nO1xuICB9O1xuXG4gIHJldHVybiBwYWNrO1xufVxuXG5mdW5jdGlvbiByYWRpdXNMZWFmKHJhZGl1cykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgbm9kZS5yID0gTWF0aC5tYXgoMCwgK3JhZGl1cyhub2RlKSB8fCAwKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhY2tDaGlsZHJlbihwYWRkaW5nLCBrKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikge1xuICAgICAgdmFyIGNoaWxkcmVuLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICByID0gcGFkZGluZyhub2RlKSAqIGsgfHwgMCxcbiAgICAgICAgICBlO1xuXG4gICAgICBpZiAocikgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY2hpbGRyZW5baV0uciArPSByO1xuICAgICAgZSA9IHBhY2tFbmNsb3NlKGNoaWxkcmVuKTtcbiAgICAgIGlmIChyKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGlsZHJlbltpXS5yIC09IHI7XG4gICAgICBub2RlLnIgPSBlICsgcjtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUNoaWxkKGspIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgbm9kZS5yICo9IGs7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgbm9kZS54ID0gcGFyZW50LnggKyBrICogbm9kZS54O1xuICAgICAgbm9kZS55ID0gcGFyZW50LnkgKyBrICogbm9kZS55O1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCBhcnJheSBmcm9tIFwiLi4vYXJyYXkuanNcIjtcbmltcG9ydCBlbmNsb3NlIGZyb20gXCIuL2VuY2xvc2UuanNcIjtcblxuZnVuY3Rpb24gcGxhY2UoYiwgYSwgYykge1xuICB2YXIgZHggPSBiLnggLSBhLngsIHgsIGEyLFxuICAgICAgZHkgPSBiLnkgLSBhLnksIHksIGIyLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgaWYgKGQyKSB7XG4gICAgYTIgPSBhLnIgKyBjLnIsIGEyICo9IGEyO1xuICAgIGIyID0gYi5yICsgYy5yLCBiMiAqPSBiMjtcbiAgICBpZiAoYTIgPiBiMikge1xuICAgICAgeCA9IChkMiArIGIyIC0gYTIpIC8gKDIgKiBkMik7XG4gICAgICB5ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGIyIC8gZDIgLSB4ICogeCkpO1xuICAgICAgYy54ID0gYi54IC0geCAqIGR4IC0geSAqIGR5O1xuICAgICAgYy55ID0gYi55IC0geCAqIGR5ICsgeSAqIGR4O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gKGQyICsgYTIgLSBiMikgLyAoMiAqIGQyKTtcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYTIgLyBkMiAtIHggKiB4KSk7XG4gICAgICBjLnggPSBhLnggKyB4ICogZHggLSB5ICogZHk7XG4gICAgICBjLnkgPSBhLnkgKyB4ICogZHkgKyB5ICogZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGMueCA9IGEueCArIGMucjtcbiAgICBjLnkgPSBhLnk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gIHZhciBkciA9IGEuciArIGIuciAtIDFlLTYsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIGRyID4gMCAmJiBkciAqIGRyID4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIHNjb3JlKG5vZGUpIHtcbiAgdmFyIGEgPSBub2RlLl8sXG4gICAgICBiID0gbm9kZS5uZXh0Ll8sXG4gICAgICBhYiA9IGEuciArIGIucixcbiAgICAgIGR4ID0gKGEueCAqIGIuciArIGIueCAqIGEucikgLyBhYixcbiAgICAgIGR5ID0gKGEueSAqIGIuciArIGIueSAqIGEucikgLyBhYjtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBOb2RlKGNpcmNsZSkge1xuICB0aGlzLl8gPSBjaXJjbGU7XG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMucHJldmlvdXMgPSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFja0VuY2xvc2UoY2lyY2xlcykge1xuICBpZiAoIShuID0gKGNpcmNsZXMgPSBhcnJheShjaXJjbGVzKSkubGVuZ3RoKSkgcmV0dXJuIDA7XG5cbiAgdmFyIGEsIGIsIGMsIG4sIGFhLCBjYSwgaSwgaiwgaywgc2osIHNrO1xuXG4gIC8vIFBsYWNlIHRoZSBmaXJzdCBjaXJjbGUuXG4gIGEgPSBjaXJjbGVzWzBdLCBhLnggPSAwLCBhLnkgPSAwO1xuICBpZiAoIShuID4gMSkpIHJldHVybiBhLnI7XG5cbiAgLy8gUGxhY2UgdGhlIHNlY29uZCBjaXJjbGUuXG4gIGIgPSBjaXJjbGVzWzFdLCBhLnggPSAtYi5yLCBiLnggPSBhLnIsIGIueSA9IDA7XG4gIGlmICghKG4gPiAyKSkgcmV0dXJuIGEuciArIGIucjtcblxuICAvLyBQbGFjZSB0aGUgdGhpcmQgY2lyY2xlLlxuICBwbGFjZShiLCBhLCBjID0gY2lyY2xlc1syXSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgZnJvbnQtY2hhaW4gdXNpbmcgdGhlIGZpcnN0IHRocmVlIGNpcmNsZXMgYSwgYiBhbmQgYy5cbiAgYSA9IG5ldyBOb2RlKGEpLCBiID0gbmV3IE5vZGUoYiksIGMgPSBuZXcgTm9kZShjKTtcbiAgYS5uZXh0ID0gYy5wcmV2aW91cyA9IGI7XG4gIGIubmV4dCA9IGEucHJldmlvdXMgPSBjO1xuICBjLm5leHQgPSBiLnByZXZpb3VzID0gYTtcblxuICAvLyBBdHRlbXB0IHRvIHBsYWNlIGVhY2ggcmVtYWluaW5nIGNpcmNsZeKAplxuICBwYWNrOiBmb3IgKGkgPSAzOyBpIDwgbjsgKytpKSB7XG4gICAgcGxhY2UoYS5fLCBiLl8sIGMgPSBjaXJjbGVzW2ldKSwgYyA9IG5ldyBOb2RlKGMpO1xuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBpbnRlcnNlY3RpbmcgY2lyY2xlIG9uIHRoZSBmcm9udC1jaGFpbiwgaWYgYW55LlxuICAgIC8vIOKAnENsb3NlbmVzc+KAnSBpcyBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZSBhbG9uZyB0aGUgZnJvbnQtY2hhaW4uXG4gICAgLy8g4oCcQWhlYWTigJ0gb3Ig4oCcYmVoaW5k4oCdIGlzIGxpa2V3aXNlIGRldGVybWluZWQgYnkgbGluZWFyIGRpc3RhbmNlLlxuICAgIGogPSBiLm5leHQsIGsgPSBhLnByZXZpb3VzLCBzaiA9IGIuXy5yLCBzayA9IGEuXy5yO1xuICAgIGRvIHtcbiAgICAgIGlmIChzaiA8PSBzaykge1xuICAgICAgICBpZiAoaW50ZXJzZWN0cyhqLl8sIGMuXykpIHtcbiAgICAgICAgICBiID0gaiwgYS5uZXh0ID0gYiwgYi5wcmV2aW91cyA9IGEsIC0taTtcbiAgICAgICAgICBjb250aW51ZSBwYWNrO1xuICAgICAgICB9XG4gICAgICAgIHNqICs9IGouXy5yLCBqID0gai5uZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoay5fLCBjLl8pKSB7XG4gICAgICAgICAgYSA9IGssIGEubmV4dCA9IGIsIGIucHJldmlvdXMgPSBhLCAtLWk7XG4gICAgICAgICAgY29udGludWUgcGFjaztcbiAgICAgICAgfVxuICAgICAgICBzayArPSBrLl8uciwgayA9IGsucHJldmlvdXM7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoaiAhPT0gay5uZXh0KTtcblxuICAgIC8vIFN1Y2Nlc3MhIEluc2VydCB0aGUgbmV3IGNpcmNsZSBjIGJldHdlZW4gYSBhbmQgYi5cbiAgICBjLnByZXZpb3VzID0gYSwgYy5uZXh0ID0gYiwgYS5uZXh0ID0gYi5wcmV2aW91cyA9IGIgPSBjO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV3IGNsb3Nlc3QgY2lyY2xlIHBhaXIgdG8gdGhlIGNlbnRyb2lkLlxuICAgIGFhID0gc2NvcmUoYSk7XG4gICAgd2hpbGUgKChjID0gYy5uZXh0KSAhPT0gYikge1xuICAgICAgaWYgKChjYSA9IHNjb3JlKGMpKSA8IGFhKSB7XG4gICAgICAgIGEgPSBjLCBhYSA9IGNhO1xuICAgICAgfVxuICAgIH1cbiAgICBiID0gYS5uZXh0O1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZW5jbG9zaW5nIGNpcmNsZSBvZiB0aGUgZnJvbnQgY2hhaW4uXG4gIGEgPSBbYi5fXSwgYyA9IGI7IHdoaWxlICgoYyA9IGMubmV4dCkgIT09IGIpIGEucHVzaChjLl8pOyBjID0gZW5jbG9zZShhKTtcblxuICAvLyBUcmFuc2xhdGUgdGhlIGNpcmNsZXMgdG8gcHV0IHRoZSBlbmNsb3NpbmcgY2lyY2xlIGFyb3VuZCB0aGUgb3JpZ2luLlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBhID0gY2lyY2xlc1tpXSwgYS54IC09IGMueCwgYS55IC09IGMueTtcblxuICByZXR1cm4gYy5yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjaXJjbGVzKSB7XG4gIHBhY2tFbmNsb3NlKGNpcmNsZXMpO1xuICByZXR1cm4gY2lyY2xlcztcbn1cbiIsImltcG9ydCByb3VuZE5vZGUgZnJvbSBcIi4vdHJlZW1hcC9yb3VuZC5qc1wiO1xuaW1wb3J0IHRyZWVtYXBEaWNlIGZyb20gXCIuL3RyZWVtYXAvZGljZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIHBhZGRpbmcgPSAwLFxuICAgICAgcm91bmQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBwYXJ0aXRpb24ocm9vdCkge1xuICAgIHZhciBuID0gcm9vdC5oZWlnaHQgKyAxO1xuICAgIHJvb3QueDAgPVxuICAgIHJvb3QueTAgPSBwYWRkaW5nO1xuICAgIHJvb3QueDEgPSBkeDtcbiAgICByb290LnkxID0gZHkgLyBuO1xuICAgIHJvb3QuZWFjaEJlZm9yZShwb3NpdGlvbk5vZGUoZHksIG4pKTtcbiAgICBpZiAocm91bmQpIHJvb3QuZWFjaEJlZm9yZShyb3VuZE5vZGUpO1xuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zaXRpb25Ob2RlKGR5LCBuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHRyZWVtYXBEaWNlKG5vZGUsIG5vZGUueDAsIGR5ICogKG5vZGUuZGVwdGggKyAxKSAvIG4sIG5vZGUueDEsIGR5ICogKG5vZGUuZGVwdGggKyAyKSAvIG4pO1xuICAgICAgfVxuICAgICAgdmFyIHgwID0gbm9kZS54MCxcbiAgICAgICAgICB5MCA9IG5vZGUueTAsXG4gICAgICAgICAgeDEgPSBub2RlLngxIC0gcGFkZGluZyxcbiAgICAgICAgICB5MSA9IG5vZGUueTEgLSBwYWRkaW5nO1xuICAgICAgaWYgKHgxIDwgeDApIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgaWYgKHkxIDwgeTApIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgbm9kZS54MCA9IHgwO1xuICAgICAgbm9kZS55MCA9IHkwO1xuICAgICAgbm9kZS54MSA9IHgxO1xuICAgICAgbm9kZS55MSA9IHkxO1xuICAgIH07XG4gIH1cblxuICBwYXJ0aXRpb24ucm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIXgsIHBhcnRpdGlvbikgOiByb3VuZDtcbiAgfTtcblxuICBwYXJ0aXRpb24uc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBwYXJ0aXRpb24pIDogW2R4LCBkeV07XG4gIH07XG5cbiAgcGFydGl0aW9uLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZyA9ICt4LCBwYXJ0aXRpb24pIDogcGFkZGluZztcbiAgfTtcblxuICByZXR1cm4gcGFydGl0aW9uO1xufVxuIiwiaW1wb3J0IHtyZXF1aXJlZH0gZnJvbSBcIi4vYWNjZXNzb3JzLmpzXCI7XG5pbXBvcnQge05vZGUsIGNvbXB1dGVIZWlnaHR9IGZyb20gXCIuL2hpZXJhcmNoeS9pbmRleC5qc1wiO1xuXG52YXIgcHJlcm9vdCA9IHtkZXB0aDogLTF9LFxuICAgIGFtYmlndW91cyA9IHt9O1xuXG5mdW5jdGlvbiBkZWZhdWx0SWQoZCkge1xuICByZXR1cm4gZC5pZDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBhcmVudElkKGQpIHtcbiAgcmV0dXJuIGQucGFyZW50SWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgaWQgPSBkZWZhdWx0SWQsXG4gICAgICBwYXJlbnRJZCA9IGRlZmF1bHRQYXJlbnRJZDtcblxuICBmdW5jdGlvbiBzdHJhdGlmeShkYXRhKSB7XG4gICAgdmFyIG5vZGVzID0gQXJyYXkuZnJvbShkYXRhKSxcbiAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgaSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIG5vZGVLZXksXG4gICAgICAgIG5vZGVCeUtleSA9IG5ldyBNYXA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBkID0gbm9kZXNbaV0sIG5vZGUgPSBub2Rlc1tpXSA9IG5ldyBOb2RlKGQpO1xuICAgICAgaWYgKChub2RlSWQgPSBpZChkLCBpLCBkYXRhKSkgIT0gbnVsbCAmJiAobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgIG5vZGVLZXkgPSBub2RlLmlkID0gbm9kZUlkO1xuICAgICAgICBub2RlQnlLZXkuc2V0KG5vZGVLZXksIG5vZGVCeUtleS5oYXMobm9kZUtleSkgPyBhbWJpZ3VvdXMgOiBub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICgobm9kZUlkID0gcGFyZW50SWQoZCwgaSwgZGF0YSkpICE9IG51bGwgJiYgKG5vZGVJZCArPSBcIlwiKSkge1xuICAgICAgICBub2RlLnBhcmVudCA9IG5vZGVJZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZUlkID0gbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgcGFyZW50ID0gbm9kZUJ5S2V5LmdldChub2RlSWQpO1xuICAgICAgICBpZiAoIXBhcmVudCkgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZzogXCIgKyBub2RlSWQpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBhbWJpZ3VvdXMpIHRocm93IG5ldyBFcnJvcihcImFtYmlndW91czogXCIgKyBub2RlSWQpO1xuICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuKSBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgZWxzZSBwYXJlbnQuY2hpbGRyZW4gPSBbbm9kZV07XG4gICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJvb3QpIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIHJvb3RzXCIpO1xuICAgICAgICByb290ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJvb3QpIHRocm93IG5ldyBFcnJvcihcIm5vIHJvb3RcIik7XG4gICAgcm9vdC5wYXJlbnQgPSBwcmVyb290O1xuICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7IG5vZGUuZGVwdGggPSBub2RlLnBhcmVudC5kZXB0aCArIDE7IC0tbjsgfSkuZWFjaEJlZm9yZShjb21wdXRlSGVpZ2h0KTtcbiAgICByb290LnBhcmVudCA9IG51bGw7XG4gICAgaWYgKG4gPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJjeWNsZVwiKTtcblxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgc3RyYXRpZnkuaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogaWQ7XG4gIH07XG5cbiAgc3RyYXRpZnkucGFyZW50SWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFyZW50SWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogcGFyZW50SWQ7XG4gIH07XG5cbiAgcmV0dXJuIHN0cmF0aWZ5O1xufVxuIiwiaW1wb3J0IHtOb2RlfSBmcm9tIFwiLi9oaWVyYXJjaHkvaW5kZXguanNcIjtcblxuZnVuY3Rpb24gZGVmYXVsdFNlcGFyYXRpb24oYSwgYikge1xuICByZXR1cm4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XG59XG5cbi8vIGZ1bmN0aW9uIHJhZGlhbFNlcGFyYXRpb24oYSwgYikge1xuLy8gICByZXR1cm4gKGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyKSAvIGEuZGVwdGg7XG4vLyB9XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB0cmF2ZXJzZSB0aGUgbGVmdCBjb250b3VyIG9mIGEgc3VidHJlZSAob3Jcbi8vIHN1YmZvcmVzdCkuIEl0IHJldHVybnMgdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91ci4gVGhpcyBzdWNjZXNzb3IgaXNcbi8vIGVpdGhlciBnaXZlbiBieSB0aGUgbGVmdG1vc3QgY2hpbGQgb2YgdiBvciBieSB0aGUgdGhyZWFkIG9mIHYuIFRoZSBmdW5jdGlvblxuLy8gcmV0dXJucyBudWxsIGlmIGFuZCBvbmx5IGlmIHYgaXMgb24gdGhlIGhpZ2hlc3QgbGV2ZWwgb2YgaXRzIHN1YnRyZWUuXG5mdW5jdGlvbiBuZXh0TGVmdCh2KSB7XG4gIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuWzBdIDogdi50O1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdvcmtzIGFuYWxvZ291c2x5IHRvIG5leHRMZWZ0LlxuZnVuY3Rpb24gbmV4dFJpZ2h0KHYpIHtcbiAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkcmVuID8gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gOiB2LnQ7XG59XG5cbi8vIFNoaWZ0cyB0aGUgY3VycmVudCBzdWJ0cmVlIHJvb3RlZCBhdCB3Ky4gVGhpcyBpcyBkb25lIGJ5IGluY3JlYXNpbmdcbi8vIHByZWxpbSh3KykgYW5kIG1vZCh3KykgYnkgc2hpZnQuXG5mdW5jdGlvbiBtb3ZlU3VidHJlZSh3bSwgd3AsIHNoaWZ0KSB7XG4gIHZhciBjaGFuZ2UgPSBzaGlmdCAvICh3cC5pIC0gd20uaSk7XG4gIHdwLmMgLT0gY2hhbmdlO1xuICB3cC5zICs9IHNoaWZ0O1xuICB3bS5jICs9IGNoYW5nZTtcbiAgd3AueiArPSBzaGlmdDtcbiAgd3AubSArPSBzaGlmdDtcbn1cblxuLy8gQWxsIG90aGVyIHNoaWZ0cywgYXBwbGllZCB0byB0aGUgc21hbGxlciBzdWJ0cmVlcyBiZXR3ZWVuIHctIGFuZCB3KywgYXJlXG4vLyBwZXJmb3JtZWQgYnkgdGhpcyBmdW5jdGlvbi4gVG8gcHJlcGFyZSB0aGUgc2hpZnRzLCB3ZSBoYXZlIHRvIGFkanVzdFxuLy8gY2hhbmdlKHcrKSwgc2hpZnQodyspLCBhbmQgY2hhbmdlKHctKS5cbmZ1bmN0aW9uIGV4ZWN1dGVTaGlmdHModikge1xuICB2YXIgc2hpZnQgPSAwLFxuICAgICAgY2hhbmdlID0gMCxcbiAgICAgIGNoaWxkcmVuID0gdi5jaGlsZHJlbixcbiAgICAgIGkgPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICB3O1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB3ID0gY2hpbGRyZW5baV07XG4gICAgdy56ICs9IHNoaWZ0O1xuICAgIHcubSArPSBzaGlmdDtcbiAgICBzaGlmdCArPSB3LnMgKyAoY2hhbmdlICs9IHcuYyk7XG4gIH1cbn1cblxuLy8gSWYgdmkt4oCZcyBhbmNlc3RvciBpcyBhIHNpYmxpbmcgb2YgdiwgcmV0dXJucyB2aS3igJlzIGFuY2VzdG9yLiBPdGhlcndpc2UsXG4vLyByZXR1cm5zIHRoZSBzcGVjaWZpZWQgKGRlZmF1bHQpIGFuY2VzdG9yLlxuZnVuY3Rpb24gbmV4dEFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpIHtcbiAgcmV0dXJuIHZpbS5hLnBhcmVudCA9PT0gdi5wYXJlbnQgPyB2aW0uYSA6IGFuY2VzdG9yO1xufVxuXG5mdW5jdGlvbiBUcmVlTm9kZShub2RlLCBpKSB7XG4gIHRoaXMuXyA9IG5vZGU7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuQSA9IG51bGw7IC8vIGRlZmF1bHQgYW5jZXN0b3JcbiAgdGhpcy5hID0gdGhpczsgLy8gYW5jZXN0b3JcbiAgdGhpcy56ID0gMDsgLy8gcHJlbGltXG4gIHRoaXMubSA9IDA7IC8vIG1vZFxuICB0aGlzLmMgPSAwOyAvLyBjaGFuZ2VcbiAgdGhpcy5zID0gMDsgLy8gc2hpZnRcbiAgdGhpcy50ID0gbnVsbDsgLy8gdGhyZWFkXG4gIHRoaXMuaSA9IGk7IC8vIG51bWJlclxufVxuXG5UcmVlTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gdHJlZVJvb3Qocm9vdCkge1xuICB2YXIgdHJlZSA9IG5ldyBUcmVlTm9kZShyb290LCAwKSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlcyA9IFt0cmVlXSxcbiAgICAgIGNoaWxkLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBpLFxuICAgICAgbjtcblxuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgaWYgKGNoaWxkcmVuID0gbm9kZS5fLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLmNoaWxkcmVuID0gbmV3IEFycmF5KG4gPSBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldID0gbmV3IFRyZWVOb2RlKGNoaWxkcmVuW2ldLCBpKSk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgKHRyZWUucGFyZW50ID0gbmV3IFRyZWVOb2RlKG51bGwsIDApKS5jaGlsZHJlbiA9IFt0cmVlXTtcbiAgcmV0dXJuIHRyZWU7XG59XG5cbi8vIE5vZGUtbGluayB0cmVlIGRpYWdyYW0gdXNpbmcgdGhlIFJlaW5nb2xkLVRpbGZvcmQgXCJ0aWR5XCIgYWxnb3JpdGhtXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbixcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIG5vZGVTaXplID0gbnVsbDtcblxuICBmdW5jdGlvbiB0cmVlKHJvb3QpIHtcbiAgICB2YXIgdCA9IHRyZWVSb290KHJvb3QpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbGF5b3V0IHVzaW5nIEJ1Y2hoZWltIGV0IGFsLuKAmXMgYWxnb3JpdGhtLlxuICAgIHQuZWFjaEFmdGVyKGZpcnN0V2FsayksIHQucGFyZW50Lm0gPSAtdC56O1xuICAgIHQuZWFjaEJlZm9yZShzZWNvbmRXYWxrKTtcblxuICAgIC8vIElmIGEgZml4ZWQgbm9kZSBzaXplIGlzIHNwZWNpZmllZCwgc2NhbGUgeCBhbmQgeS5cbiAgICBpZiAobm9kZVNpemUpIHJvb3QuZWFjaEJlZm9yZShzaXplTm9kZSk7XG5cbiAgICAvLyBJZiBhIGZpeGVkIHRyZWUgc2l6ZSBpcyBzcGVjaWZpZWQsIHNjYWxlIHggYW5kIHkgYmFzZWQgb24gdGhlIGV4dGVudC5cbiAgICAvLyBDb21wdXRlIHRoZSBsZWZ0LW1vc3QsIHJpZ2h0LW1vc3QsIGFuZCBkZXB0aC1tb3N0IG5vZGVzIGZvciBleHRlbnRzLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGxlZnQgPSByb290LFxuICAgICAgICAgIHJpZ2h0ID0gcm9vdCxcbiAgICAgICAgICBib3R0b20gPSByb290O1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUueCA8IGxlZnQueCkgbGVmdCA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlLnggPiByaWdodC54KSByaWdodCA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlLmRlcHRoID4gYm90dG9tLmRlcHRoKSBib3R0b20gPSBub2RlO1xuICAgICAgfSk7XG4gICAgICB2YXIgcyA9IGxlZnQgPT09IHJpZ2h0ID8gMSA6IHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMixcbiAgICAgICAgICB0eCA9IHMgLSBsZWZ0LngsXG4gICAgICAgICAga3ggPSBkeCAvIChyaWdodC54ICsgcyArIHR4KSxcbiAgICAgICAgICBreSA9IGR5IC8gKGJvdHRvbS5kZXB0aCB8fCAxKTtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggKyB0eCkgKiBreDtcbiAgICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGt5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICAvLyBDb21wdXRlcyBhIHByZWxpbWluYXJ5IHgtY29vcmRpbmF0ZSBmb3Igdi4gQmVmb3JlIHRoYXQsIEZJUlNUIFdBTEsgaXNcbiAgLy8gYXBwbGllZCByZWN1cnNpdmVseSB0byB0aGUgY2hpbGRyZW4gb2YgdiwgYXMgd2VsbCBhcyB0aGUgZnVuY3Rpb25cbiAgLy8gQVBQT1JUSU9OLiBBZnRlciBzcGFjaW5nIG91dCB0aGUgY2hpbGRyZW4gYnkgY2FsbGluZyBFWEVDVVRFIFNISUZUUywgdGhlXG4gIC8vIG5vZGUgdiBpcyBwbGFjZWQgdG8gdGhlIG1pZHBvaW50IG9mIGl0cyBvdXRlcm1vc3QgY2hpbGRyZW4uXG4gIGZ1bmN0aW9uIGZpcnN0V2Fsayh2KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbixcbiAgICAgICAgc2libGluZ3MgPSB2LnBhcmVudC5jaGlsZHJlbixcbiAgICAgICAgdyA9IHYuaSA/IHNpYmxpbmdzW3YuaSAtIDFdIDogbnVsbDtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGV4ZWN1dGVTaGlmdHModik7XG4gICAgICB2YXIgbWlkcG9pbnQgPSAoY2hpbGRyZW5bMF0ueiArIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnopIC8gMjtcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgICAgICB2Lm0gPSB2LnogLSBtaWRwb2ludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYueiA9IG1pZHBvaW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodykge1xuICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgfVxuICAgIHYucGFyZW50LkEgPSBhcHBvcnRpb24odiwgdywgdi5wYXJlbnQuQSB8fCBzaWJsaW5nc1swXSk7XG4gIH1cblxuICAvLyBDb21wdXRlcyBhbGwgcmVhbCB4LWNvb3JkaW5hdGVzIGJ5IHN1bW1pbmcgdXAgdGhlIG1vZGlmaWVycyByZWN1cnNpdmVseS5cbiAgZnVuY3Rpb24gc2Vjb25kV2Fsayh2KSB7XG4gICAgdi5fLnggPSB2LnogKyB2LnBhcmVudC5tO1xuICAgIHYubSArPSB2LnBhcmVudC5tO1xuICB9XG5cbiAgLy8gVGhlIGNvcmUgb2YgdGhlIGFsZ29yaXRobS4gSGVyZSwgYSBuZXcgc3VidHJlZSBpcyBjb21iaW5lZCB3aXRoIHRoZVxuICAvLyBwcmV2aW91cyBzdWJ0cmVlcy4gVGhyZWFkcyBhcmUgdXNlZCB0byB0cmF2ZXJzZSB0aGUgaW5zaWRlIGFuZCBvdXRzaWRlXG4gIC8vIGNvbnRvdXJzIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlIHVwIHRvIHRoZSBoaWdoZXN0IGNvbW1vbiBsZXZlbC4gVGhlXG4gIC8vIHZlcnRpY2VzIHVzZWQgZm9yIHRoZSB0cmF2ZXJzYWxzIGFyZSB2aSssIHZpLSwgdm8tLCBhbmQgdm8rLCB3aGVyZSB0aGVcbiAgLy8gc3VwZXJzY3JpcHQgbyBtZWFucyBvdXRzaWRlIGFuZCBpIG1lYW5zIGluc2lkZSwgdGhlIHN1YnNjcmlwdCAtIG1lYW5zIGxlZnRcbiAgLy8gc3VidHJlZSBhbmQgKyBtZWFucyByaWdodCBzdWJ0cmVlLiBGb3Igc3VtbWluZyB1cCB0aGUgbW9kaWZpZXJzIGFsb25nIHRoZVxuICAvLyBjb250b3VyLCB3ZSB1c2UgcmVzcGVjdGl2ZSB2YXJpYWJsZXMgc2krLCBzaS0sIHNvLSwgYW5kIHNvKy4gV2hlbmV2ZXIgdHdvXG4gIC8vIG5vZGVzIG9mIHRoZSBpbnNpZGUgY29udG91cnMgY29uZmxpY3QsIHdlIGNvbXB1dGUgdGhlIGxlZnQgb25lIG9mIHRoZVxuICAvLyBncmVhdGVzdCB1bmNvbW1vbiBhbmNlc3RvcnMgdXNpbmcgdGhlIGZ1bmN0aW9uIEFOQ0VTVE9SIGFuZCBjYWxsIE1PVkVcbiAgLy8gU1VCVFJFRSB0byBzaGlmdCB0aGUgc3VidHJlZSBhbmQgcHJlcGFyZSB0aGUgc2hpZnRzIG9mIHNtYWxsZXIgc3VidHJlZXMuXG4gIC8vIEZpbmFsbHksIHdlIGFkZCBhIG5ldyB0aHJlYWQgKGlmIG5lY2Vzc2FyeSkuXG4gIGZ1bmN0aW9uIGFwcG9ydGlvbih2LCB3LCBhbmNlc3Rvcikge1xuICAgIGlmICh3KSB7XG4gICAgICB2YXIgdmlwID0gdixcbiAgICAgICAgICB2b3AgPSB2LFxuICAgICAgICAgIHZpbSA9IHcsXG4gICAgICAgICAgdm9tID0gdmlwLnBhcmVudC5jaGlsZHJlblswXSxcbiAgICAgICAgICBzaXAgPSB2aXAubSxcbiAgICAgICAgICBzb3AgPSB2b3AubSxcbiAgICAgICAgICBzaW0gPSB2aW0ubSxcbiAgICAgICAgICBzb20gPSB2b20ubSxcbiAgICAgICAgICBzaGlmdDtcbiAgICAgIHdoaWxlICh2aW0gPSBuZXh0UmlnaHQodmltKSwgdmlwID0gbmV4dExlZnQodmlwKSwgdmltICYmIHZpcCkge1xuICAgICAgICB2b20gPSBuZXh0TGVmdCh2b20pO1xuICAgICAgICB2b3AgPSBuZXh0UmlnaHQodm9wKTtcbiAgICAgICAgdm9wLmEgPSB2O1xuICAgICAgICBzaGlmdCA9IHZpbS56ICsgc2ltIC0gdmlwLnogLSBzaXAgKyBzZXBhcmF0aW9uKHZpbS5fLCB2aXAuXyk7XG4gICAgICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgICAgICBtb3ZlU3VidHJlZShuZXh0QW5jZXN0b3IodmltLCB2LCBhbmNlc3RvciksIHYsIHNoaWZ0KTtcbiAgICAgICAgICBzaXAgKz0gc2hpZnQ7XG4gICAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgICB9XG4gICAgICAgIHNpbSArPSB2aW0ubTtcbiAgICAgICAgc2lwICs9IHZpcC5tO1xuICAgICAgICBzb20gKz0gdm9tLm07XG4gICAgICAgIHNvcCArPSB2b3AubTtcbiAgICAgIH1cbiAgICAgIGlmICh2aW0gJiYgIW5leHRSaWdodCh2b3ApKSB7XG4gICAgICAgIHZvcC50ID0gdmltO1xuICAgICAgICB2b3AubSArPSBzaW0gLSBzb3A7XG4gICAgICB9XG4gICAgICBpZiAodmlwICYmICFuZXh0TGVmdCh2b20pKSB7XG4gICAgICAgIHZvbS50ID0gdmlwO1xuICAgICAgICB2b20ubSArPSBzaXAgLSBzb207XG4gICAgICAgIGFuY2VzdG9yID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFuY2VzdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gc2l6ZU5vZGUobm9kZSkge1xuICAgIG5vZGUueCAqPSBkeDtcbiAgICBub2RlLnkgPSBub2RlLmRlcHRoICogZHk7XG4gIH1cblxuICB0cmVlLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2VwYXJhdGlvbiA9IHgsIHRyZWUpIDogc2VwYXJhdGlvbjtcbiAgfTtcblxuICB0cmVlLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSBmYWxzZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgdHJlZSkgOiAobm9kZVNpemUgPyBudWxsIDogW2R4LCBkeV0pO1xuICB9O1xuXG4gIHRyZWUubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSB0cnVlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlKSA6IChub2RlU2l6ZSA/IFtkeCwgZHldIDogbnVsbCk7XG4gIH07XG5cbiAgcmV0dXJuIHRyZWU7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIGksIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBzdW0sIHN1bXMgPSBuZXcgQXJyYXkobiArIDEpO1xuXG4gIGZvciAoc3Vtc1swXSA9IHN1bSA9IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgc3Vtc1tpICsgMV0gPSBzdW0gKz0gbm9kZXNbaV0udmFsdWU7XG4gIH1cblxuICBwYXJ0aXRpb24oMCwgbiwgcGFyZW50LnZhbHVlLCB4MCwgeTAsIHgxLCB5MSk7XG5cbiAgZnVuY3Rpb24gcGFydGl0aW9uKGksIGosIHZhbHVlLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGlmIChpID49IGogLSAxKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgbm9kZS54MCA9IHgwLCBub2RlLnkwID0geTA7XG4gICAgICBub2RlLngxID0geDEsIG5vZGUueTEgPSB5MTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVPZmZzZXQgPSBzdW1zW2ldLFxuICAgICAgICB2YWx1ZVRhcmdldCA9ICh2YWx1ZSAvIDIpICsgdmFsdWVPZmZzZXQsXG4gICAgICAgIGsgPSBpICsgMSxcbiAgICAgICAgaGkgPSBqIC0gMTtcblxuICAgIHdoaWxlIChrIDwgaGkpIHtcbiAgICAgIHZhciBtaWQgPSBrICsgaGkgPj4+IDE7XG4gICAgICBpZiAoc3Vtc1ttaWRdIDwgdmFsdWVUYXJnZXQpIGsgPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG5cbiAgICBpZiAoKHZhbHVlVGFyZ2V0IC0gc3Vtc1trIC0gMV0pIDwgKHN1bXNba10gLSB2YWx1ZVRhcmdldCkgJiYgaSArIDEgPCBrKSAtLWs7XG5cbiAgICB2YXIgdmFsdWVMZWZ0ID0gc3Vtc1trXSAtIHZhbHVlT2Zmc2V0LFxuICAgICAgICB2YWx1ZVJpZ2h0ID0gdmFsdWUgLSB2YWx1ZUxlZnQ7XG5cbiAgICBpZiAoKHgxIC0geDApID4gKHkxIC0geTApKSB7XG4gICAgICB2YXIgeGsgPSB2YWx1ZSA/ICh4MCAqIHZhbHVlUmlnaHQgKyB4MSAqIHZhbHVlTGVmdCkgLyB2YWx1ZSA6IHgxO1xuICAgICAgcGFydGl0aW9uKGksIGssIHZhbHVlTGVmdCwgeDAsIHkwLCB4aywgeTEpO1xuICAgICAgcGFydGl0aW9uKGssIGosIHZhbHVlUmlnaHQsIHhrLCB5MCwgeDEsIHkxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHlrID0gdmFsdWUgPyAoeTAgKiB2YWx1ZVJpZ2h0ICsgeTEgKiB2YWx1ZUxlZnQpIC8gdmFsdWUgOiB5MTtcbiAgICAgIHBhcnRpdGlvbihpLCBrLCB2YWx1ZUxlZnQsIHgwLCB5MCwgeDEsIHlrKTtcbiAgICAgIHBhcnRpdGlvbihrLCBqLCB2YWx1ZVJpZ2h0LCB4MCwgeWssIHgxLCB5MSk7XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIG5vZGUsXG4gICAgICBpID0gLTEsXG4gICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgayA9IHBhcmVudC52YWx1ZSAmJiAoeDEgLSB4MCkgLyBwYXJlbnQudmFsdWU7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueTAgPSB5MCwgbm9kZS55MSA9IHkxO1xuICAgIG5vZGUueDAgPSB4MCwgbm9kZS54MSA9IHgwICs9IG5vZGUudmFsdWUgKiBrO1xuICB9XG59XG4iLCJpbXBvcnQgcm91bmROb2RlIGZyb20gXCIuL3JvdW5kLmpzXCI7XG5pbXBvcnQgc3F1YXJpZnkgZnJvbSBcIi4vc3F1YXJpZnkuanNcIjtcbmltcG9ydCB7cmVxdWlyZWR9IGZyb20gXCIuLi9hY2Nlc3NvcnMuanNcIjtcbmltcG9ydCBjb25zdGFudCwge2NvbnN0YW50WmVyb30gZnJvbSBcIi4uL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgdGlsZSA9IHNxdWFyaWZ5LFxuICAgICAgcm91bmQgPSBmYWxzZSxcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIHBhZGRpbmdTdGFjayA9IFswXSxcbiAgICAgIHBhZGRpbmdJbm5lciA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdUb3AgPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nUmlnaHQgPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nQm90dG9tID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ0xlZnQgPSBjb25zdGFudFplcm87XG5cbiAgZnVuY3Rpb24gdHJlZW1hcChyb290KSB7XG4gICAgcm9vdC54MCA9XG4gICAgcm9vdC55MCA9IDA7XG4gICAgcm9vdC54MSA9IGR4O1xuICAgIHJvb3QueTEgPSBkeTtcbiAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKTtcbiAgICBwYWRkaW5nU3RhY2sgPSBbMF07XG4gICAgaWYgKHJvdW5kKSByb290LmVhY2hCZWZvcmUocm91bmROb2RlKTtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTm9kZShub2RlKSB7XG4gICAgdmFyIHAgPSBwYWRkaW5nU3RhY2tbbm9kZS5kZXB0aF0sXG4gICAgICAgIHgwID0gbm9kZS54MCArIHAsXG4gICAgICAgIHkwID0gbm9kZS55MCArIHAsXG4gICAgICAgIHgxID0gbm9kZS54MSAtIHAsXG4gICAgICAgIHkxID0gbm9kZS55MSAtIHA7XG4gICAgaWYgKHgxIDwgeDApIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xuICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICBub2RlLngwID0geDA7XG4gICAgbm9kZS55MCA9IHkwO1xuICAgIG5vZGUueDEgPSB4MTtcbiAgICBub2RlLnkxID0geTE7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHAgPSBwYWRkaW5nU3RhY2tbbm9kZS5kZXB0aCArIDFdID0gcGFkZGluZ0lubmVyKG5vZGUpIC8gMjtcbiAgICAgIHgwICs9IHBhZGRpbmdMZWZ0KG5vZGUpIC0gcDtcbiAgICAgIHkwICs9IHBhZGRpbmdUb3Aobm9kZSkgLSBwO1xuICAgICAgeDEgLT0gcGFkZGluZ1JpZ2h0KG5vZGUpIC0gcDtcbiAgICAgIHkxIC09IHBhZGRpbmdCb3R0b20obm9kZSkgLSBwO1xuICAgICAgaWYgKHgxIDwgeDApIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgaWYgKHkxIDwgeTApIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgdGlsZShub2RlLCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgfVxuICB9XG5cbiAgdHJlZW1hcC5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEheCwgdHJlZW1hcCkgOiByb3VuZDtcbiAgfTtcblxuICB0cmVlbWFwLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgdHJlZW1hcCkgOiBbZHgsIGR5XTtcbiAgfTtcblxuICB0cmVlbWFwLnRpbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlsZSA9IHJlcXVpcmVkKHgpLCB0cmVlbWFwKSA6IHRpbGU7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdHJlZW1hcC5wYWRkaW5nSW5uZXIoeCkucGFkZGluZ091dGVyKHgpIDogdHJlZW1hcC5wYWRkaW5nSW5uZXIoKTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmVlbWFwLnBhZGRpbmdUb3AoeCkucGFkZGluZ1JpZ2h0KHgpLnBhZGRpbmdCb3R0b20oeCkucGFkZGluZ0xlZnQoeCkgOiB0cmVlbWFwLnBhZGRpbmdUb3AoKTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdUb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ1RvcCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdUb3A7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nUmlnaHQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ1JpZ2h0ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ1JpZ2h0O1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ0JvdHRvbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nQm90dG9tID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ0JvdHRvbTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdMZWZ0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdMZWZ0ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ0xlZnQ7XG4gIH07XG5cbiAgcmV0dXJuIHRyZWVtYXA7XG59XG4iLCJpbXBvcnQgdHJlZW1hcERpY2UgZnJvbSBcIi4vZGljZS5qc1wiO1xuaW1wb3J0IHRyZWVtYXBTbGljZSBmcm9tIFwiLi9zbGljZS5qc1wiO1xuaW1wb3J0IHtwaGksIHNxdWFyaWZ5UmF0aW99IGZyb20gXCIuL3NxdWFyaWZ5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20ocmF0aW8pIHtcblxuICBmdW5jdGlvbiByZXNxdWFyaWZ5KHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBpZiAoKHJvd3MgPSBwYXJlbnQuX3NxdWFyaWZ5KSAmJiAocm93cy5yYXRpbyA9PT0gcmF0aW8pKSB7XG4gICAgICB2YXIgcm93cyxcbiAgICAgICAgICByb3csXG4gICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBqID0gLTEsXG4gICAgICAgICAgbixcbiAgICAgICAgICBtID0gcm93cy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBwYXJlbnQudmFsdWU7XG5cbiAgICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICAgIHJvdyA9IHJvd3Nbal0sIG5vZGVzID0gcm93LmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGkgPSByb3cudmFsdWUgPSAwLCBuID0gbm9kZXMubGVuZ3RoOyBpIDwgbjsgKytpKSByb3cudmFsdWUgKz0gbm9kZXNbaV0udmFsdWU7XG4gICAgICAgIGlmIChyb3cuZGljZSkgdHJlZW1hcERpY2Uocm93LCB4MCwgeTAsIHgxLCB2YWx1ZSA/IHkwICs9ICh5MSAtIHkwKSAqIHJvdy52YWx1ZSAvIHZhbHVlIDogeTEpO1xuICAgICAgICBlbHNlIHRyZWVtYXBTbGljZShyb3csIHgwLCB5MCwgdmFsdWUgPyB4MCArPSAoeDEgLSB4MCkgKiByb3cudmFsdWUgLyB2YWx1ZSA6IHgxLCB5MSk7XG4gICAgICAgIHZhbHVlIC09IHJvdy52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Ll9zcXVhcmlmeSA9IHJvd3MgPSBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgIHJvd3MucmF0aW8gPSByYXRpbztcbiAgICB9XG4gIH1cblxuICByZXNxdWFyaWZ5LnJhdGlvID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjdXN0b20oKHggPSAreCkgPiAxID8geCA6IDEpO1xuICB9O1xuXG4gIHJldHVybiByZXNxdWFyaWZ5O1xufSkocGhpKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS54MCA9IE1hdGgucm91bmQobm9kZS54MCk7XG4gIG5vZGUueTAgPSBNYXRoLnJvdW5kKG5vZGUueTApO1xuICBub2RlLngxID0gTWF0aC5yb3VuZChub2RlLngxKTtcbiAgbm9kZS55MSA9IE1hdGgucm91bmQobm9kZS55MSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIG5vZGUsXG4gICAgICBpID0gLTEsXG4gICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgayA9IHBhcmVudC52YWx1ZSAmJiAoeTEgLSB5MCkgLyBwYXJlbnQudmFsdWU7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueDAgPSB4MCwgbm9kZS54MSA9IHgxO1xuICAgIG5vZGUueTAgPSB5MCwgbm9kZS55MSA9IHkwICs9IG5vZGUudmFsdWUgKiBrO1xuICB9XG59XG4iLCJpbXBvcnQgZGljZSBmcm9tIFwiLi9kaWNlLmpzXCI7XG5pbXBvcnQgc2xpY2UgZnJvbSBcIi4vc2xpY2UuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAocGFyZW50LmRlcHRoICYgMSA/IHNsaWNlIDogZGljZSkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG59XG4iLCJpbXBvcnQgdHJlZW1hcERpY2UgZnJvbSBcIi4vZGljZS5qc1wiO1xuaW1wb3J0IHRyZWVtYXBTbGljZSBmcm9tIFwiLi9zbGljZS5qc1wiO1xuXG5leHBvcnQgdmFyIHBoaSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciByb3dzID0gW10sXG4gICAgICBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIHJvdyxcbiAgICAgIG5vZGVWYWx1ZSxcbiAgICAgIGkwID0gMCxcbiAgICAgIGkxID0gMCxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBkeCwgZHksXG4gICAgICB2YWx1ZSA9IHBhcmVudC52YWx1ZSxcbiAgICAgIHN1bVZhbHVlLFxuICAgICAgbWluVmFsdWUsXG4gICAgICBtYXhWYWx1ZSxcbiAgICAgIG5ld1JhdGlvLFxuICAgICAgbWluUmF0aW8sXG4gICAgICBhbHBoYSxcbiAgICAgIGJldGE7XG5cbiAgd2hpbGUgKGkwIDwgbikge1xuICAgIGR4ID0geDEgLSB4MCwgZHkgPSB5MSAtIHkwO1xuXG4gICAgLy8gRmluZCB0aGUgbmV4dCBub24tZW1wdHkgbm9kZS5cbiAgICBkbyBzdW1WYWx1ZSA9IG5vZGVzW2kxKytdLnZhbHVlOyB3aGlsZSAoIXN1bVZhbHVlICYmIGkxIDwgbik7XG4gICAgbWluVmFsdWUgPSBtYXhWYWx1ZSA9IHN1bVZhbHVlO1xuICAgIGFscGhhID0gTWF0aC5tYXgoZHkgLyBkeCwgZHggLyBkeSkgLyAodmFsdWUgKiByYXRpbyk7XG4gICAgYmV0YSA9IHN1bVZhbHVlICogc3VtVmFsdWUgKiBhbHBoYTtcbiAgICBtaW5SYXRpbyA9IE1hdGgubWF4KG1heFZhbHVlIC8gYmV0YSwgYmV0YSAvIG1pblZhbHVlKTtcblxuICAgIC8vIEtlZXAgYWRkaW5nIG5vZGVzIHdoaWxlIHRoZSBhc3BlY3QgcmF0aW8gbWFpbnRhaW5zIG9yIGltcHJvdmVzLlxuICAgIGZvciAoOyBpMSA8IG47ICsraTEpIHtcbiAgICAgIHN1bVZhbHVlICs9IG5vZGVWYWx1ZSA9IG5vZGVzW2kxXS52YWx1ZTtcbiAgICAgIGlmIChub2RlVmFsdWUgPCBtaW5WYWx1ZSkgbWluVmFsdWUgPSBub2RlVmFsdWU7XG4gICAgICBpZiAobm9kZVZhbHVlID4gbWF4VmFsdWUpIG1heFZhbHVlID0gbm9kZVZhbHVlO1xuICAgICAgYmV0YSA9IHN1bVZhbHVlICogc3VtVmFsdWUgKiBhbHBoYTtcbiAgICAgIG5ld1JhdGlvID0gTWF0aC5tYXgobWF4VmFsdWUgLyBiZXRhLCBiZXRhIC8gbWluVmFsdWUpO1xuICAgICAgaWYgKG5ld1JhdGlvID4gbWluUmF0aW8pIHsgc3VtVmFsdWUgLT0gbm9kZVZhbHVlOyBicmVhazsgfVxuICAgICAgbWluUmF0aW8gPSBuZXdSYXRpbztcbiAgICB9XG5cbiAgICAvLyBQb3NpdGlvbiBhbmQgcmVjb3JkIHRoZSByb3cgb3JpZW50YXRpb24uXG4gICAgcm93cy5wdXNoKHJvdyA9IHt2YWx1ZTogc3VtVmFsdWUsIGRpY2U6IGR4IDwgZHksIGNoaWxkcmVuOiBub2Rlcy5zbGljZShpMCwgaTEpfSk7XG4gICAgaWYgKHJvdy5kaWNlKSB0cmVlbWFwRGljZShyb3csIHgwLCB5MCwgeDEsIHZhbHVlID8geTAgKz0gZHkgKiBzdW1WYWx1ZSAvIHZhbHVlIDogeTEpO1xuICAgIGVsc2UgdHJlZW1hcFNsaWNlKHJvdywgeDAsIHkwLCB2YWx1ZSA/IHgwICs9IGR4ICogc3VtVmFsdWUgLyB2YWx1ZSA6IHgxLCB5MSk7XG4gICAgdmFsdWUgLT0gc3VtVmFsdWUsIGkwID0gaTE7XG4gIH1cblxuICByZXR1cm4gcm93cztcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShyYXRpbykge1xuXG4gIGZ1bmN0aW9uIHNxdWFyaWZ5KHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcbiAgfVxuXG4gIHNxdWFyaWZ5LnJhdGlvID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjdXN0b20oKHggPSAreCkgPiAxID8geCA6IDEpO1xuICB9O1xuXG4gIHJldHVybiBzcXVhcmlmeTtcbn0pKHBoaSk7XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcbmltcG9ydCBudW1iZXJBcnJheSwge2lzTnVtYmVyQXJyYXl9IGZyb20gXCIuL251bWJlckFycmF5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIChpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXkgOiBnZW5lcmljQXJyYXkpKGEsIGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJpY0FycmF5KGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcbiAgICAgIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgeCA9IG5ldyBBcnJheShuYSksXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSB2YWx1ZShhW2ldLCBiW2ldKTtcbiAgZm9yICg7IGkgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgdmFyIHQyID0gdDEgKiB0MSwgdDMgPSB0MiAqIHQxO1xuICByZXR1cm4gKCgxIC0gMyAqIHQxICsgMyAqIHQyIC0gdDMpICogdjBcbiAgICAgICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjFcbiAgICAgICsgKDEgKyAzICogdDEgKyAzICogdDIgLSAzICogdDMpICogdjJcbiAgICAgICsgdDMgKiB2MykgLyA2O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQgPD0gMCA/ICh0ID0gMCkgOiB0ID49IDEgPyAodCA9IDEsIG4gLSAxKSA6IE1hdGguZmxvb3IodCAqIG4pLFxuICAgICAgICB2MSA9IHZhbHVlc1tpXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbaSArIDFdLFxuICAgICAgICB2MCA9IGkgPiAwID8gdmFsdWVzW2kgLSAxXSA6IDIgKiB2MSAtIHYyLFxuICAgICAgICB2MyA9IGkgPCBuIC0gMSA/IHZhbHVlc1tpICsgMl0gOiAyICogdjIgLSB2MTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQge2Jhc2lzfSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcigoKHQgJT0gMSkgPCAwID8gKyt0IDogdCkgKiBuKSxcbiAgICAgICAgdjAgPSB2YWx1ZXNbKGkgKyBuIC0gMSkgJSBuXSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxuICAgICAgICB2MiA9IHZhbHVlc1soaSArIDEpICUgbl0sXG4gICAgICAgIHYzID0gdmFsdWVzWyhpICsgMikgJSBuXTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZnVuY3Rpb24gbGluZWFyKGEsIGQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSArIHQgKiBkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHBvbmVudGlhbChhLCBiLCB5KSB7XG4gIHJldHVybiBhID0gTWF0aC5wb3coYSwgeSksIGIgPSBNYXRoLnBvdyhiLCB5KSAtIGEsIHkgPSAxIC8geSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhhICsgdCAqIGIsIHkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHVlKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhbW1hKHkpIHtcbiAgcmV0dXJuICh5ID0gK3kpID09PSAxID8gbm9nYW1tYSA6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGEgPyBleHBvbmVudGlhbChhLCBiLCB5KSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IHggPT4gKCkgPT4geDtcbiIsImltcG9ydCB7Y3ViZWhlbGl4IGFzIGNvbG9yQ3ViZWhlbGl4fSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciwge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZnVuY3Rpb24gY3ViZWhlbGl4KGh1ZSkge1xuICByZXR1cm4gKGZ1bmN0aW9uIGN1YmVoZWxpeEdhbW1hKHkpIHtcbiAgICB5ID0gK3k7XG5cbiAgICBmdW5jdGlvbiBjdWJlaGVsaXgoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gY29sb3JDdWJlaGVsaXgoc3RhcnQpKS5oLCAoZW5kID0gY29sb3JDdWJlaGVsaXgoZW5kKSkuaCksXG4gICAgICAgICAgcyA9IGNvbG9yKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgICBsID0gY29sb3Ioc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICAgIHN0YXJ0LmwgPSBsKE1hdGgucG93KHQsIHkpKTtcbiAgICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGN1YmVoZWxpeC5nYW1tYSA9IGN1YmVoZWxpeEdhbW1hO1xuXG4gICAgcmV0dXJuIGN1YmVoZWxpeDtcbiAgfSkoMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1YmVoZWxpeChodWUpO1xuZXhwb3J0IHZhciBjdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4KGNvbG9yKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZTtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGQuc2V0VGltZShhICogKDEgLSB0KSArIGIgKiB0KSwgZDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICogbikpKV07XG4gIH07XG59XG4iLCJpbXBvcnQge2hjbCBhcyBjb2xvckhjbH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IsIHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGhjbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckhjbChzdGFydCkpLmgsIChlbmQgPSBjb2xvckhjbChlbmQpKS5oKSxcbiAgICAgICAgYyA9IGNvbG9yKHN0YXJ0LmMsIGVuZC5jKSxcbiAgICAgICAgbCA9IGNvbG9yKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5jID0gYyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaGNsKGh1ZSk7XG5leHBvcnQgdmFyIGhjbExvbmcgPSBoY2woY29sb3IpO1xuIiwiaW1wb3J0IHtoc2wgYXMgY29sb3JIc2x9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yLCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5mdW5jdGlvbiBoc2woaHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gY29sb3JIc2woc3RhcnQpKS5oLCAoZW5kID0gY29sb3JIc2woZW5kKSkuaCksXG4gICAgICAgIHMgPSBjb2xvcihzdGFydC5zLCBlbmQucyksXG4gICAgICAgIGwgPSBjb2xvcihzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhzbChodWUpO1xuZXhwb3J0IHZhciBoc2xMb25nID0gaHNsKGNvbG9yKTtcbiIsImltcG9ydCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBpID0gaHVlKCthLCArYik7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHggPSBpKHQpO1xuICAgIHJldHVybiB4IC0gMzYwICogTWF0aC5mbG9vcih4IC8gMzYwKTtcbiAgfTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUFycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZH0gZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZURhdGV9IGZyb20gXCIuL2RhdGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZURpc2NyZXRlfSBmcm9tIFwiLi9kaXNjcmV0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSHVlfSBmcm9tIFwiLi9odWUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU51bWJlcn0gZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU9iamVjdH0gZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcIi4vcm91bmQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVN0cmluZ30gZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5leHBvcnQge2ludGVycG9sYXRlVHJhbnNmb3JtQ3NzLCBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2Z30gZnJvbSBcIi4vdHJhbnNmb3JtL2luZGV4LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVab29tfSBmcm9tIFwiLi96b29tLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVSZ2IsIHJnYkJhc2lzIGFzIGludGVycG9sYXRlUmdiQmFzaXMsIHJnYkJhc2lzQ2xvc2VkIGFzIGludGVycG9sYXRlUmdiQmFzaXNDbG9zZWR9IGZyb20gXCIuL3JnYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSHNsLCBoc2xMb25nIGFzIGludGVycG9sYXRlSHNsTG9uZ30gZnJvbSBcIi4vaHNsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVMYWJ9IGZyb20gXCIuL2xhYi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlSGNsLCBoY2xMb25nIGFzIGludGVycG9sYXRlSGNsTG9uZ30gZnJvbSBcIi4vaGNsLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVDdWJlaGVsaXgsIGN1YmVoZWxpeExvbmcgYXMgaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nfSBmcm9tIFwiLi9jdWJlaGVsaXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwaWVjZXdpc2V9IGZyb20gXCIuL3BpZWNld2lzZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHF1YW50aXplfSBmcm9tIFwiLi9xdWFudGl6ZS5qc1wiO1xuIiwiaW1wb3J0IHtsYWIgYXMgY29sb3JMYWJ9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yIGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhYihzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gY29sb3IoKHN0YXJ0ID0gY29sb3JMYWIoc3RhcnQpKS5sLCAoZW5kID0gY29sb3JMYWIoZW5kKSkubCksXG4gICAgICBhID0gY29sb3Ioc3RhcnQuYSwgZW5kLmEpLFxuICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgIG9wYWNpdHkgPSBjb2xvcihzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgc3RhcnQubCA9IGwodCk7XG4gICAgc3RhcnQuYSA9IGEodCk7XG4gICAgc3RhcnQuYiA9IGIodCk7XG4gICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiA9ICtiLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIGlmICghYikgYiA9IFtdO1xuICB2YXIgbiA9IGEgPyBNYXRoLm1pbihiLmxlbmd0aCwgYS5sZW5ndGgpIDogMCxcbiAgICAgIGMgPSBiLnNsaWNlKCksXG4gICAgICBpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNbaV0gPSBhW2ldICogKDEgLSB0KSArIGJbaV0gKiB0O1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJBcnJheSh4KSB7XG4gIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoeCkgJiYgISh4IGluc3RhbmNlb2YgRGF0YVZpZXcpO1xufVxuIiwiaW1wb3J0IHZhbHVlIGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSB7fSxcbiAgICAgIGMgPSB7fSxcbiAgICAgIGs7XG5cbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09IFwib2JqZWN0XCIpIGEgPSB7fTtcbiAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpIGIgPSB7fTtcblxuICBmb3IgKGsgaW4gYikge1xuICAgIGlmIChrIGluIGEpIHtcbiAgICAgIGlba10gPSB2YWx1ZShhW2tdLCBiW2tdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1trXSA9IGJba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG4iLCJpbXBvcnQge2RlZmF1bHQgYXMgdmFsdWV9IGZyb20gXCIuL3ZhbHVlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBpZWNld2lzZShpbnRlcnBvbGF0ZSwgdmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkgdmFsdWVzID0gaW50ZXJwb2xhdGUsIGludGVycG9sYXRlID0gdmFsdWU7XG4gIHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGggLSAxLCB2ID0gdmFsdWVzWzBdLCBJID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICB3aGlsZSAoaSA8IG4pIElbaV0gPSBpbnRlcnBvbGF0ZSh2LCB2ID0gdmFsdWVzWysraV0pO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqPSBuKSkpO1xuICAgIHJldHVybiBJW2ldKHQgLSBpKTtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVycG9sYXRvciwgbikge1xuICB2YXIgc2FtcGxlcyA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHNhbXBsZXNbaV0gPSBpbnRlcnBvbGF0b3IoaSAvIChuIC0gMSkpO1xuICByZXR1cm4gc2FtcGxlcztcbn1cbiIsImltcG9ydCB7cmdiIGFzIGNvbG9yUmdifSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBiYXNpcyBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuaW1wb3J0IGJhc2lzQ2xvc2VkIGZyb20gXCIuL2Jhc2lzQ2xvc2VkLmpzXCI7XG5pbXBvcnQgbm9nYW1tYSwge2dhbW1hfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gcmdiR2FtbWEoeSkge1xuICB2YXIgY29sb3IgPSBnYW1tYSh5KTtcblxuICBmdW5jdGlvbiByZ2Ioc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gY29sb3IoKHN0YXJ0ID0gY29sb3JSZ2Ioc3RhcnQpKS5yLCAoZW5kID0gY29sb3JSZ2IoZW5kKSkuciksXG4gICAgICAgIGcgPSBjb2xvcihzdGFydC5nLCBlbmQuZyksXG4gICAgICAgIGIgPSBjb2xvcihzdGFydC5iLCBlbmQuYiksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuciA9IHIodCk7XG4gICAgICBzdGFydC5nID0gZyh0KTtcbiAgICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICByZ2IuZ2FtbWEgPSByZ2JHYW1tYTtcblxuICByZXR1cm4gcmdiO1xufSkoMSk7XG5cbmZ1bmN0aW9uIHJnYlNwbGluZShzcGxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9ycykge1xuICAgIHZhciBuID0gY29sb3JzLmxlbmd0aCxcbiAgICAgICAgciA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgZyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgaSwgY29sb3I7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29sb3IgPSBjb2xvclJnYihjb2xvcnNbaV0pO1xuICAgICAgcltpXSA9IGNvbG9yLnIgfHwgMDtcbiAgICAgIGdbaV0gPSBjb2xvci5nIHx8IDA7XG4gICAgICBiW2ldID0gY29sb3IuYiB8fCAwO1xuICAgIH1cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvci5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29sb3IuciA9IHIodCk7XG4gICAgICBjb2xvci5nID0gZyh0KTtcbiAgICAgIGNvbG9yLmIgPSBiKHQpO1xuICAgICAgcmV0dXJuIGNvbG9yICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIHJnYkJhc2lzID0gcmdiU3BsaW5lKGJhc2lzKTtcbmV4cG9ydCB2YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChhICogKDEgLSB0KSArIGIgKiB0KTtcbiAgfTtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbnZhciByZUEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csXG4gICAgcmVCID0gbmV3IFJlZ0V4cChyZUEuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIHplcm8oYikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uZShiKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGIodCkgKyBcIlwiO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBiaSA9IHJlQS5sYXN0SW5kZXggPSByZUIubGFzdEluZGV4ID0gMCwgLy8gc2NhbiBpbmRleCBmb3IgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYW0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYVxuICAgICAgYm0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYlxuICAgICAgYnMsIC8vIHN0cmluZyBwcmVjZWRpbmcgY3VycmVudCBudW1iZXIgaW4gYiwgaWYgYW55XG4gICAgICBpID0gLTEsIC8vIGluZGV4IGluIHNcbiAgICAgIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG5cbiAgLy8gQ29lcmNlIGlucHV0cyB0byBzdHJpbmdzLlxuICBhID0gYSArIFwiXCIsIGIgPSBiICsgXCJcIjtcblxuICAvLyBJbnRlcnBvbGF0ZSBwYWlycyBvZiBudW1iZXJzIGluIGEgJiBiLlxuICB3aGlsZSAoKGFtID0gcmVBLmV4ZWMoYSkpXG4gICAgICAmJiAoYm0gPSByZUIuZXhlYyhiKSkpIHtcbiAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHsgLy8gYSBzdHJpbmcgcHJlY2VkZXMgdGhlIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGJzID0gYi5zbGljZShiaSwgYnMpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJzO1xuICAgIH1cbiAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHsgLy8gbnVtYmVycyBpbiBhICYgYiBtYXRjaFxuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJtO1xuICAgIH0gZWxzZSB7IC8vIGludGVycG9sYXRlIG5vbi1tYXRjaGluZyBudW1iZXJzXG4gICAgICBzWysraV0gPSBudWxsO1xuICAgICAgcS5wdXNoKHtpOiBpLCB4OiBudW1iZXIoYW0sIGJtKX0pO1xuICAgIH1cbiAgICBiaSA9IHJlQi5sYXN0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgcmVtYWlucyBvZiBiLlxuICBpZiAoYmkgPCBiLmxlbmd0aCkge1xuICAgIGJzID0gYi5zbGljZShiaSk7XG4gICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgZWxzZSBzWysraV0gPSBicztcbiAgfVxuXG4gIC8vIFNwZWNpYWwgb3B0aW1pemF0aW9uIGZvciBvbmx5IGEgc2luZ2xlIG1hdGNoLlxuICAvLyBPdGhlcndpc2UsIGludGVycG9sYXRlIGVhY2ggb2YgdGhlIG51bWJlcnMgYW5kIHJlam9pbiB0aGUgc3RyaW5nLlxuICByZXR1cm4gcy5sZW5ndGggPCAyID8gKHFbMF1cbiAgICAgID8gb25lKHFbMF0ueClcbiAgICAgIDogemVybyhiKSlcbiAgICAgIDogKGIgPSBxLmxlbmd0aCwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICAgICAgfSk7XG59XG4iLCJ2YXIgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG5cbmV4cG9ydCB2YXIgaWRlbnRpdHkgPSB7XG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIHJvdGF0ZTogMCxcbiAgc2tld1g6IDAsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBzY2FsZVgsIHNjYWxlWSwgc2tld1g7XG4gIGlmIChzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYikpIGEgLz0gc2NhbGVYLCBiIC89IHNjYWxlWDtcbiAgaWYgKHNrZXdYID0gYSAqIGMgKyBiICogZCkgYyAtPSBhICogc2tld1gsIGQgLT0gYiAqIHNrZXdYO1xuICBpZiAoc2NhbGVZID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpKSBjIC89IHNjYWxlWSwgZCAvPSBzY2FsZVksIHNrZXdYIC89IHNjYWxlWTtcbiAgaWYgKGEgKiBkIDwgYiAqIGMpIGEgPSAtYSwgYiA9IC1iLCBza2V3WCA9IC1za2V3WCwgc2NhbGVYID0gLXNjYWxlWDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBlLFxuICAgIHRyYW5zbGF0ZVk6IGYsXG4gICAgcm90YXRlOiBNYXRoLmF0YW4yKGIsIGEpICogZGVncmVlcyxcbiAgICBza2V3WDogTWF0aC5hdGFuKHNrZXdYKSAqIGRlZ3JlZXMsXG4gICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgc2NhbGVZOiBzY2FsZVlcbiAgfTtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4uL251bWJlci5qc1wiO1xuaW1wb3J0IHtwYXJzZUNzcywgcGFyc2VTdmd9IGZyb20gXCIuL3BhcnNlLmpzXCI7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlLCBweENvbW1hLCBweFBhcmVuLCBkZWdQYXJlbikge1xuXG4gIGZ1bmN0aW9uIHBvcChzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID8gcy5wb3AoKSArIFwiIFwiIDogXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgcHhDb21tYSwgbnVsbCwgcHhQYXJlbik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiIHx8IHliKSB7XG4gICAgICBzLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyB4YiArIHB4Q29tbWEgKyB5YiArIHB4UGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJvdGF0ZShhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIGlmIChhIC0gYiA+IDE4MCkgYiArPSAzNjA7IGVsc2UgaWYgKGIgLSBhID4gMTgwKSBhICs9IDM2MDsgLy8gc2hvcnRlc3QgcGF0aFxuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2V3WChhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiICE9PSAxIHx8IHliICE9PSAxKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiArIHhiICsgXCIsXCIgKyB5YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG4gICAgYSA9IHBhcnNlKGEpLCBiID0gcGFyc2UoYik7XG4gICAgdHJhbnNsYXRlKGEudHJhbnNsYXRlWCwgYS50cmFuc2xhdGVZLCBiLnRyYW5zbGF0ZVgsIGIudHJhbnNsYXRlWSwgcywgcSk7XG4gICAgcm90YXRlKGEucm90YXRlLCBiLnJvdGF0ZSwgcywgcSk7XG4gICAgc2tld1goYS5za2V3WCwgYi5za2V3WCwgcywgcSk7XG4gICAgc2NhbGUoYS5zY2FsZVgsIGEuc2NhbGVZLCBiLnNjYWxlWCwgYi5zY2FsZVksIHMsIHEpO1xuICAgIGEgPSBiID0gbnVsbDsgLy8gZ2NcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHEubGVuZ3RoLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlQ3NzLCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpO1xuZXhwb3J0IHZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlU3ZnLCBcIiwgXCIsIFwiKVwiLCBcIilcIik7XG4iLCJpbXBvcnQgZGVjb21wb3NlLCB7aWRlbnRpdHl9IGZyb20gXCIuL2RlY29tcG9zZS5qc1wiO1xuXG52YXIgc3ZnTm9kZTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNzcyh2YWx1ZSkge1xuICBjb25zdCBtID0gbmV3ICh0eXBlb2YgRE9NTWF0cml4ID09PSBcImZ1bmN0aW9uXCIgPyBET01NYXRyaXggOiBXZWJLaXRDU1NNYXRyaXgpKHZhbHVlICsgXCJcIik7XG4gIHJldHVybiBtLmlzSWRlbnRpdHkgPyBpZGVudGl0eSA6IGRlY29tcG9zZShtLmEsIG0uYiwgbS5jLCBtLmQsIG0uZSwgbS5mKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3ZnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghc3ZnTm9kZSkgc3ZnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdmFsdWUpO1xuICBpZiAoISh2YWx1ZSA9IHN2Z05vZGUudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKSkpIHJldHVybiBpZGVudGl0eTtcbiAgdmFsdWUgPSB2YWx1ZS5tYXRyaXg7XG4gIHJldHVybiBkZWNvbXBvc2UodmFsdWUuYSwgdmFsdWUuYiwgdmFsdWUuYywgdmFsdWUuZCwgdmFsdWUuZSwgdmFsdWUuZik7XG59XG4iLCJpbXBvcnQge2NvbG9yfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCByZ2IgZnJvbSBcIi4vcmdiLmpzXCI7XG5pbXBvcnQge2dlbmVyaWNBcnJheX0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBkYXRlIGZyb20gXCIuL2RhdGUuanNcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQgb2JqZWN0IGZyb20gXCIuL29iamVjdC5qc1wiO1xuaW1wb3J0IHN0cmluZyBmcm9tIFwiLi9zdHJpbmcuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IG51bWJlckFycmF5LCB7aXNOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgdCA9IHR5cGVvZiBiLCBjO1xuICByZXR1cm4gYiA9PSBudWxsIHx8IHQgPT09IFwiYm9vbGVhblwiID8gY29uc3RhbnQoYilcbiAgICAgIDogKHQgPT09IFwibnVtYmVyXCIgPyBudW1iZXJcbiAgICAgIDogdCA9PT0gXCJzdHJpbmdcIiA/ICgoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgcmdiKSA6IHN0cmluZylcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gcmdiXG4gICAgICA6IGIgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZVxuICAgICAgOiBpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXlcbiAgICAgIDogQXJyYXkuaXNBcnJheShiKSA/IGdlbmVyaWNBcnJheVxuICAgICAgOiB0eXBlb2YgYi52YWx1ZU9mICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIudG9TdHJpbmcgIT09IFwiZnVuY3Rpb25cIiB8fCBpc05hTihiKSA/IG9iamVjdFxuICAgICAgOiBudW1iZXIpKGEsIGIpO1xufVxuIiwidmFyIGVwc2lsb24yID0gMWUtMTI7XG5cbmZ1bmN0aW9uIGNvc2goeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpICsgMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgLSAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiB0YW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiB6b29tUmhvKHJobywgcmhvMiwgcmhvNCkge1xuXG4gIC8vIHAwID0gW3V4MCwgdXkwLCB3MF1cbiAgLy8gcDEgPSBbdXgxLCB1eTEsIHcxXVxuICBmdW5jdGlvbiB6b29tKHAwLCBwMSkge1xuICAgIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sXG4gICAgICAgIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSxcbiAgICAgICAgZHggPSB1eDEgLSB1eDAsXG4gICAgICAgIGR5ID0gdXkxIC0gdXkwLFxuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgICBpLFxuICAgICAgICBTO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciB1MCDiiYUgdTEuXG4gICAgaWYgKGQyIDwgZXBzaWxvbjIpIHtcbiAgICAgIFMgPSBNYXRoLmxvZyh3MSAvIHcwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdXgwICsgdCAqIGR4LFxuICAgICAgICAgIHV5MCArIHQgKiBkeSxcbiAgICAgICAgICB3MCAqIE1hdGguZXhwKHJobyAqIHQgKiBTKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdlbmVyYWwgY2FzZS5cbiAgICBlbHNlIHtcbiAgICAgIHZhciBkMSA9IE1hdGguc3FydChkMiksXG4gICAgICAgICAgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG80ICogZDIpIC8gKDIgKiB3MCAqIHJobzIgKiBkMSksXG4gICAgICAgICAgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSByaG80ICogZDIpIC8gKDIgKiB3MSAqIHJobzIgKiBkMSksXG4gICAgICAgICAgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLFxuICAgICAgICAgIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgICAgIFMgPSAocjEgLSByMCkgLyByaG87XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcyA9IHQgKiBTLFxuICAgICAgICAgICAgY29zaHIwID0gY29zaChyMCksXG4gICAgICAgICAgICB1ID0gdzAgLyAocmhvMiAqIGQxKSAqIChjb3NocjAgKiB0YW5oKHJobyAqIHMgKyByMCkgLSBzaW5oKHIwKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdXgwICsgdSAqIGR4LFxuICAgICAgICAgIHV5MCArIHUgKiBkeSxcbiAgICAgICAgICB3MCAqIGNvc2hyMCAvIGNvc2gocmhvICogcyArIHIwKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGkuZHVyYXRpb24gPSBTICogMTAwMCAqIHJobyAvIE1hdGguU1FSVDI7XG5cbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIHpvb20ucmhvID0gZnVuY3Rpb24oXykge1xuICAgIHZhciBfMSA9IE1hdGgubWF4KDFlLTMsICtfKSwgXzIgPSBfMSAqIF8xLCBfNCA9IF8yICogXzI7XG4gICAgcmV0dXJuIHpvb21SaG8oXzEsIF8yLCBfNCk7XG4gIH07XG5cbiAgcmV0dXJuIHpvb207XG59KShNYXRoLlNRUlQyLCAyLCA0KTtcbiIsImNvbnN0IHBpID0gTWF0aC5QSSxcbiAgICB0YXUgPSAyICogcGksXG4gICAgZXBzaWxvbiA9IDFlLTYsXG4gICAgdGF1RXBzaWxvbiA9IHRhdSAtIGVwc2lsb247XG5cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5fID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIG5ldyBQYXRoO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHBhdGgucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGF0aCxcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuXyArPSBcIlpcIjtcbiAgICB9XG4gIH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJRXCIgKyAoK3gxKSArIFwiLFwiICsgKCt5MSkgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkNcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKCt4MikgKyBcIixcIiArICgreTIpICsgXCIsXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgfSxcbiAgYXJjVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByKSB7XG4gICAgeDEgPSAreDEsIHkxID0gK3kxLCB4MiA9ICt4MiwgeTIgPSAreTIsIHIgPSArcjtcbiAgICB2YXIgeDAgPSB0aGlzLl94MSxcbiAgICAgICAgeTAgPSB0aGlzLl95MSxcbiAgICAgICAgeDIxID0geDIgLSB4MSxcbiAgICAgICAgeTIxID0geTIgLSB5MSxcbiAgICAgICAgeDAxID0geDAgLSB4MSxcbiAgICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDEseTEpLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3IsIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4MCx5MCk/IERvIG5vdGhpbmcuXG4gICAgZWxzZSBpZiAoIShsMDFfMiA+IGVwc2lsb24pKTtcblxuICAgIC8vIE9yLCBhcmUgKHgwLHkwKSwgKHgxLHkxKSBhbmQgKHgyLHkyKSBjb2xsaW5lYXI/XG4gICAgLy8gRXF1aXZhbGVudGx5LCBpcyAoeDEseTEpIGNvaW5jaWRlbnQgd2l0aCAoeDIseTIpP1xuICAgIC8vIE9yLCBpcyB0aGUgcmFkaXVzIHplcm8/IExpbmUgdG8gKHgxLHkxKS5cbiAgICBlbHNlIGlmICghKE1hdGguYWJzKHkwMSAqIHgyMSAtIHkyMSAqIHgwMSkgPiBlcHNpbG9uKSB8fCAhcikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBkcmF3IGFuIGFyYyFcbiAgICBlbHNlIHtcbiAgICAgIHZhciB4MjAgPSB4MiAtIHgwLFxuICAgICAgICAgIHkyMCA9IHkyIC0geTAsXG4gICAgICAgICAgbDIxXzIgPSB4MjEgKiB4MjEgKyB5MjEgKiB5MjEsXG4gICAgICAgICAgbDIwXzIgPSB4MjAgKiB4MjAgKyB5MjAgKiB5MjAsXG4gICAgICAgICAgbDIxID0gTWF0aC5zcXJ0KGwyMV8yKSxcbiAgICAgICAgICBsMDEgPSBNYXRoLnNxcnQobDAxXzIpLFxuICAgICAgICAgIGwgPSByICogTWF0aC50YW4oKHBpIC0gTWF0aC5hY29zKChsMjFfMiArIGwwMV8yIC0gbDIwXzIpIC8gKDIgKiBsMjEgKiBsMDEpKSkgLyAyKSxcbiAgICAgICAgICB0MDEgPSBsIC8gbDAxLFxuICAgICAgICAgIHQyMSA9IGwgLyBsMjE7XG5cbiAgICAgIC8vIElmIHRoZSBzdGFydCB0YW5nZW50IGlzIG5vdCBjb2luY2lkZW50IHdpdGggKHgwLHkwKSwgbGluZSB0by5cbiAgICAgIGlmIChNYXRoLmFicyh0MDEgLSAxKSA+IGVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHgxICsgdDAxICogeDAxKSArIFwiLFwiICsgKHkxICsgdDAxICogeTAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMCxcIiArICgrKHkwMSAqIHgyMCA+IHgwMSAqIHkyMCkpICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MSArIHQyMSAqIHgyMSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxICsgdDIxICogeTIxKTtcbiAgICB9XG4gIH0sXG4gIGFyYzogZnVuY3Rpb24oeCwgeSwgciwgYTAsIGExLCBjY3cpIHtcbiAgICB4ID0gK3gsIHkgPSAreSwgciA9ICtyLCBjY3cgPSAhIWNjdztcbiAgICB2YXIgZHggPSByICogTWF0aC5jb3MoYTApLFxuICAgICAgICBkeSA9IHIgKiBNYXRoLnNpbihhMCksXG4gICAgICAgIHgwID0geCArIGR4LFxuICAgICAgICB5MCA9IHkgKyBkeSxcbiAgICAgICAgY3cgPSAxIF4gY2N3LFxuICAgICAgICBkYSA9IGNjdyA/IGEwIC0gYTEgOiBhMSAtIGEwO1xuXG4gICAgLy8gSXMgdGhlIHJhZGl1cyBuZWdhdGl2ZT8gRXJyb3IuXG4gICAgaWYgKHIgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgcik7XG5cbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgwLHkwKS5cbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuXyArPSBcIk1cIiArIHgwICsgXCIsXCIgKyB5MDtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgwLHkwKSBub3QgY29pbmNpZGVudCB3aXRoIHRoZSBwcmV2aW91cyBwb2ludD8gTGluZSB0byAoeDAseTApLlxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0geDApID4gZXBzaWxvbiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHkwKSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuXyArPSBcIkxcIiArIHgwICsgXCIsXCIgKyB5MDtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBlbXB0eT8gV2XigJlyZSBkb25lLlxuICAgIGlmICghcikgcmV0dXJuO1xuXG4gICAgLy8gRG9lcyB0aGUgYW5nbGUgZ28gdGhlIHdyb25nIHdheT8gRmxpcCB0aGUgZGlyZWN0aW9uLlxuICAgIGlmIChkYSA8IDApIGRhID0gZGEgJSB0YXUgKyB0YXU7XG5cbiAgICAvLyBJcyB0aGlzIGEgY29tcGxldGUgY2lyY2xlPyBEcmF3IHR3byBhcmNzIHRvIGNvbXBsZXRlIHRoZSBjaXJjbGUuXG4gICAgaWYgKGRhID4gdGF1RXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAoeCAtIGR4KSArIFwiLFwiICsgKHkgLSBkeSkgKyBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDEsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geDApICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MCk7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgbm9uLWVtcHR5PyBEcmF3IGFuIGFyYyFcbiAgICBlbHNlIGlmIChkYSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLFwiICsgKCsoZGEgPj0gcGkpKSArIFwiLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHggKyByICogTWF0aC5jb3MoYTEpKSArIFwiLFwiICsgKHRoaXMuX3kxID0geSArIHIgKiBNYXRoLnNpbihhMSkpO1xuICAgIH1cbiAgfSxcbiAgcmVjdDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuICAgIHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MCA9IHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTAgPSB0aGlzLl95MSA9ICt5KSArIFwiaFwiICsgKCt3KSArIFwidlwiICsgKCtoKSArIFwiaFwiICsgKC13KSArIFwiWlwiO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcGF0aDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGQpIHtcbiAgY29uc3QgeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCksXG4gICAgICB5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKTtcbiAgcmV0dXJuIGFkZCh0aGlzLmNvdmVyKHgsIHkpLCB4LCB5LCBkKTtcbn1cblxuZnVuY3Rpb24gYWRkKHRyZWUsIHgsIHksIGQpIHtcbiAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gdHJlZTsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0cmVlLl9yb290LFxuICAgICAgbGVhZiA9IHtkYXRhOiBkfSxcbiAgICAgIHgwID0gdHJlZS5feDAsXG4gICAgICB5MCA9IHRyZWUuX3kwLFxuICAgICAgeDEgPSB0cmVlLl94MSxcbiAgICAgIHkxID0gdHJlZS5feTEsXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgeHAsXG4gICAgICB5cCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBGaW5kIHRoZSBleGlzdGluZyBsZWFmIGZvciB0aGUgbmV3IHBvaW50LCBvciBhZGQgaXQuXG4gIHdoaWxlIChub2RlLmxlbmd0aCkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmIChwYXJlbnQgPSBub2RlLCAhKG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xuICB9XG5cbiAgLy8gSXMgdGhlIG5ldyBwb2ludCBpcyBleGFjdGx5IGNvaW5jaWRlbnQgd2l0aCB0aGUgZXhpc3RpbmcgcG9pbnQ/XG4gIHhwID0gK3RyZWUuX3guY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICB5cCA9ICt0cmVlLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgaWYgKHggPT09IHhwICYmIHkgPT09IHlwKSByZXR1cm4gbGVhZi5uZXh0ID0gbm9kZSwgcGFyZW50ID8gcGFyZW50W2ldID0gbGVhZiA6IHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIE90aGVyd2lzZSwgc3BsaXQgdGhlIGxlYWYgbm9kZSB1bnRpbCB0aGUgb2xkIGFuZCBuZXcgcG9pbnQgYXJlIHNlcGFyYXRlZC5cbiAgZG8ge1xuICAgIHBhcmVudCA9IHBhcmVudCA/IHBhcmVudFtpXSA9IG5ldyBBcnJheSg0KSA6IHRyZWUuX3Jvb3QgPSBuZXcgQXJyYXkoNCk7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gIH0gd2hpbGUgKChpID0gYm90dG9tIDw8IDEgfCByaWdodCkgPT09IChqID0gKHlwID49IHltKSA8PCAxIHwgKHhwID49IHhtKSkpO1xuICByZXR1cm4gcGFyZW50W2pdID0gbm9kZSwgcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEFsbChkYXRhKSB7XG4gIHZhciBkLCBpLCBuID0gZGF0YS5sZW5ndGgsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHh6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeXogPSBuZXcgQXJyYXkobiksXG4gICAgICB4MCA9IEluZmluaXR5LFxuICAgICAgeTAgPSBJbmZpbml0eSxcbiAgICAgIHgxID0gLUluZmluaXR5LFxuICAgICAgeTEgPSAtSW5maW5pdHk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgcG9pbnRzIGFuZCB0aGVpciBleHRlbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCA9IGRhdGFbaV0pKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIGNvbnRpbnVlO1xuICAgIHh6W2ldID0geDtcbiAgICB5eltpXSA9IHk7XG4gICAgaWYgKHggPCB4MCkgeDAgPSB4O1xuICAgIGlmICh4ID4geDEpIHgxID0geDtcbiAgICBpZiAoeSA8IHkwKSB5MCA9IHk7XG4gICAgaWYgKHkgPiB5MSkgeTEgPSB5O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgd2VyZSBubyAodmFsaWQpIHBvaW50cywgYWJvcnQuXG4gIGlmICh4MCA+IHgxIHx8IHkwID4geTEpIHJldHVybiB0aGlzO1xuXG4gIC8vIEV4cGFuZCB0aGUgdHJlZSB0byBjb3ZlciB0aGUgbmV3IHBvaW50cy5cbiAgdGhpcy5jb3Zlcih4MCwgeTApLmNvdmVyKHgxLCB5MSk7XG5cbiAgLy8gQWRkIHRoZSBuZXcgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgYWRkKHRoaXMsIHh6W2ldLCB5eltpXSwgZGF0YVtpXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgaWYgKGlzTmFOKHggPSAreCkgfHwgaXNOYU4oeSA9ICt5KSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxO1xuXG4gIC8vIElmIHRoZSBxdWFkdHJlZSBoYXMgbm8gZXh0ZW50LCBpbml0aWFsaXplIHRoZW0uXG4gIC8vIEludGVnZXIgZXh0ZW50IGFyZSBuZWNlc3Nhcnkgc28gdGhhdCBpZiB3ZSBsYXRlciBkb3VibGUgdGhlIGV4dGVudCxcbiAgLy8gdGhlIGV4aXN0aW5nIHF1YWRyYW50IGJvdW5kYXJpZXMgZG9u4oCZdCBjaGFuZ2UgZHVlIHRvIGZsb2F0aW5nIHBvaW50IGVycm9yIVxuICBpZiAoaXNOYU4oeDApKSB7XG4gICAgeDEgPSAoeDAgPSBNYXRoLmZsb29yKHgpKSArIDE7XG4gICAgeTEgPSAoeTAgPSBNYXRoLmZsb29yKHkpKSArIDE7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGRvdWJsZSByZXBlYXRlZGx5IHRvIGNvdmVyLlxuICBlbHNlIHtcbiAgICB2YXIgeiA9IHgxIC0geDAgfHwgMSxcbiAgICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgaTtcblxuICAgIHdoaWxlICh4MCA+IHggfHwgeCA+PSB4MSB8fCB5MCA+IHkgfHwgeSA+PSB5MSkge1xuICAgICAgaSA9ICh5IDwgeTApIDw8IDEgfCAoeCA8IHgwKTtcbiAgICAgIHBhcmVudCA9IG5ldyBBcnJheSg0KSwgcGFyZW50W2ldID0gbm9kZSwgbm9kZSA9IHBhcmVudCwgeiAqPSAyO1xuICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGNhc2UgMDogeDEgPSB4MCArIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAxOiB4MCA9IHgxIC0geiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHgxID0geDAgKyB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogeDAgPSB4MSAtIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcm9vdCAmJiB0aGlzLl9yb290Lmxlbmd0aCkgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IFtdO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyBkYXRhLnB1c2gobm9kZS5kYXRhKTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5jb3ZlcigrX1swXVswXSwgK19bMF1bMV0pLmNvdmVyKCtfWzFdWzBdLCArX1sxXVsxXSlcbiAgICAgIDogaXNOYU4odGhpcy5feDApID8gdW5kZWZpbmVkIDogW1t0aGlzLl94MCwgdGhpcy5feTBdLCBbdGhpcy5feDEsIHRoaXMuX3kxXV07XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICB2YXIgZGF0YSxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTIsXG4gICAgICB4MyA9IHRoaXMuX3gxLFxuICAgICAgeTMgPSB0aGlzLl95MSxcbiAgICAgIHF1YWRzID0gW10sXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHEsXG4gICAgICBpO1xuXG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHgwLCB5MCwgeDMsIHkzKSk7XG4gIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gIGVsc2Uge1xuICAgIHgwID0geCAtIHJhZGl1cywgeTAgPSB5IC0gcmFkaXVzO1xuICAgIHgzID0geCArIHJhZGl1cywgeTMgPSB5ICsgcmFkaXVzO1xuICAgIHJhZGl1cyAqPSByYWRpdXM7XG4gIH1cblxuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG5cbiAgICAvLyBTdG9wIHNlYXJjaGluZyBpZiB0aGlzIHF1YWRyYW50IGNhbuKAmXQgY29udGFpbiBhIGNsb3NlciBub2RlLlxuICAgIGlmICghKG5vZGUgPSBxLm5vZGUpXG4gICAgICAgIHx8ICh4MSA9IHEueDApID4geDNcbiAgICAgICAgfHwgKHkxID0gcS55MCkgPiB5M1xuICAgICAgICB8fCAoeDIgPSBxLngxKSA8IHgwXG4gICAgICAgIHx8ICh5MiA9IHEueTEpIDwgeTApIGNvbnRpbnVlO1xuXG4gICAgLy8gQmlzZWN0IHRoZSBjdXJyZW50IHF1YWRyYW50LlxuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgxICsgeDIpIC8gMixcbiAgICAgICAgICB5bSA9ICh5MSArIHkyKSAvIDI7XG5cbiAgICAgIHF1YWRzLnB1c2goXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbM10sIHhtLCB5bSwgeDIsIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsyXSwgeDEsIHltLCB4bSwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzFdLCB4bSwgeTEsIHgyLCB5bSksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMF0sIHgxLCB5MSwgeG0sIHltKVxuICAgICAgKTtcblxuICAgICAgLy8gVmlzaXQgdGhlIGNsb3Nlc3QgcXVhZHJhbnQgZmlyc3QuXG4gICAgICBpZiAoaSA9ICh5ID49IHltKSA8PCAxIHwgKHggPj0geG0pKSB7XG4gICAgICAgIHEgPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV0gPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXSA9IHE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmlzaXQgdGhpcyBwb2ludC4gKFZpc2l0aW5nIGNvaW5jaWRlbnQgcG9pbnRzIGlzbuKAmXQgbmVjZXNzYXJ5ISlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBkeCA9IHggLSArdGhpcy5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZHkgPSB5IC0gK3RoaXMuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZDIgPCByYWRpdXMpIHtcbiAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQocmFkaXVzID0gZDIpO1xuICAgICAgICB4MCA9IHggLSBkLCB5MCA9IHkgLSBkO1xuICAgICAgICB4MyA9IHggKyBkLCB5MyA9IHkgKyBkO1xuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy54MCA9IHgwO1xuICB0aGlzLnkwID0geTA7XG4gIHRoaXMueDEgPSB4MTtcbiAgdGhpcy55MSA9IHkxO1xufVxuIiwiaW1wb3J0IHRyZWVfYWRkLCB7YWRkQWxsIGFzIHRyZWVfYWRkQWxsfSBmcm9tIFwiLi9hZGQuanNcIjtcbmltcG9ydCB0cmVlX2NvdmVyIGZyb20gXCIuL2NvdmVyLmpzXCI7XG5pbXBvcnQgdHJlZV9kYXRhIGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB0cmVlX2V4dGVudCBmcm9tIFwiLi9leHRlbnQuanNcIjtcbmltcG9ydCB0cmVlX2ZpbmQgZnJvbSBcIi4vZmluZC5qc1wiO1xuaW1wb3J0IHRyZWVfcmVtb3ZlLCB7cmVtb3ZlQWxsIGFzIHRyZWVfcmVtb3ZlQWxsfSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCB0cmVlX3Jvb3QgZnJvbSBcIi4vcm9vdC5qc1wiO1xuaW1wb3J0IHRyZWVfc2l6ZSBmcm9tIFwiLi9zaXplLmpzXCI7XG5pbXBvcnQgdHJlZV92aXNpdCBmcm9tIFwiLi92aXNpdC5qc1wiO1xuaW1wb3J0IHRyZWVfdmlzaXRBZnRlciBmcm9tIFwiLi92aXNpdEFmdGVyLmpzXCI7XG5pbXBvcnQgdHJlZV94LCB7ZGVmYXVsdFh9IGZyb20gXCIuL3guanNcIjtcbmltcG9ydCB0cmVlX3ksIHtkZWZhdWx0WX0gZnJvbSBcIi4veS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFkdHJlZShub2RlcywgeCwgeSkge1xuICB2YXIgdHJlZSA9IG5ldyBRdWFkdHJlZSh4ID09IG51bGwgPyBkZWZhdWx0WCA6IHgsIHkgPT0gbnVsbCA/IGRlZmF1bHRZIDogeSwgTmFOLCBOYU4sIE5hTiwgTmFOKTtcbiAgcmV0dXJuIG5vZGVzID09IG51bGwgPyB0cmVlIDogdHJlZS5hZGRBbGwobm9kZXMpO1xufVxuXG5mdW5jdGlvbiBRdWFkdHJlZSh4LCB5LCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLl94ID0geDtcbiAgdGhpcy5feSA9IHk7XG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHRoaXMuX3Jvb3QgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGxlYWZfY29weShsZWFmKSB7XG4gIHZhciBjb3B5ID0ge2RhdGE6IGxlYWYuZGF0YX0sIG5leHQgPSBjb3B5O1xuICB3aGlsZSAobGVhZiA9IGxlYWYubmV4dCkgbmV4dCA9IG5leHQubmV4dCA9IHtkYXRhOiBsZWFmLmRhdGF9O1xuICByZXR1cm4gY29weTtcbn1cblxudmFyIHRyZWVQcm90byA9IHF1YWR0cmVlLnByb3RvdHlwZSA9IFF1YWR0cmVlLnByb3RvdHlwZTtcblxudHJlZVByb3RvLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvcHkgPSBuZXcgUXVhZHRyZWUodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBub2RlcyxcbiAgICAgIGNoaWxkO1xuXG4gIGlmICghbm9kZSkgcmV0dXJuIGNvcHk7XG5cbiAgaWYgKCFub2RlLmxlbmd0aCkgcmV0dXJuIGNvcHkuX3Jvb3QgPSBsZWFmX2NvcHkobm9kZSksIGNvcHk7XG5cbiAgbm9kZXMgPSBbe3NvdXJjZTogbm9kZSwgdGFyZ2V0OiBjb3B5Ll9yb290ID0gbmV3IEFycmF5KDQpfV07XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKGNoaWxkID0gbm9kZS5zb3VyY2VbaV0pIHtcbiAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCkgbm9kZXMucHVzaCh7c291cmNlOiBjaGlsZCwgdGFyZ2V0OiBub2RlLnRhcmdldFtpXSA9IG5ldyBBcnJheSg0KX0pO1xuICAgICAgICBlbHNlIG5vZGUudGFyZ2V0W2ldID0gbGVhZl9jb3B5KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn07XG5cbnRyZWVQcm90by5hZGQgPSB0cmVlX2FkZDtcbnRyZWVQcm90by5hZGRBbGwgPSB0cmVlX2FkZEFsbDtcbnRyZWVQcm90by5jb3ZlciA9IHRyZWVfY292ZXI7XG50cmVlUHJvdG8uZGF0YSA9IHRyZWVfZGF0YTtcbnRyZWVQcm90by5leHRlbnQgPSB0cmVlX2V4dGVudDtcbnRyZWVQcm90by5maW5kID0gdHJlZV9maW5kO1xudHJlZVByb3RvLnJlbW92ZSA9IHRyZWVfcmVtb3ZlO1xudHJlZVByb3RvLnJlbW92ZUFsbCA9IHRyZWVfcmVtb3ZlQWxsO1xudHJlZVByb3RvLnJvb3QgPSB0cmVlX3Jvb3Q7XG50cmVlUHJvdG8uc2l6ZSA9IHRyZWVfc2l6ZTtcbnRyZWVQcm90by52aXNpdCA9IHRyZWVfdmlzaXQ7XG50cmVlUHJvdG8udmlzaXRBZnRlciA9IHRyZWVfdmlzaXRBZnRlcjtcbnRyZWVQcm90by54ID0gdHJlZV94O1xudHJlZVByb3RvLnkgPSB0cmVlX3k7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcmV0YWluZXIsXG4gICAgICBwcmV2aW91cyxcbiAgICAgIG5leHQsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRmluZCB0aGUgbGVhZiBub2RlIGZvciB0aGUgcG9pbnQuXG4gIC8vIFdoaWxlIGRlc2NlbmRpbmcsIGFsc28gcmV0YWluIHRoZSBkZWVwZXN0IHBhcmVudCB3aXRoIGEgbm9uLXJlbW92ZWQgc2libGluZy5cbiAgaWYgKG5vZGUubGVuZ3RoKSB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmICghKHBhcmVudCA9IG5vZGUsIG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiB0aGlzO1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGJyZWFrO1xuICAgIGlmIChwYXJlbnRbKGkgKyAxKSAmIDNdIHx8IHBhcmVudFsoaSArIDIpICYgM10gfHwgcGFyZW50WyhpICsgMykgJiAzXSkgcmV0YWluZXIgPSBwYXJlbnQsIGogPSBpO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgcG9pbnQgdG8gcmVtb3ZlLlxuICB3aGlsZSAobm9kZS5kYXRhICE9PSBkKSBpZiAoIShwcmV2aW91cyA9IG5vZGUsIG5vZGUgPSBub2RlLm5leHQpKSByZXR1cm4gdGhpcztcbiAgaWYgKG5leHQgPSBub2RlLm5leHQpIGRlbGV0ZSBub2RlLm5leHQ7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvaW5jaWRlbnQgcG9pbnRzLCByZW1vdmUganVzdCB0aGUgcG9pbnQuXG4gIGlmIChwcmV2aW91cykgcmV0dXJuIChuZXh0ID8gcHJldmlvdXMubmV4dCA9IG5leHQgOiBkZWxldGUgcHJldmlvdXMubmV4dCksIHRoaXM7XG5cbiAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBwb2ludCwgcmVtb3ZlIGl0LlxuICBpZiAoIXBhcmVudCkgcmV0dXJuIHRoaXMuX3Jvb3QgPSBuZXh0LCB0aGlzO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlYWYuXG4gIG5leHQgPyBwYXJlbnRbaV0gPSBuZXh0IDogZGVsZXRlIHBhcmVudFtpXTtcblxuICAvLyBJZiB0aGUgcGFyZW50IG5vdyBjb250YWlucyBleGFjdGx5IG9uZSBsZWFmLCBjb2xsYXBzZSBzdXBlcmZsdW91cyBwYXJlbnRzLlxuICBpZiAoKG5vZGUgPSBwYXJlbnRbMF0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbM10pXG4gICAgICAmJiBub2RlID09PSAocGFyZW50WzNdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzBdKVxuICAgICAgJiYgIW5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJldGFpbmVyKSByZXRhaW5lcltqXSA9IG5vZGU7XG4gICAgZWxzZSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsKGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkgdGhpcy5yZW1vdmUoZGF0YVtpXSk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yb290O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gKytzaXplOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBzaXplO1xufVxuIiwiaW1wb3J0IFF1YWQgZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgcSwgbm9kZSA9IHRoaXMuX3Jvb3QsIGNoaWxkLCB4MCwgeTAsIHgxLCB5MTtcbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIGlmICghY2FsbGJhY2sobm9kZSA9IHEubm9kZSwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxKSAmJiBub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBuZXh0ID0gW10sIHE7XG4gIGlmICh0aGlzLl9yb290KSBxdWFkcy5wdXNoKG5ldyBRdWFkKHRoaXMuX3Jvb3QsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICB2YXIgbm9kZSA9IHEubm9kZTtcbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxLCB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgfVxuICAgIG5leHQucHVzaChxKTtcbiAgfVxuICB3aGlsZSAocSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjayhxLm5vZGUsIHEueDAsIHEueTAsIHEueDEsIHEueTEpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feCA9IF8sIHRoaXMpIDogdGhpcy5feDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0WShkKSB7XG4gIHJldHVybiBkWzFdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3kgPSBfLCB0aGlzKSA6IHRoaXMuX3k7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25zdGFudHMoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2ludGVycG9sYXRlIGFzIGludGVycG9sYXRlVmFsdWUsIGludGVycG9sYXRlTnVtYmVyLCBpbnRlcnBvbGF0ZVJvdW5kfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHVuaXQgPSBbMCwgMV07XG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUoYSwgYikge1xuICByZXR1cm4gKGIgLT0gKGEgPSArYSkpXG4gICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICh4IC0gYSkgLyBiOyB9XG4gICAgICA6IGNvbnN0YW50KGlzTmFOKGIpID8gTmFOIDogMC41KTtcbn1cblxuZnVuY3Rpb24gY2xhbXBlcihhLCBiKSB7XG4gIHZhciB0O1xuICBpZiAoYSA+IGIpIHQgPSBhLCBhID0gYiwgYiA9IHQ7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLm1heChhLCBNYXRoLm1pbihiLCB4KSk7IH07XG59XG5cbi8vIG5vcm1hbGl6ZShhLCBiKSh4KSB0YWtlcyBhIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlciB0IGluIFswLDFdLlxuLy8gaW50ZXJwb2xhdGUoYSwgYikodCkgdGFrZXMgYSBwYXJhbWV0ZXIgdCBpbiBbMCwxXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByYW5nZSB2YWx1ZSB4IGluIFthLGJdLlxuZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGQwID0gZG9tYWluWzBdLCBkMSA9IGRvbWFpblsxXSwgcjAgPSByYW5nZVswXSwgcjEgPSByYW5nZVsxXTtcbiAgaWYgKGQxIDwgZDApIGQwID0gbm9ybWFsaXplKGQxLCBkMCksIHIwID0gaW50ZXJwb2xhdGUocjEsIHIwKTtcbiAgZWxzZSBkMCA9IG5vcm1hbGl6ZShkMCwgZDEpLCByMCA9IGludGVycG9sYXRlKHIwLCByMSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiByMChkMCh4KSk7IH07XG59XG5cbmZ1bmN0aW9uIHBvbHltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGogPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMSxcbiAgICAgIGQgPSBuZXcgQXJyYXkoaiksXG4gICAgICByID0gbmV3IEFycmF5KGopLFxuICAgICAgaSA9IC0xO1xuXG4gIC8vIFJldmVyc2UgZGVzY2VuZGluZyBkb21haW5zLlxuICBpZiAoZG9tYWluW2pdIDwgZG9tYWluWzBdKSB7XG4gICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIHJhbmdlID0gcmFuZ2Uuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIH1cblxuICB3aGlsZSAoKytpIDwgaikge1xuICAgIGRbaV0gPSBub3JtYWxpemUoZG9tYWluW2ldLCBkb21haW5baSArIDFdKTtcbiAgICByW2ldID0gaW50ZXJwb2xhdGUocmFuZ2VbaV0sIHJhbmdlW2kgKyAxXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHZhciBpID0gYmlzZWN0KGRvbWFpbiwgeCwgMSwgaikgLSAxO1xuICAgIHJldHVybiByW2ldKGRbaV0oeCkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0XG4gICAgICAuZG9tYWluKHNvdXJjZS5kb21haW4oKSlcbiAgICAgIC5yYW5nZShzb3VyY2UucmFuZ2UoKSlcbiAgICAgIC5pbnRlcnBvbGF0ZShzb3VyY2UuaW50ZXJwb2xhdGUoKSlcbiAgICAgIC5jbGFtcChzb3VyY2UuY2xhbXAoKSlcbiAgICAgIC51bmtub3duKHNvdXJjZS51bmtub3duKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciBkb21haW4gPSB1bml0LFxuICAgICAgcmFuZ2UgPSB1bml0LFxuICAgICAgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVZhbHVlLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdW50cmFuc2Zvcm0sXG4gICAgICB1bmtub3duLFxuICAgICAgY2xhbXAgPSBpZGVudGl0eSxcbiAgICAgIHBpZWNld2lzZSxcbiAgICAgIG91dHB1dCxcbiAgICAgIGlucHV0O1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpO1xuICAgIGlmIChjbGFtcCAhPT0gaWRlbnRpdHkpIGNsYW1wID0gY2xhbXBlcihkb21haW5bMF0sIGRvbWFpbltuIC0gMV0pO1xuICAgIHBpZWNld2lzZSA9IG4gPiAyID8gcG9seW1hcCA6IGJpbWFwO1xuICAgIG91dHB1dCA9IGlucHV0ID0gbnVsbDtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCB8fCBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4ubWFwKHRyYW5zZm9ybSksIHJhbmdlLCBpbnRlcnBvbGF0ZSkpKSh0cmFuc2Zvcm0oY2xhbXAoeCkpKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gY2xhbXAodW50cmFuc2Zvcm0oKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZShyYW5nZSwgZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCBpbnRlcnBvbGF0ZU51bWJlcikpKSh5KSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBBcnJheS5mcm9tKF8sIG51bWJlciksIHJlc2NhbGUoKSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIHJhbmdlID0gQXJyYXkuZnJvbShfKSwgaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZVJvdW5kLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSBfID8gdHJ1ZSA6IGlkZW50aXR5LCByZXNjYWxlKCkpIDogY2xhbXAgIT09IGlkZW50aXR5O1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIHUpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB1bnRyYW5zZm9ybSA9IHU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGludW91cygpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKCkoaWRlbnRpdHksIGlkZW50aXR5KTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGUsIGludGVycG9sYXRlUm91bmQsIHBpZWNld2lzZX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXQuanNcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXIuanNcIjtcbmltcG9ydCB7bG9nZ2lzaH0gZnJvbSBcIi4vbG9nLmpzXCI7XG5pbXBvcnQge2NvcHl9IGZyb20gXCIuL3NlcXVlbnRpYWwuanNcIjtcbmltcG9ydCB7c3ltbG9naXNofSBmcm9tIFwiLi9zeW1sb2cuanNcIjtcbmltcG9ydCB7cG93aXNofSBmcm9tIFwiLi9wb3cuanNcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDAuNSxcbiAgICAgIHgyID0gMSxcbiAgICAgIHMgPSAxLFxuICAgICAgdDAsXG4gICAgICB0MSxcbiAgICAgIHQyLFxuICAgICAgazEwLFxuICAgICAgazIxLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHksXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKHggPSAwLjUgKyAoKHggPSArdHJhbnNmb3JtKHgpKSAtIHQxKSAqIChzICogeCA8IHMgKiB0MSA/IGsxMCA6IGsyMSksIGludGVycG9sYXRvcihjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbeDAsIHgxLCB4Ml0gPSBfLCB0MCA9IHRyYW5zZm9ybSh4MCA9ICt4MCksIHQxID0gdHJhbnNmb3JtKHgxID0gK3gxKSwgdDIgPSB0cmFuc2Zvcm0oeDIgPSAreDIpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMC41IC8gKHQxIC0gdDApLCBrMjEgPSB0MSA9PT0gdDIgPyAwIDogMC41IC8gKHQyIC0gdDEpLCBzID0gdDEgPCB0MCA/IC0xIDogMSwgc2NhbGUpIDogW3gwLCB4MSwgeDJdO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJhbmdlKGludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHtcbiAgICAgIHZhciByMCwgcjEsIHIyO1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3IwLCByMSwgcjJdID0gXywgaW50ZXJwb2xhdG9yID0gcGllY2V3aXNlKGludGVycG9sYXRlLCBbcjAsIHIxLCByMl0pLCBzY2FsZSkgOiBbaW50ZXJwb2xhdG9yKDApLCBpbnRlcnBvbGF0b3IoMC41KSwgaW50ZXJwb2xhdG9yKDEpXTtcbiAgICB9O1xuICB9XG5cbiAgc2NhbGUucmFuZ2UgPSByYW5nZShpbnRlcnBvbGF0ZSk7XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IHJhbmdlKGludGVycG9sYXRlUm91bmQpO1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB0MCA9IHQoeDApLCB0MSA9IHQoeDEpLCB0MiA9IHQoeDIpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMC41IC8gKHQxIC0gdDApLCBrMjEgPSB0MSA9PT0gdDIgPyAwIDogMC41IC8gKHQyIC0gdDEpLCBzID0gdDEgPCB0MCA/IC0xIDogMTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpdmVyZ2luZygpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZygpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ0xvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzAuMSwgMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ0xvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ1N5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1BvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nU3FydCgpIHtcbiAgcmV0dXJuIGRpdmVyZ2luZ1Bvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpZGVudGl0eShkb21haW4pIHtcbiAgdmFyIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgfHwgaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiB4O1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gc2NhbGU7XG5cbiAgc2NhbGUuZG9tYWluID0gc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gQXJyYXkuZnJvbShfLCBudW1iZXIpLCBzY2FsZSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWRlbnRpdHkoZG9tYWluKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGRvbWFpbiA9IGFyZ3VtZW50cy5sZW5ndGggPyBBcnJheS5mcm9tKGRvbWFpbiwgbnVtYmVyKSA6IFswLCAxXTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpbml0UmFuZ2UoZG9tYWluLCByYW5nZSkge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMTogdGhpcy5yYW5nZShkb21haW4pOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aGlzLnJhbmdlKHJhbmdlKS5kb21haW4oZG9tYWluKTsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0SW50ZXJwb2xhdG9yKGRvbWFpbiwgaW50ZXJwb2xhdG9yKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB7XG4gICAgICBpZiAodHlwZW9mIGRvbWFpbiA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLmludGVycG9sYXRvcihkb21haW4pO1xuICAgICAgZWxzZSB0aGlzLnJhbmdlKGRvbWFpbik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhpcy5kb21haW4oZG9tYWluKTtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJwb2xhdG9yID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuaW50ZXJwb2xhdG9yKGludGVycG9sYXRvcik7XG4gICAgICBlbHNlIHRoaXMucmFuZ2UoaW50ZXJwb2xhdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCB7dGlja3MsIHRpY2tJbmNyZW1lbnR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5fSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuaW1wb3J0IHRpY2tGb3JtYXQgZnJvbSBcIi4vdGlja0Zvcm1hdC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tzKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50LCBzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuXG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICB2YXIgaTAgPSAwO1xuICAgIHZhciBpMSA9IGQubGVuZ3RoIC0gMTtcbiAgICB2YXIgc3RhcnQgPSBkW2kwXTtcbiAgICB2YXIgc3RvcCA9IGRbaTFdO1xuICAgIHZhciBwcmVzdGVwO1xuICAgIHZhciBzdGVwO1xuICAgIHZhciBtYXhJdGVyID0gMTA7XG5cbiAgICBpZiAoc3RvcCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XG4gICAgICBzdGVwID0gaTAsIGkwID0gaTEsIGkxID0gc3RlcDtcbiAgICB9XG4gICAgXG4gICAgd2hpbGUgKG1heEl0ZXItLSA+IDApIHtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgICBpZiAoc3RlcCA9PT0gcHJlc3RlcCkge1xuICAgICAgICBkW2kwXSA9IHN0YXJ0XG4gICAgICAgIGRbaTFdID0gc3RvcFxuICAgICAgICByZXR1cm4gZG9tYWluKGQpO1xuICAgICAgfSBlbHNlIGlmIChzdGVwID4gMCkge1xuICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHByZXN0ZXAgPSBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpbmVhcigpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cygpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbGluZWFyKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImltcG9ydCB7dGlja3N9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtmb3JtYXR9IGZyb20gXCJkMy1mb3JtYXRcIjtcbmltcG9ydCBuaWNlIGZyb20gXCIuL25pY2UuanNcIjtcbmltcG9ydCB7Y29weSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUxvZyh4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRXhwKHgpIHtcbiAgcmV0dXJuIE1hdGguZXhwKHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2duKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmxvZygteCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cG4oeCkge1xuICByZXR1cm4gLU1hdGguZXhwKC14KTtcbn1cblxuZnVuY3Rpb24gcG93MTAoeCkge1xuICByZXR1cm4gaXNGaW5pdGUoeCkgPyArKFwiMWVcIiArIHgpIDogeCA8IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gcG93cChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSAxMCA/IHBvdzEwXG4gICAgICA6IGJhc2UgPT09IE1hdGguRSA/IE1hdGguZXhwXG4gICAgICA6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucG93KGJhc2UsIHgpOyB9O1xufVxuXG5mdW5jdGlvbiBsb2dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IE1hdGguRSA/IE1hdGgubG9nXG4gICAgICA6IGJhc2UgPT09IDEwICYmIE1hdGgubG9nMTBcbiAgICAgIHx8IGJhc2UgPT09IDIgJiYgTWF0aC5sb2cyXG4gICAgICB8fCAoYmFzZSA9IE1hdGgubG9nKGJhc2UpLCBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4KSAvIGJhc2U7IH0pO1xufVxuXG5mdW5jdGlvbiByZWZsZWN0KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gLWYoLXgpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIGJhc2UgPSAxMCxcbiAgICAgIGxvZ3MsXG4gICAgICBwb3dzO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgbG9ncyA9IGxvZ3AoYmFzZSksIHBvd3MgPSBwb3dwKGJhc2UpO1xuICAgIGlmIChkb21haW4oKVswXSA8IDApIHtcbiAgICAgIGxvZ3MgPSByZWZsZWN0KGxvZ3MpLCBwb3dzID0gcmVmbGVjdChwb3dzKTtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2duLCB0cmFuc2Zvcm1FeHBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gK18sIHJlc2NhbGUoKSkgOiBiYXNlO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdSA9IGRbMF0sXG4gICAgICAgIHYgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHI7XG5cbiAgICBpZiAociA9IHYgPCB1KSBpID0gdSwgdSA9IHYsIHYgPSBpO1xuXG4gICAgdmFyIGkgPSBsb2dzKHUpLFxuICAgICAgICBqID0gbG9ncyh2KSxcbiAgICAgICAgcCxcbiAgICAgICAgayxcbiAgICAgICAgdCxcbiAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudCxcbiAgICAgICAgeiA9IFtdO1xuXG4gICAgaWYgKCEoYmFzZSAlIDEpICYmIGogLSBpIDwgbikge1xuICAgICAgaSA9IE1hdGguZmxvb3IoaSksIGogPSBNYXRoLmNlaWwoaik7XG4gICAgICBpZiAodSA+IDApIGZvciAoOyBpIDw9IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSAxLCBwID0gcG93cyhpKTsgayA8IGJhc2U7ICsraykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgZm9yICg7IGkgPD0gajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IGJhc2UgLSAxLCBwID0gcG93cyhpKTsgayA+PSAxOyAtLWspIHtcbiAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHoubGVuZ3RoICogMiA8IG4pIHogPSB0aWNrcyh1LCB2LCBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IHRpY2tzKGksIGosIE1hdGgubWluKGogLSBpLCBuKSkubWFwKHBvd3MpO1xuICAgIH1cblxuICAgIHJldHVybiByID8gei5yZXZlcnNlKCkgOiB6O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgaWYgKHNwZWNpZmllciA9PSBudWxsKSBzcGVjaWZpZXIgPSBiYXNlID09PSAxMCA/IFwiLjBlXCIgOiBcIixcIjtcbiAgICBpZiAodHlwZW9mIHNwZWNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBzcGVjaWZpZXIgPSBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSByZXR1cm4gc3BlY2lmaWVyO1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuICAgIHZhciBrID0gTWF0aC5tYXgoMSwgYmFzZSAqIGNvdW50IC8gc2NhbGUudGlja3MoKS5sZW5ndGgpOyAvLyBUT0RPIGZhc3QgZXN0aW1hdGU/XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciBpID0gZCAvIHBvd3MoTWF0aC5yb3VuZChsb2dzKGQpKSk7XG4gICAgICBpZiAoaSAqIGJhc2UgPCBiYXNlIC0gMC41KSBpICo9IGJhc2U7XG4gICAgICByZXR1cm4gaSA8PSBrID8gc3BlY2lmaWVyKGQpIDogXCJcIjtcbiAgICB9O1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluKG5pY2UoZG9tYWluKCksIHtcbiAgICAgIGZsb29yOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguZmxvb3IobG9ncyh4KSkpOyB9LFxuICAgICAgY2VpbDogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmNlaWwobG9ncyh4KSkpOyB9XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5pY2UoZG9tYWluLCBpbnRlcnZhbCkge1xuICBkb21haW4gPSBkb21haW4uc2xpY2UoKTtcblxuICB2YXIgaTAgPSAwLFxuICAgICAgaTEgPSBkb21haW4ubGVuZ3RoIC0gMSxcbiAgICAgIHgwID0gZG9tYWluW2kwXSxcbiAgICAgIHgxID0gZG9tYWluW2kxXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHgxIDwgeDApIHtcbiAgICB0ID0gaTAsIGkwID0gaTEsIGkxID0gdDtcbiAgICB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgfVxuXG4gIGRvbWFpbltpMF0gPSBpbnRlcnZhbC5mbG9vcih4MCk7XG4gIGRvbWFpbltpMV0gPSBpbnRlcnZhbC5jZWlsKHgxKTtcbiAgcmV0dXJuIGRvbWFpbjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG51bWJlcih4KSB7XG4gIHJldHVybiAreDtcbn1cbiIsImltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBjb25zdCBpbXBsaWNpdCA9IFN5bWJvbChcImltcGxpY2l0XCIpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRpbmFsKCkge1xuICB2YXIgaW5kZXggPSBuZXcgTWFwKCksXG4gICAgICBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgZnVuY3Rpb24gc2NhbGUoZCkge1xuICAgIHZhciBrZXkgPSBkICsgXCJcIiwgaSA9IGluZGV4LmdldChrZXkpO1xuICAgIGlmICghaSkge1xuICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgIGluZGV4LnNldChrZXksIGkgPSBkb21haW4ucHVzaChkKSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZVsoaSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXSwgaW5kZXggPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBfKSB7XG4gICAgICBjb25zdCBrZXkgPSB2YWx1ZSArIFwiXCI7XG4gICAgICBpZiAoaW5kZXguaGFzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgaW5kZXguc2V0KGtleSwgZG9tYWluLnB1c2godmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JkaW5hbChkb21haW4sIHJhbmdlKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5pbXBvcnQge2NvcHksIGlkZW50aXR5LCB0cmFuc2Zvcm1lcn0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUG93KGV4cG9uZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggPCAwID8gLU1hdGgucG93KC14LCBleHBvbmVudCkgOiBNYXRoLnBvdyh4LCBleHBvbmVudCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxcnQoeCkge1xuICByZXR1cm4geCA8IDAgPyAtTWF0aC5zcXJ0KC14KSA6IE1hdGguc3FydCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3F1YXJlKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLXggKiB4IDogeCAqIHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpLFxuICAgICAgZXhwb25lbnQgPSAxO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgcmV0dXJuIGV4cG9uZW50ID09PSAxID8gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSlcbiAgICAgICAgOiBleHBvbmVudCA9PT0gMC41ID8gdHJhbnNmb3JtKHRyYW5zZm9ybVNxcnQsIHRyYW5zZm9ybVNxdWFyZSlcbiAgICAgICAgOiB0cmFuc2Zvcm0odHJhbnNmb3JtUG93KGV4cG9uZW50KSwgdHJhbnNmb3JtUG93KDEgLyBleHBvbmVudCkpO1xuICB9XG5cbiAgc2NhbGUuZXhwb25lbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXhwb25lbnQgPSArXywgcmVzY2FsZSgpKSA6IGV4cG9uZW50O1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHBvdygpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3FydCgpIHtcbiAgcmV0dXJuIHBvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJpbXBvcnQge2FzY2VuZGluZywgYmlzZWN0LCBxdWFudGlsZVNvcnRlZCBhcyB0aHJlc2hvbGR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpbGUoKSB7XG4gIHZhciBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB0aHJlc2hvbGRzID0gW10sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gTWF0aC5tYXgoMSwgcmFuZ2UubGVuZ3RoKTtcbiAgICB0aHJlc2hvbGRzID0gbmV3IEFycmF5KG4gLSAxKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGhyZXNob2xkc1tpIC0gMV0gPSB0aHJlc2hvbGQoZG9tYWluLCBpIC8gbik7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgfHwgaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiByYW5nZVtiaXNlY3QodGhyZXNob2xkcywgeCldO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dIDogW1xuICAgICAgaSA+IDAgPyB0aHJlc2hvbGRzW2kgLSAxXSA6IGRvbWFpblswXSxcbiAgICAgIGkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbaV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdXG4gICAgXTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yIChsZXQgZCBvZiBfKSBpZiAoZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGlsZSgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGl6ZSgpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIG4gPSAxLFxuICAgICAgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgeCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3gwLCB4MV0gPSBfLCB4MCA9ICt4MCwgeDEgPSAreDEsIHJlc2NhbGUoKSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChuID0gKHJhbmdlID0gQXJyYXkuZnJvbShfKSkubGVuZ3RoIC0gMSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dXG4gICAgICAgIDogaSA8IDEgPyBbeDAsIGRvbWFpblswXV1cbiAgICAgICAgOiBpID49IG4gPyBbZG9tYWluW24gLSAxXSwgeDFdXG4gICAgICAgIDogW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUudGhyZXNob2xkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aXplKClcbiAgICAgICAgLmRvbWFpbihbeDAsIHgxXSlcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KGxpbmVhcmlzaChzY2FsZSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2ludGVycG9sYXRlLCBpbnRlcnBvbGF0ZVJvdW5kfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7aWRlbnRpdHl9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdEludGVycG9sYXRvcn0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IHtsb2dnaXNofSBmcm9tIFwiLi9sb2cuanNcIjtcbmltcG9ydCB7c3ltbG9naXNofSBmcm9tIFwiLi9zeW1sb2cuanNcIjtcbmltcG9ydCB7cG93aXNofSBmcm9tIFwiLi9wb3cuanNcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICB0MCxcbiAgICAgIHQxLFxuICAgICAgazEwLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHksXG4gICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCB8fCBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IGludGVycG9sYXRvcihrMTAgPT09IDAgPyAwLjUgOiAoeCA9ICh0cmFuc2Zvcm0oeCkgLSB0MCkgKiBrMTAsIGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpIDogeCkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFt4MCwgeDFdID0gXywgdDAgPSB0cmFuc2Zvcm0oeDAgPSAreDApLCB0MSA9IHRyYW5zZm9ybSh4MSA9ICt4MSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAxIC8gKHQxIC0gdDApLCBzY2FsZSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBmdW5jdGlvbiByYW5nZShpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihfKSB7XG4gICAgICB2YXIgcjAsIHIxO1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3IwLCByMV0gPSBfLCBpbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0ZShyMCwgcjEpLCBzY2FsZSkgOiBbaW50ZXJwb2xhdG9yKDApLCBpbnRlcnBvbGF0b3IoMSldO1xuICAgIH07XG4gIH1cblxuICBzY2FsZS5yYW5nZSA9IHJhbmdlKGludGVycG9sYXRlKTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gcmFuZ2UoaW50ZXJwb2xhdGVSb3VuZCk7XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHQwID0gdCh4MCksIHQxID0gdCh4MSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAxIC8gKHQxIC0gdDApO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAuaW50ZXJwb2xhdG9yKHNvdXJjZS5pbnRlcnBvbGF0b3IoKSlcbiAgICAgIC5jbGFtcChzb3VyY2UuY2xhbXAoKSlcbiAgICAgIC51bmtub3duKHNvdXJjZS51bmtub3duKCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXF1ZW50aWFsKCkge1xuICB2YXIgc2NhbGUgPSBsaW5lYXJpc2godHJhbnNmb3JtZXIoKShpZGVudGl0eSkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc2VxdWVudGlhbCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxMb2coKSB7XG4gIHZhciBzY2FsZSA9IGxvZ2dpc2godHJhbnNmb3JtZXIoKSkuZG9tYWluKFsxLCAxMF0pO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc2VxdWVudGlhbExvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsU3ltbG9nKCkge1xuICB2YXIgc2NhbGUgPSBzeW1sb2dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsU3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFBvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc2VxdWVudGlhbFBvdygpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxTcXJ0KCkge1xuICByZXR1cm4gc2VxdWVudGlhbFBvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TeW1sb2coYykge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmxvZzFwKE1hdGguYWJzKHggLyBjKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWV4cChjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGguZXhwbTEoTWF0aC5hYnMoeCkpICogYztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bWxvZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIGMgPSAxLCBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyksIHRyYW5zZm9ybVN5bWV4cChjKSk7XG5cbiAgc2NhbGUuY29uc3RhbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3ltbG9nKGMgPSArXyksIHRyYW5zZm9ybVN5bWV4cChjKSkgOiBjO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGhyZXNob2xkKCkge1xuICB2YXIgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd24sXG4gICAgICBuID0gMTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiB4IDw9IHggPyByYW5nZVtiaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IEFycmF5LmZyb20oXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge3RpY2tTdGVwfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0LCBmb3JtYXRQcmVmaXgsIGZvcm1hdFNwZWNpZmllciwgcHJlY2lzaW9uRml4ZWQsIHByZWNpc2lvblByZWZpeCwgcHJlY2lzaW9uUm91bmR9IGZyb20gXCJkMy1mb3JtYXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGlja0Zvcm1hdChzdGFydCwgc3RvcCwgY291bnQsIHNwZWNpZmllcikge1xuICB2YXIgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCksXG4gICAgICBwcmVjaXNpb247XG4gIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIgPT0gbnVsbCA/IFwiLGZcIiA6IHNwZWNpZmllcik7XG4gIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICBjYXNlIFwic1wiOiB7XG4gICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKTtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgcmV0dXJuIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgY2FzZSBcIlwiOlxuICAgIGNhc2UgXCJlXCI6XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwicFwiOlxuICAgIGNhc2UgXCJyXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblJvdW5kKHN0ZXAsIE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiZVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZlwiOlxuICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvbkZpeGVkKHN0ZXApKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCIlXCIpICogMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHNwZWNpZmllcik7XG59XG4iLCJpbXBvcnQge3RpbWVZZWFyLCB0aW1lTW9udGgsIHRpbWVXZWVrLCB0aW1lRGF5LCB0aW1lSG91ciwgdGltZU1pbnV0ZSwgdGltZVNlY29uZCwgdGltZVRpY2tzLCB0aW1lVGlja0ludGVydmFsfSBmcm9tIFwiZDMtdGltZVwiO1xuaW1wb3J0IHt0aW1lRm9ybWF0fSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcbmltcG9ydCBjb250aW51b3VzLCB7Y29weX0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcbmltcG9ydCBuaWNlIGZyb20gXCIuL25pY2UuanNcIjtcblxuZnVuY3Rpb24gZGF0ZSh0KSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0KTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBEYXRlID8gK3QgOiArbmV3IERhdGUoK3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsZW5kYXIodGlja3MsIHRpY2tJbnRlcnZhbCwgeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZvcm1hdCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKCksXG4gICAgICBpbnZlcnQgPSBzY2FsZS5pbnZlcnQsXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgdmFyIGZvcm1hdE1pbGxpc2Vjb25kID0gZm9ybWF0KFwiLiVMXCIpLFxuICAgICAgZm9ybWF0U2Vjb25kID0gZm9ybWF0KFwiOiVTXCIpLFxuICAgICAgZm9ybWF0TWludXRlID0gZm9ybWF0KFwiJUk6JU1cIiksXG4gICAgICBmb3JtYXRIb3VyID0gZm9ybWF0KFwiJUkgJXBcIiksXG4gICAgICBmb3JtYXREYXkgPSBmb3JtYXQoXCIlYSAlZFwiKSxcbiAgICAgIGZvcm1hdFdlZWsgPSBmb3JtYXQoXCIlYiAlZFwiKSxcbiAgICAgIGZvcm1hdE1vbnRoID0gZm9ybWF0KFwiJUJcIiksXG4gICAgICBmb3JtYXRZZWFyID0gZm9ybWF0KFwiJVlcIik7XG5cbiAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgcmV0dXJuIChzZWNvbmQoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBtaW51dGUoZGF0ZSkgPCBkYXRlID8gZm9ybWF0U2Vjb25kXG4gICAgICAgIDogaG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkYXkoZGF0ZSkgPCBkYXRlID8gZm9ybWF0SG91clxuICAgICAgICA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/ICh3ZWVrKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogeWVhcihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICA6IGZvcm1hdFllYXIpKGRhdGUpO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShpbnZlcnQoeSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRvbWFpbihBcnJheS5mcm9tKF8sIG51bWJlcikpIDogZG9tYWluKCkubWFwKGRhdGUpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGludGVydmFsID09IG51bGwgPyAxMCA6IGludGVydmFsKTtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IHRpY2tGb3JtYXQgOiBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIGlmICghaW50ZXJ2YWwgfHwgdHlwZW9mIGludGVydmFsLnJhbmdlICE9PSBcImZ1bmN0aW9uXCIpIGludGVydmFsID0gdGlja0ludGVydmFsKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgaW50ZXJ2YWwgPT0gbnVsbCA/IDEwIDogaW50ZXJ2YWwpO1xuICAgIHJldHVybiBpbnRlcnZhbCA/IGRvbWFpbihuaWNlKGQsIGludGVydmFsKSkgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGNhbGVuZGFyKHRpY2tzLCB0aWNrSW50ZXJ2YWwsIHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmb3JtYXQpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpbWUoKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIodGltZVRpY2tzLCB0aW1lVGlja0ludGVydmFsLCB0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lV2VlaywgdGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVTZWNvbmQsIHRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge3V0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNUaWNrcywgdXRjVGlja0ludGVydmFsfSBmcm9tIFwiZDMtdGltZVwiO1xuaW1wb3J0IHt1dGNGb3JtYXR9IGZyb20gXCJkMy10aW1lLWZvcm1hdFwiO1xuaW1wb3J0IHtjYWxlbmRhcn0gZnJvbSBcIi4vdGltZS5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXRjVGltZSgpIHtcbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShjYWxlbmRhcih1dGNUaWNrcywgdXRjVGlja0ludGVydmFsLCB1dGNZZWFyLCB1dGNNb250aCwgdXRjV2VlaywgdXRjRGF5LCB1dGNIb3VyLCB1dGNNaW51dGUsIHV0Y1NlY29uZCwgdXRjRm9ybWF0KS5kb21haW4oW0RhdGUuVVRDKDIwMDAsIDAsIDEpLCBEYXRlLlVUQygyMDAwLCAwLCAyKV0pLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQge2FicywgYWNvcywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgaGFsZlBpLCBtYXgsIG1pbiwgcGksIHNpbiwgc3FydCwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGFyY0lubmVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY091dGVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY1N0YXJ0QW5nbGUoZCkge1xuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNFbmRBbmdsZShkKSB7XG4gIHJldHVybiBkLmVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNQYWRBbmdsZShkKSB7XG4gIHJldHVybiBkICYmIGQucGFkQW5nbGU7IC8vIE5vdGU6IG9wdGlvbmFsIVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciB4MTAgPSB4MSAtIHgwLCB5MTAgPSB5MSAtIHkwLFxuICAgICAgeDMyID0geDMgLSB4MiwgeTMyID0geTMgLSB5MixcbiAgICAgIHQgPSB5MzIgKiB4MTAgLSB4MzIgKiB5MTA7XG4gIGlmICh0ICogdCA8IGVwc2lsb24pIHJldHVybjtcbiAgdCA9ICh4MzIgKiAoeTAgLSB5MikgLSB5MzIgKiAoeDAgLSB4MikpIC8gdDtcbiAgcmV0dXJuIFt4MCArIHQgKiB4MTAsIHkwICsgdCAqIHkxMF07XG59XG5cbi8vIENvbXB1dGUgcGVycGVuZGljdWxhciBvZmZzZXQgbGluZSBvZiBsZW5ndGggcmMuXG4vLyBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmNsZS1MaW5lSW50ZXJzZWN0aW9uLmh0bWxcbmZ1bmN0aW9uIGNvcm5lclRhbmdlbnRzKHgwLCB5MCwgeDEsIHkxLCByMSwgcmMsIGN3KSB7XG4gIHZhciB4MDEgPSB4MCAtIHgxLFxuICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgIGxvID0gKGN3ID8gcmMgOiAtcmMpIC8gc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxuICAgICAgb3ggPSBsbyAqIHkwMSxcbiAgICAgIG95ID0gLWxvICogeDAxLFxuICAgICAgeDExID0geDAgKyBveCxcbiAgICAgIHkxMSA9IHkwICsgb3ksXG4gICAgICB4MTAgPSB4MSArIG94LFxuICAgICAgeTEwID0geTEgKyBveSxcbiAgICAgIHgwMCA9ICh4MTEgKyB4MTApIC8gMixcbiAgICAgIHkwMCA9ICh5MTEgKyB5MTApIC8gMixcbiAgICAgIGR4ID0geDEwIC0geDExLFxuICAgICAgZHkgPSB5MTAgLSB5MTEsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgciA9IHIxIC0gcmMsXG4gICAgICBEID0geDExICogeTEwIC0geDEwICogeTExLFxuICAgICAgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogc3FydChtYXgoMCwgciAqIHIgKiBkMiAtIEQgKiBEKSksXG4gICAgICBjeDAgPSAoRCAqIGR5IC0gZHggKiBkKSAvIGQyLFxuICAgICAgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsXG4gICAgICBjeDEgPSAoRCAqIGR5ICsgZHggKiBkKSAvIGQyLFxuICAgICAgY3kxID0gKC1EICogZHggKyBkeSAqIGQpIC8gZDIsXG4gICAgICBkeDAgPSBjeDAgLSB4MDAsXG4gICAgICBkeTAgPSBjeTAgLSB5MDAsXG4gICAgICBkeDEgPSBjeDEgLSB4MDAsXG4gICAgICBkeTEgPSBjeTEgLSB5MDA7XG5cbiAgLy8gUGljayB0aGUgY2xvc2VyIG9mIHRoZSB0d28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgLy8gVE9ETyBJcyB0aGVyZSBhIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoIGludGVyc2VjdGlvbiB0byB1c2U/XG4gIGlmIChkeDAgKiBkeDAgKyBkeTAgKiBkeTAgPiBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpIGN4MCA9IGN4MSwgY3kwID0gY3kxO1xuXG4gIHJldHVybiB7XG4gICAgY3g6IGN4MCxcbiAgICBjeTogY3kwLFxuICAgIHgwMTogLW94LFxuICAgIHkwMTogLW95LFxuICAgIHgxMTogY3gwICogKHIxIC8gciAtIDEpLFxuICAgIHkxMTogY3kwICogKHIxIC8gciAtIDEpXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5uZXJSYWRpdXMgPSBhcmNJbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzID0gYXJjT3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb25zdGFudCgwKSxcbiAgICAgIHBhZFJhZGl1cyA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gYXJjU3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gYXJjRW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IGFyY1BhZEFuZ2xlLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJjKCkge1xuICAgIHZhciBidWZmZXIsXG4gICAgICAgIHIsXG4gICAgICAgIHIwID0gK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIxID0gK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGRhID0gYWJzKGExIC0gYTApLFxuICAgICAgICBjdyA9IGExID4gYTA7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3V0ZXIgcmFkaXVzIGlzIGFsd2F5cyBsYXJnZXIgdGhhbiB0aGUgaW5uZXIgcmFkaXVzLlxuICAgIGlmIChyMSA8IHIwKSByID0gcjEsIHIxID0gcjAsIHIwID0gcjtcblxuICAgIC8vIElzIGl0IGEgcG9pbnQ/XG4gICAgaWYgKCEocjEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmNsZSBvciBhbm51bHVzP1xuICAgIGVsc2UgaWYgKGRhID4gdGF1IC0gZXBzaWxvbikge1xuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBjb3MoYTApLCByMSAqIHNpbihhMCkpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwLCBhMSwgIWN3KTtcbiAgICAgIGlmIChyMCA+IGVwc2lsb24pIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocjAgKiBjb3MoYTEpLCByMCAqIHNpbihhMSkpO1xuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEsIGEwLCBjdyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjdWxhciBvciBhbm51bGFyIHNlY3Rvcj9cbiAgICBlbHNlIHtcbiAgICAgIHZhciBhMDEgPSBhMCxcbiAgICAgICAgICBhMTEgPSBhMSxcbiAgICAgICAgICBhMDAgPSBhMCxcbiAgICAgICAgICBhMTAgPSBhMSxcbiAgICAgICAgICBkYTAgPSBkYSxcbiAgICAgICAgICBkYTEgPSBkYSxcbiAgICAgICAgICBhcCA9IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLyAyLFxuICAgICAgICAgIHJwID0gKGFwID4gZXBzaWxvbikgJiYgKHBhZFJhZGl1cyA/ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHNxcnQocjAgKiByMCArIHIxICogcjEpKSxcbiAgICAgICAgICByYyA9IG1pbihhYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICAgIHJjMCA9IHJjLFxuICAgICAgICAgIHJjMSA9IHJjLFxuICAgICAgICAgIHQwLFxuICAgICAgICAgIHQxO1xuXG4gICAgICAvLyBBcHBseSBwYWRkaW5nPyBOb3RlIHRoYXQgc2luY2UgcjEg4omlIHIwLCBkYTEg4omlIGRhMC5cbiAgICAgIGlmIChycCA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHAwID0gYXNpbihycCAvIHIwICogc2luKGFwKSksXG4gICAgICAgICAgICBwMSA9IGFzaW4ocnAgLyByMSAqIHNpbihhcCkpO1xuICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbikgcDAgKj0gKGN3ID8gMSA6IC0xKSwgYTAwICs9IHAwLCBhMTAgLT0gcDA7XG4gICAgICAgIGVsc2UgZGEwID0gMCwgYTAwID0gYTEwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24pIHAxICo9IChjdyA/IDEgOiAtMSksIGEwMSArPSBwMSwgYTExIC09IHAxO1xuICAgICAgICBlbHNlIGRhMSA9IDAsIGEwMSA9IGExMSA9IChhMCArIGExKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciB4MDEgPSByMSAqIGNvcyhhMDEpLFxuICAgICAgICAgIHkwMSA9IHIxICogc2luKGEwMSksXG4gICAgICAgICAgeDEwID0gcjAgKiBjb3MoYTEwKSxcbiAgICAgICAgICB5MTAgPSByMCAqIHNpbihhMTApO1xuXG4gICAgICAvLyBBcHBseSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBpZiAocmMgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciB4MTEgPSByMSAqIGNvcyhhMTEpLFxuICAgICAgICAgICAgeTExID0gcjEgKiBzaW4oYTExKSxcbiAgICAgICAgICAgIHgwMCA9IHIwICogY29zKGEwMCksXG4gICAgICAgICAgICB5MDAgPSByMCAqIHNpbihhMDApLFxuICAgICAgICAgICAgb2M7XG5cbiAgICAgICAgLy8gUmVzdHJpY3QgdGhlIGNvcm5lciByYWRpdXMgYWNjb3JkaW5nIHRvIHRoZSBzZWN0b3IgYW5nbGUuXG4gICAgICAgIGlmIChkYSA8IHBpICYmIChvYyA9IGludGVyc2VjdCh4MDEsIHkwMSwgeDAwLCB5MDAsIHgxMSwgeTExLCB4MTAsIHkxMCkpKSB7XG4gICAgICAgICAgdmFyIGF4ID0geDAxIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGF5ID0geTAxIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGJ4ID0geDExIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGJ5ID0geTExIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGtjID0gMSAvIHNpbihhY29zKChheCAqIGJ4ICsgYXkgKiBieSkgLyAoc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBzcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksXG4gICAgICAgICAgICAgIGxjID0gc3FydChvY1swXSAqIG9jWzBdICsgb2NbMV0gKiBvY1sxXSk7XG4gICAgICAgICAgcmMwID0gbWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgcmMxID0gbWluKHJjLCAocjEgLSBsYykgLyAoa2MgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSXMgdGhlIHNlY3RvciBjb2xsYXBzZWQgdG8gYSBsaW5lP1xuICAgICAgaWYgKCEoZGExID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBvdXRlciByaW5nIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMxID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgwMCwgeTAwLCB4MDEsIHkwMSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgxMSwgeTExLCB4MTAsIHkxMCwgcjEsIHJjMSwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzEgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzEsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpO1xuXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgLy8gT3IgcGVyaGFwcyBpdOKAmXMgYW4gYW5udWxhciBzZWN0b3IgY29sbGFwc2VkIGR1ZSB0byBwYWRkaW5nP1xuICAgICAgaWYgKCEocjAgPiBlcHNpbG9uKSB8fCAhKGRhMCA+IGVwc2lsb24pKSBjb250ZXh0LmxpbmVUbyh4MTAsIHkxMCk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgaW5uZXIgcmluZyAob3IgcG9pbnQpIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMwID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgaW5uZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEwLCBhMDAsIGN3KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9ICgraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIsXG4gICAgICAgIGEgPSAoK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBwaSAvIDI7XG4gICAgcmV0dXJuIFtjb3MoYSkgKiByLCBzaW4oYSkgKiByXTtcbiAgfTtcblxuICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW5uZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGlubmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvdXRlclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogb3V0ZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb3JuZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGNvcm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZFJhZGl1cyA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZFJhZGl1cztcbiAgfTtcblxuICBhcmMuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRBbmdsZTtcbiAgfTtcblxuICBhcmMuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgYXJjKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyYztcbn1cbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyLmpzXCI7XG5pbXBvcnQgbGluZSBmcm9tIFwiLi9saW5lLmpzXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeDAsIHkwLCB5MSkge1xuICB2YXIgeDEgPSBudWxsLFxuICAgICAgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbDtcblxuICB4MCA9IHR5cGVvZiB4MCA9PT0gXCJmdW5jdGlvblwiID8geDAgOiAoeDAgPT09IHVuZGVmaW5lZCkgPyBwb2ludFggOiBjb25zdGFudCgreDApO1xuICB5MCA9IHR5cGVvZiB5MCA9PT0gXCJmdW5jdGlvblwiID8geTAgOiAoeTAgPT09IHVuZGVmaW5lZCkgPyBjb25zdGFudCgwKSA6IGNvbnN0YW50KCt5MCk7XG4gIHkxID0gdHlwZW9mIHkxID09PSBcImZ1bmN0aW9uXCIgPyB5MSA6ICh5MSA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WSA6IGNvbnN0YW50KCt5MSk7XG5cbiAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG4gPSAoZGF0YSA9IGFycmF5KGRhdGEpKS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgeDB6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICB5MHogPSBuZXcgQXJyYXkobik7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSB7XG4gICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFTdGFydCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgICBmb3IgKGsgPSBpIC0gMTsgayA+PSBqOyAtLWspIHtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludCh4MHpba10sIHkweltrXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSB7XG4gICAgICAgIHgweltpXSA9ICt4MChkLCBpLCBkYXRhKSwgeTB6W2ldID0gK3kwKGQsIGksIGRhdGEpO1xuICAgICAgICBvdXRwdXQucG9pbnQoeDEgPyAreDEoZCwgaSwgZGF0YSkgOiB4MHpbaV0sIHkxID8gK3kxKGQsIGksIGRhdGEpIDogeTB6W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlYWxpbmUoKSB7XG4gICAgcmV0dXJuIGxpbmUoKS5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlKS5jb250ZXh0KGNvbnRleHQpO1xuICB9XG5cbiAgYXJlYS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHgxID0gbnVsbCwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MTtcbiAgfTtcblxuICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeTEgPSBudWxsLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkxO1xuICB9O1xuXG4gIGFyZWEubGluZVgwID1cbiAgYXJlYS5saW5lWTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmxpbmVZMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTEpO1xuICB9O1xuXG4gIGFyZWEubGluZVgxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MSkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGFyZWEpIDogZGVmaW5lZDtcbiAgfTtcblxuICBhcmVhLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGFyZWEpIDogY3VydmU7XG4gIH07XG5cbiAgYXJlYS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBhcmVhKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyZWE7XG59XG4iLCJleHBvcnQgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIHhcbiAgICA/IHggLy8gQXJyYXksIFR5cGVkQXJyYXksIE5vZGVMaXN0LCBhcnJheS1saWtlXG4gICAgOiBBcnJheS5mcm9tKHgpOyAvLyBNYXAsIFNldCwgaXRlcmFibGUsIHN0cmluZywgb3IgYW55dGhpbmcgZWxzZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24gY29uc3RhbnQoKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcG9pbnQodGhhdCwgeCwgeSkge1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgKDIgKiB0aGF0Ll94MCArIHRoYXQuX3gxKSAvIDMsXG4gICAgKDIgKiB0aGF0Ll95MCArIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgMiAqIHRoYXQuX3gxKSAvIDMsXG4gICAgKHRoYXQuX3kwICsgMiAqIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgNCAqIHRoYXQuX3gxICsgeCkgLyA2LFxuICAgICh0aGF0Ll95MCArIDQgKiB0aGF0Ll95MSArIHkpIC8gNlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQmFzaXMoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXMucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IC8vIHByb2NlZWRcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9jb250ZXh0LmxpbmVUbygoNSAqIHRoaXMuX3gwICsgdGhpcy5feDEpIC8gNiwgKDUgKiB0aGlzLl95MCArIHRoaXMuX3kxKSAvIDYpOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpcyhjb250ZXh0KTtcbn1cbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuXG5mdW5jdGlvbiBCYXNpc0Nsb3NlZChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpc0Nsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MiArIDIgKiB0aGlzLl94MykgLyAzLCAodGhpcy5feTIgKyAyICogdGhpcy5feTMpIC8gMyk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKCh0aGlzLl94MyArIDIgKiB0aGlzLl94MikgLyAzLCAodGhpcy5feTMgKyAyICogdGhpcy5feTIpIC8gMyk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDIgPSB4LCB0aGlzLl95MiA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geTsgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDYpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzQ2xvc2VkKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZnVuY3Rpb24gQmFzaXNPcGVuKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHZhciB4MCA9ICh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIHgpIC8gNiwgeTAgPSAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDY7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MCwgeTApIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeDAsIHkwKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNPcGVuKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHtCYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcblxuZnVuY3Rpb24gQnVuZGxlKGNvbnRleHQsIGJldGEpIHtcbiAgdGhpcy5fYmFzaXMgPSBuZXcgQmFzaXMoY29udGV4dCk7XG4gIHRoaXMuX2JldGEgPSBiZXRhO1xufVxuXG5CdW5kbGUucHJvdG90eXBlID0ge1xuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSBbXTtcbiAgICB0aGlzLl95ID0gW107XG4gICAgdGhpcy5fYmFzaXMubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgIGogPSB4Lmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoaiA+IDApIHtcbiAgICAgIHZhciB4MCA9IHhbMF0sXG4gICAgICAgICAgeTAgPSB5WzBdLFxuICAgICAgICAgIGR4ID0geFtqXSAtIHgwLFxuICAgICAgICAgIGR5ID0geVtqXSAtIHkwLFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICB0O1xuXG4gICAgICB3aGlsZSAoKytpIDw9IGopIHtcbiAgICAgICAgdCA9IGkgLyBqO1xuICAgICAgICB0aGlzLl9iYXNpcy5wb2ludChcbiAgICAgICAgICB0aGlzLl9iZXRhICogeFtpXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoeDAgKyB0ICogZHgpLFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB5W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh5MCArIHQgKiBkeSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gICAgdGhpcy5fYmFzaXMubGluZUVuZCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShiZXRhKSB7XG5cbiAgZnVuY3Rpb24gYnVuZGxlKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYmV0YSA9PT0gMSA/IG5ldyBCYXNpcyhjb250ZXh0KSA6IG5ldyBCdW5kbGUoY29udGV4dCwgYmV0YSk7XG4gIH1cblxuICBidW5kbGUuYmV0YSA9IGZ1bmN0aW9uKGJldGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCtiZXRhKTtcbiAgfTtcblxuICByZXR1cm4gYnVuZGxlO1xufSkoMC44NSk7XG4iLCJleHBvcnQgZnVuY3Rpb24gcG9pbnQodGhhdCwgeCwgeSkge1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgdGhhdC5feDEgKyB0aGF0Ll9rICogKHRoYXQuX3gyIC0gdGhhdC5feDApLFxuICAgIHRoYXQuX3kxICsgdGhhdC5fayAqICh0aGF0Ll95MiAtIHRoYXQuX3kwKSxcbiAgICB0aGF0Ll94MiArIHRoYXQuX2sgKiAodGhhdC5feDEgLSB4KSxcbiAgICB0aGF0Ll95MiArIHRoYXQuX2sgKiAodGhhdC5feTEgLSB5KSxcbiAgICB0aGF0Ll94MixcbiAgICB0aGF0Ll95MlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gxID0geCwgdGhpcy5feTEgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXJkaW5hbC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbENsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vY2FyZGluYWwuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcbiIsImltcG9ydCB7ZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7Q2FyZGluYWx9IGZyb20gXCIuL2NhcmRpbmFsLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHZhciB4MSA9IHRoYXQuX3gxLFxuICAgICAgeTEgPSB0aGF0Ll95MSxcbiAgICAgIHgyID0gdGhhdC5feDIsXG4gICAgICB5MiA9IHRoYXQuX3kyO1xuXG4gIGlmICh0aGF0Ll9sMDFfYSA+IGVwc2lsb24pIHtcbiAgICB2YXIgYSA9IDIgKiB0aGF0Ll9sMDFfMmEgKyAzICogdGhhdC5fbDAxX2EgKiB0aGF0Ll9sMTJfYSArIHRoYXQuX2wxMl8yYSxcbiAgICAgICAgbiA9IDMgKiB0aGF0Ll9sMDFfYSAqICh0aGF0Ll9sMDFfYSArIHRoYXQuX2wxMl9hKTtcbiAgICB4MSA9ICh4MSAqIGEgLSB0aGF0Ll94MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3gyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gICAgeTEgPSAoeTEgKiBhIC0gdGhhdC5feTAgKiB0aGF0Ll9sMTJfMmEgKyB0aGF0Ll95MiAqIHRoYXQuX2wwMV8yYSkgLyBuO1xuICB9XG5cbiAgaWYgKHRoYXQuX2wyM19hID4gZXBzaWxvbikge1xuICAgIHZhciBiID0gMiAqIHRoYXQuX2wyM18yYSArIDMgKiB0aGF0Ll9sMjNfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBtID0gMyAqIHRoYXQuX2wyM19hICogKHRoYXQuX2wyM19hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgyID0gKHgyICogYiArIHRoYXQuX3gxICogdGhhdC5fbDIzXzJhIC0geCAqIHRoYXQuX2wxMl8yYSkgLyBtO1xuICAgIHkyID0gKHkyICogYiArIHRoYXQuX3kxICogdGhhdC5fbDIzXzJhIC0geSAqIHRoYXQuX2wxMl8yYSkgLyBtO1xuICB9XG5cbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB0aGF0Ll94MiwgdGhhdC5feTIpO1xufVxuXG5mdW5jdGlvbiBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWwoY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuIiwiaW1wb3J0IHtDYXJkaW5hbENsb3NlZH0gZnJvbSBcIi4vY2FyZGluYWxDbG9zZWQuanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXRtdWxsUm9tLmpzXCI7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21DbG9zZWQoY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb21DbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuIiwiaW1wb3J0IHtDYXJkaW5hbE9wZW59IGZyb20gXCIuL2NhcmRpbmFsT3Blbi5qc1wiO1xuaW1wb3J0IHtwb2ludH0gZnJvbSBcIi4vY2F0bXVsbFJvbS5qc1wiO1xuXG5mdW5jdGlvbiBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbU9wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJmdW5jdGlvbiBMaW5lYXIoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcblxuZnVuY3Rpb24gTGluZWFyQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkxpbmVhckNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAodGhpcy5fcG9pbnQpIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGVsc2UgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhckNsb3NlZChjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIHNpZ24oeCkge1xuICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgc2xvcGVzIG9mIHRoZSB0YW5nZW50cyAoSGVybWl0ZS10eXBlIGludGVycG9sYXRpb24pIGJhc2VkIG9uXG4vLyB0aGUgZm9sbG93aW5nIHBhcGVyOiBTdGVmZmVuLCBNLiAxOTkwLiBBIFNpbXBsZSBNZXRob2QgZm9yIE1vbm90b25pY1xuLy8gSW50ZXJwb2xhdGlvbiBpbiBPbmUgRGltZW5zaW9uLiBBc3Ryb25vbXkgYW5kIEFzdHJvcGh5c2ljcywgVm9sLiAyMzksIE5PLlxuLy8gTk9WKElJKSwgUC4gNDQzLCAxOTkwLlxuZnVuY3Rpb24gc2xvcGUzKHRoYXQsIHgyLCB5Mikge1xuICB2YXIgaDAgPSB0aGF0Ll94MSAtIHRoYXQuX3gwLFxuICAgICAgaDEgPSB4MiAtIHRoYXQuX3gxLFxuICAgICAgczAgPSAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyAoaDAgfHwgaDEgPCAwICYmIC0wKSxcbiAgICAgIHMxID0gKHkyIC0gdGhhdC5feTEpIC8gKGgxIHx8IGgwIDwgMCAmJiAtMCksXG4gICAgICBwID0gKHMwICogaDEgKyBzMSAqIGgwKSAvIChoMCArIGgxKTtcbiAgcmV0dXJuIChzaWduKHMwKSArIHNpZ24oczEpKSAqIE1hdGgubWluKE1hdGguYWJzKHMwKSwgTWF0aC5hYnMoczEpLCAwLjUgKiBNYXRoLmFicyhwKSkgfHwgMDtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgb25lLXNpZGVkIHNsb3BlLlxuZnVuY3Rpb24gc2xvcGUyKHRoYXQsIHQpIHtcbiAgdmFyIGggPSB0aGF0Ll94MSAtIHRoYXQuX3gwO1xuICByZXR1cm4gaCA/ICgzICogKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gaCAtIHQpIC8gMiA6IHQ7XG59XG5cbi8vIEFjY29yZGluZyB0byBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19IZXJtaXRlX3NwbGluZSNSZXByZXNlbnRhdGlvbnNcbi8vIFwieW91IGNhbiBleHByZXNzIGN1YmljIEhlcm1pdGUgaW50ZXJwb2xhdGlvbiBpbiB0ZXJtcyBvZiBjdWJpYyBCw6l6aWVyIGN1cnZlc1xuLy8gd2l0aCByZXNwZWN0IHRvIHRoZSBmb3VyIHZhbHVlcyBwMCwgcDAgKyBtMCAvIDMsIHAxIC0gbTEgLyAzLCBwMVwiLlxuZnVuY3Rpb24gcG9pbnQodGhhdCwgdDAsIHQxKSB7XG4gIHZhciB4MCA9IHRoYXQuX3gwLFxuICAgICAgeTAgPSB0aGF0Ll95MCxcbiAgICAgIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgZHggPSAoeDEgLSB4MCkgLyAzO1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDAgKyBkeCwgeTAgKyBkeCAqIHQwLCB4MSAtIGR4LCB5MSAtIGR4ICogdDEsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5Nb25vdG9uZVgucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPVxuICAgIHRoaXMuX3QwID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5fdDAsIHNsb3BlMih0aGlzLCB0aGlzLl90MCkpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgdDEgPSBOYU47XG5cbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAoeCA9PT0gdGhpcy5feDEgJiYgeSA9PT0gdGhpcy5feTEpIHJldHVybjsgLy8gSWdub3JlIGNvaW5jaWRlbnQgcG9pbnRzLlxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgcG9pbnQodGhpcywgc2xvcGUyKHRoaXMsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKSwgdDEpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHRoaXMuX3QwLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gICAgdGhpcy5fdDAgPSB0MTtcbiAgfVxufVxuXG5mdW5jdGlvbiBNb25vdG9uZVkoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gbmV3IFJlZmxlY3RDb250ZXh0KGNvbnRleHQpO1xufVxuXG4oTW9ub3RvbmVZLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9ub3RvbmVYLnByb3RvdHlwZSkpLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICBNb25vdG9uZVgucHJvdG90eXBlLnBvaW50LmNhbGwodGhpcywgeSwgeCk7XG59O1xuXG5mdW5jdGlvbiBSZWZsZWN0Q29udGV4dChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5SZWZsZWN0Q29udGV4dC5wcm90b3R5cGUgPSB7XG4gIG1vdmVUbzogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh5LCB4KTsgfSxcbiAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHsgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTsgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubGluZVRvKHksIHgpOyB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkgeyB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oeTEsIHgxLCB5MiwgeDIsIHksIHgpOyB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBNb25vdG9uZVgoY29udGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vdG9uZVkoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWShjb250ZXh0KTtcbn1cbiIsImZ1bmN0aW9uIE5hdHVyYWwoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTmF0dXJhbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgbiA9IHgubGVuZ3RoO1xuXG4gICAgaWYgKG4pIHtcbiAgICAgIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzBdLCB5WzBdKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHhbMF0sIHlbMF0pO1xuICAgICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeFsxXSwgeVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHggPSBjb250cm9sUG9pbnRzKHgpLFxuICAgICAgICAgICAgcHkgPSBjb250cm9sUG9pbnRzKHkpO1xuICAgICAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMTsgaTEgPCBuOyArK2kwLCArK2kxKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHB4WzBdW2kwXSwgcHlbMF1baTBdLCBweFsxXVtpMF0sIHB5WzFdW2kwXSwgeFtpMV0sIHlbaTFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIG4gPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG4vLyBTZWUgaHR0cHM6Ly93d3cucGFydGljbGVpbmNlbGwuY29tLzIwMTIvYmV6aWVyLXNwbGluZXMvIGZvciBkZXJpdmF0aW9uLlxuZnVuY3Rpb24gY29udHJvbFBvaW50cyh4KSB7XG4gIHZhciBpLFxuICAgICAgbiA9IHgubGVuZ3RoIC0gMSxcbiAgICAgIG0sXG4gICAgICBhID0gbmV3IEFycmF5KG4pLFxuICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkobik7XG4gIGFbMF0gPSAwLCBiWzBdID0gMiwgclswXSA9IHhbMF0gKyAyICogeFsxXTtcbiAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyArK2kpIGFbaV0gPSAxLCBiW2ldID0gNCwgcltpXSA9IDQgKiB4W2ldICsgMiAqIHhbaSArIDFdO1xuICBhW24gLSAxXSA9IDIsIGJbbiAtIDFdID0gNywgcltuIC0gMV0gPSA4ICogeFtuIC0gMV0gKyB4W25dO1xuICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSBtID0gYVtpXSAvIGJbaSAtIDFdLCBiW2ldIC09IG0sIHJbaV0gLT0gbSAqIHJbaSAtIDFdO1xuICBhW24gLSAxXSA9IHJbbiAtIDFdIC8gYltuIC0gMV07XG4gIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IC0taSkgYVtpXSA9IChyW2ldIC0gYVtpICsgMV0pIC8gYltpXTtcbiAgYltuIC0gMV0gPSAoeFtuXSArIGFbbiAtIDFdKSAvIDI7XG4gIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgKytpKSBiW2ldID0gMiAqIHhbaSArIDFdIC0gYVtpICsgMV07XG4gIHJldHVybiBbYSwgYl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBOYXR1cmFsKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gU3RlcChjb250ZXh0LCB0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl90ID0gdDtcbn1cblxuU3RlcC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoMCA8IHRoaXMuX3QgJiYgdGhpcy5fdCA8IDEgJiYgdGhpcy5fcG9pbnQgPT09IDIpIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBpZiAodGhpcy5fbGluZSA+PSAwKSB0aGlzLl90ID0gMSAtIHRoaXMuX3QsIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX3QgPD0gMCkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHkpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4MSA9IHRoaXMuX3ggKiAoMSAtIHRoaXMuX3QpICsgeCAqIHRoaXMuX3Q7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHRoaXMuX3kpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB5KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5feCA9IHgsIHRoaXMuX3kgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAwLjUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcEJlZm9yZShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBBZnRlcihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAxKTtcbn1cbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyLmpzXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbDtcblxuICB4ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAoeCA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WCA6IGNvbnN0YW50KHgpO1xuICB5ID0gdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IHkgOiAoeSA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WSA6IGNvbnN0YW50KHkpO1xuXG4gIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gKGRhdGEgPSBhcnJheShkYXRhKSkubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXI7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkgb3V0cHV0LnBvaW50KCt4KGQsIGksIGRhdGEpLCAreShkLCBpLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeDtcbiAgfTtcblxuICBsaW5lLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHk7XG4gIH07XG5cbiAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGxpbmUpIDogZGVmaW5lZDtcbiAgfTtcblxuICBsaW5lLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGxpbmUpIDogY3VydmU7XG4gIH07XG5cbiAgbGluZS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBsaW5lKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmU7XG59XG4iLCJleHBvcnQgdmFyIGFicyA9IE1hdGguYWJzO1xuZXhwb3J0IHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG5leHBvcnQgdmFyIGNvcyA9IE1hdGguY29zO1xuZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG5leHBvcnQgdmFyIGVwc2lsb24gPSAxZS0xMjtcbmV4cG9ydCB2YXIgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IHZhciBoYWxmUGkgPSBwaSAvIDI7XG5leHBvcnQgdmFyIHRhdSA9IDIgKiBwaTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPj0gMSA/IGhhbGZQaSA6IHggPD0gLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHgocCkge1xuICByZXR1cm4gcFswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkocCkge1xuICByZXR1cm4gcFsxXTtcbn1cbiIsImltcG9ydCB7cGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcbmltcG9ydCBjaXJjbGUgZnJvbSBcIi4vc3ltYm9sL2NpcmNsZS5qc1wiO1xuaW1wb3J0IGNyb3NzIGZyb20gXCIuL3N5bWJvbC9jcm9zcy5qc1wiO1xuaW1wb3J0IGRpYW1vbmQgZnJvbSBcIi4vc3ltYm9sL2RpYW1vbmQuanNcIjtcbmltcG9ydCBzdGFyIGZyb20gXCIuL3N5bWJvbC9zdGFyLmpzXCI7XG5pbXBvcnQgc3F1YXJlIGZyb20gXCIuL3N5bWJvbC9zcXVhcmUuanNcIjtcbmltcG9ydCB0cmlhbmdsZSBmcm9tIFwiLi9zeW1ib2wvdHJpYW5nbGUuanNcIjtcbmltcG9ydCB3eWUgZnJvbSBcIi4vc3ltYm9sL3d5ZS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCB2YXIgc3ltYm9scyA9IFtcbiAgY2lyY2xlLFxuICBjcm9zcyxcbiAgZGlhbW9uZCxcbiAgc3F1YXJlLFxuICBzdGFyLFxuICB0cmlhbmdsZSxcbiAgd3llXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gIHZhciBjb250ZXh0ID0gbnVsbDtcbiAgdHlwZSA9IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIgPyB0eXBlIDogY29uc3RhbnQodHlwZSB8fCBjaXJjbGUpO1xuICBzaXplID0gdHlwZW9mIHNpemUgPT09IFwiZnVuY3Rpb25cIiA/IHNpemUgOiBjb25zdGFudChzaXplID09PSB1bmRlZmluZWQgPyA2NCA6ICtzaXplKTtcblxuICBmdW5jdGlvbiBzeW1ib2woKSB7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG4gICAgdHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmRyYXcoY29udGV4dCwgK3NpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eXBlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc3ltYm9sKSA6IHR5cGU7XG4gIH07XG5cbiAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2l6ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzeW1ib2wpIDogc2l6ZTtcbiAgfTtcblxuICBzeW1ib2wuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8sIHN5bWJvbCkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBzeW1ib2w7XG59XG4iLCJpbXBvcnQge3BpLCB0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBwaSk7XG4gICAgY29udGV4dC5tb3ZlVG8ociwgMCk7XG4gICAgY29udGV4dC5hcmMoMCwgMCwgciwgMCwgdGF1KTtcbiAgfVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgY29udGV4dC5tb3ZlVG8oLTMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgcik7XG4gICAgY29udGV4dC5saW5lVG8oLTMgKiByLCByKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwidmFyIHRhbjMwID0gTWF0aC5zcXJ0KDEgLyAzKSxcbiAgICB0YW4zMF8yID0gdGFuMzAgKiAyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgeSA9IE1hdGguc3FydChzaXplIC8gdGFuMzBfMiksXG4gICAgICAgIHggPSB5ICogdGFuMzA7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIDApO1xuICAgIGNvbnRleHQubGluZVRvKDAsIHkpO1xuICAgIGNvbnRleHQubGluZVRvKC14LCAwKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHcgPSBNYXRoLnNxcnQoc2l6ZSksXG4gICAgICAgIHggPSAtdyAvIDI7XG4gICAgY29udGV4dC5yZWN0KHgsIHgsIHcsIHcpO1xuICB9XG59O1xuIiwiaW1wb3J0IHtwaSwgdGF1fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG52YXIga2EgPSAwLjg5MDgxMzA5MTUyOTI4NTIyODEwLFxuICAgIGtyID0gTWF0aC5zaW4ocGkgLyAxMCkgLyBNYXRoLnNpbig3ICogcGkgLyAxMCksXG4gICAga3ggPSBNYXRoLnNpbih0YXUgLyAxMCkgKiBrcixcbiAgICBreSA9IC1NYXRoLmNvcyh0YXUgLyAxMCkgKiBrcjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAqIGthKSxcbiAgICAgICAgeCA9IGt4ICogcixcbiAgICAgICAgeSA9IGt5ICogcjtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCA1OyArK2kpIHtcbiAgICAgIHZhciBhID0gdGF1ICogaSAvIDUsXG4gICAgICAgICAgYyA9IE1hdGguY29zKGEpLFxuICAgICAgICAgIHMgPSBNYXRoLnNpbihhKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMgKiByLCAtYyAqIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8oYyAqIHggLSBzICogeSwgcyAqIHggKyBjICogeSk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJ2YXIgc3FydDMgPSBNYXRoLnNxcnQoMyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gLU1hdGguc3FydChzaXplIC8gKHNxcnQzICogMykpO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHkgKiAyKTtcbiAgICBjb250ZXh0LmxpbmVUbygtc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsInZhciBjID0gLTAuNSxcbiAgICBzID0gTWF0aC5zcXJ0KDMpIC8gMixcbiAgICBrID0gMSAvIE1hdGguc3FydCgxMiksXG4gICAgYSA9IChrIC8gMiArIDEpICogMztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIGEpLFxuICAgICAgICB4MCA9IHIgLyAyLFxuICAgICAgICB5MCA9IHIgKiBrLFxuICAgICAgICB4MSA9IHgwLFxuICAgICAgICB5MSA9IHIgKiBrICsgcixcbiAgICAgICAgeDIgPSAteDEsXG4gICAgICAgIHkyID0geTE7XG4gICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwIC0gcyAqIHkwLCBzICogeDAgKyBjICogeTApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSAtIHMgKiB5MSwgcyAqIHgxICsgYyAqIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgLSBzICogeTIsIHMgKiB4MiArIGMgKiB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwICsgcyAqIHkwLCBjICogeTAgLSBzICogeDApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSArIHMgKiB5MSwgYyAqIHkxIC0gcyAqIHgxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgKyBzICogeTIsIGMgKiB5MiAtIHMgKiB4Mik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsImltcG9ydCBmb3JtYXRMb2NhbGUgZnJvbSBcIi4vbG9jYWxlLmpzXCI7XG5cbnZhciBsb2NhbGU7XG5leHBvcnQgdmFyIHRpbWVGb3JtYXQ7XG5leHBvcnQgdmFyIHRpbWVQYXJzZTtcbmV4cG9ydCB2YXIgdXRjRm9ybWF0O1xuZXhwb3J0IHZhciB1dGNQYXJzZTtcblxuZGVmYXVsdExvY2FsZSh7XG4gIGRhdGVUaW1lOiBcIiV4LCAlWFwiLFxuICBkYXRlOiBcIiUtbS8lLWQvJVlcIixcbiAgdGltZTogXCIlLUk6JU06JVMgJXBcIixcbiAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgdGltZUZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIHRpbWVQYXJzZSA9IGxvY2FsZS5wYXJzZTtcbiAgdXRjRm9ybWF0ID0gbG9jYWxlLnV0Y0Zvcm1hdDtcbiAgdXRjUGFyc2UgPSBsb2NhbGUudXRjUGFyc2U7XG4gIHJldHVybiBsb2NhbGU7XG59XG4iLCJpbXBvcnQge1xuICB0aW1lRGF5LFxuICB0aW1lU3VuZGF5LFxuICB0aW1lTW9uZGF5LFxuICB0aW1lVGh1cnNkYXksXG4gIHRpbWVZZWFyLFxuICB1dGNEYXksXG4gIHV0Y1N1bmRheSxcbiAgdXRjTW9uZGF5LFxuICB1dGNUaHVyc2RheSxcbiAgdXRjWWVhclxufSBmcm9tIFwiZDMtdGltZVwiO1xuXG5mdW5jdGlvbiBsb2NhbERhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkLnkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZShkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xufVxuXG5mdW5jdGlvbiB1dGNEYXRlKGQpIHtcbiAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xufVxuXG5mdW5jdGlvbiBuZXdEYXRlKHksIG0sIGQpIHtcbiAgcmV0dXJuIHt5OiB5LCBtOiBtLCBkOiBkLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0TG9jYWxlKGxvY2FsZSkge1xuICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLFxuICAgICAgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSxcbiAgICAgIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsXG4gICAgICBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLFxuICAgICAgbG9jYWxlX3dlZWtkYXlzID0gbG9jYWxlLmRheXMsXG4gICAgICBsb2NhbGVfc2hvcnRXZWVrZGF5cyA9IGxvY2FsZS5zaG9ydERheXMsXG4gICAgICBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocyxcbiAgICAgIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcblxuICB2YXIgcGVyaW9kUmUgPSBmb3JtYXRSZShsb2NhbGVfcGVyaW9kcyksXG4gICAgICBwZXJpb2RMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3BlcmlvZHMpLFxuICAgICAgd2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHNob3J0V2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgIG1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfbW9udGhzKSxcbiAgICAgIG1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLFxuICAgICAgc2hvcnRNb250aFJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSxcbiAgICAgIHNob3J0TW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcblxuICB2YXIgZm9ybWF0cyA9IHtcbiAgICBcImFcIjogZm9ybWF0U2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxuICAgIFwiYlwiOiBmb3JtYXRTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBmb3JtYXRNb250aCxcbiAgICBcImNcIjogbnVsbCxcbiAgICBcImRcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcImVcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcImZcIjogZm9ybWF0TWljcm9zZWNvbmRzLFxuICAgIFwiZ1wiOiBmb3JtYXRZZWFySVNPLFxuICAgIFwiR1wiOiBmb3JtYXRGdWxsWWVhcklTTyxcbiAgICBcIkhcIjogZm9ybWF0SG91cjI0LFxuICAgIFwiSVwiOiBmb3JtYXRIb3VyMTIsXG4gICAgXCJqXCI6IGZvcm1hdERheU9mWWVhcixcbiAgICBcIkxcIjogZm9ybWF0TWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBmb3JtYXRNb250aE51bWJlcixcbiAgICBcIk1cIjogZm9ybWF0TWludXRlcyxcbiAgICBcInBcIjogZm9ybWF0UGVyaW9kLFxuICAgIFwicVwiOiBmb3JtYXRRdWFydGVyLFxuICAgIFwiUVwiOiBmb3JtYXRVbml4VGltZXN0YW1wLFxuICAgIFwic1wiOiBmb3JtYXRVbml4VGltZXN0YW1wU2Vjb25kcyxcbiAgICBcIlNcIjogZm9ybWF0U2Vjb25kcyxcbiAgICBcInVcIjogZm9ybWF0V2Vla2RheU51bWJlck1vbmRheSxcbiAgICBcIlVcIjogZm9ybWF0V2Vla051bWJlclN1bmRheSxcbiAgICBcIlZcIjogZm9ybWF0V2Vla051bWJlcklTTyxcbiAgICBcIndcIjogZm9ybWF0V2Vla2RheU51bWJlclN1bmRheSxcbiAgICBcIldcIjogZm9ybWF0V2Vla051bWJlck1vbmRheSxcbiAgICBcInhcIjogbnVsbCxcbiAgICBcIlhcIjogbnVsbCxcbiAgICBcInlcIjogZm9ybWF0WWVhcixcbiAgICBcIllcIjogZm9ybWF0RnVsbFllYXIsXG4gICAgXCJaXCI6IGZvcm1hdFpvbmUsXG4gICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gIH07XG5cbiAgdmFyIHV0Y0Zvcm1hdHMgPSB7XG4gICAgXCJhXCI6IGZvcm1hdFVUQ1Nob3J0V2Vla2RheSxcbiAgICBcIkFcIjogZm9ybWF0VVRDV2Vla2RheSxcbiAgICBcImJcIjogZm9ybWF0VVRDU2hvcnRNb250aCxcbiAgICBcIkJcIjogZm9ybWF0VVRDTW9udGgsXG4gICAgXCJjXCI6IG51bGwsXG4gICAgXCJkXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgXCJlXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgXCJmXCI6IGZvcm1hdFVUQ01pY3Jvc2Vjb25kcyxcbiAgICBcImdcIjogZm9ybWF0VVRDWWVhcklTTyxcbiAgICBcIkdcIjogZm9ybWF0VVRDRnVsbFllYXJJU08sXG4gICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0VVRDSG91cjEyLFxuICAgIFwialwiOiBmb3JtYXRVVENEYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0VVRDTW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdFVUQ01pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICBcInFcIjogZm9ybWF0VVRDUXVhcnRlcixcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciBwYXJzZXMgPSB7XG4gICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJmXCI6IHBhcnNlTWljcm9zZWNvbmRzLFxuICAgIFwiZ1wiOiBwYXJzZVllYXIsXG4gICAgXCJHXCI6IHBhcnNlRnVsbFllYXIsXG4gICAgXCJIXCI6IHBhcnNlSG91cjI0LFxuICAgIFwiSVwiOiBwYXJzZUhvdXIyNCxcbiAgICBcImpcIjogcGFyc2VEYXlPZlllYXIsXG4gICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBwYXJzZU1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBwYXJzZU1pbnV0ZXMsXG4gICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxuICAgIFwicVwiOiBwYXJzZVF1YXJ0ZXIsXG4gICAgXCJRXCI6IHBhcnNlVW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogcGFyc2VVbml4VGltZXN0YW1wU2Vjb25kcyxcbiAgICBcIlNcIjogcGFyc2VTZWNvbmRzLFxuICAgIFwidVwiOiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IHBhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICBcIlZcIjogcGFyc2VXZWVrTnVtYmVySVNPLFxuICAgIFwid1wiOiBwYXJzZVdlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IHBhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICBcInhcIjogcGFyc2VMb2NhbGVEYXRlLFxuICAgIFwiWFwiOiBwYXJzZUxvY2FsZVRpbWUsXG4gICAgXCJ5XCI6IHBhcnNlWWVhcixcbiAgICBcIllcIjogcGFyc2VGdWxsWWVhcixcbiAgICBcIlpcIjogcGFyc2Vab25lLFxuICAgIFwiJVwiOiBwYXJzZUxpdGVyYWxQZXJjZW50XG4gIH07XG5cbiAgLy8gVGhlc2UgcmVjdXJzaXZlIGRpcmVjdGl2ZSBkZWZpbml0aW9ucyBtdXN0IGJlIGRlZmVycmVkLlxuICBmb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIGZvcm1hdHMpO1xuICBmb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIGZvcm1hdHMpO1xuICBmb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCBmb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCB1dGNGb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCB1dGNGb3JtYXRzKTtcbiAgdXRjRm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgdXRjRm9ybWF0cyk7XG5cbiAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllciwgZm9ybWF0cykge1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgc3RyaW5nID0gW10sXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgcGFkLFxuICAgICAgICAgIGZvcm1hdDtcblxuICAgICAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSBkYXRlID0gbmV3IERhdGUoK2RhdGUpO1xuXG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICBpZiAoKHBhZCA9IHBhZHNbYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKV0pICE9IG51bGwpIGMgPSBzcGVjaWZpZXIuY2hhckF0KCsraSk7XG4gICAgICAgICAgZWxzZSBwYWQgPSBjID09PSBcImVcIiA/IFwiIFwiIDogXCIwXCI7XG4gICAgICAgICAgaWYgKGZvcm1hdCA9IGZvcm1hdHNbY10pIGMgPSBmb3JtYXQoZGF0ZSwgcGFkKTtcbiAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgIHJldHVybiBzdHJpbmcuam9pbihcIlwiKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3UGFyc2Uoc3BlY2lmaWVyLCBaKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIGQgPSBuZXdEYXRlKDE5MDAsIHVuZGVmaW5lZCwgMSksXG4gICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nICs9IFwiXCIsIDApLFxuICAgICAgICAgIHdlZWssIGRheTtcbiAgICAgIGlmIChpICE9IHN0cmluZy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBJZiBhIFVOSVggdGltZXN0YW1wIGlzIHNwZWNpZmllZCwgcmV0dXJuIGl0LlxuICAgICAgaWYgKFwiUVwiIGluIGQpIHJldHVybiBuZXcgRGF0ZShkLlEpO1xuICAgICAgaWYgKFwic1wiIGluIGQpIHJldHVybiBuZXcgRGF0ZShkLnMgKiAxMDAwICsgKFwiTFwiIGluIGQgPyBkLkwgOiAwKSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdXRjUGFyc2UsIG5ldmVyIHVzZSB0aGUgbG9jYWwgdGltZXpvbmUuXG4gICAgICBpZiAoWiAmJiAhKFwiWlwiIGluIGQpKSBkLlogPSAwO1xuXG4gICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG5cbiAgICAgIC8vIElmIHRoZSBtb250aCB3YXMgbm90IHNwZWNpZmllZCwgaW5oZXJpdCBmcm9tIHRoZSBxdWFydGVyLlxuICAgICAgaWYgKGQubSA9PT0gdW5kZWZpbmVkKSBkLm0gPSBcInFcIiBpbiBkID8gZC5xIDogMDtcblxuICAgICAgLy8gQ29udmVydCBkYXktb2Ytd2VlayBhbmQgd2Vlay1vZi15ZWFyIHRvIGRheS1vZi15ZWFyLlxuICAgICAgaWYgKFwiVlwiIGluIGQpIHtcbiAgICAgICAgaWYgKGQuViA8IDEgfHwgZC5WID4gNTMpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gMTtcbiAgICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgICB3ZWVrID0gdXRjRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLCBkYXkgPSB3ZWVrLmdldFVUQ0RheSgpO1xuICAgICAgICAgIHdlZWsgPSBkYXkgPiA0IHx8IGRheSA9PT0gMCA/IHV0Y01vbmRheS5jZWlsKHdlZWspIDogdXRjTW9uZGF5KHdlZWspO1xuICAgICAgICAgIHdlZWsgPSB1dGNEYXkub2Zmc2V0KHdlZWssIChkLlYgLSAxKSAqIDcpO1xuICAgICAgICAgIGQueSA9IHdlZWsuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICBkLm0gPSB3ZWVrLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgZC5kID0gd2Vlay5nZXRVVENEYXRlKCkgKyAoZC53ICsgNikgJSA3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdlZWsgPSBsb2NhbERhdGUobmV3RGF0ZShkLnksIDAsIDEpKSwgZGF5ID0gd2Vlay5nZXREYXkoKTtcbiAgICAgICAgICB3ZWVrID0gZGF5ID4gNCB8fCBkYXkgPT09IDAgPyB0aW1lTW9uZGF5LmNlaWwod2VlaykgOiB0aW1lTW9uZGF5KHdlZWspO1xuICAgICAgICAgIHdlZWsgPSB0aW1lRGF5Lm9mZnNldCh3ZWVrLCAoZC5WIC0gMSkgKiA3KTtcbiAgICAgICAgICBkLnkgPSB3ZWVrLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgZC5tID0gd2Vlay5nZXRNb250aCgpO1xuICAgICAgICAgIGQuZCA9IHdlZWsuZ2V0RGF0ZSgpICsgKGQudyArIDYpICUgNztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpIHtcbiAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IFwidVwiIGluIGQgPyBkLnUgJSA3IDogXCJXXCIgaW4gZCA/IDEgOiAwO1xuICAgICAgICBkYXkgPSBcIlpcIiBpbiBkID8gdXRjRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLmdldFVUQ0RheSgpIDogbG9jYWxEYXRlKG5ld0RhdGUoZC55LCAwLCAxKSkuZ2V0RGF5KCk7XG4gICAgICAgIGQubSA9IDA7XG4gICAgICAgIGQuZCA9IFwiV1wiIGluIGQgPyAoZC53ICsgNikgJSA3ICsgZC5XICogNyAtIChkYXkgKyA1KSAlIDcgOiBkLncgKyBkLlUgKiA3IC0gKGRheSArIDYpICUgNztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkLCBhbGwgZmllbGRzIGFyZSBpbnRlcnByZXRlZCBhcyBVVEMgYW5kIHRoZW5cbiAgICAgIC8vIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0aW1lIHpvbmUuXG4gICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICBkLkggKz0gZC5aIC8gMTAwIHwgMDtcbiAgICAgICAgZC5NICs9IGQuWiAlIDEwMDtcbiAgICAgICAgcmV0dXJuIHV0Y0RhdGUoZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgYWxsIGZpZWxkcyBhcmUgaW4gbG9jYWwgdGltZS5cbiAgICAgIHJldHVybiBsb2NhbERhdGUoZCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nLCBqKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgbSA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgIGMsXG4gICAgICAgIHBhcnNlO1xuXG4gICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICBjID0gc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIGlmIChjID09PSAzNykge1xuICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJBdChpKyspO1xuICAgICAgICBwYXJzZSA9IHBhcnNlc1tjIGluIHBhZHMgPyBzcGVjaWZpZXIuY2hhckF0KGkrKykgOiBjXTtcbiAgICAgICAgaWYgKCFwYXJzZSB8fCAoKGogPSBwYXJzZShkLCBzdHJpbmcsIGopKSA8IDApKSByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGo7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBlcmlvZChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHBlcmlvZFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLnAgPSBwZXJpb2RMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gd2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNob3J0TW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBzaG9ydE1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQubSA9IHNob3J0TW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGVUaW1lLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX3RpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXREYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRRdWFydGVyKGQpIHtcbiAgICByZXR1cm4gMSArIH5+KGQuZ2V0TW9udGgoKSAvIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENQZXJpb2QoZCkge1xuICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0VVRDSG91cnMoKSA+PSAxMildO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDUXVhcnRlcihkKSB7XG4gICAgcmV0dXJuIDEgKyB+fihkLmdldFVUQ01vbnRoKCkgLyAzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCBmb3JtYXRzKTtcbiAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIHAgPSBuZXdQYXJzZShzcGVjaWZpZXIgKz0gXCJcIiwgZmFsc2UpO1xuICAgICAgcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICB1dGNGb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIHV0Y0Zvcm1hdHMpO1xuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgICB1dGNQYXJzZTogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgcCA9IG5ld1BhcnNlKHNwZWNpZmllciArPSBcIlwiLCB0cnVlKTtcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifSxcbiAgICBudW1iZXJSZSA9IC9eXFxzKlxcZCsvLCAvLyBub3RlOiBpZ25vcmVzIG5leHQgZGlyZWN0aXZlXG4gICAgcGVyY2VudFJlID0gL14lLyxcbiAgICByZXF1b3RlUmUgPSAvW1xcXFxeJCorP3xbXFxdKCkue31dL2c7XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsXG4gICAgICBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xufVxuXG5mdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShyZXF1b3RlUmUsIFwiXFxcXCQmXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChyZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICByZXR1cm4gbmV3IE1hcChuYW1lcy5tYXAoKG5hbWUsIGkpID0+IFtuYW1lLnRvTG93ZXJDYXNlKCksIGldKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyAoZC51ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlcklTTyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlYgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gL14oWil8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/Ly5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLlogPSBuWzFdID8gMCA6IC0oblsyXSArIChuWzNdIHx8IFwiMDBcIikpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVhcnRlcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLnEgPSBuWzBdICogMyAtIDMsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZlllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gMCwgZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICByZXR1cm4gbiA/IChkLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pY3Jvc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLkwgPSBNYXRoLmZsb29yKG5bMF0gLyAxMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpdGVyYWxQZXJjZW50KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IHBlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVuaXhUaW1lc3RhbXAoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICByZXR1cm4gbiA/IChkLlEgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5zID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXREYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyB0aW1lRGF5LmNvdW50KHRpbWVZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pY3Jvc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkgKyBcIjAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyTW9uZGF5KGQpIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIHJldHVybiBkYXkgPT09IDAgPyA3IDogZGF5O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZCh0aW1lU3VuZGF5LmNvdW50KHRpbWVZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBkSVNPKGQpIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIHJldHVybiAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IHRpbWVUaHVyc2RheShkKSA6IHRpbWVUaHVyc2RheS5jZWlsKGQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVySVNPKGQsIHApIHtcbiAgZCA9IGRJU08oZCk7XG4gIHJldHVybiBwYWQodGltZVRodXJzZGF5LmNvdW50KHRpbWVZZWFyKGQpLCBkKSArICh0aW1lWWVhcihkKS5nZXREYXkoKSA9PT0gNCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcbiAgcmV0dXJuIGQuZ2V0RGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKHRpbWVNb25kYXkuY291bnQodGltZVllYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXJJU08oZCwgcCkge1xuICBkID0gZElTTyhkKTtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRGdWxsWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRGdWxsWWVhcklTTyhkLCBwKSB7XG4gIHZhciBkYXkgPSBkLmdldERheSgpO1xuICBkID0gKGRheSA+PSA0IHx8IGRheSA9PT0gMCkgPyB0aW1lVGh1cnNkYXkoZCkgOiB0aW1lVGh1cnNkYXkuY2VpbChkKTtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICB2YXIgeiA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgcmV0dXJuICh6ID4gMCA/IFwiLVwiIDogKHogKj0gLTEsIFwiK1wiKSlcbiAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgKyBwYWQoeiAlIDYwLCBcIjBcIiwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRGF0ZSgpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZCgxICsgdXRjRGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWljcm9zZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ1NlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xuICB2YXIgZG93ID0gZC5nZXRVVENEYXkoKTtcbiAgcmV0dXJuIGRvdyA9PT0gMCA/IDcgOiBkb3c7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKHV0Y1N1bmRheS5jb3VudCh1dGNZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBVVENkSVNPKGQpIHtcbiAgdmFyIGRheSA9IGQuZ2V0VVRDRGF5KCk7XG4gIHJldHVybiAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IHV0Y1RodXJzZGF5KGQpIDogdXRjVGh1cnNkYXkuY2VpbChkKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlcklTTyhkLCBwKSB7XG4gIGQgPSBVVENkSVNPKGQpO1xuICByZXR1cm4gcGFkKHV0Y1RodXJzZGF5LmNvdW50KHV0Y1llYXIoZCksIGQpICsgKHV0Y1llYXIoZCkuZ2V0VVRDRGF5KCkgPT09IDQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlclN1bmRheShkKSB7XG4gIHJldHVybiBkLmdldFVUQ0RheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZCh1dGNNb25kYXkuY291bnQodXRjWWVhcihkKSAtIDEsIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWWVhcklTTyhkLCBwKSB7XG4gIGQgPSBVVENkSVNPKGQpO1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFySVNPKGQsIHApIHtcbiAgdmFyIGRheSA9IGQuZ2V0VVRDRGF5KCk7XG4gIGQgPSAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IHV0Y1RodXJzZGF5KGQpIDogdXRjVGh1cnNkYXkuY2VpbChkKTtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1pvbmUoKSB7XG4gIHJldHVybiBcIiswMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExpdGVyYWxQZXJjZW50KCkge1xuICByZXR1cm4gXCIlXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuaXhUaW1lc3RhbXAoZCkge1xuICByZXR1cm4gK2Q7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzKGQpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoK2QgLyAxMDAwKTtcbn1cbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbkRheSwgZHVyYXRpb25NaW51dGV9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciBkYXkgPSBpbnRlcnZhbChcbiAgZGF0ZSA9PiBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApLFxuICAoZGF0ZSwgc3RlcCkgPT4gZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCksXG4gIChzdGFydCwgZW5kKSA9PiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uRGF5LFxuICBkYXRlID0+IGRhdGUuZ2V0RGF0ZSgpIC0gMVxuKTtcblxuZXhwb3J0IGRlZmF1bHQgZGF5O1xuZXhwb3J0IHZhciBkYXlzID0gZGF5LnJhbmdlO1xuIiwiZXhwb3J0IGNvbnN0IGR1cmF0aW9uU2Vjb25kID0gMTAwMDtcbmV4cG9ydCBjb25zdCBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjA7XG5leHBvcnQgY29uc3QgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MDtcbmV4cG9ydCBjb25zdCBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0O1xuZXhwb3J0IGNvbnN0IGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNztcbmV4cG9ydCBjb25zdCBkdXJhdGlvbk1vbnRoID0gZHVyYXRpb25EYXkgKiAzMDtcbmV4cG9ydCBjb25zdCBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbkhvdXIsIGR1cmF0aW9uTWludXRlLCBkdXJhdGlvblNlY29uZH0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIGhvdXIgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShkYXRlIC0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAtIGRhdGUuZ2V0U2Vjb25kcygpICogZHVyYXRpb25TZWNvbmQgLSBkYXRlLmdldE1pbnV0ZXMoKSAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRIb3VycygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGhvdXI7XG5leHBvcnQgdmFyIGhvdXJzID0gaG91ci5yYW5nZTtcbiIsInZhciB0MCA9IG5ldyBEYXRlLFxuICAgIHQxID0gbmV3IERhdGU7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQsIGZpZWxkKSB7XG5cbiAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyBuZXcgRGF0ZSA6IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gIH1cblxuICBpbnRlcnZhbC5mbG9vciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLmNlaWwgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZmxvb3JpKGRhdGUpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkMCA9IGludGVydmFsKGRhdGUpLFxuICAgICAgICBkMSA9IGludGVydmFsLmNlaWwoZGF0ZSk7XG4gICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gIH07XG5cbiAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgdmFyIHJhbmdlID0gW10sIHByZXZpb3VzO1xuICAgIHN0YXJ0ID0gaW50ZXJ2YWwuY2VpbChzdGFydCk7XG4gICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgIGlmICghKHN0YXJ0IDwgc3RvcCkgfHwgIShzdGVwID4gMCkpIHJldHVybiByYW5nZTsgLy8gYWxzbyBoYW5kbGVzIEludmFsaWQgRGF0ZVxuICAgIGRvIHJhbmdlLnB1c2gocHJldmlvdXMgPSBuZXcgRGF0ZSgrc3RhcnQpKSwgb2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCk7XG4gICAgd2hpbGUgKHByZXZpb3VzIDwgc3RhcnQgJiYgc3RhcnQgPCBzdG9wKTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB7XG4gICAgICAgIGlmIChzdGVwIDwgMCkgd2hpbGUgKCsrc3RlcCA8PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgLTEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGVsc2Ugd2hpbGUgKC0tc3RlcCA+PSAwKSB7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldGkoZGF0ZSwgKzEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGNvdW50KSB7XG4gICAgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIGludGVydmFsLmV2ZXJ5ID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICByZXR1cm4gIWlzRmluaXRlKHN0ZXApIHx8ICEoc3RlcCA+IDApID8gbnVsbFxuICAgICAgICAgIDogIShzdGVwID4gMSkgPyBpbnRlcnZhbFxuICAgICAgICAgIDogaW50ZXJ2YWwuZmlsdGVyKGZpZWxkXG4gICAgICAgICAgICAgID8gZnVuY3Rpb24oZCkgeyByZXR1cm4gZmllbGQoZCkgJSBzdGVwID09PSAwOyB9XG4gICAgICAgICAgICAgIDogZnVuY3Rpb24oZCkgeyByZXR1cm4gaW50ZXJ2YWwuY291bnQoMCwgZCkgJSBzdGVwID09PSAwOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGludGVydmFsO1xufVxuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5cbnZhciBtaWxsaXNlY29uZCA9IGludGVydmFsKGZ1bmN0aW9uKCkge1xuICAvLyBub29wXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxubWlsbGlzZWNvbmQuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIGsgPSBNYXRoLmZsb29yKGspO1xuICBpZiAoIWlzRmluaXRlKGspIHx8ICEoayA+IDApKSByZXR1cm4gbnVsbDtcbiAgaWYgKCEoayA+IDEpKSByZXR1cm4gbWlsbGlzZWNvbmQ7XG4gIHJldHVybiBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoZGF0ZSAvIGspICogayk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogayk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGs7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWlsbGlzZWNvbmQ7XG5leHBvcnQgdmFyIG1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uTWludXRlLCBkdXJhdGlvblNlY29uZH0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIG1pbnV0ZSA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKGRhdGUgLSBkYXRlLmdldE1pbGxpc2Vjb25kcygpIC0gZGF0ZS5nZXRTZWNvbmRzKCkgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtaW51dGU7XG5leHBvcnQgdmFyIG1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcblxudmFyIG1vbnRoID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldERhdGUoMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0TW9udGgoKSAtIHN0YXJ0LmdldE1vbnRoKCkgKyAoZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpKSAqIDEyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1vbnRoO1xuZXhwb3J0IHZhciBtb250aHMgPSBtb250aC5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvblNlY29uZH0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIHNlY29uZCA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKGRhdGUgLSBkYXRlLmdldE1pbGxpc2Vjb25kcygpKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uU2Vjb25kKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvblNlY29uZDtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNlY29uZDtcbmV4cG9ydCB2YXIgc2Vjb25kcyA9IHNlY29uZC5yYW5nZTtcbiIsImltcG9ydCB7YmlzZWN0b3IsIHRpY2tTdGVwfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7ZHVyYXRpb25EYXksIGR1cmF0aW9uSG91ciwgZHVyYXRpb25NaW51dGUsIGR1cmF0aW9uTW9udGgsIGR1cmF0aW9uU2Vjb25kLCBkdXJhdGlvbldlZWssIGR1cmF0aW9uWWVhcn0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBtaWxsaXNlY29uZCBmcm9tIFwiLi9taWxsaXNlY29uZC5qc1wiO1xuaW1wb3J0IHNlY29uZCBmcm9tIFwiLi9zZWNvbmQuanNcIjtcbmltcG9ydCBtaW51dGUgZnJvbSBcIi4vbWludXRlLmpzXCI7XG5pbXBvcnQgaG91ciBmcm9tIFwiLi9ob3VyLmpzXCI7XG5pbXBvcnQgZGF5IGZyb20gXCIuL2RheS5qc1wiO1xuaW1wb3J0IHtzdW5kYXkgYXMgd2Vla30gZnJvbSBcIi4vd2Vlay5qc1wiO1xuaW1wb3J0IG1vbnRoIGZyb20gXCIuL21vbnRoLmpzXCI7XG5pbXBvcnQgeWVhciBmcm9tIFwiLi95ZWFyLmpzXCI7XG5pbXBvcnQgdXRjTWludXRlIGZyb20gXCIuL3V0Y01pbnV0ZS5qc1wiO1xuaW1wb3J0IHV0Y0hvdXIgZnJvbSBcIi4vdXRjSG91ci5qc1wiO1xuaW1wb3J0IHV0Y0RheSBmcm9tIFwiLi91dGNEYXkuanNcIjtcbmltcG9ydCB7dXRjU3VuZGF5IGFzIHV0Y1dlZWt9IGZyb20gXCIuL3V0Y1dlZWsuanNcIjtcbmltcG9ydCB1dGNNb250aCBmcm9tIFwiLi91dGNNb250aC5qc1wiO1xuaW1wb3J0IHV0Y1llYXIgZnJvbSBcIi4vdXRjWWVhci5qc1wiO1xuXG5mdW5jdGlvbiB0aWNrZXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlKSB7XG5cbiAgY29uc3QgdGlja0ludGVydmFscyA9IFtcbiAgICBbc2Vjb25kLCAgMSwgICAgICBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgIDUsICA1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDE1LCAxNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW21pbnV0ZSwgIDEsICAgICAgZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsICA1LCAgNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLFxuICAgIFsgIGhvdXIsICAxLCAgICAgIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgIDYsICA2ICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsIDEyLCAxMiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICAgZGF5LCAgMSwgICAgICBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgIGRheSwgIDIsICAyICogZHVyYXRpb25EYXkgICBdLFxuICAgIFsgIHdlZWssICAxLCAgICAgIGR1cmF0aW9uV2VlayAgXSxcbiAgICBbIG1vbnRoLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyBtb250aCwgIDMsICAzICogZHVyYXRpb25Nb250aCBdLFxuICAgIFsgIHllYXIsICAxLCAgICAgIGR1cmF0aW9uWWVhciAgXVxuICBdO1xuXG4gIGZ1bmN0aW9uIHRpY2tzKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICAgIGNvbnN0IHJldmVyc2UgPSBzdG9wIDwgc3RhcnQ7XG4gICAgaWYgKHJldmVyc2UpIFtzdGFydCwgc3RvcF0gPSBbc3RvcCwgc3RhcnRdO1xuICAgIGNvbnN0IGludGVydmFsID0gY291bnQgJiYgdHlwZW9mIGNvdW50LnJhbmdlID09PSBcImZ1bmN0aW9uXCIgPyBjb3VudCA6IHRpY2tJbnRlcnZhbChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgIGNvbnN0IHRpY2tzID0gaW50ZXJ2YWwgPyBpbnRlcnZhbC5yYW5nZShzdGFydCwgK3N0b3AgKyAxKSA6IFtdOyAvLyBpbmNsdXNpdmUgc3RvcFxuICAgIHJldHVybiByZXZlcnNlID8gdGlja3MucmV2ZXJzZSgpIDogdGlja3M7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrSW50ZXJ2YWwoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIGNvdW50O1xuICAgIGNvbnN0IGkgPSBiaXNlY3RvcigoWywsIHN0ZXBdKSA9PiBzdGVwKS5yaWdodCh0aWNrSW50ZXJ2YWxzLCB0YXJnZXQpO1xuICAgIGlmIChpID09PSB0aWNrSW50ZXJ2YWxzLmxlbmd0aCkgcmV0dXJuIHllYXIuZXZlcnkodGlja1N0ZXAoc3RhcnQgLyBkdXJhdGlvblllYXIsIHN0b3AgLyBkdXJhdGlvblllYXIsIGNvdW50KSk7XG4gICAgaWYgKGkgPT09IDApIHJldHVybiBtaWxsaXNlY29uZC5ldmVyeShNYXRoLm1heCh0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpLCAxKSk7XG4gICAgY29uc3QgW3QsIHN0ZXBdID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgIHJldHVybiB0LmV2ZXJ5KHN0ZXApO1xuICB9XG5cbiAgcmV0dXJuIFt0aWNrcywgdGlja0ludGVydmFsXTtcbn1cblxuY29uc3QgW3V0Y1RpY2tzLCB1dGNUaWNrSW50ZXJ2YWxdID0gdGlja2VyKHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSk7XG5jb25zdCBbdGltZVRpY2tzLCB0aW1lVGlja0ludGVydmFsXSA9IHRpY2tlcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUpO1xuXG5leHBvcnQge3V0Y1RpY2tzLCB1dGNUaWNrSW50ZXJ2YWwsIHRpbWVUaWNrcywgdGltZVRpY2tJbnRlcnZhbH07XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25EYXl9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciB1dGNEYXkgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uRGF5O1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENEYXRlKCkgLSAxO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0Y0RheTtcbmV4cG9ydCB2YXIgdXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbkhvdXJ9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciB1dGNIb3VyID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1dGNIb3VyO1xuZXhwb3J0IHZhciB1dGNIb3VycyA9IHV0Y0hvdXIucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25NaW51dGV9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbnZhciB1dGNNaW51dGUgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbk1pbnV0ZTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTWludXRlcygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0Y01pbnV0ZTtcbmV4cG9ydCB2YXIgdXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuXG52YXIgdXRjTW9udGggPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZSgxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENNb250aChkYXRlLmdldFVUQ01vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENNb250aCgpIC0gc3RhcnQuZ2V0VVRDTW9udGgoKSArIChlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01vbnRoKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdXRjTW9udGg7XG5leHBvcnQgdmFyIHV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uV2Vla30gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxuZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gIHJldHVybiBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbldlZWs7XG4gIH0pO1xufVxuXG5leHBvcnQgdmFyIHV0Y1N1bmRheSA9IHV0Y1dlZWtkYXkoMCk7XG5leHBvcnQgdmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG5leHBvcnQgdmFyIHV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xuZXhwb3J0IHZhciB1dGNXZWRuZXNkYXkgPSB1dGNXZWVrZGF5KDMpO1xuZXhwb3J0IHZhciB1dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG5leHBvcnQgdmFyIHV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG5leHBvcnQgdmFyIHV0Y1NhdHVyZGF5ID0gdXRjV2Vla2RheSg2KTtcblxuZXhwb3J0IHZhciB1dGNTdW5kYXlzID0gdXRjU3VuZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNNb25kYXlzID0gdXRjTW9uZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNGcmlkYXlzID0gdXRjRnJpZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB1dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuXG52YXIgdXRjWWVhciA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG51dGNZZWFyLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAvIGspICogayk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwICogayk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXRjWWVhcjtcbmV4cG9ydCB2YXIgdXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uTWludXRlLCBkdXJhdGlvbldlZWt9IGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5cbmZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICByZXR1cm4gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbmV4cG9ydCB2YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbmV4cG9ydCB2YXIgdHVlc2RheSA9IHdlZWtkYXkoMik7XG5leHBvcnQgdmFyIHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG5leHBvcnQgdmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbmV4cG9ydCB2YXIgZnJpZGF5ID0gd2Vla2RheSg1KTtcbmV4cG9ydCB2YXIgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG5leHBvcnQgdmFyIHN1bmRheXMgPSBzdW5kYXkucmFuZ2U7XG5leHBvcnQgdmFyIG1vbmRheXMgPSBtb25kYXkucmFuZ2U7XG5leHBvcnQgdmFyIHR1ZXNkYXlzID0gdHVlc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgd2VkbmVzZGF5cyA9IHdlZG5lc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgdGh1cnNkYXlzID0gdGh1cnNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIGZyaWRheXMgPSBmcmlkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHNhdHVyZGF5cyA9IHNhdHVyZGF5LnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5cbnZhciB5ZWFyID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnllYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB5ZWFyO1xuZXhwb3J0IHZhciB5ZWFycyA9IHllYXIucmFuZ2U7XG4iLCJpbXBvcnQge1RpbWVyLCBub3d9IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lciwgdG90YWwgPSBkZWxheTtcbiAgaWYgKGRlbGF5ID09IG51bGwpIHJldHVybiB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSwgdDtcbiAgdC5fcmVzdGFydCA9IHQucmVzdGFydDtcbiAgdC5yZXN0YXJ0ID0gZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgZGVsYXkgPSArZGVsYXksIHRpbWUgPSB0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lO1xuICAgIHQuX3Jlc3RhcnQoZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgICBlbGFwc2VkICs9IHRvdGFsO1xuICAgICAgdC5fcmVzdGFydCh0aWNrLCB0b3RhbCArPSBkZWxheSwgdGltZSk7XG4gICAgICBjYWxsYmFjayhlbGFwc2VkKTtcbiAgICB9LCBkZWxheSwgdGltZSk7XG4gIH1cbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuIiwidmFyIGZyYW1lID0gMCwgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XG4gICAgdGltZW91dCA9IDAsIC8vIGlzIGEgdGltZW91dCBwZW5kaW5nP1xuICAgIGludGVydmFsID0gMCwgLy8gYXJlIGFueSB0aW1lcnMgYWN0aXZlP1xuICAgIHBva2VEZWxheSA9IDEwMDAsIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XG4gICAgdGFza0hlYWQsXG4gICAgdGFza1RhaWwsXG4gICAgY2xvY2tMYXN0ID0gMCxcbiAgICBjbG9ja05vdyA9IDAsXG4gICAgY2xvY2tTa2V3ID0gMCxcbiAgICBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsXG4gICAgc2V0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAxNyk7IH07XG5cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBjbG9ja05vdyB8fCAoc2V0RnJhbWUoY2xlYXJOb3cpLCBjbG9ja05vdyA9IGNsb2NrLm5vdygpICsgY2xvY2tTa2V3KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJOb3coKSB7XG4gIGNsb2NrTm93ID0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lcihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyRmx1c2goKSB7XG4gIG5vdygpOyAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSwgaWYgbm90IGFscmVhZHkgc2V0LlxuICArK2ZyYW1lOyAvLyBQcmV0ZW5kIHdl4oCZdmUgc2V0IGFuIGFsYXJtLCBpZiB3ZSBoYXZlbuKAmXQgYWxyZWFkeS5cbiAgdmFyIHQgPSB0YXNrSGVhZCwgZTtcbiAgd2hpbGUgKHQpIHtcbiAgICBpZiAoKGUgPSBjbG9ja05vdyAtIHQuX3RpbWUpID49IDApIHQuX2NhbGwuY2FsbChudWxsLCBlKTtcbiAgICB0ID0gdC5fbmV4dDtcbiAgfVxuICAtLWZyYW1lO1xufVxuXG5mdW5jdGlvbiB3YWtlKCkge1xuICBjbG9ja05vdyA9IChjbG9ja0xhc3QgPSBjbG9jay5ub3coKSkgKyBjbG9ja1NrZXc7XG4gIGZyYW1lID0gdGltZW91dCA9IDA7XG4gIHRyeSB7XG4gICAgdGltZXJGbHVzaCgpO1xuICB9IGZpbmFsbHkge1xuICAgIGZyYW1lID0gMDtcbiAgICBuYXAoKTtcbiAgICBjbG9ja05vdyA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9rZSgpIHtcbiAgdmFyIG5vdyA9IGNsb2NrLm5vdygpLCBkZWxheSA9IG5vdyAtIGNsb2NrTGFzdDtcbiAgaWYgKGRlbGF5ID4gcG9rZURlbGF5KSBjbG9ja1NrZXcgLT0gZGVsYXksIGNsb2NrTGFzdCA9IG5vdztcbn1cblxuZnVuY3Rpb24gbmFwKCkge1xuICB2YXIgdDAsIHQxID0gdGFza0hlYWQsIHQyLCB0aW1lID0gSW5maW5pdHk7XG4gIHdoaWxlICh0MSkge1xuICAgIGlmICh0MS5fY2FsbCkge1xuICAgICAgaWYgKHRpbWUgPiB0MS5fdGltZSkgdGltZSA9IHQxLl90aW1lO1xuICAgICAgdDAgPSB0MSwgdDEgPSB0MS5fbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgPSB0MS5fbmV4dCwgdDEuX25leHQgPSBudWxsO1xuICAgICAgdDEgPSB0MCA/IHQwLl9uZXh0ID0gdDIgOiB0YXNrSGVhZCA9IHQyO1xuICAgIH1cbiAgfVxuICB0YXNrVGFpbCA9IHQwO1xuICBzbGVlcCh0aW1lKTtcbn1cblxuZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICBpZiAoZnJhbWUpIHJldHVybjsgLy8gU29vbmVzdCBhbGFybSBhbHJlYWR5IHNldCwgb3Igd2lsbCBiZS5cbiAgaWYgKHRpbWVvdXQpIHRpbWVvdXQgPSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIHZhciBkZWxheSA9IHRpbWUgLSBjbG9ja05vdzsgLy8gU3RyaWN0bHkgbGVzcyB0aGFuIGlmIHdlIHJlY29tcHV0ZWQgY2xvY2tOb3cuXG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgdGltZSAtIGNsb2NrLm5vdygpIC0gY2xvY2tTa2V3KTtcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnRlcnZhbCkgY2xvY2tMYXN0ID0gY2xvY2subm93KCksIGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9rZSwgcG9rZURlbGF5KTtcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xuICB9XG59XG4iLCJcbmNvbnN0IEVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpO1xuY29uc3QgRURHRV9TVEFDSyA9IG5ldyBVaW50MzJBcnJheSg1MTIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWxhdW5hdG9yIHtcblxuICAgIHN0YXRpYyBmcm9tKHBvaW50cywgZ2V0WCA9IGRlZmF1bHRHZXRYLCBnZXRZID0gZGVmYXVsdEdldFkpIHtcbiAgICAgICAgY29uc3QgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IG5ldyBGbG9hdDY0QXJyYXkobiAqIDIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgY29vcmRzWzIgKiBpXSA9IGdldFgocCk7XG4gICAgICAgICAgICBjb29yZHNbMiAqIGkgKyAxXSA9IGdldFkocCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERlbGF1bmF0b3IoY29vcmRzKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb29yZHMpIHtcbiAgICAgICAgY29uc3QgbiA9IGNvb3Jkcy5sZW5ndGggPj4gMTtcbiAgICAgICAgaWYgKG4gPiAwICYmIHR5cGVvZiBjb29yZHNbMF0gIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGNvb3JkcyB0byBjb250YWluIG51bWJlcnMuJyk7XG5cbiAgICAgICAgdGhpcy5jb29yZHMgPSBjb29yZHM7XG5cbiAgICAgICAgLy8gYXJyYXlzIHRoYXQgd2lsbCBzdG9yZSB0aGUgdHJpYW5ndWxhdGlvbiBncmFwaFxuICAgICAgICBjb25zdCBtYXhUcmlhbmdsZXMgPSBNYXRoLm1heCgyICogbiAtIDUsIDApO1xuICAgICAgICB0aGlzLl90cmlhbmdsZXMgPSBuZXcgVWludDMyQXJyYXkobWF4VHJpYW5nbGVzICogMyk7XG4gICAgICAgIHRoaXMuX2hhbGZlZGdlcyA9IG5ldyBJbnQzMkFycmF5KG1heFRyaWFuZ2xlcyAqIDMpO1xuXG4gICAgICAgIC8vIHRlbXBvcmFyeSBhcnJheXMgZm9yIHRyYWNraW5nIHRoZSBlZGdlcyBvZiB0aGUgYWR2YW5jaW5nIGNvbnZleCBodWxsXG4gICAgICAgIHRoaXMuX2hhc2hTaXplID0gTWF0aC5jZWlsKE1hdGguc3FydChuKSk7XG4gICAgICAgIHRoaXMuX2h1bGxQcmV2ID0gbmV3IFVpbnQzMkFycmF5KG4pOyAvLyBlZGdlIHRvIHByZXYgZWRnZVxuICAgICAgICB0aGlzLl9odWxsTmV4dCA9IG5ldyBVaW50MzJBcnJheShuKTsgLy8gZWRnZSB0byBuZXh0IGVkZ2VcbiAgICAgICAgdGhpcy5faHVsbFRyaSA9IG5ldyBVaW50MzJBcnJheShuKTsgLy8gZWRnZSB0byBhZGphY2VudCB0cmlhbmdsZVxuICAgICAgICB0aGlzLl9odWxsSGFzaCA9IG5ldyBJbnQzMkFycmF5KHRoaXMuX2hhc2hTaXplKS5maWxsKC0xKTsgLy8gYW5ndWxhciBlZGdlIGhhc2hcblxuICAgICAgICAvLyB0ZW1wb3JhcnkgYXJyYXlzIGZvciBzb3J0aW5nIHBvaW50c1xuICAgICAgICB0aGlzLl9pZHMgPSBuZXcgVWludDMyQXJyYXkobik7XG4gICAgICAgIHRoaXMuX2Rpc3RzID0gbmV3IEZsb2F0NjRBcnJheShuKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3Qge2Nvb3JkcywgX2h1bGxQcmV2OiBodWxsUHJldiwgX2h1bGxOZXh0OiBodWxsTmV4dCwgX2h1bGxUcmk6IGh1bGxUcmksIF9odWxsSGFzaDogaHVsbEhhc2h9ID0gIHRoaXM7XG4gICAgICAgIGNvbnN0IG4gPSBjb29yZHMubGVuZ3RoID4+IDE7XG5cbiAgICAgICAgLy8gcG9wdWxhdGUgYW4gYXJyYXkgb2YgcG9pbnQgaW5kaWNlczsgY2FsY3VsYXRlIGlucHV0IGRhdGEgYmJveFxuICAgICAgICBsZXQgbWluWCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgbWluWSA9IEluZmluaXR5O1xuICAgICAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgbGV0IG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBjb29yZHNbMiAqIGldO1xuICAgICAgICAgICAgY29uc3QgeSA9IGNvb3Jkc1syICogaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgICAgIHRoaXMuX2lkc1tpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3ggPSAobWluWCArIG1heFgpIC8gMjtcbiAgICAgICAgY29uc3QgY3kgPSAobWluWSArIG1heFkpIC8gMjtcblxuICAgICAgICBsZXQgbWluRGlzdCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgaTAsIGkxLCBpMjtcblxuICAgICAgICAvLyBwaWNrIGEgc2VlZCBwb2ludCBjbG9zZSB0byB0aGUgY2VudGVyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gZGlzdChjeCwgY3ksIGNvb3Jkc1syICogaV0sIGNvb3Jkc1syICogaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChkIDwgbWluRGlzdCkge1xuICAgICAgICAgICAgICAgIGkwID0gaTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpMHggPSBjb29yZHNbMiAqIGkwXTtcbiAgICAgICAgY29uc3QgaTB5ID0gY29vcmRzWzIgKiBpMCArIDFdO1xuXG4gICAgICAgIG1pbkRpc3QgPSBJbmZpbml0eTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBzZWVkXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaTApIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZCA9IGRpc3QoaTB4LCBpMHksIGNvb3Jkc1syICogaV0sIGNvb3Jkc1syICogaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChkIDwgbWluRGlzdCAmJiBkID4gMCkge1xuICAgICAgICAgICAgICAgIGkxID0gaTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaTF4ID0gY29vcmRzWzIgKiBpMV07XG4gICAgICAgIGxldCBpMXkgPSBjb29yZHNbMiAqIGkxICsgMV07XG5cbiAgICAgICAgbGV0IG1pblJhZGl1cyA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHRoaXJkIHBvaW50IHdoaWNoIGZvcm1zIHRoZSBzbWFsbGVzdCBjaXJjdW1jaXJjbGUgd2l0aCB0aGUgZmlyc3QgdHdvXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaTAgfHwgaSA9PT0gaTEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgciA9IGNpcmN1bXJhZGl1cyhpMHgsIGkweSwgaTF4LCBpMXksIGNvb3Jkc1syICogaV0sIGNvb3Jkc1syICogaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyIDwgbWluUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgaTIgPSBpO1xuICAgICAgICAgICAgICAgIG1pblJhZGl1cyA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkyeCA9IGNvb3Jkc1syICogaTJdO1xuICAgICAgICBsZXQgaTJ5ID0gY29vcmRzWzIgKiBpMiArIDFdO1xuXG4gICAgICAgIGlmIChtaW5SYWRpdXMgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvLyBvcmRlciBjb2xsaW5lYXIgcG9pbnRzIGJ5IGR4IChvciBkeSBpZiBhbGwgeCBhcmUgaWRlbnRpY2FsKVxuICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgbGlzdCBhcyBhIGh1bGxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzdHNbaV0gPSAoY29vcmRzWzIgKiBpXSAtIGNvb3Jkc1swXSkgfHwgKGNvb3Jkc1syICogaSArIDFdIC0gY29vcmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1aWNrc29ydCh0aGlzLl9pZHMsIHRoaXMuX2Rpc3RzLCAwLCBuIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBodWxsID0gbmV3IFVpbnQzMkFycmF5KG4pO1xuICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGQwID0gLUluZmluaXR5OyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLl9pZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3RzW2lkXSA+IGQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGh1bGxbaisrXSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICBkMCA9IHRoaXMuX2Rpc3RzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmh1bGwgPSBodWxsLnN1YmFycmF5KDAsIGopO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZXMgPSBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgICAgICAgICB0aGlzLmhhbGZlZGdlcyA9IG5ldyBVaW50MzJBcnJheSgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN3YXAgdGhlIG9yZGVyIG9mIHRoZSBzZWVkIHBvaW50cyBmb3IgY291bnRlci1jbG9ja3dpc2Ugb3JpZW50YXRpb25cbiAgICAgICAgaWYgKG9yaWVudChpMHgsIGkweSwgaTF4LCBpMXksIGkyeCwgaTJ5KSkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGkxO1xuICAgICAgICAgICAgY29uc3QgeCA9IGkxeDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBpMXk7XG4gICAgICAgICAgICBpMSA9IGkyO1xuICAgICAgICAgICAgaTF4ID0gaTJ4O1xuICAgICAgICAgICAgaTF5ID0gaTJ5O1xuICAgICAgICAgICAgaTIgPSBpO1xuICAgICAgICAgICAgaTJ4ID0geDtcbiAgICAgICAgICAgIGkyeSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjZW50ZXIgPSBjaXJjdW1jZW50ZXIoaTB4LCBpMHksIGkxeCwgaTF5LCBpMngsIGkyeSk7XG4gICAgICAgIHRoaXMuX2N4ID0gY2VudGVyLng7XG4gICAgICAgIHRoaXMuX2N5ID0gY2VudGVyLnk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RzW2ldID0gZGlzdChjb29yZHNbMiAqIGldLCBjb29yZHNbMiAqIGkgKyAxXSwgY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNvcnQgdGhlIHBvaW50cyBieSBkaXN0YW5jZSBmcm9tIHRoZSBzZWVkIHRyaWFuZ2xlIGNpcmN1bWNlbnRlclxuICAgICAgICBxdWlja3NvcnQodGhpcy5faWRzLCB0aGlzLl9kaXN0cywgMCwgbiAtIDEpO1xuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgc2VlZCB0cmlhbmdsZSBhcyB0aGUgc3RhcnRpbmcgaHVsbFxuICAgICAgICB0aGlzLl9odWxsU3RhcnQgPSBpMDtcbiAgICAgICAgbGV0IGh1bGxTaXplID0gMztcblxuICAgICAgICBodWxsTmV4dFtpMF0gPSBodWxsUHJldltpMl0gPSBpMTtcbiAgICAgICAgaHVsbE5leHRbaTFdID0gaHVsbFByZXZbaTBdID0gaTI7XG4gICAgICAgIGh1bGxOZXh0W2kyXSA9IGh1bGxQcmV2W2kxXSA9IGkwO1xuXG4gICAgICAgIGh1bGxUcmlbaTBdID0gMDtcbiAgICAgICAgaHVsbFRyaVtpMV0gPSAxO1xuICAgICAgICBodWxsVHJpW2kyXSA9IDI7XG5cbiAgICAgICAgaHVsbEhhc2guZmlsbCgtMSk7XG4gICAgICAgIGh1bGxIYXNoW3RoaXMuX2hhc2hLZXkoaTB4LCBpMHkpXSA9IGkwO1xuICAgICAgICBodWxsSGFzaFt0aGlzLl9oYXNoS2V5KGkxeCwgaTF5KV0gPSBpMTtcbiAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleShpMngsIGkyeSldID0gaTI7XG5cbiAgICAgICAgdGhpcy50cmlhbmdsZXNMZW4gPSAwO1xuICAgICAgICB0aGlzLl9hZGRUcmlhbmdsZShpMCwgaTEsIGkyLCAtMSwgLTEsIC0xKTtcblxuICAgICAgICBmb3IgKGxldCBrID0gMCwgeHAsIHlwOyBrIDwgdGhpcy5faWRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcy5faWRzW2tdO1xuICAgICAgICAgICAgY29uc3QgeCA9IGNvb3Jkc1syICogaV07XG4gICAgICAgICAgICBjb25zdCB5ID0gY29vcmRzWzIgKiBpICsgMV07XG5cbiAgICAgICAgICAgIC8vIHNraXAgbmVhci1kdXBsaWNhdGUgcG9pbnRzXG4gICAgICAgICAgICBpZiAoayA+IDAgJiYgTWF0aC5hYnMoeCAtIHhwKSA8PSBFUFNJTE9OICYmIE1hdGguYWJzKHkgLSB5cCkgPD0gRVBTSUxPTikgY29udGludWU7XG4gICAgICAgICAgICB4cCA9IHg7XG4gICAgICAgICAgICB5cCA9IHk7XG5cbiAgICAgICAgICAgIC8vIHNraXAgc2VlZCB0cmlhbmdsZSBwb2ludHNcbiAgICAgICAgICAgIGlmIChpID09PSBpMCB8fCBpID09PSBpMSB8fCBpID09PSBpMikgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgYSB2aXNpYmxlIGVkZ2Ugb24gdGhlIGNvbnZleCBodWxsIHVzaW5nIGVkZ2UgaGFzaFxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBrZXkgPSB0aGlzLl9oYXNoS2V5KHgsIHkpOyBqIDwgdGhpcy5faGFzaFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaHVsbEhhc2hbKGtleSArIGopICUgdGhpcy5faGFzaFNpemVdO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCAhPT0gLTEgJiYgc3RhcnQgIT09IGh1bGxOZXh0W3N0YXJ0XSkgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXJ0ID0gaHVsbFByZXZbc3RhcnRdO1xuICAgICAgICAgICAgbGV0IGUgPSBzdGFydCwgcTtcbiAgICAgICAgICAgIHdoaWxlIChxID0gaHVsbE5leHRbZV0sICFvcmllbnQoeCwgeSwgY29vcmRzWzIgKiBlXSwgY29vcmRzWzIgKiBlICsgMV0sIGNvb3Jkc1syICogcV0sIGNvb3Jkc1syICogcSArIDFdKSkge1xuICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgIGlmIChlID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBlID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlID09PSAtMSkgY29udGludWU7IC8vIGxpa2VseSBhIG5lYXItZHVwbGljYXRlIHBvaW50OyBza2lwIGl0XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgZmlyc3QgdHJpYW5nbGUgZnJvbSB0aGUgcG9pbnRcbiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5fYWRkVHJpYW5nbGUoZSwgaSwgaHVsbE5leHRbZV0sIC0xLCAtMSwgaHVsbFRyaVtlXSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGZsaXAgdHJpYW5nbGVzIGZyb20gdGhlIHBvaW50IHVudGlsIHRoZXkgc2F0aXNmeSB0aGUgRGVsYXVuYXkgY29uZGl0aW9uXG4gICAgICAgICAgICBodWxsVHJpW2ldID0gdGhpcy5fbGVnYWxpemUodCArIDIpO1xuICAgICAgICAgICAgaHVsbFRyaVtlXSA9IHQ7IC8vIGtlZXAgdHJhY2sgb2YgYm91bmRhcnkgdHJpYW5nbGVzIG9uIHRoZSBodWxsXG4gICAgICAgICAgICBodWxsU2l6ZSsrO1xuXG4gICAgICAgICAgICAvLyB3YWxrIGZvcndhcmQgdGhyb3VnaCB0aGUgaHVsbCwgYWRkaW5nIG1vcmUgdHJpYW5nbGVzIGFuZCBmbGlwcGluZyByZWN1cnNpdmVseVxuICAgICAgICAgICAgbGV0IG4gPSBodWxsTmV4dFtlXTtcbiAgICAgICAgICAgIHdoaWxlIChxID0gaHVsbE5leHRbbl0sIG9yaWVudCh4LCB5LCBjb29yZHNbMiAqIG5dLCBjb29yZHNbMiAqIG4gKyAxXSwgY29vcmRzWzIgKiBxXSwgY29vcmRzWzIgKiBxICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgdCA9IHRoaXMuX2FkZFRyaWFuZ2xlKG4sIGksIHEsIGh1bGxUcmlbaV0sIC0xLCBodWxsVHJpW25dKTtcbiAgICAgICAgICAgICAgICBodWxsVHJpW2ldID0gdGhpcy5fbGVnYWxpemUodCArIDIpO1xuICAgICAgICAgICAgICAgIGh1bGxOZXh0W25dID0gbjsgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgaHVsbFNpemUtLTtcbiAgICAgICAgICAgICAgICBuID0gcTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2FsayBiYWNrd2FyZCBmcm9tIHRoZSBvdGhlciBzaWRlLCBhZGRpbmcgbW9yZSB0cmlhbmdsZXMgYW5kIGZsaXBwaW5nXG4gICAgICAgICAgICBpZiAoZSA9PT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocSA9IGh1bGxQcmV2W2VdLCBvcmllbnQoeCwgeSwgY29vcmRzWzIgKiBxXSwgY29vcmRzWzIgKiBxICsgMV0sIGNvb3Jkc1syICogZV0sIGNvb3Jkc1syICogZSArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5fYWRkVHJpYW5nbGUocSwgaSwgZSwgLTEsIGh1bGxUcmlbZV0sIGh1bGxUcmlbcV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZWdhbGl6ZSh0ICsgMik7XG4gICAgICAgICAgICAgICAgICAgIGh1bGxUcmlbcV0gPSB0O1xuICAgICAgICAgICAgICAgICAgICBodWxsTmV4dFtlXSA9IGU7IC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICBodWxsU2l6ZS0tO1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaHVsbCBpbmRpY2VzXG4gICAgICAgICAgICB0aGlzLl9odWxsU3RhcnQgPSBodWxsUHJldltpXSA9IGU7XG4gICAgICAgICAgICBodWxsTmV4dFtlXSA9IGh1bGxQcmV2W25dID0gaTtcbiAgICAgICAgICAgIGh1bGxOZXh0W2ldID0gbjtcblxuICAgICAgICAgICAgLy8gc2F2ZSB0aGUgdHdvIG5ldyBlZGdlcyBpbiB0aGUgaGFzaCB0YWJsZVxuICAgICAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleSh4LCB5KV0gPSBpO1xuICAgICAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleShjb29yZHNbMiAqIGVdLCBjb29yZHNbMiAqIGUgKyAxXSldID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaHVsbCA9IG5ldyBVaW50MzJBcnJheShodWxsU2l6ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gdGhpcy5faHVsbFN0YXJ0OyBpIDwgaHVsbFNpemU7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5odWxsW2ldID0gZTtcbiAgICAgICAgICAgIGUgPSBodWxsTmV4dFtlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaW0gdHlwZWQgdHJpYW5nbGUgbWVzaCBhcnJheXNcbiAgICAgICAgdGhpcy50cmlhbmdsZXMgPSB0aGlzLl90cmlhbmdsZXMuc3ViYXJyYXkoMCwgdGhpcy50cmlhbmdsZXNMZW4pO1xuICAgICAgICB0aGlzLmhhbGZlZGdlcyA9IHRoaXMuX2hhbGZlZGdlcy5zdWJhcnJheSgwLCB0aGlzLnRyaWFuZ2xlc0xlbik7XG4gICAgfVxuXG4gICAgX2hhc2hLZXkoeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihwc2V1ZG9BbmdsZSh4IC0gdGhpcy5fY3gsIHkgLSB0aGlzLl9jeSkgKiB0aGlzLl9oYXNoU2l6ZSkgJSB0aGlzLl9oYXNoU2l6ZTtcbiAgICB9XG5cbiAgICBfbGVnYWxpemUoYSkge1xuICAgICAgICBjb25zdCB7X3RyaWFuZ2xlczogdHJpYW5nbGVzLCBfaGFsZmVkZ2VzOiBoYWxmZWRnZXMsIGNvb3Jkc30gPSB0aGlzO1xuXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGFyID0gMDtcblxuICAgICAgICAvLyByZWN1cnNpb24gZWxpbWluYXRlZCB3aXRoIGEgZml4ZWQtc2l6ZSBzdGFja1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgYiA9IGhhbGZlZGdlc1thXTtcblxuICAgICAgICAgICAgLyogaWYgdGhlIHBhaXIgb2YgdHJpYW5nbGVzIGRvZXNuJ3Qgc2F0aXNmeSB0aGUgRGVsYXVuYXkgY29uZGl0aW9uXG4gICAgICAgICAgICAgKiAocDEgaXMgaW5zaWRlIHRoZSBjaXJjdW1jaXJjbGUgb2YgW3AwLCBwbCwgcHJdKSwgZmxpcCB0aGVtLFxuICAgICAgICAgICAgICogdGhlbiBkbyB0aGUgc2FtZSBjaGVjay9mbGlwIHJlY3Vyc2l2ZWx5IGZvciB0aGUgbmV3IHBhaXIgb2YgdHJpYW5nbGVzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAgICAgIHBsICAgICAgICAgICAgICAgICAgICBwbFxuICAgICAgICAgICAgICogICAgICAgICAgL3x8XFwgICAgICAgICAgICAgICAgICAvICBcXFxuICAgICAgICAgICAgICogICAgICAgYWwvIHx8IFxcYmwgICAgICAgICAgICBhbC8gICAgXFxhXG4gICAgICAgICAgICAgKiAgICAgICAgLyAgfHwgIFxcICAgICAgICAgICAgICAvICAgICAgXFxcbiAgICAgICAgICAgICAqICAgICAgIC8gIGF8fGIgIFxcICAgIGZsaXAgICAgL19fX2FyX19fXFxcbiAgICAgICAgICAgICAqICAgICBwMFxcICAgfHwgICAvcDEgICA9PiAgIHAwXFwtLS1ibC0tLS9wMVxuICAgICAgICAgICAgICogICAgICAgIFxcICB8fCAgLyAgICAgICAgICAgICAgXFwgICAgICAvXG4gICAgICAgICAgICAgKiAgICAgICBhclxcIHx8IC9iciAgICAgICAgICAgICBiXFwgICAgL2JyXG4gICAgICAgICAgICAgKiAgICAgICAgICBcXHx8LyAgICAgICAgICAgICAgICAgIFxcICAvXG4gICAgICAgICAgICAgKiAgICAgICAgICAgcHIgICAgICAgICAgICAgICAgICAgIHByXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGEwID0gYSAtIGEgJSAzO1xuICAgICAgICAgICAgYXIgPSBhMCArIChhICsgMikgJSAzO1xuXG4gICAgICAgICAgICBpZiAoYiA9PT0gLTEpIHsgLy8gY29udmV4IGh1bGwgZWRnZVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcbiAgICAgICAgICAgICAgICBhID0gRURHRV9TVEFDS1stLWldO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBiMCA9IGIgLSBiICUgMztcbiAgICAgICAgICAgIGNvbnN0IGFsID0gYTAgKyAoYSArIDEpICUgMztcbiAgICAgICAgICAgIGNvbnN0IGJsID0gYjAgKyAoYiArIDIpICUgMztcblxuICAgICAgICAgICAgY29uc3QgcDAgPSB0cmlhbmdsZXNbYXJdO1xuICAgICAgICAgICAgY29uc3QgcHIgPSB0cmlhbmdsZXNbYV07XG4gICAgICAgICAgICBjb25zdCBwbCA9IHRyaWFuZ2xlc1thbF07XG4gICAgICAgICAgICBjb25zdCBwMSA9IHRyaWFuZ2xlc1tibF07XG5cbiAgICAgICAgICAgIGNvbnN0IGlsbGVnYWwgPSBpbkNpcmNsZShcbiAgICAgICAgICAgICAgICBjb29yZHNbMiAqIHAwXSwgY29vcmRzWzIgKiBwMCArIDFdLFxuICAgICAgICAgICAgICAgIGNvb3Jkc1syICogcHJdLCBjb29yZHNbMiAqIHByICsgMV0sXG4gICAgICAgICAgICAgICAgY29vcmRzWzIgKiBwbF0sIGNvb3Jkc1syICogcGwgKyAxXSxcbiAgICAgICAgICAgICAgICBjb29yZHNbMiAqIHAxXSwgY29vcmRzWzIgKiBwMSArIDFdKTtcblxuICAgICAgICAgICAgaWYgKGlsbGVnYWwpIHtcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXNbYV0gPSBwMTtcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXNbYl0gPSBwMDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGhibCA9IGhhbGZlZGdlc1tibF07XG5cbiAgICAgICAgICAgICAgICAvLyBlZGdlIHN3YXBwZWQgb24gdGhlIG90aGVyIHNpZGUgb2YgdGhlIGh1bGwgKHJhcmUpOyBmaXggdGhlIGhhbGZlZGdlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGlmIChoYmwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlID0gdGhpcy5faHVsbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faHVsbFRyaVtlXSA9PT0gYmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9odWxsVHJpW2VdID0gYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLl9odWxsUHJldltlXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZSAhPT0gdGhpcy5faHVsbFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluayhhLCBoYmwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmsoYiwgaGFsZmVkZ2VzW2FyXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluayhhciwgYmwpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYnIgPSBiMCArIChiICsgMSkgJSAzO1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgd29ycnkgYWJvdXQgaGl0dGluZyB0aGUgY2FwOiBpdCBjYW4gb25seSBoYXBwZW4gb24gZXh0cmVtZWx5IGRlZ2VuZXJhdGUgaW5wdXRcbiAgICAgICAgICAgICAgICBpZiAoaSA8IEVER0VfU1RBQ0subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIEVER0VfU1RBQ0tbaSsrXSA9IGJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xuICAgICAgICAgICAgICAgIGEgPSBFREdFX1NUQUNLWy0taV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXI7XG4gICAgfVxuXG4gICAgX2xpbmsoYSwgYikge1xuICAgICAgICB0aGlzLl9oYWxmZWRnZXNbYV0gPSBiO1xuICAgICAgICBpZiAoYiAhPT0gLTEpIHRoaXMuX2hhbGZlZGdlc1tiXSA9IGE7XG4gICAgfVxuXG4gICAgLy8gYWRkIGEgbmV3IHRyaWFuZ2xlIGdpdmVuIHZlcnRleCBpbmRpY2VzIGFuZCBhZGphY2VudCBoYWxmLWVkZ2UgaWRzXG4gICAgX2FkZFRyaWFuZ2xlKGkwLCBpMSwgaTIsIGEsIGIsIGMpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMudHJpYW5nbGVzTGVuO1xuXG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlc1t0XSA9IGkwO1xuICAgICAgICB0aGlzLl90cmlhbmdsZXNbdCArIDFdID0gaTE7XG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlc1t0ICsgMl0gPSBpMjtcblxuICAgICAgICB0aGlzLl9saW5rKHQsIGEpO1xuICAgICAgICB0aGlzLl9saW5rKHQgKyAxLCBiKTtcbiAgICAgICAgdGhpcy5fbGluayh0ICsgMiwgYyk7XG5cbiAgICAgICAgdGhpcy50cmlhbmdsZXNMZW4gKz0gMztcblxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG59XG5cbi8vIG1vbm90b25pY2FsbHkgaW5jcmVhc2VzIHdpdGggcmVhbCBhbmdsZSwgYnV0IGRvZXNuJ3QgbmVlZCBleHBlbnNpdmUgdHJpZ29ub21ldHJ5XG5mdW5jdGlvbiBwc2V1ZG9BbmdsZShkeCwgZHkpIHtcbiAgICBjb25zdCBwID0gZHggLyAoTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKTtcbiAgICByZXR1cm4gKGR5ID4gMCA/IDMgLSBwIDogMSArIHApIC8gNDsgLy8gWzAuLjFdXG59XG5cbmZ1bmN0aW9uIGRpc3QoYXgsIGF5LCBieCwgYnkpIHtcbiAgICBjb25zdCBkeCA9IGF4IC0gYng7XG4gICAgY29uc3QgZHkgPSBheSAtIGJ5O1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLy8gcmV0dXJuIDJkIG9yaWVudGF0aW9uIHNpZ24gaWYgd2UncmUgY29uZmlkZW50IGluIGl0IHRocm91Z2ggSi4gU2hld2NodWsncyBlcnJvciBib3VuZCBjaGVja1xuZnVuY3Rpb24gb3JpZW50SWZTdXJlKHB4LCBweSwgcngsIHJ5LCBxeCwgcXkpIHtcbiAgICBjb25zdCBsID0gKHJ5IC0gcHkpICogKHF4IC0gcHgpO1xuICAgIGNvbnN0IHIgPSAocnggLSBweCkgKiAocXkgLSBweSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKGwgLSByKSA+PSAzLjMzMDY2OTA3Mzg3NTQ3MTZlLTE2ICogTWF0aC5hYnMobCArIHIpID8gbCAtIHIgOiAwO1xufVxuXG4vLyBhIG1vcmUgcm9idXN0IG9yaWVudGF0aW9uIHRlc3QgdGhhdCdzIHN0YWJsZSBpbiBhIGdpdmVuIHRyaWFuZ2xlICh0byBmaXggcm9idXN0bmVzcyBpc3N1ZXMpXG5mdW5jdGlvbiBvcmllbnQocngsIHJ5LCBxeCwgcXksIHB4LCBweSkge1xuICAgIGNvbnN0IHNpZ24gPSBvcmllbnRJZlN1cmUocHgsIHB5LCByeCwgcnksIHF4LCBxeSkgfHxcbiAgICBvcmllbnRJZlN1cmUocngsIHJ5LCBxeCwgcXksIHB4LCBweSkgfHxcbiAgICBvcmllbnRJZlN1cmUocXgsIHF5LCBweCwgcHksIHJ4LCByeSk7XG4gICAgcmV0dXJuIHNpZ24gPCAwO1xufVxuXG5mdW5jdGlvbiBpbkNpcmNsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICBjb25zdCBkeCA9IGF4IC0gcHg7XG4gICAgY29uc3QgZHkgPSBheSAtIHB5O1xuICAgIGNvbnN0IGV4ID0gYnggLSBweDtcbiAgICBjb25zdCBleSA9IGJ5IC0gcHk7XG4gICAgY29uc3QgZnggPSBjeCAtIHB4O1xuICAgIGNvbnN0IGZ5ID0gY3kgLSBweTtcblxuICAgIGNvbnN0IGFwID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgY29uc3QgYnAgPSBleCAqIGV4ICsgZXkgKiBleTtcbiAgICBjb25zdCBjcCA9IGZ4ICogZnggKyBmeSAqIGZ5O1xuXG4gICAgcmV0dXJuIGR4ICogKGV5ICogY3AgLSBicCAqIGZ5KSAtXG4gICAgICAgICAgIGR5ICogKGV4ICogY3AgLSBicCAqIGZ4KSArXG4gICAgICAgICAgIGFwICogKGV4ICogZnkgLSBleSAqIGZ4KSA8IDA7XG59XG5cbmZ1bmN0aW9uIGNpcmN1bXJhZGl1cyhheCwgYXksIGJ4LCBieSwgY3gsIGN5KSB7XG4gICAgY29uc3QgZHggPSBieCAtIGF4O1xuICAgIGNvbnN0IGR5ID0gYnkgLSBheTtcbiAgICBjb25zdCBleCA9IGN4IC0gYXg7XG4gICAgY29uc3QgZXkgPSBjeSAtIGF5O1xuXG4gICAgY29uc3QgYmwgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBjb25zdCBjbCA9IGV4ICogZXggKyBleSAqIGV5O1xuICAgIGNvbnN0IGQgPSAwLjUgLyAoZHggKiBleSAtIGR5ICogZXgpO1xuXG4gICAgY29uc3QgeCA9IChleSAqIGJsIC0gZHkgKiBjbCkgKiBkO1xuICAgIGNvbnN0IHkgPSAoZHggKiBjbCAtIGV4ICogYmwpICogZDtcblxuICAgIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuXG5mdW5jdGlvbiBjaXJjdW1jZW50ZXIoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkge1xuICAgIGNvbnN0IGR4ID0gYnggLSBheDtcbiAgICBjb25zdCBkeSA9IGJ5IC0gYXk7XG4gICAgY29uc3QgZXggPSBjeCAtIGF4O1xuICAgIGNvbnN0IGV5ID0gY3kgLSBheTtcblxuICAgIGNvbnN0IGJsID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgY29uc3QgY2wgPSBleCAqIGV4ICsgZXkgKiBleTtcbiAgICBjb25zdCBkID0gMC41IC8gKGR4ICogZXkgLSBkeSAqIGV4KTtcblxuICAgIGNvbnN0IHggPSBheCArIChleSAqIGJsIC0gZHkgKiBjbCkgKiBkO1xuICAgIGNvbnN0IHkgPSBheSArIChkeCAqIGNsIC0gZXggKiBibCkgKiBkO1xuXG4gICAgcmV0dXJuIHt4LCB5fTtcbn1cblxuZnVuY3Rpb24gcXVpY2tzb3J0KGlkcywgZGlzdHMsIGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSAyMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gbGVmdCArIDE7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBEaXN0ID0gZGlzdHNbdGVtcF07XG4gICAgICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGogPj0gbGVmdCAmJiBkaXN0c1tpZHNbal1dID4gdGVtcERpc3QpIGlkc1tqICsgMV0gPSBpZHNbai0tXTtcbiAgICAgICAgICAgIGlkc1tqICsgMV0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVkaWFuID0gKGxlZnQgKyByaWdodCkgPj4gMTtcbiAgICAgICAgbGV0IGkgPSBsZWZ0ICsgMTtcbiAgICAgICAgbGV0IGogPSByaWdodDtcbiAgICAgICAgc3dhcChpZHMsIG1lZGlhbiwgaSk7XG4gICAgICAgIGlmIChkaXN0c1tpZHNbbGVmdF1dID4gZGlzdHNbaWRzW3JpZ2h0XV0pIHN3YXAoaWRzLCBsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChkaXN0c1tpZHNbaV1dID4gZGlzdHNbaWRzW3JpZ2h0XV0pIHN3YXAoaWRzLCBpLCByaWdodCk7XG4gICAgICAgIGlmIChkaXN0c1tpZHNbbGVmdF1dID4gZGlzdHNbaWRzW2ldXSkgc3dhcChpZHMsIGxlZnQsIGkpO1xuXG4gICAgICAgIGNvbnN0IHRlbXAgPSBpZHNbaV07XG4gICAgICAgIGNvbnN0IHRlbXBEaXN0ID0gZGlzdHNbdGVtcF07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBkbyBpKys7IHdoaWxlIChkaXN0c1tpZHNbaV1dIDwgdGVtcERpc3QpO1xuICAgICAgICAgICAgZG8gai0tOyB3aGlsZSAoZGlzdHNbaWRzW2pdXSA+IHRlbXBEaXN0KTtcbiAgICAgICAgICAgIGlmIChqIDwgaSkgYnJlYWs7XG4gICAgICAgICAgICBzd2FwKGlkcywgaSwgaik7XG4gICAgICAgIH1cbiAgICAgICAgaWRzW2xlZnQgKyAxXSA9IGlkc1tqXTtcbiAgICAgICAgaWRzW2pdID0gdGVtcDtcblxuICAgICAgICBpZiAocmlnaHQgLSBpICsgMSA+PSBqIC0gbGVmdCkge1xuICAgICAgICAgICAgcXVpY2tzb3J0KGlkcywgZGlzdHMsIGksIHJpZ2h0KTtcbiAgICAgICAgICAgIHF1aWNrc29ydChpZHMsIGRpc3RzLCBsZWZ0LCBqIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWlja3NvcnQoaWRzLCBkaXN0cywgbGVmdCwgaiAtIDEpO1xuICAgICAgICAgICAgcXVpY2tzb3J0KGlkcywgZGlzdHMsIGksIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICBjb25zdCB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEdldFgocCkge1xuICAgIHJldHVybiBwWzBdO1xufVxuZnVuY3Rpb24gZGVmYXVsdEdldFkocCkge1xuICAgIHJldHVybiBwWzFdO1xufVxuIiwiaW1wb3J0IHRyYW5zZm9ybSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgdmFyIHQgPSB0cmFuc2Zvcm0odG9wb2xvZ3kudHJhbnNmb3JtKSwga2V5LFxuICAgICAgeDAgPSBJbmZpbml0eSwgeTAgPSB4MCwgeDEgPSAteDAsIHkxID0gLXgwO1xuXG4gIGZ1bmN0aW9uIGJib3hQb2ludChwKSB7XG4gICAgcCA9IHQocCk7XG4gICAgaWYgKHBbMF0gPCB4MCkgeDAgPSBwWzBdO1xuICAgIGlmIChwWzBdID4geDEpIHgxID0gcFswXTtcbiAgICBpZiAocFsxXSA8IHkwKSB5MCA9IHBbMV07XG4gICAgaWYgKHBbMV0gPiB5MSkgeTEgPSBwWzFdO1xuICB9XG5cbiAgZnVuY3Rpb24gYmJveEdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChiYm94R2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBiYm94UG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogby5jb29yZGluYXRlcy5mb3JFYWNoKGJib3hQb2ludCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRvcG9sb2d5LmFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJjLmxlbmd0aCwgcDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcCA9IHQoYXJjW2ldLCBpKTtcbiAgICAgIGlmIChwWzBdIDwgeDApIHgwID0gcFswXTtcbiAgICAgIGlmIChwWzBdID4geDEpIHgxID0gcFswXTtcbiAgICAgIGlmIChwWzFdIDwgeTApIHkwID0gcFsxXTtcbiAgICAgIGlmIChwWzFdID4geTEpIHkxID0gcFsxXTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvciAoa2V5IGluIHRvcG9sb2d5Lm9iamVjdHMpIHtcbiAgICBiYm94R2VvbWV0cnkodG9wb2xvZ3kub2JqZWN0c1trZXldKTtcbiAgfVxuXG4gIHJldHVybiBbeDAsIHkwLCB4MSwgeTFdO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgeCkge1xuICB2YXIgbG8gPSAwLCBoaSA9IGEubGVuZ3RoO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmIChhW21pZF0gPCB4KSBsbyA9IG1pZCArIDE7XG4gICAgZWxzZSBoaSA9IG1pZDtcbiAgfVxuICByZXR1cm4gbG87XG59XG4iLCJpbXBvcnQgcmV2ZXJzZSBmcm9tIFwiLi9yZXZlcnNlLmpzXCI7XG5pbXBvcnQgdHJhbnNmb3JtIGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgbykge1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIG8gPSB0b3BvbG9neS5vYmplY3RzW29dO1xuICByZXR1cm4gby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiXG4gICAgICA/IHt0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsIGZlYXR1cmVzOiBvLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGZlYXR1cmUodG9wb2xvZ3ksIG8pOyB9KX1cbiAgICAgIDogZmVhdHVyZSh0b3BvbG9neSwgbyk7XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmUodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIGlkID0gby5pZCxcbiAgICAgIGJib3ggPSBvLmJib3gsXG4gICAgICBwcm9wZXJ0aWVzID0gby5wcm9wZXJ0aWVzID09IG51bGwgPyB7fSA6IG8ucHJvcGVydGllcyxcbiAgICAgIGdlb21ldHJ5ID0gb2JqZWN0KHRvcG9sb2d5LCBvKTtcbiAgcmV0dXJuIGlkID09IG51bGwgJiYgYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IGJib3ggPT0gbnVsbCA/IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBiYm94OiBiYm94LCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KHRvcG9sb2d5LCBvKSB7XG4gIHZhciB0cmFuc2Zvcm1Qb2ludCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgYXJjcyA9IHRvcG9sb2d5LmFyY3M7XG5cbiAgZnVuY3Rpb24gYXJjKGksIHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoKSBwb2ludHMucG9wKCk7XG4gICAgZm9yICh2YXIgYSA9IGFyY3NbaSA8IDAgPyB+aSA6IGldLCBrID0gMCwgbiA9IGEubGVuZ3RoOyBrIDwgbjsgKytrKSB7XG4gICAgICBwb2ludHMucHVzaCh0cmFuc2Zvcm1Qb2ludChhW2tdLCBrKSk7XG4gICAgfVxuICAgIGlmIChpIDwgMCkgcmV2ZXJzZShwb2ludHMsIG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnQocCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qb2ludChwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHBvaW50cy5wdXNoKHBvaW50c1swXSk7IC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBwZXIgdGhlIHNwZWNpZmljYXRpb24uXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJpbmcoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBsaW5lKGFyY3MpO1xuICAgIHdoaWxlIChwb2ludHMubGVuZ3RoIDwgNCkgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBtYXkgaGFwcGVuIGlmIGFuIGFyYyBoYXMgb25seSB0d28gcG9pbnRzLlxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MpIHtcbiAgICByZXR1cm4gYXJjcy5tYXAocmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgdmFyIHR5cGUgPSBvLnR5cGUsIGNvb3JkaW5hdGVzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiByZXR1cm4ge3R5cGU6IHR5cGUsIGdlb21ldHJpZXM6IG8uZ2VvbWV0cmllcy5tYXAoZ2VvbWV0cnkpfTtcbiAgICAgIGNhc2UgXCJQb2ludFwiOiBjb29yZGluYXRlcyA9IHBvaW50KG8uY29vcmRpbmF0ZXMpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IGNvb3JkaW5hdGVzID0gby5jb29yZGluYXRlcy5tYXAocG9pbnQpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGNvb3JkaW5hdGVzID0gbGluZShvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKGxpbmUpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGNvb3JkaW5hdGVzID0gcG9seWdvbihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBvLmFyY3MubWFwKHBvbHlnb24pOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGU6IHR5cGUsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307XG4gIH1cblxuICByZXR1cm4gZ2VvbWV0cnkobyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGJib3h9IGZyb20gXCIuL2Jib3guanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmZWF0dXJlfSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWVzaCwgbWVzaEFyY3N9IGZyb20gXCIuL21lc2guanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXJnZSwgbWVyZ2VBcmNzfSBmcm9tIFwiLi9tZXJnZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG5laWdoYm9yc30gZnJvbSBcIi4vbmVpZ2hib3JzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpemV9IGZyb20gXCIuL3F1YW50aXplLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNmb3JtfSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB1bnRyYW5zZm9ybX0gZnJvbSBcIi4vdW50cmFuc2Zvcm0uanNcIjtcbiIsImltcG9ydCB7b2JqZWN0fSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5pbXBvcnQgc3RpdGNoIGZyb20gXCIuL3N0aXRjaC5qc1wiO1xuXG5mdW5jdGlvbiBwbGFuYXJSaW5nQXJlYShyaW5nKSB7XG4gIHZhciBpID0gLTEsIG4gPSByaW5nLmxlbmd0aCwgYSwgYiA9IHJpbmdbbiAtIDFdLCBhcmVhID0gMDtcbiAgd2hpbGUgKCsraSA8IG4pIGEgPSBiLCBiID0gcmluZ1tpXSwgYXJlYSArPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICByZXR1cm4gTWF0aC5hYnMoYXJlYSk7IC8vIE5vdGU6IGRvdWJsZWQgYXJlYSFcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3kpIHtcbiAgcmV0dXJuIG9iamVjdCh0b3BvbG9neSwgbWVyZ2VBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcmNzKHRvcG9sb2d5LCBvYmplY3RzKSB7XG4gIHZhciBwb2x5Z29uc0J5QXJjID0ge30sXG4gICAgICBwb2x5Z29ucyA9IFtdLFxuICAgICAgZ3JvdXBzID0gW107XG5cbiAgb2JqZWN0cy5mb3JFYWNoKGdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgc3dpdGNoIChvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3Qoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6IG8uYXJjcy5mb3JFYWNoKGV4dHJhY3QpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0KHBvbHlnb24pIHtcbiAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAocG9seWdvbnNCeUFyY1thcmMgPSBhcmMgPCAwID8gfmFyYyA6IGFyY10gfHwgKHBvbHlnb25zQnlBcmNbYXJjXSA9IFtdKSkucHVzaChwb2x5Z29uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhKHJpbmcpIHtcbiAgICByZXR1cm4gcGxhbmFyUmluZ0FyZWEob2JqZWN0KHRvcG9sb2d5LCB7dHlwZTogXCJQb2x5Z29uXCIsIGFyY3M6IFtyaW5nXX0pLmNvb3JkaW5hdGVzWzBdKTtcbiAgfVxuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGlmICghcG9seWdvbi5fKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBbXSxcbiAgICAgICAgICBuZWlnaGJvcnMgPSBbcG9seWdvbl07XG4gICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgd2hpbGUgKHBvbHlnb24gPSBuZWlnaGJvcnMucG9wKCkpIHtcbiAgICAgICAgZ3JvdXAucHVzaChwb2x5Z29uKTtcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICBwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICBkZWxldGUgcG9seWdvbi5fO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgYXJjczogZ3JvdXBzLm1hcChmdW5jdGlvbihwb2x5Z29ucykge1xuICAgICAgdmFyIGFyY3MgPSBbXSwgbjtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgZXh0ZXJpb3IgKHVuaXF1ZSkgYXJjcy5cbiAgICAgIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIGFyY3MucHVzaChhcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdGl0Y2ggdGhlIGFyY3MgaW50byBvbmUgb3IgbW9yZSByaW5ncy5cbiAgICAgIGFyY3MgPSBzdGl0Y2godG9wb2xvZ3ksIGFyY3MpO1xuXG4gICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIHJpbmcgaXMgcmV0dXJuZWQsXG4gICAgICAvLyBhdCBtb3N0IG9uZSBvZiB0aGVzZSByaW5ncyBjYW4gYmUgdGhlIGV4dGVyaW9yO1xuICAgICAgLy8gY2hvb3NlIHRoZSBvbmUgd2l0aCB0aGUgZ3JlYXRlc3QgYWJzb2x1dGUgYXJlYS5cbiAgICAgIGlmICgobiA9IGFyY3MubGVuZ3RoKSA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGsgPSBhcmVhKGFyY3NbMF0pLCBraSwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmICgoa2kgPSBhcmVhKGFyY3NbaV0pKSA+IGspIHtcbiAgICAgICAgICAgIHQgPSBhcmNzWzBdLCBhcmNzWzBdID0gYXJjc1tpXSwgYXJjc1tpXSA9IHQsIGsgPSBraTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGFyY3MpIHtcbiAgICAgIHJldHVybiBhcmNzLmxlbmd0aCA+IDA7XG4gICAgfSlcbiAgfTtcbn1cbiIsImltcG9ydCB7b2JqZWN0fSBmcm9tIFwiLi9mZWF0dXJlLmpzXCI7XG5pbXBvcnQgc3RpdGNoIGZyb20gXCIuL3N0aXRjaC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXNoQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lc2hBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcikge1xuICB2YXIgYXJjcywgaSwgbjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBhcmNzID0gZXh0cmFjdEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKTtcbiAgZWxzZSBmb3IgKGkgPSAwLCBhcmNzID0gbmV3IEFycmF5KG4gPSB0b3BvbG9neS5hcmNzLmxlbmd0aCk7IGkgPCBuOyArK2kpIGFyY3NbaV0gPSBpO1xuICByZXR1cm4ge3R5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGFyY3M6IHN0aXRjaCh0b3BvbG9neSwgYXJjcyl9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpIHtcbiAgdmFyIGFyY3MgPSBbXSxcbiAgICAgIGdlb21zQnlBcmMgPSBbXSxcbiAgICAgIGdlb207XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDAoaSkge1xuICAgIHZhciBqID0gaSA8IDAgPyB+aSA6IGk7XG4gICAgKGdlb21zQnlBcmNbal0gfHwgKGdlb21zQnlBcmNbal0gPSBbXSkpLnB1c2goe2k6IGksIGc6IGdlb219KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QxKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDIoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MyhhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKGdlb20gPSBvLCBvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goZ2VvbWV0cnkpOyBicmVhaztcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6IGV4dHJhY3QxKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjYXNlIFwiUG9seWdvblwiOiBleHRyYWN0MihvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogZXh0cmFjdDMoby5hcmNzKTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZ2VvbWV0cnkob2JqZWN0KTtcblxuICBnZW9tc0J5QXJjLmZvckVhY2goZmlsdGVyID09IG51bGxcbiAgICAgID8gZnVuY3Rpb24oZ2VvbXMpIHsgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9XG4gICAgICA6IGZ1bmN0aW9uKGdlb21zKSB7IGlmIChmaWx0ZXIoZ2VvbXNbMF0uZywgZ2VvbXNbZ2VvbXMubGVuZ3RoIC0gMV0uZykpIGFyY3MucHVzaChnZW9tc1swXS5pKTsgfSk7XG5cbiAgcmV0dXJuIGFyY3M7XG59XG4iLCJpbXBvcnQgYmlzZWN0IGZyb20gXCIuL2Jpc2VjdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmplY3RzKSB7XG4gIHZhciBpbmRleGVzQnlBcmMgPSB7fSwgLy8gYXJjIGluZGV4IC0+IGFycmF5IG9mIG9iamVjdCBpbmRleGVzXG4gICAgICBuZWlnaGJvcnMgPSBvYmplY3RzLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICBmdW5jdGlvbiBsaW5lKGFyY3MsIGkpIHtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKGEgPCAwKSBhID0gfmE7XG4gICAgICB2YXIgbyA9IGluZGV4ZXNCeUFyY1thXTtcbiAgICAgIGlmIChvKSBvLnB1c2goaSk7XG4gICAgICBlbHNlIGluZGV4ZXNCeUFyY1thXSA9IFtpXTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgbGluZShhcmMsIGkpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8sIGkpIHtcbiAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChmdW5jdGlvbihvKSB7IGdlb21ldHJ5KG8sIGkpOyB9KTtcbiAgICBlbHNlIGlmIChvLnR5cGUgaW4gZ2VvbWV0cnlUeXBlKSBnZW9tZXRyeVR5cGVbby50eXBlXShvLmFyY3MsIGkpO1xuICB9XG5cbiAgdmFyIGdlb21ldHJ5VHlwZSA9IHtcbiAgICBMaW5lU3RyaW5nOiBsaW5lLFxuICAgIE11bHRpTGluZVN0cmluZzogcG9seWdvbixcbiAgICBQb2x5Z29uOiBwb2x5Z29uLFxuICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24oYXJjcywgaSkgeyBhcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7IHBvbHlnb24oYXJjLCBpKTsgfSk7IH1cbiAgfTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZvciAodmFyIGkgaW4gaW5kZXhlc0J5QXJjKSB7XG4gICAgZm9yICh2YXIgaW5kZXhlcyA9IGluZGV4ZXNCeUFyY1tpXSwgbSA9IGluZGV4ZXMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbTsgKytrKSB7XG4gICAgICAgIHZhciBpaiA9IGluZGV4ZXNbal0sIGlrID0gaW5kZXhlc1trXSwgbjtcbiAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lqXSlbaSA9IGJpc2VjdChuLCBpayldICE9PSBpaykgbi5zcGxpY2UoaSwgMCwgaWspO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWtdKVtpID0gYmlzZWN0KG4sIGlqKV0gIT09IGlqKSBuLnNwbGljZShpLCAwLCBpaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn1cbiIsImltcG9ydCBiYm94IGZyb20gXCIuL2Jib3guanNcIjtcbmltcG9ydCB1bnRyYW5zZm9ybSBmcm9tIFwiLi91bnRyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgdHJhbnNmb3JtKSB7XG4gIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgcXVhbnRpemVkXCIpO1xuXG4gIGlmICghdHJhbnNmb3JtIHx8ICF0cmFuc2Zvcm0uc2NhbGUpIHtcbiAgICBpZiAoISgobiA9IE1hdGguZmxvb3IodHJhbnNmb3JtKSkgPj0gMikpIHRocm93IG5ldyBFcnJvcihcIm4gbXVzdCBiZSDiiaUyXCIpO1xuICAgIGJveCA9IHRvcG9sb2d5LmJib3ggfHwgYmJveCh0b3BvbG9neSk7XG4gICAgdmFyIHgwID0gYm94WzBdLCB5MCA9IGJveFsxXSwgeDEgPSBib3hbMl0sIHkxID0gYm94WzNdLCBuO1xuICAgIHRyYW5zZm9ybSA9IHtzY2FsZTogW3gxIC0geDAgPyAoeDEgLSB4MCkgLyAobiAtIDEpIDogMSwgeTEgLSB5MCA/ICh5MSAtIHkwKSAvIChuIC0gMSkgOiAxXSwgdHJhbnNsYXRlOiBbeDAsIHkwXX07XG4gIH0gZWxzZSB7XG4gICAgYm94ID0gdG9wb2xvZ3kuYmJveDtcbiAgfVxuXG4gIHZhciB0ID0gdW50cmFuc2Zvcm0odHJhbnNmb3JtKSwgYm94LCBrZXksIGlucHV0cyA9IHRvcG9sb2d5Lm9iamVjdHMsIG91dHB1dHMgPSB7fTtcblxuICBmdW5jdGlvbiBxdWFudGl6ZVBvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHQocG9pbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhbnRpemVHZW9tZXRyeShpbnB1dCkge1xuICAgIHZhciBvdXRwdXQ7XG4gICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG91dHB1dCA9IHt0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLCBnZW9tZXRyaWVzOiBpbnB1dC5nZW9tZXRyaWVzLm1hcChxdWFudGl6ZUdlb21ldHJ5KX07IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IG91dHB1dCA9IHt0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBxdWFudGl6ZVBvaW50KGlucHV0LmNvb3JkaW5hdGVzKX07IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogb3V0cHV0ID0ge3R5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogaW5wdXQuY29vcmRpbmF0ZXMubWFwKHF1YW50aXplUG9pbnQpfTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChpbnB1dC5pZCAhPSBudWxsKSBvdXRwdXQuaWQgPSBpbnB1dC5pZDtcbiAgICBpZiAoaW5wdXQuYmJveCAhPSBudWxsKSBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgaWYgKGlucHV0LnByb3BlcnRpZXMgIT0gbnVsbCkgb3V0cHV0LnByb3BlcnRpZXMgPSBpbnB1dC5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUFyYyhpbnB1dCkge1xuICAgIHZhciBpID0gMCwgaiA9IDEsIG4gPSBpbnB1dC5sZW5ndGgsIHAsIG91dHB1dCA9IG5ldyBBcnJheShuKTsgLy8gcGVzc2ltaXN0aWNcbiAgICBvdXRwdXRbMF0gPSB0KGlucHV0WzBdLCAwKTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKChwID0gdChpbnB1dFtpXSwgaSkpWzBdIHx8IHBbMV0pIG91dHB1dFtqKytdID0gcDsgLy8gbm9uLWNvaW5jaWRlbnQgcG9pbnRzXG4gICAgaWYgKGogPT09IDEpIG91dHB1dFtqKytdID0gWzAsIDBdOyAvLyBhbiBhcmMgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICBvdXRwdXQubGVuZ3RoID0gajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgZm9yIChrZXkgaW4gaW5wdXRzKSBvdXRwdXRzW2tleV0gPSBxdWFudGl6ZUdlb21ldHJ5KGlucHV0c1trZXldKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVG9wb2xvZ3lcIixcbiAgICBiYm94OiBib3gsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgb2JqZWN0czogb3V0cHV0cyxcbiAgICBhcmNzOiB0b3BvbG9neS5hcmNzLm1hcChxdWFudGl6ZUFyYylcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBuKSB7XG4gIHZhciB0LCBqID0gYXJyYXkubGVuZ3RoLCBpID0gaiAtIG47XG4gIHdoaWxlIChpIDwgLS1qKSB0ID0gYXJyYXlbaV0sIGFycmF5W2krK10gPSBhcnJheVtqXSwgYXJyYXlbal0gPSB0O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odG9wb2xvZ3ksIGFyY3MpIHtcbiAgdmFyIHN0aXRjaGVkQXJjcyA9IHt9LFxuICAgICAgZnJhZ21lbnRCeVN0YXJ0ID0ge30sXG4gICAgICBmcmFnbWVudEJ5RW5kID0ge30sXG4gICAgICBmcmFnbWVudHMgPSBbXSxcbiAgICAgIGVtcHR5SW5kZXggPSAtMTtcblxuICAvLyBTdGl0Y2ggZW1wdHkgYXJjcyBmaXJzdCwgc2luY2UgdGhleSBtYXkgYmUgc3Vic3VtZWQgYnkgb3RoZXIgYXJjcy5cbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGksIGopIHtcbiAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHQ7XG4gICAgaWYgKGFyYy5sZW5ndGggPCAzICYmICFhcmNbMV1bMF0gJiYgIWFyY1sxXVsxXSkge1xuICAgICAgdCA9IGFyY3NbKytlbXB0eUluZGV4XSwgYXJjc1tlbXB0eUluZGV4XSA9IGksIGFyY3Nbal0gPSB0O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgZSA9IGVuZHMoaSksXG4gICAgICAgIHN0YXJ0ID0gZVswXSxcbiAgICAgICAgZW5kID0gZVsxXSxcbiAgICAgICAgZiwgZztcblxuICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgIGYucHVzaChpKTtcbiAgICAgIGYuZW5kID0gZW5kO1xuICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2cuc3RhcnRdO1xuICAgICAgICB2YXIgZmcgPSBnID09PSBmID8gZiA6IGYuY29uY2F0KGcpO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZmcuc3RhcnQgPSBmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZmcuZW5kID0gZy5lbmRdID0gZmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF0pIHtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICBmLnVuc2hpZnQoaSk7XG4gICAgICBmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2cuZW5kXTtcbiAgICAgICAgdmFyIGdmID0gZyA9PT0gZiA/IGYgOiBnLmNvbmNhdChmKTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2dmLnN0YXJ0ID0gZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2dmLmVuZCA9IGYuZW5kXSA9IGdmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSBmO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmID0gW2ldO1xuICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kXSA9IGY7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBlbmRzKGkpIHtcbiAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHAwID0gYXJjWzBdLCBwMTtcbiAgICBpZiAodG9wb2xvZ3kudHJhbnNmb3JtKSBwMSA9IFswLCAwXSwgYXJjLmZvckVhY2goZnVuY3Rpb24oZHApIHsgcDFbMF0gKz0gZHBbMF0sIHAxWzFdICs9IGRwWzFdOyB9KTtcbiAgICBlbHNlIHAxID0gYXJjW2FyYy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gaSA8IDAgPyBbcDEsIHAwXSA6IFtwMCwgcDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KSB7XG4gICAgZm9yICh2YXIgayBpbiBmcmFnbWVudEJ5RW5kKSB7XG4gICAgICB2YXIgZiA9IGZyYWdtZW50QnlFbmRba107XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgZGVsZXRlIGYuc3RhcnQ7XG4gICAgICBkZWxldGUgZi5lbmQ7XG4gICAgICBmLmZvckVhY2goZnVuY3Rpb24oaSkgeyBzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldID0gMTsgfSk7XG4gICAgICBmcmFnbWVudHMucHVzaChmKTtcbiAgICB9XG4gIH1cblxuICBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpO1xuICBmbHVzaChmcmFnbWVudEJ5U3RhcnQsIGZyYWdtZW50QnlFbmQpO1xuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkgeyBpZiAoIXN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0pIGZyYWdtZW50cy5wdXNoKFtpXSk7IH0pO1xuXG4gIHJldHVybiBmcmFnbWVudHM7XG59XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICB2YXIgeDAsXG4gICAgICB5MCxcbiAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaSkge1xuICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgdmFyIGogPSAyLCBuID0gaW5wdXQubGVuZ3RoLCBvdXRwdXQgPSBuZXcgQXJyYXkobik7XG4gICAgb3V0cHV0WzBdID0gKHgwICs9IGlucHV0WzBdKSAqIGt4ICsgZHg7XG4gICAgb3V0cHV0WzFdID0gKHkwICs9IGlucHV0WzFdKSAqIGt5ICsgZHk7XG4gICAgd2hpbGUgKGogPCBuKSBvdXRwdXRbal0gPSBpbnB1dFtqXSwgKytqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICB2YXIgeDAsXG4gICAgICB5MCxcbiAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaSkge1xuICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgdmFyIGogPSAyLFxuICAgICAgICBuID0gaW5wdXQubGVuZ3RoLFxuICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHgxID0gTWF0aC5yb3VuZCgoaW5wdXRbMF0gLSBkeCkgLyBreCksXG4gICAgICAgIHkxID0gTWF0aC5yb3VuZCgoaW5wdXRbMV0gLSBkeSkgLyBreSk7XG4gICAgb3V0cHV0WzBdID0geDEgLSB4MCwgeDAgPSB4MTtcbiAgICBvdXRwdXRbMV0gPSB5MSAtIHkwLCB5MCA9IHkxO1xuICAgIHdoaWxlIChqIDwgbikgb3V0cHV0W2pdID0gaW5wdXRbal0sICsrajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuIiwiZXhwb3J0IHtcbiAgZG9tQ2FudmFzIGFzIGRvbUNhbnZhcyxcbiAgZG9tQ2FudmFzIGFzIGNhbnZhcyxcbiAgZG9tSW1hZ2UgYXMgaW1hZ2Vcbn0gZnJvbSAnLi9zcmMvZG9tQ2FudmFzJztcbiIsImV4cG9ydCBmdW5jdGlvbiBkb21DYW52YXModywgaCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB7XG4gICAgY29uc3QgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGlmIChjICYmIGMuZ2V0Q29udGV4dCkge1xuICAgICAgYy53aWR0aCA9IHc7XG4gICAgICBjLmhlaWdodCA9IGg7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBjb25zdCBkb21JbWFnZSA9ICgpID0+XG4gIHR5cGVvZiBJbWFnZSAhPT0gJ3VuZGVmaW5lZCcgPyBJbWFnZSA6IG51bGw7XG4iLCJpbXBvcnQgeyBwZXJtdXRlLCBiaXNlY3RMZWZ0LCBiaXNlY3RSaWdodCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5jb25zdCBhcnJheTggPSBuID0+IG5ldyBVaW50OEFycmF5KG4pO1xuY29uc3QgYXJyYXkxNiA9IG4gPT4gbmV3IFVpbnQxNkFycmF5KG4pO1xuY29uc3QgYXJyYXkzMiA9IG4gPT4gbmV3IFVpbnQzMkFycmF5KG4pO1xuXG4vKipcbiAqIE1haW50YWlucyBDcm9zc0ZpbHRlciBzdGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiBCaXRtYXBzKCkge1xuICBsZXQgd2lkdGggPSA4LFxuICAgICAgZGF0YSA9IFtdLFxuICAgICAgc2VlbiA9IGFycmF5MzIoMCksXG4gICAgICBjdXJyID0gYXJyYXkoMCwgd2lkdGgpLFxuICAgICAgcHJldiA9IGFycmF5KDAsIHdpZHRoKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiAoKSA9PiBkYXRhLFxuICAgIHNlZW46ICgpID0+IHNlZW4gPSBsZW5ndGhlbihzZWVuLCBkYXRhLmxlbmd0aCksXG5cbiAgICBhZGQoYXJyYXkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gZGF0YS5sZW5ndGgsIG4gPSBhcnJheS5sZW5ndGgsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdCA9IGFycmF5W2ldO1xuICAgICAgICB0Ll9pbmRleCA9IGorKztcbiAgICAgICAgZGF0YS5wdXNoKHQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmUobnVtLCBtYXApIHtcbiAgICAgIC8vIG1hcDogaW5kZXggLT4gYm9vbGVhbiAodHJ1ZSA9PiByZW1vdmUpXG4gICAgICBjb25zdCBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBjb3B5ID0gQXJyYXkobiAtIG51bSksXG4gICAgICAgICAgICByZWluZGV4ID0gZGF0YTsgLy8gcmV1c2Ugb2xkIGRhdGEgYXJyYXkgZm9yIGluZGV4IG1hcFxuXG4gICAgICBsZXQgdCwgaSwgajsgLy8gc2VlayBmb3J3YXJkIHRvIGZpcnN0IHJlbW92YWxcblxuICAgICAgZm9yIChpID0gMDsgIW1hcFtpXSAmJiBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvcHlbaV0gPSBkYXRhW2ldO1xuICAgICAgICByZWluZGV4W2ldID0gaTtcbiAgICAgIH0gLy8gY29uZGVuc2UgYXJyYXlzXG5cblxuICAgICAgZm9yIChqID0gaTsgaSA8IG47ICsraSkge1xuICAgICAgICB0ID0gZGF0YVtpXTtcblxuICAgICAgICBpZiAoIW1hcFtpXSkge1xuICAgICAgICAgIHJlaW5kZXhbaV0gPSBqO1xuICAgICAgICAgIGN1cnJbal0gPSBjdXJyW2ldO1xuICAgICAgICAgIHByZXZbal0gPSBwcmV2W2ldO1xuICAgICAgICAgIGNvcHlbal0gPSB0O1xuICAgICAgICAgIHQuX2luZGV4ID0gaisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlaW5kZXhbaV0gPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJbaV0gPSAwOyAvLyBjbGVhciB1bnVzZWQgYml0c1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gY29weTtcbiAgICAgIHJldHVybiByZWluZGV4O1xuICAgIH0sXG5cbiAgICBzaXplOiAoKSA9PiBkYXRhLmxlbmd0aCxcbiAgICBjdXJyOiAoKSA9PiBjdXJyLFxuICAgIHByZXY6ICgpID0+IHByZXYsXG4gICAgcmVzZXQ6IGsgPT4gcHJldltrXSA9IGN1cnJba10sXG4gICAgYWxsOiAoKSA9PiB3aWR0aCA8IDB4MTAxID8gMHhmZiA6IHdpZHRoIDwgMHgxMDAwMSA/IDB4ZmZmZiA6IDB4ZmZmZmZmZmYsXG5cbiAgICBzZXQoaywgb25lKSB7XG4gICAgICBjdXJyW2tdIHw9IG9uZTtcbiAgICB9LFxuXG4gICAgY2xlYXIoaywgb25lKSB7XG4gICAgICBjdXJyW2tdICY9IH5vbmU7XG4gICAgfSxcblxuICAgIHJlc2l6ZShuLCBtKSB7XG4gICAgICBjb25zdCBrID0gY3Vyci5sZW5ndGg7XG5cbiAgICAgIGlmIChuID4gayB8fCBtID4gd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heChtLCB3aWR0aCk7XG4gICAgICAgIGN1cnIgPSBhcnJheShuLCB3aWR0aCwgY3Vycik7XG4gICAgICAgIHByZXYgPSBhcnJheShuLCB3aWR0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG59XG5cbmZ1bmN0aW9uIGxlbmd0aGVuKGFycmF5LCBsZW5ndGgsIGNvcHkpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA+PSBsZW5ndGgpIHJldHVybiBhcnJheTtcbiAgY29weSA9IGNvcHkgfHwgbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG4gIGNvcHkuc2V0KGFycmF5KTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIGFycmF5KG4sIG0sIGFycmF5KSB7XG4gIGNvbnN0IGNvcHkgPSAobSA8IDB4MTAxID8gYXJyYXk4IDogbSA8IDB4MTAwMDEgPyBhcnJheTE2IDogYXJyYXkzMikobik7XG4gIGlmIChhcnJheSkgY29weS5zZXQoYXJyYXkpO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gRGltZW5zaW9uIChpbmRleCwgaSwgcXVlcnkpIHtcbiAgY29uc3QgYml0ID0gMSA8PCBpO1xuICByZXR1cm4ge1xuICAgIG9uZTogYml0LFxuICAgIHplcm86IH5iaXQsXG4gICAgcmFuZ2U6IHF1ZXJ5LnNsaWNlKCksXG4gICAgYmlzZWN0OiBpbmRleC5iaXNlY3QsXG4gICAgaW5kZXg6IGluZGV4LmluZGV4LFxuICAgIHNpemU6IGluZGV4LnNpemUsXG5cbiAgICBvbkFkZChhZGRlZCwgY3Vycikge1xuICAgICAgY29uc3QgZGltID0gdGhpcyxcbiAgICAgICAgICAgIHJhbmdlID0gZGltLmJpc2VjdChkaW0ucmFuZ2UsIGFkZGVkLnZhbHVlKSxcbiAgICAgICAgICAgIGlkeCA9IGFkZGVkLmluZGV4LFxuICAgICAgICAgICAgbG8gPSByYW5nZVswXSxcbiAgICAgICAgICAgIGhpID0gcmFuZ2VbMV0sXG4gICAgICAgICAgICBuMSA9IGlkeC5sZW5ndGg7XG4gICAgICBsZXQgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxvOyArK2kpIGN1cnJbaWR4W2ldXSB8PSBiaXQ7XG5cbiAgICAgIGZvciAoaSA9IGhpOyBpIDwgbjE7ICsraSkgY3VycltpZHhbaV1dIHw9IGJpdDtcblxuICAgICAgcmV0dXJuIGRpbTtcbiAgICB9XG5cbiAgfTtcbn1cblxuLyoqXG4gKiBNYWludGFpbnMgYSBsaXN0IG9mIHZhbHVlcywgc29ydGVkIGJ5IGtleS5cbiAqL1xuXG5mdW5jdGlvbiBTb3J0ZWRJbmRleCgpIHtcbiAgbGV0IGluZGV4ID0gYXJyYXkzMigwKSxcbiAgICAgIHZhbHVlID0gW10sXG4gICAgICBzaXplID0gMDtcblxuICBmdW5jdGlvbiBpbnNlcnQoa2V5LCBkYXRhLCBiYXNlKSB7XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IG4wID0gc2l6ZSxcbiAgICAgICAgICBuMSA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGFkZGkgPSBhcnJheTMyKG4xKTtcbiAgICBsZXQgYWRkdiA9IEFycmF5KG4xKSxcbiAgICAgICAgb2xkdixcbiAgICAgICAgb2xkaSxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuMTsgKytpKSB7XG4gICAgICBhZGR2W2ldID0ga2V5KGRhdGFbaV0pO1xuICAgICAgYWRkaVtpXSA9IGk7XG4gICAgfVxuXG4gICAgYWRkdiA9IHNvcnQoYWRkdiwgYWRkaSk7XG5cbiAgICBpZiAobjApIHtcbiAgICAgIG9sZHYgPSB2YWx1ZTtcbiAgICAgIG9sZGkgPSBpbmRleDtcbiAgICAgIHZhbHVlID0gQXJyYXkobjAgKyBuMSk7XG4gICAgICBpbmRleCA9IGFycmF5MzIobjAgKyBuMSk7XG4gICAgICBtZXJnZShiYXNlLCBvbGR2LCBvbGRpLCBuMCwgYWRkdiwgYWRkaSwgbjEsIHZhbHVlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChiYXNlID4gMCkgZm9yIChpID0gMDsgaSA8IG4xOyArK2kpIHtcbiAgICAgICAgYWRkaVtpXSArPSBiYXNlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBhZGR2O1xuICAgICAgaW5kZXggPSBhZGRpO1xuICAgIH1cblxuICAgIHNpemUgPSBuMCArIG4xO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleDogYWRkaSxcbiAgICAgIHZhbHVlOiBhZGR2XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZShudW0sIG1hcCkge1xuICAgIC8vIG1hcDogaW5kZXggLT4gcmVtb3ZlXG4gICAgY29uc3QgbiA9IHNpemU7XG4gICAgbGV0IGlkeCwgaSwgajsgLy8gc2VlayBmb3J3YXJkIHRvIGZpcnN0IHJlbW92YWxcblxuICAgIGZvciAoaSA9IDA7ICFtYXBbaW5kZXhbaV1dICYmIGkgPCBuOyArK2kpOyAvLyBjb25kZW5zZSBpbmRleCBhbmQgdmFsdWUgYXJyYXlzXG5cblxuICAgIGZvciAoaiA9IGk7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICghbWFwW2lkeCA9IGluZGV4W2ldXSkge1xuICAgICAgICBpbmRleFtqXSA9IGlkeDtcbiAgICAgICAgdmFsdWVbal0gPSB2YWx1ZVtpXTtcbiAgICAgICAgKytqO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNpemUgPSBuIC0gbnVtO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVpbmRleChtYXApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHNpemU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGluZGV4W2ldID0gbWFwW2luZGV4W2ldXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiaXNlY3QocmFuZ2UsIGFycmF5KSB7XG4gICAgbGV0IG47XG5cbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5ID0gdmFsdWU7XG4gICAgICBuID0gc2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2Jpc2VjdExlZnQoYXJyYXksIHJhbmdlWzBdLCAwLCBuKSwgYmlzZWN0UmlnaHQoYXJyYXksIHJhbmdlWzFdLCAwLCBuKV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGluc2VydDogaW5zZXJ0LFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIGJpc2VjdDogYmlzZWN0LFxuICAgIHJlaW5kZXg6IHJlaW5kZXgsXG4gICAgaW5kZXg6ICgpID0+IGluZGV4LFxuICAgIHNpemU6ICgpID0+IHNpemVcbiAgfTtcbn1cblxuZnVuY3Rpb24gc29ydCh2YWx1ZXMsIGluZGV4KSB7XG4gIHZhbHVlcy5zb3J0LmNhbGwoaW5kZXgsIChhLCBiKSA9PiB7XG4gICAgY29uc3QgeCA9IHZhbHVlc1thXSxcbiAgICAgICAgICB5ID0gdmFsdWVzW2JdO1xuICAgIHJldHVybiB4IDwgeSA/IC0xIDogeCA+IHkgPyAxIDogMDtcbiAgfSk7XG4gIHJldHVybiBwZXJtdXRlKHZhbHVlcywgaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBtZXJnZShiYXNlLCB2YWx1ZTAsIGluZGV4MCwgbjAsIHZhbHVlMSwgaW5kZXgxLCBuMSwgdmFsdWUsIGluZGV4KSB7XG4gIGxldCBpMCA9IDAsXG4gICAgICBpMSA9IDAsXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkwIDwgbjAgJiYgaTEgPCBuMTsgKytpKSB7XG4gICAgaWYgKHZhbHVlMFtpMF0gPCB2YWx1ZTFbaTFdKSB7XG4gICAgICB2YWx1ZVtpXSA9IHZhbHVlMFtpMF07XG4gICAgICBpbmRleFtpXSA9IGluZGV4MFtpMCsrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVbaV0gPSB2YWx1ZTFbaTFdO1xuICAgICAgaW5kZXhbaV0gPSBpbmRleDFbaTErK10gKyBiYXNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBpMCA8IG4wOyArK2kwLCArK2kpIHtcbiAgICB2YWx1ZVtpXSA9IHZhbHVlMFtpMF07XG4gICAgaW5kZXhbaV0gPSBpbmRleDBbaTBdO1xuICB9XG5cbiAgZm9yICg7IGkxIDwgbjE7ICsraTEsICsraSkge1xuICAgIHZhbHVlW2ldID0gdmFsdWUxW2kxXTtcbiAgICBpbmRleFtpXSA9IGluZGV4MVtpMV0gKyBiYXNlO1xuICB9XG59XG5cbi8qKlxuICogQW4gaW5kZXhlZCBtdWx0aS1kaW1lbnNpb25hbCBmaWx0ZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IHBhcmFtcy5maWVsZHMgLSBBbiBhcnJheSBvZiBkaW1lbnNpb24gYWNjZXNzb3JzIHRvIGZpbHRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcy5xdWVyeSAtIEFuIGFycmF5IG9mIHBlci1kaW1lbnNpb24gcmFuZ2UgcXVlcmllcy5cbiAqL1xuXG5mdW5jdGlvbiBDcm9zc0ZpbHRlcihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgQml0bWFwcygpLCBwYXJhbXMpO1xuICB0aGlzLl9pbmRpY2VzID0gbnVsbDtcbiAgdGhpcy5fZGltcyA9IG51bGw7XG59XG5Dcm9zc0ZpbHRlci5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdDcm9zc0ZpbHRlcicsXG4gICdtZXRhZGF0YSc6IHt9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3F1ZXJ5JyxcbiAgICAndHlwZSc6ICdhcnJheScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAncmVxdWlyZWQnOiB0cnVlLFxuICAgICdjb250ZW50Jzoge1xuICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICdhcnJheSc6IHRydWUsXG4gICAgICAnbGVuZ3RoJzogMlxuICAgIH1cbiAgfV1cbn07XG5pbmhlcml0cyhDcm9zc0ZpbHRlciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICghdGhpcy5fZGltcykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdChfLCBwdWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbml0ID0gXy5tb2RpZmllZCgnZmllbGRzJykgfHwgXy5maWVsZHMuc29tZShmID0+IHB1bHNlLm1vZGlmaWVkKGYuZmllbGRzKSk7XG5cbiAgICAgIHJldHVybiBpbml0ID8gdGhpcy5yZWluaXQoXywgcHVsc2UpIDogdGhpcy5ldmFsKF8sIHB1bHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdChfLCBwdWxzZSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgICAgIHF1ZXJ5ID0gXy5xdWVyeSxcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyA9IHt9LFxuICAgICAgICAgIGRpbXMgPSB0aGlzLl9kaW1zID0gW10sXG4gICAgICAgICAgbSA9IHF1ZXJ5Lmxlbmd0aDtcbiAgICBsZXQgaSA9IDAsXG4gICAgICAgIGtleSxcbiAgICAgICAgaW5kZXg7IC8vIGluc3RhbnRpYXRlIGluZGljZXMgYW5kIGRpbWVuc2lvbnNcblxuICAgIGZvciAoOyBpIDwgbTsgKytpKSB7XG4gICAgICBrZXkgPSBmaWVsZHNbaV0uZm5hbWU7XG4gICAgICBpbmRleCA9IGluZGljZXNba2V5XSB8fCAoaW5kaWNlc1trZXldID0gU29ydGVkSW5kZXgoKSk7XG4gICAgICBkaW1zLnB1c2goRGltZW5zaW9uKGluZGV4LCBpLCBxdWVyeVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV2YWwoXywgcHVsc2UpO1xuICB9LFxuXG4gIHJlaW5pdChfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dHB1dCA9IHB1bHNlLm1hdGVyaWFsaXplKCkuZm9yaygpLFxuICAgICAgICAgIGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgICAgIHF1ZXJ5ID0gXy5xdWVyeSxcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgICAgICBiaXRzID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBjdXJyID0gYml0cy5jdXJyKCksXG4gICAgICAgICAgcHJldiA9IGJpdHMucHJldigpLFxuICAgICAgICAgIGFsbCA9IGJpdHMuYWxsKCksXG4gICAgICAgICAgb3V0ID0gb3V0cHV0LnJlbSA9IG91dHB1dC5hZGQsXG4gICAgICAgICAgbW9kID0gb3V0cHV0Lm1vZCxcbiAgICAgICAgICBtID0gcXVlcnkubGVuZ3RoLFxuICAgICAgICAgIGFkZHMgPSB7fTtcbiAgICBsZXQgYWRkLCBpbmRleCwga2V5LCBtb2RzLCByZW1NYXAsIG1vZE1hcCwgaSwgbiwgZjsgLy8gc2V0IHByZXYgdG8gY3VycmVudCBzdGF0ZVxuXG4gICAgcHJldi5zZXQoY3Vycik7IC8vIGlmIHB1bHNlIGhhcyByZW1vdmUgdHVwbGVzLCBwcm9jZXNzIHRoZW0gZmlyc3RcblxuICAgIGlmIChwdWxzZS5yZW0ubGVuZ3RoKSB7XG4gICAgICByZW1NYXAgPSB0aGlzLnJlbW92ZShfLCBwdWxzZSwgb3V0cHV0KTtcbiAgICB9IC8vIGlmIHB1bHNlIGhhcyBhZGRlZCB0dXBsZXMsIGFkZCB0aGVtIHRvIHN0YXRlXG5cblxuICAgIGlmIChwdWxzZS5hZGQubGVuZ3RoKSB7XG4gICAgICBiaXRzLmFkZChwdWxzZS5hZGQpO1xuICAgIH0gLy8gaWYgcHVsc2UgaGFzIG1vZGlmaWVkIHR1cGxlcywgY3JlYXRlIGFuIGluZGV4IG1hcFxuXG5cbiAgICBpZiAocHVsc2UubW9kLmxlbmd0aCkge1xuICAgICAgbW9kTWFwID0ge307XG5cbiAgICAgIGZvciAobW9kcyA9IHB1bHNlLm1vZCwgaSA9IDAsIG4gPSBtb2RzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBtb2RNYXBbbW9kc1tpXS5faW5kZXhdID0gMTtcbiAgICAgIH1cbiAgICB9IC8vIHJlLWluaXRpYWxpemUgaW5kaWNlcyBhcyBuZWVkZWQsIHVwZGF0ZSBjdXJyIGJpdG1hcFxuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICBmID0gZmllbGRzW2ldO1xuXG4gICAgICBpZiAoIWRpbXNbaV0gfHwgXy5tb2RpZmllZCgnZmllbGRzJywgaSkgfHwgcHVsc2UubW9kaWZpZWQoZi5maWVsZHMpKSB7XG4gICAgICAgIGtleSA9IGYuZm5hbWU7XG5cbiAgICAgICAgaWYgKCEoYWRkID0gYWRkc1trZXldKSkge1xuICAgICAgICAgIGluZGljZXNba2V5XSA9IGluZGV4ID0gU29ydGVkSW5kZXgoKTtcbiAgICAgICAgICBhZGRzW2tleV0gPSBhZGQgPSBpbmRleC5pbnNlcnQoZiwgcHVsc2Uuc291cmNlLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbXNbaV0gPSBEaW1lbnNpb24oaW5kZXgsIGksIHF1ZXJ5W2ldKS5vbkFkZChhZGQsIGN1cnIpO1xuICAgICAgfVxuICAgIH0gLy8gdmlzaXQgZWFjaCB0dXBsZVxuICAgIC8vIGlmIGZpbHRlciBzdGF0ZSBjaGFuZ2VkLCBwdXNoIGluZGV4IHRvIGFkZC9yZW1cbiAgICAvLyBlbHNlIGlmIGluIG1vZCBhbmQgcGFzc2VzIGEgZmlsdGVyLCBwdXNoIGluZGV4IHRvIG1vZFxuXG5cbiAgICBmb3IgKGkgPSAwLCBuID0gYml0cy5kYXRhKCkubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAocmVtTWFwW2ldKSB7XG4gICAgICAgIC8vIHNraXAgaWYgcmVtb3ZlZCB0dXBsZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAocHJldltpXSAhPT0gY3VycltpXSkge1xuICAgICAgICAvLyBhZGQgaWYgc3RhdGUgY2hhbmdlZFxuICAgICAgICBvdXQucHVzaChpKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kTWFwW2ldICYmIGN1cnJbaV0gIT09IGFsbCkge1xuICAgICAgICAvLyBvdGhlcndpc2UsIHBhc3MgbW9kcyB0aHJvdWdoXG4gICAgICAgIG1vZC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJpdHMubWFzayA9ICgxIDw8IG0pIC0gMTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIGV2YWwoXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBwdWxzZS5tYXRlcmlhbGl6ZSgpLmZvcmsoKSxcbiAgICAgICAgICBtID0gdGhpcy5fZGltcy5sZW5ndGg7XG4gICAgbGV0IG1hc2sgPSAwO1xuXG4gICAgaWYgKHB1bHNlLnJlbS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtb3ZlKF8sIHB1bHNlLCBvdXRwdXQpO1xuICAgICAgbWFzayB8PSAoMSA8PCBtKSAtIDE7XG4gICAgfVxuXG4gICAgaWYgKF8ubW9kaWZpZWQoJ3F1ZXJ5JykgJiYgIV8ubW9kaWZpZWQoJ2ZpZWxkcycpKSB7XG4gICAgICBtYXNrIHw9IHRoaXMudXBkYXRlKF8sIHB1bHNlLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIGlmIChwdWxzZS5hZGQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluc2VydChfLCBwdWxzZSwgb3V0cHV0KTtcbiAgICAgIG1hc2sgfD0gKDEgPDwgbSkgLSAxO1xuICAgIH1cblxuICAgIGlmIChwdWxzZS5tb2QubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1vZGlmeShwdWxzZSwgb3V0cHV0KTtcbiAgICAgIG1hc2sgfD0gKDEgPDwgbSkgLSAxO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUubWFzayA9IG1hc2s7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcblxuICBpbnNlcnQoXywgcHVsc2UsIG91dHB1dCkge1xuICAgIGNvbnN0IHR1cGxlcyA9IHB1bHNlLmFkZCxcbiAgICAgICAgICBiaXRzID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyxcbiAgICAgICAgICBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgICAgICBhZGRzID0ge30sXG4gICAgICAgICAgb3V0ID0gb3V0cHV0LmFkZCxcbiAgICAgICAgICBuID0gYml0cy5zaXplKCkgKyB0dXBsZXMubGVuZ3RoLFxuICAgICAgICAgIG0gPSBkaW1zLmxlbmd0aDtcbiAgICBsZXQgayA9IGJpdHMuc2l6ZSgpLFxuICAgICAgICBqLFxuICAgICAgICBrZXksXG4gICAgICAgIGFkZDsgLy8gcmVzaXplIGJpdG1hcHMgYW5kIGFkZCB0dXBsZXMgYXMgbmVlZGVkXG5cbiAgICBiaXRzLnJlc2l6ZShuLCBtKTtcbiAgICBiaXRzLmFkZCh0dXBsZXMpO1xuICAgIGNvbnN0IGN1cnIgPSBiaXRzLmN1cnIoKSxcbiAgICAgICAgICBwcmV2ID0gYml0cy5wcmV2KCksXG4gICAgICAgICAgYWxsID0gYml0cy5hbGwoKTsgLy8gYWRkIHRvIGRpbWVuc2lvbmFsIGluZGljZXNcblxuICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGtleSA9IGZpZWxkc1tqXS5mbmFtZTtcbiAgICAgIGFkZCA9IGFkZHNba2V5XSB8fCAoYWRkc1trZXldID0gaW5kaWNlc1trZXldLmluc2VydChmaWVsZHNbal0sIHR1cGxlcywgaykpO1xuICAgICAgZGltc1tqXS5vbkFkZChhZGQsIGN1cnIpO1xuICAgIH0gLy8gc2V0IHByZXZpb3VzIGZpbHRlcnMsIG91dHB1dCBpZiBwYXNzZXMgYXQgbGVhc3Qgb25lIGZpbHRlclxuXG5cbiAgICBmb3IgKDsgayA8IG47ICsraykge1xuICAgICAgcHJldltrXSA9IGFsbDtcbiAgICAgIGlmIChjdXJyW2tdICE9PSBhbGwpIG91dC5wdXNoKGspO1xuICAgIH1cbiAgfSxcblxuICBtb2RpZnkocHVsc2UsIG91dHB1dCkge1xuICAgIGNvbnN0IG91dCA9IG91dHB1dC5tb2QsXG4gICAgICAgICAgYml0cyA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgY3VyciA9IGJpdHMuY3VycigpLFxuICAgICAgICAgIGFsbCA9IGJpdHMuYWxsKCksXG4gICAgICAgICAgdHVwbGVzID0gcHVsc2UubW9kO1xuICAgIGxldCBpLCBuLCBrO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IHR1cGxlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGsgPSB0dXBsZXNbaV0uX2luZGV4O1xuICAgICAgaWYgKGN1cnJba10gIT09IGFsbCkgb3V0LnB1c2goayk7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZShfLCBwdWxzZSwgb3V0cHV0KSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuX2luZGljZXMsXG4gICAgICAgICAgYml0cyA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgY3VyciA9IGJpdHMuY3VycigpLFxuICAgICAgICAgIHByZXYgPSBiaXRzLnByZXYoKSxcbiAgICAgICAgICBhbGwgPSBiaXRzLmFsbCgpLFxuICAgICAgICAgIG1hcCA9IHt9LFxuICAgICAgICAgIG91dCA9IG91dHB1dC5yZW0sXG4gICAgICAgICAgdHVwbGVzID0gcHVsc2UucmVtO1xuICAgIGxldCBpLCBuLCBrLCBmOyAvLyBwcm9jZXNzIHR1cGxlcywgb3V0cHV0IGlmIHBhc3NlcyBhdCBsZWFzdCBvbmUgZmlsdGVyXG5cbiAgICBmb3IgKGkgPSAwLCBuID0gdHVwbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgayA9IHR1cGxlc1tpXS5faW5kZXg7XG4gICAgICBtYXBba10gPSAxOyAvLyBidWlsZCBpbmRleCBtYXBcblxuICAgICAgcHJldltrXSA9IGYgPSBjdXJyW2tdO1xuICAgICAgY3VycltrXSA9IGFsbDtcbiAgICAgIGlmIChmICE9PSBhbGwpIG91dC5wdXNoKGspO1xuICAgIH0gLy8gcmVtb3ZlIGZyb20gZGltZW5zaW9uYWwgaW5kaWNlc1xuXG5cbiAgICBmb3IgKGsgaW4gaW5kaWNlcykge1xuICAgICAgaW5kaWNlc1trXS5yZW1vdmUobiwgbWFwKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlaW5kZXgocHVsc2UsIG4sIG1hcCk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfSxcblxuICAvLyByZWluZGV4IGZpbHRlcnMgYW5kIGluZGljZXMgYWZ0ZXIgcHJvcGFnYXRpb24gY29tcGxldGVzXG4gIHJlaW5kZXgocHVsc2UsIG51bSwgbWFwKSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuX2luZGljZXMsXG4gICAgICAgICAgYml0cyA9IHRoaXMudmFsdWU7XG4gICAgcHVsc2UucnVuQWZ0ZXIoKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXhNYXAgPSBiaXRzLnJlbW92ZShudW0sIG1hcCk7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZGljZXMpIGluZGljZXNba2V5XS5yZWluZGV4KGluZGV4TWFwKTtcbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGUoXywgcHVsc2UsIG91dHB1dCkge1xuICAgIGNvbnN0IGRpbXMgPSB0aGlzLl9kaW1zLFxuICAgICAgICAgIHF1ZXJ5ID0gXy5xdWVyeSxcbiAgICAgICAgICBzdGFtcCA9IHB1bHNlLnN0YW1wLFxuICAgICAgICAgIG0gPSBkaW1zLmxlbmd0aDtcbiAgICBsZXQgbWFzayA9IDAsXG4gICAgICAgIGksXG4gICAgICAgIHE7IC8vIHN1cnZleSBob3cgbWFueSBxdWVyaWVzIGhhdmUgY2hhbmdlZFxuXG4gICAgb3V0cHV0LmZpbHRlcnMgPSAwO1xuXG4gICAgZm9yIChxID0gMDsgcSA8IG07ICsrcSkge1xuICAgICAgaWYgKF8ubW9kaWZpZWQoJ3F1ZXJ5JywgcSkpIHtcbiAgICAgICAgaSA9IHE7XG4gICAgICAgICsrbWFzaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gMSkge1xuICAgICAgLy8gb25seSBvbmUgcXVlcnkgY2hhbmdlZCwgdXNlIG1vcmUgZWZmaWNpZW50IHVwZGF0ZVxuICAgICAgbWFzayA9IGRpbXNbaV0ub25lO1xuICAgICAgdGhpcy5pbmNyZW1lbnRPbmUoZGltc1tpXSwgcXVlcnlbaV0sIG91dHB1dC5hZGQsIG91dHB1dC5yZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtdWx0aXBsZSBxdWVyaWVzIGNoYW5nZWQsIHBlcmZvcm0gZnVsbCByZWNvcmQga2VlcGluZ1xuICAgICAgZm9yIChxID0gMCwgbWFzayA9IDA7IHEgPCBtOyArK3EpIHtcbiAgICAgICAgaWYgKCFfLm1vZGlmaWVkKCdxdWVyeScsIHEpKSBjb250aW51ZTtcbiAgICAgICAgbWFzayB8PSBkaW1zW3FdLm9uZTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRBbGwoZGltc1txXSwgcXVlcnlbcV0sIHN0YW1wLCBvdXRwdXQuYWRkKTtcbiAgICAgICAgb3V0cHV0LnJlbSA9IG91dHB1dC5hZGQ7IC8vIGR1cGxpY2F0ZSBhZGQvcmVtIGZvciBkb3duc3RyZWFtIHJlc29sdmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFzaztcbiAgfSxcblxuICBpbmNyZW1lbnRBbGwoZGltLCBxdWVyeSwgc3RhbXAsIG91dCkge1xuICAgIGNvbnN0IGJpdHMgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIHNlZW4gPSBiaXRzLnNlZW4oKSxcbiAgICAgICAgICBjdXJyID0gYml0cy5jdXJyKCksXG4gICAgICAgICAgcHJldiA9IGJpdHMucHJldigpLFxuICAgICAgICAgIGluZGV4ID0gZGltLmluZGV4KCksXG4gICAgICAgICAgb2xkID0gZGltLmJpc2VjdChkaW0ucmFuZ2UpLFxuICAgICAgICAgIHJhbmdlID0gZGltLmJpc2VjdChxdWVyeSksXG4gICAgICAgICAgbG8xID0gcmFuZ2VbMF0sXG4gICAgICAgICAgaGkxID0gcmFuZ2VbMV0sXG4gICAgICAgICAgbG8wID0gb2xkWzBdLFxuICAgICAgICAgIGhpMCA9IG9sZFsxXSxcbiAgICAgICAgICBvbmUgPSBkaW0ub25lO1xuICAgIGxldCBpLCBqLCBrOyAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBsbyBpbmRleC5cblxuICAgIGlmIChsbzEgPCBsbzApIHtcbiAgICAgIGZvciAoaSA9IGxvMSwgaiA9IE1hdGgubWluKGxvMCwgaGkxKTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG5cbiAgICAgICAgaWYgKHNlZW5ba10gIT09IHN0YW1wKSB7XG4gICAgICAgICAgcHJldltrXSA9IGN1cnJba107XG4gICAgICAgICAgc2VlbltrXSA9IHN0YW1wO1xuICAgICAgICAgIG91dC5wdXNoKGspO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycltrXSBePSBvbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsbzEgPiBsbzApIHtcbiAgICAgIGZvciAoaSA9IGxvMCwgaiA9IE1hdGgubWluKGxvMSwgaGkwKTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG5cbiAgICAgICAgaWYgKHNlZW5ba10gIT09IHN0YW1wKSB7XG4gICAgICAgICAgcHJldltrXSA9IGN1cnJba107XG4gICAgICAgICAgc2VlbltrXSA9IHN0YW1wO1xuICAgICAgICAgIG91dC5wdXNoKGspO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycltrXSBePSBvbmU7XG4gICAgICB9XG4gICAgfSAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBoaSBpbmRleC5cblxuXG4gICAgaWYgKGhpMSA+IGhpMCkge1xuICAgICAgZm9yIChpID0gTWF0aC5tYXgobG8xLCBoaTApLCBqID0gaGkxOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcblxuICAgICAgICBpZiAoc2VlbltrXSAhPT0gc3RhbXApIHtcbiAgICAgICAgICBwcmV2W2tdID0gY3VycltrXTtcbiAgICAgICAgICBzZWVuW2tdID0gc3RhbXA7XG4gICAgICAgICAgb3V0LnB1c2goayk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhpMSA8IGhpMCkge1xuICAgICAgZm9yIChpID0gTWF0aC5tYXgobG8wLCBoaTEpLCBqID0gaGkwOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcblxuICAgICAgICBpZiAoc2VlbltrXSAhPT0gc3RhbXApIHtcbiAgICAgICAgICBwcmV2W2tdID0gY3VycltrXTtcbiAgICAgICAgICBzZWVuW2tdID0gc3RhbXA7XG4gICAgICAgICAgb3V0LnB1c2goayk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaW0ucmFuZ2UgPSBxdWVyeS5zbGljZSgpO1xuICB9LFxuXG4gIGluY3JlbWVudE9uZShkaW0sIHF1ZXJ5LCBhZGQsIHJlbSkge1xuICAgIGNvbnN0IGJpdHMgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIGN1cnIgPSBiaXRzLmN1cnIoKSxcbiAgICAgICAgICBpbmRleCA9IGRpbS5pbmRleCgpLFxuICAgICAgICAgIG9sZCA9IGRpbS5iaXNlY3QoZGltLnJhbmdlKSxcbiAgICAgICAgICByYW5nZSA9IGRpbS5iaXNlY3QocXVlcnkpLFxuICAgICAgICAgIGxvMSA9IHJhbmdlWzBdLFxuICAgICAgICAgIGhpMSA9IHJhbmdlWzFdLFxuICAgICAgICAgIGxvMCA9IG9sZFswXSxcbiAgICAgICAgICBoaTAgPSBvbGRbMV0sXG4gICAgICAgICAgb25lID0gZGltLm9uZTtcbiAgICBsZXQgaSwgaiwgazsgLy8gRmFzdCBpbmNyZW1lbnRhbCB1cGRhdGUgYmFzZWQgb24gcHJldmlvdXMgbG8gaW5kZXguXG5cbiAgICBpZiAobG8xIDwgbG8wKSB7XG4gICAgICBmb3IgKGkgPSBsbzEsIGogPSBNYXRoLm1pbihsbzAsIGhpMSk7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgayA9IGluZGV4W2ldO1xuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgICAgYWRkLnB1c2goayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsbzEgPiBsbzApIHtcbiAgICAgIGZvciAoaSA9IGxvMCwgaiA9IE1hdGgubWluKGxvMSwgaGkwKTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgICByZW0ucHVzaChrKTtcbiAgICAgIH1cbiAgICB9IC8vIEZhc3QgaW5jcmVtZW50YWwgdXBkYXRlIGJhc2VkIG9uIHByZXZpb3VzIGhpIGluZGV4LlxuXG5cbiAgICBpZiAoaGkxID4gaGkwKSB7XG4gICAgICBmb3IgKGkgPSBNYXRoLm1heChsbzEsIGhpMCksIGogPSBoaTE7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgayA9IGluZGV4W2ldO1xuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgICAgYWRkLnB1c2goayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoaTEgPCBoaTApIHtcbiAgICAgIGZvciAoaSA9IE1hdGgubWF4KGxvMCwgaGkxKSwgaiA9IGhpMDsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgICByZW0ucHVzaChrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaW0ucmFuZ2UgPSBxdWVyeS5zbGljZSgpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFNlbGVjdGl2ZWx5IGZpbHRlcnMgdHVwbGVzIGJ5IHJlc29sdmluZyBhZ2FpbnN0IGEgZmlsdGVyIGJpdG1hcC5cbiAqIFVzZWZ1bCBmb3IgcHJvY2Vzc2luZyB0aGUgb3V0cHV0IG9mIGEgY3Jvc3MtZmlsdGVyIHRyYW5zZm9ybS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5pZ25vcmUgLSBBIGJpdCBtYXNrIGluZGljYXRpbmcgd2hpY2ggZmlsdGVycyB0byBpZ25vcmUuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmZpbHRlciAtIFRoZSBwZXItdHVwbGUgZmlsdGVyIGJpdG1hcHMuIFR5cGljYWxseSB0aGlzXG4gKiAgIHBhcmFtZXRlciB2YWx1ZSBpcyBhIHJlZmVyZW5jZSB0byBhIHtAbGluayBDcm9zc0ZpbHRlcn0gdHJhbnNmb3JtLlxuICovXG5cbmZ1bmN0aW9uIFJlc29sdmVGaWx0ZXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5SZXNvbHZlRmlsdGVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1Jlc29sdmVGaWx0ZXInLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnaWdub3JlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdyZXF1aXJlZCc6IHRydWUsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0EgYml0IG1hc2sgaW5kaWNhdGluZyB3aGljaCBmaWx0ZXJzIHRvIGlnbm9yZS4nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWx0ZXInLFxuICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZSxcbiAgICAnZGVzY3JpcHRpb24nOiAnUGVyLXR1cGxlIGZpbHRlciBiaXRtYXBzIGZyb20gYSBDcm9zc0ZpbHRlciB0cmFuc2Zvcm0uJ1xuICB9XVxufTtcbmluaGVyaXRzKFJlc29sdmVGaWx0ZXIsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBpZ25vcmUgPSB+KF8uaWdub3JlIHx8IDApLFxuICAgICAgICAgIC8vIGJpdCBtYXNrIHdoZXJlIHplcm9zIC0+IGRpbXMgdG8gaWdub3JlXG4gICAgYml0bWFwID0gXy5maWx0ZXIsXG4gICAgICAgICAgbWFzayA9IGJpdG1hcC5tYXNrOyAvLyBleGl0IGVhcmx5IGlmIG5vIHJlbGV2YW50IGZpbHRlciBjaGFuZ2VzXG5cbiAgICBpZiAoKG1hc2sgJiBpZ25vcmUpID09PSAwKSByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuXG4gICAgY29uc3Qgb3V0cHV0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLFxuICAgICAgICAgIGRhdGEgPSBiaXRtYXAuZGF0YSgpLFxuICAgICAgICAgIGN1cnIgPSBiaXRtYXAuY3VycigpLFxuICAgICAgICAgIHByZXYgPSBiaXRtYXAucHJldigpLFxuICAgICAgICAgIHBhc3MgPSBrID0+ICEoY3VycltrXSAmIGlnbm9yZSkgPyBkYXRhW2tdIDogbnVsbDsgLy8gcHJvcGFnYXRlIGFsbCBtb2QgdHVwbGVzIHRoYXQgcGFzcyB0aGUgZmlsdGVyXG5cblxuICAgIG91dHB1dC5maWx0ZXIob3V0cHV0Lk1PRCwgcGFzcyk7IC8vIGRldGVybWluZSBhZGQgJiByZW0gdHVwbGVzIHZpYSBmaWx0ZXIgZnVuY3Rpb25zXG4gICAgLy8gZm9yIGVmZmljaWVuY3ksIHdlIGRvICpub3QqIHBvcHVsYXRlIG5ldyBhcnJheXMsXG4gICAgLy8gaW5zdGVhZCB3ZSBhZGQgZmlsdGVyIGZ1bmN0aW9ucyBhcHBsaWVkIGRvd25zdHJlYW1cblxuICAgIGlmICghKG1hc2sgJiBtYXNrIC0gMSkpIHtcbiAgICAgIC8vIG9ubHkgb25lIGZpbHRlciBjaGFuZ2VkXG4gICAgICBvdXRwdXQuZmlsdGVyKG91dHB1dC5BREQsIHBhc3MpO1xuICAgICAgb3V0cHV0LmZpbHRlcihvdXRwdXQuUkVNLCBrID0+IChjdXJyW2tdICYgaWdub3JlKSA9PT0gbWFzayA/IGRhdGFba10gOiBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbXVsdGlwbGUgZmlsdGVycyBjaGFuZ2VkXG4gICAgICBvdXRwdXQuZmlsdGVyKG91dHB1dC5BREQsIGsgPT4ge1xuICAgICAgICBjb25zdCBjID0gY3VycltrXSAmIGlnbm9yZSxcbiAgICAgICAgICAgICAgZiA9ICFjICYmIGMgXiBwcmV2W2tdICYgaWdub3JlO1xuICAgICAgICByZXR1cm4gZiA/IGRhdGFba10gOiBudWxsO1xuICAgICAgfSk7XG4gICAgICBvdXRwdXQuZmlsdGVyKG91dHB1dC5SRU0sIGsgPT4ge1xuICAgICAgICBjb25zdCBjID0gY3VycltrXSAmIGlnbm9yZSxcbiAgICAgICAgICAgICAgZiA9IGMgJiYgIShjIF4gKGMgXiBwcmV2W2tdICYgaWdub3JlKSk7XG4gICAgICAgIHJldHVybiBmID8gZGF0YVtrXSA6IG51bGw7XG4gICAgICB9KTtcbiAgICB9IC8vIGFkZCBmaWx0ZXIgdG8gc291cmNlIGRhdGEgaW4gY2FzZSBvZiByZWZsb3cuLi5cblxuXG4gICAgcmV0dXJuIG91dHB1dC5maWx0ZXIob3V0cHV0LlNPVVJDRSwgdCA9PiBwYXNzKHQuX2luZGV4KSk7XG4gIH1cblxufSk7XG5cbmV4cG9ydCB7IENyb3NzRmlsdGVyIGFzIGNyb3NzZmlsdGVyLCBSZXNvbHZlRmlsdGVyIGFzIHJlc29sdmVmaWx0ZXIgfTtcbiIsImltcG9ydCB7IGlkZW50aXR5LCBhcnJheSwgaXNGdW5jdGlvbiwgY29uc3RhbnQsIGlzQXJyYXksIGlkLCBlcnJvciwgdHJ1dGh5LCBkZWJvdW5jZSwgZXh0ZW5kLCB2aXNpdEFycmF5LCBpbmhlcml0cywgbG9nZ2VyLCBFcnJvciwgaGFzT3duUHJvcGVydHkgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgcmVhZCwgcmVzcG9uc2VUeXBlLCBsb2FkZXIgfSBmcm9tICd2ZWdhLWxvYWRlcic7XG5pbXBvcnQgeyBkZWZhdWx0TG9jYWxlIH0gZnJvbSAndmVnYS1mb3JtYXQnO1xuXG5mdW5jdGlvbiBVbmlxdWVMaXN0KGlkRnVuYykge1xuICBjb25zdCAkID0gaWRGdW5jIHx8IGlkZW50aXR5LFxuICAgICAgICBsaXN0ID0gW10sXG4gICAgICAgIGlkcyA9IHt9O1xuXG4gIGxpc3QuYWRkID0gXyA9PiB7XG4gICAgY29uc3QgaWQgPSAkKF8pO1xuXG4gICAgaWYgKCFpZHNbaWRdKSB7XG4gICAgICBpZHNbaWRdID0gMTtcbiAgICAgIGxpc3QucHVzaChfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfTtcblxuICBsaXN0LnJlbW92ZSA9IF8gPT4ge1xuICAgIGNvbnN0IGlkID0gJChfKTtcblxuICAgIGlmIChpZHNbaWRdKSB7XG4gICAgICBpZHNbaWRdID0gMDtcbiAgICAgIGNvbnN0IGlkeCA9IGxpc3QuaW5kZXhPZihfKTtcbiAgICAgIGlmIChpZHggPj0gMCkgbGlzdC5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYW5kIGF3YWl0IGEgcG90ZW50aWFsbHkgYXN5bmMgY2FsbGJhY2sgZnVuY3Rpb24uIElmXG4gKiBhbiBlcnJvciBvY2N1cnMsIHRyYXAgaXQgYW5kIHJvdXRlIHRvIERhdGFmbG93LmVycm9yLlxuICogQHBhcmFtIHtEYXRhZmxvd30gZGYgLSBUaGUgZGF0YWZsb3cgaW5zdGFuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgYW5kIHRoZW4gYXdhaXQuIFRoZSBkYXRhZmxvdyB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgc2luZ2xlXG4gKiAgIGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNDYWxsYmFjayAoZGYsIGNhbGxiYWNrKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgY2FsbGJhY2soZGYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZi5lcnJvcihlcnIpO1xuICB9XG59XG5cbmNvbnN0IFRVUExFX0lEX0tFWSA9IFN5bWJvbCgndmVnYV9pZCcpO1xubGV0IFRVUExFX0lEID0gMTtcbi8qKlxuICogQ2hlY2tzIGlmIGFuIGlucHV0IHZhbHVlIGlzIGEgcmVnaXN0ZXJlZCB0dXBsZS5cbiAqIEBwYXJhbSB7Kn0gdCAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGlucHV0IGlzIGEgdHVwbGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc1R1cGxlKHQpIHtcbiAgcmV0dXJuICEhKHQgJiYgdHVwbGVpZCh0KSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGlkIG9mIGEgdHVwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gdCAtIFRoZSBpbnB1dCB0dXBsZS5cbiAqIEByZXR1cm4geyp9IHRoZSB0dXBsZSBpZC5cbiAqL1xuXG5mdW5jdGlvbiB0dXBsZWlkKHQpIHtcbiAgcmV0dXJuIHRbVFVQTEVfSURfS0VZXTtcbn1cbi8qKlxuICogU2V0cyB0aGUgaWQgb2YgYSB0dXBsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0IC0gVGhlIGlucHV0IHR1cGxlLlxuICogQHBhcmFtIHsqfSBpZCAtIFRoZSBpZCB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJuIHtvYmplY3R9IHRoZSBpbnB1dCB0dXBsZS5cbiAqL1xuXG5mdW5jdGlvbiBzZXRpZCh0LCBpZCkge1xuICB0W1RVUExFX0lEX0tFWV0gPSBpZDtcbiAgcmV0dXJuIHQ7XG59XG4vKipcbiAqIEluZ2VzdCBhbiBvYmplY3Qgb3IgdmFsdWUgYXMgYSBkYXRhIHR1cGxlLlxuICogSWYgdGhlIGlucHV0IHZhbHVlIGlzIGFuIG9iamVjdCwgYW4gaWQgZmllbGQgd2lsbCBiZSBhZGRlZCB0byBpdC4gRm9yXG4gKiBlZmZpY2llbmN5LCB0aGUgaW5wdXQgb2JqZWN0IGlzIG1vZGlmaWVkIGRpcmVjdGx5LiBBIGNvcHkgaXMgbm90IG1hZGUuXG4gKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgYSBsaXRlcmFsLCBpdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSBuZXcgb2JqZWN0XG4gKiBpbnN0YW5jZSwgd2l0aCB0aGUgdmFsdWUgYWNjZXNzaWJsZSBhcyB0aGUgJ2RhdGEnIHByb3BlcnR5LlxuICogQHBhcmFtIGRhdHVtIC0gVGhlIHZhbHVlIHRvIGluZ2VzdC5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIGluZ2VzdGVkIGRhdGEgdHVwbGUuXG4gKi9cblxuXG5mdW5jdGlvbiBpbmdlc3QkMShkYXR1bSkge1xuICBjb25zdCB0ID0gZGF0dW0gPT09IE9iamVjdChkYXR1bSkgPyBkYXR1bSA6IHtcbiAgICBkYXRhOiBkYXR1bVxuICB9O1xuICByZXR1cm4gdHVwbGVpZCh0KSA/IHQgOiBzZXRpZCh0LCBUVVBMRV9JRCsrKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBzb3VyY2UgdHVwbGUsIHJldHVybiBhIGRlcml2ZWQgY29weS5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0IC0gVGhlIHNvdXJjZSB0dXBsZS5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIGRlcml2ZWQgdHVwbGUuXG4gKi9cblxuZnVuY3Rpb24gZGVyaXZlKHQpIHtcbiAgcmV0dXJuIHJlZGVyaXZlKHQsIGluZ2VzdCQxKHt9KSk7XG59XG4vKipcbiAqIFJlZGVyaXZlIGEgZGVyaXZlZCB0dXBsZSBieSBjb3B5aW5nIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdHVwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gdCAtIFRoZSBzb3VyY2UgdHVwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gZCAtIFRoZSBkZXJpdmVkIHR1cGxlLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgZGVyaXZlZCB0dXBsZS5cbiAqL1xuXG5mdW5jdGlvbiByZWRlcml2ZSh0LCBkKSB7XG4gIGZvciAoY29uc3QgayBpbiB0KSBkW2tdID0gdFtrXTtcblxuICByZXR1cm4gZDtcbn1cbi8qKlxuICogUmVwbGFjZSBhbiBleGlzdGluZyB0dXBsZSB3aXRoIGEgbmV3IHR1cGxlLlxuICogQHBhcmFtIHtvYmplY3R9IHQgLSBUaGUgZXhpc3RpbmcgZGF0YSB0dXBsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkIC0gVGhlIG5ldyB0dXBsZSB0aGF0IHJlcGxhY2VzIHRoZSBvbGQuXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBuZXcgdHVwbGUuXG4gKi9cblxuZnVuY3Rpb24gcmVwbGFjZSh0LCBkKSB7XG4gIHJldHVybiBzZXRpZChkLCB0dXBsZWlkKHQpKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYW4gYXVnbWVudGVkIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBzdGFibGVcbiAqIHNvcnRpbmcgYnkgdHVwbGUgaWQgd2hlbiB0aGUgZ2l2ZW4gY29tcGFyYXRvciBwcm9kdWNlcyB0aWVzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY21wIC0gVGhlIGNvbXBhcmF0b3IgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmXSAtIE9wdGlvbmFsIHR1cGxlIGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEFuIGF1Z21lbnRlZCBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIHN0YWJsZUNvbXBhcmUoY21wLCBmKSB7XG4gIHJldHVybiAhY21wID8gbnVsbCA6IGYgPyAoYSwgYikgPT4gY21wKGEsIGIpIHx8IHR1cGxlaWQoZihhKSkgLSB0dXBsZWlkKGYoYikpIDogKGEsIGIpID0+IGNtcChhLCBiKSB8fCB0dXBsZWlkKGEpIC0gdHVwbGVpZChiKTtcbn1cblxuZnVuY3Rpb24gaXNDaGFuZ2VTZXQodikge1xuICByZXR1cm4gdiAmJiB2LmNvbnN0cnVjdG9yID09PSBjaGFuZ2VzZXQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VzZXQoKSB7XG4gIGNvbnN0IGFkZCA9IFtdLFxuICAgICAgICAvLyBpbnNlcnQgdHVwbGVzXG4gIHJlbSA9IFtdLFxuICAgICAgICAvLyByZW1vdmUgdHVwbGVzXG4gIG1vZCA9IFtdLFxuICAgICAgICAvLyBtb2RpZnkgdHVwbGVzXG4gIHJlbXAgPSBbXSxcbiAgICAgICAgLy8gcmVtb3ZlIGJ5IHByZWRpY2F0ZVxuICBtb2RwID0gW107IC8vIG1vZGlmeSBieSBwcmVkaWNhdGVcblxuICBsZXQgY2xlYW4gPSBudWxsLFxuICAgICAgcmVmbG93ID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgY29uc3RydWN0b3I6IGNoYW5nZXNldCxcblxuICAgIGluc2VydCh0KSB7XG4gICAgICBjb25zdCBkID0gYXJyYXkodCksXG4gICAgICAgICAgICBuID0gZC5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBhZGQucHVzaChkW2ldKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZSh0KSB7XG4gICAgICBjb25zdCBhID0gaXNGdW5jdGlvbih0KSA/IHJlbXAgOiByZW0sXG4gICAgICAgICAgICBkID0gYXJyYXkodCksXG4gICAgICAgICAgICBuID0gZC5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBhLnB1c2goZFtpXSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtb2RpZnkodCwgZmllbGQsIHZhbHVlKSB7XG4gICAgICBjb25zdCBtID0ge1xuICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgIHZhbHVlOiBjb25zdGFudCh2YWx1ZSlcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHQpKSB7XG4gICAgICAgIG0uZmlsdGVyID0gdDtcbiAgICAgICAgbW9kcC5wdXNoKG0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbS50dXBsZSA9IHQ7XG4gICAgICAgIG1vZC5wdXNoKG0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZW5jb2RlKHQsIHNldCkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24odCkpIG1vZHAucHVzaCh7XG4gICAgICAgIGZpbHRlcjogdCxcbiAgICAgICAgZmllbGQ6IHNldFxuICAgICAgfSk7ZWxzZSBtb2QucHVzaCh7XG4gICAgICAgIHR1cGxlOiB0LFxuICAgICAgICBmaWVsZDogc2V0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhbih2YWx1ZSkge1xuICAgICAgY2xlYW4gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZWZsb3coKSB7XG4gICAgICByZWZsb3cgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHB1bHNlKHB1bHNlLCB0dXBsZXMpIHtcbiAgICAgIGNvbnN0IGN1ciA9IHt9LFxuICAgICAgICAgICAgb3V0ID0ge307XG4gICAgICBsZXQgaSwgbiwgbSwgZiwgdCwgaWQ7IC8vIGJ1aWxkIGxvb2t1cCB0YWJsZSBvZiBjdXJyZW50IHR1cGxlc1xuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gdHVwbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBjdXJbdHVwbGVpZCh0dXBsZXNbaV0pXSA9IDE7XG4gICAgICB9IC8vIHByb2Nlc3MgaW5kaXZpZHVhbCB0dXBsZXMgdG8gcmVtb3ZlXG5cblxuICAgICAgZm9yIChpID0gMCwgbiA9IHJlbS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdCA9IHJlbVtpXTtcbiAgICAgICAgY3VyW3R1cGxlaWQodCldID0gLTE7XG4gICAgICB9IC8vIHByb2Nlc3MgcHJlZGljYXRlLWJhc2VkIHJlbW92YWxzXG5cblxuICAgICAgZm9yIChpID0gMCwgbiA9IHJlbXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGYgPSByZW1wW2ldO1xuICAgICAgICB0dXBsZXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBpZiAoZih0KSkgY3VyW3R1cGxlaWQodCldID0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBwcm9jZXNzIGFsbCBhZGQgdHVwbGVzXG5cblxuICAgICAgZm9yIChpID0gMCwgbiA9IGFkZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdCA9IGFkZFtpXTtcbiAgICAgICAgaWQgPSB0dXBsZWlkKHQpO1xuXG4gICAgICAgIGlmIChjdXJbaWRdKSB7XG4gICAgICAgICAgLy8gdHVwbGUgYWxyZWFkeSByZXNpZGVzIGluIGRhdGFzZXRcbiAgICAgICAgICAvLyBpZiBmbGFnZ2VkIGZvciBib3RoIGFkZCBhbmQgcmVtb3ZlLCBjYW5jZWxcbiAgICAgICAgICBjdXJbaWRdID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0dXBsZSBkb2VzIG5vdCByZXNpZGUgaW4gZGF0YXNldCwgYWRkXG4gICAgICAgICAgcHVsc2UuYWRkLnB1c2goaW5nZXN0JDEoYWRkW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcG9wdWxhdGUgcHVsc2UgcmVtIGxpc3RcblxuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gdHVwbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB0ID0gdHVwbGVzW2ldO1xuICAgICAgICBpZiAoY3VyW3R1cGxlaWQodCldIDwgMCkgcHVsc2UucmVtLnB1c2godCk7XG4gICAgICB9IC8vIG1vZGlmeSBoZWxwZXIgbWV0aG9kXG5cblxuICAgICAgZnVuY3Rpb24gbW9kaWZ5KHQsIGYsIHYpIHtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICB0W2ZdID0gdih0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdWxzZS5lbmNvZGUgPSBmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWZsb3cpIG91dFt0dXBsZWlkKHQpXSA9IHQ7XG4gICAgICB9IC8vIHByb2Nlc3MgaW5kaXZpZHVhbCB0dXBsZXMgdG8gbW9kaWZ5XG5cblxuICAgICAgZm9yIChpID0gMCwgbiA9IG1vZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbSA9IG1vZFtpXTtcbiAgICAgICAgdCA9IG0udHVwbGU7XG4gICAgICAgIGYgPSBtLmZpZWxkO1xuICAgICAgICBpZCA9IGN1clt0dXBsZWlkKHQpXTtcblxuICAgICAgICBpZiAoaWQgPiAwKSB7XG4gICAgICAgICAgbW9kaWZ5KHQsIGYsIG0udmFsdWUpO1xuICAgICAgICAgIHB1bHNlLm1vZGlmaWVzKGYpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHByb2Nlc3MgcHJlZGljYXRlLWJhc2VkIG1vZGlmaWNhdGlvbnNcblxuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gbW9kcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbSA9IG1vZHBbaV07XG4gICAgICAgIGYgPSBtLmZpbHRlcjtcbiAgICAgICAgdHVwbGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgaWYgKGYodCkgJiYgY3VyW3R1cGxlaWQodCldID4gMCkge1xuICAgICAgICAgICAgbW9kaWZ5KHQsIG0uZmllbGQsIG0udmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHB1bHNlLm1vZGlmaWVzKG0uZmllbGQpO1xuICAgICAgfSAvLyB1cG9uIHJlZmxvdyByZXF1ZXN0LCBwb3B1bGF0ZSBtb2Qgd2l0aCBhbGwgbm9uLXJlbW92ZWQgdHVwbGVzXG4gICAgICAvLyBvdGhlcndpc2UsIHBvcHVsYXRlIG1vZCB3aXRoIG1vZGlmaWVkIHR1cGxlcyBvbmx5XG5cblxuICAgICAgaWYgKHJlZmxvdykge1xuICAgICAgICBwdWxzZS5tb2QgPSByZW0ubGVuZ3RoIHx8IHJlbXAubGVuZ3RoID8gdHVwbGVzLmZpbHRlcih0ID0+IGN1clt0dXBsZWlkKHQpXSA+IDApIDogdHVwbGVzLnNsaWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGlkIGluIG91dCkgcHVsc2UubW9kLnB1c2gob3V0W2lkXSk7XG4gICAgICB9IC8vIHNldCBwdWxzZSBnYXJiYWdlIGNvbGxlY3Rpb24gcmVxdWVzdFxuXG5cbiAgICAgIGlmIChjbGVhbiB8fCBjbGVhbiA9PSBudWxsICYmIChyZW0ubGVuZ3RoIHx8IHJlbXAubGVuZ3RoKSkge1xuICAgICAgICBwdWxzZS5jbGVhbih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB1bHNlO1xuICAgIH1cblxuICB9O1xufVxuXG5jb25zdCBDQUNIRSA9ICdfOm1vZDpfJztcbi8qKlxuICogSGFzaCB0aGF0IHRyYWNrcyBtb2RpZmljYXRpb25zIHRvIGFzc2lnbmVkIHZhbHVlcy5cbiAqIENhbGxlcnMgKm11c3QqIHVzZSB0aGUgc2V0IG1ldGhvZCB0byB1cGRhdGUgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIFBhcmFtZXRlcnMoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBDQUNIRSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB7fVxuICB9KTtcbn1cblBhcmFtZXRlcnMucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogU2V0IGEgcGFyYW1ldGVyIHZhbHVlLiBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGNoYW5nZXMsIHRoZSBwYXJhbWV0ZXJcbiAgICogd2lsbCBiZSByZWNvcmRlZCBhcyBtb2RpZmllZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIGFuIGFycmF5LXZhbHVlIHBhcmFtZXRlci4gSWdub3JlZCBpZlxuICAgKiAgIHRoZSBhcmd1bWVudCBpcyB1bmRlZmluZWQsIG51bGwgb3IgbGVzcyB0aGFuIHplcm8uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgcGFyYW1ldGVyIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gSWYgdHJ1ZSwgcmVjb3JkcyB0aGUgcGFyYW1ldGVyIGFzIG1vZGlmaWVkXG4gICAqICAgZXZlbiBpZiB0aGUgdmFsdWUgaXMgdW5jaGFuZ2VkLlxuICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJzfSAtIFRoaXMgcGFyYW1ldGVyIG9iamVjdC5cbiAgICovXG4gIHNldChuYW1lLCBpbmRleCwgdmFsdWUsIGZvcmNlKSB7XG4gICAgY29uc3QgbyA9IHRoaXMsXG4gICAgICAgICAgdiA9IG9bbmFtZV0sXG4gICAgICAgICAgbW9kID0gb1tDQUNIRV07XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICBpZiAodltpbmRleF0gIT09IHZhbHVlIHx8IGZvcmNlKSB7XG4gICAgICAgIHZbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIG1vZFtpbmRleCArICc6JyArIG5hbWVdID0gLTE7XG4gICAgICAgIG1vZFtuYW1lXSA9IC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodiAhPT0gdmFsdWUgfHwgZm9yY2UpIHtcbiAgICAgIG9bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIG1vZFtuYW1lXSA9IGlzQXJyYXkodmFsdWUpID8gMSArIHZhbHVlLmxlbmd0aCA6IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBvO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiBvbmUgb3IgbW9yZSBwYXJhbWV0ZXJzIGhhcyBiZWVuIG1vZGlmaWVkLiBJZiBpbnZva2VkIHdpdGggbm9cbiAgICogYXJndW1lbnRzLCByZXR1cm5zIHRydWUgaWYgYW55IHBhcmFtZXRlciB2YWx1ZSBoYXMgY2hhbmdlZC4gSWYgdGhlIGZpcnN0XG4gICAqIGFyZ3VtZW50IGlzIGFycmF5LCByZXR1cm5zIHRydWVzIGlmIGFueSBwYXJhbWV0ZXIgbmFtZSBpbiB0aGUgYXJyYXkgaGFzXG4gICAqIGNoYW5nZWQuIE90aGVyd2lzZSwgdGVzdHMgaWYgdGhlIGdpdmVuIG5hbWUgYW5kIG9wdGlvbmFsIGFycmF5IGluZGV4IGhhc1xuICAgKiBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBwYXJhbWV0ZXIgbmFtZSB0byB0ZXN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PXVuZGVmaW5lZF0gLSBUaGUgcGFyYW1ldGVyIGFycmF5IGluZGV4IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIGEgcXVlcmllZCBwYXJhbWV0ZXIgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgbW9kaWZpZWQobmFtZSwgaW5kZXgpIHtcbiAgICBjb25zdCBtb2QgPSB0aGlzW0NBQ0hFXTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBrIGluIG1vZCkge1xuICAgICAgICBpZiAobW9kW2tdKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShuYW1lKSkge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuYW1lLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGlmIChtb2RbbmFtZVtrXV0pIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4ICE9IG51bGwgJiYgaW5kZXggPj0gMCA/IGluZGV4ICsgMSA8IG1vZFtuYW1lXSB8fCAhIW1vZFtpbmRleCArICc6JyArIG5hbWVdIDogISFtb2RbbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgbW9kaWZpY2F0aW9uIHJlY29yZHMuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gICAqIGFsbCBwYXJhbWV0ZXJzIGFyZSBjb25zaWRlcmVkIHVubW9kaWZpZWQuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzW0NBQ0hFXSA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn07XG5cbmxldCBPUF9JRCA9IDA7XG5jb25zdCBQVUxTRSA9ICdwdWxzZScsXG4gICAgICBOT19QQVJBTVMgPSBuZXcgUGFyYW1ldGVycygpOyAvLyBCb29sZWFuIEZsYWdzXG5cbmNvbnN0IFNLSVAkMSA9IDEsXG4gICAgICBNT0RJRklFRCA9IDI7XG4vKipcbiAqIEFuIE9wZXJhdG9yIGlzIGEgcHJvY2Vzc2luZyBub2RlIGluIGEgZGF0YWZsb3cgZ3JhcGguXG4gKiBFYWNoIG9wZXJhdG9yIHN0b3JlcyBhIHZhbHVlIGFuZCBhbiBvcHRpb25hbCB2YWx1ZSB1cGRhdGUgZnVuY3Rpb24uXG4gKiBPcGVyYXRvcnMgY2FuIGFjY2VwdCBhIGhhc2ggb2YgbmFtZWQgcGFyYW1ldGVycy4gUGFyYW1ldGVyIHZhbHVlcyBjYW5cbiAqIGVpdGhlciBiZSBkaXJlY3QgKEphdmFTY3JpcHQgbGl0ZXJhbHMsIGFycmF5cywgb2JqZWN0cykgb3IgaW5kaXJlY3RcbiAqIChvdGhlciBvcGVyYXRvcnMgd2hvc2UgdmFsdWVzIHdpbGwgYmUgcHVsbGVkIGR5bmFtaWNhbGx5KS4gT3BlcmF0b3JzXG4gKiBpbmNsdWRlZCBhcyBwYXJhbWV0ZXJzIHdpbGwgaGF2ZSB0aGlzIG9wZXJhdG9yIGFkZGVkIGFzIGEgZGVwZW5kZW5jeS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSBbaW5pdF0gLSBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0LCBQdWxzZSl9IFt1cGRhdGVdIC0gQW4gdXBkYXRlIGZ1bmN0aW9uLiBVcG9uXG4gKiAgIGV2YWx1YXRpb24gb2YgdGhpcyBvcGVyYXRvciwgdGhlIHVwZGF0ZSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYW5kIHRoZVxuICogICByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBuZXcgdmFsdWUgb2YgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtib29sZWFufSBbcmVhY3Q9dHJ1ZV0gLSBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBvcGVyYXRvciBzaG91bGRcbiAqICAgbGlzdGVuIGZvciBjaGFuZ2VzIHRvIHVwc3RyZWFtIG9wZXJhdG9ycyBpbmNsdWRlZCBhcyBwYXJhbWV0ZXJzLlxuICogQHNlZSBwYXJhbWV0ZXJzXG4gKi9cblxuZnVuY3Rpb24gT3BlcmF0b3IoaW5pdCwgdXBkYXRlLCBwYXJhbXMsIHJlYWN0KSB7XG4gIHRoaXMuaWQgPSArK09QX0lEO1xuICB0aGlzLnZhbHVlID0gaW5pdDtcbiAgdGhpcy5zdGFtcCA9IC0xO1xuICB0aGlzLnJhbmsgPSAtMTtcbiAgdGhpcy5xcmFuayA9IC0xO1xuICB0aGlzLmZsYWdzID0gMDtcblxuICBpZiAodXBkYXRlKSB7XG4gICAgdGhpcy5fdXBkYXRlID0gdXBkYXRlO1xuICB9XG5cbiAgaWYgKHBhcmFtcykgdGhpcy5wYXJhbWV0ZXJzKHBhcmFtcywgcmVhY3QpO1xufVxuXG5mdW5jdGlvbiBmbGFnKGJpdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgY29uc3QgZiA9IHRoaXMuZmxhZ3M7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiAhIShmICYgYml0KTtcbiAgICB0aGlzLmZsYWdzID0gc3RhdGUgPyBmIHwgYml0IDogZiAmIH5iaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbk9wZXJhdG9yLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRhcmdldCBvcGVyYXRvcnMgZGVwZW5kZW50IG9uIHRoaXMgb3BlcmF0b3IuXG4gICAqIElmIHRoaXMgbGlzdCBkb2VzIG5vdCBleGlzdCwgaXQgaXMgY3JlYXRlZCBhbmQgdGhlbiByZXR1cm5lZC5cbiAgICogQHJldHVybiB7VW5pcXVlTGlzdH1cbiAgICovXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldHMgfHwgKHRoaXMuX3RhcmdldHMgPSBVbmlxdWVMaXN0KGlkKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoaXMgb3BlcmF0b3IuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgMSBpZiB0aGUgb3BlcmF0b3IgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICogICBhY2NvcmRpbmcgdG8gc3RyaWN0IGVxdWFsaXR5LCByZXR1cm5zIDAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgc2V0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBvcGVyYXRvciBldmFsdWF0aW9uIHNob3VsZCBiZSBza2lwcGVkIG9uIHRoZSBuZXh0IHB1bHNlLlxuICAgKiBUaGlzIG9wZXJhdG9yIHdpbGwgc3RpbGwgcHJvcGFnYXRlIGluY29taW5nIHB1bHNlcywgYnV0IGl0cyB1cGRhdGUgZnVuY3Rpb25cbiAgICogd2lsbCBub3QgYmUgaW52b2tlZC4gVGhlIHNraXAgZmxhZyBpcyByZXNldCBhZnRlciBldmVyeSBwdWxzZSwgc28gY2FsbGluZ1xuICAgKiB0aGlzIG1ldGhvZCB3aWxsIGFmZmVjdCBwcm9jZXNzaW5nIG9mIHRoZSBuZXh0IHB1bHNlIG9ubHkuXG4gICAqL1xuICBza2lwOiBmbGFnKFNLSVAkMSksXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IHRoaXMgb3BlcmF0b3IncyB2YWx1ZSBoYXMgYmVlbiBtb2RpZmllZCBvbiBpdHMgbW9zdCByZWNlbnRcbiAgICogcHVsc2UuIE5vcm1hbGx5IG1vZGlmaWNhdGlvbiBpcyBjaGVja2VkIHZpYSBzdHJpY3QgZXF1YWxpdHk7IGhvd2V2ZXIsIGluXG4gICAqIHNvbWUgY2FzZXMgaXQgaXMgbW9yZSBlZmZpY2llbnQgdG8gdXBkYXRlIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBhbiBvYmplY3QuXG4gICAqIEluIHRob3NlIGNhc2VzLCB0aGUgbW9kaWZpZWQgZmxhZyBjYW4gYmUgdXNlZCB0byB0cmlnZ2VyIHByb3BhZ2F0aW9uLiBPbmNlXG4gICAqIHNldCwgdGhlIG1vZGlmaWNhdGlvbiBmbGFnIHBlcnNpc3RzIGFjcm9zcyBwdWxzZXMgdW50aWwgdW5zZXQuIFRoZSBmbGFnIGNhblxuICAgKiBiZSB1c2VkIHdpdGggdGhlIGxhc3QgdGltZXN0YW1wIHRvIHRlc3QgaWYgYSBtb2RpZmljYXRpb24gaXMgcmVjZW50LlxuICAgKi9cbiAgbW9kaWZpZWQ6IGZsYWcoTU9ESUZJRUQpLFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBhcmUgYW5hbHl6ZWQgZm9yXG4gICAqIG9wZXJhdG9yIGluc3RhbmNlcy4gSWYgZm91bmQsIHRoaXMgb3BlcmF0b3Igd2lsbCBiZSBhZGRlZCBhcyBhIGRlcGVuZGVuY3lcbiAgICogb2YgdGhlIHBhcmFtZXRlcml6aW5nIG9wZXJhdG9yLiBPcGVyYXRvciB2YWx1ZXMgYXJlIGR5bmFtaWNhbGx5IG1hcnNoYWxsZWRcbiAgICogZnJvbSBlYWNoIG9wZXJhdG9yIHBhcmFtZXRlciBwcmlvciB0byBldmFsdWF0aW9uLiBJZiBhIHBhcmFtZXRlciB2YWx1ZSBpc1xuICAgKiBhbiBhcnJheSwgdGhlIGFycmF5IHdpbGwgYWxzbyBiZSBzZWFyY2hlZCBmb3IgT3BlcmF0b3IgaW5zdGFuY2VzLiBIb3dldmVyLFxuICAgKiB0aGUgc2VhcmNoIGRvZXMgbm90IHJlY3Vyc2UgaW50byBzdWItYXJyYXlzIG9yIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gQSBoYXNoIG9mIG9wZXJhdG9yIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlYWN0PXRydWVdIC0gQSBmbGFnIGluZGljYXRpbmcgaWYgdGhpcyBvcGVyYXRvciBzaG91bGRcbiAgICogICBhdXRvbWF0aWNhbGx5IHVwZGF0ZSAocmVhY3QpIHdoZW4gcGFyYW1ldGVyIHZhbHVlcyBjaGFuZ2UuIEluIG90aGVyIHdvcmRzLFxuICAgKiAgIHRoaXMgZmxhZyBkZXRlcm1pbmVzIGlmIHRoZSBvcGVyYXRvciByZWdpc3RlcnMgaXRzZWxmIGFzIGEgbGlzdGVuZXIgb25cbiAgICogICBhbnkgdXBzdHJlYW0gb3BlcmF0b3JzIGluY2x1ZGVkIGluIHRoZSBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0b25seT1mYWxzZV0gLSBBIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIG9wZXJhdG9yXG4gICAqICAgc2hvdWxkIGNhbGN1bGF0ZSBhbiB1cGRhdGUgb25seSB1cG9uIGl0cyBpbml0aWF0YWwgZXZhbHVhdGlvbiwgdGhlblxuICAgKiAgIGRlcmVnaXN0ZXIgZGVwZW5kZW5jaWVzIGFuZCBzdXBwcmVzcyBhbGwgZnV0dXJlIHVwZGF0ZSBpbnZvY2F0aW9ucy5cbiAgICogQHJldHVybiB7T3BlcmF0b3JbXX0gLSBBbiBhcnJheSBvZiB1cHN0cmVhbSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBwYXJhbWV0ZXJzKHBhcmFtcywgcmVhY3QsIGluaXRvbmx5KSB7XG4gICAgcmVhY3QgPSByZWFjdCAhPT0gZmFsc2U7XG4gICAgY29uc3QgYXJndmFsID0gdGhpcy5fYXJndmFsID0gdGhpcy5fYXJndmFsIHx8IG5ldyBQYXJhbWV0ZXJzKCksXG4gICAgICAgICAgYXJnb3BzID0gdGhpcy5fYXJnb3BzID0gdGhpcy5fYXJnb3BzIHx8IFtdLFxuICAgICAgICAgIGRlcHMgPSBbXTtcbiAgICBsZXQgbmFtZSwgdmFsdWUsIG4sIGk7XG5cbiAgICBjb25zdCBhZGQgPSAobmFtZSwgaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPcGVyYXRvcikge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMpIHtcbiAgICAgICAgICBpZiAocmVhY3QpIHZhbHVlLnRhcmdldHMoKS5hZGQodGhpcyk7XG4gICAgICAgICAgZGVwcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ29wcy5wdXNoKHtcbiAgICAgICAgICBvcDogdmFsdWUsXG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmd2YWwuc2V0KG5hbWUsIGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAobmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHZhbHVlID0gcGFyYW1zW25hbWVdO1xuXG4gICAgICBpZiAobmFtZSA9PT0gUFVMU0UpIHtcbiAgICAgICAgYXJyYXkodmFsdWUpLmZvckVhY2gob3AgPT4ge1xuICAgICAgICAgIGlmICghKG9wIGluc3RhbmNlb2YgT3BlcmF0b3IpKSB7XG4gICAgICAgICAgICBlcnJvcignUHVsc2UgcGFyYW1ldGVycyBtdXN0IGJlIG9wZXJhdG9yIGluc3RhbmNlcy4nKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wICE9PSB0aGlzKSB7XG4gICAgICAgICAgICBvcC50YXJnZXRzKCkuYWRkKHRoaXMpO1xuICAgICAgICAgICAgZGVwcy5wdXNoKG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhcmd2YWwuc2V0KG5hbWUsIC0xLCBBcnJheShuID0gdmFsdWUubGVuZ3RoKSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgYWRkKG5hbWUsIGksIHZhbHVlW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZChuYW1lLCAtMSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWFyc2hhbGwoKS5jbGVhcigpOyAvLyBpbml0aWFsaXplIHZhbHVlc1xuXG4gICAgaWYgKGluaXRvbmx5KSBhcmdvcHMuaW5pdG9ubHkgPSB0cnVlO1xuICAgIHJldHVybiBkZXBzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgZm9yIG1hcnNoYWxsaW5nIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqIFZpc2l0cyBlYWNoIG9wZXJhdG9yIGRlcGVuZGVuY3kgdG8gcHVsbCB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJzfSBBIFBhcmFtZXRlcnMgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIHVwZGF0ZSBmdW5jdGlvbi5cbiAgICovXG4gIG1hcnNoYWxsKHN0YW1wKSB7XG4gICAgY29uc3QgYXJndmFsID0gdGhpcy5fYXJndmFsIHx8IE5PX1BBUkFNUyxcbiAgICAgICAgICBhcmdvcHMgPSB0aGlzLl9hcmdvcHM7XG4gICAgbGV0IGl0ZW0sIGksIG9wLCBtb2Q7XG5cbiAgICBpZiAoYXJnb3BzKSB7XG4gICAgICBjb25zdCBuID0gYXJnb3BzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBpdGVtID0gYXJnb3BzW2ldO1xuICAgICAgICBvcCA9IGl0ZW0ub3A7XG4gICAgICAgIG1vZCA9IG9wLm1vZGlmaWVkKCkgJiYgb3Auc3RhbXAgPT09IHN0YW1wO1xuICAgICAgICBhcmd2YWwuc2V0KGl0ZW0ubmFtZSwgaXRlbS5pbmRleCwgb3AudmFsdWUsIG1vZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdvcHMuaW5pdG9ubHkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGl0ZW0gPSBhcmdvcHNbaV07XG4gICAgICAgICAgaXRlbS5vcC50YXJnZXRzKCkucmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXJnb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXBkYXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJndmFsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRhY2ggdGhpcyBvcGVyYXRvciBmcm9tIHRoZSBkYXRhZmxvdy5cbiAgICogVW5yZWdpc3RlcnMgbGlzdGVuZXJzIG9uIHVwc3RyZWFtIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGRldGFjaCgpIHtcbiAgICBjb25zdCBhcmdvcHMgPSB0aGlzLl9hcmdvcHM7XG4gICAgbGV0IGksIG4sIGl0ZW0sIG9wO1xuXG4gICAgaWYgKGFyZ29wcykge1xuICAgICAgZm9yIChpID0gMCwgbiA9IGFyZ29wcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaXRlbSA9IGFyZ29wc1tpXTtcbiAgICAgICAgb3AgPSBpdGVtLm9wO1xuXG4gICAgICAgIGlmIChvcC5fdGFyZ2V0cykge1xuICAgICAgICAgIG9wLl90YXJnZXRzLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gdGhlIHNvdXJjZSBhbmQgcHVsc2Ugb2JqZWN0LFxuICAgIC8vIGlmIHByZXNlbnQsIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIG9mIG9sZCBkYXRhLlxuXG5cbiAgICB0aGlzLnB1bHNlID0gbnVsbDtcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGVnYXRlIG1ldGhvZCB0byBwZXJmb3JtIG9wZXJhdG9yIHByb2Nlc3NpbmcuXG4gICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gY3VzdG9tIHByb2Nlc3NpbmcuXG4gICAqIEJ5IGRlZmF1bHQsIGl0IG1hcnNoYWxscyBwYXJhbWV0ZXJzIGFuZCBjYWxscyB0aGUgdXBkYXRlIGZ1bmN0aW9uXG4gICAqIGlmIHRoYXQgZnVuY3Rpb24gaXMgZGVmaW5lZC4gSWYgdGhlIHVwZGF0ZSBmdW5jdGlvbiBkb2VzIG5vdFxuICAgKiBjaGFuZ2UgdGhlIG9wZXJhdG9yIHZhbHVlIHRoZW4gU3RvcFByb3BhZ2F0aW9uIGlzIHJldHVybmVkLlxuICAgKiBJZiBubyB1cGRhdGUgZnVuY3Rpb24gaXMgZGVmaW5lZCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgKiBAcGFyYW0ge1B1bHNlfSBwdWxzZSAtIHRoZSBjdXJyZW50IGRhdGFmbG93IHB1bHNlLlxuICAgKiBAcmV0dXJuIFRoZSBvdXRwdXQgcHVsc2Ugb3IgU3RvcFByb3BhZ2F0aW9uLiBBIGZhbHN5IHJldHVybiB2YWx1ZVxuICAgKiAgIChpbmNsdWRpbmcgdW5kZWZpbmVkKSB3aWxsIGxldCB0aGUgaW5wdXQgcHVsc2UgcGFzcyB0aHJvdWdoLlxuICAgKi9cbiAgZXZhbHVhdGUocHVsc2UpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLm1hcnNoYWxsKHB1bHNlLnN0YW1wKSxcbiAgICAgICAgICAgIHYgPSB1cGRhdGUuY2FsbCh0aGlzLCBwYXJhbXMsIHB1bHNlKTtcbiAgICAgIHBhcmFtcy5jbGVhcigpO1xuXG4gICAgICBpZiAodiAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdjtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMubW9kaWZpZWQoKSkge1xuICAgICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUnVuIHRoaXMgb3BlcmF0b3IgZm9yIHRoZSBjdXJyZW50IHB1bHNlLiBJZiB0aGlzIG9wZXJhdG9yIGhhcyBhbHJlYWR5XG4gICAqIGJlZW4gcnVuIGF0IChvciBhZnRlcikgdGhlIHB1bHNlIHRpbWVzdGFtcCwgcmV0dXJucyBTdG9wUHJvcGFnYXRpb24uXG4gICAqIEludGVybmFsbHksIHRoaXMgbWV0aG9kIGNhbGxzIHtAbGluayBldmFsdWF0ZX0gdG8gcGVyZm9ybSBwcm9jZXNzaW5nLlxuICAgKiBJZiB7QGxpbmsgZXZhbHVhdGV9IHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgdGhlIGlucHV0IHB1bHNlIGlzIHJldHVybmVkLlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgTk9UIGJlIG92ZXJyaWRkZW4sIGluc3RlYWQgb3ZlcnJyaWRlIHtAbGluayBldmFsdWF0ZX0uXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gdGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4gdGhlIG91dHB1dCBwdWxzZSBmb3IgdGhpcyBvcGVyYXRvciAob3IgU3RvcFByb3BhZ2F0aW9uKVxuICAgKi9cbiAgcnVuKHB1bHNlKSB7XG4gICAgaWYgKHB1bHNlLnN0YW1wIDwgdGhpcy5zdGFtcCkgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICBsZXQgcnY7XG5cbiAgICBpZiAodGhpcy5za2lwKCkpIHtcbiAgICAgIHRoaXMuc2tpcChmYWxzZSk7XG4gICAgICBydiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2ID0gdGhpcy5ldmFsdWF0ZShwdWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHVsc2UgPSBydiB8fCBwdWxzZTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEFkZCBhbiBvcGVyYXRvciB0byB0aGUgZGF0YWZsb3cgZ3JhcGguIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhXG4gKiB2YXJpZXR5IG9mIGlucHV0IGFyZ3VtZW50IHR5cGVzLiBUaGUgYmFzaWMgc2lnbmF0dXJlIHN1cHBvcnRzIGFuXG4gKiBpbml0aWFsIHZhbHVlLCB1cGRhdGUgZnVuY3Rpb24gYW5kIHBhcmFtZXRlcnMuIElmIHRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAqIGlzIGFuIE9wZXJhdG9yIGluc3RhbmNlLCBpdCB3aWxsIGJlIGFkZGVkIGRpcmVjdGx5LiBJZiBpdCBpcyBhXG4gKiBjb25zdHJ1Y3RvciBmb3IgYW4gT3BlcmF0b3Igc3ViY2xhc3MsIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgaW5zdGFudGlhdGVkLlxuICogT3RoZXJ3aXNlLCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gaW5zdGFuY2UsIGl0IHdpbGwgYmUgdXNlZFxuICogYXMgdGhlIHVwZGF0ZSBmdW5jdGlvbiBhbmQgYSBudWxsIGluaXRpYWwgdmFsdWUgaXMgYXNzdW1lZC5cbiAqIEBwYXJhbSB7Kn0gaW5pdCAtIE9uZSBvZjogdGhlIG9wZXJhdG9yIHRvIGFkZCwgdGhlIGluaXRpYWwgdmFsdWUgb2ZcbiAqICAgdGhlIG9wZXJhdG9yLCBhbiBvcGVyYXRvciBjbGFzcyB0byBpbnN0YW50aWF0ZSwgb3IgYW4gdXBkYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3VwZGF0ZV0gLSBUaGUgb3BlcmF0b3IgdXBkYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIC0gVGhlIG9wZXJhdG9yIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWFjdD10cnVlXSAtIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIG9wZXJhdG9yIHNob3VsZFxuICogICBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdXBzdHJlYW0gb3BlcmF0b3JzIGluY2x1ZGVkIGFzIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJuIHtPcGVyYXRvcn0gLSBUaGUgYWRkZWQgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gYWRkIChpbml0LCB1cGRhdGUsIHBhcmFtcywgcmVhY3QpIHtcbiAgbGV0IHNoaWZ0ID0gMSxcbiAgICAgIG9wO1xuXG4gIGlmIChpbml0IGluc3RhbmNlb2YgT3BlcmF0b3IpIHtcbiAgICBvcCA9IGluaXQ7XG4gIH0gZWxzZSBpZiAoaW5pdCAmJiBpbml0LnByb3RvdHlwZSBpbnN0YW5jZW9mIE9wZXJhdG9yKSB7XG4gICAgb3AgPSBuZXcgaW5pdCgpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oaW5pdCkpIHtcbiAgICBvcCA9IG5ldyBPcGVyYXRvcihudWxsLCBpbml0KTtcbiAgfSBlbHNlIHtcbiAgICBzaGlmdCA9IDA7XG4gICAgb3AgPSBuZXcgT3BlcmF0b3IoaW5pdCwgdXBkYXRlKTtcbiAgfVxuXG4gIHRoaXMucmFuayhvcCk7XG5cbiAgaWYgKHNoaWZ0KSB7XG4gICAgcmVhY3QgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0gdXBkYXRlO1xuICB9XG5cbiAgaWYgKHBhcmFtcykgdGhpcy5jb25uZWN0KG9wLCBvcC5wYXJhbWV0ZXJzKHBhcmFtcywgcmVhY3QpKTtcbiAgdGhpcy50b3VjaChvcCk7XG4gIHJldHVybiBvcDtcbn1cblxuLyoqXG4gKiBDb25uZWN0IGEgdGFyZ2V0IG9wZXJhdG9yIGFzIGEgZGVwZW5kZW50IG9mIHNvdXJjZSBvcGVyYXRvcnMuXG4gKiBJZiBuZWNlc3NhcnksIHRoaXMgbWV0aG9kIHdpbGwgcmVyYW5rIHRoZSB0YXJnZXQgb3BlcmF0b3IgYW5kIGl0c1xuICogZGVwZW5kZW50cyB0byBlbnN1cmUgcHJvcGFnYXRpb24gcHJvY2VlZHMgaW4gYSB0b3BvbG9naWNhbGx5IHNvcnRlZCBvcmRlci5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IHRhcmdldCAtIFRoZSB0YXJnZXQgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PE9wZXJhdG9yPn0gLSBUaGUgc291cmNlIG9wZXJhdG9ycyB0aGF0IHNob3VsZCBwcm9wYWdhdGVcbiAqICAgdG8gdGhlIHRhcmdldCBvcGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gY29ubmVjdCAodGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGNvbnN0IHRhcmdldFJhbmsgPSB0YXJnZXQucmFuayxcbiAgICAgICAgbiA9IHNvdXJjZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHRhcmdldFJhbmsgPCBzb3VyY2VzW2ldLnJhbmspIHtcbiAgICAgIHRoaXMucmVyYW5rKHRhcmdldCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmxldCBTVFJFQU1fSUQgPSAwO1xuLyoqXG4gKiBNb2RlbHMgYW4gZXZlbnQgc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCwgbnVtYmVyKTogYm9vbGVhbn0gW2ZpbHRlcl0gLSBGaWx0ZXIgcHJlZGljYXRlLlxuICogICBFdmVudHMgcGFzcyB0aHJvdWdoIHdoZW4gdHJ1dGh5LCBldmVudHMgYXJlIHN1cHByZXNzZWQgd2hlbiBmYWxzeS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KTogKn0gW2FwcGx5XSAtIEFwcGxpZWQgdG8gaW5wdXQgZXZlbnRzIHRvIHByb2R1Y2VcbiAqICAgbmV3IGV2ZW50IHZhbHVlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KX0gW3JlY2VpdmVdIC0gRXZlbnQgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIHVwb24gcmVjZWlwdCBvZiBhIG5ldyBldmVudC4gVXNlIHRvIG92ZXJyaWRlIHN0YW5kYXJkIGV2ZW50IHByb2Nlc3NpbmcuXG4gKi9cblxuZnVuY3Rpb24gRXZlbnRTdHJlYW0oZmlsdGVyLCBhcHBseSwgcmVjZWl2ZSkge1xuICB0aGlzLmlkID0gKytTVFJFQU1fSUQ7XG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICBpZiAocmVjZWl2ZSkgdGhpcy5yZWNlaXZlID0gcmVjZWl2ZTtcbiAgaWYgKGZpbHRlcikgdGhpcy5fZmlsdGVyID0gZmlsdGVyO1xuICBpZiAoYXBwbHkpIHRoaXMuX2FwcGx5ID0gYXBwbHk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZXZlbnQgc3RyZWFtIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkXG4gKiAob3B0aW9uYWwpIGZpbHRlciwgYXBwbHkgYW5kIHJlY2VpdmUgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsIG51bWJlcik6IGJvb2xlYW59IFtmaWx0ZXJdIC0gRmlsdGVyIHByZWRpY2F0ZS5cbiAqICAgRXZlbnRzIHBhc3MgdGhyb3VnaCB3aGVuIHRydXRoeSwgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHdoZW4gZmFsc3kuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6ICp9IFthcHBseV0gLSBBcHBsaWVkIHRvIGlucHV0IGV2ZW50cyB0byBwcm9kdWNlXG4gKiAgIG5ldyBldmVudCB2YWx1ZXMuXG4gKiBAc2VlIEV2ZW50U3RyZWFtXG4gKi9cblxuZnVuY3Rpb24gc3RyZWFtKGZpbHRlciwgYXBwbHksIHJlY2VpdmUpIHtcbiAgcmV0dXJuIG5ldyBFdmVudFN0cmVhbShmaWx0ZXIsIGFwcGx5LCByZWNlaXZlKTtcbn1cbkV2ZW50U3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgX2ZpbHRlcjogdHJ1dGh5LFxuICBfYXBwbHk6IGlkZW50aXR5LFxuXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldHMgfHwgKHRoaXMuX3RhcmdldHMgPSBVbmlxdWVMaXN0KGlkKSk7XG4gIH0sXG5cbiAgY29uc3VtZShfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gISF0aGlzLl9jb25zdW1lO1xuICAgIHRoaXMuX2NvbnN1bWUgPSAhIV87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVjZWl2ZShldnQpIHtcbiAgICBpZiAodGhpcy5fZmlsdGVyKGV2dCkpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMudmFsdWUgPSB0aGlzLl9hcHBseShldnQpLFxuICAgICAgICAgICAgdHJnID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAgICAgIG4gPSB0cmcgPyB0cmcubGVuZ3RoIDogMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRyZ1tpXS5yZWNlaXZlKHZhbCk7XG5cbiAgICAgIGlmICh0aGlzLl9jb25zdW1lKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGZpbHRlcihmaWx0ZXIpIHtcbiAgICBjb25zdCBzID0gc3RyZWFtKGZpbHRlcik7XG4gICAgdGhpcy50YXJnZXRzKCkuYWRkKHMpO1xuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIGFwcGx5KGFwcGx5KSB7XG4gICAgY29uc3QgcyA9IHN0cmVhbShudWxsLCBhcHBseSk7XG4gICAgdGhpcy50YXJnZXRzKCkuYWRkKHMpO1xuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIG1lcmdlKCkge1xuICAgIGNvbnN0IHMgPSBzdHJlYW0oKTtcbiAgICB0aGlzLnRhcmdldHMoKS5hZGQocyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGFyZ3VtZW50c1tpXS50YXJnZXRzKCkuYWRkKHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIHRocm90dGxlKHBhdXNlKSB7XG4gICAgbGV0IHQgPSAtMTtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgaWYgKG5vdyAtIHQgPiBwYXVzZSkge1xuICAgICAgICB0ID0gbm93O1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGRlYm91bmNlKGRlbGF5KSB7XG4gICAgY29uc3QgcyA9IHN0cmVhbSgpO1xuICAgIHRoaXMudGFyZ2V0cygpLmFkZChzdHJlYW0obnVsbCwgbnVsbCwgZGVib3VuY2UoZGVsYXksIGUgPT4ge1xuICAgICAgY29uc3QgZGYgPSBlLmRhdGFmbG93O1xuICAgICAgcy5yZWNlaXZlKGUpO1xuICAgICAgaWYgKGRmICYmIGRmLnJ1bikgZGYucnVuKCk7XG4gICAgfSkpKTtcbiAgICByZXR1cm4gcztcbiAgfSxcblxuICBiZXR3ZWVuKGEsIGIpIHtcbiAgICBsZXQgYWN0aXZlID0gZmFsc2U7XG4gICAgYS50YXJnZXRzKCkuYWRkKHN0cmVhbShudWxsLCBudWxsLCAoKSA9PiBhY3RpdmUgPSB0cnVlKSk7XG4gICAgYi50YXJnZXRzKCkuYWRkKHN0cmVhbShudWxsLCBudWxsLCAoKSA9PiBhY3RpdmUgPSBmYWxzZSkpO1xuICAgIHJldHVybiB0aGlzLmZpbHRlcigoKSA9PiBhY3RpdmUpO1xuICB9LFxuXG4gIGRldGFjaCgpIHtcbiAgICAvLyBlbnN1cmVzIGNvbXBhdGliaWxpdHkgd2l0aCBvcGVyYXRvcnMgKCMyNzUzKVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIG90aGVyIHN0cmVhbXMgYW5kIGZpbHRlciBmdW5jdGlvbnMgdGhhdCBtYXlcbiAgICAvLyBiZSBib3VuZCB0byBzdWJjb250ZXh0cyB0aGF0IG5lZWQgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgdGhpcy5fZmlsdGVyID0gdHJ1dGh5O1xuICAgIHRoaXMuX3RhcmdldHMgPSBudWxsO1xuICB9XG5cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV2ZW50IHN0cmVhbSBmcm9tIGFuIGV2ZW50IHNvdXJjZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBUaGUgZXZlbnQgc291cmNlIHRvIG1vbml0b3IuIFRoZSBpbnB1dCBtdXN0XG4gKiAgc3VwcG9ydCB0aGUgYWRkRXZlbnRMaXN0ZW5lciBtZXRob2QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBib29sZWFufSBbZmlsdGVyXSAtIEV2ZW50IGZpbHRlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gW2FwcGx5XSAtIEV2ZW50IGFwcGxpY2F0aW9uIGZ1bmN0aW9uLlxuICogICBJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYW5kIHRoZSByZXN1bHQgd2lsbCBiZVxuICogICB1c2VkIGFzIHRoZSBkb3duc3RyZWFtIGV2ZW50IHZhbHVlLlxuICogQHJldHVybiB7RXZlbnRTdHJlYW19XG4gKi9cblxuZnVuY3Rpb24gZXZlbnRzIChzb3VyY2UsIHR5cGUsIGZpbHRlciwgYXBwbHkpIHtcbiAgY29uc3QgZGYgPSB0aGlzLFxuICAgICAgICBzID0gc3RyZWFtKGZpbHRlciwgYXBwbHkpLFxuICAgICAgICBzZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLmRhdGFmbG93ID0gZGY7XG5cbiAgICB0cnkge1xuICAgICAgcy5yZWNlaXZlKGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZi5lcnJvcihlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRmLnJ1bigpO1xuICAgIH1cbiAgfTtcblxuICBsZXQgc291cmNlcztcblxuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNvdXJjZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNvdXJjZSk7XG4gIH0gZWxzZSB7XG4gICAgc291cmNlcyA9IGFycmF5KHNvdXJjZSk7XG4gIH1cblxuICBjb25zdCBuID0gc291cmNlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzb3VyY2VzW2ldLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc2VuZCk7XG4gIH1cblxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gcGFyc2UoZGF0YSwgZm9ybWF0KSB7XG4gIGNvbnN0IGxvY2FsZSA9IHRoaXMubG9jYWxlKCk7XG4gIHJldHVybiByZWFkKGRhdGEsIGZvcm1hdCwgbG9jYWxlLnRpbWVQYXJzZSwgbG9jYWxlLnV0Y1BhcnNlKTtcbn1cbi8qKlxuICogSW5nZXN0cyBuZXcgZGF0YSBpbnRvIHRoZSBkYXRhZmxvdy4gRmlyc3QgcGFyc2VzIHRoZSBkYXRhIHVzaW5nIHRoZVxuICogdmVnYS1sb2FkZXIgcmVhZCBtZXRob2QsIHRoZW4gcHVsc2VzIGEgY2hhbmdlc2V0IHRvIHRoZSB0YXJnZXQgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSB0YXJnZXQgLSBUaGUgT3BlcmF0b3IgdG8gdGFyZ2V0IHdpdGggaW5nZXN0ZWQgZGF0YSxcbiAqICAgdHlwaWNhbGx5IGEgQ29sbGVjdCB0cmFuc2Zvcm0gaW5zdGFuY2UuXG4gKiBAcGFyYW0geyp9IGRhdGEgLSBUaGUgaW5wdXQgZGF0YSwgcHJpb3IgdG8gcGFyc2luZy4gRm9yIEpTT04gdGhpcyBtYXlcbiAqICAgYmUgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LiBGb3IgQ1NWLCBUU1YsIGV0YyBzaG91bGQgYmUgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gZm9ybWF0IC0gVGhlIGRhdGEgZm9ybWF0IGRlc2NyaXB0aW9uIGZvciBwYXJzaW5nXG4gKiAgIGxvYWRlZCBkYXRhLiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gdGhlIHZlZ2EtbG9hZGVyIHJlYWQgbWV0aG9kLlxuICogQHJldHVybnMge0RhdGFmbG93fVxuICovXG5cbmZ1bmN0aW9uIGluZ2VzdCh0YXJnZXQsIGRhdGEsIGZvcm1hdCkge1xuICBkYXRhID0gdGhpcy5wYXJzZShkYXRhLCBmb3JtYXQpO1xuICByZXR1cm4gdGhpcy5wdWxzZSh0YXJnZXQsIHRoaXMuY2hhbmdlc2V0KCkuaW5zZXJ0KGRhdGEpKTtcbn1cbi8qKlxuICogUmVxdWVzdCBkYXRhIGZyb20gYW4gZXh0ZXJuYWwgc291cmNlLCBwYXJzZSBpdCwgYW5kIHJldHVybiBhIFByb21pc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBmcm9tIHdoaWNoIHRvIGxvYWQgdGhlIGRhdGEuIFRoaXMgc3RyaW5nXG4gKiAgIGlzIHBhc3NlZCB0byB0aGUgdmVnYS1sb2FkZXIgbG9hZCBtZXRob2QuXG4gKiBAcGFyYW0ge29iamVjdH0gW2Zvcm1hdF0gLSBUaGUgZGF0YSBmb3JtYXQgZGVzY3JpcHRpb24gZm9yIHBhcnNpbmdcbiAqICAgbG9hZGVkIGRhdGEuIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byB0aGUgdmVnYS1sb2FkZXIgcmVhZCBtZXRob2QuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB1cG9uIGNvbXBsZXRpb24gb2YgdGhlIHJlcXVlc3QuXG4gKiAgIFRoZSByZXNvbHZlZCBvYmplY3QgY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogICAtIGRhdGE6IGFuIGFycmF5IG9mIHBhcnNlZCBkYXRhIChvciBudWxsIHVwb24gZXJyb3IpXG4gKiAgIC0gc3RhdHVzOiBhIGNvZGUgZm9yIHN1Y2Nlc3MgKDApLCBsb2FkIGZhaWwgKC0xKSwgb3IgcGFyc2UgZmFpbCAoLTIpXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIGZvcm1hdCkge1xuICBjb25zdCBkZiA9IHRoaXM7XG4gIGxldCBzdGF0dXMgPSAwLFxuICAgICAgZGF0YTtcblxuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCBkZi5sb2FkZXIoKS5sb2FkKHVybCwge1xuICAgICAgY29udGV4dDogJ2RhdGFmbG93JyxcbiAgICAgIHJlc3BvbnNlOiByZXNwb25zZVR5cGUoZm9ybWF0ICYmIGZvcm1hdC50eXBlKVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBkZi5wYXJzZShkYXRhLCBmb3JtYXQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc3RhdHVzID0gLTI7XG4gICAgICBkZi53YXJuKCdEYXRhIGluZ2VzdGlvbiBmYWlsZWQnLCB1cmwsIGVycik7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzdGF0dXMgPSAtMTtcbiAgICBkZi53YXJuKCdMb2FkaW5nIGZhaWxlZCcsIHVybCwgZXJyKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBzdGF0dXNcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWxvYWQodGFyZ2V0LCB1cmwsIGZvcm1hdCkge1xuICBjb25zdCBkZiA9IHRoaXMsXG4gICAgICAgIHBlbmRpbmcgPSBkZi5fcGVuZGluZyB8fCBsb2FkUGVuZGluZyhkZik7XG4gIHBlbmRpbmcucmVxdWVzdHMgKz0gMTtcbiAgY29uc3QgcmVzID0gYXdhaXQgZGYucmVxdWVzdCh1cmwsIGZvcm1hdCk7XG4gIGRmLnB1bHNlKHRhcmdldCwgZGYuY2hhbmdlc2V0KCkucmVtb3ZlKHRydXRoeSkuaW5zZXJ0KHJlcy5kYXRhIHx8IFtdKSk7XG4gIHBlbmRpbmcuZG9uZSgpO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBsb2FkUGVuZGluZyhkZikge1xuICBsZXQgYWNjZXB0O1xuICBjb25zdCBwZW5kaW5nID0gbmV3IFByb21pc2UoYSA9PiBhY2NlcHQgPSBhKTtcbiAgcGVuZGluZy5yZXF1ZXN0cyA9IDA7XG5cbiAgcGVuZGluZy5kb25lID0gKCkgPT4ge1xuICAgIGlmICgtLXBlbmRpbmcucmVxdWVzdHMgPT09IDApIHtcbiAgICAgIGRmLl9wZW5kaW5nID0gbnVsbDtcbiAgICAgIGFjY2VwdChkZik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkZi5fcGVuZGluZyA9IHBlbmRpbmc7XG59XG5cbmNvbnN0IFNLSVAgPSB7XG4gIHNraXA6IHRydWVcbn07XG4vKipcbiAqIFBlcmZvcm0gb3BlcmF0b3IgdXBkYXRlcyBpbiByZXNwb25zZSB0byBldmVudHMuIEFwcGxpZXMgYW5cbiAqIHVwZGF0ZSBmdW5jdGlvbiB0byBjb21wdXRlIGEgbmV3IG9wZXJhdG9yIHZhbHVlLiBJZiB0aGUgdXBkYXRlIGZ1bmN0aW9uXG4gKiByZXR1cm5zIGEge0BsaW5rIENoYW5nZVNldH0sIHRoZSBvcGVyYXRvciB3aWxsIGJlIHB1bHNlZCB3aXRoIHRob3NlIHR1cGxlXG4gKiBjaGFuZ2VzLiBPdGhlcndpc2UsIHRoZSBvcGVyYXRvciB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQgdG8gdGhlIHJldHVybiB2YWx1ZS5cbiAqIEBwYXJhbSB7RXZlbnRTdHJlYW18T3BlcmF0b3J9IHNvdXJjZSAtIFRoZSBldmVudCBzb3VyY2UgdG8gcmVhY3QgdG8uXG4gKiAgIFRoaXMgYXJndW1lbnQgY2FuIGJlIGVpdGhlciBhbiBFdmVudFN0cmVhbSBvciBhbiBPcGVyYXRvci5cbiAqIEBwYXJhbSB7T3BlcmF0b3J8ZnVuY3Rpb24ob2JqZWN0KTpPcGVyYXRvcn0gdGFyZ2V0IC0gVGhlIG9wZXJhdG9yIHRvIHVwZGF0ZS5cbiAqICAgVGhpcyBhcmd1bWVudCBjYW4gZWl0aGVyIGJlIGFuIE9wZXJhdG9yIGluc3RhbmNlIG9yIChpZiB0aGUgc291cmNlXG4gKiAgIGFyZ3VtZW50IGlzIGFuIEV2ZW50U3RyZWFtKSwgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYW4gZXZlbnQgb2JqZWN0IGFzXG4gKiAgIGlucHV0IGFuZCByZXR1cm5zIGFuIE9wZXJhdG9yIHRvIHRhcmdldC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUGFyYW1ldGVycyxFdmVudCk6ICp9IFt1cGRhdGVdIC0gT3B0aW9uYWwgdXBkYXRlIGZ1bmN0aW9uXG4gKiAgIHRvIGNvbXB1dGUgdGhlIG5ldyBvcGVyYXRvciB2YWx1ZSwgb3IgYSBsaXRlcmFsIHZhbHVlIHRvIHNldC4gVXBkYXRlXG4gKiAgIGZ1bmN0aW9ucyBleHBlY3QgdG8gcmVjZWl2ZSBhIHBhcmFtZXRlciBvYmplY3QgYW5kIGV2ZW50IGFzIGFyZ3VtZW50cy5cbiAqICAgVGhpcyBmdW5jdGlvbiBjYW4gZWl0aGVyIHJldHVybiBhIG5ldyBvcGVyYXRvciB2YWx1ZSBvciAoaWYgdGhlIHNvdXJjZVxuICogICBhcmd1bWVudCBpcyBhbiBFdmVudFN0cmVhbSkgYSB7QGxpbmsgQ2hhbmdlU2V0fSBpbnN0YW5jZSB0byBwdWxzZVxuICogICB0aGUgdGFyZ2V0IG9wZXJhdG9yIHdpdGggdHVwbGUgY2hhbmdlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSB1cGRhdGUgZnVuY3Rpb24gcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgaGFzaC4gSWYgbm90IG92ZXJyaWRkZW4sXG4gKiAgIHVwZGF0ZWQgb3BlcmF0b3JzIHdpbGwgYmUgc2tpcHBlZCBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgYmUgc2tpcHBlZDogaXQgd2lsbCBub3QgYmUgZXZhbHVhdGVkLCBidXQgaXRzIGRlcGVuZGVudHMgd2lsbCBiZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZm9yY2VdIC0gSWYgdHJ1ZSwgdGhlIG9wZXJhdG9yIHdpbGxcbiAqICAgYmUgcmUtZXZhbHVhdGVkIGV2ZW4gaWYgaXRzIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cbiAqIEByZXR1cm4ge0RhdGFmbG93fVxuICovXG5cbmZ1bmN0aW9uIG9uIChzb3VyY2UsIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgZm4gPSBzb3VyY2UgaW5zdGFuY2VvZiBPcGVyYXRvciA/IG9uT3BlcmF0b3IgOiBvblN0cmVhbTtcbiAgZm4odGhpcywgc291cmNlLCB0YXJnZXQsIHVwZGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG9uU3RyZWFtKGRmLCBzdHJlYW0sIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0ID0gZXh0ZW5kKHt9LCBvcHRpb25zLCBTS0lQKTtcbiAgbGV0IGZ1bmMsIG9wO1xuICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkgdGFyZ2V0ID0gY29uc3RhbnQodGFyZ2V0KTtcblxuICBpZiAodXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBmdW5jID0gZSA9PiBkZi50b3VjaCh0YXJnZXQoZSkpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odXBkYXRlKSkge1xuICAgIG9wID0gbmV3IE9wZXJhdG9yKG51bGwsIHVwZGF0ZSwgcGFyYW1zLCBmYWxzZSk7XG5cbiAgICBmdW5jID0gZSA9PiB7XG4gICAgICBvcC5ldmFsdWF0ZShlKTtcbiAgICAgIGNvbnN0IHQgPSB0YXJnZXQoZSksXG4gICAgICAgICAgICB2ID0gb3AudmFsdWU7XG4gICAgICBpc0NoYW5nZVNldCh2KSA/IGRmLnB1bHNlKHQsIHYsIG9wdGlvbnMpIDogZGYudXBkYXRlKHQsIHYsIG9wdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmdW5jID0gZSA9PiBkZi51cGRhdGUodGFyZ2V0KGUpLCB1cGRhdGUsIG9wdCk7XG4gIH1cblxuICBzdHJlYW0uYXBwbHkoZnVuYyk7XG59XG5cbmZ1bmN0aW9uIG9uT3BlcmF0b3IoZGYsIHNvdXJjZSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICBpZiAodXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2UudGFyZ2V0cygpLmFkZCh0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgICAgb3AgPSBuZXcgT3BlcmF0b3IobnVsbCwgdXBkYXRlcih0YXJnZXQsIHVwZGF0ZSksIHBhcmFtcywgZmFsc2UpO1xuICAgIG9wLm1vZGlmaWVkKG9wdC5mb3JjZSk7XG4gICAgb3AucmFuayA9IHNvdXJjZS5yYW5rOyAvLyBpbW1lZGlhdGVseSBmb2xsb3cgc291cmNlXG5cbiAgICBzb3VyY2UudGFyZ2V0cygpLmFkZChvcCk7IC8vIGFkZCBkZXBlbmRlbmN5XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBvcC5za2lwKHRydWUpOyAvLyBza2lwIGZpcnN0IGludm9jYXRpb25cblxuICAgICAgb3AudmFsdWUgPSB0YXJnZXQudmFsdWU7IC8vIGluaXRpYWxpemUgdmFsdWVcblxuICAgICAgb3AudGFyZ2V0cygpLmFkZCh0YXJnZXQpOyAvLyBjaGFpbiBkZXBlbmRlbmNpZXNcblxuICAgICAgZGYuY29ubmVjdCh0YXJnZXQsIFtvcF0pOyAvLyByZXJhbmsgYXMgbmVlZGVkLCAjMTY3MlxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVyKHRhcmdldCwgdXBkYXRlKSB7XG4gIHVwZGF0ZSA9IGlzRnVuY3Rpb24odXBkYXRlKSA/IHVwZGF0ZSA6IGNvbnN0YW50KHVwZGF0ZSk7XG4gIHJldHVybiB0YXJnZXQgPyBmdW5jdGlvbiAoXywgcHVsc2UpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHVwZGF0ZShfLCBwdWxzZSk7XG5cbiAgICBpZiAoIXRhcmdldC5za2lwKCkpIHtcbiAgICAgIHRhcmdldC5za2lwKHZhbHVlICE9PSB0aGlzLnZhbHVlKS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSA6IHVwZGF0ZTtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIGEgcmFuayB0byBhbiBvcGVyYXRvci4gUmFua3MgYXJlIGFzc2lnbmVkIGluIGluY3JlYXNpbmcgb3JkZXJcbiAqIGJ5IGluY3JlbWVudGluZyBhbiBpbnRlcm5hbCByYW5rIGNvdW50ZXIuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSBvcCAtIFRoZSBvcGVyYXRvciB0byBhc3NpZ24gYSByYW5rLlxuICovXG5cbmZ1bmN0aW9uIHJhbmsob3ApIHtcbiAgb3AucmFuayA9ICsrdGhpcy5fcmFuaztcbn1cbi8qKlxuICogUmUtcmFua3MgYW4gb3BlcmF0b3IgYW5kIGFsbCBkb3duc3RyZWFtIHRhcmdldCBkZXBlbmRlbmNpZXMuIFRoaXNcbiAqIGlzIG5lY2Vzc2FyeSB3aGVuIHVwc3RyZWFtIGRlcGVuZGVuY2llcyBvZiBoaWdoZXIgcmFuayBhcmUgYWRkZWQgdG9cbiAqIGEgdGFyZ2V0IG9wZXJhdG9yLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gcmUtcmFuay5cbiAqL1xuXG5mdW5jdGlvbiByZXJhbmsob3ApIHtcbiAgY29uc3QgcXVldWUgPSBbb3BdO1xuICBsZXQgY3VyLCBsaXN0LCBpO1xuXG4gIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICB0aGlzLnJhbmsoY3VyID0gcXVldWUucG9wKCkpO1xuXG4gICAgaWYgKGxpc3QgPSBjdXIuX3RhcmdldHMpIHtcbiAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgcXVldWUucHVzaChjdXIgPSBsaXN0W2ldKTtcbiAgICAgICAgaWYgKGN1ciA9PT0gb3ApIGVycm9yKCdDeWNsZSBkZXRlY3RlZCBpbiBkYXRhZmxvdyBncmFwaC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZW50aW5lbCB2YWx1ZSBpbmRpY2F0aW5nIHB1bHNlIHByb3BhZ2F0aW9uIHNob3VsZCBzdG9wLlxuICovXG5cbmNvbnN0IFN0b3BQcm9wYWdhdGlvbiA9IHt9OyAvLyBQdWxzZSB2aXNpdCB0eXBlIGZsYWdzXG5cbmNvbnN0IEFERCA9IDEgPDwgMCxcbiAgICAgIFJFTSA9IDEgPDwgMSxcbiAgICAgIE1PRCA9IDEgPDwgMixcbiAgICAgIEFERF9SRU0gPSBBREQgfCBSRU0sXG4gICAgICBBRERfTU9EID0gQUREIHwgTU9ELFxuICAgICAgQUxMID0gQUREIHwgUkVNIHwgTU9ELFxuICAgICAgUkVGTE9XID0gMSA8PCAzLFxuICAgICAgU09VUkNFID0gMSA8PCA0LFxuICAgICAgTk9fU09VUkNFID0gMSA8PCA1LFxuICAgICAgTk9fRklFTERTID0gMSA8PCA2O1xuLyoqXG4gKiBBIFB1bHNlIGVuYWJsZXMgaW50ZXItb3BlcmF0b3IgY29tbXVuaWNhdGlvbiBkdXJpbmcgYSBydW4gb2YgdGhlXG4gKiBkYXRhZmxvdyBncmFwaC4gSW4gYWRkaXRpb24gdG8gdGhlIGN1cnJlbnQgdGltZXN0YW1wLCBhIHB1bHNlIG1heSBhbHNvXG4gKiBjb250YWluIGEgY2hhbmdlLXNldCBvZiBhZGRlZCwgcmVtb3ZlZCBvciBtb2RpZmllZCBkYXRhIHR1cGxlcywgYXMgd2VsbCBhc1xuICogYSBwb2ludGVyIHRvIGEgZnVsbCBiYWNraW5nIGRhdGEgc291cmNlLiBUdXBsZSBjaGFuZ2Ugc2V0cyBtYXkgbm90XG4gKiBiZSBmdWxseSBtYXRlcmlhbGl6ZWQ7IGZvciBleGFtcGxlLCB0byBwcmV2ZW50IG5lZWRsZXNzIGFycmF5IGNyZWF0aW9uXG4gKiBhIGNoYW5nZSBzZXQgbWF5IGluY2x1ZGUgbGFyZ2VyIGFycmF5cyBhbmQgY29ycmVzcG9uZGluZyBmaWx0ZXIgZnVuY3Rpb25zLlxuICogVGhlIHB1bHNlIHByb3ZpZGVzIGEge0BsaW5rIHZpc2l0fSBtZXRob2QgdG8gZW5hYmxlIHByb3BlciBhbmQgZWZmaWNpZW50XG4gKiBpdGVyYXRpb24gb3ZlciByZXF1ZXN0ZWQgZGF0YSB0dXBsZXMuXG4gKlxuICogSW4gYWRkaXRpb24sIGVhY2ggcHVsc2UgY2FuIHRyYWNrIG1vZGlmaWNhdGlvbiBmbGFncyBmb3IgZGF0YSB0dXBsZSBmaWVsZHMuXG4gKiBSZXNwb25zaWJsZSB0cmFuc2Zvcm0gb3BlcmF0b3JzIHNob3VsZCBjYWxsIHRoZSB7QGxpbmsgbW9kaWZpZXN9IG1ldGhvZCB0b1xuICogaW5kaWNhdGUgY2hhbmdlcyB0byBkYXRhIGZpZWxkcy4gVGhlIHtAbGluayBtb2RpZmllZH0gbWV0aG9kIGVuYWJsZXNcbiAqIHF1ZXJ5aW5nIG9mIHRoaXMgbW9kaWZpY2F0aW9uIHN0YXRlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtEYXRhZmxvd30gZGF0YWZsb3cgLSBUaGUgYmFja2luZyBkYXRhZmxvdyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFtcCAtIFRoZSBjdXJyZW50IHByb3BhZ2F0aW9uIHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RlXSAtIEFuIG9wdGlvbmFsIGVuY29kaW5nIHNldCBuYW1lLCB3aGljaCBpcyB0aGVuXG4gKiAgIGFjY2Vzc2libGUgYXMgUHVsc2UuZW5jb2RlLiBPcGVyYXRvcnMgY2FuIHJlc3BvbmQgdG8gKG9yIGlnbm9yZSkgdGhpc1xuICogICBzZXR0aW5nIGFzIGFwcHJvcHJpYXRlLiBUaGlzIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoXG4gKiAgIHRoZSBFbmNvZGUgdHJhbnNmb3JtIGluIHRoZSB2ZWdhLWVuY29kZSBtb2R1bGUuXG4gKi9cblxuZnVuY3Rpb24gUHVsc2UoZGF0YWZsb3csIHN0YW1wLCBlbmNvZGUpIHtcbiAgdGhpcy5kYXRhZmxvdyA9IGRhdGFmbG93O1xuICB0aGlzLnN0YW1wID0gc3RhbXAgPT0gbnVsbCA/IC0xIDogc3RhbXA7XG4gIHRoaXMuYWRkID0gW107XG4gIHRoaXMucmVtID0gW107XG4gIHRoaXMubW9kID0gW107XG4gIHRoaXMuZmllbGRzID0gbnVsbDtcbiAgdGhpcy5lbmNvZGUgPSBlbmNvZGUgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoZGF0YSwgZmlsdGVyKSB7XG4gIGNvbnN0IG91dCA9IFtdO1xuICB2aXNpdEFycmF5KGRhdGEsIGZpbHRlciwgXyA9PiBvdXQucHVzaChfKSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGZpbHRlcihwdWxzZSwgZmxhZ3MpIHtcbiAgY29uc3QgbWFwID0ge307XG4gIHB1bHNlLnZpc2l0KGZsYWdzLCB0ID0+IHtcbiAgICBtYXBbdHVwbGVpZCh0KV0gPSAxO1xuICB9KTtcbiAgcmV0dXJuIHQgPT4gbWFwW3R1cGxlaWQodCldID8gbnVsbCA6IHQ7XG59XG5cbmZ1bmN0aW9uIGFkZEZpbHRlcihhLCBiKSB7XG4gIHJldHVybiBhID8gKHQsIGkpID0+IGEodCwgaSkgJiYgYih0LCBpKSA6IGI7XG59XG5cblB1bHNlLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFNlbnRpbmVsIHZhbHVlIGluZGljYXRpbmcgcHVsc2UgcHJvcGFnYXRpb24gc2hvdWxkIHN0b3AuXG4gICAqL1xuICBTdG9wUHJvcGFnYXRpb24sXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIEFERCAoYWRkZWQpIHR1cGxlcy5cbiAgICovXG4gIEFERCxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgUkVNIChyZW1vdmVkKSB0dXBsZXMuXG4gICAqL1xuICBSRU0sXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIE1PRCAobW9kaWZpZWQpIHR1cGxlcy5cbiAgICovXG4gIE1PRCxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgQUREIChhZGRlZCkgYW5kIFJFTSAocmVtb3ZlZCkgdHVwbGVzLlxuICAgKi9cbiAgQUREX1JFTSxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgQUREIChhZGRlZCkgYW5kIE1PRCAobW9kaWZpZWQpIHR1cGxlcy5cbiAgICovXG4gIEFERF9NT0QsXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIEFERCwgUkVNIGFuZCBNT0QgdHVwbGVzLlxuICAgKi9cbiAgQUxMLFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBhbGwgdHVwbGVzIGluIGEgZGF0YSBzb3VyY2VcbiAgICogZXhjZXB0IGZvciB0aGUgQURELCBSRU0gYW5kIE1PRCB0dXBsZXMuXG4gICAqL1xuICBSRUZMT1csXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGEgJ3Bhc3MtdGhyb3VnaCcgdG8gYVxuICAgKiBiYWNraW5nIGRhdGEgc291cmNlLCBpZ25vcmluZyBBREQsIFJFTSBhbmQgTU9EIHR1cGxlcy5cbiAgICovXG4gIFNPVVJDRSxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgdGhhdCBzb3VyY2UgZGF0YSBzaG91bGQgYmVcbiAgICogc3VwcHJlc3NlZCB3aGVuIGNyZWF0aW5nIGEgZm9ya2VkIHB1bHNlLlxuICAgKi9cbiAgTk9fU09VUkNFLFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyB0aGF0IGZpZWxkIG1vZGlmaWNhdGlvbnMgc2hvdWxkIGJlXG4gICAqIHN1cHByZXNzZWQgd2hlbiBjcmVhdGluZyBhIGZvcmtlZCBwdWxzZS5cbiAgICovXG4gIE5PX0ZJRUxEUyxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwdWxzZSBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIHRoaXMgcHVsc2UuXG4gICAqIFRoZSBkYXRhZmxvdywgdGltZSBzdGFtcCBhbmQgZmllbGQgbW9kaWZpY2F0aW9uIHZhbHVlcyBhcmUgY29waWVkIG92ZXIuXG4gICAqIEJ5IGRlZmF1bHQsIG5ldyBlbXB0eSBBREQsIFJFTSBhbmQgTU9EIGFycmF5cyBhcmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gSW50ZWdlciBvZiBib29sZWFuIGZsYWdzIGluZGljYXRpbmcgd2hpY2ggKGlmIGFueSlcbiAgICogICB0dXBsZSBhcnJheXMgc2hvdWxkIGJlIGNvcGllZCB0byB0aGUgbmV3IHB1bHNlLiBUaGUgc3VwcG9ydGVkIGZsYWcgdmFsdWVzXG4gICAqICAgYXJlIEFERCwgUkVNIGFuZCBNT0QuIEFycmF5IHJlZmVyZW5jZXMgYXJlIGNvcGllZCBkaXJlY3RseTogbmV3IGFycmF5XG4gICAqICAgaW5zdGFuY2VzIGFyZSBub3QgY3JlYXRlZC5cbiAgICogQHJldHVybiB7UHVsc2V9IC0gVGhlIGZvcmtlZCBwdWxzZSBpbnN0YW5jZS5cbiAgICogQHNlZSBpbml0XG4gICAqL1xuICBmb3JrKGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBQdWxzZSh0aGlzLmRhdGFmbG93KS5pbml0KHRoaXMsIGZsYWdzKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBwdWxzZSB3aXRoIG5ldyBtYXRlcmlhbGl6ZWQgYXJyYXlcbiAgICogaW5zdGFuY2VzIGZvciB0aGUgQURELCBSRU0sIE1PRCwgYW5kIFNPVVJDRSBhcnJheXMuXG4gICAqIFRoZSBkYXRhZmxvdywgdGltZSBzdGFtcCBhbmQgZmllbGQgbW9kaWZpY2F0aW9uIHZhbHVlcyBhcmUgY29waWVkIG92ZXIuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFRoZSBjbG9uZWQgcHVsc2UgaW5zdGFuY2UuXG4gICAqIEBzZWUgaW5pdFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuZm9yayhBTEwpO1xuICAgIHAuYWRkID0gcC5hZGQuc2xpY2UoKTtcbiAgICBwLnJlbSA9IHAucmVtLnNsaWNlKCk7XG4gICAgcC5tb2QgPSBwLm1vZC5zbGljZSgpO1xuICAgIGlmIChwLnNvdXJjZSkgcC5zb3VyY2UgPSBwLnNvdXJjZS5zbGljZSgpO1xuICAgIHJldHVybiBwLm1hdGVyaWFsaXplKEFMTCB8IFNPVVJDRSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwdWxzZSB0aGF0IGFkZHMgYWxsIHR1cGxlcyBmcm9tIGEgYmFja2luZyBzb3VyY2UuIFRoaXMgaXNcbiAgICogdXNlZnVsIGZvciBjYXNlcyB3aGVyZSBvcGVyYXRvcnMgYXJlIGFkZGVkIHRvIGEgZGF0YWZsb3cgYWZ0ZXIgYW5cbiAgICogdXBzdHJlYW0gZGF0YSBwaXBlbGluZSBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCwgZW5zdXJpbmcgdGhhdFxuICAgKiBuZXcgb3BlcmF0b3JzIGNhbiBvYnNlcnZlIGFsbCB0dXBsZXMgd2l0aGluIGEgc3RyZWFtLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBBIHB1bHNlIGluc3RhbmNlIHdpdGggYWxsIHNvdXJjZSB0dXBsZXMgaW5jbHVkZWRcbiAgICogICBpbiB0aGUgYWRkIGFycmF5LiBJZiB0aGUgY3VycmVudCBwdWxzZSBhbHJlYWR5IGhhcyBhbGwgc291cmNlXG4gICAqICAgdHVwbGVzIGluIGl0cyBhZGQgYXJyYXksIGl0IGlzIHJldHVybmVkIGRpcmVjdGx5LiBJZiB0aGUgY3VycmVudFxuICAgKiAgIHB1bHNlIGRvZXMgbm90IGhhdmUgYSBiYWNraW5nIHNvdXJjZSwgaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHkuXG4gICAqL1xuICBhZGRBbGwoKSB7XG4gICAgbGV0IHAgPSB0aGlzO1xuICAgIGNvbnN0IHJldXNlID0gIXAuc291cmNlIHx8IHAuYWRkID09PSBwLnJlbSAvLyBzcGVjaWFsIGNhc2UgZm9yIGluZGV4ZWQgc2V0IChlLmcuLCBjcm9zc2ZpbHRlcilcbiAgICB8fCAhcC5yZW0ubGVuZ3RoICYmIHAuc291cmNlLmxlbmd0aCA9PT0gcC5hZGQubGVuZ3RoO1xuXG4gICAgaWYgKHJldXNlKSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IG5ldyBQdWxzZSh0aGlzLmRhdGFmbG93KS5pbml0KHRoaXMpO1xuICAgICAgcC5hZGQgPSBwLnNvdXJjZTtcbiAgICAgIHAucmVtID0gW107IC8vIG5ldyBvcGVyYXRvcnMgY2FuIGlnbm9yZSByZW0gIzI3NjlcblxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoaXMgcHVsc2UgYmFzZWQgb24gdGhlIHZhbHVlcyBvZiBhbm90aGVyIHB1bHNlLiBUaGlzIG1ldGhvZFxuICAgKiBpcyB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIGZvcmt9IHRvIGluaXRpYWxpemUgYSBuZXcgZm9ya2VkIHR1cGxlLlxuICAgKiBUaGUgZGF0YWZsb3csIHRpbWUgc3RhbXAgYW5kIGZpZWxkIG1vZGlmaWNhdGlvbiB2YWx1ZXMgYXJlIGNvcGllZCBvdmVyLlxuICAgKiBCeSBkZWZhdWx0LCBuZXcgZW1wdHkgQURELCBSRU0gYW5kIE1PRCBhcnJheXMgYXJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7UHVsc2V9IHNyYyAtIFRoZSBzb3VyY2UgcHVsc2UgdG8gY29weSBmcm9tLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgLSBJbnRlZ2VyIG9mIGJvb2xlYW4gZmxhZ3MgaW5kaWNhdGluZyB3aGljaCAoaWYgYW55KVxuICAgKiAgIHR1cGxlIGFycmF5cyBzaG91bGQgYmUgY29waWVkIHRvIHRoZSBuZXcgcHVsc2UuIFRoZSBzdXBwb3J0ZWQgZmxhZyB2YWx1ZXNcbiAgICogICBhcmUgQURELCBSRU0gYW5kIE1PRC4gQXJyYXkgcmVmZXJlbmNlcyBhcmUgY29waWVkIGRpcmVjdGx5OiBuZXcgYXJyYXlcbiAgICogICBpbnN0YW5jZXMgYXJlIG5vdCBjcmVhdGVkLiBCeSBkZWZhdWx0LCBzb3VyY2UgZGF0YSBhcnJheXMgYXJlIGNvcGllZFxuICAgKiAgIHRvIHRoZSBuZXcgcHVsc2UuIFVzZSB0aGUgTk9fU09VUkNFIGZsYWcgdG8gZW5mb3JjZSBhIG51bGwgc291cmNlLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgUHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICBpbml0KHNyYywgZmxhZ3MpIHtcbiAgICBjb25zdCBwID0gdGhpcztcbiAgICBwLnN0YW1wID0gc3JjLnN0YW1wO1xuICAgIHAuZW5jb2RlID0gc3JjLmVuY29kZTtcblxuICAgIGlmIChzcmMuZmllbGRzICYmICEoZmxhZ3MgJiBOT19GSUVMRFMpKSB7XG4gICAgICBwLmZpZWxkcyA9IHNyYy5maWVsZHM7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgQUREKSB7XG4gICAgICBwLmFkZEYgPSBzcmMuYWRkRjtcbiAgICAgIHAuYWRkID0gc3JjLmFkZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5hZGRGID0gbnVsbDtcbiAgICAgIHAuYWRkID0gW107XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgUkVNKSB7XG4gICAgICBwLnJlbUYgPSBzcmMucmVtRjtcbiAgICAgIHAucmVtID0gc3JjLnJlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5yZW1GID0gbnVsbDtcbiAgICAgIHAucmVtID0gW107XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgTU9EKSB7XG4gICAgICBwLm1vZEYgPSBzcmMubW9kRjtcbiAgICAgIHAubW9kID0gc3JjLm1vZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5tb2RGID0gbnVsbDtcbiAgICAgIHAubW9kID0gW107XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgTk9fU09VUkNFKSB7XG4gICAgICBwLnNyY0YgPSBudWxsO1xuICAgICAgcC5zb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnNyY0YgPSBzcmMuc3JjRjtcbiAgICAgIHAuc291cmNlID0gc3JjLnNvdXJjZTtcbiAgICAgIGlmIChzcmMuY2xlYW5zKSBwLmNsZWFucyA9IHNyYy5jbGVhbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciBwdWxzZSBwcm9wYWdhdGlvbiBjb21wbGV0ZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gcnVuLlxuICAgKi9cbiAgcnVuQWZ0ZXIoZnVuYykge1xuICAgIHRoaXMuZGF0YWZsb3cucnVuQWZ0ZXIoZnVuYyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0dXBsZXMgaGF2ZSBiZWVuIGFkZGVkLCByZW1vdmVkIG9yIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2ZsYWdzXSAtIFRoZSB0dXBsZSB0eXBlcyAoQURELCBSRU0gb3IgTU9EKSB0byBxdWVyeS5cbiAgICogICBEZWZhdWx0cyB0byBBTEwsIHJldHVybmluZyB0cnVlIGlmIGFueSB0dXBsZSB0eXBlIGhhcyBjaGFuZ2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiBvbmUgb3IgbW9yZSBxdWVyaWVkIHR1cGxlIHR5cGVzIGhhdmVcbiAgICogICBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjaGFuZ2VkKGZsYWdzKSB7XG4gICAgY29uc3QgZiA9IGZsYWdzIHx8IEFMTDtcbiAgICByZXR1cm4gZiAmIEFERCAmJiB0aGlzLmFkZC5sZW5ndGggfHwgZiAmIFJFTSAmJiB0aGlzLnJlbS5sZW5ndGggfHwgZiAmIE1PRCAmJiB0aGlzLm1vZC5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhIFwicmVmbG93XCIgb2YgdHVwbGUgdmFsdWVzLCBzdWNoIHRoYXQgYWxsIHR1cGxlcyBpbiB0aGUgYmFja2luZ1xuICAgKiBzb3VyY2UgYXJlIGFkZGVkIHRvIHRoZSBNT0Qgc2V0LCB1bmxlc3MgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBBREQgc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JrPWZhbHNlXSAtIElmIHRydWUsIHJldHVybnMgYSBmb3JrZWQgY29weSBvZiB0aGlzXG4gICAqICAgcHVsc2UsIGFuZCBpbnZva2VzIHJlZmxvdyBvbiB0aGF0IGRlcml2ZWQgcHVsc2UuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFRoZSByZWZsb3dlZCBwdWxzZSBpbnN0YW5jZS5cbiAgICovXG4gIHJlZmxvdyhmb3JrKSB7XG4gICAgaWYgKGZvcmspIHJldHVybiB0aGlzLmZvcmsoQUxMKS5yZWZsb3coKTtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmFkZC5sZW5ndGgsXG4gICAgICAgICAgc3JjID0gdGhpcy5zb3VyY2UgJiYgdGhpcy5zb3VyY2UubGVuZ3RoO1xuXG4gICAgaWYgKHNyYyAmJiBzcmMgIT09IGxlbikge1xuICAgICAgdGhpcy5tb2QgPSB0aGlzLnNvdXJjZTtcbiAgICAgIGlmIChsZW4pIHRoaXMuZmlsdGVyKE1PRCwgZmlsdGVyKHRoaXMsIEFERCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQvc2V0IG1ldGFkYXRhIHRvIHB1bHNlIHJlcXVlc3RpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAqIHRvIHJlY2xhaW0gY3VycmVudGx5IHVudXNlZCByZXNvdXJjZXMuXG4gICAqL1xuICBjbGVhbih2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNsZWFucyA9ICEhdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2xlYW5zO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTWFya3Mgb25lIG9yIG1vcmUgZGF0YSBmaWVsZCBuYW1lcyBhcyBtb2RpZmllZCB0byBhc3Npc3QgZGVwZW5kZW5jeVxuICAgKiB0cmFja2luZyBhbmQgaW5jcmVtZW50YWwgcHJvY2Vzc2luZyBieSB0cmFuc2Zvcm0gb3BlcmF0b3JzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBfIC0gVGhlIGZpZWxkKHMpIHRvIG1hcmsgYXMgbW9kaWZpZWQuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICBtb2RpZmllcyhfKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuZmllbGRzIHx8ICh0aGlzLmZpZWxkcyA9IHt9KTtcblxuICAgIGlmIChpc0FycmF5KF8pKSB7XG4gICAgICBfLmZvckVhY2goZiA9PiBoYXNoW2ZdID0gdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2hbX10gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgb25lIG9yIG1vcmUgZGF0YSBmaWVsZHMgaGF2ZSBiZWVuIG1vZGlmaWVkIGR1cmluZyB0aGlzIHB1bHNlXG4gICAqIHByb3BhZ2F0aW9uIHRpbWVzdGFtcC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gXyAtIFRoZSBmaWVsZChzKSB0byBjaGVjayBmb3IgbW9kaWZpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbm9tb2QgLSBJZiB0cnVlLCB3aWxsIGNoZWNrIHRoZSBtb2RpZmllZCBmbGFnIGV2ZW4gaWZcbiAgICogICBubyBtb2QgdHVwbGVzIGV4aXN0LiBJZiBmYWxzZSAoZGVmYXVsdCksIG1vZCB0dXBsZXMgbXVzdCBiZSBwcmVzZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlIHByb3ZpZGVkIGZpZWxkcyBoYXMgYmVlblxuICAgKiAgIG1hcmtlZCBhcyBtb2RpZmllZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgbW9kaWZpZWQoXywgbm9tb2QpIHtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICByZXR1cm4gISgobm9tb2QgfHwgdGhpcy5tb2QubGVuZ3RoKSAmJiBmaWVsZHMpID8gZmFsc2UgOiAhYXJndW1lbnRzLmxlbmd0aCA/ICEhZmllbGRzIDogaXNBcnJheShfKSA/IF8uc29tZShmID0+IGZpZWxkc1tmXSkgOiBmaWVsZHNbX107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBmaWx0ZXIgZnVuY3Rpb24gdG8gb25lIG1vcmUgdHVwbGUgc2V0cy4gRmlsdGVycyBhcmUgYXBwbGllZCB0b1xuICAgKiBiYWNraW5nIHR1cGxlIGFycmF5cywgdG8gZGV0ZXJtaW5lIHRoZSBhY3R1YWwgc2V0IG9mIHR1cGxlcyBjb25zaWRlcmVkXG4gICAqIGFkZGVkLCByZW1vdmVkIG9yIG1vZGlmaWVkLiBUaGV5IGNhbiBiZSB1c2VkIHRvIGRlbGF5IG1hdGVyaWFsaXphdGlvbiBvZlxuICAgKiBhIHR1cGxlIHNldCBpbiBvcmRlciB0byBhdm9pZCBleHBlbnNpdmUgYXJyYXkgY29waWVzLiBJbiBhZGRpdGlvbiwgdGhlXG4gICAqIGZpbHRlciBmdW5jdGlvbnMgY2FuIHNlcnZlIGFzIHZhbHVlIHRyYW5zZm9ybWVyczogdW5saWtlIHN0YW5kYXJkIHByZWRpY2F0ZVxuICAgKiBmdW5jdGlvbiAod2hpY2ggcmV0dXJuIGJvb2xlYW4gdmFsdWVzKSwgUHVsc2UgZmlsdGVycyBzaG91bGQgcmV0dXJuIHRoZVxuICAgKiBhY3R1YWwgdHVwbGUgdmFsdWUgdG8gcHJvY2Vzcy4gSWYgYSB0dXBsZSBzZXQgaXMgYWxyZWFkeSBmaWx0ZXJlZCwgdGhlXG4gICAqIG5ldyBmaWx0ZXIgZnVuY3Rpb24gd2lsbCBiZSBhcHBlbmRlZCBpbnRvIGEgY29uanVudGl2ZSAoJ2FuZCcpIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgLSBGbGFncyBpbmRpY2F0aW5nIHRoZSB0dXBsZSBzZXQocykgdG8gZmlsdGVyLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopOm9iamVjdH0gZmlsdGVyIC0gRmlsdGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gICAqICAgdG8gdGhlIHR1cGxlIHNldCBhcnJheSwgYW5kIHNob3VsZCByZXR1cm4gYSBkYXRhIHR1cGxlIGlmIHRoZSB2YWx1ZVxuICAgKiAgIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdHVwbGUgc2V0LCBhbmQgZmFsc3kgKG9yIG51bGwpIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7UHVsc2V9IC0gUmV0dXJucyB0aGlzIHB1bHNlIGluc3RhbmNlLlxuICAgKi9cbiAgZmlsdGVyKGZsYWdzLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBwID0gdGhpcztcbiAgICBpZiAoZmxhZ3MgJiBBREQpIHAuYWRkRiA9IGFkZEZpbHRlcihwLmFkZEYsIGZpbHRlcik7XG4gICAgaWYgKGZsYWdzICYgUkVNKSBwLnJlbUYgPSBhZGRGaWx0ZXIocC5yZW1GLCBmaWx0ZXIpO1xuICAgIGlmIChmbGFncyAmIE1PRCkgcC5tb2RGID0gYWRkRmlsdGVyKHAubW9kRiwgZmlsdGVyKTtcbiAgICBpZiAoZmxhZ3MgJiBTT1VSQ0UpIHAuc3JjRiA9IGFkZEZpbHRlcihwLnNyY0YsIGZpbHRlcik7XG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hdGVyaWFsaXplIG9uZSBvciBtb3JlIHR1cGxlIHNldHMgaW4gdGhpcyBwdWxzZS4gSWYgdGhlIHR1cGxlIHNldChzKSBoYXZlXG4gICAqIGEgcmVnaXN0ZXJlZCBmaWx0ZXIgZnVuY3Rpb24sIGl0IHdpbGwgYmUgYXBwbGllZCBhbmQgdGhlIHR1cGxlIHNldChzKSB3aWxsXG4gICAqIGJlIHJlcGxhY2VkIHdpdGggbWF0ZXJpYWxpemVkIHR1cGxlIGFycmF5cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gRmxhZ3MgaW5kaWNhdGluZyB0aGUgdHVwbGUgc2V0KHMpIHRvIG1hdGVyaWFsaXplLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICBtYXRlcmlhbGl6ZShmbGFncykge1xuICAgIGZsYWdzID0gZmxhZ3MgfHwgQUxMO1xuICAgIGNvbnN0IHAgPSB0aGlzO1xuXG4gICAgaWYgKGZsYWdzICYgQUREICYmIHAuYWRkRikge1xuICAgICAgcC5hZGQgPSBtYXRlcmlhbGl6ZShwLmFkZCwgcC5hZGRGKTtcbiAgICAgIHAuYWRkRiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgUkVNICYmIHAucmVtRikge1xuICAgICAgcC5yZW0gPSBtYXRlcmlhbGl6ZShwLnJlbSwgcC5yZW1GKTtcbiAgICAgIHAucmVtRiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgTU9EICYmIHAubW9kRikge1xuICAgICAgcC5tb2QgPSBtYXRlcmlhbGl6ZShwLm1vZCwgcC5tb2RGKTtcbiAgICAgIHAubW9kRiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgU09VUkNFICYmIHAuc3JjRikge1xuICAgICAgcC5zb3VyY2UgPSBwLnNvdXJjZS5maWx0ZXIocC5zcmNGKTtcbiAgICAgIHAuc3JjRiA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZpc2l0IG9uZSBvciBtb3JlIHR1cGxlIHNldHMgaW4gdGhpcyBwdWxzZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gRmxhZ3MgaW5kaWNhdGluZyB0aGUgdHVwbGUgc2V0KHMpIHRvIHZpc2l0LlxuICAgKiAgIExlZ2FsIHZhbHVlcyBhcmUgQURELCBSRU0sIE1PRCBhbmQgU09VUkNFIChpZiBhIGJhY2tpbmcgZGF0YSBzb3VyY2VcbiAgICogICBoYXMgYmVlbiBzZXQpLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6Kn0gLSBWaXNpdG9yIGZ1bmN0aW9uIGludm9rZWQgcGVyLXR1cGxlLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICB2aXNpdChmbGFncywgdmlzaXRvcikge1xuICAgIGNvbnN0IHAgPSB0aGlzLFxuICAgICAgICAgIHYgPSB2aXNpdG9yO1xuXG4gICAgaWYgKGZsYWdzICYgU09VUkNFKSB7XG4gICAgICB2aXNpdEFycmF5KHAuc291cmNlLCBwLnNyY0YsIHYpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgQUREKSB2aXNpdEFycmF5KHAuYWRkLCBwLmFkZEYsIHYpO1xuICAgIGlmIChmbGFncyAmIFJFTSkgdmlzaXRBcnJheShwLnJlbSwgcC5yZW1GLCB2KTtcbiAgICBpZiAoZmxhZ3MgJiBNT0QpIHZpc2l0QXJyYXkocC5tb2QsIHAubW9kRiwgdik7XG4gICAgY29uc3Qgc3JjID0gcC5zb3VyY2U7XG5cbiAgICBpZiAoZmxhZ3MgJiBSRUZMT1cgJiYgc3JjKSB7XG4gICAgICBjb25zdCBzdW0gPSBwLmFkZC5sZW5ndGggKyBwLm1vZC5sZW5ndGg7XG5cbiAgICAgIGlmIChzdW0gPT09IHNyYy5sZW5ndGgpIDsgZWxzZSBpZiAoc3VtKSB7XG4gICAgICAgIHZpc2l0QXJyYXkoc3JjLCBmaWx0ZXIocCwgQUREX01PRCksIHYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm8gYWRkL3JlbS9tb2QgdHVwbGVzLCB2aXNpdCBzb3VyY2VcbiAgICAgICAgdmlzaXRBcnJheShzcmMsIHAuc3JjRiwgdik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH1cblxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2V0IG9mIG11bHRpcGxlIHB1bHNlcy4gVXNlZCBhcyBpbnB1dCBmb3Igb3BlcmF0b3JzXG4gKiB0aGF0IGFjY2VwdCBtdWx0aXBsZSBwdWxzZXMgYXQgYSB0aW1lLiBDb250YWluZWQgcHVsc2VzIGFyZVxuICogYWNjZXNzaWJsZSB2aWEgdGhlIHB1YmxpYyBcInB1bHNlc1wiIGFycmF5IHByb3BlcnR5LiBUaGlzIHB1bHNlIGRvZVxuICogbm90IGNhcnJ5IGFkZGVkLCByZW1vdmVkIG9yIG1vZGlmaWVkIHR1cGxlcyBkaXJlY3RseS4gSG93ZXZlcixcbiAqIHRoZSB2aXNpdCBtZXRob2QgY2FuIGJlIHVzZWQgdG8gdHJhdmVyc2UgYWxsIHN1Y2ggdHVwbGVzIGNvbnRhaW5lZFxuICogaW4gc3ViLXB1bHNlcyB3aXRoIGEgdGltZXN0YW1wIG1hdGNoaW5nIHRoaXMgcGFyZW50IG11bHRpLXB1bHNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0RhdGFmbG93fSBkYXRhZmxvdyAtIFRoZSBiYWNraW5nIGRhdGFmbG93IGluc3RhbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YW1wIC0gVGhlIHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7QXJyYXk8UHVsc2U+fSBwdWxzZXMgLSBUaGUgc3ViLXB1bHNlcyBmb3IgdGhpcyBtdWx0aS1wdWxzZS5cbiAqL1xuXG5mdW5jdGlvbiBNdWx0aVB1bHNlKGRhdGFmbG93LCBzdGFtcCwgcHVsc2VzLCBlbmNvZGUpIHtcbiAgY29uc3QgcCA9IHRoaXMsXG4gICAgICAgIG4gPSBwdWxzZXMubGVuZ3RoO1xuICBsZXQgYyA9IDA7XG4gIHRoaXMuZGF0YWZsb3cgPSBkYXRhZmxvdztcbiAgdGhpcy5zdGFtcCA9IHN0YW1wO1xuICB0aGlzLmZpZWxkcyA9IG51bGw7XG4gIHRoaXMuZW5jb2RlID0gZW5jb2RlIHx8IG51bGw7XG4gIHRoaXMucHVsc2VzID0gcHVsc2VzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgcHVsc2UgPSBwdWxzZXNbaV07XG4gICAgaWYgKHB1bHNlLnN0YW1wICE9PSBzdGFtcCkgY29udGludWU7XG5cbiAgICBpZiAocHVsc2UuZmllbGRzKSB7XG4gICAgICBjb25zdCBoYXNoID0gcC5maWVsZHMgfHwgKHAuZmllbGRzID0ge30pO1xuXG4gICAgICBmb3IgKGNvbnN0IGYgaW4gcHVsc2UuZmllbGRzKSB7XG4gICAgICAgIGhhc2hbZl0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHAuQUREKSkgYyB8PSBwLkFERDtcbiAgICBpZiAocHVsc2UuY2hhbmdlZChwLlJFTSkpIGMgfD0gcC5SRU07XG4gICAgaWYgKHB1bHNlLmNoYW5nZWQocC5NT0QpKSBjIHw9IHAuTU9EO1xuICB9XG5cbiAgdGhpcy5jaGFuZ2VzID0gYztcbn1cbmluaGVyaXRzKE11bHRpUHVsc2UsIFB1bHNlLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHB1bHNlIGJhc2VkIG9uIHRoZSB2YWx1ZXMgb2YgdGhpcyBwdWxzZS5cbiAgICogVGhlIGRhdGFmbG93LCB0aW1lIHN0YW1wIGFuZCBmaWVsZCBtb2RpZmljYXRpb24gdmFsdWVzIGFyZSBjb3BpZWQgb3Zlci5cbiAgICogQHJldHVybiB7UHVsc2V9XG4gICAqL1xuICBmb3JrKGZsYWdzKSB7XG4gICAgY29uc3QgcCA9IG5ldyBQdWxzZSh0aGlzLmRhdGFmbG93KS5pbml0KHRoaXMsIGZsYWdzICYgdGhpcy5OT19GSUVMRFMpO1xuXG4gICAgaWYgKGZsYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChmbGFncyAmIHAuQUREKSB0aGlzLnZpc2l0KHAuQURELCB0ID0+IHAuYWRkLnB1c2godCkpO1xuICAgICAgaWYgKGZsYWdzICYgcC5SRU0pIHRoaXMudmlzaXQocC5SRU0sIHQgPT4gcC5yZW0ucHVzaCh0KSk7XG4gICAgICBpZiAoZmxhZ3MgJiBwLk1PRCkgdGhpcy52aXNpdChwLk1PRCwgdCA9PiBwLm1vZC5wdXNoKHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICBjaGFuZ2VkKGZsYWdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlcyAmIGZsYWdzO1xuICB9LFxuXG4gIG1vZGlmaWVkKF8pIHtcbiAgICBjb25zdCBwID0gdGhpcyxcbiAgICAgICAgICBmaWVsZHMgPSBwLmZpZWxkcztcbiAgICByZXR1cm4gIShmaWVsZHMgJiYgcC5jaGFuZ2VzICYgcC5NT0QpID8gMCA6IGlzQXJyYXkoXykgPyBfLnNvbWUoZiA9PiBmaWVsZHNbZl0pIDogZmllbGRzW19dO1xuICB9LFxuXG4gIGZpbHRlcigpIHtcbiAgICBlcnJvcignTXVsdGlQdWxzZSBkb2VzIG5vdCBzdXBwb3J0IGZpbHRlcmluZy4nKTtcbiAgfSxcblxuICBtYXRlcmlhbGl6ZSgpIHtcbiAgICBlcnJvcignTXVsdGlQdWxzZSBkb2VzIG5vdCBzdXBwb3J0IG1hdGVyaWFsaXphdGlvbi4nKTtcbiAgfSxcblxuICB2aXNpdChmbGFncywgdmlzaXRvcikge1xuICAgIGNvbnN0IHAgPSB0aGlzLFxuICAgICAgICAgIHB1bHNlcyA9IHAucHVsc2VzLFxuICAgICAgICAgIG4gPSBwdWxzZXMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcblxuICAgIGlmIChmbGFncyAmIHAuU09VUkNFKSB7XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBwdWxzZXNbaV0udmlzaXQoZmxhZ3MsIHZpc2l0b3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAocHVsc2VzW2ldLnN0YW1wID09PSBwLnN0YW1wKSB7XG4gICAgICAgICAgcHVsc2VzW2ldLnZpc2l0KGZsYWdzLCB2aXNpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9XG5cbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF0b21pYy11cGRhdGVzICovXG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgZGF0YWZsb3cgYW5kIHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBwdWxzZVxuICogcHJvcGFnYXRpb24gY29tcGxldGVzLiBUaGlzIG1ldGhvZCB3aWxsIGluY3JlbWVudCB0aGUgY3VycmVudCB0aW1lc3RhbXBcbiAqIGFuZCBwcm9jZXNzIGFsbCB1cGRhdGVkLCBwdWxzZWQgYW5kIHRvdWNoZWQgb3BlcmF0b3JzLiBXaGVuIGludm9rZWQgZm9yXG4gKiB0aGUgZmlyc3QgdGltZSwgYWxsIHJlZ2lzdGVyZWQgb3BlcmF0b3JzIHdpbGwgYmUgcHJvY2Vzc2VkLiBUaGlzIG1ldGhvZFxuICogc2hvdWxkIG5vdCBiZSBpbnZva2VkIGJ5IHRoaXJkLXBhcnR5IGNsaWVudHMsIHVzZSB7QGxpbmsgcnVuQXN5bmN9IG9yXG4gKiB7QGxpbmsgcnVufSBpbnN0ZWFkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGVdIC0gVGhlIG5hbWUgb2YgYW4gZW5jb2Rpbmcgc2V0IHRvIGludm9rZSBkdXJpbmdcbiAqICAgcHJvcGFnYXRpb24uIFRoaXMgdmFsdWUgaXMgYWRkZWQgdG8gZ2VuZXJhdGVkIFB1bHNlIGluc3RhbmNlcztcbiAqICAgb3BlcmF0b3JzIGNhbiB0aGVuIHJlc3BvbmQgdG8gKG9yIGlnbm9yZSkgdGhpcyBzZXR0aW5nIGFzIGFwcHJvcHJpYXRlLlxuICogICBUaGlzIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBFbmNvZGUgdHJhbnNmb3JtIGluXG4gKiAgIHRoZSB2ZWdhLWVuY29kZSBwYWNrYWdlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3ByZXJ1bl0gLSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgaW1tZWRpYXRlbHkgYmVmb3JlIGRhdGFmbG93IGV2YWx1YXRpb24gY29tbWVuY2VzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Bvc3RydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGFmdGVyIGRhdGFmbG93IGV2YWx1YXRpb24gY29tcGxldGVzLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiAgIGFmdGVyIHRob3NlIHJlZ2lzdGVyZWQgdmlhIHtAbGluayBydW5BZnRlcn0uXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoaXMgZGF0YWZsb3cgYWZ0ZXJcbiAqICAgZXZhbHVhdGlvbiBjb21wbGV0ZXMuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGUoZW5jb2RlLCBwcmVydW4sIHBvc3RydW4pIHtcbiAgY29uc3QgZGYgPSB0aGlzLFxuICAgICAgICBhc3luYyA9IFtdOyAvLyBpZiB0aGUgcHVsc2UgdmFsdWUgaXMgc2V0LCB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsXG5cbiAgaWYgKGRmLl9wdWxzZSkgcmV0dXJuIHJlZW50cmFudChkZik7IC8vIHdhaXQgZm9yIHBlbmRpbmcgZGF0YXNldHMgdG8gbG9hZFxuXG4gIGlmIChkZi5fcGVuZGluZykgYXdhaXQgZGYuX3BlbmRpbmc7IC8vIGludm9rZSBwcmVydW4gZnVuY3Rpb24sIGlmIHByb3ZpZGVkXG5cbiAgaWYgKHByZXJ1bikgYXdhaXQgYXN5bmNDYWxsYmFjayhkZiwgcHJlcnVuKTsgLy8gZXhpdCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gdXBkYXRlc1xuXG4gIGlmICghZGYuX3RvdWNoZWQubGVuZ3RoKSB7XG4gICAgZGYuZGVidWcoJ0RhdGFmbG93IGludm9rZWQsIGJ1dCBub3RoaW5nIHRvIGRvLicpO1xuICAgIHJldHVybiBkZjtcbiAgfSAvLyBpbmNyZW1lbnQgdGltZXN0YW1wIGNsb2NrXG5cblxuICBjb25zdCBzdGFtcCA9ICsrZGYuX2Nsb2NrOyAvLyBzZXQgdGhlIGN1cnJlbnQgcHVsc2VcblxuICBkZi5fcHVsc2UgPSBuZXcgUHVsc2UoZGYsIHN0YW1wLCBlbmNvZGUpOyAvLyBpbml0aWFsaXplIHByaW9yaXR5IHF1ZXVlLCByZXNldCB0b3VjaGVkIG9wZXJhdG9yc1xuXG4gIGRmLl90b3VjaGVkLmZvckVhY2gob3AgPT4gZGYuX2VucXVldWUob3AsIHRydWUpKTtcblxuICBkZi5fdG91Y2hlZCA9IFVuaXF1ZUxpc3QoaWQpO1xuICBsZXQgY291bnQgPSAwLFxuICAgICAgb3AsXG4gICAgICBuZXh0LFxuICAgICAgZXJyb3I7XG5cbiAgdHJ5IHtcbiAgICB3aGlsZSAoZGYuX2hlYXAuc2l6ZSgpID4gMCkge1xuICAgICAgLy8gZGVxdWV1ZSBvcGVyYXRvciB3aXRoIGhpZ2hlc3QgcHJpb3JpdHlcbiAgICAgIG9wID0gZGYuX2hlYXAucG9wKCk7IC8vIHJlLXF1ZXVlIGlmIHJhbmsgY2hhbmdlZFxuXG4gICAgICBpZiAob3AucmFuayAhPT0gb3AucXJhbmspIHtcbiAgICAgICAgZGYuX2VucXVldWUob3AsIHRydWUpO1xuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBvdGhlcndpc2UsIGV2YWx1YXRlIHRoZSBvcGVyYXRvclxuXG5cbiAgICAgIG5leHQgPSBvcC5ydW4oZGYuX2dldFB1bHNlKG9wLCBlbmNvZGUpKTtcblxuICAgICAgaWYgKG5leHQudGhlbikge1xuICAgICAgICAvLyBhd2FpdCBpZiBvcGVyYXRvciByZXR1cm5zIGEgcHJvbWlzZSBkaXJlY3RseVxuICAgICAgICBuZXh0ID0gYXdhaXQgbmV4dDtcbiAgICAgIH0gZWxzZSBpZiAobmV4dC5hc3luYykge1xuICAgICAgICAvLyBxdWV1ZSBwYXJhbGxlbCBhc3luY2hyb25vdXMgZXhlY3V0aW9uXG4gICAgICAgIGFzeW5jLnB1c2gobmV4dC5hc3luYyk7XG4gICAgICAgIG5leHQgPSBTdG9wUHJvcGFnYXRpb247XG4gICAgICB9IC8vIHByb3BhZ2F0ZSBldmFsdWF0aW9uLCBlbnF1ZXVlIGRlcGVuZGVudCBvcGVyYXRvcnNcblxuXG4gICAgICBpZiAobmV4dCAhPT0gU3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGlmIChvcC5fdGFyZ2V0cykgb3AuX3RhcmdldHMuZm9yRWFjaChvcCA9PiBkZi5fZW5xdWV1ZShvcCkpO1xuICAgICAgfSAvLyBpbmNyZW1lbnQgdmlzaXQgY291bnRlclxuXG5cbiAgICAgICsrY291bnQ7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZi5faGVhcC5jbGVhcigpO1xuXG4gICAgZXJyb3IgPSBlcnI7XG4gIH0gLy8gcmVzZXQgcHVsc2UgbWFwXG5cblxuICBkZi5faW5wdXQgPSB7fTtcbiAgZGYuX3B1bHNlID0gbnVsbDtcbiAgZGYuZGVidWcoYFB1bHNlICR7c3RhbXB9OiAke2NvdW50fSBvcGVyYXRvcnNgKTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBkZi5fcG9zdHJ1biA9IFtdO1xuICAgIGRmLmVycm9yKGVycm9yKTtcbiAgfSAvLyBpbnZva2UgY2FsbGJhY2tzIHF1ZXVlZCB2aWEgcnVuQWZ0ZXJcblxuXG4gIGlmIChkZi5fcG9zdHJ1bi5sZW5ndGgpIHtcbiAgICBjb25zdCBwciA9IGRmLl9wb3N0cnVuLnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcblxuICAgIGRmLl9wb3N0cnVuID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByLmxlbmd0aDsgKytpKSB7XG4gICAgICBhd2FpdCBhc3luY0NhbGxiYWNrKGRmLCBwcltpXS5jYWxsYmFjayk7XG4gICAgfVxuICB9IC8vIGludm9rZSBwb3N0cnVuIGZ1bmN0aW9uLCBpZiBwcm92aWRlZFxuXG5cbiAgaWYgKHBvc3RydW4pIGF3YWl0IGFzeW5jQ2FsbGJhY2soZGYsIHBvc3RydW4pOyAvLyBoYW5kbGUgbm9uLWJsb2NraW5nIGFzeW5jaHJvbm91cyBjYWxsYmFja3NcblxuICBpZiAoYXN5bmMubGVuZ3RoKSB7XG4gICAgUHJvbWlzZS5hbGwoYXN5bmMpLnRoZW4oY2IgPT4gZGYucnVuQXN5bmMobnVsbCwgKCkgPT4ge1xuICAgICAgY2IuZm9yRWFjaChmID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmKGRmKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZGYuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIGRmO1xufVxuLyoqXG4gKiBRdWV1ZXMgZGF0YWZsb3cgZXZhbHVhdGlvbiB0byBydW4gb25jZSBhbnkgb3RoZXIgcXVldWVkIGV2YWx1YXRpb25zIGhhdmVcbiAqIGNvbXBsZXRlZCBhbmQgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBxdWV1ZWQgcHVsc2VcbiAqIHByb3BhZ2F0aW9uIGNvbXBsZXRlcy4gSWYgcHJvdmlkZWQsIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkXG4gKiBpbW1lZGlhdGVseSBiZWZvcmUgZXZhbHVhdGlvbiBjb21tZW5jZXMuIFRoaXMgbWV0aG9kIHdpbGwgZW5zdXJlIGFcbiAqIHNlcGFyYXRlIGV2YWx1YXRpb24gaXMgaW52b2tlZCBmb3IgZWFjaCB0aW1lIGl0IGlzIGNhbGxlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RlXSAtIFRoZSBuYW1lIG9mIGFuIGVuY29kaW5nIHNldCB0byBpbnZva2UgZHVyaW5nXG4gKiAgIHByb3BhZ2F0aW9uLiBUaGlzIHZhbHVlIGlzIGFkZGVkIHRvIGdlbmVyYXRlZCBQdWxzZSBpbnN0YW5jZXM7XG4gKiAgIG9wZXJhdG9ycyBjYW4gdGhlbiByZXNwb25kIHRvIChvciBpZ25vcmUpIHRoaXMgc2V0dGluZyBhcyBhcHByb3ByaWF0ZS5cbiAqICAgVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgRW5jb2RlIHRyYW5zZm9ybSBpblxuICogICB0aGUgdmVnYS1lbmNvZGUgcGFja2FnZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcmVydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGltbWVkaWF0ZWx5IGJlZm9yZSBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbW1lbmNlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwb3N0cnVuXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICBhZnRlciBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbXBsZXRlcy4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogICBhZnRlciB0aG9zZSByZWdpc3RlcmVkIHZpYSB7QGxpbmsgcnVuQWZ0ZXJ9LlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGlzIGRhdGFmbG93IGFmdGVyXG4gKiAgIGV2YWx1YXRpb24gY29tcGxldGVzLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bkFzeW5jKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSB7XG4gIC8vIGF3YWl0IHByZXZpb3VzbHkgcXVldWVkIGZ1bmN0aW9uc1xuICB3aGlsZSAodGhpcy5fcnVubmluZykgYXdhaXQgdGhpcy5fcnVubmluZzsgLy8gcnVuIGRhdGFmbG93LCBtYW5hZ2UgcnVubmluZyBwcm9taXNlXG5cblxuICBjb25zdCBjbGVhciA9ICgpID0+IHRoaXMuX3J1bm5pbmcgPSBudWxsO1xuXG4gICh0aGlzLl9ydW5uaW5nID0gdGhpcy5ldmFsdWF0ZShlbmNvZGUsIHByZXJ1biwgcG9zdHJ1bikpLnRoZW4oY2xlYXIsIGNsZWFyKTtcbiAgcmV0dXJuIHRoaXMuX3J1bm5pbmc7XG59XG4vKipcbiAqIFJlcXVlc3RzIGRhdGFmbG93IGV2YWx1YXRpb24gYW5kIHRoZSBpbW1lZGlhdGVseSByZXR1cm5zIHRoaXMgZGF0YWZsb3dcbiAqIGluc3RhbmNlLiBJZiB0aGVyZSBhcmUgcGVuZGluZyBkYXRhIGxvYWRpbmcgb3Igb3RoZXIgYXN5bmNocm9ub3VzXG4gKiBvcGVyYXRpb25zLCB0aGUgZGF0YWZsb3cgd2lsbCBldmFsdWF0ZSBhc3luY2hyb25vdXNseSBhZnRlciB0aGlzIG1ldGhvZFxuICogaGFzIGJlZW4gaW52b2tlZC4gVG8gdHJhY2sgd2hlbiBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbXBsZXRlcywgdXNlIHRoZVxuICoge0BsaW5rIHJ1bkFzeW5jfSBtZXRob2QgaW5zdGVhZC4gVGhpcyBtZXRob2Qgd2lsbCByYWlzZSBhbiBlcnJvciBpZlxuICogaW52b2tlZCB3aGlsZSB0aGUgZGF0YWZsb3cgaXMgYWxyZWFkeSBpbiB0aGUgbWlkc3Qgb2YgZXZhbHVhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RlXSAtIFRoZSBuYW1lIG9mIGFuIGVuY29kaW5nIHNldCB0byBpbnZva2UgZHVyaW5nXG4gKiAgIHByb3BhZ2F0aW9uLiBUaGlzIHZhbHVlIGlzIGFkZGVkIHRvIGdlbmVyYXRlZCBQdWxzZSBpbnN0YW5jZXM7XG4gKiAgIG9wZXJhdG9ycyBjYW4gdGhlbiByZXNwb25kIHRvIChvciBpZ25vcmUpIHRoaXMgc2V0dGluZyBhcyBhcHByb3ByaWF0ZS5cbiAqICAgVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgRW5jb2RlIHRyYW5zZm9ybSBpblxuICogICB0aGUgdmVnYS1lbmNvZGUgbW9kdWxlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3ByZXJ1bl0gLSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgaW1tZWRpYXRlbHkgYmVmb3JlIGRhdGFmbG93IGV2YWx1YXRpb24gY29tbWVuY2VzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Bvc3RydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGFmdGVyIGRhdGFmbG93IGV2YWx1YXRpb24gY29tcGxldGVzLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiAgIGFmdGVyIHRob3NlIHJlZ2lzdGVyZWQgdmlhIHtAbGluayBydW5BZnRlcn0uXG4gKiBAcmV0dXJuIHtEYXRhZmxvd30gLSBUaGlzIGRhdGFmbG93IGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIHJ1bihlbmNvZGUsIHByZXJ1biwgcG9zdHJ1bikge1xuICByZXR1cm4gdGhpcy5fcHVsc2UgPyByZWVudHJhbnQodGhpcykgOiAodGhpcy5ldmFsdWF0ZShlbmNvZGUsIHByZXJ1biwgcG9zdHJ1biksIHRoaXMpO1xufVxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBjdXJyZW50IHB1bHNlXG4gKiBwcm9wYWdhdGlvbiBjb21wbGV0ZXMuIElmIG5vIHByb3BhZ2F0aW9uIGlzIGN1cnJlbnRseSBvY2N1cnJpbmcsXG4gKiB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZCBpbW1lZGlhdGVseS4gQ2FsbGJhY2tzIHNjaGVkdWxlZCB2aWEgcnVuQWZ0ZXJcbiAqIGFyZSBpbnZva2VkIGltbWVkaWF0ZWx5IHVwb24gY29tcGxldGlvbiBvZiB0aGUgY3VycmVudCBjeWNsZSwgYmVmb3JlXG4gKiBhbnkgcmVxdWVzdCBxdWV1ZWQgdmlhIHJ1bkFzeW5jLiBUaGlzIG1ldGhvZCBpcyBwcmltYXJpbHkgaW50ZW5kZWQgZm9yXG4gKiBpbnRlcm5hbCB1c2UuIFRoaXJkLXBhcnR5IGNhbGxlcnMgdXNpbmcgcnVuQWZ0ZXIgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICogdGhhdCBpbnZva2VzIHtAbGluayBydW59IG9yIHtAbGluayBydW5Bc3luY30gc2hvdWxkIG5vdCB1c2UgdGhpcyBtZXRob2QsXG4gKiBidXQgaW5zdGVhZCB1c2Uge0BsaW5rIHJ1bkFzeW5jfSB3aXRoIHByZXJ1biBvciBwb3N0cnVuIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRGF0YWZsb3cpfSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4uXG4gKiAgIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGlzIERhdGFmbG93IGluc3RhbmNlIGFzIGl0c1xuICogICBzb2xlIGFyZ3VtZW50LlxuICogQHBhcmFtIHtib29sZWFufSBlbnF1ZXVlIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZVxuICogICBjYWxsYmFjayBzaG91bGQgYmUgcXVldWVkIHVwIHRvIHJ1biBhZnRlciB0aGUgbmV4dCBwcm9wYWdhdGlvblxuICogICBjeWNsZSwgc3VwcHJlc3NpbmcgaW1tZWRpYXRlIGludm9jYXRpb24gd2hlbiBwcm9wYWdhdGlvbiBpcyBub3RcbiAqICAgY3VycmVudGx5IG9jY3VycmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHldIC0gQSBwcmlvcml0eSB2YWx1ZSB1c2VkIHRvIHNvcnQgcmVnaXN0ZXJlZFxuICogICBjYWxsYmFja3MgdG8gZGV0ZXJtaW5lIGV4ZWN1dGlvbiBvcmRlci4gVGhpcyBhcmd1bWVudCBpcyBpbnRlbmRlZFxuICogICBmb3IgaW50ZXJuYWwgVmVnYSB1c2Ugb25seS5cbiAqL1xuXG5mdW5jdGlvbiBydW5BZnRlcihjYWxsYmFjaywgZW5xdWV1ZSwgcHJpb3JpdHkpIHtcbiAgaWYgKHRoaXMuX3B1bHNlIHx8IGVucXVldWUpIHtcbiAgICAvLyBwdWxzZSBwcm9wYWdhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZywgcXVldWUgdG8gcnVuIGFmdGVyXG4gICAgdGhpcy5fcG9zdHJ1bi5wdXNoKHtcbiAgICAgIHByaW9yaXR5OiBwcmlvcml0eSB8fCAwLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcHVsc2UgcHJvcGFnYXRpb24gYWxyZWFkeSBjb21wbGV0ZSwgaW52b2tlIGltbWVkaWF0ZWx5XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBSYWlzZSBhbiBlcnJvciBmb3IgcmUtZW50cmFudCBkYXRhZmxvdyBldmFsdWF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIHJlZW50cmFudChkZikge1xuICBkZi5lcnJvcignRGF0YWZsb3cgYWxyZWFkeSBydW5uaW5nLiBVc2UgcnVuQXN5bmMoKSB0byBjaGFpbiBpbnZvY2F0aW9ucy4nKTtcbiAgcmV0dXJuIGRmO1xufVxuLyoqXG4gKiBFbnF1ZXVlIGFuIG9wZXJhdG9yIGludG8gdGhlIHByaW9yaXR5IHF1ZXVlIGZvciBldmFsdWF0aW9uLiBUaGUgb3BlcmF0b3JcbiAqIHdpbGwgYmUgZW5xdWV1ZWQgaWYgaXQgaGFzIG5vIHJlZ2lzdGVyZWQgcHVsc2UgZm9yIHRoZSBjdXJyZW50IGN5Y2xlLCBvciBpZlxuICogdGhlIGZvcmNlIGFyZ3VtZW50IGlzIHRydWUuIFVwb24gZW5xdWV1ZSwgdGhpcyBtZXRob2QgYWxzbyBzZXRzIHRoZVxuICogb3BlcmF0b3IncyBxcmFuayB0byB0aGUgY3VycmVudCByYW5rIHZhbHVlLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gZW5xdWV1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSAtIEEgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBvcGVyYXRvciBzaG91bGQgYmVcbiAqICAgZm9yY2VhYmx5IGFkZGVkIHRvIHRoZSBxdWV1ZSwgZXZlbiBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHByZXZpb3VzbHlcbiAqICAgZW5xdWV1ZWQgZHVyaW5nIHRoZSBjdXJyZW50IHB1bHNlIHByb3BhZ2F0aW9uLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRoZVxuICogICBkYXRhZmxvdyBncmFwaCBpcyBkeW5hbWljYWxseSBtb2RpZmllZCBhbmQgdGhlIG9wZXJhdG9yIHJhbmsgY2hhbmdlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVucXVldWUob3AsIGZvcmNlKSB7XG4gIGNvbnN0IHEgPSBvcC5zdGFtcCA8IHRoaXMuX2Nsb2NrO1xuICBpZiAocSkgb3Auc3RhbXAgPSB0aGlzLl9jbG9jaztcblxuICBpZiAocSB8fCBmb3JjZSkge1xuICAgIG9wLnFyYW5rID0gb3AucmFuaztcblxuICAgIHRoaXMuX2hlYXAucHVzaChvcCk7XG4gIH1cbn1cbi8qKlxuICogUHJvdmlkZSBhIGNvcnJlY3QgcHVsc2UgZm9yIGV2YWx1YXRpbmcgYW4gb3BlcmF0b3IuIElmIHRoZSBvcGVyYXRvciBoYXMgYW5cbiAqIGV4cGxpY2l0IHNvdXJjZSBvcGVyYXRvciwgd2Ugd2lsbCB0cnkgdG8gcHVsbCB0aGUgcHVsc2UocykgZnJvbSBpdC5cbiAqIElmIHRoZXJlIGlzIGFuIGFycmF5IG9mIHNvdXJjZSBvcGVyYXRvcnMsIHdlIGJ1aWxkIGEgbXVsdGktcHVsc2UuXG4gKiBPdGhlcndpc2UsIHdlIHJldHVybiBhIGN1cnJlbnQgcHVsc2Ugd2l0aCBjb3JyZWN0IHNvdXJjZSBkYXRhLlxuICogSWYgdGhlIHB1bHNlIGlzIHRoZSBwdWxzZSBtYXAgaGFzIGFuIGV4cGxpY2l0IHRhcmdldCBzZXQsIHdlIHVzZSB0aGF0LlxuICogRWxzZSBpZiB0aGUgcHVsc2Ugb24gdGhlIHVwc3RyZWFtIHNvdXJjZSBvcGVyYXRvciBpcyBjdXJyZW50LCB3ZSB1c2UgdGhhdC5cbiAqIEVsc2Ugd2UgdXNlIHRoZSBwdWxzZSBmcm9tIHRoZSBwdWxzZSBtYXAsIGJ1dCBjb3B5IHRoZSBzb3VyY2UgdHVwbGUgYXJyYXkuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSBvcCAtIFRoZSBvcGVyYXRvciBmb3Igd2hpY2ggdG8gZ2V0IGFuIGlucHV0IHB1bHNlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGVdIC0gQW4gKG9wdGlvbmFsKSBlbmNvZGluZyBzZXQgbmFtZSB3aXRoIHdoaWNoIHRvXG4gKiAgIGFubm90YXRlIHRoZSByZXR1cm5lZCBwdWxzZS4gU2VlIHtAbGluayBydW59IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGdldFB1bHNlKG9wLCBlbmNvZGUpIHtcbiAgY29uc3QgcyA9IG9wLnNvdXJjZSxcbiAgICAgICAgc3RhbXAgPSB0aGlzLl9jbG9jaztcbiAgcmV0dXJuIHMgJiYgaXNBcnJheShzKSA/IG5ldyBNdWx0aVB1bHNlKHRoaXMsIHN0YW1wLCBzLm1hcChfID0+IF8ucHVsc2UpLCBlbmNvZGUpIDogdGhpcy5faW5wdXRbb3AuaWRdIHx8IHNpbmdsZVB1bHNlKHRoaXMuX3B1bHNlLCBzICYmIHMucHVsc2UpO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVQdWxzZShwLCBzKSB7XG4gIGlmIChzICYmIHMuc3RhbXAgPT09IHAuc3RhbXApIHtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIHAgPSBwLmZvcmsoKTtcblxuICBpZiAocyAmJiBzICE9PSBTdG9wUHJvcGFnYXRpb24pIHtcbiAgICBwLnNvdXJjZSA9IHMuc291cmNlO1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmNvbnN0IE5PX09QVCA9IHtcbiAgc2tpcDogZmFsc2UsXG4gIGZvcmNlOiBmYWxzZVxufTtcbi8qKlxuICogVG91Y2hlcyBhbiBvcGVyYXRvciwgc2NoZWR1bGluZyBpdCB0byBiZSBldmFsdWF0ZWQuIElmIGludm9rZWQgb3V0c2lkZSBvZlxuICogYSBwdWxzZSBwcm9wYWdhdGlvbiwgdGhlIG9wZXJhdG9yIHdpbGwgYmUgZXZhbHVhdGVkIHRoZSBuZXh0IHRpbWUgdGhpc1xuICogZGF0YWZsb3cgaXMgcnVuLiBJZiBpbnZva2VkIGluIHRoZSBtaWRzdCBvZiBwdWxzZSBwcm9wYWdhdGlvbiwgdGhlIG9wZXJhdG9yXG4gKiB3aWxsIGJlIHF1ZXVlZCBmb3IgZXZhbHVhdGlvbiBpZiBhbmQgb25seSBpZiB0aGUgb3BlcmF0b3IgaGFzIG5vdCB5ZXQgYmVlblxuICogZXZhbHVhdGVkIG9uIHRoZSBjdXJyZW50IHByb3BhZ2F0aW9uIHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIHRvdWNoLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBoYXNoLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgIGJlIHNraXBwZWQ6IGl0IHdpbGwgbm90IGJlIGV2YWx1YXRlZCwgYnV0IGl0cyBkZXBlbmRlbnRzIHdpbGwgYmUuXG4gKiBAcmV0dXJuIHtEYXRhZmxvd31cbiAqL1xuXG5mdW5jdGlvbiB0b3VjaChvcCwgb3B0aW9ucykge1xuICBjb25zdCBvcHQgPSBvcHRpb25zIHx8IE5PX09QVDtcblxuICBpZiAodGhpcy5fcHVsc2UpIHtcbiAgICAvLyBpZiBpbiBtaWRzdCBvZiBwcm9wYWdhdGlvbiwgYWRkIHRvIHByaW9yaXR5IHF1ZXVlXG4gICAgdGhpcy5fZW5xdWV1ZShvcCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCBxdWV1ZSBmb3IgbmV4dCBwcm9wYWdhdGlvblxuICAgIHRoaXMuX3RvdWNoZWQuYWRkKG9wKTtcbiAgfVxuXG4gIGlmIChvcHQuc2tpcCkgb3Auc2tpcCh0cnVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBvcGVyYXRvci5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBoYXNoLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZV0gLSBJZiB0cnVlLCB0aGUgb3BlcmF0b3Igd2lsbFxuICogICBiZSByZS1ldmFsdWF0ZWQgZXZlbiBpZiBpdHMgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgIGJlIHNraXBwZWQ6IGl0IHdpbGwgbm90IGJlIGV2YWx1YXRlZCwgYnV0IGl0cyBkZXBlbmRlbnRzIHdpbGwgYmUuXG4gKiBAcmV0dXJuIHtEYXRhZmxvd31cbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGUob3AsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnMgfHwgTk9fT1BUO1xuXG4gIGlmIChvcC5zZXQodmFsdWUpIHx8IG9wdC5mb3JjZSkge1xuICAgIHRoaXMudG91Y2gob3AsIG9wdCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogUHVsc2VzIGFuIG9wZXJhdG9yIHdpdGggYSBjaGFuZ2VzZXQgb2YgdHVwbGVzLiBJZiBpbnZva2VkIG91dHNpZGUgb2ZcbiAqIGEgcHVsc2UgcHJvcGFnYXRpb24sIHRoZSBwdWxzZSB3aWxsIGJlIGFwcGxpZWQgdGhlIG5leHQgdGltZSB0aGlzXG4gKiBkYXRhZmxvdyBpcyBydW4uIElmIGludm9rZWQgaW4gdGhlIG1pZHN0IG9mIHB1bHNlIHByb3BhZ2F0aW9uLCB0aGUgcHVsc2VcbiAqIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNldCBvZiBhY3RpdmUgcHVsc2VzIGFuZCB3aWxsIGJlIGFwcGxpZWQgaWYgYW5kXG4gKiBvbmx5IGlmIHRoZSB0YXJnZXQgb3BlcmF0b3IgaGFzIG5vdCB5ZXQgYmVlbiBldmFsdWF0ZWQgb24gdGhlIGN1cnJlbnRcbiAqIHByb3BhZ2F0aW9uIHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIHB1bHNlLlxuICogQHBhcmFtIHtDaGFuZ2VTZXR9IHZhbHVlIC0gVGhlIHR1cGxlIGNoYW5nZXNldCB0byBhcHBseS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgaGFzaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcF0gLSBJZiB0cnVlLCB0aGUgb3BlcmF0b3Igd2lsbFxuICogICBiZSBza2lwcGVkOiBpdCB3aWxsIG5vdCBiZSBldmFsdWF0ZWQsIGJ1dCBpdHMgZGVwZW5kZW50cyB3aWxsIGJlLlxuICogQHJldHVybiB7RGF0YWZsb3d9XG4gKi9cblxuZnVuY3Rpb24gcHVsc2Uob3AsIGNoYW5nZXNldCwgb3B0aW9ucykge1xuICB0aGlzLnRvdWNoKG9wLCBvcHRpb25zIHx8IE5PX09QVCk7XG4gIGNvbnN0IHAgPSBuZXcgUHVsc2UodGhpcywgdGhpcy5fY2xvY2sgKyAodGhpcy5fcHVsc2UgPyAwIDogMSkpLFxuICAgICAgICB0ID0gb3AucHVsc2UgJiYgb3AucHVsc2Uuc291cmNlIHx8IFtdO1xuICBwLnRhcmdldCA9IG9wO1xuICB0aGlzLl9pbnB1dFtvcC5pZF0gPSBjaGFuZ2VzZXQucHVsc2UocCwgdCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBIZWFwKGNtcCkge1xuICBsZXQgbm9kZXMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcjogKCkgPT4gbm9kZXMgPSBbXSxcbiAgICBzaXplOiAoKSA9PiBub2Rlcy5sZW5ndGgsXG4gICAgcGVlazogKCkgPT4gbm9kZXNbMF0sXG4gICAgcHVzaDogeCA9PiB7XG4gICAgICBub2Rlcy5wdXNoKHgpO1xuICAgICAgcmV0dXJuIHNpZnRkb3duKG5vZGVzLCAwLCBub2Rlcy5sZW5ndGggLSAxLCBjbXApO1xuICAgIH0sXG4gICAgcG9wOiAoKSA9PiB7XG4gICAgICBjb25zdCBsYXN0ID0gbm9kZXMucG9wKCk7XG4gICAgICBsZXQgaXRlbTtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gbm9kZXNbMF07XG4gICAgICAgIG5vZGVzWzBdID0gbGFzdDtcbiAgICAgICAgc2lmdHVwKG5vZGVzLCAwLCBjbXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbSA9IGxhc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc2lmdGRvd24oYXJyYXksIHN0YXJ0LCBpZHgsIGNtcCkge1xuICBsZXQgcGFyZW50LCBwaWR4O1xuICBjb25zdCBpdGVtID0gYXJyYXlbaWR4XTtcblxuICB3aGlsZSAoaWR4ID4gc3RhcnQpIHtcbiAgICBwaWR4ID0gaWR4IC0gMSA+PiAxO1xuICAgIHBhcmVudCA9IGFycmF5W3BpZHhdO1xuXG4gICAgaWYgKGNtcChpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgYXJyYXlbaWR4XSA9IHBhcmVudDtcbiAgICAgIGlkeCA9IHBpZHg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBhcnJheVtpZHhdID0gaXRlbTtcbn1cblxuZnVuY3Rpb24gc2lmdHVwKGFycmF5LCBpZHgsIGNtcCkge1xuICBjb25zdCBzdGFydCA9IGlkeCxcbiAgICAgICAgZW5kID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpdGVtID0gYXJyYXlbaWR4XTtcbiAgbGV0IGNpZHggPSAoaWR4IDw8IDEpICsgMSxcbiAgICAgIHJpZHg7XG5cbiAgd2hpbGUgKGNpZHggPCBlbmQpIHtcbiAgICByaWR4ID0gY2lkeCArIDE7XG5cbiAgICBpZiAocmlkeCA8IGVuZCAmJiBjbXAoYXJyYXlbY2lkeF0sIGFycmF5W3JpZHhdKSA+PSAwKSB7XG4gICAgICBjaWR4ID0gcmlkeDtcbiAgICB9XG5cbiAgICBhcnJheVtpZHhdID0gYXJyYXlbY2lkeF07XG4gICAgaWR4ID0gY2lkeDtcbiAgICBjaWR4ID0gKGlkeCA8PCAxKSArIDE7XG4gIH1cblxuICBhcnJheVtpZHhdID0gaXRlbTtcbiAgcmV0dXJuIHNpZnRkb3duKGFycmF5LCBzdGFydCwgaWR4LCBjbXApO1xufVxuXG4vKipcbiAqIEEgZGF0YWZsb3cgZ3JhcGggZm9yIHJlYWN0aXZlIHByb2Nlc3Npbmcgb2YgZGF0YSBzdHJlYW1zLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gRGF0YWZsb3coKSB7XG4gIHRoaXMubG9nZ2VyKGxvZ2dlcigpKTtcbiAgdGhpcy5sb2dMZXZlbChFcnJvcik7XG4gIHRoaXMuX2Nsb2NrID0gMDtcbiAgdGhpcy5fcmFuayA9IDA7XG4gIHRoaXMuX2xvY2FsZSA9IGRlZmF1bHRMb2NhbGUoKTtcblxuICB0cnkge1xuICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcigpO1xuICB9IGNhdGNoIChlKSB7Ly8gZG8gbm90aGluZyBpZiBsb2FkZXIgbW9kdWxlIGlzIHVuYXZhaWxhYmxlXG4gIH1cblxuICB0aGlzLl90b3VjaGVkID0gVW5pcXVlTGlzdChpZCk7XG4gIHRoaXMuX2lucHV0ID0ge307XG4gIHRoaXMuX3B1bHNlID0gbnVsbDtcbiAgdGhpcy5faGVhcCA9IEhlYXAoKGEsIGIpID0+IGEucXJhbmsgLSBiLnFyYW5rKTtcbiAgdGhpcy5fcG9zdHJ1biA9IFtdO1xufVxuXG5mdW5jdGlvbiBsb2dNZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvZ1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbkRhdGFmbG93LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRpbWVzdGFtcCBvZiB0aGlzIGRhdGFmbG93LiBUaGlzIHZhbHVlIHJlZmxlY3RzIHRoZVxuICAgKiB0aW1lc3RhbXAgb2YgdGhlIHByZXZpb3VzIGRhdGFmbG93IHJ1bi4gVGhlIGRhdGFmbG93IGlzIGluaXRpYWxpemVkXG4gICAqIHdpdGggYSBzdGFtcCB2YWx1ZSBvZiAwLiBUaGUgaW5pdGlhbCBydW4gb2YgdGhlIGRhdGFmbG93IHdpbGwgaGF2ZVxuICAgKiBhIHRpbWVzdGFwIG9mIDEsIGFuZCBzbyBvbi4gVGhpcyB2YWx1ZSB3aWxsIG1hdGNoIHRoZVxuICAgKiB7QGxpbmsgUHVsc2Uuc3RhbXB9IHByb3BlcnR5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGN1cnJlbnQgdGltZXN0YW1wIHZhbHVlLlxuICAgKi9cbiAgc3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb2NrO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGxvYWRlciBpbnN0YW5jZSB0byB1c2UgZm9yIGRhdGEgZmlsZSBsb2FkaW5nLiBBXG4gICAqIGxvYWRlciBvYmplY3QgbXVzdCBwcm92aWRlIGEgXCJsb2FkXCIgbWV0aG9kIGZvciBsb2FkaW5nIGZpbGVzIGFuZCBhXG4gICAqIFwic2FuaXRpemVcIiBtZXRob2QgZm9yIGNoZWNraW5nIFVSTC9maWxlbmFtZSB2YWxpZGl0eS4gQm90aCBtZXRob2RzXG4gICAqIHNob3VsZCBhY2NlcHQgYSBVUkkgYW5kIG9wdGlvbnMgaGFzaCBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm4gYSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxvYWRlZCBmaWxlIGNvbnRlbnRzIChsb2FkKSBvciBhIGhhc2ggY29udGFpbmluZ1xuICAgKiBzYW5pdGl6ZWQgVVJJIGRhdGEgd2l0aCB0aGUgc2FuaXRpemVkIHVybCBhc3NpZ25lZCB0byB0aGUgXCJocmVmXCIgcHJvcGVydHlcbiAgICogKHNhbml0aXplKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IF8gLSBUaGUgbG9hZGVyIGluc3RhbmNlIHRvIHVzZS5cbiAgICogQHJldHVybiB7b2JqZWN0fERhdGFmbG93fSAtIElmIG5vIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHJldHVybnNcbiAgICogICB0aGUgY3VycmVudCBsb2FkZXIgaW5zdGFuY2UuIE90aGVyd2lzZSByZXR1cm5zIHRoaXMgRGF0YWZsb3cgaW5zdGFuY2UuXG4gICAqL1xuICBsb2FkZXIoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9sb2FkZXIgPSBfO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGxvY2FsZSBpbnN0YW5jZSB0byB1c2UgZm9yIGZvcm1hdHRpbmcgYW5kIHBhcnNpbmdcbiAgICogc3RyaW5nIHZhbHVlcy4gVGhlIGxvY2FsZSBvYmplY3Qgc2hvdWxkIGJlIHByb3ZpZGVkIGJ5IHRoZVxuICAgKiB2ZWdhLWZvcm1hdCBsaWJyYXJ5LCBhbmQgaW5jbHVkZSBtZXRob2RzIHN1Y2ggYXMgZm9ybWF0LCB0aW1lRm9ybWF0LFxuICAgKiB1dGNGb3JtYXQsIHRpbWVQYXJzZSwgYW5kIHV0Y1BhcnNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gXyAtIFRoZSBsb2NhbGUgaW5zdGFuY2UgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R8RGF0YWZsb3d9IC0gSWYgbm8gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgcmV0dXJuc1xuICAgKiAgIHRoZSBjdXJyZW50IGxvY2FsZSBpbnN0YW5jZS4gT3RoZXJ3aXNlIHJldHVybnMgdGhpcyBEYXRhZmxvdyBpbnN0YW5jZS5cbiAgICovXG4gIGxvY2FsZShfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2xvY2FsZSA9IF87XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvZ2dlciBpbnN0YW5jZSB1c2VkIHRvIGxvZyBtZXNzYWdlcy4gSWYgbm8gYXJndW1lbnRzIGFyZVxuICAgKiBwcm92aWRlZCwgcmV0dXJucyB0aGUgY3VycmVudCBsb2dnZXIgaW5zdGFuY2UuIE90aGVyd2lzZSwgc2V0cyB0aGUgbG9nZ2VyXG4gICAqIGFuZCByZXR1cm4gdGhpcyBEYXRhZmxvdyBpbnN0YW5jZS4gUHJvdmlkZWQgbG9nZ2VycyBtdXN0IHN1cHBvcnQgdGhlIGZ1bGxcbiAgICogQVBJIG9mIGxvZ2dlciBvYmplY3RzIGdlbmVyYXRlZCBieSB0aGUgdmVnYS11dGlsIGxvZ2dlciBtZXRob2QuIE5vdGUgdGhhdFxuICAgKiBieSBkZWZhdWx0IHRoZSBsb2cgbGV2ZWwgb2YgdGhlIG5ldyBsb2dnZXIgd2lsbCBiZSB1c2VkOyB1c2UgdGhlIGxvZ0xldmVsXG4gICAqIG1ldGhvZCB0byBhZGp1c3QgdGhlIGxvZyBsZXZlbCBhcyBuZWVkZWQuXG4gICAqL1xuICBsb2dnZXIobG9nZ2VyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2xvZyA9IGxvZ2dlcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9ncyBhbiBlcnJvciBtZXNzYWdlLiBCeSBkZWZhdWx0LCBsb2dnZWQgbWVzc2FnZXMgYXJlIHdyaXR0ZW4gdG8gY29uc29sZVxuICAgKiBvdXRwdXQuIFRoZSBtZXNzYWdlIHdpbGwgb25seSBiZSBsb2dnZWQgaWYgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGlzIGhpZ2hcbiAgICogZW5vdWdoIHRvIHBlcm1pdCBlcnJvciBtZXNzYWdlcy5cbiAgICovXG4gIGVycm9yOiBsb2dNZXRob2QoJ2Vycm9yJyksXG5cbiAgLyoqXG4gICAqIExvZ3MgYSB3YXJuaW5nIG1lc3NhZ2UuIEJ5IGRlZmF1bHQsIGxvZ2dlZCBtZXNzYWdlcyBhcmUgd3JpdHRlbiB0byBjb25zb2xlXG4gICAqIG91dHB1dC4gVGhlIG1lc3NhZ2Ugd2lsbCBvbmx5IGJlIGxvZ2dlZCBpZiB0aGUgY3VycmVudCBsb2cgbGV2ZWwgaXMgaGlnaFxuICAgKiBlbm91Z2ggdG8gcGVybWl0IHdhcm5pbmcgbWVzc2FnZXMuXG4gICAqL1xuICB3YXJuOiBsb2dNZXRob2QoJ3dhcm4nKSxcblxuICAvKipcbiAgICogTG9ncyBhIGluZm9ybWF0aW9uIG1lc3NhZ2UuIEJ5IGRlZmF1bHQsIGxvZ2dlZCBtZXNzYWdlcyBhcmUgd3JpdHRlbiB0b1xuICAgKiBjb25zb2xlIG91dHB1dC4gVGhlIG1lc3NhZ2Ugd2lsbCBvbmx5IGJlIGxvZ2dlZCBpZiB0aGUgY3VycmVudCBsb2cgbGV2ZWwgaXNcbiAgICogaGlnaCBlbm91Z2ggdG8gcGVybWl0IGluZm9ybWF0aW9uIG1lc3NhZ2VzLlxuICAgKi9cbiAgaW5mbzogbG9nTWV0aG9kKCdpbmZvJyksXG5cbiAgLyoqXG4gICAqIExvZ3MgYSBkZWJ1ZyBtZXNzYWdlLiBCeSBkZWZhdWx0LCBsb2dnZWQgbWVzc2FnZXMgYXJlIHdyaXR0ZW4gdG8gY29uc29sZVxuICAgKiBvdXRwdXQuIFRoZSBtZXNzYWdlIHdpbGwgb25seSBiZSBsb2dnZWQgaWYgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGlzIGhpZ2hcbiAgICogZW5vdWdoIHRvIHBlcm1pdCBkZWJ1ZyBtZXNzYWdlcy5cbiAgICovXG4gIGRlYnVnOiBsb2dNZXRob2QoJ2RlYnVnJyksXG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgbG9nIGxldmVsLiBJZiBhbiBhcmd1bWVudCBpcyBwcm92aWRlZCwgaXRcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBuZXcgbG9nIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xldmVsXSAtIFNob3VsZCBiZSBvbmUgb2YgTm9uZSwgV2FybiwgSW5mb1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGN1cnJlbnQgbG9nIGxldmVsLlxuICAgKi9cbiAgbG9nTGV2ZWw6IGxvZ01ldGhvZCgnbGV2ZWwnKSxcblxuICAvKipcbiAgICogRW1wdHkgZW50cnkgdGhyZXNob2xkIGZvciBnYXJiYWdlIGNsZWFuaW5nLiBNYXAgZGF0YSBzdHJ1Y3R1cmVzIHdpbGxcbiAgICogcGVyZm9ybSBjbGVhbmluZyBvbmNlIHRoZSBudW1iZXIgb2YgZW1wdHkgZW50cmllcyBleGNlZWRzIHRoaXMgdmFsdWUuXG4gICAqL1xuICBjbGVhblRocmVzaG9sZDogMWU0LFxuICAvLyBPUEVSQVRPUiBSRUdJU1RSQVRJT05cbiAgYWRkLFxuICBjb25uZWN0LFxuICByYW5rLFxuICByZXJhbmssXG4gIC8vIE9QRVJBVE9SIFVQREFURVNcbiAgcHVsc2UsXG4gIHRvdWNoLFxuICB1cGRhdGUsXG4gIGNoYW5nZXNldCxcbiAgLy8gREFUQSBMT0FESU5HXG4gIGluZ2VzdCxcbiAgcGFyc2UsXG4gIHByZWxvYWQsXG4gIHJlcXVlc3QsXG4gIC8vIEVWRU5UIEhBTkRMSU5HXG4gIGV2ZW50cyxcbiAgb24sXG4gIC8vIFBVTFNFIFBST1BBR0FUSU9OXG4gIGV2YWx1YXRlLFxuICBydW4sXG4gIHJ1bkFzeW5jLFxuICBydW5BZnRlcixcbiAgX2VucXVldWU6IGVucXVldWUsXG4gIF9nZXRQdWxzZTogZ2V0UHVsc2Vcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIG9wZXJhdG9ycyB0aGF0IHByb2Nlc3MgZGF0YSB0dXBsZXMuXG4gKiBTdWJjbGFzc2VzIG11c3QgcHJvdmlkZSBhIHtAbGluayB0cmFuc2Zvcm19IG1ldGhvZCBmb3Igb3BlcmF0b3IgcHJvY2Vzc2luZy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSBbaW5pdF0gLSBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gW3NvdXJjZV0gLSBUaGUgb3BlcmF0b3IgZnJvbSB3aGljaCB0byByZWNlaXZlIHB1bHNlcy5cbiAqL1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oaW5pdCwgcGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgaW5pdCwgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFRyYW5zZm9ybSwgT3BlcmF0b3IsIHtcbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB7QGxpbmsgT3BlcmF0b3IuZXZhbHVhdGV9IGZvciB0cmFuc2Zvcm0gb3BlcmF0b3JzLlxuICAgKiBJbnRlcm5hbGx5LCB0aGlzIG1ldGhvZCBjYWxscyB7QGxpbmsgZXZhbHVhdGV9IHRvIHBlcmZvcm0gcHJvY2Vzc2luZy5cbiAgICogSWYge0BsaW5rIGV2YWx1YXRlfSByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZSBpbnB1dCBwdWxzZSBpcyByZXR1cm5lZC5cbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIE5PVCBiZSBvdmVycmlkZGVuLCBpbnN0ZWFkIG92ZXJycmlkZSB7QGxpbmsgZXZhbHVhdGV9LlxuICAgKiBAcGFyYW0ge1B1bHNlfSBwdWxzZSAtIHRoZSBjdXJyZW50IGRhdGFmbG93IHB1bHNlLlxuICAgKiBAcmV0dXJuIHRoZSBvdXRwdXQgcHVsc2UgZm9yIHRoaXMgb3BlcmF0b3IgKG9yIFN0b3BQcm9wYWdhdGlvbilcbiAgICovXG4gIHJ1bihwdWxzZSkge1xuICAgIGlmIChwdWxzZS5zdGFtcCA8IHRoaXMuc3RhbXApIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgbGV0IHJ2O1xuXG4gICAgaWYgKHRoaXMuc2tpcCgpKSB7XG4gICAgICB0aGlzLnNraXAoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBydiA9IHRoaXMuZXZhbHVhdGUocHVsc2UpO1xuICAgIH1cblxuICAgIHJ2ID0gcnYgfHwgcHVsc2U7XG5cbiAgICBpZiAocnYudGhlbikge1xuICAgICAgcnYgPSBydi50aGVuKF8gPT4gdGhpcy5wdWxzZSA9IF8pO1xuICAgIH0gZWxzZSBpZiAocnYgIT09IHB1bHNlLlN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgdGhpcy5wdWxzZSA9IHJ2O1xuICAgIH1cblxuICAgIHJldHVybiBydjtcbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHtAbGluayBPcGVyYXRvci5ldmFsdWF0ZX0gZm9yIHRyYW5zZm9ybSBvcGVyYXRvcnMuXG4gICAqIE1hcnNoYWxscyBwYXJhbWV0ZXIgdmFsdWVzIGFuZCB0aGVuIGludm9rZXMge0BsaW5rIHRyYW5zZm9ybX0uXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gdGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4ge1B1bHNlfSBUaGUgb3V0cHV0IHB1bHNlIChvciBTdG9wUHJvcGFnYXRpb24pLiBBIGZhbHN5IHJldHVyblxuICAgICAgIHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkKSB3aWxsIGxldCB0aGUgaW5wdXQgcHVsc2UgcGFzcyB0aHJvdWdoLlxuICAqL1xuICBldmFsdWF0ZShwdWxzZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMubWFyc2hhbGwocHVsc2Uuc3RhbXApLFxuICAgICAgICAgIG91dCA9IHRoaXMudHJhbnNmb3JtKHBhcmFtcywgcHVsc2UpO1xuICAgIHBhcmFtcy5jbGVhcigpO1xuICAgIHJldHVybiBvdXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgaW5jb21pbmcgcHVsc2VzLlxuICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgdHJhbnNmb3Jtcy5cbiAgICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBfIC0gVGhlIG9wZXJhdG9yIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gVGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4ge1B1bHNlfSBUaGUgb3V0cHV0IHB1bHNlIChvciBTdG9wUHJvcGFnYXRpb24pLiBBIGZhbHN5IHJldHVyblxuICAgKiAgIHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkKSB3aWxsIGxldCB0aGUgaW5wdXQgcHVsc2UgcGFzcyB0aHJvdWdoLlxuICAgKi9cbiAgdHJhbnNmb3JtKCkge31cblxufSk7XG5cbmNvbnN0IHRyYW5zZm9ybXMgPSB7fTtcbmZ1bmN0aW9uIGRlZmluaXRpb24odHlwZSkge1xuICBjb25zdCB0ID0gdHJhbnNmb3JtKHR5cGUpO1xuICByZXR1cm4gdCAmJiB0LkRlZmluaXRpb24gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybSh0eXBlKSB7XG4gIHR5cGUgPSB0eXBlICYmIHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRyYW5zZm9ybXMsIHR5cGUpID8gdHJhbnNmb3Jtc1t0eXBlXSA6IG51bGw7XG59XG5cbmV4cG9ydCB7IERhdGFmbG93LCBFdmVudFN0cmVhbSwgTXVsdGlQdWxzZSwgT3BlcmF0b3IsIFBhcmFtZXRlcnMsIFB1bHNlLCBUcmFuc2Zvcm0sIFVuaXF1ZUxpc3QsIGFzeW5jQ2FsbGJhY2ssIGNoYW5nZXNldCwgZGVmaW5pdGlvbiwgZGVyaXZlLCBpbmdlc3QkMSBhcyBpbmdlc3QsIGlzQ2hhbmdlU2V0LCBpc1R1cGxlLCByZWRlcml2ZSwgcmVwbGFjZSwgc3RhYmxlQ29tcGFyZSwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1zLCB0dXBsZWlkIH07XG4iLCJpbXBvcnQgeyBUcmFuc2Zvcm0sIGluZ2VzdCwgdHVwbGVpZCwgc3RhYmxlQ29tcGFyZSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgdGlja0NvdW50LCB0aWNrRm9ybWF0LCB2YWxpZFRpY2tzLCB0aWNrVmFsdWVzLCBTeW1ib2xMZWdlbmQsIGxhYmVsRm9ybWF0LCBsYWJlbFZhbHVlcywgR3JhZGllbnRMZWdlbmQsIHNjYWxlRnJhY3Rpb24sIGxhYmVsRnJhY3Rpb24sIHNjYWxlLCBpc0NvbnRpbnVvdXMsIFNlcXVlbnRpYWwsIExpbmVhciwgVGltZSwgVVRDLCBQb3csIFNxcnQsIE9yZGluYWwsIHNjYWxlSW1wbGljaXQsIExvZywgU3ltbG9nLCBpc0xvZ2FyaXRobWljLCBCaW5PcmRpbmFsLCBiYW5kU3BhY2UsIGlzSW50ZXJwb2xhdGluZywgaW50ZXJwb2xhdGVSYW5nZSwgcXVhbnRpemVJbnRlcnBvbGF0b3IsIGludGVycG9sYXRlQ29sb3JzLCBpbnRlcnBvbGF0ZSwgQmFuZCwgUG9pbnQsIHNjaGVtZSwgVGhyZXNob2xkLCBRdWFudGlsZSwgUXVhbnRpemUsIERpdmVyZ2luZyB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGlzQXJyYXksIGVycm9yLCBmYXN0bWFwLCBmYWxzeSwgaXNGdW5jdGlvbiwgY29uc3RhbnQsIHBlZWssIG9uZSwgdG9TZXQsIGlzU3RyaW5nLCB6b29tTG9nLCB6b29tUG93LCB6b29tU3ltbG9nLCB6b29tTGluZWFyLCBzdHJpbmdWYWx1ZSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBzdW0sIHJhbmdlIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgaW50ZXJwb2xhdGVSb3VuZCwgaW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGUkMSB9IGZyb20gJ2QzLWludGVycG9sYXRlJztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYXhpcyB0aWNrcyBmb3IgdmlzdWFsaXppbmcgYSBzcGF0aWFsIHNjYWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge1NjYWxlfSBwYXJhbXMuc2NhbGUgLSBUaGUgc2NhbGUgdG8gZ2VuZXJhdGUgdGlja3MgZm9yLlxuICogQHBhcmFtIHsqfSBbcGFyYW1zLmNvdW50PTEwXSAtIFRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgdGlja3MsIG9yXG4gKiAgIGRlc2lyZWQgdGljayBpbnRlcnZhbCwgdG8gdXNlLlxuICogQHBhcmFtIHtBcnJheTwqPn0gW3BhcmFtcy52YWx1ZXNdIC0gVGhlIGV4YWN0IHRpY2sgdmFsdWVzIHRvIHVzZS5cbiAqICAgVGhlc2UgbXVzdCBiZSBsZWdhbCBkb21haW4gdmFsdWVzIGZvciB0aGUgcHJvdmlkZWQgc2NhbGUuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgY291bnQgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6c3RyaW5nfSBbcGFyYW1zLmZvcm1hdFNwZWNpZmllcl0gLSBBIGZvcm1hdCBzcGVjaWZpZXJcbiAqICAgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggc2NhbGUudGlja0Zvcm1hdC4gTGVnYWwgdmFsdWVzIGFyZVxuICogICBhbnkgdmFsaWQgZDMgNC4wIGZvcm1hdCBzcGVjaWZpZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopOnN0cmluZ30gW3BhcmFtcy5mb3JtYXRdIC0gVGhlIGZvcm1hdCBmdW5jdGlvbiB0byB1c2UuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgZm9ybWF0U3BlY2lmaWVyIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cblxuZnVuY3Rpb24gQXhpc1RpY2tzKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoQXhpc1RpY2tzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSkge1xuICAgICAgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlID0gcHVsc2UuZGF0YWZsb3cubG9jYWxlKCksXG4gICAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSxcbiAgICAgICAgdGlja3MgPSB0aGlzLnZhbHVlLFxuICAgICAgICBzY2FsZSA9IF8uc2NhbGUsXG4gICAgICAgIHRhbGx5ID0gXy5jb3VudCA9PSBudWxsID8gXy52YWx1ZXMgPyBfLnZhbHVlcy5sZW5ndGggOiAxMCA6IF8uY291bnQsXG4gICAgICAgIGNvdW50ID0gdGlja0NvdW50KHNjYWxlLCB0YWxseSwgXy5taW5zdGVwKSxcbiAgICAgICAgZm9ybWF0ID0gXy5mb3JtYXQgfHwgdGlja0Zvcm1hdChsb2NhbGUsIHNjYWxlLCBjb3VudCwgXy5mb3JtYXRTcGVjaWZpZXIsIF8uZm9ybWF0VHlwZSwgISFfLnZhbHVlcyksXG4gICAgICAgIHZhbHVlcyA9IF8udmFsdWVzID8gdmFsaWRUaWNrcyhzY2FsZSwgXy52YWx1ZXMsIGNvdW50KSA6IHRpY2tWYWx1ZXMoc2NhbGUsIGNvdW50KTtcbiAgICBpZiAodGlja3MpIG91dC5yZW0gPSB0aWNrcztcbiAgICB0aWNrcyA9IHZhbHVlcy5tYXAoKHZhbHVlLCBpKSA9PiBpbmdlc3Qoe1xuICAgICAgaW5kZXg6IGkgLyAodmFsdWVzLmxlbmd0aCAtIDEgfHwgMSksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBsYWJlbDogZm9ybWF0KHZhbHVlKVxuICAgIH0pKTtcblxuICAgIGlmIChfLmV4dHJhICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgLy8gYWRkIGFuIGV4dHJhIHRpY2sgcGVnZ2VkIHRvIHRoZSBpbml0aWFsIGRvbWFpbiB2YWx1ZVxuICAgICAgLy8gdGhpcyBpcyB1c2VkIHRvIGdlbmVyYXRlIGF4ZXMgd2l0aCAnYmlubmVkJyBkb21haW5zXG4gICAgICB0aWNrcy5wdXNoKGluZ2VzdCh7XG4gICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICB2YWx1ZTogdGlja3NbMF0udmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6ICcnXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3V0LnNvdXJjZSA9IHRpY2tzO1xuICAgIG91dC5hZGQgPSB0aWNrcztcbiAgICB0aGlzLnZhbHVlID0gdGlja3M7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBKb2lucyBhIHNldCBvZiBkYXRhIGVsZW1lbnRzIGFnYWluc3QgYSBzZXQgb2YgdmlzdWFsIGl0ZW1zLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG9iamVjdH0gW3BhcmFtcy5pdGVtXSAtIEFuIGl0ZW0gZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBbcGFyYW1zLmtleV0gLSBUaGUga2V5IGZpZWxkIGFzc29jaWF0aW5nIGRhdGEgYW5kIHZpc3VhbCBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBEYXRhSm9pbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEl0ZW1DcmVhdGUoKSB7XG4gIHJldHVybiBpbmdlc3Qoe30pO1xufVxuXG5mdW5jdGlvbiBuZXdNYXAoa2V5KSB7XG4gIGNvbnN0IG1hcCA9IGZhc3RtYXAoKS50ZXN0KHQgPT4gdC5leGl0KTtcblxuICBtYXAubG9va3VwID0gdCA9PiBtYXAuZ2V0KGtleSh0KSk7XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxuaW5oZXJpdHMoRGF0YUpvaW4sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgZGYgPSBwdWxzZS5kYXRhZmxvdyxcbiAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICBpdGVtID0gXy5pdGVtIHx8IGRlZmF1bHRJdGVtQ3JlYXRlLFxuICAgICAgICBrZXkgPSBfLmtleSB8fCB0dXBsZWlkLFxuICAgICAgICBtYXAgPSB0aGlzLnZhbHVlOyAvLyBwcmV2ZW50IHRyYW5zaWVudCAoZS5nLiwgaG92ZXIpIHJlcXVlc3RzIGZyb21cbiAgICAvLyBjYXNjYWRpbmcgYWNyb3NzIG1hcmtzIGRlcml2ZWQgZnJvbSBtYXJrc1xuXG4gICAgaWYgKGlzQXJyYXkob3V0LmVuY29kZSkpIHtcbiAgICAgIG91dC5lbmNvZGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChtYXAgJiYgKF8ubW9kaWZpZWQoJ2tleScpIHx8IHB1bHNlLm1vZGlmaWVkKGtleSkpKSB7XG4gICAgICBlcnJvcignRGF0YUpvaW4gZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllZCBrZXkgZnVuY3Rpb24gb3IgZmllbGRzLicpO1xuICAgIH1cblxuICAgIGlmICghbWFwKSB7XG4gICAgICBwdWxzZSA9IHB1bHNlLmFkZEFsbCgpO1xuICAgICAgdGhpcy52YWx1ZSA9IG1hcCA9IG5ld01hcChrZXkpO1xuICAgIH1cblxuICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiB7XG4gICAgICBjb25zdCBrID0ga2V5KHQpO1xuICAgICAgbGV0IHggPSBtYXAuZ2V0KGspO1xuXG4gICAgICBpZiAoeCkge1xuICAgICAgICBpZiAoeC5leGl0KSB7XG4gICAgICAgICAgbWFwLmVtcHR5LS07XG4gICAgICAgICAgb3V0LmFkZC5wdXNoKHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dC5tb2QucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGl0ZW0odCk7XG4gICAgICAgIG1hcC5zZXQoaywgeCk7XG4gICAgICAgIG91dC5hZGQucHVzaCh4KTtcbiAgICAgIH1cblxuICAgICAgeC5kYXR1bSA9IHQ7XG4gICAgICB4LmV4aXQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgY29uc3QgayA9IGtleSh0KSxcbiAgICAgICAgICAgIHggPSBtYXAuZ2V0KGspO1xuXG4gICAgICBpZiAoeCkge1xuICAgICAgICB4LmRhdHVtID0gdDtcbiAgICAgICAgb3V0Lm1vZC5wdXNoKHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICBjb25zdCBrID0ga2V5KHQpLFxuICAgICAgICAgICAgeCA9IG1hcC5nZXQoayk7XG5cbiAgICAgIGlmICh0ID09PSB4LmRhdHVtICYmICF4LmV4aXQpIHtcbiAgICAgICAgb3V0LnJlbS5wdXNoKHgpO1xuICAgICAgICB4LmV4aXQgPSB0cnVlO1xuICAgICAgICArK21hcC5lbXB0eTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocHVsc2UuY2hhbmdlZChwdWxzZS5BRERfTU9EKSkgb3V0Lm1vZGlmaWVzKCdkYXR1bScpO1xuXG4gICAgaWYgKHB1bHNlLmNsZWFuKCkgfHwgXy5jbGVhbiAmJiBtYXAuZW1wdHkgPiBkZi5jbGVhblRocmVzaG9sZCkge1xuICAgICAgZGYucnVuQWZ0ZXIobWFwLmNsZWFuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEludm9rZXMgZW5jb2RpbmcgZnVuY3Rpb25zIGZvciB2aXN1YWwgaXRlbXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byB0aGUgZW5jb2RpbmcgZnVuY3Rpb25zLiBUaGlzXG4gKiAgIHBhcmFtZXRlciBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0byBhbGwgaW52b2tlZCBlbmNvZGluZyBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcy5tb2Q9ZmFsc2VdIC0gRmxhZyBpbmRpY2F0aW5nIGlmIHR1cGxlcyBpbiB0aGUgaW5wdXRcbiAqICAgbW9kIHNldCB0aGF0IGFyZSB1bm1vZGlmaWVkIGJ5IGVuY29kZXJzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtLmVuY29kZXJzIC0gVGhlIGVuY29kaW5nIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QsIG9iamVjdCk6IGJvb2xlYW59IFtwYXJhbS5lbmNvZGVycy51cGRhdGVdIC0gVXBkYXRlIGVuY29kaW5nIHNldFxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QsIG9iamVjdCk6IGJvb2xlYW59IFtwYXJhbS5lbmNvZGVycy5lbnRlcl0gLSBFbnRlciBlbmNvZGluZyBzZXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0LCBvYmplY3QpOiBib29sZWFufSBbcGFyYW0uZW5jb2RlcnMuZXhpdF0gLSBFeGl0IGVuY29kaW5nIHNldFxuICovXG5cbmZ1bmN0aW9uIEVuY29kZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKEVuY29kZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFERF9SRU0pLFxuICAgICAgICBmbW9kID0gXy5tb2QgfHwgZmFsc2UsXG4gICAgICAgIGVuY29kZXJzID0gXy5lbmNvZGVycyxcbiAgICAgICAgZW5jb2RlID0gcHVsc2UuZW5jb2RlOyAvLyBpZiBhbiBhcnJheSwgdGhlIGVuY29kZSBkaXJlY3RpdmUgaW5jbHVkZXMgYWRkaXRpb25hbCBzZXRzXG4gICAgLy8gdGhhdCBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgZm9yIHRoZSBwcmltYXJ5IHNldCB0byBiZSBpbnZva2VkXG4gICAgLy8gZS5nLiwgb25seSBydW4gdGhlIHVwZGF0ZSBzZXQgaWYgdGhlIGhvdmVyIHNldCBpcyBkZWZpbmVkXG5cbiAgICBpZiAoaXNBcnJheShlbmNvZGUpKSB7XG4gICAgICBpZiAob3V0LmNoYW5nZWQoKSB8fCBlbmNvZGUuZXZlcnkoZSA9PiBlbmNvZGVyc1tlXSkpIHtcbiAgICAgICAgZW5jb2RlID0gZW5jb2RlWzBdO1xuICAgICAgICBvdXQuZW5jb2RlID0gbnVsbDsgLy8gY29uc3VtZSB0YXJnZXRlZCBlbmNvZGUgZGlyZWN0aXZlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH0gLy8gbWFyc2hhbGwgZW5jb2RlciBmdW5jdGlvbnNcblxuXG4gICAgdmFyIHJlZW50ZXIgPSBlbmNvZGUgPT09ICdlbnRlcicsXG4gICAgICAgIHVwZGF0ZSA9IGVuY29kZXJzLnVwZGF0ZSB8fCBmYWxzeSxcbiAgICAgICAgZW50ZXIgPSBlbmNvZGVycy5lbnRlciB8fCBmYWxzeSxcbiAgICAgICAgZXhpdCA9IGVuY29kZXJzLmV4aXQgfHwgZmFsc3ksXG4gICAgICAgIHNldCA9IChlbmNvZGUgJiYgIXJlZW50ZXIgPyBlbmNvZGVyc1tlbmNvZGVdIDogdXBkYXRlKSB8fCBmYWxzeTtcblxuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERCkpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiB7XG4gICAgICAgIGVudGVyKHQsIF8pO1xuICAgICAgICB1cGRhdGUodCwgXyk7XG4gICAgICB9KTtcbiAgICAgIG91dC5tb2RpZmllcyhlbnRlci5vdXRwdXQpO1xuICAgICAgb3V0Lm1vZGlmaWVzKHVwZGF0ZS5vdXRwdXQpO1xuXG4gICAgICBpZiAoc2V0ICE9PSBmYWxzeSAmJiBzZXQgIT09IHVwZGF0ZSkge1xuICAgICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgICAgIHNldCh0LCBfKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dC5tb2RpZmllcyhzZXQub3V0cHV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHVsc2UuY2hhbmdlZChwdWxzZS5SRU0pICYmIGV4aXQgIT09IGZhbHN5KSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgICBleGl0KHQsIF8pO1xuICAgICAgfSk7XG4gICAgICBvdXQubW9kaWZpZXMoZXhpdC5vdXRwdXQpO1xuICAgIH1cblxuICAgIGlmIChyZWVudGVyIHx8IHNldCAhPT0gZmFsc3kpIHtcbiAgICAgIGNvbnN0IGZsYWcgPSBwdWxzZS5NT0QgfCAoXy5tb2RpZmllZCgpID8gcHVsc2UuUkVGTE9XIDogMCk7XG5cbiAgICAgIGlmIChyZWVudGVyKSB7XG4gICAgICAgIHB1bHNlLnZpc2l0KGZsYWcsIHQgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vZCA9IGVudGVyKHQsIF8pIHx8IGZtb2Q7XG4gICAgICAgICAgaWYgKHNldCh0LCBfKSB8fCBtb2QpIG91dC5tb2QucHVzaCh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdXQubW9kLmxlbmd0aCkgb3V0Lm1vZGlmaWVzKGVudGVyLm91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWxzZS52aXNpdChmbGFnLCB0ID0+IHtcbiAgICAgICAgICBpZiAoc2V0KHQsIF8pIHx8IGZtb2QpIG91dC5tb2QucHVzaCh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXQubW9kLmxlbmd0aCkgb3V0Lm1vZGlmaWVzKHNldC5vdXRwdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuY2hhbmdlZCgpID8gb3V0IDogcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBsZWdlbmQgZW50cmllcyBmb3IgdmlzdWFsaXppbmcgYSBzY2FsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtTY2FsZX0gcGFyYW1zLnNjYWxlIC0gVGhlIHNjYWxlIHRvIGdlbmVyYXRlIGl0ZW1zIGZvci5cbiAqIEBwYXJhbSB7Kn0gW3BhcmFtcy5jb3VudD01XSAtIFRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgaXRlbXMsIG9yXG4gKiAgIGRlc2lyZWQgdGljayBpbnRlcnZhbCwgdG8gdXNlLlxuICogQHBhcmFtIHsqfSBbcGFyYW1zLmxpbWl0XSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvXG4gKiAgIGluY2x1ZGUgaW4gYSBzeW1ib2wgbGVnZW5kLlxuICogQHBhcmFtIHtBcnJheTwqPn0gW3BhcmFtcy52YWx1ZXNdIC0gVGhlIGV4YWN0IHRpY2sgdmFsdWVzIHRvIHVzZS5cbiAqICAgVGhlc2UgbXVzdCBiZSBsZWdhbCBkb21haW4gdmFsdWVzIGZvciB0aGUgcHJvdmlkZWQgc2NhbGUuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgY291bnQgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmZvcm1hdFNwZWNpZmllcl0gLSBBIGZvcm1hdCBzcGVjaWZpZXJcbiAqICAgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggc2NhbGUudGlja0Zvcm1hdC4gTGVnYWwgdmFsdWVzIGFyZVxuICogICBhbnkgdmFsaWQgRDMgZm9ybWF0IHNwZWNpZmllciBzdHJpbmcuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopOnN0cmluZ30gW3BhcmFtcy5mb3JtYXRdIC0gVGhlIGZvcm1hdCBmdW5jdGlvbiB0byB1c2UuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgZm9ybWF0U3BlY2lmaWVyIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cblxuZnVuY3Rpb24gTGVnZW5kRW50cmllcyhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG59XG5pbmhlcml0cyhMZWdlbmRFbnRyaWVzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgIT0gbnVsbCAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSBwdWxzZS5kYXRhZmxvdy5sb2NhbGUoKSxcbiAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICBpdGVtcyA9IHRoaXMudmFsdWUsXG4gICAgICAgIHR5cGUgPSBfLnR5cGUgfHwgU3ltYm9sTGVnZW5kLFxuICAgICAgICBzY2FsZSA9IF8uc2NhbGUsXG4gICAgICAgIGxpbWl0ID0gK18ubGltaXQsXG4gICAgICAgIGNvdW50ID0gdGlja0NvdW50KHNjYWxlLCBfLmNvdW50ID09IG51bGwgPyA1IDogXy5jb3VudCwgXy5taW5zdGVwKSxcbiAgICAgICAgbHNraXAgPSAhIV8udmFsdWVzIHx8IHR5cGUgPT09IFN5bWJvbExlZ2VuZCxcbiAgICAgICAgZm9ybWF0ID0gXy5mb3JtYXQgfHwgbGFiZWxGb3JtYXQobG9jYWxlLCBzY2FsZSwgY291bnQsIHR5cGUsIF8uZm9ybWF0U3BlY2lmaWVyLCBfLmZvcm1hdFR5cGUsIGxza2lwKSxcbiAgICAgICAgdmFsdWVzID0gXy52YWx1ZXMgfHwgbGFiZWxWYWx1ZXMoc2NhbGUsIGNvdW50KSxcbiAgICAgICAgZG9tYWluLFxuICAgICAgICBmcmFjdGlvbixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBlbGxpcHNpcztcbiAgICBpZiAoaXRlbXMpIG91dC5yZW0gPSBpdGVtcztcblxuICAgIGlmICh0eXBlID09PSBTeW1ib2xMZWdlbmQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB2YWx1ZXMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgcHVsc2UuZGF0YWZsb3cud2FybignU3ltYm9sIGxlZ2VuZCBjb3VudCBleGNlZWRzIGxpbWl0LCBmaWx0ZXJpbmcgaXRlbXMuJyk7XG4gICAgICAgIGl0ZW1zID0gdmFsdWVzLnNsaWNlKDAsIGxpbWl0IC0gMSk7XG4gICAgICAgIGVsbGlwc2lzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zID0gdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihzaXplID0gXy5zaXplKSkge1xuICAgICAgICAvLyBpZiBmaXJzdCB2YWx1ZSBtYXBzIHRvIHNpemUgemVybywgcmVtb3ZlIGZyb20gbGlzdCAodmVnYSM3MTcpXG4gICAgICAgIGlmICghXy52YWx1ZXMgJiYgc2NhbGUoaXRlbXNbMF0pID09PSAwKSB7XG4gICAgICAgICAgaXRlbXMgPSBpdGVtcy5zbGljZSgxKTtcbiAgICAgICAgfSAvLyBjb21wdXRlIHNpemUgb2Zmc2V0IGZvciBsZWdlbmQgZW50cmllc1xuXG5cbiAgICAgICAgb2Zmc2V0ID0gaXRlbXMucmVkdWNlKChtYXgsIHZhbHVlKSA9PiBNYXRoLm1heChtYXgsIHNpemUodmFsdWUsIF8pKSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gY29uc3RhbnQob2Zmc2V0ID0gc2l6ZSB8fCA4KTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMgPSBpdGVtcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4gaW5nZXN0KHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBsYWJlbDogZm9ybWF0KHZhbHVlLCBpbmRleCwgaXRlbXMpLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBzaXplOiBzaXplKHZhbHVlLCBfKVxuICAgICAgfSkpO1xuXG4gICAgICBpZiAoZWxsaXBzaXMpIHtcbiAgICAgICAgZWxsaXBzaXMgPSB2YWx1ZXNbaXRlbXMubGVuZ3RoXTtcbiAgICAgICAgaXRlbXMucHVzaChpbmdlc3Qoe1xuICAgICAgICAgIGluZGV4OiBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgbGFiZWw6IFwiXFx1MjAyNlwiLmNvbmNhdCh2YWx1ZXMubGVuZ3RoIC0gaXRlbXMubGVuZ3RoLCBcIiBlbnRyaWVzXCIpLFxuICAgICAgICAgIHZhbHVlOiBlbGxpcHNpcyxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICBzaXplOiBzaXplKGVsbGlwc2lzLCBfKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBHcmFkaWVudExlZ2VuZCkge1xuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluKCksIGZyYWN0aW9uID0gc2NhbGVGcmFjdGlvbihzY2FsZSwgZG9tYWluWzBdLCBwZWVrKGRvbWFpbikpOyAvLyBpZiBhdXRvbWF0aWMgbGFiZWwgZ2VuZXJhdGlvbiBwcm9kdWNlcyAyIG9yIGZld2VyIHZhbHVlcyxcbiAgICAgIC8vIHVzZSB0aGUgZG9tYWluIGVuZCBwb2ludHMgaW5zdGVhZCAoZml4ZXMgdmVnYS92ZWdhIzEzNjQpXG5cbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoIDwgMyAmJiAhXy52YWx1ZXMgJiYgZG9tYWluWzBdICE9PSBwZWVrKGRvbWFpbikpIHtcbiAgICAgICAgdmFsdWVzID0gW2RvbWFpblswXSwgcGVlayhkb21haW4pXTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMgPSB2YWx1ZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+IGluZ2VzdCh7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgbGFiZWw6IGZvcm1hdCh2YWx1ZSwgaW5kZXgsIHZhbHVlcyksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcGVyYzogZnJhY3Rpb24odmFsdWUpXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICAgIGZyYWN0aW9uID0gbGFiZWxGcmFjdGlvbihzY2FsZSk7XG4gICAgICBpdGVtcyA9IHZhbHVlcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4gaW5nZXN0KHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBsYWJlbDogZm9ybWF0KHZhbHVlLCBpbmRleCwgdmFsdWVzKSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBwZXJjOiBpbmRleCA/IGZyYWN0aW9uKHZhbHVlKSA6IDAsXG4gICAgICAgIHBlcmMyOiBpbmRleCA9PT0gc2l6ZSA/IDEgOiBmcmFjdGlvbih2YWx1ZXNbaW5kZXggKyAxXSlcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvdXQuc291cmNlID0gaXRlbXM7XG4gICAgb3V0LmFkZCA9IGl0ZW1zO1xuICAgIHRoaXMudmFsdWUgPSBpdGVtcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5jb25zdCBzb3VyY2VYID0gdCA9PiB0LnNvdXJjZS54O1xuXG5jb25zdCBzb3VyY2VZID0gdCA9PiB0LnNvdXJjZS55O1xuXG5jb25zdCB0YXJnZXRYID0gdCA9PiB0LnRhcmdldC54O1xuXG5jb25zdCB0YXJnZXRZID0gdCA9PiB0LnRhcmdldC55O1xuLyoqXG4gKiBMYXlvdXQgcGF0aHMgbGlua2luZyBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cblxuZnVuY3Rpb24gTGlua1BhdGgocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIHt9LCBwYXJhbXMpO1xufVxuTGlua1BhdGguRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnTGlua1BhdGgnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzb3VyY2VYJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiAnc291cmNlLngnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3VyY2VZJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiAnc291cmNlLnknXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0YXJnZXRYJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiAndGFyZ2V0LngnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0YXJnZXRZJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiAndGFyZ2V0LnknXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcmllbnQnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICdkZWZhdWx0JzogJ3ZlcnRpY2FsJyxcbiAgICAndmFsdWVzJzogWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ3JhZGlhbCddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzaGFwZScsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAnbGluZScsXG4gICAgJ3ZhbHVlcyc6IFsnbGluZScsICdhcmMnLCAnY3VydmUnLCAnZGlhZ29uYWwnLCAnb3J0aG9nb25hbCddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyZXF1aXJlJyxcbiAgICAndHlwZSc6ICdzaWduYWwnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdwYXRoJ1xuICB9XVxufTtcbmluaGVyaXRzKExpbmtQYXRoLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIHN4ID0gXy5zb3VyY2VYIHx8IHNvdXJjZVgsXG4gICAgICAgIHN5ID0gXy5zb3VyY2VZIHx8IHNvdXJjZVksXG4gICAgICAgIHR4ID0gXy50YXJnZXRYIHx8IHRhcmdldFgsXG4gICAgICAgIHR5ID0gXy50YXJnZXRZIHx8IHRhcmdldFksXG4gICAgICAgIGFzID0gXy5hcyB8fCAncGF0aCcsXG4gICAgICAgIG9yaWVudCA9IF8ub3JpZW50IHx8ICd2ZXJ0aWNhbCcsXG4gICAgICAgIHNoYXBlID0gXy5zaGFwZSB8fCAnbGluZScsXG4gICAgICAgIHBhdGggPSBQYXRocy5nZXQoc2hhcGUgKyAnLScgKyBvcmllbnQpIHx8IFBhdGhzLmdldChzaGFwZSk7XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIGVycm9yKCdMaW5rUGF0aCB1bnN1cHBvcnRlZCB0eXBlOiAnICsgXy5zaGFwZSArIChfLm9yaWVudCA/ICctJyArIF8ub3JpZW50IDogJycpKTtcbiAgICB9XG5cbiAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgICAgdFthc10gPSBwYXRoKHN4KHQpLCBzeSh0KSwgdHgodCksIHR5KHQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5jb25zdCBsaW5lID0gKHN4LCBzeSwgdHgsIHR5KSA9PiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0wnICsgdHggKyAnLCcgKyB0eTtcblxuY29uc3QgbGluZVIgPSAoc2EsIHNyLCB0YSwgdHIpID0+IGxpbmUoc3IgKiBNYXRoLmNvcyhzYSksIHNyICogTWF0aC5zaW4oc2EpLCB0ciAqIE1hdGguY29zKHRhKSwgdHIgKiBNYXRoLnNpbih0YSkpO1xuXG5jb25zdCBhcmMgPSAoc3gsIHN5LCB0eCwgdHkpID0+IHtcbiAgdmFyIGR4ID0gdHggLSBzeCxcbiAgICAgIGR5ID0gdHkgLSBzeSxcbiAgICAgIHJyID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAvIDIsXG4gICAgICByYSA9IDE4MCAqIE1hdGguYXRhbjIoZHksIGR4KSAvIE1hdGguUEk7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0EnICsgcnIgKyAnLCcgKyByciArICcgJyArIHJhICsgJyAwIDEnICsgJyAnICsgdHggKyAnLCcgKyB0eTtcbn07XG5cbmNvbnN0IGFyY1IgPSAoc2EsIHNyLCB0YSwgdHIpID0+IGFyYyhzciAqIE1hdGguY29zKHNhKSwgc3IgKiBNYXRoLnNpbihzYSksIHRyICogTWF0aC5jb3ModGEpLCB0ciAqIE1hdGguc2luKHRhKSk7XG5cbmNvbnN0IGN1cnZlID0gKHN4LCBzeSwgdHgsIHR5KSA9PiB7XG4gIGNvbnN0IGR4ID0gdHggLSBzeCxcbiAgICAgICAgZHkgPSB0eSAtIHN5LFxuICAgICAgICBpeCA9IDAuMiAqIChkeCArIGR5KSxcbiAgICAgICAgaXkgPSAwLjIgKiAoZHkgLSBkeCk7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0MnICsgKHN4ICsgaXgpICsgJywnICsgKHN5ICsgaXkpICsgJyAnICsgKHR4ICsgaXkpICsgJywnICsgKHR5IC0gaXgpICsgJyAnICsgdHggKyAnLCcgKyB0eTtcbn07XG5cbmNvbnN0IGN1cnZlUiA9IChzYSwgc3IsIHRhLCB0cikgPT4gY3VydmUoc3IgKiBNYXRoLmNvcyhzYSksIHNyICogTWF0aC5zaW4oc2EpLCB0ciAqIE1hdGguY29zKHRhKSwgdHIgKiBNYXRoLnNpbih0YSkpO1xuXG5jb25zdCBvcnRob1ggPSAoc3gsIHN5LCB0eCwgdHkpID0+ICdNJyArIHN4ICsgJywnICsgc3kgKyAnVicgKyB0eSArICdIJyArIHR4O1xuXG5jb25zdCBvcnRob1kgPSAoc3gsIHN5LCB0eCwgdHkpID0+ICdNJyArIHN4ICsgJywnICsgc3kgKyAnSCcgKyB0eCArICdWJyArIHR5O1xuXG5jb25zdCBvcnRob1IgPSAoc2EsIHNyLCB0YSwgdHIpID0+IHtcbiAgY29uc3Qgc2MgPSBNYXRoLmNvcyhzYSksXG4gICAgICAgIHNzID0gTWF0aC5zaW4oc2EpLFxuICAgICAgICB0YyA9IE1hdGguY29zKHRhKSxcbiAgICAgICAgdHMgPSBNYXRoLnNpbih0YSksXG4gICAgICAgIHNmID0gTWF0aC5hYnModGEgLSBzYSkgPiBNYXRoLlBJID8gdGEgPD0gc2EgOiB0YSA+IHNhO1xuICByZXR1cm4gJ00nICsgc3IgKiBzYyArICcsJyArIHNyICogc3MgKyAnQScgKyBzciArICcsJyArIHNyICsgJyAwIDAsJyArIChzZiA/IDEgOiAwKSArICcgJyArIHNyICogdGMgKyAnLCcgKyBzciAqIHRzICsgJ0wnICsgdHIgKiB0YyArICcsJyArIHRyICogdHM7XG59O1xuXG5jb25zdCBkaWFnb25hbFggPSAoc3gsIHN5LCB0eCwgdHkpID0+IHtcbiAgY29uc3QgbSA9IChzeCArIHR4KSAvIDI7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0MnICsgbSArICcsJyArIHN5ICsgJyAnICsgbSArICcsJyArIHR5ICsgJyAnICsgdHggKyAnLCcgKyB0eTtcbn07XG5cbmNvbnN0IGRpYWdvbmFsWSA9IChzeCwgc3ksIHR4LCB0eSkgPT4ge1xuICBjb25zdCBtID0gKHN5ICsgdHkpIC8gMjtcbiAgcmV0dXJuICdNJyArIHN4ICsgJywnICsgc3kgKyAnQycgKyBzeCArICcsJyArIG0gKyAnICcgKyB0eCArICcsJyArIG0gKyAnICcgKyB0eCArICcsJyArIHR5O1xufTtcblxuY29uc3QgZGlhZ29uYWxSID0gKHNhLCBzciwgdGEsIHRyKSA9PiB7XG4gIGNvbnN0IHNjID0gTWF0aC5jb3Moc2EpLFxuICAgICAgICBzcyA9IE1hdGguc2luKHNhKSxcbiAgICAgICAgdGMgPSBNYXRoLmNvcyh0YSksXG4gICAgICAgIHRzID0gTWF0aC5zaW4odGEpLFxuICAgICAgICBtciA9IChzciArIHRyKSAvIDI7XG4gIHJldHVybiAnTScgKyBzciAqIHNjICsgJywnICsgc3IgKiBzcyArICdDJyArIG1yICogc2MgKyAnLCcgKyBtciAqIHNzICsgJyAnICsgbXIgKiB0YyArICcsJyArIG1yICogdHMgKyAnICcgKyB0ciAqIHRjICsgJywnICsgdHIgKiB0cztcbn07XG5cbmNvbnN0IFBhdGhzID0gZmFzdG1hcCh7XG4gICdsaW5lJzogbGluZSxcbiAgJ2xpbmUtcmFkaWFsJzogbGluZVIsXG4gICdhcmMnOiBhcmMsXG4gICdhcmMtcmFkaWFsJzogYXJjUixcbiAgJ2N1cnZlJzogY3VydmUsXG4gICdjdXJ2ZS1yYWRpYWwnOiBjdXJ2ZVIsXG4gICdvcnRob2dvbmFsLWhvcml6b250YWwnOiBvcnRob1gsXG4gICdvcnRob2dvbmFsLXZlcnRpY2FsJzogb3J0aG9ZLFxuICAnb3J0aG9nb25hbC1yYWRpYWwnOiBvcnRob1IsXG4gICdkaWFnb25hbC1ob3Jpem9udGFsJzogZGlhZ29uYWxYLFxuICAnZGlhZ29uYWwtdmVydGljYWwnOiBkaWFnb25hbFksXG4gICdkaWFnb25hbC1yYWRpYWwnOiBkaWFnb25hbFJcbn0pO1xuXG4vKipcbiAqIFBpZSBhbmQgZG9udXQgY2hhcnQgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBzaXplIHBpZSBzZWdtZW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0YXJ0QW5nbGU9MF0gLSBUaGUgc3RhcnQgYW5nbGUgKGluIHJhZGlhbnMpIG9mIHRoZSBsYXlvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5lbmRBbmdsZT0yz4BdIC0gVGhlIGVuZCBhbmdsZSAoaW4gcmFkaWFucykgb2YgdGhlIGxheW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5zb3J0XSAtIEJvb2xlYW4gZmxhZyBmb3Igc29ydGluZyBzZWN0b3JzIGJ5IHZhbHVlLlxuICovXG5cbmZ1bmN0aW9uIFBpZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblBpZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdQaWUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGFydEFuZ2xlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZW5kQW5nbGUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiA2LjI4MzE4NTMwNzE3OTU4NlxuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddXG4gIH1dXG59O1xuaW5oZXJpdHMoUGllLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIGFzID0gXy5hcyB8fCBbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSxcbiAgICAgICAgc3RhcnRBbmdsZSA9IGFzWzBdLFxuICAgICAgICBlbmRBbmdsZSA9IGFzWzFdLFxuICAgICAgICBmaWVsZCA9IF8uZmllbGQgfHwgb25lLFxuICAgICAgICBzdGFydCA9IF8uc3RhcnRBbmdsZSB8fCAwLFxuICAgICAgICBzdG9wID0gXy5lbmRBbmdsZSAhPSBudWxsID8gXy5lbmRBbmdsZSA6IDIgKiBNYXRoLlBJLFxuICAgICAgICBkYXRhID0gcHVsc2Uuc291cmNlLFxuICAgICAgICB2YWx1ZXMgPSBkYXRhLm1hcChmaWVsZCksXG4gICAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBhID0gc3RhcnQsXG4gICAgICAgIGsgPSAoc3RvcCAtIHN0YXJ0KSAvIHN1bSh2YWx1ZXMpLFxuICAgICAgICBpbmRleCA9IHJhbmdlKG4pLFxuICAgICAgICBpLFxuICAgICAgICB0LFxuICAgICAgICB2O1xuXG4gICAgaWYgKF8uc29ydCkge1xuICAgICAgaW5kZXguc29ydCgoYSwgYikgPT4gdmFsdWVzW2FdIC0gdmFsdWVzW2JdKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2ID0gdmFsdWVzW2luZGV4W2ldXTtcbiAgICAgIHQgPSBkYXRhW2luZGV4W2ldXTtcbiAgICAgIHRbc3RhcnRBbmdsZV0gPSBhO1xuICAgICAgdFtlbmRBbmdsZV0gPSBhICs9IHYgKiBrO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuY29uc3QgREVGQVVMVF9DT1VOVCA9IDU7XG5cbmZ1bmN0aW9uIGluY2x1ZGVaZXJvKHNjYWxlKSB7XG4gIGNvbnN0IHR5cGUgPSBzY2FsZS50eXBlO1xuICByZXR1cm4gIXNjYWxlLmJpbnMgJiYgKHR5cGUgPT09IExpbmVhciB8fCB0eXBlID09PSBQb3cgfHwgdHlwZSA9PT0gU3FydCk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVQYWQodHlwZSkge1xuICByZXR1cm4gaXNDb250aW51b3VzKHR5cGUpICYmIHR5cGUgIT09IFNlcXVlbnRpYWw7XG59XG5cbmNvbnN0IFNLSVAgPSB0b1NldChbJ3NldCcsICdtb2RpZmllZCcsICdjbGVhcicsICd0eXBlJywgJ3NjaGVtZScsICdzY2hlbWVFeHRlbnQnLCAnc2NoZW1lQ291bnQnLCAnZG9tYWluJywgJ2RvbWFpbk1pbicsICdkb21haW5NaWQnLCAnZG9tYWluTWF4JywgJ2RvbWFpblJhdycsICdkb21haW5JbXBsaWNpdCcsICduaWNlJywgJ3plcm8nLCAnYmlucycsICdyYW5nZScsICdyYW5nZVN0ZXAnLCAncm91bmQnLCAncmV2ZXJzZScsICdpbnRlcnBvbGF0ZScsICdpbnRlcnBvbGF0ZUdhbW1hJ10pO1xuLyoqXG4gKiBNYWludGFpbnMgYSBzY2FsZSBmdW5jdGlvbiBtYXBwaW5nIGRhdGEgdmFsdWVzIHRvIHZpc3VhbCBjaGFubmVscy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIFNjYWxlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xuICB0aGlzLm1vZGlmaWVkKHRydWUpOyAvLyBhbHdheXMgdHJlYXQgYXMgbW9kaWZpZWRcbn1cbmluaGVyaXRzKFNjYWxlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIGRmID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICAgIHNjYWxlJDEgPSB0aGlzLnZhbHVlLFxuICAgICAgICBrZXkgPSBzY2FsZUtleShfKTtcblxuICAgIGlmICghc2NhbGUkMSB8fCBrZXkgIT09IHNjYWxlJDEudHlwZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHNjYWxlJDEgPSBzY2FsZShrZXkpKCk7XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gXykgaWYgKCFTS0lQW2tleV0pIHtcbiAgICAgIC8vIHBhZGRpbmcgaXMgYSBzY2FsZSBwcm9wZXJ0eSBmb3IgYmFuZC9wb2ludCBidXQgbm90IG90aGVyc1xuICAgICAgaWYgKGtleSA9PT0gJ3BhZGRpbmcnICYmIGluY2x1ZGVQYWQoc2NhbGUkMS50eXBlKSkgY29udGludWU7IC8vIGludm9rZSBzY2FsZSBwcm9wZXJ0eSBzZXR0ZXIsIHJhaXNlIHdhcm5pbmcgaWYgbm90IGZvdW5kXG5cbiAgICAgIGlzRnVuY3Rpb24oc2NhbGUkMVtrZXldKSA/IHNjYWxlJDFba2V5XShfW2tleV0pIDogZGYud2FybignVW5zdXBwb3J0ZWQgc2NhbGUgcHJvcGVydHk6ICcgKyBrZXkpO1xuICAgIH1cblxuICAgIGNvbmZpZ3VyZVJhbmdlKHNjYWxlJDEsIF8sIGNvbmZpZ3VyZUJpbnMoc2NhbGUkMSwgXywgY29uZmlndXJlRG9tYWluKHNjYWxlJDEsIF8sIGRmKSkpO1xuICAgIHJldHVybiBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHNjYWxlS2V5KF8pIHtcbiAgdmFyIHQgPSBfLnR5cGUsXG4gICAgICBkID0gJycsXG4gICAgICBuOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwcmUgVmVnYSA1LlxuXG4gIGlmICh0ID09PSBTZXF1ZW50aWFsKSByZXR1cm4gU2VxdWVudGlhbCArICctJyArIExpbmVhcjtcblxuICBpZiAoaXNDb250aW51b3VzQ29sb3IoXykpIHtcbiAgICBuID0gXy5yYXdEb21haW4gPyBfLnJhd0RvbWFpbi5sZW5ndGggOiBfLmRvbWFpbiA/IF8uZG9tYWluLmxlbmd0aCArICsoXy5kb21haW5NaWQgIT0gbnVsbCkgOiAwO1xuICAgIGQgPSBuID09PSAyID8gU2VxdWVudGlhbCArICctJyA6IG4gPT09IDMgPyBEaXZlcmdpbmcgKyAnLScgOiAnJztcbiAgfVxuXG4gIHJldHVybiAoZCArIHQgfHwgTGluZWFyKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBpc0NvbnRpbnVvdXNDb2xvcihfKSB7XG4gIGNvbnN0IHQgPSBfLnR5cGU7XG4gIHJldHVybiBpc0NvbnRpbnVvdXModCkgJiYgdCAhPT0gVGltZSAmJiB0ICE9PSBVVEMgJiYgKF8uc2NoZW1lIHx8IF8ucmFuZ2UgJiYgXy5yYW5nZS5sZW5ndGggJiYgXy5yYW5nZS5ldmVyeShpc1N0cmluZykpO1xufVxuXG5mdW5jdGlvbiBjb25maWd1cmVEb21haW4oc2NhbGUsIF8sIGRmKSB7XG4gIC8vIGNoZWNrIHJhdyBkb21haW4sIGlmIHByb3ZpZGVkIHVzZSB0aGF0IGFuZCBleGl0IGVhcmx5XG4gIGNvbnN0IHJhdyA9IHJhd0RvbWFpbihzY2FsZSwgXy5kb21haW5SYXcsIGRmKTtcbiAgaWYgKHJhdyA+IC0xKSByZXR1cm4gcmF3O1xuICB2YXIgZG9tYWluID0gXy5kb21haW4sXG4gICAgICB0eXBlID0gc2NhbGUudHlwZSxcbiAgICAgIHplcm8gPSBfLnplcm8gfHwgXy56ZXJvID09PSB1bmRlZmluZWQgJiYgaW5jbHVkZVplcm8oc2NhbGUpLFxuICAgICAgbixcbiAgICAgIG1pZDtcbiAgaWYgKCFkb21haW4pIHJldHVybiAwOyAvLyBhZGp1c3QgY29udGludW91cyBkb21haW4gZm9yIG1pbmltdW0gcGl4ZWwgcGFkZGluZ1xuXG4gIGlmIChpbmNsdWRlUGFkKHR5cGUpICYmIF8ucGFkZGluZyAmJiBkb21haW5bMF0gIT09IHBlZWsoZG9tYWluKSkge1xuICAgIGRvbWFpbiA9IHBhZERvbWFpbih0eXBlLCBkb21haW4sIF8ucmFuZ2UsIF8ucGFkZGluZywgXy5leHBvbmVudCwgXy5jb25zdGFudCk7XG4gIH0gLy8gYWRqdXN0IGRvbWFpbiBiYXNlZCBvbiB6ZXJvLCBtaW4sIG1heCBzZXR0aW5nc1xuXG5cbiAgaWYgKHplcm8gfHwgXy5kb21haW5NaW4gIT0gbnVsbCB8fCBfLmRvbWFpbk1heCAhPSBudWxsIHx8IF8uZG9tYWluTWlkICE9IG51bGwpIHtcbiAgICBuID0gKGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpKS5sZW5ndGggLSAxIHx8IDE7XG5cbiAgICBpZiAoemVybykge1xuICAgICAgaWYgKGRvbWFpblswXSA+IDApIGRvbWFpblswXSA9IDA7XG4gICAgICBpZiAoZG9tYWluW25dIDwgMCkgZG9tYWluW25dID0gMDtcbiAgICB9XG5cbiAgICBpZiAoXy5kb21haW5NaW4gIT0gbnVsbCkgZG9tYWluWzBdID0gXy5kb21haW5NaW47XG4gICAgaWYgKF8uZG9tYWluTWF4ICE9IG51bGwpIGRvbWFpbltuXSA9IF8uZG9tYWluTWF4O1xuXG4gICAgaWYgKF8uZG9tYWluTWlkICE9IG51bGwpIHtcbiAgICAgIG1pZCA9IF8uZG9tYWluTWlkO1xuICAgICAgY29uc3QgaSA9IG1pZCA+IGRvbWFpbltuXSA/IG4gKyAxIDogbWlkIDwgZG9tYWluWzBdID8gMCA6IG47XG4gICAgICBpZiAoaSAhPT0gbikgZGYud2FybignU2NhbGUgZG9tYWluTWlkIGV4Y2VlZHMgZG9tYWluIG1pbiBvciBtYXguJywgbWlkKTtcbiAgICAgIGRvbWFpbi5zcGxpY2UoaSwgMCwgbWlkKTtcbiAgICB9XG4gIH0gLy8gc2V0IHRoZSBzY2FsZSBkb21haW5cblxuXG4gIHNjYWxlLmRvbWFpbihkb21haW5DaGVjayh0eXBlLCBkb21haW4sIGRmKSk7IC8vIGlmIG9yZGluYWwgc2NhbGUgZG9tYWluIGlzIGRlZmluZWQsIHByZXZlbnQgaW1wbGljaXRcbiAgLy8gZG9tYWluIGNvbnN0cnVjdGlvbiBhcyBzaWRlLWVmZmVjdCBvZiBzY2FsZSBsb29rdXBcblxuICBpZiAodHlwZSA9PT0gT3JkaW5hbCkge1xuICAgIHNjYWxlLnVua25vd24oXy5kb21haW5JbXBsaWNpdCA/IHNjYWxlSW1wbGljaXQgOiB1bmRlZmluZWQpO1xuICB9IC8vIHBlcmZvcm0gJ25pY2UnIGFkanVzdG1lbnQgYXMgcmVxdWVzdGVkXG5cblxuICBpZiAoXy5uaWNlICYmIHNjYWxlLm5pY2UpIHtcbiAgICBzY2FsZS5uaWNlKF8ubmljZSAhPT0gdHJ1ZSAmJiB0aWNrQ291bnQoc2NhbGUsIF8ubmljZSkgfHwgbnVsbCk7XG4gIH0gLy8gcmV0dXJuIHRoZSBjYXJkaW5hbGl0eSBvZiB0aGUgZG9tYWluXG5cblxuICByZXR1cm4gZG9tYWluLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gcmF3RG9tYWluKHNjYWxlLCByYXcsIGRmKSB7XG4gIGlmIChyYXcpIHtcbiAgICBzY2FsZS5kb21haW4oZG9tYWluQ2hlY2soc2NhbGUudHlwZSwgcmF3LCBkZikpO1xuICAgIHJldHVybiByYXcubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWREb21haW4odHlwZSwgZG9tYWluLCByYW5nZSwgcGFkLCBleHBvbmVudCwgY29uc3RhbnQpIHtcbiAgdmFyIHNwYW4gPSBNYXRoLmFicyhwZWVrKHJhbmdlKSAtIHJhbmdlWzBdKSxcbiAgICAgIGZyYWMgPSBzcGFuIC8gKHNwYW4gLSAyICogcGFkKSxcbiAgICAgIGQgPSB0eXBlID09PSBMb2cgPyB6b29tTG9nKGRvbWFpbiwgbnVsbCwgZnJhYykgOiB0eXBlID09PSBTcXJ0ID8gem9vbVBvdyhkb21haW4sIG51bGwsIGZyYWMsIDAuNSkgOiB0eXBlID09PSBQb3cgPyB6b29tUG93KGRvbWFpbiwgbnVsbCwgZnJhYywgZXhwb25lbnQgfHwgMSkgOiB0eXBlID09PSBTeW1sb2cgPyB6b29tU3ltbG9nKGRvbWFpbiwgbnVsbCwgZnJhYywgY29uc3RhbnQgfHwgMSkgOiB6b29tTGluZWFyKGRvbWFpbiwgbnVsbCwgZnJhYyk7XG4gIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpO1xuICBkb21haW5bMF0gPSBkWzBdO1xuICBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdID0gZFsxXTtcbiAgcmV0dXJuIGRvbWFpbjtcbn1cblxuZnVuY3Rpb24gZG9tYWluQ2hlY2sodHlwZSwgZG9tYWluLCBkZikge1xuICBpZiAoaXNMb2dhcml0aG1pYyh0eXBlKSkge1xuICAgIC8vIHN1bSBzaWducyBvZiBkb21haW4gdmFsdWVzXG4gICAgLy8gaWYgYWxsIHBvcyBvciBhbGwgbmVnLCBhYnMoc3VtKSA9PT0gZG9tYWluLmxlbmd0aFxuICAgIHZhciBzID0gTWF0aC5hYnMoZG9tYWluLnJlZHVjZSgocywgdikgPT4gcyArICh2IDwgMCA/IC0xIDogdiA+IDAgPyAxIDogMCksIDApKTtcblxuICAgIGlmIChzICE9PSBkb21haW4ubGVuZ3RoKSB7XG4gICAgICBkZi53YXJuKCdMb2cgc2NhbGUgZG9tYWluIGluY2x1ZGVzIHplcm86ICcgKyBzdHJpbmdWYWx1ZShkb21haW4pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tYWluO1xufVxuXG5mdW5jdGlvbiBjb25maWd1cmVCaW5zKHNjYWxlLCBfLCBjb3VudCkge1xuICBsZXQgYmlucyA9IF8uYmlucztcblxuICBpZiAoYmlucyAmJiAhaXNBcnJheShiaW5zKSkge1xuICAgIC8vIGdlbmVyYXRlIGJpbiBib3VuZGFyeSBhcnJheVxuICAgIGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgICAgIGxvID0gZG9tYWluWzBdLFxuICAgICAgICAgIGhpID0gcGVlayhkb21haW4pLFxuICAgICAgICAgIHN0ZXAgPSBiaW5zLnN0ZXA7XG4gICAgbGV0IHN0YXJ0ID0gYmlucy5zdGFydCA9PSBudWxsID8gbG8gOiBiaW5zLnN0YXJ0LFxuICAgICAgICBzdG9wID0gYmlucy5zdG9wID09IG51bGwgPyBoaSA6IGJpbnMuc3RvcDtcbiAgICBpZiAoIXN0ZXApIGVycm9yKCdTY2FsZSBiaW5zIHBhcmFtZXRlciBtaXNzaW5nIHN0ZXAgcHJvcGVydHkuJyk7XG4gICAgaWYgKHN0YXJ0IDwgbG8pIHN0YXJ0ID0gc3RlcCAqIE1hdGguY2VpbChsbyAvIHN0ZXApO1xuICAgIGlmIChzdG9wID4gaGkpIHN0b3AgPSBzdGVwICogTWF0aC5mbG9vcihoaSAvIHN0ZXApO1xuICAgIGJpbnMgPSByYW5nZShzdGFydCwgc3RvcCArIHN0ZXAgLyAyLCBzdGVwKTtcbiAgfVxuXG4gIGlmIChiaW5zKSB7XG4gICAgLy8gYXNzaWduIGJpbiBib3VuZGFyaWVzIHRvIHNjYWxlIGluc3RhbmNlXG4gICAgc2NhbGUuYmlucyA9IGJpbnM7XG4gIH0gZWxzZSBpZiAoc2NhbGUuYmlucykge1xuICAgIC8vIG5vIGN1cnJlbnQgYmlucywgcmVtb3ZlIGJpbnMgaWYgcHJldmlvdXNseSBzZXRcbiAgICBkZWxldGUgc2NhbGUuYmlucztcbiAgfSAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBiaW4tb3JkaW5hbCBzY2FsZXNcblxuXG4gIGlmIChzY2FsZS50eXBlID09PSBCaW5PcmRpbmFsKSB7XG4gICAgaWYgKCFiaW5zKSB7XG4gICAgICAvLyB0aGUgZG9tYWluIHNwZWNpZmllcyB0aGUgYmluc1xuICAgICAgc2NhbGUuYmlucyA9IHNjYWxlLmRvbWFpbigpO1xuICAgIH0gZWxzZSBpZiAoIV8uZG9tYWluICYmICFfLmRvbWFpblJhdykge1xuICAgICAgLy8gdGhlIGJpbnMgc3BlY2lmeSB0aGUgZG9tYWluXG4gICAgICBzY2FsZS5kb21haW4oYmlucyk7XG4gICAgICBjb3VudCA9IGJpbnMubGVuZ3RoO1xuICAgIH1cbiAgfSAvLyByZXR1cm4gZG9tYWluIGNhcmRpbmFsaXR5XG5cblxuICByZXR1cm4gY291bnQ7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZVJhbmdlKHNjYWxlLCBfLCBjb3VudCkge1xuICB2YXIgdHlwZSA9IHNjYWxlLnR5cGUsXG4gICAgICByb3VuZCA9IF8ucm91bmQgfHwgZmFsc2UsXG4gICAgICByYW5nZSA9IF8ucmFuZ2U7IC8vIGlmIHJhbmdlIHN0ZXAgc3BlY2lmaWVkLCBjYWxjdWxhdGUgZnVsbCByYW5nZSBleHRlbnRcblxuICBpZiAoXy5yYW5nZVN0ZXAgIT0gbnVsbCkge1xuICAgIHJhbmdlID0gY29uZmlndXJlUmFuZ2VTdGVwKHR5cGUsIF8sIGNvdW50KTtcbiAgfSAvLyBlbHNlIGlmIGEgcmFuZ2Ugc2NoZW1lIGlzIGRlZmluZWQsIHVzZSB0aGF0XG4gIGVsc2UgaWYgKF8uc2NoZW1lKSB7XG4gICAgICByYW5nZSA9IGNvbmZpZ3VyZVNjaGVtZSh0eXBlLCBfLCBjb3VudCk7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHJhbmdlKSkge1xuICAgICAgICBpZiAoc2NhbGUuaW50ZXJwb2xhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYWxlLmludGVycG9sYXRvcihyYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoXCJTY2FsZSB0eXBlIFwiLmNvbmNhdCh0eXBlLCBcIiBkb2VzIG5vdCBzdXBwb3J0IGludGVycG9sYXRpbmcgY29sb3Igc2NoZW1lcy5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBnaXZlbiBhIHJhbmdlIGFycmF5IGZvciBhbiBpbnRlcnBvbGF0aW5nIHNjYWxlLCBjb252ZXJ0IHRvIGludGVycG9sYXRvclxuXG5cbiAgaWYgKHJhbmdlICYmIGlzSW50ZXJwb2xhdGluZyh0eXBlKSkge1xuICAgIHJldHVybiBzY2FsZS5pbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVDb2xvcnMoZmxpcChyYW5nZSwgXy5yZXZlcnNlKSwgXy5pbnRlcnBvbGF0ZSwgXy5pbnRlcnBvbGF0ZUdhbW1hKSk7XG4gIH0gLy8gY29uZmlndXJlIHJvdW5kaW5nIC8gaW50ZXJwb2xhdGlvblxuXG5cbiAgaWYgKHJhbmdlICYmIF8uaW50ZXJwb2xhdGUgJiYgc2NhbGUuaW50ZXJwb2xhdGUpIHtcbiAgICBzY2FsZS5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZShfLmludGVycG9sYXRlLCBfLmludGVycG9sYXRlR2FtbWEpKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNjYWxlLnJvdW5kKSkge1xuICAgIHNjYWxlLnJvdW5kKHJvdW5kKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNjYWxlLnJhbmdlUm91bmQpKSB7XG4gICAgc2NhbGUuaW50ZXJwb2xhdGUocm91bmQgPyBpbnRlcnBvbGF0ZVJvdW5kIDogaW50ZXJwb2xhdGUkMSk7XG4gIH1cblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKGZsaXAocmFuZ2UsIF8ucmV2ZXJzZSkpO1xufVxuXG5mdW5jdGlvbiBjb25maWd1cmVSYW5nZVN0ZXAodHlwZSwgXywgY291bnQpIHtcbiAgaWYgKHR5cGUgIT09IEJhbmQgJiYgdHlwZSAhPT0gUG9pbnQpIHtcbiAgICBlcnJvcignT25seSBiYW5kIGFuZCBwb2ludCBzY2FsZXMgc3VwcG9ydCByYW5nZVN0ZXAuJyk7XG4gIH0gLy8gY2FsY3VsYXRlIGZ1bGwgcmFuZ2UgYmFzZWQgb24gcmVxdWVzdGVkIHN0ZXAgc2l6ZSBhbmQgcGFkZGluZ1xuXG5cbiAgdmFyIG91dGVyID0gKF8ucGFkZGluZ091dGVyICE9IG51bGwgPyBfLnBhZGRpbmdPdXRlciA6IF8ucGFkZGluZykgfHwgMCxcbiAgICAgIGlubmVyID0gdHlwZSA9PT0gUG9pbnQgPyAxIDogKF8ucGFkZGluZ0lubmVyICE9IG51bGwgPyBfLnBhZGRpbmdJbm5lciA6IF8ucGFkZGluZykgfHwgMDtcbiAgcmV0dXJuIFswLCBfLnJhbmdlU3RlcCAqIGJhbmRTcGFjZShjb3VudCwgaW5uZXIsIG91dGVyKV07XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZVNjaGVtZSh0eXBlLCBfLCBjb3VudCkge1xuICB2YXIgZXh0ZW50ID0gXy5zY2hlbWVFeHRlbnQsXG4gICAgICBuYW1lLFxuICAgICAgc2NoZW1lJDE7XG5cbiAgaWYgKGlzQXJyYXkoXy5zY2hlbWUpKSB7XG4gICAgc2NoZW1lJDEgPSBpbnRlcnBvbGF0ZUNvbG9ycyhfLnNjaGVtZSwgXy5pbnRlcnBvbGF0ZSwgXy5pbnRlcnBvbGF0ZUdhbW1hKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gXy5zY2hlbWUudG9Mb3dlckNhc2UoKTtcbiAgICBzY2hlbWUkMSA9IHNjaGVtZShuYW1lKTtcbiAgICBpZiAoIXNjaGVtZSQxKSBlcnJvcihcIlVucmVjb2duaXplZCBzY2hlbWUgbmFtZTogXCIuY29uY2F0KF8uc2NoZW1lKSk7XG4gIH0gLy8gZGV0ZXJtaW5lIHNpemUgZm9yIHBvdGVudGlhbCBkaXNjcmV0ZSByYW5nZVxuXG5cbiAgY291bnQgPSB0eXBlID09PSBUaHJlc2hvbGQgPyBjb3VudCArIDEgOiB0eXBlID09PSBCaW5PcmRpbmFsID8gY291bnQgLSAxIDogdHlwZSA9PT0gUXVhbnRpbGUgfHwgdHlwZSA9PT0gUXVhbnRpemUgPyArXy5zY2hlbWVDb3VudCB8fCBERUZBVUxUX0NPVU5UIDogY291bnQ7IC8vIGFkanVzdCBhbmQvb3IgcXVhbnRpemUgc2NoZW1lIGFzIGFwcHJvcHJpYXRlXG5cbiAgcmV0dXJuIGlzSW50ZXJwb2xhdGluZyh0eXBlKSA/IGFkanVzdFNjaGVtZShzY2hlbWUkMSwgZXh0ZW50LCBfLnJldmVyc2UpIDogaXNGdW5jdGlvbihzY2hlbWUkMSkgPyBxdWFudGl6ZUludGVycG9sYXRvcihhZGp1c3RTY2hlbWUoc2NoZW1lJDEsIGV4dGVudCksIGNvdW50KSA6IHR5cGUgPT09IE9yZGluYWwgPyBzY2hlbWUkMSA6IHNjaGVtZSQxLnNsaWNlKDAsIGNvdW50KTtcbn1cblxuZnVuY3Rpb24gYWRqdXN0U2NoZW1lKHNjaGVtZSwgZXh0ZW50LCByZXZlcnNlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHNjaGVtZSkgJiYgKGV4dGVudCB8fCByZXZlcnNlKSA/IGludGVycG9sYXRlUmFuZ2Uoc2NoZW1lLCBmbGlwKGV4dGVudCB8fCBbMCwgMV0sIHJldmVyc2UpKSA6IHNjaGVtZTtcbn1cblxuZnVuY3Rpb24gZmxpcChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gcmV2ZXJzZSA/IGFycmF5LnNsaWNlKCkucmV2ZXJzZSgpIDogYXJyYXk7XG59XG5cbi8qKlxuICogU29ydHMgc2NlbmVncmFwaCBpdGVtcyBpbiB0aGUgcHVsc2Ugc291cmNlIGFycmF5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEEgY29tcGFyYXRvclxuICogICBmdW5jdGlvbiBmb3Igc29ydGluZyB0dXBsZXMuXG4gKi9cblxuZnVuY3Rpb24gU29ydEl0ZW1zKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoU29ydEl0ZW1zLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgbW9kID0gXy5tb2RpZmllZCgnc29ydCcpIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREKSB8fCBwdWxzZS5tb2RpZmllZChfLnNvcnQuZmllbGRzKSB8fCBwdWxzZS5tb2RpZmllZCgnZGF0dW0nKTtcbiAgICBpZiAobW9kKSBwdWxzZS5zb3VyY2Uuc29ydChzdGFibGVDb21wYXJlKF8uc29ydCkpO1xuICAgIHRoaXMubW9kaWZpZWQobW9kKTtcbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbmNvbnN0IFplcm8gPSAnemVybycsXG4gICAgICBDZW50ZXIgPSAnY2VudGVyJyxcbiAgICAgIE5vcm1hbGl6ZSA9ICdub3JtYWxpemUnLFxuICAgICAgRGVmT3V0cHV0ID0gWyd5MCcsICd5MSddO1xuLyoqXG4gKiBTdGFjayBsYXlvdXQgZm9yIHZpc3VhbGl6YXRpb24gZWxlbWVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIHN0YWNrLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29ycyB0byBncm91cGJ5LlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3Qsb2JqZWN0KTogbnVtYmVyfSBbcGFyYW1zLnNvcnRdIC0gQSBjb21wYXJhdG9yIGZvciBzdGFjayBzb3J0aW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvZmZzZXQ9J3plcm8nXSAtIFN0YWNrIGJhc2VsaW5lIG9mZnNldC4gT25lIG9mICd6ZXJvJywgJ2NlbnRlcicsICdub3JtYWxpemUnLlxuICovXG5cbmZ1bmN0aW9uIFN0YWNrKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuU3RhY2suRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnU3RhY2snLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ29mZnNldCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiBaZXJvLFxuICAgICd2YWx1ZXMnOiBbWmVybywgQ2VudGVyLCBOb3JtYWxpemVdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogRGVmT3V0cHV0XG4gIH1dXG59O1xuaW5oZXJpdHMoU3RhY2ssIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgYXMgPSBfLmFzIHx8IERlZk91dHB1dCxcbiAgICAgICAgeTAgPSBhc1swXSxcbiAgICAgICAgeTEgPSBhc1sxXSxcbiAgICAgICAgc29ydCA9IHN0YWJsZUNvbXBhcmUoXy5zb3J0KSxcbiAgICAgICAgZmllbGQgPSBfLmZpZWxkIHx8IG9uZSxcbiAgICAgICAgc3RhY2sgPSBfLm9mZnNldCA9PT0gQ2VudGVyID8gc3RhY2tDZW50ZXIgOiBfLm9mZnNldCA9PT0gTm9ybWFsaXplID8gc3RhY2tOb3JtYWxpemUgOiBzdGFja1plcm8sXG4gICAgICAgIGdyb3VwcyxcbiAgICAgICAgaSxcbiAgICAgICAgbixcbiAgICAgICAgbWF4OyAvLyBwYXJ0aXRpb24sIHN1bSwgYW5kIHNvcnQgdGhlIHN0YWNrIGdyb3Vwc1xuXG4gICAgZ3JvdXBzID0gcGFydGl0aW9uKHB1bHNlLnNvdXJjZSwgXy5ncm91cGJ5LCBzb3J0LCBmaWVsZCk7IC8vIGNvbXB1dGUgc3RhY2sgbGF5b3V0cyBwZXIgZ3JvdXBcblxuICAgIGZvciAoaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoLCBtYXggPSBncm91cHMubWF4OyBpIDwgbjsgKytpKSB7XG4gICAgICBzdGFjayhncm91cHNbaV0sIG1heCwgZmllbGQsIHkwLCB5MSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gc3RhY2tDZW50ZXIoZ3JvdXAsIG1heCwgZmllbGQsIHkwLCB5MSkge1xuICB2YXIgbGFzdCA9IChtYXggLSBncm91cC5zdW0pIC8gMixcbiAgICAgIG0gPSBncm91cC5sZW5ndGgsXG4gICAgICBqID0gMCxcbiAgICAgIHQ7XG5cbiAgZm9yICg7IGogPCBtOyArK2opIHtcbiAgICB0ID0gZ3JvdXBbal07XG4gICAgdFt5MF0gPSBsYXN0O1xuICAgIHRbeTFdID0gbGFzdCArPSBNYXRoLmFicyhmaWVsZCh0KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhY2tOb3JtYWxpemUoZ3JvdXAsIG1heCwgZmllbGQsIHkwLCB5MSkge1xuICB2YXIgc2NhbGUgPSAxIC8gZ3JvdXAuc3VtLFxuICAgICAgbGFzdCA9IDAsXG4gICAgICBtID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgaiA9IDAsXG4gICAgICB2ID0gMCxcbiAgICAgIHQ7XG5cbiAgZm9yICg7IGogPCBtOyArK2opIHtcbiAgICB0ID0gZ3JvdXBbal07XG4gICAgdFt5MF0gPSBsYXN0O1xuICAgIHRbeTFdID0gbGFzdCA9IHNjYWxlICogKHYgKz0gTWF0aC5hYnMoZmllbGQodCkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFja1plcm8oZ3JvdXAsIG1heCwgZmllbGQsIHkwLCB5MSkge1xuICB2YXIgbGFzdFBvcyA9IDAsXG4gICAgICBsYXN0TmVnID0gMCxcbiAgICAgIG0gPSBncm91cC5sZW5ndGgsXG4gICAgICBqID0gMCxcbiAgICAgIHYsXG4gICAgICB0O1xuXG4gIGZvciAoOyBqIDwgbTsgKytqKSB7XG4gICAgdCA9IGdyb3VwW2pdO1xuICAgIHYgPSArZmllbGQodCk7XG5cbiAgICBpZiAodiA8IDApIHtcbiAgICAgIHRbeTBdID0gbGFzdE5lZztcbiAgICAgIHRbeTFdID0gbGFzdE5lZyArPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICB0W3kwXSA9IGxhc3RQb3M7XG4gICAgICB0W3kxXSA9IGxhc3RQb3MgKz0gdjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIHNvcnQsIGZpZWxkKSB7XG4gIHZhciBncm91cHMgPSBbXSxcbiAgICAgIGdldCA9IGYgPT4gZih0KSxcbiAgICAgIG1hcCxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbSxcbiAgICAgIHQsXG4gICAgICBrLFxuICAgICAgZyxcbiAgICAgIHMsXG4gICAgICBtYXg7IC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIHN0YWNrIGdyb3Vwc1xuXG5cbiAgaWYgKGdyb3VwYnkgPT0gbnVsbCkge1xuICAgIGdyb3Vwcy5wdXNoKGRhdGEuc2xpY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXAgPSB7fSwgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IGRhdGFbaV07XG4gICAgICBrID0gZ3JvdXBieS5tYXAoZ2V0KTtcbiAgICAgIGcgPSBtYXBba107XG5cbiAgICAgIGlmICghZykge1xuICAgICAgICBtYXBba10gPSBnID0gW107XG4gICAgICAgIGdyb3Vwcy5wdXNoKGcpO1xuICAgICAgfVxuXG4gICAgICBnLnB1c2godCk7XG4gICAgfVxuICB9IC8vIGNvbXB1dGUgc3VtcyBvZiBncm91cHMsIHNvcnQgZ3JvdXBzIGFzIG5lZWRlZFxuXG5cbiAgZm9yIChrID0gMCwgbWF4ID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBtOyArK2spIHtcbiAgICBnID0gZ3JvdXBzW2tdO1xuXG4gICAgZm9yIChpID0gMCwgcyA9IDAsIG4gPSBnLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgcyArPSBNYXRoLmFicyhmaWVsZChnW2ldKSk7XG4gICAgfVxuXG4gICAgZy5zdW0gPSBzO1xuICAgIGlmIChzID4gbWF4KSBtYXggPSBzO1xuICAgIGlmIChzb3J0KSBnLnNvcnQoc29ydCk7XG4gIH1cblxuICBncm91cHMubWF4ID0gbWF4O1xuICByZXR1cm4gZ3JvdXBzO1xufVxuXG5leHBvcnQgeyBBeGlzVGlja3MgYXMgYXhpc3RpY2tzLCBEYXRhSm9pbiBhcyBkYXRham9pbiwgRW5jb2RlIGFzIGVuY29kZSwgTGVnZW5kRW50cmllcyBhcyBsZWdlbmRlbnRyaWVzLCBMaW5rUGF0aCBhcyBsaW5rcGF0aCwgUGllIGFzIHBpZSwgU2NhbGUgYXMgc2NhbGUsIFNvcnRJdGVtcyBhcyBzb3J0aXRlbXMsIFN0YWNrIGFzIHN0YWNrIH07XG4iLCJjb25zdCBWSUVXID0gJ3ZpZXcnLFxuICAgICAgTEJSQUNLID0gJ1snLFxuICAgICAgUkJSQUNLID0gJ10nLFxuICAgICAgTEJSQUNFID0gJ3snLFxuICAgICAgUkJSQUNFID0gJ30nLFxuICAgICAgQ09MT04gPSAnOicsXG4gICAgICBDT01NQSA9ICcsJyxcbiAgICAgIE5BTUUgPSAnQCcsXG4gICAgICBHVCA9ICc+JyxcbiAgICAgIElMTEVHQUwgPSAvW1tcXF17fV0vLFxuICAgICAgREVGQVVMVF9NQVJLUyA9IHtcbiAgJyonOiAxLFxuICBhcmM6IDEsXG4gIGFyZWE6IDEsXG4gIGdyb3VwOiAxLFxuICBpbWFnZTogMSxcbiAgbGluZTogMSxcbiAgcGF0aDogMSxcbiAgcmVjdDogMSxcbiAgcnVsZTogMSxcbiAgc2hhcGU6IDEsXG4gIHN5bWJvbDogMSxcbiAgdGV4dDogMSxcbiAgdHJhaWw6IDFcbn07XG5sZXQgREVGQVVMVF9TT1VSQ0UsIE1BUktTO1xuLyoqXG4gKiBQYXJzZSBhbiBldmVudCBzZWxlY3RvciBzdHJpbmcuXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGV2ZW50IHN0cmVhbSBkZWZpbml0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBldmVudFNlbGVjdG9yIChzZWxlY3Rvciwgc291cmNlLCBtYXJrcykge1xuICBERUZBVUxUX1NPVVJDRSA9IHNvdXJjZSB8fCBWSUVXO1xuICBNQVJLUyA9IG1hcmtzIHx8IERFRkFVTFRfTUFSS1M7XG4gIHJldHVybiBwYXJzZU1lcmdlKHNlbGVjdG9yLnRyaW0oKSkubWFwKHBhcnNlU2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBpc01hcmtUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIE1BUktTW3R5cGVdO1xufVxuXG5mdW5jdGlvbiBmaW5kKHMsIGksIGVuZENoYXIsIHB1c2hDaGFyLCBwb3BDaGFyKSB7XG4gIGNvbnN0IG4gPSBzLmxlbmd0aDtcbiAgbGV0IGNvdW50ID0gMCxcbiAgICAgIGM7XG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBjID0gc1tpXTtcbiAgICBpZiAoIWNvdW50ICYmIGMgPT09IGVuZENoYXIpIHJldHVybiBpO2Vsc2UgaWYgKHBvcENoYXIgJiYgcG9wQ2hhci5pbmRleE9mKGMpID49IDApIC0tY291bnQ7ZWxzZSBpZiAocHVzaENoYXIgJiYgcHVzaENoYXIuaW5kZXhPZihjKSA+PSAwKSArK2NvdW50O1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWVyZ2Uocykge1xuICBjb25zdCBvdXRwdXQgPSBbXSxcbiAgICAgICAgbiA9IHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwLFxuICAgICAgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBuKSB7XG4gICAgaSA9IGZpbmQocywgaSwgQ09NTUEsIExCUkFDSyArIExCUkFDRSwgUkJSQUNLICsgUkJSQUNFKTtcbiAgICBvdXRwdXQucHVzaChzLnN1YnN0cmluZyhzdGFydCwgaSkudHJpbSgpKTtcbiAgICBzdGFydCA9ICsraTtcbiAgfVxuXG4gIGlmIChvdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgJ0VtcHR5IGV2ZW50IHNlbGVjdG9yOiAnICsgcztcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2VsZWN0b3Iocykge1xuICByZXR1cm4gc1swXSA9PT0gJ1snID8gcGFyc2VCZXR3ZWVuKHMpIDogcGFyc2VTdHJlYW0ocyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQmV0d2VlbihzKSB7XG4gIGNvbnN0IG4gPSBzLmxlbmd0aDtcbiAgbGV0IGkgPSAxLFxuICAgICAgYjtcbiAgaSA9IGZpbmQocywgaSwgUkJSQUNLLCBMQlJBQ0ssIFJCUkFDSyk7XG5cbiAgaWYgKGkgPT09IG4pIHtcbiAgICB0aHJvdyAnRW1wdHkgYmV0d2VlbiBzZWxlY3RvcjogJyArIHM7XG4gIH1cblxuICBiID0gcGFyc2VNZXJnZShzLnN1YnN0cmluZygxLCBpKSk7XG5cbiAgaWYgKGIubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgJ0JldHdlZW4gc2VsZWN0b3IgbXVzdCBoYXZlIHR3byBlbGVtZW50czogJyArIHM7XG4gIH1cblxuICBzID0gcy5zbGljZShpICsgMSkudHJpbSgpO1xuXG4gIGlmIChzWzBdICE9PSBHVCkge1xuICAgIHRocm93ICdFeHBlY3RlZCBcXCc+XFwnIGFmdGVyIGJldHdlZW4gc2VsZWN0b3I6ICcgKyBzO1xuICB9XG5cbiAgYiA9IGIubWFwKHBhcnNlU2VsZWN0b3IpO1xuICBjb25zdCBzdHJlYW0gPSBwYXJzZVNlbGVjdG9yKHMuc2xpY2UoMSkudHJpbSgpKTtcblxuICBpZiAoc3RyZWFtLmJldHdlZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogYixcbiAgICAgIHN0cmVhbTogc3RyZWFtXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uYmV0d2VlbiA9IGI7XG4gIH1cblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmVhbShzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHtcbiAgICBzb3VyY2U6IERFRkFVTFRfU09VUkNFXG4gIH0sXG4gICAgICAgIHNvdXJjZSA9IFtdO1xuICBsZXQgdGhyb3R0bGUgPSBbMCwgMF0sXG4gICAgICBtYXJrbmFtZSA9IDAsXG4gICAgICBzdGFydCA9IDAsXG4gICAgICBuID0gcy5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGosXG4gICAgICBmaWx0ZXI7IC8vIGV4dHJhY3QgdGhyb3R0bGUgZnJvbSBlbmRcblxuICBpZiAoc1tuIC0gMV0gPT09IFJCUkFDRSkge1xuICAgIGkgPSBzLmxhc3RJbmRleE9mKExCUkFDRSk7XG5cbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdHRsZSA9IHBhcnNlVGhyb3R0bGUocy5zdWJzdHJpbmcoaSArIDEsIG4gLSAxKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93ICdJbnZhbGlkIHRocm90dGxlIHNwZWNpZmljYXRpb246ICcgKyBzO1xuICAgICAgfVxuXG4gICAgICBzID0gcy5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICBuID0gcy5sZW5ndGg7XG4gICAgfSBlbHNlIHRocm93ICdVbm1hdGNoZWQgcmlnaHQgYnJhY2U6ICcgKyBzO1xuXG4gICAgaSA9IDA7XG4gIH1cblxuICBpZiAoIW4pIHRocm93IHM7IC8vIHNldCBuYW1lIGZsYWcgYmFzZWQgb24gZmlyc3QgY2hhclxuXG4gIGlmIChzWzBdID09PSBOQU1FKSBtYXJrbmFtZSA9ICsraTsgLy8gZXh0cmFjdCBmaXJzdCBwYXJ0IG9mIG11bHRpLXBhcnQgc3RyZWFtIHNlbGVjdG9yXG5cbiAgaiA9IGZpbmQocywgaSwgQ09MT04pO1xuXG4gIGlmIChqIDwgbikge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBqKS50cmltKCkpO1xuICAgIHN0YXJ0ID0gaSA9ICsrajtcbiAgfSAvLyBleHRyYWN0IHJlbWFpbmluZyBwYXJ0IG9mIHN0cmVhbSBzZWxlY3RvclxuXG5cbiAgaSA9IGZpbmQocywgaSwgTEJSQUNLKTtcblxuICBpZiAoaSA9PT0gbikge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBuKS50cmltKCkpO1xuICB9IGVsc2Uge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBpKS50cmltKCkpO1xuICAgIGZpbHRlciA9IFtdO1xuICAgIHN0YXJ0ID0gKytpO1xuICAgIGlmIChzdGFydCA9PT0gbikgdGhyb3cgJ1VubWF0Y2hlZCBsZWZ0IGJyYWNrZXQ6ICcgKyBzO1xuICB9IC8vIGV4dHJhY3QgZmlsdGVyc1xuXG5cbiAgd2hpbGUgKGkgPCBuKSB7XG4gICAgaSA9IGZpbmQocywgaSwgUkJSQUNLKTtcbiAgICBpZiAoaSA9PT0gbikgdGhyb3cgJ1VubWF0Y2hlZCBsZWZ0IGJyYWNrZXQ6ICcgKyBzO1xuICAgIGZpbHRlci5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBpKS50cmltKCkpO1xuICAgIGlmIChpIDwgbiAtIDEgJiYgc1srK2ldICE9PSBMQlJBQ0spIHRocm93ICdFeHBlY3RlZCBsZWZ0IGJyYWNrZXQ6ICcgKyBzO1xuICAgIHN0YXJ0ID0gKytpO1xuICB9IC8vIG1hcnNoYWxsIGV2ZW50IHN0cmVhbSBzcGVjaWZpY2F0aW9uXG5cblxuICBpZiAoIShuID0gc291cmNlLmxlbmd0aCkgfHwgSUxMRUdBTC50ZXN0KHNvdXJjZVtuIC0gMV0pKSB7XG4gICAgdGhyb3cgJ0ludmFsaWQgZXZlbnQgc2VsZWN0b3I6ICcgKyBzO1xuICB9XG5cbiAgaWYgKG4gPiAxKSB7XG4gICAgc3RyZWFtLnR5cGUgPSBzb3VyY2VbMV07XG5cbiAgICBpZiAobWFya25hbWUpIHtcbiAgICAgIHN0cmVhbS5tYXJrbmFtZSA9IHNvdXJjZVswXS5zbGljZSgxKTtcbiAgICB9IGVsc2UgaWYgKGlzTWFya1R5cGUoc291cmNlWzBdKSkge1xuICAgICAgc3RyZWFtLm1hcmt0eXBlID0gc291cmNlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uc291cmNlID0gc291cmNlWzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0udHlwZSA9IHNvdXJjZVswXTtcbiAgfVxuXG4gIGlmIChzdHJlYW0udHlwZS5zbGljZSgtMSkgPT09ICchJykge1xuICAgIHN0cmVhbS5jb25zdW1lID0gdHJ1ZTtcbiAgICBzdHJlYW0udHlwZSA9IHN0cmVhbS50eXBlLnNsaWNlKDAsIC0xKTtcbiAgfVxuXG4gIGlmIChmaWx0ZXIgIT0gbnVsbCkgc3RyZWFtLmZpbHRlciA9IGZpbHRlcjtcbiAgaWYgKHRocm90dGxlWzBdKSBzdHJlYW0udGhyb3R0bGUgPSB0aHJvdHRsZVswXTtcbiAgaWYgKHRocm90dGxlWzFdKSBzdHJlYW0uZGVib3VuY2UgPSB0aHJvdHRsZVsxXTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaHJvdHRsZShzKSB7XG4gIGNvbnN0IGEgPSBzLnNwbGl0KENPTU1BKTtcbiAgaWYgKCFzLmxlbmd0aCB8fCBhLmxlbmd0aCA+IDIpIHRocm93IHM7XG4gIHJldHVybiBhLm1hcChfID0+IHtcbiAgICBjb25zdCB4ID0gK187XG4gICAgaWYgKHggIT09IHgpIHRocm93IHM7XG4gICAgcmV0dXJuIHg7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBldmVudFNlbGVjdG9yIGFzIHBhcnNlU2VsZWN0b3IgfTtcbiIsImltcG9ydCB7IGVycm9yLCB0b1NldCwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGhhc093blByb3BlcnR5IH0gZnJvbSAndmVnYS11dGlsJztcblxuY29uc3QgUmF3Q29kZSA9ICdSYXdDb2RlJztcbmNvbnN0IExpdGVyYWwgPSAnTGl0ZXJhbCc7XG5jb25zdCBQcm9wZXJ0eSA9ICdQcm9wZXJ0eSc7XG5jb25zdCBJZGVudGlmaWVyID0gJ0lkZW50aWZpZXInO1xuY29uc3QgQXJyYXlFeHByZXNzaW9uID0gJ0FycmF5RXhwcmVzc2lvbic7XG5jb25zdCBCaW5hcnlFeHByZXNzaW9uID0gJ0JpbmFyeUV4cHJlc3Npb24nO1xuY29uc3QgQ2FsbEV4cHJlc3Npb24gPSAnQ2FsbEV4cHJlc3Npb24nO1xuY29uc3QgQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic7XG5jb25zdCBMb2dpY2FsRXhwcmVzc2lvbiA9ICdMb2dpY2FsRXhwcmVzc2lvbic7XG5jb25zdCBNZW1iZXJFeHByZXNzaW9uID0gJ01lbWJlckV4cHJlc3Npb24nO1xuY29uc3QgT2JqZWN0RXhwcmVzc2lvbiA9ICdPYmplY3RFeHByZXNzaW9uJztcbmNvbnN0IFVuYXJ5RXhwcmVzc2lvbiA9ICdVbmFyeUV4cHJlc3Npb24nO1xuZnVuY3Rpb24gQVNUTm9kZSh0eXBlKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG59XG5cbkFTVE5vZGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgbGV0IGMsIGksIG47XG4gIGlmICh2aXNpdG9yKHRoaXMpKSByZXR1cm4gMTtcblxuICBmb3IgKGMgPSBjaGlsZHJlbih0aGlzKSwgaSA9IDAsIG4gPSBjLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmIChjW2ldLnZpc2l0KHZpc2l0b3IpKSByZXR1cm4gMTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2hpbGRyZW4obm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgQXJyYXlFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudHM7XG5cbiAgICBjYXNlIEJpbmFyeUV4cHJlc3Npb246XG4gICAgY2FzZSBMb2dpY2FsRXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS5sZWZ0LCBub2RlLnJpZ2h0XTtcblxuICAgIGNhc2UgQ2FsbEV4cHJlc3Npb246XG4gICAgICByZXR1cm4gW25vZGUuY2FsbGVlXS5jb25jYXQobm9kZS5hcmd1bWVudHMpO1xuXG4gICAgY2FzZSBDb25kaXRpb25hbEV4cHJlc3Npb246XG4gICAgICByZXR1cm4gW25vZGUudGVzdCwgbm9kZS5jb25zZXF1ZW50LCBub2RlLmFsdGVybmF0ZV07XG5cbiAgICBjYXNlIE1lbWJlckV4cHJlc3Npb246XG4gICAgICByZXR1cm4gW25vZGUub2JqZWN0LCBub2RlLnByb3BlcnR5XTtcblxuICAgIGNhc2UgT2JqZWN0RXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBub2RlLnByb3BlcnRpZXM7XG5cbiAgICBjYXNlIFByb3BlcnR5OlxuICAgICAgcmV0dXJuIFtub2RlLmtleSwgbm9kZS52YWx1ZV07XG5cbiAgICBjYXNlIFVuYXJ5RXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS5hcmd1bWVudF07XG5cbiAgICBjYXNlIElkZW50aWZpZXI6XG4gICAgY2FzZSBMaXRlcmFsOlxuICAgIGNhc2UgUmF3Q29kZTpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qXG4gIFRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiBwYXJzZXIgaXMgYmFzZWQgb24gRXNwcmltYSAoaHR0cDovL2VzcHJpbWEub3JnLykuXG4gIE9yaWdpbmFsIGhlYWRlciBjb21tZW50IGFuZCBsaWNlbnNlIGZvciBFc3ByaW1hIGlzIGluY2x1ZGVkIGhlcmU6XG5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgVGhhZGRlZSBUeWwgPHRoYWRkZWUudHlsQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMSBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xudmFyIFRva2VuTmFtZSwgc291cmNlLCBpbmRleCwgbGVuZ3RoLCBsb29rYWhlYWQ7XG52YXIgVG9rZW5Cb29sZWFuTGl0ZXJhbCA9IDEsXG4gICAgVG9rZW5FT0YgPSAyLFxuICAgIFRva2VuSWRlbnRpZmllciA9IDMsXG4gICAgVG9rZW5LZXl3b3JkID0gNCxcbiAgICBUb2tlbk51bGxMaXRlcmFsID0gNSxcbiAgICBUb2tlbk51bWVyaWNMaXRlcmFsID0gNixcbiAgICBUb2tlblB1bmN0dWF0b3IgPSA3LFxuICAgIFRva2VuU3RyaW5nTGl0ZXJhbCA9IDgsXG4gICAgVG9rZW5SZWd1bGFyRXhwcmVzc2lvbiA9IDk7XG5Ub2tlbk5hbWUgPSB7fTtcblRva2VuTmFtZVtUb2tlbkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcblRva2VuTmFtZVtUb2tlbkVPRl0gPSAnPGVuZD4nO1xuVG9rZW5OYW1lW1Rva2VuSWRlbnRpZmllcl0gPSAnSWRlbnRpZmllcic7XG5Ub2tlbk5hbWVbVG9rZW5LZXl3b3JkXSA9ICdLZXl3b3JkJztcblRva2VuTmFtZVtUb2tlbk51bGxMaXRlcmFsXSA9ICdOdWxsJztcblRva2VuTmFtZVtUb2tlbk51bWVyaWNMaXRlcmFsXSA9ICdOdW1lcmljJztcblRva2VuTmFtZVtUb2tlblB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xuVG9rZW5OYW1lW1Rva2VuU3RyaW5nTGl0ZXJhbF0gPSAnU3RyaW5nJztcblRva2VuTmFtZVtUb2tlblJlZ3VsYXJFeHByZXNzaW9uXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XG52YXIgU3ludGF4QXJyYXlFeHByZXNzaW9uID0gJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgU3ludGF4QmluYXJ5RXhwcmVzc2lvbiA9ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICBTeW50YXhDYWxsRXhwcmVzc2lvbiA9ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgU3ludGF4Q29uZGl0aW9uYWxFeHByZXNzaW9uID0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgU3ludGF4SWRlbnRpZmllciA9ICdJZGVudGlmaWVyJyxcbiAgICBTeW50YXhMaXRlcmFsID0gJ0xpdGVyYWwnLFxuICAgIFN5bnRheExvZ2ljYWxFeHByZXNzaW9uID0gJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICBTeW50YXhNZW1iZXJFeHByZXNzaW9uID0gJ01lbWJlckV4cHJlc3Npb24nLFxuICAgIFN5bnRheE9iamVjdEV4cHJlc3Npb24gPSAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgU3ludGF4UHJvcGVydHkgPSAnUHJvcGVydHknLFxuICAgIFN5bnRheFVuYXJ5RXhwcmVzc2lvbiA9ICdVbmFyeUV4cHJlc3Npb24nOyAvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxuXG52YXIgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiA9ICdVbmV4cGVjdGVkIHRva2VuICUwJyxcbiAgICBNZXNzYWdlVW5leHBlY3RlZE51bWJlciA9ICdVbmV4cGVjdGVkIG51bWJlcicsXG4gICAgTWVzc2FnZVVuZXhwZWN0ZWRTdHJpbmcgPSAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICAgIE1lc3NhZ2VVbmV4cGVjdGVkSWRlbnRpZmllciA9ICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxuICAgIE1lc3NhZ2VVbmV4cGVjdGVkUmVzZXJ2ZWQgPSAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcbiAgICBNZXNzYWdlVW5leHBlY3RlZEVPUyA9ICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXG4gICAgTWVzc2FnZUludmFsaWRSZWdFeHAgPSAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgIE1lc3NhZ2VVbnRlcm1pbmF0ZWRSZWdFeHAgPSAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLycsXG4gICAgTWVzc2FnZVN0cmljdE9jdGFsTGl0ZXJhbCA9ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICBNZXNzYWdlU3RyaWN0RHVwbGljYXRlUHJvcGVydHkgPSAnRHVwbGljYXRlIGRhdGEgcHJvcGVydHkgaW4gb2JqZWN0IGxpdGVyYWwgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnO1xudmFyIElMTEVHQUwgPSAnSUxMRUdBTCcsXG4gICAgRElTQUJMRUQgPSAnRGlzYWJsZWQuJzsgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5weS5cblxudmFyIFJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKCdbXFxcXHhBQVxcXFx4QjVcXFxceEJBXFxcXHhDMC1cXFxceEQ2XFxcXHhEOC1cXFxceEY2XFxcXHhGOC1cXFxcdTAyQzFcXFxcdTAyQzYtXFxcXHUwMkQxXFxcXHUwMkUwLVxcXFx1MDJFNFxcXFx1MDJFQ1xcXFx1MDJFRVxcXFx1MDM3MC1cXFxcdTAzNzRcXFxcdTAzNzZcXFxcdTAzNzdcXFxcdTAzN0EtXFxcXHUwMzdEXFxcXHUwMzdGXFxcXHUwMzg2XFxcXHUwMzg4LVxcXFx1MDM4QVxcXFx1MDM4Q1xcXFx1MDM4RS1cXFxcdTAzQTFcXFxcdTAzQTMtXFxcXHUwM0Y1XFxcXHUwM0Y3LVxcXFx1MDQ4MVxcXFx1MDQ4QS1cXFxcdTA1MkZcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDVEMC1cXFxcdTA1RUFcXFxcdTA1RjAtXFxcXHUwNUYyXFxcXHUwNjIwLVxcXFx1MDY0QVxcXFx1MDY2RVxcXFx1MDY2RlxcXFx1MDY3MS1cXFxcdTA2RDNcXFxcdTA2RDVcXFxcdTA2RTVcXFxcdTA2RTZcXFxcdTA2RUVcXFxcdTA2RUZcXFxcdTA2RkEtXFxcXHUwNkZDXFxcXHUwNkZGXFxcXHUwNzEwXFxcXHUwNzEyLVxcXFx1MDcyRlxcXFx1MDc0RC1cXFxcdTA3QTVcXFxcdTA3QjFcXFxcdTA3Q0EtXFxcXHUwN0VBXFxcXHUwN0Y0XFxcXHUwN0Y1XFxcXHUwN0ZBXFxcXHUwODAwLVxcXFx1MDgxNVxcXFx1MDgxQVxcXFx1MDgyNFxcXFx1MDgyOFxcXFx1MDg0MC1cXFxcdTA4NThcXFxcdTA4QTAtXFxcXHUwOEIyXFxcXHUwOTA0LVxcXFx1MDkzOVxcXFx1MDkzRFxcXFx1MDk1MFxcXFx1MDk1OC1cXFxcdTA5NjFcXFxcdTA5NzEtXFxcXHUwOTgwXFxcXHUwOTg1LVxcXFx1MDk4Q1xcXFx1MDk4RlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5QThcXFxcdTA5QUEtXFxcXHUwOUIwXFxcXHUwOUIyXFxcXHUwOUI2LVxcXFx1MDlCOVxcXFx1MDlCRFxcXFx1MDlDRVxcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTFcXFxcdTA5RjBcXFxcdTA5RjFcXFxcdTBBMDUtXFxcXHUwQTBBXFxcXHUwQTBGXFxcXHUwQTEwXFxcXHUwQTEzLVxcXFx1MEEyOFxcXFx1MEEyQS1cXFxcdTBBMzBcXFxcdTBBMzJcXFxcdTBBMzNcXFxcdTBBMzVcXFxcdTBBMzZcXFxcdTBBMzhcXFxcdTBBMzlcXFxcdTBBNTktXFxcXHUwQTVDXFxcXHUwQTVFXFxcXHUwQTcyLVxcXFx1MEE3NFxcXFx1MEE4NS1cXFxcdTBBOERcXFxcdTBBOEYtXFxcXHUwQTkxXFxcXHUwQTkzLVxcXFx1MEFBOFxcXFx1MEFBQS1cXFxcdTBBQjBcXFxcdTBBQjJcXFxcdTBBQjNcXFxcdTBBQjUtXFxcXHUwQUI5XFxcXHUwQUJEXFxcXHUwQUQwXFxcXHUwQUUwXFxcXHUwQUUxXFxcXHUwQjA1LVxcXFx1MEIwQ1xcXFx1MEIwRlxcXFx1MEIxMFxcXFx1MEIxMy1cXFxcdTBCMjhcXFxcdTBCMkEtXFxcXHUwQjMwXFxcXHUwQjMyXFxcXHUwQjMzXFxcXHUwQjM1LVxcXFx1MEIzOVxcXFx1MEIzRFxcXFx1MEI1Q1xcXFx1MEI1RFxcXFx1MEI1Ri1cXFxcdTBCNjFcXFxcdTBCNzFcXFxcdTBCODNcXFxcdTBCODUtXFxcXHUwQjhBXFxcXHUwQjhFLVxcXFx1MEI5MFxcXFx1MEI5Mi1cXFxcdTBCOTVcXFxcdTBCOTlcXFxcdTBCOUFcXFxcdTBCOUNcXFxcdTBCOUVcXFxcdTBCOUZcXFxcdTBCQTNcXFxcdTBCQTRcXFxcdTBCQTgtXFxcXHUwQkFBXFxcXHUwQkFFLVxcXFx1MEJCOVxcXFx1MEJEMFxcXFx1MEMwNS1cXFxcdTBDMENcXFxcdTBDMEUtXFxcXHUwQzEwXFxcXHUwQzEyLVxcXFx1MEMyOFxcXFx1MEMyQS1cXFxcdTBDMzlcXFxcdTBDM0RcXFxcdTBDNThcXFxcdTBDNTlcXFxcdTBDNjBcXFxcdTBDNjFcXFxcdTBDODUtXFxcXHUwQzhDXFxcXHUwQzhFLVxcXFx1MEM5MFxcXFx1MEM5Mi1cXFxcdTBDQThcXFxcdTBDQUEtXFxcXHUwQ0IzXFxcXHUwQ0I1LVxcXFx1MENCOVxcXFx1MENCRFxcXFx1MENERVxcXFx1MENFMFxcXFx1MENFMVxcXFx1MENGMVxcXFx1MENGMlxcXFx1MEQwNS1cXFxcdTBEMENcXFxcdTBEMEUtXFxcXHUwRDEwXFxcXHUwRDEyLVxcXFx1MEQzQVxcXFx1MEQzRFxcXFx1MEQ0RVxcXFx1MEQ2MFxcXFx1MEQ2MVxcXFx1MEQ3QS1cXFxcdTBEN0ZcXFxcdTBEODUtXFxcXHUwRDk2XFxcXHUwRDlBLVxcXFx1MERCMVxcXFx1MERCMy1cXFxcdTBEQkJcXFxcdTBEQkRcXFxcdTBEQzAtXFxcXHUwREM2XFxcXHUwRTAxLVxcXFx1MEUzMFxcXFx1MEUzMlxcXFx1MEUzM1xcXFx1MEU0MC1cXFxcdTBFNDZcXFxcdTBFODFcXFxcdTBFODJcXFxcdTBFODRcXFxcdTBFODdcXFxcdTBFODhcXFxcdTBFOEFcXFxcdTBFOERcXFxcdTBFOTQtXFxcXHUwRTk3XFxcXHUwRTk5LVxcXFx1MEU5RlxcXFx1MEVBMS1cXFxcdTBFQTNcXFxcdTBFQTVcXFxcdTBFQTdcXFxcdTBFQUFcXFxcdTBFQUJcXFxcdTBFQUQtXFxcXHUwRUIwXFxcXHUwRUIyXFxcXHUwRUIzXFxcXHUwRUJEXFxcXHUwRUMwLVxcXFx1MEVDNFxcXFx1MEVDNlxcXFx1MEVEQy1cXFxcdTBFREZcXFxcdTBGMDBcXFxcdTBGNDAtXFxcXHUwRjQ3XFxcXHUwRjQ5LVxcXFx1MEY2Q1xcXFx1MEY4OC1cXFxcdTBGOENcXFxcdTEwMDAtXFxcXHUxMDJBXFxcXHUxMDNGXFxcXHUxMDUwLVxcXFx1MTA1NVxcXFx1MTA1QS1cXFxcdTEwNURcXFxcdTEwNjFcXFxcdTEwNjVcXFxcdTEwNjZcXFxcdTEwNkUtXFxcXHUxMDcwXFxcXHUxMDc1LVxcXFx1MTA4MVxcXFx1MTA4RVxcXFx1MTBBMC1cXFxcdTEwQzVcXFxcdTEwQzdcXFxcdTEwQ0RcXFxcdTEwRDAtXFxcXHUxMEZBXFxcXHUxMEZDLVxcXFx1MTI0OFxcXFx1MTI0QS1cXFxcdTEyNERcXFxcdTEyNTAtXFxcXHUxMjU2XFxcXHUxMjU4XFxcXHUxMjVBLVxcXFx1MTI1RFxcXFx1MTI2MC1cXFxcdTEyODhcXFxcdTEyOEEtXFxcXHUxMjhEXFxcXHUxMjkwLVxcXFx1MTJCMFxcXFx1MTJCMi1cXFxcdTEyQjVcXFxcdTEyQjgtXFxcXHUxMkJFXFxcXHUxMkMwXFxcXHUxMkMyLVxcXFx1MTJDNVxcXFx1MTJDOC1cXFxcdTEyRDZcXFxcdTEyRDgtXFxcXHUxMzEwXFxcXHUxMzEyLVxcXFx1MTMxNVxcXFx1MTMxOC1cXFxcdTEzNUFcXFxcdTEzODAtXFxcXHUxMzhGXFxcXHUxM0EwLVxcXFx1MTNGNFxcXFx1MTQwMS1cXFxcdTE2NkNcXFxcdTE2NkYtXFxcXHUxNjdGXFxcXHUxNjgxLVxcXFx1MTY5QVxcXFx1MTZBMC1cXFxcdTE2RUFcXFxcdTE2RUUtXFxcXHUxNkY4XFxcXHUxNzAwLVxcXFx1MTcwQ1xcXFx1MTcwRS1cXFxcdTE3MTFcXFxcdTE3MjAtXFxcXHUxNzMxXFxcXHUxNzQwLVxcXFx1MTc1MVxcXFx1MTc2MC1cXFxcdTE3NkNcXFxcdTE3NkUtXFxcXHUxNzcwXFxcXHUxNzgwLVxcXFx1MTdCM1xcXFx1MTdEN1xcXFx1MTdEQ1xcXFx1MTgyMC1cXFxcdTE4NzdcXFxcdTE4ODAtXFxcXHUxOEE4XFxcXHUxOEFBXFxcXHUxOEIwLVxcXFx1MThGNVxcXFx1MTkwMC1cXFxcdTE5MUVcXFxcdTE5NTAtXFxcXHUxOTZEXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5QUJcXFxcdTE5QzEtXFxcXHUxOUM3XFxcXHUxQTAwLVxcXFx1MUExNlxcXFx1MUEyMC1cXFxcdTFBNTRcXFxcdTFBQTdcXFxcdTFCMDUtXFxcXHUxQjMzXFxcXHUxQjQ1LVxcXFx1MUI0QlxcXFx1MUI4My1cXFxcdTFCQTBcXFxcdTFCQUVcXFxcdTFCQUZcXFxcdTFCQkEtXFxcXHUxQkU1XFxcXHUxQzAwLVxcXFx1MUMyM1xcXFx1MUM0RC1cXFxcdTFDNEZcXFxcdTFDNUEtXFxcXHUxQzdEXFxcXHUxQ0U5LVxcXFx1MUNFQ1xcXFx1MUNFRS1cXFxcdTFDRjFcXFxcdTFDRjVcXFxcdTFDRjZcXFxcdTFEMDAtXFxcXHUxREJGXFxcXHUxRTAwLVxcXFx1MUYxNVxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjAtXFxcXHUxRjQ1XFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUYtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUZCNFxcXFx1MUZCNi1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2LVxcXFx1MUZDQ1xcXFx1MUZEMC1cXFxcdTFGRDNcXFxcdTFGRDYtXFxcXHUxRkRCXFxcXHUxRkUwLVxcXFx1MUZFQ1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjYtXFxcXHUxRkZDXFxcXHUyMDcxXFxcXHUyMDdGXFxcXHUyMDkwLVxcXFx1MjA5Q1xcXFx1MjEwMlxcXFx1MjEwN1xcXFx1MjEwQS1cXFxcdTIxMTNcXFxcdTIxMTVcXFxcdTIxMTktXFxcXHUyMTFEXFxcXHUyMTI0XFxcXHUyMTI2XFxcXHUyMTI4XFxcXHUyMTJBLVxcXFx1MjEyRFxcXFx1MjEyRi1cXFxcdTIxMzlcXFxcdTIxM0MtXFxcXHUyMTNGXFxcXHUyMTQ1LVxcXFx1MjE0OVxcXFx1MjE0RVxcXFx1MjE2MC1cXFxcdTIxODhcXFxcdTJDMDAtXFxcXHUyQzJFXFxcXHUyQzMwLVxcXFx1MkM1RVxcXFx1MkM2MC1cXFxcdTJDRTRcXFxcdTJDRUItXFxcXHUyQ0VFXFxcXHUyQ0YyXFxcXHUyQ0YzXFxcXHUyRDAwLVxcXFx1MkQyNVxcXFx1MkQyN1xcXFx1MkQyRFxcXFx1MkQzMC1cXFxcdTJENjdcXFxcdTJENkZcXFxcdTJEODAtXFxcXHUyRDk2XFxcXHUyREEwLVxcXFx1MkRBNlxcXFx1MkRBOC1cXFxcdTJEQUVcXFxcdTJEQjAtXFxcXHUyREI2XFxcXHUyREI4LVxcXFx1MkRCRVxcXFx1MkRDMC1cXFxcdTJEQzZcXFxcdTJEQzgtXFxcXHUyRENFXFxcXHUyREQwLVxcXFx1MkRENlxcXFx1MkREOC1cXFxcdTJEREVcXFxcdTJFMkZcXFxcdTMwMDUtXFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyOVxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwMzgtXFxcXHUzMDNDXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5RC1cXFxcdTMwOUZcXFxcdTMwQTEtXFxcXHUzMEZBXFxcXHUzMEZDLVxcXFx1MzBGRlxcXFx1MzEwNS1cXFxcdTMxMkRcXFxcdTMxMzEtXFxcXHUzMThFXFxcXHUzMUEwLVxcXFx1MzFCQVxcXFx1MzFGMC1cXFxcdTMxRkZcXFxcdTM0MDAtXFxcXHU0REI1XFxcXHU0RTAwLVxcXFx1OUZDQ1xcXFx1QTAwMC1cXFxcdUE0OENcXFxcdUE0RDAtXFxcXHVBNEZEXFxcXHVBNTAwLVxcXFx1QTYwQ1xcXFx1QTYxMC1cXFxcdUE2MUZcXFxcdUE2MkFcXFxcdUE2MkJcXFxcdUE2NDAtXFxcXHVBNjZFXFxcXHVBNjdGLVxcXFx1QTY5RFxcXFx1QTZBMC1cXFxcdUE2RUZcXFxcdUE3MTctXFxcXHVBNzFGXFxcXHVBNzIyLVxcXFx1QTc4OFxcXFx1QTc4Qi1cXFxcdUE3OEVcXFxcdUE3OTAtXFxcXHVBN0FEXFxcXHVBN0IwXFxcXHVBN0IxXFxcXHVBN0Y3LVxcXFx1QTgwMVxcXFx1QTgwMy1cXFxcdUE4MDVcXFxcdUE4MDctXFxcXHVBODBBXFxcXHVBODBDLVxcXFx1QTgyMlxcXFx1QTg0MC1cXFxcdUE4NzNcXFxcdUE4ODItXFxcXHVBOEIzXFxcXHVBOEYyLVxcXFx1QThGN1xcXFx1QThGQlxcXFx1QTkwQS1cXFxcdUE5MjVcXFxcdUE5MzAtXFxcXHVBOTQ2XFxcXHVBOTYwLVxcXFx1QTk3Q1xcXFx1QTk4NC1cXFxcdUE5QjJcXFxcdUE5Q0ZcXFxcdUE5RTAtXFxcXHVBOUU0XFxcXHVBOUU2LVxcXFx1QTlFRlxcXFx1QTlGQS1cXFxcdUE5RkVcXFxcdUFBMDAtXFxcXHVBQTI4XFxcXHVBQTQwLVxcXFx1QUE0MlxcXFx1QUE0NC1cXFxcdUFBNEJcXFxcdUFBNjAtXFxcXHVBQTc2XFxcXHVBQTdBXFxcXHVBQTdFLVxcXFx1QUFBRlxcXFx1QUFCMVxcXFx1QUFCNVxcXFx1QUFCNlxcXFx1QUFCOS1cXFxcdUFBQkRcXFxcdUFBQzBcXFxcdUFBQzJcXFxcdUFBREItXFxcXHVBQUREXFxcXHVBQUUwLVxcXFx1QUFFQVxcXFx1QUFGMi1cXFxcdUFBRjRcXFxcdUFCMDEtXFxcXHVBQjA2XFxcXHVBQjA5LVxcXFx1QUIwRVxcXFx1QUIxMS1cXFxcdUFCMTZcXFxcdUFCMjAtXFxcXHVBQjI2XFxcXHVBQjI4LVxcXFx1QUIyRVxcXFx1QUIzMC1cXFxcdUFCNUFcXFxcdUFCNUMtXFxcXHVBQjVGXFxcXHVBQjY0XFxcXHVBQjY1XFxcXHVBQkMwLVxcXFx1QUJFMlxcXFx1QUMwMC1cXFxcdUQ3QTNcXFxcdUQ3QjAtXFxcXHVEN0M2XFxcXHVEN0NCLVxcXFx1RDdGQlxcXFx1RjkwMC1cXFxcdUZBNkRcXFxcdUZBNzAtXFxcXHVGQUQ5XFxcXHVGQjAwLVxcXFx1RkIwNlxcXFx1RkIxMy1cXFxcdUZCMTdcXFxcdUZCMURcXFxcdUZCMUYtXFxcXHVGQjI4XFxcXHVGQjJBLVxcXFx1RkIzNlxcXFx1RkIzOC1cXFxcdUZCM0NcXFxcdUZCM0VcXFxcdUZCNDBcXFxcdUZCNDFcXFxcdUZCNDNcXFxcdUZCNDRcXFxcdUZCNDYtXFxcXHVGQkIxXFxcXHVGQkQzLVxcXFx1RkQzRFxcXFx1RkQ1MC1cXFxcdUZEOEZcXFxcdUZEOTItXFxcXHVGREM3XFxcXHVGREYwLVxcXFx1RkRGQlxcXFx1RkU3MC1cXFxcdUZFNzRcXFxcdUZFNzYtXFxcXHVGRUZDXFxcXHVGRjIxLVxcXFx1RkYzQVxcXFx1RkY0MS1cXFxcdUZGNUFcXFxcdUZGNjYtXFxcXHVGRkJFXFxcXHVGRkMyLVxcXFx1RkZDN1xcXFx1RkZDQS1cXFxcdUZGQ0ZcXFxcdUZGRDItXFxcXHVGRkQ3XFxcXHVGRkRBLVxcXFx1RkZEQ10nKSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcblJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyUGFydCA9IG5ldyBSZWdFeHAoJ1tcXFxceEFBXFxcXHhCNVxcXFx4QkFcXFxceEMwLVxcXFx4RDZcXFxceEQ4LVxcXFx4RjZcXFxceEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzAwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzN0ZcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDQ4QS1cXFxcdTA1MkZcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDU5MS1cXFxcdTA1QkRcXFxcdTA1QkZcXFxcdTA1QzFcXFxcdTA1QzJcXFxcdTA1QzRcXFxcdTA1QzVcXFxcdTA1QzdcXFxcdTA1RDAtXFxcXHUwNUVBXFxcXHUwNUYwLVxcXFx1MDVGMlxcXFx1MDYxMC1cXFxcdTA2MUFcXFxcdTA2MjAtXFxcXHUwNjY5XFxcXHUwNjZFLVxcXFx1MDZEM1xcXFx1MDZENS1cXFxcdTA2RENcXFxcdTA2REYtXFxcXHUwNkU4XFxcXHUwNkVBLVxcXFx1MDZGQ1xcXFx1MDZGRlxcXFx1MDcxMC1cXFxcdTA3NEFcXFxcdTA3NEQtXFxcXHUwN0IxXFxcXHUwN0MwLVxcXFx1MDdGNVxcXFx1MDdGQVxcXFx1MDgwMC1cXFxcdTA4MkRcXFxcdTA4NDAtXFxcXHUwODVCXFxcXHUwOEEwLVxcXFx1MDhCMlxcXFx1MDhFNC1cXFxcdTA5NjNcXFxcdTA5NjYtXFxcXHUwOTZGXFxcXHUwOTcxLVxcXFx1MDk4M1xcXFx1MDk4NS1cXFxcdTA5OENcXFxcdTA5OEZcXFxcdTA5OTBcXFxcdTA5OTMtXFxcXHUwOUE4XFxcXHUwOUFBLVxcXFx1MDlCMFxcXFx1MDlCMlxcXFx1MDlCNi1cXFxcdTA5QjlcXFxcdTA5QkMtXFxcXHUwOUM0XFxcXHUwOUM3XFxcXHUwOUM4XFxcXHUwOUNCLVxcXFx1MDlDRVxcXFx1MDlEN1xcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTNcXFxcdTA5RTYtXFxcXHUwOUYxXFxcXHUwQTAxLVxcXFx1MEEwM1xcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEEzQ1xcXFx1MEEzRS1cXFxcdTBBNDJcXFxcdTBBNDdcXFxcdTBBNDhcXFxcdTBBNEItXFxcXHUwQTREXFxcXHUwQTUxXFxcXHUwQTU5LVxcXFx1MEE1Q1xcXFx1MEE1RVxcXFx1MEE2Ni1cXFxcdTBBNzVcXFxcdTBBODEtXFxcXHUwQTgzXFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkMtXFxcXHUwQUM1XFxcXHUwQUM3LVxcXFx1MEFDOVxcXFx1MEFDQi1cXFxcdTBBQ0RcXFxcdTBBRDBcXFxcdTBBRTAtXFxcXHUwQUUzXFxcXHUwQUU2LVxcXFx1MEFFRlxcXFx1MEIwMS1cXFxcdTBCMDNcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNDLVxcXFx1MEI0NFxcXFx1MEI0N1xcXFx1MEI0OFxcXFx1MEI0Qi1cXFxcdTBCNERcXFxcdTBCNTZcXFxcdTBCNTdcXFxcdTBCNUNcXFxcdTBCNURcXFxcdTBCNUYtXFxcXHUwQjYzXFxcXHUwQjY2LVxcXFx1MEI2RlxcXFx1MEI3MVxcXFx1MEI4MlxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkJFLVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNEXFxcXHUwQkQwXFxcXHUwQkQ3XFxcXHUwQkU2LVxcXFx1MEJFRlxcXFx1MEMwMC1cXFxcdTBDMDNcXFxcdTBDMDUtXFxcXHUwQzBDXFxcXHUwQzBFLVxcXFx1MEMxMFxcXFx1MEMxMi1cXFxcdTBDMjhcXFxcdTBDMkEtXFxcXHUwQzM5XFxcXHUwQzNELVxcXFx1MEM0NFxcXFx1MEM0Ni1cXFxcdTBDNDhcXFxcdTBDNEEtXFxcXHUwQzREXFxcXHUwQzU1XFxcXHUwQzU2XFxcXHUwQzU4XFxcXHUwQzU5XFxcXHUwQzYwLVxcXFx1MEM2M1xcXFx1MEM2Ni1cXFxcdTBDNkZcXFxcdTBDODEtXFxcXHUwQzgzXFxcXHUwQzg1LVxcXFx1MEM4Q1xcXFx1MEM4RS1cXFxcdTBDOTBcXFxcdTBDOTItXFxcXHUwQ0E4XFxcXHUwQ0FBLVxcXFx1MENCM1xcXFx1MENCNS1cXFxcdTBDQjlcXFxcdTBDQkMtXFxcXHUwQ0M0XFxcXHUwQ0M2LVxcXFx1MENDOFxcXFx1MENDQS1cXFxcdTBDQ0RcXFxcdTBDRDVcXFxcdTBDRDZcXFxcdTBDREVcXFxcdTBDRTAtXFxcXHUwQ0UzXFxcXHUwQ0U2LVxcXFx1MENFRlxcXFx1MENGMVxcXFx1MENGMlxcXFx1MEQwMS1cXFxcdTBEMDNcXFxcdTBEMDUtXFxcXHUwRDBDXFxcXHUwRDBFLVxcXFx1MEQxMFxcXFx1MEQxMi1cXFxcdTBEM0FcXFxcdTBEM0QtXFxcXHUwRDQ0XFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENEVcXFxcdTBENTdcXFxcdTBENjAtXFxcXHUwRDYzXFxcXHUwRDY2LVxcXFx1MEQ2RlxcXFx1MEQ3QS1cXFxcdTBEN0ZcXFxcdTBEODJcXFxcdTBEODNcXFxcdTBEODUtXFxcXHUwRDk2XFxcXHUwRDlBLVxcXFx1MERCMVxcXFx1MERCMy1cXFxcdTBEQkJcXFxcdTBEQkRcXFxcdTBEQzAtXFxcXHUwREM2XFxcXHUwRENBXFxcXHUwRENGLVxcXFx1MERENFxcXFx1MERENlxcXFx1MEREOC1cXFxcdTBEREZcXFxcdTBERTYtXFxcXHUwREVGXFxcXHUwREYyXFxcXHUwREYzXFxcXHUwRTAxLVxcXFx1MEUzQVxcXFx1MEU0MC1cXFxcdTBFNEVcXFxcdTBFNTAtXFxcXHUwRTU5XFxcXHUwRTgxXFxcXHUwRTgyXFxcXHUwRTg0XFxcXHUwRTg3XFxcXHUwRTg4XFxcXHUwRThBXFxcXHUwRThEXFxcXHUwRTk0LVxcXFx1MEU5N1xcXFx1MEU5OS1cXFxcdTBFOUZcXFxcdTBFQTEtXFxcXHUwRUEzXFxcXHUwRUE1XFxcXHUwRUE3XFxcXHUwRUFBXFxcXHUwRUFCXFxcXHUwRUFELVxcXFx1MEVCOVxcXFx1MEVCQi1cXFxcdTBFQkRcXFxcdTBFQzAtXFxcXHUwRUM0XFxcXHUwRUM2XFxcXHUwRUM4LVxcXFx1MEVDRFxcXFx1MEVEMC1cXFxcdTBFRDlcXFxcdTBFREMtXFxcXHUwRURGXFxcXHUwRjAwXFxcXHUwRjE4XFxcXHUwRjE5XFxcXHUwRjIwLVxcXFx1MEYyOVxcXFx1MEYzNVxcXFx1MEYzN1xcXFx1MEYzOVxcXFx1MEYzRS1cXFxcdTBGNDdcXFxcdTBGNDktXFxcXHUwRjZDXFxcXHUwRjcxLVxcXFx1MEY4NFxcXFx1MEY4Ni1cXFxcdTBGOTdcXFxcdTBGOTktXFxcXHUwRkJDXFxcXHUwRkM2XFxcXHUxMDAwLVxcXFx1MTA0OVxcXFx1MTA1MC1cXFxcdTEwOURcXFxcdTEwQTAtXFxcXHUxMEM1XFxcXHUxMEM3XFxcXHUxMENEXFxcXHUxMEQwLVxcXFx1MTBGQVxcXFx1MTBGQy1cXFxcdTEyNDhcXFxcdTEyNEEtXFxcXHUxMjREXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1QS1cXFxcdTEyNURcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhBLVxcXFx1MTI4RFxcXFx1MTI5MC1cXFxcdTEyQjBcXFxcdTEyQjItXFxcXHUxMkI1XFxcXHUxMkI4LVxcXFx1MTJCRVxcXFx1MTJDMFxcXFx1MTJDMi1cXFxcdTEyQzVcXFxcdTEyQzgtXFxcXHUxMkQ2XFxcXHUxMkQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVBXFxcXHUxMzVELVxcXFx1MTM1RlxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTEzQTAtXFxcXHUxM0Y0XFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2N0ZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTZFRS1cXFxcdTE2RjhcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxNFxcXFx1MTcyMC1cXFxcdTE3MzRcXFxcdTE3NDAtXFxcXHUxNzUzXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3ODAtXFxcXHUxN0QzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxN0REXFxcXHUxN0UwLVxcXFx1MTdFOVxcXFx1MTgwQi1cXFxcdTE4MERcXFxcdTE4MTAtXFxcXHUxODE5XFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxRVxcXFx1MTkyMC1cXFxcdTE5MkJcXFxcdTE5MzAtXFxcXHUxOTNCXFxcXHUxOTQ2LVxcXFx1MTk2RFxcXFx1MTk3MC1cXFxcdTE5NzRcXFxcdTE5ODAtXFxcXHUxOUFCXFxcXHUxOUIwLVxcXFx1MTlDOVxcXFx1MTlEMC1cXFxcdTE5RDlcXFxcdTFBMDAtXFxcXHUxQTFCXFxcXHUxQTIwLVxcXFx1MUE1RVxcXFx1MUE2MC1cXFxcdTFBN0NcXFxcdTFBN0YtXFxcXHUxQTg5XFxcXHUxQTkwLVxcXFx1MUE5OVxcXFx1MUFBN1xcXFx1MUFCMC1cXFxcdTFBQkRcXFxcdTFCMDAtXFxcXHUxQjRCXFxcXHUxQjUwLVxcXFx1MUI1OVxcXFx1MUI2Qi1cXFxcdTFCNzNcXFxcdTFCODAtXFxcXHUxQkYzXFxcXHUxQzAwLVxcXFx1MUMzN1xcXFx1MUM0MC1cXFxcdTFDNDlcXFxcdTFDNEQtXFxcXHUxQzdEXFxcXHUxQ0QwLVxcXFx1MUNEMlxcXFx1MUNENC1cXFxcdTFDRjZcXFxcdTFDRjhcXFxcdTFDRjlcXFxcdTFEMDAtXFxcXHUxREY1XFxcXHUxREZDLVxcXFx1MUYxNVxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjAtXFxcXHUxRjQ1XFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUYtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUZCNFxcXFx1MUZCNi1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2LVxcXFx1MUZDQ1xcXFx1MUZEMC1cXFxcdTFGRDNcXFxcdTFGRDYtXFxcXHUxRkRCXFxcXHUxRkUwLVxcXFx1MUZFQ1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjYtXFxcXHUxRkZDXFxcXHUyMDBDXFxcXHUyMDBEXFxcXHUyMDNGXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHUyMDcxXFxcXHUyMDdGXFxcXHUyMDkwLVxcXFx1MjA5Q1xcXFx1MjBEMC1cXFxcdTIwRENcXFxcdTIwRTFcXFxcdTIwRTUtXFxcXHUyMEYwXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTYwLVxcXFx1MjE4OFxcXFx1MkMwMC1cXFxcdTJDMkVcXFxcdTJDMzAtXFxcXHUyQzVFXFxcXHUyQzYwLVxcXFx1MkNFNFxcXFx1MkNFQi1cXFxcdTJDRjNcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDI3XFxcXHUyRDJEXFxcXHUyRDMwLVxcXFx1MkQ2N1xcXFx1MkQ2RlxcXFx1MkQ3Ri1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MkRFMC1cXFxcdTJERkZcXFxcdTJFMkZcXFxcdTMwMDUtXFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyRlxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwMzgtXFxcXHUzMDNDXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5OVxcXFx1MzA5QVxcXFx1MzA5RC1cXFxcdTMwOUZcXFxcdTMwQTEtXFxcXHUzMEZBXFxcXHUzMEZDLVxcXFx1MzBGRlxcXFx1MzEwNS1cXFxcdTMxMkRcXFxcdTMxMzEtXFxcXHUzMThFXFxcXHUzMUEwLVxcXFx1MzFCQVxcXFx1MzFGMC1cXFxcdTMxRkZcXFxcdTM0MDAtXFxcXHU0REI1XFxcXHU0RTAwLVxcXFx1OUZDQ1xcXFx1QTAwMC1cXFxcdUE0OENcXFxcdUE0RDAtXFxcXHVBNEZEXFxcXHVBNTAwLVxcXFx1QTYwQ1xcXFx1QTYxMC1cXFxcdUE2MkJcXFxcdUE2NDAtXFxcXHVBNjZGXFxcXHVBNjc0LVxcXFx1QTY3RFxcXFx1QTY3Ri1cXFxcdUE2OURcXFxcdUE2OUYtXFxcXHVBNkYxXFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTcyMi1cXFxcdUE3ODhcXFxcdUE3OEItXFxcXHVBNzhFXFxcXHVBNzkwLVxcXFx1QTdBRFxcXFx1QTdCMFxcXFx1QTdCMVxcXFx1QTdGNy1cXFxcdUE4MjdcXFxcdUE4NDAtXFxcXHVBODczXFxcXHVBODgwLVxcXFx1QThDNFxcXFx1QThEMC1cXFxcdUE4RDlcXFxcdUE4RTAtXFxcXHVBOEY3XFxcXHVBOEZCXFxcXHVBOTAwLVxcXFx1QTkyRFxcXFx1QTkzMC1cXFxcdUE5NTNcXFxcdUE5NjAtXFxcXHVBOTdDXFxcXHVBOTgwLVxcXFx1QTlDMFxcXFx1QTlDRi1cXFxcdUE5RDlcXFxcdUE5RTAtXFxcXHVBOUZFXFxcXHVBQTAwLVxcXFx1QUEzNlxcXFx1QUE0MC1cXFxcdUFBNERcXFxcdUFBNTAtXFxcXHVBQTU5XFxcXHVBQTYwLVxcXFx1QUE3NlxcXFx1QUE3QS1cXFxcdUFBQzJcXFxcdUFBREItXFxcXHVBQUREXFxcXHVBQUUwLVxcXFx1QUFFRlxcXFx1QUFGMi1cXFxcdUFBRjZcXFxcdUFCMDEtXFxcXHVBQjA2XFxcXHVBQjA5LVxcXFx1QUIwRVxcXFx1QUIxMS1cXFxcdUFCMTZcXFxcdUFCMjAtXFxcXHVBQjI2XFxcXHVBQjI4LVxcXFx1QUIyRVxcXFx1QUIzMC1cXFxcdUFCNUFcXFxcdUFCNUMtXFxcXHVBQjVGXFxcXHVBQjY0XFxcXHVBQjY1XFxcXHVBQkMwLVxcXFx1QUJFQVxcXFx1QUJFQ1xcXFx1QUJFRFxcXFx1QUJGMC1cXFxcdUFCRjlcXFxcdUFDMDAtXFxcXHVEN0EzXFxcXHVEN0IwLVxcXFx1RDdDNlxcXFx1RDdDQi1cXFxcdUQ3RkJcXFxcdUY5MDAtXFxcXHVGQTZEXFxcXHVGQTcwLVxcXFx1RkFEOVxcXFx1RkIwMC1cXFxcdUZCMDZcXFxcdUZCMTMtXFxcXHVGQjE3XFxcXHVGQjFELVxcXFx1RkIyOFxcXFx1RkIyQS1cXFxcdUZCMzZcXFxcdUZCMzgtXFxcXHVGQjNDXFxcXHVGQjNFXFxcXHVGQjQwXFxcXHVGQjQxXFxcXHVGQjQzXFxcXHVGQjQ0XFxcXHVGQjQ2LVxcXFx1RkJCMVxcXFx1RkJEMy1cXFxcdUZEM0RcXFxcdUZENTAtXFxcXHVGRDhGXFxcXHVGRDkyLVxcXFx1RkRDN1xcXFx1RkRGMC1cXFxcdUZERkJcXFxcdUZFMDAtXFxcXHVGRTBGXFxcXHVGRTIwLVxcXFx1RkUyRFxcXFx1RkUzM1xcXFx1RkUzNFxcXFx1RkU0RC1cXFxcdUZFNEZcXFxcdUZFNzAtXFxcXHVGRTc0XFxcXHVGRTc2LVxcXFx1RkVGQ1xcXFx1RkYxMC1cXFxcdUZGMTlcXFxcdUZGMjEtXFxcXHVGRjNBXFxcXHVGRjNGXFxcXHVGRjQxLVxcXFx1RkY1QVxcXFx1RkY2Ni1cXFxcdUZGQkVcXFxcdUZGQzItXFxcXHVGRkM3XFxcXHVGRkNBLVxcXFx1RkZDRlxcXFx1RkZEMi1cXFxcdUZGRDdcXFxcdUZGREEtXFxcXHVGRkRDXScpOyAvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4vLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbi8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuLy8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuIGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOTsgLy8gMC4uOVxufVxuXG5mdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRicuaW5kZXhPZihjaCkgPj0gMDtcbn1cblxuZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG59IC8vIDcuMiBXaGl0ZSBTcGFjZVxuXG5cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICByZXR1cm4gY2ggPT09IDB4MjAgfHwgY2ggPT09IDB4MDkgfHwgY2ggPT09IDB4MEIgfHwgY2ggPT09IDB4MEMgfHwgY2ggPT09IDB4QTAgfHwgY2ggPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MTgwRSwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjaCkgPj0gMDtcbn0gLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuXG5mdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgwQSB8fCBjaCA9PT0gMHgwRCB8fCBjaCA9PT0gMHgyMDI4IHx8IGNoID09PSAweDIwMjk7XG59IC8vIDcuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RiB8fCBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHwgY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBIHx8IGNoID09PSAweDVDIHx8IGNoID49IDB4ODAgJiYgUmVnZXhOb25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICByZXR1cm4gY2ggPT09IDB4MjQgfHwgY2ggPT09IDB4NUYgfHwgY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBIHx8IGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSB8fCBjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkgfHwgY2ggPT09IDB4NUMgfHwgY2ggPj0gMHg4MCAmJiBSZWdleE5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSk7XG59IC8vIDcuNi4xLjEgS2V5d29yZHNcblxuXG5jb25zdCBrZXl3b3JkcyA9IHtcbiAgJ2lmJzogMSxcbiAgJ2luJzogMSxcbiAgJ2RvJzogMSxcbiAgJ3Zhcic6IDEsXG4gICdmb3InOiAxLFxuICAnbmV3JzogMSxcbiAgJ3RyeSc6IDEsXG4gICdsZXQnOiAxLFxuICAndGhpcyc6IDEsXG4gICdlbHNlJzogMSxcbiAgJ2Nhc2UnOiAxLFxuICAndm9pZCc6IDEsXG4gICd3aXRoJzogMSxcbiAgJ2VudW0nOiAxLFxuICAnd2hpbGUnOiAxLFxuICAnYnJlYWsnOiAxLFxuICAnY2F0Y2gnOiAxLFxuICAndGhyb3cnOiAxLFxuICAnY29uc3QnOiAxLFxuICAneWllbGQnOiAxLFxuICAnY2xhc3MnOiAxLFxuICAnc3VwZXInOiAxLFxuICAncmV0dXJuJzogMSxcbiAgJ3R5cGVvZic6IDEsXG4gICdkZWxldGUnOiAxLFxuICAnc3dpdGNoJzogMSxcbiAgJ2V4cG9ydCc6IDEsXG4gICdpbXBvcnQnOiAxLFxuICAncHVibGljJzogMSxcbiAgJ3N0YXRpYyc6IDEsXG4gICdkZWZhdWx0JzogMSxcbiAgJ2ZpbmFsbHknOiAxLFxuICAnZXh0ZW5kcyc6IDEsXG4gICdwYWNrYWdlJzogMSxcbiAgJ3ByaXZhdGUnOiAxLFxuICAnZnVuY3Rpb24nOiAxLFxuICAnY29udGludWUnOiAxLFxuICAnZGVidWdnZXInOiAxLFxuICAnaW50ZXJmYWNlJzogMSxcbiAgJ3Byb3RlY3RlZCc6IDEsXG4gICdpbnN0YW5jZW9mJzogMSxcbiAgJ2ltcGxlbWVudHMnOiAxXG59O1xuXG5mdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY29uc3QgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICBpZiAoaXNXaGl0ZVNwYWNlKGNoKSB8fCBpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgKytpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gIHZhciBpLFxuICAgICAgbGVuLFxuICAgICAgY2gsXG4gICAgICBjb2RlID0gMDtcbiAgbGVuID0gcHJlZml4ID09PSAndScgPyA0IDogMjtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xufVxuXG5mdW5jdGlvbiBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpIHtcbiAgdmFyIGNoLCBjb2RlLCBjdTEsIGN1MjtcbiAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICBjb2RlID0gMDsgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG5cbiAgaWYgKGNoID09PSAnfScpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgaWYgKGNvZGUgPiAweDEwRkZGRiB8fCBjaCAhPT0gJ30nKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH0gLy8gVVRGLTE2IEVuY29kaW5nXG5cblxuICBpZiAoY29kZSA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIGN1MSA9IChjb2RlIC0gMHgxMDAwMCA+PiAxMCkgKyAweEQ4MDA7XG4gIGN1MiA9IChjb2RlIC0gMHgxMDAwMCAmIDEwMjMpICsgMHhEQzAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjdTEsIGN1Mik7XG59XG5cbmZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xuICB2YXIgY2gsIGlkO1xuICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KyspO1xuICBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpOyAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG5cbiAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfVxuXG4gICAgKytpbmRleDtcbiAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcblxuICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH1cblxuICAgIGlkID0gY2g7XG4gIH1cblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgICsraW5kZXg7XG4gICAgaWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7IC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cblxuICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XG5cbiAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgICB9XG5cbiAgICAgICsraW5kZXg7XG4gICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcblxuICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgICAgfVxuXG4gICAgICBpZCArPSBjaDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGdldElkZW50aWZpZXIoKSB7XG4gIHZhciBzdGFydCwgY2g7XG4gIHN0YXJ0ID0gaW5kZXgrKztcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgIGluZGV4ID0gc3RhcnQ7XG4gICAgICByZXR1cm4gZ2V0RXNjYXBlZElkZW50aWZpZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICsraW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KTtcbn1cblxuZnVuY3Rpb24gc2NhbklkZW50aWZpZXIoKSB7XG4gIHZhciBzdGFydCwgaWQsIHR5cGU7XG4gIHN0YXJ0ID0gaW5kZXg7IC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG5cbiAgaWQgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4NUMgPyBnZXRFc2NhcGVkSWRlbnRpZmllcigpIDogZ2V0SWRlbnRpZmllcigpOyAvLyBUaGVyZSBpcyBubyBrZXl3b3JkIG9yIGxpdGVyYWwgd2l0aCBvbmx5IG9uZSBjaGFyYWN0ZXIuXG4gIC8vIFRodXMsIGl0IG11c3QgYmUgYW4gaWRlbnRpZmllci5cblxuICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgdHlwZSA9IFRva2VuSWRlbnRpZmllcjtcbiAgfSBlbHNlIGlmIChrZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHR5cGUgPSBUb2tlbktleXdvcmQ7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdudWxsJykge1xuICAgIHR5cGUgPSBUb2tlbk51bGxMaXRlcmFsO1xuICB9IGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcbiAgICB0eXBlID0gVG9rZW5Cb29sZWFuTGl0ZXJhbDtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gVG9rZW5JZGVudGlmaWVyO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZhbHVlOiBpZCxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBpbmRleFxuICB9O1xufSAvLyA3LjcgUHVuY3R1YXRvcnNcblxuXG5mdW5jdGlvbiBzY2FuUHVuY3R1YXRvcigpIHtcbiAgdmFyIHN0YXJ0ID0gaW5kZXgsXG4gICAgICBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpLFxuICAgICAgY29kZTIsXG4gICAgICBjaDEgPSBzb3VyY2VbaW5kZXhdLFxuICAgICAgY2gyLFxuICAgICAgY2gzLFxuICAgICAgY2g0O1xuXG4gIHN3aXRjaCAoY29kZSkge1xuICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgIGNhc2UgMHgyRTogLy8gLiBkb3RcblxuICAgIGNhc2UgMHgyODogLy8gKCBvcGVuIGJyYWNrZXRcblxuICAgIGNhc2UgMHgyOTogLy8gKSBjbG9zZSBicmFja2V0XG5cbiAgICBjYXNlIDB4M0I6IC8vIDsgc2VtaWNvbG9uXG5cbiAgICBjYXNlIDB4MkM6IC8vICwgY29tbWFcblxuICAgIGNhc2UgMHg3QjogLy8geyBvcGVuIGN1cmx5IGJyYWNlXG5cbiAgICBjYXNlIDB4N0Q6IC8vIH0gY2xvc2UgY3VybHkgYnJhY2VcblxuICAgIGNhc2UgMHg1QjogLy8gW1xuXG4gICAgY2FzZSAweDVEOiAvLyBdXG5cbiAgICBjYXNlIDB4M0E6IC8vIDpcblxuICAgIGNhc2UgMHgzRjogLy8gP1xuXG4gICAgY2FzZSAweDdFOlxuICAgICAgLy8gflxuICAgICAgKytpbmRleDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFRva2VuUHVuY3R1YXRvcixcbiAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSksXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjb2RlMiA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSk7IC8vICc9JyAoVSswMDNEKSBtYXJrcyBhbiBhc3NpZ25tZW50IG9yIGNvbXBhcmlzb24gb3BlcmF0b3IuXG5cbiAgICAgIGlmIChjb2RlMiA9PT0gMHgzRCkge1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDB4MkI6IC8vICtcblxuICAgICAgICAgIGNhc2UgMHgyRDogLy8gLVxuXG4gICAgICAgICAgY2FzZSAweDJGOiAvLyAvXG5cbiAgICAgICAgICBjYXNlIDB4M0M6IC8vIDxcblxuICAgICAgICAgIGNhc2UgMHgzRTogLy8gPlxuXG4gICAgICAgICAgY2FzZSAweDVFOiAvLyBeXG5cbiAgICAgICAgICBjYXNlIDB4N0M6IC8vIHxcblxuICAgICAgICAgIGNhc2UgMHgyNTogLy8gJVxuXG4gICAgICAgICAgY2FzZSAweDI2OiAvLyAmXG5cbiAgICAgICAgICBjYXNlIDB4MkE6XG4gICAgICAgICAgICAvLyAqXG4gICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZTIpLFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlIDB4MjE6IC8vICFcblxuICAgICAgICAgIGNhc2UgMHgzRDpcbiAgICAgICAgICAgIC8vID1cbiAgICAgICAgICAgIGluZGV4ICs9IDI7IC8vICE9PSBhbmQgPT09XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0QpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCksXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIH0gLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvcjogPj4+PVxuXG5cbiAgY2g0ID0gc291cmNlLnN1YnN0cihpbmRleCwgNCk7XG5cbiAgaWYgKGNoNCA9PT0gJz4+Pj0nKSB7XG4gICAgaW5kZXggKz0gNDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoNCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9IC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cblxuICBjaDMgPSBjaDQuc3Vic3RyKDAsIDMpO1xuXG4gIGlmIChjaDMgPT09ICc+Pj4nIHx8IGNoMyA9PT0gJzw8PScgfHwgY2gzID09PSAnPj49Jykge1xuICAgIGluZGV4ICs9IDM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFRva2VuUHVuY3R1YXRvcixcbiAgICAgIHZhbHVlOiBjaDMsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGluZGV4XG4gICAgfTtcbiAgfSAvLyBPdGhlciAyLWNoYXJhY3RlciBwdW5jdHVhdG9yczogKysgLS0gPDwgPj4gJiYgfHxcblxuXG4gIGNoMiA9IGNoMy5zdWJzdHIoMCwgMik7XG5cbiAgaWYgKGNoMSA9PT0gY2gyWzFdICYmICcrLTw+JnwnLmluZGV4T2YoY2gxKSA+PSAwIHx8IGNoMiA9PT0gJz0+Jykge1xuICAgIGluZGV4ICs9IDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFRva2VuUHVuY3R1YXRvcixcbiAgICAgIHZhbHVlOiBjaDIsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGluZGV4XG4gICAgfTtcbiAgfVxuXG4gIGlmIChjaDIgPT09ICcvLycpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfSAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPCA+ID0gISArIC0gKiAlICYgfCBeIC9cblxuXG4gIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKGNoMSkgPj0gMCkge1xuICAgICsraW5kZXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFRva2VuUHVuY3R1YXRvcixcbiAgICAgIHZhbHVlOiBjaDEsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGluZGV4XG4gICAgfTtcbiAgfVxuXG4gIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xufSAvLyA3LjguMyBOdW1lcmljIExpdGVyYWxzXG5cblxuZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgbGV0IG51bWJlciA9ICcnO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmICghaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgfVxuXG4gIGlmIChudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cblxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUb2tlbk51bWVyaWNMaXRlcmFsLFxuICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCkge1xuICBsZXQgbnVtYmVyID0gJzAnICsgc291cmNlW2luZGV4KytdO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICB9XG5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUb2tlbk51bWVyaWNMaXRlcmFsLFxuICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgIG9jdGFsOiB0cnVlLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5OdW1lcmljTGl0ZXJhbCgpIHtcbiAgdmFyIG51bWJlciwgc3RhcnQsIGNoO1xuICBjaCA9IHNvdXJjZVtpbmRleF07XG4gIGFzc2VydChpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCBjaCA9PT0gJy4nLCAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XG4gIHN0YXJ0ID0gaW5kZXg7XG4gIG51bWJlciA9ICcnO1xuXG4gIGlmIChjaCAhPT0gJy4nKSB7XG4gICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgIGNoID0gc291cmNlW2luZGV4XTsgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXG5cbiAgICBpZiAobnVtYmVyID09PSAnMCcpIHtcbiAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgKytpbmRleDtcbiAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgcmV0dXJuIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpO1xuICAgICAgfSAvLyBkZWNpbWFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcgc3VjaCBhcyAnMDknIGlzIGlsbGVnYWwuXG5cblxuICAgICAgaWYgKGNoICYmIGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgIH1cblxuICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgIH1cblxuICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgIGNoID0gc291cmNlW2luZGV4XTtcblxuICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcbiAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgfVxuXG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFRva2VuTnVtZXJpY0xpdGVyYWwsXG4gICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBpbmRleFxuICB9O1xufSAvLyA3LjguNCBTdHJpbmcgTGl0ZXJhbHNcblxuXG5mdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgdmFyIHN0ciA9ICcnLFxuICAgICAgcXVvdGUsXG4gICAgICBzdGFydCxcbiAgICAgIGNoLFxuICAgICAgY29kZSxcbiAgICAgIG9jdGFsID0gZmFsc2U7XG4gIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgYXNzZXJ0KHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJywgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuICBzdGFydCA9IGluZGV4O1xuICArK2luZGV4O1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgcXVvdGUgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgIGlmICghY2ggfHwgIWlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICBzdHIgKz0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTsgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcblxuICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7IC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXG4gICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG5cbiAgICAgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiYgaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9IGNoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogVG9rZW5TdHJpbmdMaXRlcmFsLFxuICAgIHZhbHVlOiBzdHIsXG4gICAgb2N0YWw6IG9jdGFsLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgbGV0IHRtcCA9IHBhdHRlcm47XG5cbiAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSA+PSAwKSB7XG4gICAgLy8gUmVwbGFjZSBlYWNoIGFzdHJhbCBzeW1ib2wgYW5kIGV2ZXJ5IFVuaWNvZGUgY29kZSBwb2ludFxuICAgIC8vIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIEFTQ0lJIHN5bWJvbCB0byBhdm9pZCB0aHJvd2luZyBvblxuICAgIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBhcmUgb25seSB2YWxpZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZVxuICAgIC8vIGAvdWAgZmxhZy5cbiAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCB0aGUgQVNDSUkgc3ltYm9sIGB4YCBtaWdodCBjYXVzZSBmYWxzZVxuICAgIC8vIG5lZ2F0aXZlcyBpbiB1bmxpa2VseSBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXs2MX0tYl1gIGlzIGFcbiAgICAvLyBwZXJmZWN0bHkgdmFsaWQgcGF0dGVybiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYFthLWJdYCwgYnV0IGl0XG4gICAgLy8gd291bGQgYmUgcmVwbGFjZWQgYnkgYFt4LWJdYCB3aGljaCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgdG1wID0gdG1wLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH0vZywgKCQwLCAkMSkgPT4ge1xuICAgICAgaWYgKHBhcnNlSW50KCQxLCAxNikgPD0gMHgxMEZGRkYpIHtcbiAgICAgICAgcmV0dXJuICd4JztcbiAgICAgIH1cblxuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZUludmFsaWRSZWdFeHApO1xuICAgIH0pLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgJ3gnKTtcbiAgfSAvLyBGaXJzdCwgZGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cblxuXG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cCh0bXApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZUludmFsaWRSZWdFeHApO1xuICB9IC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXG4gIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcbiAgLy8gdXNlcy5cblxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FuUmVnRXhwQm9keSgpIHtcbiAgdmFyIGNoLCBzdHIsIGNsYXNzTWFya2VyLCB0ZXJtaW5hdGVkLCBib2R5O1xuICBjaCA9IHNvdXJjZVtpbmRleF07XG4gIGFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcbiAgc3RyID0gc291cmNlW2luZGV4KytdO1xuICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICB0ZXJtaW5hdGVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgc3RyICs9IGNoO1xuXG4gICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgIGNoID0gc291cmNlW2luZGV4KytdOyAvLyBFQ01BLTI2MiA3LjguNVxuXG4gICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IGNoO1xuICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgfSBlbHNlIGlmIChjbGFzc01hcmtlcikge1xuICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgfSAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuXG5cbiAgYm9keSA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBib2R5LFxuICAgIGxpdGVyYWw6IHN0clxuICB9O1xufVxuXG5mdW5jdGlvbiBzY2FuUmVnRXhwRmxhZ3MoKSB7XG4gIHZhciBjaCwgc3RyLCBmbGFncztcbiAgc3RyID0gJyc7XG4gIGZsYWdzID0gJyc7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICArK2luZGV4O1xuXG4gICAgaWYgKGNoID09PSAnXFxcXCcgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGFncyArPSBjaDtcbiAgICAgIHN0ciArPSBjaDtcbiAgICB9XG4gIH1cblxuICBpZiAoZmxhZ3Muc2VhcmNoKC9bXmdpbXV5XS9nKSA+PSAwKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZUludmFsaWRSZWdFeHAsIGZsYWdzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGZsYWdzLFxuICAgIGxpdGVyYWw6IHN0clxuICB9O1xufVxuXG5mdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xuICB2YXIgc3RhcnQsIGJvZHksIGZsYWdzLCB2YWx1ZTtcbiAgbG9va2FoZWFkID0gbnVsbDtcbiAgc2tpcENvbW1lbnQoKTtcbiAgc3RhcnQgPSBpbmRleDtcbiAgYm9keSA9IHNjYW5SZWdFeHBCb2R5KCk7XG4gIGZsYWdzID0gc2NhblJlZ0V4cEZsYWdzKCk7XG4gIHZhbHVlID0gdGVzdFJlZ0V4cChib2R5LnZhbHVlLCBmbGFncy52YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgbGl0ZXJhbDogYm9keS5saXRlcmFsICsgZmxhZ3MubGl0ZXJhbCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcmVnZXg6IHtcbiAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICB9LFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuSWRlbnRpZmllciB8fCB0b2tlbi50eXBlID09PSBUb2tlbktleXdvcmQgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW5Cb29sZWFuTGl0ZXJhbCB8fCB0b2tlbi50eXBlID09PSBUb2tlbk51bGxMaXRlcmFsO1xufVxuXG5mdW5jdGlvbiBhZHZhbmNlKCkge1xuICBza2lwQ29tbWVudCgpO1xuXG4gIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5FT0YsXG4gICAgICBzdGFydDogaW5kZXgsXG4gICAgICBlbmQ6IGluZGV4XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICByZXR1cm4gc2NhbklkZW50aWZpZXIoKTtcbiAgfSAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xuXG5cbiAgaWYgKGNoID09PSAweDI4IHx8IGNoID09PSAweDI5IHx8IGNoID09PSAweDNCKSB7XG4gICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gIH0gLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cblxuXG4gIGlmIChjaCA9PT0gMHgyNyB8fCBjaCA9PT0gMHgyMikge1xuICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICB9IC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG5cblxuICBpZiAoY2ggPT09IDB4MkUpIHtcbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfVxuXG4gIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gIH1cblxuICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbn1cblxuZnVuY3Rpb24gbGV4KCkge1xuICBjb25zdCB0b2tlbiA9IGxvb2thaGVhZDtcbiAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gIGxvb2thaGVhZCA9IGFkdmFuY2UoKTtcbiAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gIHJldHVybiB0b2tlbjtcbn1cblxuZnVuY3Rpb24gcGVlaygpIHtcbiAgY29uc3QgcG9zID0gaW5kZXg7XG4gIGxvb2thaGVhZCA9IGFkdmFuY2UoKTtcbiAgaW5kZXggPSBwb3M7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaEFycmF5RXhwcmVzc2lvbihlbGVtZW50cykge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4QXJyYXlFeHByZXNzaW9uKTtcbiAgbm9kZS5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnID8gU3ludGF4TG9naWNhbEV4cHJlc3Npb24gOiBTeW50YXhCaW5hcnlFeHByZXNzaW9uKTtcbiAgbm9kZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheENhbGxFeHByZXNzaW9uKTtcbiAgbm9kZS5jYWxsZWUgPSBjYWxsZWU7XG4gIG5vZGUuYXJndW1lbnRzID0gYXJncztcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheENvbmRpdGlvbmFsRXhwcmVzc2lvbik7XG4gIG5vZGUudGVzdCA9IHRlc3Q7XG4gIG5vZGUuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gIG5vZGUuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoSWRlbnRpZmllcihuYW1lKSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhJZGVudGlmaWVyKTtcbiAgbm9kZS5uYW1lID0gbmFtZTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaExpdGVyYWwodG9rZW4pIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheExpdGVyYWwpO1xuICBub2RlLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gIG5vZGUucmF3ID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuXG4gIGlmICh0b2tlbi5yZWdleCkge1xuICAgIGlmIChub2RlLnJhdyA9PT0gJy8vJykge1xuICAgICAgbm9kZS5yYXcgPSAnLyg/OikvJztcbiAgICB9XG5cbiAgICBub2RlLnJlZ2V4ID0gdG9rZW4ucmVnZXg7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTWVtYmVyRXhwcmVzc2lvbihhY2Nlc3Nvciwgb2JqZWN0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4TWVtYmVyRXhwcmVzc2lvbik7XG4gIG5vZGUuY29tcHV0ZWQgPSBhY2Nlc3NvciA9PT0gJ1snO1xuICBub2RlLm9iamVjdCA9IG9iamVjdDtcbiAgbm9kZS5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICBpZiAoIW5vZGUuY29tcHV0ZWQpIHByb3BlcnR5Lm1lbWJlciA9IHRydWU7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheE9iamVjdEV4cHJlc3Npb24pO1xuICBub2RlLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoUHJvcGVydHkoa2luZCwga2V5LCB2YWx1ZSkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4UHJvcGVydHkpO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBub2RlLmtpbmQgPSBraW5kO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4VW5hcnlFeHByZXNzaW9uKTtcbiAgbm9kZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICBub2RlLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGU7XG59IC8vIFRocm93IGFuIGV4Y2VwdGlvblxuXG5cbmZ1bmN0aW9uIHRocm93RXJyb3IodG9rZW4sIG1lc3NhZ2VGb3JtYXQpIHtcbiAgdmFyIGVycm9yLFxuICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCAod2hvbGUsIGluZGV4KSA9PiB7XG4gICAgYXNzZXJ0KGluZGV4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgcmV0dXJuIGFyZ3NbaW5kZXhdO1xuICB9KTtcbiAgZXJyb3IgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyb3IuaW5kZXggPSBpbmRleDtcbiAgZXJyb3IuZGVzY3JpcHRpb24gPSBtc2c7XG4gIHRocm93IGVycm9yO1xufSAvLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXG5cblxuZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkKHRva2VuKSB7XG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbkVPRikge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkRU9TKTtcbiAgfVxuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbk51bWVyaWNMaXRlcmFsKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWROdW1iZXIpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuU3RyaW5nTGl0ZXJhbCkge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkU3RyaW5nKTtcbiAgfVxuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbklkZW50aWZpZXIpIHtcbiAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlVW5leHBlY3RlZElkZW50aWZpZXIpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuS2V5d29yZCkge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkUmVzZXJ2ZWQpO1xuICB9IC8vIEJvb2xlYW5MaXRlcmFsLCBOdWxsTGl0ZXJhbCwgb3IgUHVuY3R1YXRvci5cblxuXG4gIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbn0gLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cbi8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG5cbmZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICBjb25zdCB0b2tlbiA9IGxleCgpO1xuXG4gIGlmICh0b2tlbi50eXBlICE9PSBUb2tlblB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgfVxufSAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblxuXG5mdW5jdGlvbiBtYXRjaCh2YWx1ZSkge1xuICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudmFsdWUgPT09IHZhbHVlO1xufSAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5d29yZFxuXG5cbmZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW5LZXl3b3JkICYmIGxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcbn0gLy8gMTEuMS40IEFycmF5IEluaXRpYWxpc2VyXG5cblxuZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgZXhwZWN0KCdbJyk7XG5cbiAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgIGxleCgpO1xuICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHMucHVzaChwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpKTtcblxuICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxleCgpO1xuICByZXR1cm4gZmluaXNoQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKTtcbn0gLy8gMTEuMS41IE9iamVjdCBJbml0aWFsaXNlclxuXG5cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICBjb25zdCB0b2tlbiA9IGxleCgpOyAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IGZyb20gcGFyc2VPYmplY3RQcm9wZXJ0eSgpLCB3aGVyZVxuICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5TdHJpbmdMaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuTnVtZXJpY0xpdGVyYWwpIHtcbiAgICBpZiAodG9rZW4ub2N0YWwpIHtcbiAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VTdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgfVxuXG4gIHJldHVybiBmaW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eSgpIHtcbiAgdmFyIHRva2VuLCBrZXksIGlkLCB2YWx1ZTtcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIHRva2VuID0gbG9va2FoZWFkO1xuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbklkZW50aWZpZXIpIHtcbiAgICBpZCA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICBleHBlY3QoJzonKTtcbiAgICB2YWx1ZSA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG4gICAgcmV0dXJuIGZpbmlzaFByb3BlcnR5KCdpbml0JywgaWQsIHZhbHVlKTtcbiAgfVxuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbkVPRiB8fCB0b2tlbi50eXBlID09PSBUb2tlblB1bmN0dWF0b3IpIHtcbiAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICBleHBlY3QoJzonKTtcbiAgICB2YWx1ZSA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG4gICAgcmV0dXJuIGZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSBbXSxcbiAgICAgIHByb3BlcnR5LFxuICAgICAgbmFtZSxcbiAgICAgIGtleSxcbiAgICAgIG1hcCA9IHt9LFxuICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICBleHBlY3QoJ3snKTtcblxuICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICBwcm9wZXJ0eSA9IHBhcnNlT2JqZWN0UHJvcGVydHkoKTtcblxuICAgIGlmIChwcm9wZXJ0eS5rZXkudHlwZSA9PT0gU3ludGF4SWRlbnRpZmllcikge1xuICAgICAgbmFtZSA9IHByb3BlcnR5LmtleS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICB9XG5cbiAgICBrZXkgPSAnJCcgKyBuYW1lO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VTdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcFtrZXldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICBleHBlY3QoJywnKTtcbiAgICB9XG4gIH1cblxuICBleHBlY3QoJ30nKTtcbiAgcmV0dXJuIGZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcyk7XG59IC8vIDExLjEuNiBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuXG5mdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgZXhwZWN0KCcoJyk7XG4gIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgZXhwZWN0KCcpJyk7XG4gIHJldHVybiBleHByO1xufSAvLyAxMS4xIFByaW1hcnkgRXhwcmVzc2lvbnNcblxuXG5jb25zdCBsZWdhbEtleXdvcmRzID0ge1xuICAnaWYnOiAxXG59O1xuXG5mdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCkge1xuICB2YXIgdHlwZSwgdG9rZW4sIGV4cHI7XG5cbiAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICByZXR1cm4gcGFyc2VHcm91cEV4cHJlc3Npb24oKTtcbiAgfVxuXG4gIGlmIChtYXRjaCgnWycpKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICB9XG5cbiAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICB9XG5cbiAgdHlwZSA9IGxvb2thaGVhZC50eXBlO1xuICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcblxuICBpZiAodHlwZSA9PT0gVG9rZW5JZGVudGlmaWVyIHx8IGxlZ2FsS2V5d29yZHNbbG9va2FoZWFkLnZhbHVlXSkge1xuICAgIGV4cHIgPSBmaW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlblN0cmluZ0xpdGVyYWwgfHwgdHlwZSA9PT0gVG9rZW5OdW1lcmljTGl0ZXJhbCkge1xuICAgIGlmIChsb29rYWhlYWQub2N0YWwpIHtcbiAgICAgIHRocm93RXJyb3IobG9va2FoZWFkLCBNZXNzYWdlU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICB9XG5cbiAgICBleHByID0gZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW5LZXl3b3JkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKERJU0FCTEVEKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbkJvb2xlYW5MaXRlcmFsKSB7XG4gICAgdG9rZW4gPSBsZXgoKTtcbiAgICB0b2tlbi52YWx1ZSA9IHRva2VuLnZhbHVlID09PSAndHJ1ZSc7XG4gICAgZXhwciA9IGZpbmlzaExpdGVyYWwodG9rZW4pO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuTnVsbExpdGVyYWwpIHtcbiAgICB0b2tlbiA9IGxleCgpO1xuICAgIHRva2VuLnZhbHVlID0gbnVsbDtcbiAgICBleHByID0gZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgIGV4cHIgPSBmaW5pc2hMaXRlcmFsKHNjYW5SZWdFeHAoKSk7XG4gICAgcGVlaygpO1xuICB9IGVsc2Uge1xuICAgIHRocm93VW5leHBlY3RlZChsZXgoKSk7XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn0gLy8gMTEuMiBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG5cbmZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICBjb25zdCBhcmdzID0gW107XG4gIGV4cGVjdCgnKCcpO1xuXG4gIGlmICghbWF0Y2goJyknKSkge1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJncy5wdXNoKHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkpO1xuXG4gICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KCcsJyk7XG4gICAgfVxuICB9XG5cbiAgZXhwZWN0KCcpJyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKSB7XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICBjb25zdCB0b2tlbiA9IGxleCgpO1xuXG4gIGlmICghaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcbiAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICB9XG5cbiAgcmV0dXJuIGZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICBleHBlY3QoJy4nKTtcbiAgcmV0dXJuIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvbXB1dGVkTWVtYmVyKCkge1xuICBleHBlY3QoJ1snKTtcbiAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICBleHBlY3QoJ10nKTtcbiAgcmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpIHtcbiAgdmFyIGV4cHIsIGFyZ3MsIHByb3BlcnR5O1xuICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gIGZvciAoOzspIHtcbiAgICBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICBleHByID0gZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgZXhwciA9IGZpbmlzaENhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICBleHByID0gZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHI7XG59IC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG5cbmZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gIGNvbnN0IGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKTtcblxuICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuUHVuY3R1YXRvcikge1xuICAgIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKERJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn0gLy8gMTEuNCBVbmFyeSBPcGVyYXRvcnNcblxuXG5mdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgdmFyIHRva2VuLCBleHByO1xuXG4gIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbktleXdvcmQpIHtcbiAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICB9IGVsc2UgaWYgKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKERJU0FCTEVEKTtcbiAgfSBlbHNlIGlmIChtYXRjaCgnKycpIHx8IG1hdGNoKCctJykgfHwgbWF0Y2goJ34nKSB8fCBtYXRjaCgnIScpKSB7XG4gICAgdG9rZW4gPSBsZXgoKTtcbiAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICBleHByID0gZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpO1xuICB9IGVsc2Uge1xuICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbikge1xuICBsZXQgcHJlYyA9IDA7XG5cbiAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuUHVuY3R1YXRvciAmJiB0b2tlbi50eXBlICE9PSBUb2tlbktleXdvcmQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICBjYXNlICd8fCc6XG4gICAgICBwcmVjID0gMTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnJiYnOlxuICAgICAgcHJlYyA9IDI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3wnOlxuICAgICAgcHJlYyA9IDM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ14nOlxuICAgICAgcHJlYyA9IDQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJyYnOlxuICAgICAgcHJlYyA9IDU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJz09JzpcbiAgICBjYXNlICchPSc6XG4gICAgY2FzZSAnPT09JzpcbiAgICBjYXNlICchPT0nOlxuICAgICAgcHJlYyA9IDY7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJzwnOlxuICAgIGNhc2UgJz4nOlxuICAgIGNhc2UgJzw9JzpcbiAgICBjYXNlICc+PSc6XG4gICAgY2FzZSAnaW5zdGFuY2VvZic6XG4gICAgY2FzZSAnaW4nOlxuICAgICAgcHJlYyA9IDc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJzw8JzpcbiAgICBjYXNlICc+Pic6XG4gICAgY2FzZSAnPj4+JzpcbiAgICAgIHByZWMgPSA4O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICcrJzpcbiAgICBjYXNlICctJzpcbiAgICAgIHByZWMgPSA5O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICcqJzpcbiAgICBjYXNlICcvJzpcbiAgICBjYXNlICclJzpcbiAgICAgIHByZWMgPSAxMTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHByZWM7XG59IC8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG4vLyAxMS42IEFkZGl0aXZlIE9wZXJhdG9yc1xuLy8gMTEuNyBCaXR3aXNlIFNoaWZ0IE9wZXJhdG9yc1xuLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuLy8gMTEuOSBFcXVhbGl0eSBPcGVyYXRvcnNcbi8vIDExLjEwIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXG5cblxuZnVuY3Rpb24gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCkge1xuICB2YXIgbWFya2VyLCBtYXJrZXJzLCBleHByLCB0b2tlbiwgcHJlYywgc3RhY2ssIHJpZ2h0LCBvcGVyYXRvciwgbGVmdCwgaTtcbiAgbWFya2VyID0gbG9va2FoZWFkO1xuICBsZWZ0ID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gIHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKHRva2VuKTtcblxuICBpZiAocHJlYyA9PT0gMCkge1xuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgdG9rZW4ucHJlYyA9IHByZWM7XG4gIGxleCgpO1xuICBtYXJrZXJzID0gW21hcmtlciwgbG9va2FoZWFkXTtcbiAgcmlnaHQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xuXG4gIHdoaWxlICgocHJlYyA9IGJpbmFyeVByZWNlZGVuY2UobG9va2FoZWFkKSkgPiAwKSB7XG4gICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyICYmIHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykge1xuICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgIG9wZXJhdG9yID0gc3RhY2sucG9wKCkudmFsdWU7XG4gICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG4gICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgZXhwciA9IGZpbmlzaEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgfSAvLyBTaGlmdC5cblxuXG4gICAgdG9rZW4gPSBsZXgoKTtcbiAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICBtYXJrZXJzLnB1c2gobG9va2FoZWFkKTtcbiAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICBzdGFjay5wdXNoKGV4cHIpO1xuICB9IC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG5cblxuICBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgZXhwciA9IHN0YWNrW2ldO1xuICBtYXJrZXJzLnBvcCgpO1xuXG4gIHdoaWxlIChpID4gMSkge1xuICAgIG1hcmtlcnMucG9wKCk7XG4gICAgZXhwciA9IGZpbmlzaEJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIGV4cHIpO1xuICAgIGkgLT0gMjtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufSAvLyAxMS4xMiBDb25kaXRpb25hbCBPcGVyYXRvclxuXG5cbmZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICB2YXIgZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlO1xuICBleHByID0gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgaWYgKG1hdGNoKCc/JykpIHtcbiAgICBsZXgoKTtcbiAgICBjb25zZXF1ZW50ID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICBleHBlY3QoJzonKTtcbiAgICBhbHRlcm5hdGUgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuICAgIGV4cHIgPSBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufSAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgY29uc3QgZXhwciA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpOyAvLyBubyBzZXF1ZW5jZSBleHByZXNzaW9uc1xuICB9XG5cbiAgcmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIHBhcnNlciAoY29kZSkge1xuICBzb3VyY2UgPSBjb2RlO1xuICBpbmRleCA9IDA7XG4gIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gIGxvb2thaGVhZCA9IG51bGw7XG4gIHBlZWsoKTtcbiAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW5FT0YpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0IHRva2VuIGFmdGVyIGV4cHJlc3Npb24uJyk7XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn1cblxudmFyIENvbnN0YW50cyA9IHtcbiAgTmFOOiAnTmFOJyxcbiAgRTogJ01hdGguRScsXG4gIExOMjogJ01hdGguTE4yJyxcbiAgTE4xMDogJ01hdGguTE4xMCcsXG4gIExPRzJFOiAnTWF0aC5MT0cyRScsXG4gIExPRzEwRTogJ01hdGguTE9HMTBFJyxcbiAgUEk6ICdNYXRoLlBJJyxcbiAgU1FSVDFfMjogJ01hdGguU1FSVDFfMicsXG4gIFNRUlQyOiAnTWF0aC5TUVJUMicsXG4gIE1JTl9WQUxVRTogJ051bWJlci5NSU5fVkFMVUUnLFxuICBNQVhfVkFMVUU6ICdOdW1iZXIuTUFYX1ZBTFVFJ1xufTtcblxuZnVuY3Rpb24gRnVuY3Rpb25zIChjb2RlZ2VuKSB7XG4gIGZ1bmN0aW9uIGZuY2FsbChuYW1lLCBhcmdzLCBjYXN0LCB0eXBlKSB7XG4gICAgbGV0IG9iaiA9IGNvZGVnZW4oYXJnc1swXSk7XG5cbiAgICBpZiAoY2FzdCkge1xuICAgICAgb2JqID0gY2FzdCArICcoJyArIG9iaiArICcpJztcbiAgICAgIGlmIChjYXN0Lmxhc3RJbmRleE9mKCduZXcgJywgMCkgPT09IDApIG9iaiA9ICcoJyArIG9iaiArICcpJztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqICsgJy4nICsgbmFtZSArICh0eXBlIDwgMCA/ICcnIDogdHlwZSA9PT0gMCA/ICcoKScgOiAnKCcgKyBhcmdzLnNsaWNlKDEpLm1hcChjb2RlZ2VuKS5qb2luKCcsJykgKyAnKScpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4obmFtZSwgY2FzdCwgdHlwZSkge1xuICAgIHJldHVybiBhcmdzID0+IGZuY2FsbChuYW1lLCBhcmdzLCBjYXN0LCB0eXBlKTtcbiAgfVxuXG4gIGNvbnN0IERBVEUgPSAnbmV3IERhdGUnLFxuICAgICAgICBTVFJJTkcgPSAnU3RyaW5nJyxcbiAgICAgICAgUkVHRVhQID0gJ1JlZ0V4cCc7XG4gIHJldHVybiB7XG4gICAgLy8gTUFUSCBmdW5jdGlvbnNcbiAgICBpc05hTjogJ051bWJlci5pc05hTicsXG4gICAgaXNGaW5pdGU6ICdOdW1iZXIuaXNGaW5pdGUnLFxuICAgIGFiczogJ01hdGguYWJzJyxcbiAgICBhY29zOiAnTWF0aC5hY29zJyxcbiAgICBhc2luOiAnTWF0aC5hc2luJyxcbiAgICBhdGFuOiAnTWF0aC5hdGFuJyxcbiAgICBhdGFuMjogJ01hdGguYXRhbjInLFxuICAgIGNlaWw6ICdNYXRoLmNlaWwnLFxuICAgIGNvczogJ01hdGguY29zJyxcbiAgICBleHA6ICdNYXRoLmV4cCcsXG4gICAgZmxvb3I6ICdNYXRoLmZsb29yJyxcbiAgICBsb2c6ICdNYXRoLmxvZycsXG4gICAgbWF4OiAnTWF0aC5tYXgnLFxuICAgIG1pbjogJ01hdGgubWluJyxcbiAgICBwb3c6ICdNYXRoLnBvdycsXG4gICAgcmFuZG9tOiAnTWF0aC5yYW5kb20nLFxuICAgIHJvdW5kOiAnTWF0aC5yb3VuZCcsXG4gICAgc2luOiAnTWF0aC5zaW4nLFxuICAgIHNxcnQ6ICdNYXRoLnNxcnQnLFxuICAgIHRhbjogJ01hdGgudGFuJyxcbiAgICBjbGFtcDogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpIGVycm9yKCdNaXNzaW5nIGFyZ3VtZW50cyB0byBjbGFtcCBmdW5jdGlvbi4nKTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpIGVycm9yKCdUb28gbWFueSBhcmd1bWVudHMgdG8gY2xhbXAgZnVuY3Rpb24uJyk7XG4gICAgICBjb25zdCBhID0gYXJncy5tYXAoY29kZWdlbik7XG4gICAgICByZXR1cm4gJ01hdGgubWF4KCcgKyBhWzFdICsgJywgTWF0aC5taW4oJyArIGFbMl0gKyAnLCcgKyBhWzBdICsgJykpJztcbiAgICB9LFxuICAgIC8vIERBVEUgZnVuY3Rpb25zXG4gICAgbm93OiAnRGF0ZS5ub3cnLFxuICAgIHV0YzogJ0RhdGUuVVRDJyxcbiAgICBkYXRldGltZTogREFURSxcbiAgICBkYXRlOiBmbignZ2V0RGF0ZScsIERBVEUsIDApLFxuICAgIGRheTogZm4oJ2dldERheScsIERBVEUsIDApLFxuICAgIHllYXI6IGZuKCdnZXRGdWxsWWVhcicsIERBVEUsIDApLFxuICAgIG1vbnRoOiBmbignZ2V0TW9udGgnLCBEQVRFLCAwKSxcbiAgICBob3VyczogZm4oJ2dldEhvdXJzJywgREFURSwgMCksXG4gICAgbWludXRlczogZm4oJ2dldE1pbnV0ZXMnLCBEQVRFLCAwKSxcbiAgICBzZWNvbmRzOiBmbignZ2V0U2Vjb25kcycsIERBVEUsIDApLFxuICAgIG1pbGxpc2Vjb25kczogZm4oJ2dldE1pbGxpc2Vjb25kcycsIERBVEUsIDApLFxuICAgIHRpbWU6IGZuKCdnZXRUaW1lJywgREFURSwgMCksXG4gICAgdGltZXpvbmVvZmZzZXQ6IGZuKCdnZXRUaW1lem9uZU9mZnNldCcsIERBVEUsIDApLFxuICAgIHV0Y2RhdGU6IGZuKCdnZXRVVENEYXRlJywgREFURSwgMCksXG4gICAgdXRjZGF5OiBmbignZ2V0VVRDRGF5JywgREFURSwgMCksXG4gICAgdXRjeWVhcjogZm4oJ2dldFVUQ0Z1bGxZZWFyJywgREFURSwgMCksXG4gICAgdXRjbW9udGg6IGZuKCdnZXRVVENNb250aCcsIERBVEUsIDApLFxuICAgIHV0Y2hvdXJzOiBmbignZ2V0VVRDSG91cnMnLCBEQVRFLCAwKSxcbiAgICB1dGNtaW51dGVzOiBmbignZ2V0VVRDTWludXRlcycsIERBVEUsIDApLFxuICAgIHV0Y3NlY29uZHM6IGZuKCdnZXRVVENTZWNvbmRzJywgREFURSwgMCksXG4gICAgdXRjbWlsbGlzZWNvbmRzOiBmbignZ2V0VVRDTWlsbGlzZWNvbmRzJywgREFURSwgMCksXG4gICAgLy8gc2VxdWVuY2UgZnVuY3Rpb25zXG4gICAgbGVuZ3RoOiBmbignbGVuZ3RoJywgbnVsbCwgLTEpLFxuICAgIC8vIFNUUklORyBmdW5jdGlvbnNcbiAgICBwYXJzZUZsb2F0OiAncGFyc2VGbG9hdCcsXG4gICAgcGFyc2VJbnQ6ICdwYXJzZUludCcsXG4gICAgdXBwZXI6IGZuKCd0b1VwcGVyQ2FzZScsIFNUUklORywgMCksXG4gICAgbG93ZXI6IGZuKCd0b0xvd2VyQ2FzZScsIFNUUklORywgMCksXG4gICAgc3Vic3RyaW5nOiBmbignc3Vic3RyaW5nJywgU1RSSU5HKSxcbiAgICBzcGxpdDogZm4oJ3NwbGl0JywgU1RSSU5HKSxcbiAgICB0cmltOiBmbigndHJpbScsIFNUUklORywgMCksXG4gICAgLy8gUkVHRVhQIGZ1bmN0aW9uc1xuICAgIHJlZ2V4cDogUkVHRVhQLFxuICAgIHRlc3Q6IGZuKCd0ZXN0JywgUkVHRVhQKSxcbiAgICAvLyBDb250cm9sIEZsb3cgZnVuY3Rpb25zXG4gICAgaWY6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSBlcnJvcignTWlzc2luZyBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uJyk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSBlcnJvcignVG9vIG1hbnkgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLicpO1xuICAgICAgY29uc3QgYSA9IGFyZ3MubWFwKGNvZGVnZW4pO1xuICAgICAgcmV0dXJuICcoJyArIGFbMF0gKyAnPycgKyBhWzFdICsgJzonICsgYVsyXSArICcpJztcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmlwUXVvdGVzKHMpIHtcbiAgY29uc3QgbiA9IHMgJiYgcy5sZW5ndGggLSAxO1xuICByZXR1cm4gbiAmJiAoc1swXSA9PT0gJ1wiJyAmJiBzW25dID09PSAnXCInIHx8IHNbMF0gPT09ICdcXCcnICYmIHNbbl0gPT09ICdcXCcnKSA/IHMuc2xpY2UoMSwgLTEpIDogcztcbn1cblxuZnVuY3Rpb24gY29kZWdlbiAob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgY29uc3QgYWxsb3dlZCA9IG9wdC5hbGxvd2VkID8gdG9TZXQob3B0LmFsbG93ZWQpIDoge30sXG4gICAgICAgIGZvcmJpZGRlbiA9IG9wdC5mb3JiaWRkZW4gPyB0b1NldChvcHQuZm9yYmlkZGVuKSA6IHt9LFxuICAgICAgICBjb25zdGFudHMgPSBvcHQuY29uc3RhbnRzIHx8IENvbnN0YW50cyxcbiAgICAgICAgZnVuY3Rpb25zID0gKG9wdC5mdW5jdGlvbnMgfHwgRnVuY3Rpb25zKSh2aXNpdCksXG4gICAgICAgIGdsb2JhbHZhciA9IG9wdC5nbG9iYWx2YXIsXG4gICAgICAgIGZpZWxkdmFyID0gb3B0LmZpZWxkdmFyLFxuICAgICAgICBvdXRwdXRHbG9iYWwgPSBpc0Z1bmN0aW9uKGdsb2JhbHZhcikgPyBnbG9iYWx2YXIgOiBpZCA9PiBgJHtnbG9iYWx2YXJ9W1wiJHtpZH1cIl1gO1xuICBsZXQgZ2xvYmFscyA9IHt9LFxuICAgICAgZmllbGRzID0ge30sXG4gICAgICBtZW1iZXJEZXB0aCA9IDA7XG5cbiAgZnVuY3Rpb24gdmlzaXQoYXN0KSB7XG4gICAgaWYgKGlzU3RyaW5nKGFzdCkpIHJldHVybiBhc3Q7XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gR2VuZXJhdG9yc1thc3QudHlwZV07XG4gICAgaWYgKGdlbmVyYXRvciA9PSBudWxsKSBlcnJvcignVW5zdXBwb3J0ZWQgdHlwZTogJyArIGFzdC50eXBlKTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yKGFzdCk7XG4gIH1cblxuICBjb25zdCBHZW5lcmF0b3JzID0ge1xuICAgIExpdGVyYWw6IG4gPT4gbi5yYXcsXG4gICAgSWRlbnRpZmllcjogbiA9PiB7XG4gICAgICBjb25zdCBpZCA9IG4ubmFtZTtcblxuICAgICAgaWYgKG1lbWJlckRlcHRoID4gMCkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGZvcmJpZGRlbiwgaWQpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcignSWxsZWdhbCBpZGVudGlmaWVyOiAnICsgaWQpO1xuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShjb25zdGFudHMsIGlkKSkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnRzW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoYWxsb3dlZCwgaWQpKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbHNbaWRdID0gMTtcbiAgICAgICAgcmV0dXJuIG91dHB1dEdsb2JhbChpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBNZW1iZXJFeHByZXNzaW9uOiBuID0+IHtcbiAgICAgIGNvbnN0IGQgPSAhbi5jb21wdXRlZCxcbiAgICAgICAgICAgIG8gPSB2aXNpdChuLm9iamVjdCk7XG4gICAgICBpZiAoZCkgbWVtYmVyRGVwdGggKz0gMTtcbiAgICAgIGNvbnN0IHAgPSB2aXNpdChuLnByb3BlcnR5KTtcblxuICAgICAgaWYgKG8gPT09IGZpZWxkdmFyKSB7XG4gICAgICAgIC8vIHN0cmlwIHF1b3RlcyB0byBzYW5pdGl6ZSBmaWVsZCBuYW1lICgjMTY1MylcbiAgICAgICAgZmllbGRzW3N0cmlwUXVvdGVzKHApXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgcmV0dXJuIG8gKyAoZCA/ICcuJyArIHAgOiAnWycgKyBwICsgJ10nKTtcbiAgICB9LFxuICAgIENhbGxFeHByZXNzaW9uOiBuID0+IHtcbiAgICAgIGlmIChuLmNhbGxlZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgZXJyb3IoJ0lsbGVnYWwgY2FsbGVlIHR5cGU6ICcgKyBuLmNhbGxlZS50eXBlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FsbGVlID0gbi5jYWxsZWUubmFtZSxcbiAgICAgICAgICAgIGFyZ3MgPSBuLmFyZ3VtZW50cyxcbiAgICAgICAgICAgIGZuID0gaGFzT3duUHJvcGVydHkoZnVuY3Rpb25zLCBjYWxsZWUpICYmIGZ1bmN0aW9uc1tjYWxsZWVdO1xuICAgICAgaWYgKCFmbikgZXJyb3IoJ1VucmVjb2duaXplZCBmdW5jdGlvbjogJyArIGNhbGxlZSk7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihmbikgPyBmbihhcmdzKSA6IGZuICsgJygnICsgYXJncy5tYXAodmlzaXQpLmpvaW4oJywnKSArICcpJztcbiAgICB9LFxuICAgIEFycmF5RXhwcmVzc2lvbjogbiA9PiAnWycgKyBuLmVsZW1lbnRzLm1hcCh2aXNpdCkuam9pbignLCcpICsgJ10nLFxuICAgIEJpbmFyeUV4cHJlc3Npb246IG4gPT4gJygnICsgdmlzaXQobi5sZWZ0KSArICcgJyArIG4ub3BlcmF0b3IgKyAnICcgKyB2aXNpdChuLnJpZ2h0KSArICcpJyxcbiAgICBVbmFyeUV4cHJlc3Npb246IG4gPT4gJygnICsgbi5vcGVyYXRvciArIHZpc2l0KG4uYXJndW1lbnQpICsgJyknLFxuICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogbiA9PiAnKCcgKyB2aXNpdChuLnRlc3QpICsgJz8nICsgdmlzaXQobi5jb25zZXF1ZW50KSArICc6JyArIHZpc2l0KG4uYWx0ZXJuYXRlKSArICcpJyxcbiAgICBMb2dpY2FsRXhwcmVzc2lvbjogbiA9PiAnKCcgKyB2aXNpdChuLmxlZnQpICsgbi5vcGVyYXRvciArIHZpc2l0KG4ucmlnaHQpICsgJyknLFxuICAgIE9iamVjdEV4cHJlc3Npb246IG4gPT4gJ3snICsgbi5wcm9wZXJ0aWVzLm1hcCh2aXNpdCkuam9pbignLCcpICsgJ30nLFxuICAgIFByb3BlcnR5OiBuID0+IHtcbiAgICAgIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICBjb25zdCBrID0gdmlzaXQobi5rZXkpO1xuICAgICAgbWVtYmVyRGVwdGggLT0gMTtcbiAgICAgIHJldHVybiBrICsgJzonICsgdmlzaXQobi52YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvZGVnZW4oYXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgY29kZTogdmlzaXQoYXN0KSxcbiAgICAgIGdsb2JhbHM6IE9iamVjdC5rZXlzKGdsb2JhbHMpLFxuICAgICAgZmllbGRzOiBPYmplY3Qua2V5cyhmaWVsZHMpXG4gICAgfTtcbiAgICBnbG9iYWxzID0ge307XG4gICAgZmllbGRzID0ge307XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNvZGVnZW4uZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICBjb2RlZ2VuLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiAgcmV0dXJuIGNvZGVnZW47XG59XG5cbmV4cG9ydCB7IEFTVE5vZGUsIEFycmF5RXhwcmVzc2lvbiwgQmluYXJ5RXhwcmVzc2lvbiwgQ2FsbEV4cHJlc3Npb24sIENvbmRpdGlvbmFsRXhwcmVzc2lvbiwgSWRlbnRpZmllciwgTGl0ZXJhbCwgTG9naWNhbEV4cHJlc3Npb24sIE1lbWJlckV4cHJlc3Npb24sIE9iamVjdEV4cHJlc3Npb24sIFByb3BlcnR5LCBSYXdDb2RlLCBVbmFyeUV4cHJlc3Npb24sIGNvZGVnZW4gYXMgY29kZWdlbkV4cHJlc3Npb24sIENvbnN0YW50cyBhcyBjb25zdGFudHMsIEZ1bmN0aW9ucyBhcyBmdW5jdGlvbnMsIHBhcnNlciBhcyBwYXJzZUV4cHJlc3Npb24gfTtcbiIsImltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGFycmF5LCBpc0Z1bmN0aW9uLCBhY2Nlc3NvckZpZWxkcywgaGFzT3duUHJvcGVydHksIGVycm9yIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGZvcmNlU2ltdWxhdGlvbiwgZm9yY2VDZW50ZXIsIGZvcmNlQ29sbGlkZSwgZm9yY2VNYW55Qm9keSwgZm9yY2VMaW5rLCBmb3JjZVgsIGZvcmNlWSB9IGZyb20gJ2QzLWZvcmNlJztcblxuY29uc3QgRm9yY2VNYXAgPSB7XG4gIGNlbnRlcjogZm9yY2VDZW50ZXIsXG4gIGNvbGxpZGU6IGZvcmNlQ29sbGlkZSxcbiAgbmJvZHk6IGZvcmNlTWFueUJvZHksXG4gIGxpbms6IGZvcmNlTGluayxcbiAgeDogZm9yY2VYLFxuICB5OiBmb3JjZVlcbn07XG5jb25zdCBGb3JjZXMgPSAnZm9yY2VzJyxcbiAgICAgIEZvcmNlUGFyYW1zID0gWydhbHBoYScsICdhbHBoYU1pbicsICdhbHBoYVRhcmdldCcsICd2ZWxvY2l0eURlY2F5JywgJ2ZvcmNlcyddLFxuICAgICAgRm9yY2VDb25maWcgPSBbJ3N0YXRpYycsICdpdGVyYXRpb25zJ10sXG4gICAgICBGb3JjZU91dHB1dCA9IFsneCcsICd5JywgJ3Z4JywgJ3Z5J107XG4vKipcbiAqIEZvcmNlIHNpbXVsYXRpb24gbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IHBhcmFtcy5mb3JjZXMgLSBUaGUgZm9yY2VzIHRvIGFwcGx5LlxuICovXG5cbmZ1bmN0aW9uIEZvcmNlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuRm9yY2UuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnRm9yY2UnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzdGF0aWMnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ3Jlc3RhcnQnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2l0ZXJhdGlvbnMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAzMDBcbiAgfSwge1xuICAgICduYW1lJzogJ2FscGhhJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYWxwaGFNaW4nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwLjAwMVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYWxwaGFUYXJnZXQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd2ZWxvY2l0eURlY2F5JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMC40XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb3JjZXMnLFxuICAgICd0eXBlJzogJ3BhcmFtJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdwYXJhbXMnOiBbe1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ2NlbnRlcidcbiAgICAgIH0sXG4gICAgICAncGFyYW1zJzogW3tcbiAgICAgICAgJ25hbWUnOiAneCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMFxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICd5JyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAwXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgICdrZXknOiB7XG4gICAgICAgICdmb3JjZSc6ICdjb2xsaWRlJ1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICdyYWRpdXMnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZXhwcic6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAnc3RyZW5ndGgnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDAuN1xuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdpdGVyYXRpb25zJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAxXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgICdrZXknOiB7XG4gICAgICAgICdmb3JjZSc6ICduYm9keSdcbiAgICAgIH0sXG4gICAgICAncGFyYW1zJzogW3tcbiAgICAgICAgJ25hbWUnOiAnc3RyZW5ndGgnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IC0zMFxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICd0aGV0YScsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMC45XG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ2Rpc3RhbmNlTWluJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAxXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ2Rpc3RhbmNlTWF4JyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAna2V5Jzoge1xuICAgICAgICAnZm9yY2UnOiAnbGluaydcbiAgICAgIH0sXG4gICAgICAncGFyYW1zJzogW3tcbiAgICAgICAgJ25hbWUnOiAnbGlua3MnLFxuICAgICAgICAndHlwZSc6ICdkYXRhJ1xuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdpZCcsXG4gICAgICAgICd0eXBlJzogJ2ZpZWxkJ1xuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdkaXN0YW5jZScsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMzAsXG4gICAgICAgICdleHByJzogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdzdHJlbmd0aCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdleHByJzogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdpdGVyYXRpb25zJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAxXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgICdrZXknOiB7XG4gICAgICAgICdmb3JjZSc6ICd4J1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICdzdHJlbmd0aCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMC4xXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ3gnLFxuICAgICAgICAndHlwZSc6ICdmaWVsZCdcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ3knXG4gICAgICB9LFxuICAgICAgJ3BhcmFtcyc6IFt7XG4gICAgICAgICduYW1lJzogJ3N0cmVuZ3RoJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAwLjFcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAneScsXG4gICAgICAgICd0eXBlJzogJ2ZpZWxkJ1xuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbW9kaWZ5JzogZmFsc2UsXG4gICAgJ2RlZmF1bHQnOiBGb3JjZU91dHB1dFxuICB9XVxufTtcbmluaGVyaXRzKEZvcmNlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIHNpbSA9IHRoaXMudmFsdWUsXG4gICAgICAgIGNoYW5nZSA9IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSksXG4gICAgICAgIHBhcmFtcyA9IF8ubW9kaWZpZWQoRm9yY2VQYXJhbXMpLFxuICAgICAgICBpdGVycyA9IF8uaXRlcmF0aW9ucyB8fCAzMDA7IC8vIGNvbmZpZ3VyZSBzaW11bGF0aW9uXG5cblxuICAgIGlmICghc2ltKSB7XG4gICAgICB0aGlzLnZhbHVlID0gc2ltID0gc2ltdWxhdGlvbihwdWxzZS5zb3VyY2UsIF8pO1xuICAgICAgc2ltLm9uKCd0aWNrJywgcmVydW4ocHVsc2UuZGF0YWZsb3csIHRoaXMpKTtcblxuICAgICAgaWYgKCFfLnN0YXRpYykge1xuICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICBzaW0udGljaygpOyAvLyBlbnN1cmUgd2UgcnVuIG9uIGluaXRcbiAgICAgIH1cblxuICAgICAgcHVsc2UubW9kaWZpZXMoJ2luZGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgcHVsc2UubW9kaWZpZXMoJ2luZGV4Jyk7XG4gICAgICAgIHNpbS5ub2RlcyhwdWxzZS5zb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuTU9EKSkge1xuICAgICAgICBzZXR1cChzaW0sIF8sIDAsIHB1bHNlKTtcbiAgICAgIH1cbiAgICB9IC8vIHJ1biBzaW11bGF0aW9uXG5cblxuICAgIGlmIChwYXJhbXMgfHwgY2hhbmdlIHx8IF8ubW9kaWZpZWQoRm9yY2VDb25maWcpIHx8IHB1bHNlLmNoYW5nZWQoKSAmJiBfLnJlc3RhcnQpIHtcbiAgICAgIHNpbS5hbHBoYShNYXRoLm1heChzaW0uYWxwaGEoKSwgXy5hbHBoYSB8fCAxKSkuYWxwaGFEZWNheSgxIC0gTWF0aC5wb3coc2ltLmFscGhhTWluKCksIDEgLyBpdGVycykpO1xuXG4gICAgICBpZiAoXy5zdGF0aWMpIHtcbiAgICAgICAgZm9yIChzaW0uc3RvcCgpOyAtLWl0ZXJzID49IDA7KSBzaW0udGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNpbS5zdG9wcGVkKCkpIHNpbS5yZXN0YXJ0KCk7XG4gICAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uOyAvLyBkZWZlciB0byBzaW0gdGlja3NcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2goXywgcHVsc2UpO1xuICB9LFxuXG4gIGZpbmlzaChfLCBwdWxzZSkge1xuICAgIGNvbnN0IGRhdGFmbG93ID0gcHVsc2UuZGF0YWZsb3c7IC8vIGluc3BlY3QgZGVwZW5kZW5jaWVzLCB0b3VjaCBsaW5rIHNvdXJjZSBkYXRhXG5cbiAgICBmb3IgKGxldCBhcmdzID0gdGhpcy5fYXJnb3BzLCBqID0gMCwgbSA9IGFyZ3MubGVuZ3RoLCBhcmc7IGogPCBtOyArK2opIHtcbiAgICAgIGFyZyA9IGFyZ3Nbal07XG5cbiAgICAgIGlmIChhcmcubmFtZSAhPT0gRm9yY2VzIHx8IGFyZy5vcC5fYXJndmFsLmZvcmNlICE9PSAnbGluaycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG9wcyA9IGFyZy5vcC5fYXJnb3BzLCBpID0gMCwgbiA9IG9wcy5sZW5ndGgsIG9wOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChvcHNbaV0ubmFtZSA9PT0gJ2xpbmtzJyAmJiAob3AgPSBvcHNbaV0ub3Auc291cmNlKSkge1xuICAgICAgICAgIGRhdGFmbG93LnB1bHNlKG9wLCBkYXRhZmxvdy5jaGFuZ2VzZXQoKS5yZWZsb3coKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHJlZmxvdyBhbGwgbm9kZXNcblxuXG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKEZvcmNlT3V0cHV0KTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gcmVydW4oZGYsIG9wKSB7XG4gIHJldHVybiAoKSA9PiBkZi50b3VjaChvcCkucnVuKCk7XG59XG5cbmZ1bmN0aW9uIHNpbXVsYXRpb24obm9kZXMsIF8pIHtcbiAgY29uc3Qgc2ltID0gZm9yY2VTaW11bGF0aW9uKG5vZGVzKSxcbiAgICAgICAgc3RvcCA9IHNpbS5zdG9wLFxuICAgICAgICByZXN0YXJ0ID0gc2ltLnJlc3RhcnQ7XG4gIGxldCBzdG9wcGVkID0gZmFsc2U7XG5cbiAgc2ltLnN0b3BwZWQgPSAoKSA9PiBzdG9wcGVkO1xuXG4gIHNpbS5yZXN0YXJ0ID0gKCkgPT4gKHN0b3BwZWQgPSBmYWxzZSwgcmVzdGFydCgpKTtcblxuICBzaW0uc3RvcCA9ICgpID0+IChzdG9wcGVkID0gdHJ1ZSwgc3RvcCgpKTtcblxuICByZXR1cm4gc2V0dXAoc2ltLCBfLCB0cnVlKS5vbignZW5kJywgKCkgPT4gc3RvcHBlZCA9IHRydWUpO1xufVxuXG5mdW5jdGlvbiBzZXR1cChzaW0sIF8sIGluaXQsIHB1bHNlKSB7XG4gIHZhciBmID0gYXJyYXkoXy5mb3JjZXMpLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBwLFxuICAgICAgbmFtZTtcblxuICBmb3IgKGkgPSAwLCBuID0gRm9yY2VQYXJhbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgcCA9IEZvcmNlUGFyYW1zW2ldO1xuICAgIGlmIChwICE9PSBGb3JjZXMgJiYgXy5tb2RpZmllZChwKSkgc2ltW3BdKF9bcF0pO1xuICB9XG5cbiAgZm9yIChpID0gMCwgbiA9IGYubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgbmFtZSA9IEZvcmNlcyArIGk7XG4gICAgcCA9IGluaXQgfHwgXy5tb2RpZmllZChGb3JjZXMsIGkpID8gZ2V0Rm9yY2UoZltpXSkgOiBwdWxzZSAmJiBtb2RpZmllZChmW2ldLCBwdWxzZSkgPyBzaW0uZm9yY2UobmFtZSkgOiBudWxsO1xuICAgIGlmIChwKSBzaW0uZm9yY2UobmFtZSwgcCk7XG4gIH1cblxuICBmb3IgKG4gPSBzaW0ubnVtRm9yY2VzIHx8IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzaW0uZm9yY2UoRm9yY2VzICsgaSwgbnVsbCk7IC8vIHJlbW92ZVxuICB9XG5cbiAgc2ltLm51bUZvcmNlcyA9IGYubGVuZ3RoO1xuICByZXR1cm4gc2ltO1xufVxuXG5mdW5jdGlvbiBtb2RpZmllZChmLCBwdWxzZSkge1xuICB2YXIgaywgdjtcblxuICBmb3IgKGsgaW4gZikge1xuICAgIGlmIChpc0Z1bmN0aW9uKHYgPSBmW2tdKSAmJiBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyh2KSkpIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGdldEZvcmNlKF8pIHtcbiAgdmFyIGYsIHA7XG5cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShGb3JjZU1hcCwgXy5mb3JjZSkpIHtcbiAgICBlcnJvcignVW5yZWNvZ25pemVkIGZvcmNlOiAnICsgXy5mb3JjZSk7XG4gIH1cblxuICBmID0gRm9yY2VNYXBbXy5mb3JjZV0oKTtcblxuICBmb3IgKHAgaW4gXykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGZbcF0pKSBzZXRGb3JjZVBhcmFtKGZbcF0sIF9bcF0sIF8pO1xuICB9XG5cbiAgcmV0dXJuIGY7XG59XG5cbmZ1bmN0aW9uIHNldEZvcmNlUGFyYW0oZiwgdiwgXykge1xuICBmKGlzRnVuY3Rpb24odikgPyBkID0+IHYoZCwgXykgOiB2KTtcbn1cblxuZXhwb3J0IHsgRm9yY2UgYXMgZm9yY2UgfTtcbiIsImltcG9ydCB7IHRpY2tTdGVwIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgZm9ybWF0U3BlY2lmaWVyLCBwcmVjaXNpb25GaXhlZCwgcHJlY2lzaW9uUm91bmQsIHByZWNpc2lvblByZWZpeCwgZm9ybWF0TG9jYWxlLCBmb3JtYXQsIGZvcm1hdFByZWZpeCB9IGZyb20gJ2QzLWZvcm1hdCc7XG5pbXBvcnQgeyBTRUNPTkRTLCBNSU5VVEVTLCBIT1VSUywgREFURSwgV0VFSywgTU9OVEgsIFFVQVJURVIsIFlFQVIsIE1JTExJU0VDT05EUywgREFZLCB0aW1lSW50ZXJ2YWwsIHV0Y0ludGVydmFsIH0gZnJvbSAndmVnYS10aW1lJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc09iamVjdCwgZXJyb3IsIGV4dGVuZCB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyB0aW1lRm9ybWF0LCB0aW1lUGFyc2UsIHV0Y0Zvcm1hdCwgdXRjUGFyc2UsIHRpbWVGb3JtYXRMb2NhbGUgYXMgdGltZUZvcm1hdExvY2FsZSQxIH0gZnJvbSAnZDMtdGltZS1mb3JtYXQnO1xuXG5mdW5jdGlvbiBtZW1vaXplIChtZXRob2QpIHtcbiAgY29uc3QgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIHNwZWMgPT4gY2FjaGVbc3BlY10gfHwgKGNhY2hlW3NwZWNdID0gbWV0aG9kKHNwZWMpKTtcbn1cblxuZnVuY3Rpb24gdHJpbVplcm9lcyhudW1iZXJGb3JtYXQsIGRlY2ltYWxDaGFyKSB7XG4gIHJldHVybiB4ID0+IHtcbiAgICBjb25zdCBzdHIgPSBudW1iZXJGb3JtYXQoeCksXG4gICAgICAgICAgZGVjID0gc3RyLmluZGV4T2YoZGVjaW1hbENoYXIpO1xuICAgIGlmIChkZWMgPCAwKSByZXR1cm4gc3RyO1xuICAgIGxldCBpZHggPSByaWdodG1vc3REaWdpdChzdHIsIGRlYyk7XG4gICAgY29uc3QgZW5kID0gaWR4IDwgc3RyLmxlbmd0aCA/IHN0ci5zbGljZShpZHgpIDogJyc7XG5cbiAgICB3aGlsZSAoLS1pZHggPiBkZWMpIGlmIChzdHJbaWR4XSAhPT0gJzAnKSB7XG4gICAgICArK2lkeDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgaWR4KSArIGVuZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmlnaHRtb3N0RGlnaXQoc3RyLCBkZWMpIHtcbiAgbGV0IGkgPSBzdHIubGFzdEluZGV4T2YoJ2UnKSxcbiAgICAgIGM7XG4gIGlmIChpID4gMCkgcmV0dXJuIGk7XG5cbiAgZm9yIChpID0gc3RyLmxlbmd0aDsgLS1pID4gZGVjOykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSByZXR1cm4gaSArIDE7IC8vIGlzIGRpZ2l0XG4gIH1cbn1cblxuZnVuY3Rpb24gbnVtYmVyTG9jYWxlKGxvY2FsZSkge1xuICBjb25zdCBmb3JtYXQgPSBtZW1vaXplKGxvY2FsZS5mb3JtYXQpLFxuICAgICAgICBmb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4ge1xuICAgIGZvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXgsXG5cbiAgICBmb3JtYXRGbG9hdChzcGVjKSB7XG4gICAgICBjb25zdCBzID0gZm9ybWF0U3BlY2lmaWVyKHNwZWMgfHwgJywnKTtcblxuICAgICAgaWYgKHMucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgcy5wcmVjaXNpb24gPSAxMjtcblxuICAgICAgICBzd2l0Y2ggKHMudHlwZSkge1xuICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcy5wcmVjaXNpb24gLT0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICBzLnByZWNpc2lvbiAtPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJpbVplcm9lcyhmb3JtYXQocyksIC8vIG51bWJlciBmb3JtYXRcbiAgICAgICAgZm9ybWF0KCcuMWYnKSgxKVsxXSAvLyBkZWNpbWFsIHBvaW50IGNoYXJhY3RlclxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdChzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZm9ybWF0U3BhbihzdGFydCwgc3RvcCwgY291bnQsIHNwZWNpZmllcikge1xuICAgICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gJyxmJyA6IHNwZWNpZmllcik7XG4gICAgICBjb25zdCBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICBsZXQgcHJlY2lzaW9uO1xuXG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25Sb3VuZChzdGVwLCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gJ2UnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uRml4ZWQoc3RlcCkpKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gJyUnKSAqIDI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9ybWF0KHNwZWNpZmllcik7XG4gICAgfVxuXG4gIH07XG59XG5cbmxldCBkZWZhdWx0TnVtYmVyTG9jYWxlO1xucmVzZXROdW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG5mdW5jdGlvbiByZXNldE51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoKSB7XG4gIHJldHVybiBkZWZhdWx0TnVtYmVyTG9jYWxlID0gbnVtYmVyTG9jYWxlKHtcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICB9KTtcbn1cbmZ1bmN0aW9uIG51bWJlckZvcm1hdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIHJldHVybiBudW1iZXJMb2NhbGUoZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pKTtcbn1cbmZ1bmN0aW9uIG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRlZmF1bHROdW1iZXJMb2NhbGUgPSBudW1iZXJGb3JtYXRMb2NhbGUoZGVmaW5pdGlvbikgOiBkZWZhdWx0TnVtYmVyTG9jYWxlO1xufVxuXG5mdW5jdGlvbiB0aW1lTXVsdGlGb3JtYXQoZm9ybWF0LCBpbnRlcnZhbCwgc3BlYykge1xuICBzcGVjID0gc3BlYyB8fCB7fTtcblxuICBpZiAoIWlzT2JqZWN0KHNwZWMpKSB7XG4gICAgZXJyb3IoXCJJbnZhbGlkIHRpbWUgbXVsdGktZm9ybWF0IHNwZWNpZmllcjogXCIuY29uY2F0KHNwZWMpKTtcbiAgfVxuXG4gIGNvbnN0IHNlY29uZCA9IGludGVydmFsKFNFQ09ORFMpLFxuICAgICAgICBtaW51dGUgPSBpbnRlcnZhbChNSU5VVEVTKSxcbiAgICAgICAgaG91ciA9IGludGVydmFsKEhPVVJTKSxcbiAgICAgICAgZGF5ID0gaW50ZXJ2YWwoREFURSksXG4gICAgICAgIHdlZWsgPSBpbnRlcnZhbChXRUVLKSxcbiAgICAgICAgbW9udGggPSBpbnRlcnZhbChNT05USCksXG4gICAgICAgIHF1YXJ0ZXIgPSBpbnRlcnZhbChRVUFSVEVSKSxcbiAgICAgICAgeWVhciA9IGludGVydmFsKFlFQVIpLFxuICAgICAgICBMID0gZm9ybWF0KHNwZWNbTUlMTElTRUNPTkRTXSB8fCAnLiVMJyksXG4gICAgICAgIFMgPSBmb3JtYXQoc3BlY1tTRUNPTkRTXSB8fCAnOiVTJyksXG4gICAgICAgIE0gPSBmb3JtYXQoc3BlY1tNSU5VVEVTXSB8fCAnJUk6JU0nKSxcbiAgICAgICAgSCA9IGZvcm1hdChzcGVjW0hPVVJTXSB8fCAnJUkgJXAnKSxcbiAgICAgICAgZCA9IGZvcm1hdChzcGVjW0RBVEVdIHx8IHNwZWNbREFZXSB8fCAnJWEgJWQnKSxcbiAgICAgICAgdyA9IGZvcm1hdChzcGVjW1dFRUtdIHx8ICclYiAlZCcpLFxuICAgICAgICBtID0gZm9ybWF0KHNwZWNbTU9OVEhdIHx8ICclQicpLFxuICAgICAgICBxID0gZm9ybWF0KHNwZWNbUVVBUlRFUl0gfHwgJyVCJyksXG4gICAgICAgIHkgPSBmb3JtYXQoc3BlY1tZRUFSXSB8fCAnJVknKTtcbiAgcmV0dXJuIGRhdGUgPT4gKHNlY29uZChkYXRlKSA8IGRhdGUgPyBMIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IFMgOiBob3VyKGRhdGUpIDwgZGF0ZSA/IE0gOiBkYXkoZGF0ZSkgPCBkYXRlID8gSCA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/IHdlZWsoZGF0ZSkgPCBkYXRlID8gZCA6IHcgOiB5ZWFyKGRhdGUpIDwgZGF0ZSA/IHF1YXJ0ZXIoZGF0ZSkgPCBkYXRlID8gbSA6IHEgOiB5KShkYXRlKTtcbn1cblxuZnVuY3Rpb24gdGltZUxvY2FsZShsb2NhbGUpIHtcbiAgY29uc3QgdGltZUZvcm1hdCA9IG1lbW9pemUobG9jYWxlLmZvcm1hdCksXG4gICAgICAgIHV0Y0Zvcm1hdCA9IG1lbW9pemUobG9jYWxlLnV0Y0Zvcm1hdCk7XG4gIHJldHVybiB7XG4gICAgdGltZUZvcm1hdDogc3BlYyA9PiBpc1N0cmluZyhzcGVjKSA/IHRpbWVGb3JtYXQoc3BlYykgOiB0aW1lTXVsdGlGb3JtYXQodGltZUZvcm1hdCwgdGltZUludGVydmFsLCBzcGVjKSxcbiAgICB1dGNGb3JtYXQ6IHNwZWMgPT4gaXNTdHJpbmcoc3BlYykgPyB1dGNGb3JtYXQoc3BlYykgOiB0aW1lTXVsdGlGb3JtYXQodXRjRm9ybWF0LCB1dGNJbnRlcnZhbCwgc3BlYyksXG4gICAgdGltZVBhcnNlOiBtZW1vaXplKGxvY2FsZS5wYXJzZSksXG4gICAgdXRjUGFyc2U6IG1lbW9pemUobG9jYWxlLnV0Y1BhcnNlKVxuICB9O1xufVxuXG5sZXQgZGVmYXVsdFRpbWVMb2NhbGU7XG5yZXNldFRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG5mdW5jdGlvbiByZXNldFRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCkge1xuICByZXR1cm4gZGVmYXVsdFRpbWVMb2NhbGUgPSB0aW1lTG9jYWxlKHtcbiAgICBmb3JtYXQ6IHRpbWVGb3JtYXQsXG4gICAgcGFyc2U6IHRpbWVQYXJzZSxcbiAgICB1dGNGb3JtYXQ6IHV0Y0Zvcm1hdCxcbiAgICB1dGNQYXJzZTogdXRjUGFyc2VcbiAgfSk7XG59XG5mdW5jdGlvbiB0aW1lRm9ybWF0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHRpbWVMb2NhbGUodGltZUZvcm1hdExvY2FsZSQxKGRlZmluaXRpb24pKTtcbn1cbmZ1bmN0aW9uIHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkZWZhdWx0VGltZUxvY2FsZSA9IHRpbWVGb3JtYXRMb2NhbGUoZGVmaW5pdGlvbikgOiBkZWZhdWx0VGltZUxvY2FsZTtcbn1cblxuY29uc3QgY3JlYXRlTG9jYWxlID0gKG51bWJlciwgdGltZSkgPT4gZXh0ZW5kKHt9LCBudW1iZXIsIHRpbWUpO1xuXG5mdW5jdGlvbiBsb2NhbGUobnVtYmVyU3BlYywgdGltZVNwZWMpIHtcbiAgY29uc3QgbnVtYmVyID0gbnVtYmVyU3BlYyA/IG51bWJlckZvcm1hdExvY2FsZShudW1iZXJTcGVjKSA6IG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoKTtcbiAgY29uc3QgdGltZSA9IHRpbWVTcGVjID8gdGltZUZvcm1hdExvY2FsZSh0aW1lU3BlYykgOiB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuICByZXR1cm4gY3JlYXRlTG9jYWxlKG51bWJlciwgdGltZSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0TG9jYWxlKG51bWJlclNwZWMsIHRpbWVTcGVjKSB7XG4gIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIGlmIChhcmdzICYmIGFyZ3MgIT09IDIpIHtcbiAgICBlcnJvcignZGVmYXVsdExvY2FsZSBleHBlY3RzIGVpdGhlciB6ZXJvIG9yIHR3byBhcmd1bWVudHMuJyk7XG4gIH1cblxuICByZXR1cm4gYXJncyA/IGNyZWF0ZUxvY2FsZShudW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlKG51bWJlclNwZWMpLCB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSh0aW1lU3BlYykpIDogY3JlYXRlTG9jYWxlKG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoKSwgdGltZUZvcm1hdERlZmF1bHRMb2NhbGUoKSk7XG59XG5mdW5jdGlvbiByZXNldERlZmF1bHRMb2NhbGUoKSB7XG4gIHJlc2V0TnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuICByZXNldFRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG4gIHJldHVybiBkZWZhdWx0TG9jYWxlKCk7XG59XG5cbmV4cG9ydCB7IGRlZmF1bHRMb2NhbGUsIGxvY2FsZSwgbnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSwgbnVtYmVyRm9ybWF0TG9jYWxlLCByZXNldERlZmF1bHRMb2NhbGUsIHJlc2V0TnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSwgcmVzZXRUaW1lRm9ybWF0RGVmYXVsdExvY2FsZSwgdGltZUZvcm1hdERlZmF1bHRMb2NhbGUsIHRpbWVGb3JtYXRMb2NhbGUgfTtcbiIsImltcG9ydCB7IHRydXRoeSwgZXJyb3IsIGhhc093blByb3BlcnR5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgc3RyaW5nVmFsdWUsIGV4dGVuZCwgaXNBcnJheSwgaXNPYmplY3QsIGZpZWxkLCBwZWVrLCBpZGVudGl0eSwgYXJyYXkgYXMgYXJyYXkkMSwgaXNCb29sZWFuLCBpc0RhdGUsIGlzTnVtYmVyLCBpc1JlZ0V4cCwgdG9Cb29sZWFuLCB0b0RhdGUsIHRvTnVtYmVyLCB0b1N0cmluZywgZmx1c2gsIGxlcnAsIHBhZCwgc3BhbiwgaW5yYW5nZSwgdHJ1bmNhdGUsIHF1YXJ0ZXIsIHV0Y3F1YXJ0ZXIsIGV4dGVudCwgY2xhbXBSYW5nZSwgcGFuTGluZWFyLCBwYW5Mb2csIHBhblBvdywgcGFuU3ltbG9nLCB6b29tTGluZWFyLCB6b29tTG9nLCB6b29tUG93LCB6b29tU3ltbG9nIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IExpdGVyYWwsIGNvZGVnZW5FeHByZXNzaW9uLCBjb25zdGFudHMsIGZ1bmN0aW9ucywgcGFyc2VFeHByZXNzaW9uLCBDYWxsRXhwcmVzc2lvbiB9IGZyb20gJ3ZlZ2EtZXhwcmVzc2lvbic7XG5pbXBvcnQgeyBnZW9Cb3VuZHMgYXMgZ2VvQm91bmRzJDEsIGdlb0NlbnRyb2lkIGFzIGdlb0NlbnRyb2lkJDEsIGdlb0FyZWEgYXMgZ2VvQXJlYSQxIH0gZnJvbSAnZDMtZ2VvJztcbmltcG9ydCB7IHJnYiwgbGFiLCBoY2wsIGhzbCB9IGZyb20gJ2QzLWNvbG9yJztcbmltcG9ydCB7IGlzVHVwbGUgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGJhbmRTcGFjZSwgc2NhbGUgYXMgc2NhbGUkMSwgc2NhbGVGcmFjdGlvbiB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuaW1wb3J0IHsgR3JhZGllbnQsIHBhdGhSZW5kZXIsIHBhdGhQYXJzZSwgQm91bmRzLCBpbnRlcnNlY3QgYXMgaW50ZXJzZWN0JDEgfSBmcm9tICd2ZWdhLXNjZW5lZ3JhcGgnO1xuaW1wb3J0IHsgc2VsZWN0aW9uVmlzaXRvciwgc2VsZWN0aW9uVGVzdCwgc2VsZWN0aW9uSWRUZXN0LCBzZWxlY3Rpb25SZXNvbHZlLCBzZWxlY3Rpb25UdXBsZXMgfSBmcm9tICd2ZWdhLXNlbGVjdGlvbnMnO1xuaW1wb3J0IHsgcmFuZG9tLCBjdW11bGF0aXZlTm9ybWFsLCBjdW11bGF0aXZlTG9nTm9ybWFsLCBjdW11bGF0aXZlVW5pZm9ybSwgZGVuc2l0eU5vcm1hbCwgZGVuc2l0eUxvZ05vcm1hbCwgZGVuc2l0eVVuaWZvcm0sIHF1YW50aWxlTm9ybWFsLCBxdWFudGlsZUxvZ05vcm1hbCwgcXVhbnRpbGVVbmlmb3JtLCBzYW1wbGVOb3JtYWwsIHNhbXBsZUxvZ05vcm1hbCwgc2FtcGxlVW5pZm9ybSB9IGZyb20gJ3ZlZ2Etc3RhdGlzdGljcyc7XG5pbXBvcnQgeyB1dGNPZmZzZXQsIHV0Y1NlcXVlbmNlLCB0aW1lT2Zmc2V0LCB0aW1lU2VxdWVuY2UsIHRpbWVVbml0U3BlY2lmaWVyLCB3ZWVrLCB1dGN3ZWVrLCBkYXlvZnllYXIsIHV0Y2RheW9meWVhciB9IGZyb20gJ3ZlZ2EtdGltZSc7XG5pbXBvcnQgeyByYW5nZSBhcyByYW5nZSQxIH0gZnJvbSAnZDMtYXJyYXknO1xuXG5mdW5jdGlvbiBkYXRhKG5hbWUpIHtcbiAgY29uc3QgZGF0YSA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdO1xuICByZXR1cm4gZGF0YSA/IGRhdGEudmFsdWVzLnZhbHVlIDogW107XG59XG5mdW5jdGlvbiBpbmRhdGEobmFtZSwgZmllbGQsIHZhbHVlKSB7XG4gIGNvbnN0IGluZGV4ID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV1bJ2luZGV4OicgKyBmaWVsZF0sXG4gICAgICAgIGVudHJ5ID0gaW5kZXggPyBpbmRleC52YWx1ZS5nZXQodmFsdWUpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gZW50cnkgPyBlbnRyeS5jb3VudCA6IGVudHJ5O1xufVxuZnVuY3Rpb24gc2V0ZGF0YShuYW1lLCB0dXBsZXMpIHtcbiAgY29uc3QgZGYgPSB0aGlzLmNvbnRleHQuZGF0YWZsb3csXG4gICAgICAgIGRhdGEgPSB0aGlzLmNvbnRleHQuZGF0YVtuYW1lXSxcbiAgICAgICAgaW5wdXQgPSBkYXRhLmlucHV0O1xuICBkZi5wdWxzZShpbnB1dCwgZGYuY2hhbmdlc2V0KCkucmVtb3ZlKHRydXRoeSkuaW5zZXJ0KHR1cGxlcykpO1xuICByZXR1cm4gMTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlIChpdGVtLCBuYW1lLCByZXR2YWwpIHtcbiAgaWYgKGl0ZW0pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMuY29udGV4dC5kYXRhZmxvdyxcbiAgICAgICAgICB0YXJnZXQgPSBpdGVtLm1hcmsuc291cmNlO1xuICAgIGRmLnB1bHNlKHRhcmdldCwgZGYuY2hhbmdlc2V0KCkuZW5jb2RlKGl0ZW0sIG5hbWUpKTtcbiAgfVxuXG4gIHJldHVybiByZXR2YWwgIT09IHVuZGVmaW5lZCA/IHJldHZhbCA6IGl0ZW07XG59XG5cbmNvbnN0IHdyYXAgPSBtZXRob2QgPT4gZnVuY3Rpb24gKHZhbHVlLCBzcGVjKSB7XG4gIGNvbnN0IGxvY2FsZSA9IHRoaXMuY29udGV4dC5kYXRhZmxvdy5sb2NhbGUoKTtcbiAgcmV0dXJuIGxvY2FsZVttZXRob2RdKHNwZWMpKHZhbHVlKTtcbn07XG5cbmNvbnN0IGZvcm1hdCA9IHdyYXAoJ2Zvcm1hdCcpO1xuY29uc3QgdGltZUZvcm1hdCA9IHdyYXAoJ3RpbWVGb3JtYXQnKTtcbmNvbnN0IHV0Y0Zvcm1hdCA9IHdyYXAoJ3V0Y0Zvcm1hdCcpO1xuY29uc3QgdGltZVBhcnNlID0gd3JhcCgndGltZVBhcnNlJyk7XG5jb25zdCB1dGNQYXJzZSA9IHdyYXAoJ3V0Y1BhcnNlJyk7XG5jb25zdCBkYXRlT2JqID0gbmV3IERhdGUoMjAwMCwgMCwgMSk7XG5cbmZ1bmN0aW9uIHRpbWUobW9udGgsIGRheSwgc3BlY2lmaWVyKSB7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihtb250aCkgfHwgIU51bWJlci5pc0ludGVnZXIoZGF5KSkgcmV0dXJuICcnO1xuICBkYXRlT2JqLnNldFllYXIoMjAwMCk7XG4gIGRhdGVPYmouc2V0TW9udGgobW9udGgpO1xuICBkYXRlT2JqLnNldERhdGUoZGF5KTtcbiAgcmV0dXJuIHRpbWVGb3JtYXQuY2FsbCh0aGlzLCBkYXRlT2JqLCBzcGVjaWZpZXIpO1xufVxuXG5mdW5jdGlvbiBtb250aEZvcm1hdChtb250aCkge1xuICByZXR1cm4gdGltZS5jYWxsKHRoaXMsIG1vbnRoLCAxLCAnJUInKTtcbn1cbmZ1bmN0aW9uIG1vbnRoQWJicmV2Rm9ybWF0KG1vbnRoKSB7XG4gIHJldHVybiB0aW1lLmNhbGwodGhpcywgbW9udGgsIDEsICclYicpO1xufVxuZnVuY3Rpb24gZGF5Rm9ybWF0KGRheSkge1xuICByZXR1cm4gdGltZS5jYWxsKHRoaXMsIDAsIDIgKyBkYXksICclQScpO1xufVxuZnVuY3Rpb24gZGF5QWJicmV2Rm9ybWF0KGRheSkge1xuICByZXR1cm4gdGltZS5jYWxsKHRoaXMsIDAsIDIgKyBkYXksICclYScpO1xufVxuXG5jb25zdCBEYXRhUHJlZml4ID0gJzonO1xuY29uc3QgSW5kZXhQcmVmaXggPSAnQCc7XG5jb25zdCBTY2FsZVByZWZpeCA9ICclJztcbmNvbnN0IFNpZ25hbFByZWZpeCA9ICckJztcblxuZnVuY3Rpb24gZGF0YVZpc2l0b3IobmFtZSwgYXJncywgc2NvcGUsIHBhcmFtcykge1xuICBpZiAoYXJnc1swXS50eXBlICE9PSBMaXRlcmFsKSB7XG4gICAgZXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIGRhdGEgZnVuY3Rpb25zIG11c3QgYmUgYSBzdHJpbmcgbGl0ZXJhbC4nKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSBhcmdzWzBdLnZhbHVlLFxuICAgICAgICBkYXRhTmFtZSA9IERhdGFQcmVmaXggKyBkYXRhO1xuXG4gIGlmICghaGFzT3duUHJvcGVydHkoZGF0YU5hbWUsIHBhcmFtcykpIHtcbiAgICB0cnkge1xuICAgICAgcGFyYW1zW2RhdGFOYW1lXSA9IHNjb3BlLmdldERhdGEoZGF0YSkudHVwbGVzUmVmKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7Ly8gaWYgZGF0YSBzZXQgZG9lcyBub3QgZXhpc3QsIHRoZXJlJ3Mgbm90aGluZyB0byB0cmFja1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW5kYXRhVmlzaXRvcihuYW1lLCBhcmdzLCBzY29wZSwgcGFyYW1zKSB7XG4gIGlmIChhcmdzWzBdLnR5cGUgIT09IExpdGVyYWwpIGVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBpbmRhdGEgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLicpO1xuICBpZiAoYXJnc1sxXS50eXBlICE9PSBMaXRlcmFsKSBlcnJvcignU2Vjb25kIGFyZ3VtZW50IHRvIGluZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGxpdGVyYWwuJyk7XG4gIGNvbnN0IGRhdGEgPSBhcmdzWzBdLnZhbHVlLFxuICAgICAgICBmaWVsZCA9IGFyZ3NbMV0udmFsdWUsXG4gICAgICAgIGluZGV4TmFtZSA9IEluZGV4UHJlZml4ICsgZmllbGQ7XG5cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShpbmRleE5hbWUsIHBhcmFtcykpIHtcbiAgICBwYXJhbXNbaW5kZXhOYW1lXSA9IHNjb3BlLmdldERhdGEoZGF0YSkuaW5kYXRhUmVmKHNjb3BlLCBmaWVsZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNjYWxlVmlzaXRvcihuYW1lLCBhcmdzLCBzY29wZSwgcGFyYW1zKSB7XG4gIGlmIChhcmdzWzBdLnR5cGUgPT09IExpdGVyYWwpIHtcbiAgICAvLyBhZGQgc2NhbGUgZGVwZW5kZW5jeVxuICAgIGFkZFNjYWxlRGVwZW5kZW5jeShzY29wZSwgcGFyYW1zLCBhcmdzWzBdLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbmRpcmVjdCBzY2FsZSBsb29rdXA7IGFkZCBhbGwgc2NhbGVzIGFzIHBhcmFtZXRlcnNcbiAgICBmb3IgKG5hbWUgaW4gc2NvcGUuc2NhbGVzKSB7XG4gICAgICBhZGRTY2FsZURlcGVuZGVuY3koc2NvcGUsIHBhcmFtcywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFNjYWxlRGVwZW5kZW5jeShzY29wZSwgcGFyYW1zLCBuYW1lKSB7XG4gIGNvbnN0IHNjYWxlTmFtZSA9IFNjYWxlUHJlZml4ICsgbmFtZTtcblxuICBpZiAoIWhhc093blByb3BlcnR5KHBhcmFtcywgc2NhbGVOYW1lKSkge1xuICAgIHRyeSB7XG4gICAgICBwYXJhbXNbc2NhbGVOYW1lXSA9IHNjb3BlLnNjYWxlUmVmKG5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikgey8vIFRPRE86IGVycm9yIGhhbmRsaW5nPyB3YXJuaW5nP1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShuYW1lLCBjdHgpIHtcbiAgbGV0IHM7XG4gIHJldHVybiBpc0Z1bmN0aW9uKG5hbWUpID8gbmFtZSA6IGlzU3RyaW5nKG5hbWUpID8gKHMgPSBjdHguc2NhbGVzW25hbWVdKSAmJiBzLnZhbHVlIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaW50ZXJuYWxTY2FsZUZ1bmN0aW9ucyhjb2RlZ2VuLCBmbmN0eCwgdmlzaXRvcnMpIHtcbiAgLy8gYWRkIGhlbHBlciBtZXRob2QgdG8gdGhlICd0aGlzJyBleHByZXNzaW9uIGZ1bmN0aW9uIGNvbnRleHRcbiAgZm5jdHguX19iYW5kd2lkdGggPSBzID0+IHMgJiYgcy5iYW5kd2lkdGggPyBzLmJhbmR3aWR0aCgpIDogMDsgLy8gcmVnaXN0ZXIgQVNUIHZpc2l0b3JzIGZvciBpbnRlcm5hbCBzY2FsZSBmdW5jdGlvbnNcblxuXG4gIHZpc2l0b3JzLl9iYW5kd2lkdGggPSBzY2FsZVZpc2l0b3I7XG4gIHZpc2l0b3JzLl9yYW5nZSA9IHNjYWxlVmlzaXRvcjtcbiAgdmlzaXRvcnMuX3NjYWxlID0gc2NhbGVWaXNpdG9yOyAvLyByZXNvbHZlIHNjYWxlIHJlZmVyZW5jZSBkaXJlY3RseSB0byB0aGUgc2lnbmFsIGhhc2ggYXJndW1lbnRcblxuICBjb25zdCByZWYgPSBhcmcgPT4gJ19bJyArIChhcmcudHlwZSA9PT0gTGl0ZXJhbCA/IHN0cmluZ1ZhbHVlKFNjYWxlUHJlZml4ICsgYXJnLnZhbHVlKSA6IHN0cmluZ1ZhbHVlKFNjYWxlUHJlZml4KSArICcrJyArIGNvZGVnZW4oYXJnKSkgKyAnXSc7IC8vIGRlZmluZSBhbmQgcmV0dXJuIGludGVybmFsIHNjYWxlIGZ1bmN0aW9uIGNvZGUgZ2VuZXJhdG9yc1xuICAvLyB0aGVzZSBpbnRlcm5hbCBmdW5jdGlvbnMgYXJlIGNhbGxlZCBieSBtYXJrIGVuY29kZXJzXG5cblxuICByZXR1cm4ge1xuICAgIF9iYW5kd2lkdGg6IGFyZ3MgPT4gYHRoaXMuX19iYW5kd2lkdGgoJHtyZWYoYXJnc1swXSl9KWAsXG4gICAgX3JhbmdlOiBhcmdzID0+IGAke3JlZihhcmdzWzBdKX0ucmFuZ2UoKWAsXG4gICAgX3NjYWxlOiBhcmdzID0+IGAke3JlZihhcmdzWzBdKX0oJHtjb2RlZ2VuKGFyZ3NbMV0pfSlgXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdlb01ldGhvZChtZXRob2ROYW1lLCBnbG9iYWxNZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm9qZWN0aW9uLCBnZW9qc29uLCBncm91cCkge1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAvLyBwcm9qZWN0aW9uIGRlZmluZWQsIHVzZSBpdFxuICAgICAgY29uc3QgcCA9IGdldFNjYWxlKHByb2plY3Rpb24sIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgICAgIHJldHVybiBwICYmIHAucGF0aFttZXRob2ROYW1lXShnZW9qc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJvamVjdGlvbiB1bmRlZmluZWQsIHVzZSBnbG9iYWwgbWV0aG9kXG4gICAgICByZXR1cm4gZ2xvYmFsTWV0aG9kKGdlb2pzb24pO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgZ2VvQXJlYSA9IGdlb01ldGhvZCgnYXJlYScsIGdlb0FyZWEkMSk7XG5jb25zdCBnZW9Cb3VuZHMgPSBnZW9NZXRob2QoJ2JvdW5kcycsIGdlb0JvdW5kcyQxKTtcbmNvbnN0IGdlb0NlbnRyb2lkID0gZ2VvTWV0aG9kKCdjZW50cm9pZCcsIGdlb0NlbnRyb2lkJDEpO1xuXG5mdW5jdGlvbiBpblNjb3BlIChpdGVtKSB7XG4gIGNvbnN0IGdyb3VwID0gdGhpcy5jb250ZXh0Lmdyb3VwO1xuICBsZXQgdmFsdWUgPSBmYWxzZTtcbiAgaWYgKGdyb3VwKSB3aGlsZSAoaXRlbSkge1xuICAgIGlmIChpdGVtID09PSBncm91cCkge1xuICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaXRlbSA9IGl0ZW0ubWFyay5ncm91cDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGxvZyhkZiwgbWV0aG9kLCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgZGZbbWV0aG9kXS5hcHBseShkZiwgWydFWFBSRVNTSU9OJ10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGYud2FybihlcnIpO1xuICB9XG5cbiAgcmV0dXJuIGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbn1cblxuZnVuY3Rpb24gd2FybigpIHtcbiAgcmV0dXJuIGxvZyh0aGlzLmNvbnRleHQuZGF0YWZsb3csICd3YXJuJywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGluZm8oKSB7XG4gIHJldHVybiBsb2codGhpcy5jb250ZXh0LmRhdGFmbG93LCAnaW5mbycsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBkZWJ1ZygpIHtcbiAgcmV0dXJuIGxvZyh0aGlzLmNvbnRleHQuZGF0YWZsb3csICdkZWJ1ZycsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNoYW5uZWxfbHVtaW5hbmNlX3ZhbHVlKGNoYW5uZWxWYWx1ZSkge1xuICBjb25zdCB2YWwgPSBjaGFubmVsVmFsdWUgLyAyNTU7XG5cbiAgaWYgKHZhbCA8PSAwLjAzOTI4KSB7XG4gICAgcmV0dXJuIHZhbCAvIDEyLjkyO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgucG93KCh2YWwgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gbHVtaW5hbmNlKGNvbG9yKSB7XG4gIGNvbnN0IGMgPSByZ2IoY29sb3IpLFxuICAgICAgICByID0gY2hhbm5lbF9sdW1pbmFuY2VfdmFsdWUoYy5yKSxcbiAgICAgICAgZyA9IGNoYW5uZWxfbHVtaW5hbmNlX3ZhbHVlKGMuZyksXG4gICAgICAgIGIgPSBjaGFubmVsX2x1bWluYW5jZV92YWx1ZShjLmIpO1xuICByZXR1cm4gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xufSAvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNjb250cmFzdC1yYXRpb2RlZlxuXG5mdW5jdGlvbiBjb250cmFzdChjb2xvcjEsIGNvbG9yMikge1xuICBjb25zdCBsdW0xID0gbHVtaW5hbmNlKGNvbG9yMSksXG4gICAgICAgIGx1bTIgPSBsdW1pbmFuY2UoY29sb3IyKSxcbiAgICAgICAgbHVtTCA9IE1hdGgubWF4KGx1bTEsIGx1bTIpLFxuICAgICAgICBsdW1EID0gTWF0aC5taW4obHVtMSwgbHVtMik7XG4gIHJldHVybiAobHVtTCArIDAuMDUpIC8gKGx1bUQgKyAwLjA1KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UgKCkge1xuICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoe30pO1xuICByZXR1cm4gZXh0ZW5kKC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IGEgIT09IGEgJiYgYiAhPT0gYiA/IHRydWUgOiBpc0FycmF5KGEpID8gaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggPyBlcXVhbEFycmF5KGEsIGIpIDogZmFsc2UgOiBpc09iamVjdChhKSAmJiBpc09iamVjdChiKSA/IGVxdWFsT2JqZWN0KGEsIGIpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGVxdWFsQXJyYXkoYSwgYikge1xuICBmb3IgKGxldCBpID0gMCwgbiA9IGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0KGEsIGIpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUHJlZGljYXRlKHByb3BzKSB7XG4gIHJldHVybiBfID0+IGVxdWFsT2JqZWN0KHByb3BzLCBfKTtcbn1cblxuZnVuY3Rpb24gbW9kaWZ5IChuYW1lLCBpbnNlcnQsIHJlbW92ZSwgdG9nZ2xlLCBtb2RpZnksIHZhbHVlcykge1xuICBjb25zdCBkZiA9IHRoaXMuY29udGV4dC5kYXRhZmxvdyxcbiAgICAgICAgZGF0YSA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdLFxuICAgICAgICBpbnB1dCA9IGRhdGEuaW5wdXQsXG4gICAgICAgIHN0YW1wID0gZGYuc3RhbXAoKTtcbiAgbGV0IGNoYW5nZXMgPSBkYXRhLmNoYW5nZXMsXG4gICAgICBwcmVkaWNhdGUsXG4gICAgICBrZXk7XG5cbiAgaWYgKGRmLl90cmlnZ2VyID09PSBmYWxzZSB8fCAhKGlucHV0LnZhbHVlLmxlbmd0aCB8fCBpbnNlcnQgfHwgdG9nZ2xlKSkge1xuICAgIC8vIG5vdGhpbmcgdG8gZG8hXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoIWNoYW5nZXMgfHwgY2hhbmdlcy5zdGFtcCA8IHN0YW1wKSB7XG4gICAgZGF0YS5jaGFuZ2VzID0gY2hhbmdlcyA9IGRmLmNoYW5nZXNldCgpO1xuICAgIGNoYW5nZXMuc3RhbXAgPSBzdGFtcDtcbiAgICBkZi5ydW5BZnRlcigoKSA9PiB7XG4gICAgICBkYXRhLm1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIGRmLnB1bHNlKGlucHV0LCBjaGFuZ2VzKS5ydW4oKTtcbiAgICB9LCB0cnVlLCAxKTtcbiAgfVxuXG4gIGlmIChyZW1vdmUpIHtcbiAgICBwcmVkaWNhdGUgPSByZW1vdmUgPT09IHRydWUgPyB0cnV0aHkgOiBpc0FycmF5KHJlbW92ZSkgfHwgaXNUdXBsZShyZW1vdmUpID8gcmVtb3ZlIDogcmVtb3ZlUHJlZGljYXRlKHJlbW92ZSk7XG4gICAgY2hhbmdlcy5yZW1vdmUocHJlZGljYXRlKTtcbiAgfVxuXG4gIGlmIChpbnNlcnQpIHtcbiAgICBjaGFuZ2VzLmluc2VydChpbnNlcnQpO1xuICB9XG5cbiAgaWYgKHRvZ2dsZSkge1xuICAgIHByZWRpY2F0ZSA9IHJlbW92ZVByZWRpY2F0ZSh0b2dnbGUpO1xuXG4gICAgaWYgKGlucHV0LnZhbHVlLnNvbWUocHJlZGljYXRlKSkge1xuICAgICAgY2hhbmdlcy5yZW1vdmUocHJlZGljYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlcy5pbnNlcnQodG9nZ2xlKTtcbiAgICB9XG4gIH1cblxuICBpZiAobW9kaWZ5KSB7XG4gICAgZm9yIChrZXkgaW4gdmFsdWVzKSB7XG4gICAgICBjaGFuZ2VzLm1vZGlmeShtb2RpZnksIGtleSwgdmFsdWVzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAxO1xufVxuXG5mdW5jdGlvbiBwaW5jaERpc3RhbmNlKGV2ZW50KSB7XG4gIGNvbnN0IHQgPSBldmVudC50b3VjaGVzLFxuICAgICAgICBkeCA9IHRbMF0uY2xpZW50WCAtIHRbMV0uY2xpZW50WCxcbiAgICAgICAgZHkgPSB0WzBdLmNsaWVudFkgLSB0WzFdLmNsaWVudFk7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufVxuZnVuY3Rpb24gcGluY2hBbmdsZShldmVudCkge1xuICBjb25zdCB0ID0gZXZlbnQudG91Y2hlcztcbiAgcmV0dXJuIE1hdGguYXRhbjIodFswXS5jbGllbnRZIC0gdFsxXS5jbGllbnRZLCB0WzBdLmNsaWVudFggLSB0WzFdLmNsaWVudFgpO1xufVxuXG5jb25zdCBhY2Nlc3NvcnMgPSB7fTtcbmZ1bmN0aW9uIHBsdWNrIChkYXRhLCBuYW1lKSB7XG4gIGNvbnN0IGFjY2Vzc29yID0gYWNjZXNzb3JzW25hbWVdIHx8IChhY2Nlc3NvcnNbbmFtZV0gPSBmaWVsZChuYW1lKSk7XG4gIHJldHVybiBpc0FycmF5KGRhdGEpID8gZGF0YS5tYXAoYWNjZXNzb3IpIDogYWNjZXNzb3IoZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGFycmF5KHNlcSkge1xuICByZXR1cm4gaXNBcnJheShzZXEpIHx8IEFycmF5QnVmZmVyLmlzVmlldyhzZXEpID8gc2VxIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gc2VxdWVuY2Uoc2VxKSB7XG4gIHJldHVybiBhcnJheShzZXEpIHx8IChpc1N0cmluZyhzZXEpID8gc2VxIDogbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGpvaW4oc2VxLCAuLi5hcmdzKSB7XG4gIHJldHVybiBhcnJheShzZXEpLmpvaW4oLi4uYXJncyk7XG59XG5mdW5jdGlvbiBpbmRleG9mKHNlcSwgLi4uYXJncykge1xuICByZXR1cm4gc2VxdWVuY2Uoc2VxKS5pbmRleE9mKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gbGFzdGluZGV4b2Yoc2VxLCAuLi5hcmdzKSB7XG4gIHJldHVybiBzZXF1ZW5jZShzZXEpLmxhc3RJbmRleE9mKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gc2xpY2Uoc2VxLCAuLi5hcmdzKSB7XG4gIHJldHVybiBzZXF1ZW5jZShzZXEpLnNsaWNlKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gcmVwbGFjZShzdHIsIHBhdHRlcm4sIHJlcGwpIHtcbiAgaWYgKGlzRnVuY3Rpb24ocmVwbCkpIGVycm9yKCdGdW5jdGlvbiBhcmd1bWVudCBwYXNzZWQgdG8gcmVwbGFjZS4nKTtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocGF0dGVybiwgcmVwbCk7XG59XG5mdW5jdGlvbiByZXZlcnNlKHNlcSkge1xuICByZXR1cm4gYXJyYXkoc2VxKS5zbGljZSgpLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gYmFuZHNwYWNlKGNvdW50LCBwYWRkaW5nSW5uZXIsIHBhZGRpbmdPdXRlcikge1xuICByZXR1cm4gYmFuZFNwYWNlKGNvdW50IHx8IDAsIHBhZGRpbmdJbm5lciB8fCAwLCBwYWRkaW5nT3V0ZXIgfHwgMCk7XG59XG5mdW5jdGlvbiBiYW5kd2lkdGgobmFtZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuIHMgJiYgcy5iYW5kd2lkdGggPyBzLmJhbmR3aWR0aCgpIDogMDtcbn1cbmZ1bmN0aW9uIGNvcHkobmFtZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuIHMgPyBzLmNvcHkoKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGRvbWFpbihuYW1lLCBncm91cCkge1xuICBjb25zdCBzID0gZ2V0U2NhbGUobmFtZSwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gcyA/IHMuZG9tYWluKCkgOiBbXTtcbn1cbmZ1bmN0aW9uIGludmVydChuYW1lLCByYW5nZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuICFzID8gdW5kZWZpbmVkIDogaXNBcnJheShyYW5nZSkgPyAocy5pbnZlcnRSYW5nZSB8fCBzLmludmVydCkocmFuZ2UpIDogKHMuaW52ZXJ0IHx8IHMuaW52ZXJ0RXh0ZW50KShyYW5nZSk7XG59XG5mdW5jdGlvbiByYW5nZShuYW1lLCBncm91cCkge1xuICBjb25zdCBzID0gZ2V0U2NhbGUobmFtZSwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gcyAmJiBzLnJhbmdlID8gcy5yYW5nZSgpIDogW107XG59XG5mdW5jdGlvbiBzY2FsZShuYW1lLCB2YWx1ZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuIHMgPyBzKHZhbHVlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2NhbGVHcmFkaWVudCAoc2NhbGUsIHAwLCBwMSwgY291bnQsIGdyb3VwKSB7XG4gIHNjYWxlID0gZ2V0U2NhbGUoc2NhbGUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgY29uc3QgZ3JhZGllbnQgPSBHcmFkaWVudChwMCwgcDEpO1xuICBsZXQgc3RvcHMgPSBzY2FsZS5kb21haW4oKSxcbiAgICAgIG1pbiA9IHN0b3BzWzBdLFxuICAgICAgbWF4ID0gcGVlayhzdG9wcyksXG4gICAgICBmcmFjdGlvbiA9IGlkZW50aXR5O1xuXG4gIGlmICghKG1heCAtIG1pbikpIHtcbiAgICAvLyBleHBhbmQgc2NhbGUgaWYgZG9tYWluIGhhcyB6ZXJvIHNwYW4sIGZpeCAjMTQ3OVxuICAgIHNjYWxlID0gKHNjYWxlLmludGVycG9sYXRvciA/IHNjYWxlJDEoJ3NlcXVlbnRpYWwnKSgpLmludGVycG9sYXRvcihzY2FsZS5pbnRlcnBvbGF0b3IoKSkgOiBzY2FsZSQxKCdsaW5lYXInKSgpLmludGVycG9sYXRlKHNjYWxlLmludGVycG9sYXRlKCkpLnJhbmdlKHNjYWxlLnJhbmdlKCkpKS5kb21haW4oW21pbiA9IDAsIG1heCA9IDFdKTtcbiAgfSBlbHNlIHtcbiAgICBmcmFjdGlvbiA9IHNjYWxlRnJhY3Rpb24oc2NhbGUsIG1pbiwgbWF4KTtcbiAgfVxuXG4gIGlmIChzY2FsZS50aWNrcykge1xuICAgIHN0b3BzID0gc2NhbGUudGlja3MoK2NvdW50IHx8IDE1KTtcbiAgICBpZiAobWluICE9PSBzdG9wc1swXSkgc3RvcHMudW5zaGlmdChtaW4pO1xuICAgIGlmIChtYXggIT09IHBlZWsoc3RvcHMpKSBzdG9wcy5wdXNoKG1heCk7XG4gIH1cblxuICBzdG9wcy5mb3JFYWNoKF8gPT4gZ3JhZGllbnQuc3RvcChmcmFjdGlvbihfKSwgc2NhbGUoXykpKTtcbiAgcmV0dXJuIGdyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBnZW9TaGFwZShwcm9qZWN0aW9uLCBnZW9qc29uLCBncm91cCkge1xuICBjb25zdCBwID0gZ2V0U2NhbGUocHJvamVjdGlvbiwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gcCA/IHAucGF0aC5jb250ZXh0KGNvbnRleHQpKGdlb2pzb24pIDogJyc7XG4gIH07XG59XG5mdW5jdGlvbiBwYXRoU2hhcGUocGF0aCkge1xuICBsZXQgcCA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0ID8gcGF0aFJlbmRlcihjb250ZXh0LCBwID0gcCB8fCBwYXRoUGFyc2UocGF0aCkpIDogcGF0aDtcbiAgfTtcbn1cblxuY29uc3QgZGF0dW0gPSBkID0+IGQuZGF0YTtcblxuZnVuY3Rpb24gdHJlZU5vZGVzKG5hbWUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHJlZSA9IGRhdGEuY2FsbChjb250ZXh0LCBuYW1lKTtcbiAgcmV0dXJuIHRyZWUucm9vdCAmJiB0cmVlLnJvb3QubG9va3VwIHx8IHt9O1xufVxuXG5mdW5jdGlvbiB0cmVlUGF0aChuYW1lLCBzb3VyY2UsIHRhcmdldCkge1xuICBjb25zdCBub2RlcyA9IHRyZWVOb2RlcyhuYW1lLCB0aGlzKSxcbiAgICAgICAgcyA9IG5vZGVzW3NvdXJjZV0sXG4gICAgICAgIHQgPSBub2Rlc1t0YXJnZXRdO1xuICByZXR1cm4gcyAmJiB0ID8gcy5wYXRoKHQpLm1hcChkYXR1bSkgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0cmVlQW5jZXN0b3JzKG5hbWUsIG5vZGUpIHtcbiAgY29uc3QgbiA9IHRyZWVOb2RlcyhuYW1lLCB0aGlzKVtub2RlXTtcbiAgcmV0dXJuIG4gPyBuLmFuY2VzdG9ycygpLm1hcChkYXR1bSkgOiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IF93aW5kb3cgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgfHwgbnVsbDtcblxuZnVuY3Rpb24gc2NyZWVuKCkge1xuICBjb25zdCB3ID0gX3dpbmRvdygpO1xuXG4gIHJldHVybiB3ID8gdy5zY3JlZW4gOiB7fTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1NpemUoKSB7XG4gIGNvbnN0IHcgPSBfd2luZG93KCk7XG5cbiAgcmV0dXJuIHcgPyBbdy5pbm5lcldpZHRoLCB3LmlubmVySGVpZ2h0XSA6IFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBjb250YWluZXJTaXplKCkge1xuICBjb25zdCB2aWV3ID0gdGhpcy5jb250ZXh0LmRhdGFmbG93LFxuICAgICAgICBlbCA9IHZpZXcuY29udGFpbmVyICYmIHZpZXcuY29udGFpbmVyKCk7XG4gIHJldHVybiBlbCA/IFtlbC5jbGllbnRXaWR0aCwgZWwuY2xpZW50SGVpZ2h0XSA6IFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCAoYiwgb3B0LCBncm91cCkge1xuICBpZiAoIWIpIHJldHVybiBbXTtcbiAgY29uc3QgW3UsIHZdID0gYixcbiAgICAgICAgYm94ID0gbmV3IEJvdW5kcygpLnNldCh1WzBdLCB1WzFdLCB2WzBdLCB2WzFdKSxcbiAgICAgICAgc2NlbmUgPSBncm91cCB8fCB0aGlzLmNvbnRleHQuZGF0YWZsb3cuc2NlbmVncmFwaCgpLnJvb3Q7XG4gIHJldHVybiBpbnRlcnNlY3QkMShzY2VuZSwgYm94LCBmaWx0ZXIob3B0KSk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlcihvcHQpIHtcbiAgbGV0IHAgPSBudWxsO1xuXG4gIGlmIChvcHQpIHtcbiAgICBjb25zdCB0eXBlcyA9IGFycmF5JDEob3B0Lm1hcmt0eXBlKSxcbiAgICAgICAgICBuYW1lcyA9IGFycmF5JDEob3B0Lm1hcmtuYW1lKTtcblxuICAgIHAgPSBfID0+ICghdHlwZXMubGVuZ3RoIHx8IHR5cGVzLnNvbWUodCA9PiBfLm1hcmt0eXBlID09PSB0KSkgJiYgKCFuYW1lcy5sZW5ndGggfHwgbmFtZXMuc29tZShzID0+IF8ubmFtZSA9PT0gcykpO1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IHtcbiAgcmFuZG9tKCkge1xuICAgIHJldHVybiByYW5kb20oKTtcbiAgfSxcblxuICAvLyBvdmVycmlkZSBkZWZhdWx0XG4gIGN1bXVsYXRpdmVOb3JtYWwsXG4gIGN1bXVsYXRpdmVMb2dOb3JtYWwsXG4gIGN1bXVsYXRpdmVVbmlmb3JtLFxuICBkZW5zaXR5Tm9ybWFsLFxuICBkZW5zaXR5TG9nTm9ybWFsLFxuICBkZW5zaXR5VW5pZm9ybSxcbiAgcXVhbnRpbGVOb3JtYWwsXG4gIHF1YW50aWxlTG9nTm9ybWFsLFxuICBxdWFudGlsZVVuaWZvcm0sXG4gIHNhbXBsZU5vcm1hbCxcbiAgc2FtcGxlTG9nTm9ybWFsLFxuICBzYW1wbGVVbmlmb3JtLFxuICBpc0FycmF5LFxuICBpc0Jvb2xlYW4sXG4gIGlzRGF0ZSxcblxuICBpc0RlZmluZWQoXykge1xuICAgIHJldHVybiBfICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgaXNOdW1iZXIsXG4gIGlzT2JqZWN0LFxuICBpc1JlZ0V4cCxcbiAgaXNTdHJpbmcsXG4gIGlzVHVwbGUsXG5cbiAgaXNWYWxpZChfKSB7XG4gICAgcmV0dXJuIF8gIT0gbnVsbCAmJiBfID09PSBfO1xuICB9LFxuXG4gIHRvQm9vbGVhbixcbiAgdG9EYXRlLFxuICB0b051bWJlcixcbiAgdG9TdHJpbmcsXG4gIGluZGV4b2YsXG4gIGpvaW4sXG4gIGxhc3RpbmRleG9mLFxuICByZXBsYWNlLFxuICByZXZlcnNlLFxuICBzbGljZSxcbiAgZmx1c2gsXG4gIGxlcnAsXG4gIG1lcmdlLFxuICBwYWQsXG4gIHBlZWssXG4gIHBsdWNrLFxuICBzcGFuLFxuICBpbnJhbmdlLFxuICB0cnVuY2F0ZSxcbiAgcmdiLFxuICBsYWIsXG4gIGhjbCxcbiAgaHNsLFxuICBsdW1pbmFuY2UsXG4gIGNvbnRyYXN0LFxuICBzZXF1ZW5jZTogcmFuZ2UkMSxcbiAgZm9ybWF0LFxuICB1dGNGb3JtYXQsXG4gIHV0Y1BhcnNlLFxuICB1dGNPZmZzZXQsXG4gIHV0Y1NlcXVlbmNlLFxuICB0aW1lRm9ybWF0LFxuICB0aW1lUGFyc2UsXG4gIHRpbWVPZmZzZXQsXG4gIHRpbWVTZXF1ZW5jZSxcbiAgdGltZVVuaXRTcGVjaWZpZXIsXG4gIG1vbnRoRm9ybWF0LFxuICBtb250aEFiYnJldkZvcm1hdCxcbiAgZGF5Rm9ybWF0LFxuICBkYXlBYmJyZXZGb3JtYXQsXG4gIHF1YXJ0ZXIsXG4gIHV0Y3F1YXJ0ZXIsXG4gIHdlZWssXG4gIHV0Y3dlZWssXG4gIGRheW9meWVhcixcbiAgdXRjZGF5b2Z5ZWFyLFxuICB3YXJuLFxuICBpbmZvLFxuICBkZWJ1ZyxcbiAgZXh0ZW50LFxuICBpblNjb3BlLFxuICBpbnRlcnNlY3QsXG4gIGNsYW1wUmFuZ2UsXG4gIHBpbmNoRGlzdGFuY2UsXG4gIHBpbmNoQW5nbGUsXG4gIHNjcmVlbixcbiAgY29udGFpbmVyU2l6ZSxcbiAgd2luZG93U2l6ZSxcbiAgYmFuZHNwYWNlLFxuICBzZXRkYXRhLFxuICBwYXRoU2hhcGUsXG4gIHBhbkxpbmVhcixcbiAgcGFuTG9nLFxuICBwYW5Qb3csXG4gIHBhblN5bWxvZyxcbiAgem9vbUxpbmVhcixcbiAgem9vbUxvZyxcbiAgem9vbVBvdyxcbiAgem9vbVN5bWxvZyxcbiAgZW5jb2RlLFxuICBtb2RpZnlcbn07XG5jb25zdCBldmVudEZ1bmN0aW9ucyA9IFsndmlldycsICdpdGVtJywgJ2dyb3VwJywgJ3h5JywgJ3gnLCAneSddLFxuICAgICAgLy8gZXZlbnQgZnVuY3Rpb25zXG5ldmVudFByZWZpeCA9ICdldmVudC52ZWdhLicsXG4gICAgICAvLyBldmVudCBmdW5jdGlvbiBwcmVmaXhcbnRoaXNQcmVmaXggPSAndGhpcy4nLFxuICAgICAgLy8gZnVuY3Rpb24gY29udGV4dCBwcmVmaXhcbmFzdFZpc2l0b3JzID0ge307IC8vIEFTVCB2aXNpdG9ycyBmb3IgZGVwZW5kZW5jeSBhbmFseXNpc1xuLy8gZXhwb3J0IGNvZGUgZ2VuZXJhdG9yIHBhcmFtZXRlcnNcblxuY29uc3QgY29kZWdlblBhcmFtcyA9IHtcbiAgZm9yYmlkZGVuOiBbJ18nXSxcbiAgYWxsb3dlZDogWydkYXR1bScsICdldmVudCcsICdpdGVtJ10sXG4gIGZpZWxkdmFyOiAnZGF0dW0nLFxuICBnbG9iYWx2YXI6IGlkID0+IGBfWyR7c3RyaW5nVmFsdWUoU2lnbmFsUHJlZml4ICsgaWQpfV1gLFxuICBmdW5jdGlvbnM6IGJ1aWxkRnVuY3Rpb25zLFxuICBjb25zdGFudHM6IGNvbnN0YW50cyxcbiAgdmlzaXRvcnM6IGFzdFZpc2l0b3JzXG59OyAvLyBleHBvcnQgY29kZSBnZW5lcmF0b3JcblxuY29uc3QgY29kZUdlbmVyYXRvciA9IGNvZGVnZW5FeHByZXNzaW9uKGNvZGVnZW5QYXJhbXMpOyAvLyBCdWlsZCBleHByZXNzaW9uIGZ1bmN0aW9uIHJlZ2lzdHJ5XG5cbmZ1bmN0aW9uIGJ1aWxkRnVuY3Rpb25zKGNvZGVnZW4pIHtcbiAgY29uc3QgZm4gPSBmdW5jdGlvbnMoY29kZWdlbik7XG4gIGV2ZW50RnVuY3Rpb25zLmZvckVhY2gobmFtZSA9PiBmbltuYW1lXSA9IGV2ZW50UHJlZml4ICsgbmFtZSk7XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGZ1bmN0aW9uQ29udGV4dCkge1xuICAgIGZuW25hbWVdID0gdGhpc1ByZWZpeCArIG5hbWU7XG4gIH1cblxuICBleHRlbmQoZm4sIGludGVybmFsU2NhbGVGdW5jdGlvbnMoY29kZWdlbiwgZnVuY3Rpb25Db250ZXh0LCBhc3RWaXNpdG9ycykpO1xuICByZXR1cm4gZm47XG59IC8vIFJlZ2lzdGVyIGFuIGV4cHJlc3Npb24gZnVuY3Rpb25cblxuXG5mdW5jdGlvbiBleHByZXNzaW9uRnVuY3Rpb24obmFtZSwgZm4sIHZpc2l0b3IpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Db250ZXh0W25hbWVdO1xuICB9IC8vIHJlZ2lzdGVyIHdpdGggdGhlIGZ1bmN0aW9uQ29udGV4dFxuXG5cbiAgZnVuY3Rpb25Db250ZXh0W25hbWVdID0gZm47IC8vIGlmIHRoZXJlIGlzIGFuIGFzdFZpc2l0b3IgcmVnaXN0ZXIgdGhhdCwgdG9vXG5cbiAgaWYgKHZpc2l0b3IpIGFzdFZpc2l0b3JzW25hbWVdID0gdmlzaXRvcjsgLy8gaWYgdGhlIGNvZGUgZ2VuZXJhdG9yIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQsXG4gIC8vIHdlIG5lZWQgdG8gYWxzbyByZWdpc3RlciB0aGUgZnVuY3Rpb24gd2l0aCBpdFxuXG4gIGlmIChjb2RlR2VuZXJhdG9yKSBjb2RlR2VuZXJhdG9yLmZ1bmN0aW9uc1tuYW1lXSA9IHRoaXNQcmVmaXggKyBuYW1lO1xuICByZXR1cm4gdGhpcztcbn0gLy8gcmVnaXN0ZXIgZXhwcmVzc2lvbiBmdW5jdGlvbnMgd2l0aCBhc3QgdmlzaXRvcnNcblxuZXhwcmVzc2lvbkZ1bmN0aW9uKCdiYW5kd2lkdGgnLCBiYW5kd2lkdGgsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2NvcHknLCBjb3B5LCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdkb21haW4nLCBkb21haW4sIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3JhbmdlJywgcmFuZ2UsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2ludmVydCcsIGludmVydCwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignc2NhbGUnLCBzY2FsZSwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignZ3JhZGllbnQnLCBzY2FsZUdyYWRpZW50LCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9BcmVhJywgZ2VvQXJlYSwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignZ2VvQm91bmRzJywgZ2VvQm91bmRzLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9DZW50cm9pZCcsIGdlb0NlbnRyb2lkLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9TaGFwZScsIGdlb1NoYXBlLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdpbmRhdGEnLCBpbmRhdGEsIGluZGF0YVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdkYXRhJywgZGF0YSwgZGF0YVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCd0cmVlUGF0aCcsIHRyZWVQYXRoLCBkYXRhVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3RyZWVBbmNlc3RvcnMnLCB0cmVlQW5jZXN0b3JzLCBkYXRhVmlzaXRvcik7IC8vIHJlZ2lzdGVyIFZlZ2EtTGl0ZSBzZWxlY3Rpb24gZnVuY3Rpb25zXG5cbmV4cHJlc3Npb25GdW5jdGlvbigndmxTZWxlY3Rpb25UZXN0Jywgc2VsZWN0aW9uVGVzdCwgc2VsZWN0aW9uVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3ZsU2VsZWN0aW9uSWRUZXN0Jywgc2VsZWN0aW9uSWRUZXN0LCBzZWxlY3Rpb25WaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbigndmxTZWxlY3Rpb25SZXNvbHZlJywgc2VsZWN0aW9uUmVzb2x2ZSwgc2VsZWN0aW9uVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3ZsU2VsZWN0aW9uVHVwbGVzJywgc2VsZWN0aW9uVHVwbGVzKTtcblxuZnVuY3Rpb24gcGFyc2VyIChleHByLCBzY29wZSkge1xuICBjb25zdCBwYXJhbXMgPSB7fTsgLy8gcGFyc2UgdGhlIGV4cHJlc3Npb24gdG8gYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgKGFzdClcblxuICBsZXQgYXN0O1xuXG4gIHRyeSB7XG4gICAgZXhwciA9IGlzU3RyaW5nKGV4cHIpID8gZXhwciA6IHN0cmluZ1ZhbHVlKGV4cHIpICsgJyc7XG4gICAgYXN0ID0gcGFyc2VFeHByZXNzaW9uKGV4cHIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcignRXhwcmVzc2lvbiBwYXJzZSBlcnJvcjogJyArIGV4cHIpO1xuICB9IC8vIGFuYWx5emUgYXN0IGZ1bmN0aW9uIGNhbGxzIGZvciBkZXBlbmRlbmNpZXNcblxuXG4gIGFzdC52aXNpdChub2RlID0+IHtcbiAgICBpZiAobm9kZS50eXBlICE9PSBDYWxsRXhwcmVzc2lvbikgcmV0dXJuO1xuICAgIGNvbnN0IG5hbWUgPSBub2RlLmNhbGxlZS5uYW1lLFxuICAgICAgICAgIHZpc2l0ID0gY29kZWdlblBhcmFtcy52aXNpdG9yc1tuYW1lXTtcbiAgICBpZiAodmlzaXQpIHZpc2l0KG5hbWUsIG5vZGUuYXJndW1lbnRzLCBzY29wZSwgcGFyYW1zKTtcbiAgfSk7IC8vIHBlcmZvcm0gY29kZSBnZW5lcmF0aW9uXG5cbiAgY29uc3QgZ2VuID0gY29kZUdlbmVyYXRvcihhc3QpOyAvLyBjb2xsZWN0IHNpZ25hbCBkZXBlbmRlbmNpZXNcblxuICBnZW4uZ2xvYmFscy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IHNpZ25hbE5hbWUgPSBTaWduYWxQcmVmaXggKyBuYW1lO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShwYXJhbXMsIHNpZ25hbE5hbWUpICYmIHNjb3BlLmdldFNpZ25hbChuYW1lKSkge1xuICAgICAgcGFyYW1zW3NpZ25hbE5hbWVdID0gc2NvcGUuc2lnbmFsUmVmKG5hbWUpO1xuICAgIH1cbiAgfSk7IC8vIHJldHVybiBnZW5lcmF0ZWQgZXhwcmVzc2lvbiBjb2RlIGFuZCBkZXBlbmRlbmNpZXNcblxuICByZXR1cm4ge1xuICAgICRleHByOiBleHRlbmQoe1xuICAgICAgY29kZTogZ2VuLmNvZGVcbiAgICB9LCBzY29wZS5vcHRpb25zLmFzdCA/IHtcbiAgICAgIGFzdFxuICAgIH0gOiBudWxsKSxcbiAgICAkZmllbGRzOiBnZW4uZmllbGRzLFxuICAgICRwYXJhbXM6IHBhcmFtc1xuICB9O1xufVxuXG5leHBvcnQgeyBEYXRhUHJlZml4LCBJbmRleFByZWZpeCwgU2NhbGVQcmVmaXgsIFNpZ25hbFByZWZpeCwgYmFuZHNwYWNlLCBiYW5kd2lkdGgsIGNvZGVHZW5lcmF0b3IsIGNvZGVnZW5QYXJhbXMsIGNvbnRhaW5lclNpemUsIGNvbnRyYXN0LCBjb3B5LCBkYXRhLCBkYXRhVmlzaXRvciwgZGF5QWJicmV2Rm9ybWF0LCBkYXlGb3JtYXQsIGRlYnVnLCBkb21haW4sIGVuY29kZSwgZXhwcmVzc2lvbkZ1bmN0aW9uLCBmb3JtYXQsIGZ1bmN0aW9uQ29udGV4dCwgZ2VvQXJlYSwgZ2VvQm91bmRzLCBnZW9DZW50cm9pZCwgZ2VvU2hhcGUsIGluU2NvcGUsIGluZGF0YSwgaW5kYXRhVmlzaXRvciwgaW5kZXhvZiwgaW5mbywgaW52ZXJ0LCBqb2luLCBsYXN0aW5kZXhvZiwgbHVtaW5hbmNlLCBtZXJnZSwgbW9kaWZ5LCBtb250aEFiYnJldkZvcm1hdCwgbW9udGhGb3JtYXQsIHBhcnNlciBhcyBwYXJzZUV4cHJlc3Npb24sIHBhdGhTaGFwZSwgcGluY2hBbmdsZSwgcGluY2hEaXN0YW5jZSwgcGx1Y2ssIHJhbmdlLCByZXBsYWNlLCByZXZlcnNlLCBzY2FsZSwgc2NhbGVHcmFkaWVudCwgc2NhbGVWaXNpdG9yLCBzY3JlZW4sIHNldGRhdGEsIHNsaWNlLCB0aW1lRm9ybWF0LCB0aW1lUGFyc2UsIHRyZWVBbmNlc3RvcnMsIHRyZWVQYXRoLCB1dGNGb3JtYXQsIHV0Y1BhcnNlLCB3YXJuLCB3aW5kb3dTaXplIH07XG4iLCJpbXBvcnQgeyBUcmFuc2Zvcm0sIHJlZGVyaXZlLCBpbmdlc3QsIHJlcGxhY2UgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGVycm9yLCBleHRlbnQsIGluaGVyaXRzLCBpZGVudGl0eSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGNvbnN0YW50LCBhcnJheSwgb25lLCBhY2Nlc3Nvck5hbWUsIGFjY2Vzc29yRmllbGRzLCBmaWVsZCwgZXh0ZW5kLCB0b1NldCwgemVybyB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyByYW5nZSwgdGlja1N0ZXAsIG1heCwgc3VtIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgYmFuZHdpZHRoTlJEIH0gZnJvbSAndmVnYS1zdGF0aXN0aWNzJztcbmltcG9ydCB7IGdldFByb2plY3Rpb25QYXRoLCBwcm9qZWN0aW9uUHJvcGVydGllcywgcHJvamVjdGlvbiB9IGZyb20gJ3ZlZ2EtcHJvamVjdGlvbic7XG5pbXBvcnQgeyBnZW9HcmF0aWN1bGUgfSBmcm9tICdkMy1nZW8nO1xuaW1wb3J0IHsgcmdiIH0gZnJvbSAnZDMtY29sb3InO1xuaW1wb3J0IHsgY2FudmFzIH0gZnJvbSAndmVnYS1jYW52YXMnO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuY29uc3QgY2FzZXMgPSBbW10sIFtbWzEuMCwgMS41XSwgWzAuNSwgMS4wXV1dLCBbW1sxLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSwgW1tbMS41LCAxLjBdLCBbMC41LCAxLjBdXV0sIFtbWzEuMCwgMC41XSwgWzEuNSwgMS4wXV1dLCBbW1sxLjAsIDEuNV0sIFswLjUsIDEuMF1dLCBbWzEuMCwgMC41XSwgWzEuNSwgMS4wXV1dLCBbW1sxLjAsIDAuNV0sIFsxLjAsIDEuNV1dXSwgW1tbMS4wLCAwLjVdLCBbMC41LCAxLjBdXV0sIFtbWzAuNSwgMS4wXSwgWzEuMCwgMC41XV1dLCBbW1sxLjAsIDEuNV0sIFsxLjAsIDAuNV1dXSwgW1tbMC41LCAxLjBdLCBbMS4wLCAwLjVdXSwgW1sxLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSwgW1tbMS41LCAxLjBdLCBbMS4wLCAwLjVdXV0sIFtbWzAuNSwgMS4wXSwgWzEuNSwgMS4wXV1dLCBbW1sxLjAsIDEuNV0sIFsxLjUsIDEuMF1dXSwgW1tbMC41LCAxLjBdLCBbMS4wLCAxLjVdXV0sIFtdXTsgLy8gSW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tIGQzL2QzLWNvbnRvdXIuIFRoYW5rcyFcblxuZnVuY3Rpb24gY29udG91cnMgKCkge1xuICB2YXIgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgc21vb3RoID0gc21vb3RoTGluZWFyO1xuXG4gIGZ1bmN0aW9uIGNvbnRvdXJzKHZhbHVlcywgdHopIHtcbiAgICByZXR1cm4gdHoubWFwKHZhbHVlID0+IGNvbnRvdXIodmFsdWVzLCB2YWx1ZSkpO1xuICB9IC8vIEFjY3VtdWxhdGUsIHNtb290aCBjb250b3VyIHJpbmdzLCBhc3NpZ24gaG9sZXMgdG8gZXh0ZXJpb3IgcmluZ3MuXG4gIC8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYm9zdG9jay9zaGFwZWZpbGUvYmxvYi92MC42LjIvc2hwL3BvbHlnb24uanNcblxuXG4gIGZ1bmN0aW9uIGNvbnRvdXIodmFsdWVzLCB2YWx1ZSkge1xuICAgIHZhciBwb2x5Z29ucyA9IFtdLFxuICAgICAgICBob2xlcyA9IFtdO1xuICAgIGlzb3JpbmdzKHZhbHVlcywgdmFsdWUsIHJpbmcgPT4ge1xuICAgICAgc21vb3RoKHJpbmcsIHZhbHVlcywgdmFsdWUpO1xuICAgICAgaWYgKGFyZWEocmluZykgPiAwKSBwb2x5Z29ucy5wdXNoKFtyaW5nXSk7ZWxzZSBob2xlcy5wdXNoKHJpbmcpO1xuICAgIH0pO1xuICAgIGhvbGVzLmZvckVhY2goaG9sZSA9PiB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb25zLmxlbmd0aCwgcG9seWdvbjsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoY29udGFpbnMoKHBvbHlnb24gPSBwb2x5Z29uc1tpXSlbMF0sIGhvbGUpICE9PSAtMSkge1xuICAgICAgICAgIHBvbHlnb24ucHVzaChob2xlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBjb29yZGluYXRlczogcG9seWdvbnNcbiAgICB9O1xuICB9IC8vIE1hcmNoaW5nIHNxdWFyZXMgd2l0aCBpc29saW5lcyBzdGl0Y2hlZCBpbnRvIHJpbmdzLlxuICAvLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdG9wb2pzb24vdG9wb2pzb24tY2xpZW50L2Jsb2IvdjMuMC4wL3NyYy9zdGl0Y2guanNcblxuXG4gIGZ1bmN0aW9uIGlzb3JpbmdzKHZhbHVlcywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZyYWdtZW50QnlTdGFydCA9IG5ldyBBcnJheSgpLFxuICAgICAgICBmcmFnbWVudEJ5RW5kID0gbmV3IEFycmF5KCksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHQwLFxuICAgICAgICB0MSxcbiAgICAgICAgdDIsXG4gICAgICAgIHQzOyAvLyBTcGVjaWFsIGNhc2UgZm9yIHRoZSBmaXJzdCByb3cgKHkgPSAtMSwgdDIgPSB0MyA9IDApLlxuXG4gICAgeCA9IHkgPSAtMTtcbiAgICB0MSA9IHZhbHVlc1swXSA+PSB2YWx1ZTtcbiAgICBjYXNlc1t0MSA8PCAxXS5mb3JFYWNoKHN0aXRjaCk7XG5cbiAgICB3aGlsZSAoKyt4IDwgZHggLSAxKSB7XG4gICAgICB0MCA9IHQxLCB0MSA9IHZhbHVlc1t4ICsgMV0gPj0gdmFsdWU7XG4gICAgICBjYXNlc1t0MCB8IHQxIDw8IDFdLmZvckVhY2goc3RpdGNoKTtcbiAgICB9XG5cbiAgICBjYXNlc1t0MSA8PCAwXS5mb3JFYWNoKHN0aXRjaCk7IC8vIEdlbmVyYWwgY2FzZSBmb3IgdGhlIGludGVybWVkaWF0ZSByb3dzLlxuXG4gICAgd2hpbGUgKCsreSA8IGR5IC0gMSkge1xuICAgICAgeCA9IC0xO1xuICAgICAgdDEgPSB2YWx1ZXNbeSAqIGR4ICsgZHhdID49IHZhbHVlO1xuICAgICAgdDIgPSB2YWx1ZXNbeSAqIGR4XSA+PSB2YWx1ZTtcbiAgICAgIGNhc2VzW3QxIDw8IDEgfCB0MiA8PCAyXS5mb3JFYWNoKHN0aXRjaCk7XG5cbiAgICAgIHdoaWxlICgrK3ggPCBkeCAtIDEpIHtcbiAgICAgICAgdDAgPSB0MSwgdDEgPSB2YWx1ZXNbeSAqIGR4ICsgZHggKyB4ICsgMV0gPj0gdmFsdWU7XG4gICAgICAgIHQzID0gdDIsIHQyID0gdmFsdWVzW3kgKiBkeCArIHggKyAxXSA+PSB2YWx1ZTtcbiAgICAgICAgY2FzZXNbdDAgfCB0MSA8PCAxIHwgdDIgPDwgMiB8IHQzIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcbiAgICAgIH1cblxuICAgICAgY2FzZXNbdDEgfCB0MiA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgfSAvLyBTcGVjaWFsIGNhc2UgZm9yIHRoZSBsYXN0IHJvdyAoeSA9IGR5IC0gMSwgdDAgPSB0MSA9IDApLlxuXG5cbiAgICB4ID0gLTE7XG4gICAgdDIgPSB2YWx1ZXNbeSAqIGR4XSA+PSB2YWx1ZTtcbiAgICBjYXNlc1t0MiA8PCAyXS5mb3JFYWNoKHN0aXRjaCk7XG5cbiAgICB3aGlsZSAoKyt4IDwgZHggLSAxKSB7XG4gICAgICB0MyA9IHQyLCB0MiA9IHZhbHVlc1t5ICogZHggKyB4ICsgMV0gPj0gdmFsdWU7XG4gICAgICBjYXNlc1t0MiA8PCAyIHwgdDMgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuICAgIH1cblxuICAgIGNhc2VzW3QyIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcblxuICAgIGZ1bmN0aW9uIHN0aXRjaChsaW5lKSB7XG4gICAgICB2YXIgc3RhcnQgPSBbbGluZVswXVswXSArIHgsIGxpbmVbMF1bMV0gKyB5XSxcbiAgICAgICAgICBlbmQgPSBbbGluZVsxXVswXSArIHgsIGxpbmVbMV1bMV0gKyB5XSxcbiAgICAgICAgICBzdGFydEluZGV4ID0gaW5kZXgoc3RhcnQpLFxuICAgICAgICAgIGVuZEluZGV4ID0gaW5kZXgoZW5kKSxcbiAgICAgICAgICBmLFxuICAgICAgICAgIGc7XG5cbiAgICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydEluZGV4XSkge1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRJbmRleF0pIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcblxuICAgICAgICAgIGlmIChmID09PSBnKSB7XG4gICAgICAgICAgICBmLnJpbmcucHVzaChlbmQpO1xuICAgICAgICAgICAgY2FsbGJhY2soZi5yaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtnLmVuZF0gPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBmLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGcuZW5kLFxuICAgICAgICAgICAgICByaW5nOiBmLnJpbmcuY29uY2F0KGcucmluZylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgICAgICBmLnJpbmcucHVzaChlbmQpO1xuICAgICAgICAgIGZyYWdtZW50QnlFbmRbZi5lbmQgPSBlbmRJbmRleF0gPSBmO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGYgPSBmcmFnbWVudEJ5U3RhcnRbZW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChnID0gZnJhZ21lbnRCeUVuZFtzdGFydEluZGV4XSkge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuXG4gICAgICAgICAgaWYgKGYgPT09IGcpIHtcbiAgICAgICAgICAgIGYucmluZy5wdXNoKGVuZCk7XG4gICAgICAgICAgICBjYWxsYmFjayhmLnJpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGcuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogZi5lbmQsXG4gICAgICAgICAgICAgIHJpbmc6IGcucmluZy5jb25jYXQoZi5yaW5nKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgICAgICBmLnJpbmcudW5zaGlmdChzdGFydCk7XG4gICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydEluZGV4XSA9IGY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtzdGFydEluZGV4XSA9IGZyYWdtZW50QnlFbmRbZW5kSW5kZXhdID0ge1xuICAgICAgICAgIHN0YXJ0OiBzdGFydEluZGV4LFxuICAgICAgICAgIGVuZDogZW5kSW5kZXgsXG4gICAgICAgICAgcmluZzogW3N0YXJ0LCBlbmRdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXgocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMF0gKiAyICsgcG9pbnRbMV0gKiAoZHggKyAxKSAqIDQ7XG4gIH1cblxuICBmdW5jdGlvbiBzbW9vdGhMaW5lYXIocmluZywgdmFsdWVzLCB2YWx1ZSkge1xuICAgIHJpbmcuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICB2YXIgeCA9IHBvaW50WzBdLFxuICAgICAgICAgIHkgPSBwb2ludFsxXSxcbiAgICAgICAgICB4dCA9IHggfCAwLFxuICAgICAgICAgIHl0ID0geSB8IDAsXG4gICAgICAgICAgdjAsXG4gICAgICAgICAgdjEgPSB2YWx1ZXNbeXQgKiBkeCArIHh0XTtcblxuICAgICAgaWYgKHggPiAwICYmIHggPCBkeCAmJiB4dCA9PT0geCkge1xuICAgICAgICB2MCA9IHZhbHVlc1t5dCAqIGR4ICsgeHQgLSAxXTtcbiAgICAgICAgcG9pbnRbMF0gPSB4ICsgKHZhbHVlIC0gdjApIC8gKHYxIC0gdjApIC0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAoeSA+IDAgJiYgeSA8IGR5ICYmIHl0ID09PSB5KSB7XG4gICAgICAgIHYwID0gdmFsdWVzWyh5dCAtIDEpICogZHggKyB4dF07XG4gICAgICAgIHBvaW50WzFdID0geSArICh2YWx1ZSAtIHYwKSAvICh2MSAtIHYwKSAtIDAuNTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnRvdXJzLmNvbnRvdXIgPSBjb250b3VyO1xuXG4gIGNvbnRvdXJzLnNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtkeCwgZHldO1xuXG4gICAgdmFyIF8wID0gTWF0aC5mbG9vcihfWzBdKSxcbiAgICAgICAgXzEgPSBNYXRoLmZsb29yKF9bMV0pO1xuXG4gICAgaWYgKCEoXzAgPj0gMCAmJiBfMSA+PSAwKSkgZXJyb3IoJ2ludmFsaWQgc2l6ZScpO1xuICAgIHJldHVybiBkeCA9IF8wLCBkeSA9IF8xLCBjb250b3VycztcbiAgfTtcblxuICBjb250b3Vycy5zbW9vdGggPSBmdW5jdGlvbiAoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNtb290aCA9IF8gPyBzbW9vdGhMaW5lYXIgOiBub29wLCBjb250b3VycykgOiBzbW9vdGggPT09IHNtb290aExpbmVhcjtcbiAgfTtcblxuICByZXR1cm4gY29udG91cnM7XG59XG5cbmZ1bmN0aW9uIGFyZWEocmluZykge1xuICB2YXIgaSA9IDAsXG4gICAgICBuID0gcmluZy5sZW5ndGgsXG4gICAgICBhcmVhID0gcmluZ1tuIC0gMV1bMV0gKiByaW5nWzBdWzBdIC0gcmluZ1tuIC0gMV1bMF0gKiByaW5nWzBdWzFdO1xuXG4gIHdoaWxlICgrK2kgPCBuKSBhcmVhICs9IHJpbmdbaSAtIDFdWzFdICogcmluZ1tpXVswXSAtIHJpbmdbaSAtIDFdWzBdICogcmluZ1tpXVsxXTtcblxuICByZXR1cm4gYXJlYTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocmluZywgaG9sZSkge1xuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IGhvbGUubGVuZ3RoLFxuICAgICAgYztcblxuICB3aGlsZSAoKytpIDwgbikgaWYgKGMgPSByaW5nQ29udGFpbnMocmluZywgaG9sZVtpXSkpIHJldHVybiBjO1xuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiByaW5nQ29udGFpbnMocmluZywgcG9pbnQpIHtcbiAgdmFyIHggPSBwb2ludFswXSxcbiAgICAgIHkgPSBwb2ludFsxXSxcbiAgICAgIGNvbnRhaW5zID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSByaW5nLmxlbmd0aCwgaiA9IG4gLSAxOyBpIDwgbjsgaiA9IGkrKykge1xuICAgIHZhciBwaSA9IHJpbmdbaV0sXG4gICAgICAgIHhpID0gcGlbMF0sXG4gICAgICAgIHlpID0gcGlbMV0sXG4gICAgICAgIHBqID0gcmluZ1tqXSxcbiAgICAgICAgeGogPSBwalswXSxcbiAgICAgICAgeWogPSBwalsxXTtcbiAgICBpZiAoc2VnbWVudENvbnRhaW5zKHBpLCBwaiwgcG9pbnQpKSByZXR1cm4gMDtcbiAgICBpZiAoeWkgPiB5ICE9PSB5aiA+IHkgJiYgeCA8ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGkpIGNvbnRhaW5zID0gLWNvbnRhaW5zO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5zO1xufVxuXG5mdW5jdGlvbiBzZWdtZW50Q29udGFpbnMoYSwgYiwgYykge1xuICB2YXIgaTtcbiAgcmV0dXJuIGNvbGxpbmVhcihhLCBiLCBjKSAmJiB3aXRoaW4oYVtpID0gKyhhWzBdID09PSBiWzBdKV0sIGNbaV0sIGJbaV0pO1xufVxuXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSwgYiwgYykge1xuICByZXR1cm4gKGJbMF0gLSBhWzBdKSAqIChjWzFdIC0gYVsxXSkgPT09IChjWzBdIC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pO1xufVxuXG5mdW5jdGlvbiB3aXRoaW4ocCwgcSwgcikge1xuICByZXR1cm4gcCA8PSBxICYmIHEgPD0gciB8fCByIDw9IHEgJiYgcSA8PSBwO1xufVxuXG5mdW5jdGlvbiBxdWFudGl6ZSAoaywgbmljZSwgemVybykge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHZhciBleCA9IGV4dGVudCh2YWx1ZXMpLFxuICAgICAgICBzdGFydCA9IHplcm8gPyBNYXRoLm1pbihleFswXSwgMCkgOiBleFswXSxcbiAgICAgICAgc3RvcCA9IGV4WzFdLFxuICAgICAgICBzcGFuID0gc3RvcCAtIHN0YXJ0LFxuICAgICAgICBzdGVwID0gbmljZSA/IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBrKSA6IHNwYW4gLyAoayArIDEpO1xuICAgIHJldHVybiByYW5nZShzdGFydCArIHN0ZXAsIHN0b3AsIHN0ZXApO1xuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGlzb2NvbnRvdXJzIChsZXZlbCBzZXRzKSBiYXNlZCBvbiBpbnB1dCByYXN0ZXIgZ3JpZCBkYXRhLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IFtwYXJhbXMuZmllbGRdIC0gVGhlIGZpZWxkIHdpdGggcmFzdGVyIGdyaWRcbiAqICAgZGF0YS4gSWYgdW5zcGVjaWZpZWQsIHRoZSB0dXBsZSBpdHNlbGYgaXMgaW50ZXJwcmV0ZWQgYXMgYSByYXN0ZXIgZ3JpZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy50aHJlc2hvbGRzXSAtIENvbnRvdXIgdGhyZXNob2xkIGFycmF5LiBJZlxuICogICBzcGVjaWZpZWQsIHRoZSBsZXZlbHMsIG5pY2UsIHJlc29sdmUsIGFuZCB6ZXJvIHBhcmFtZXRlcnMgYXJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5sZXZlbHNdIC0gVGhlIGRlc2lyZWQgbnVtYmVyIG9mIGNvbnRvdXIgbGV2ZWxzLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLm5pY2VdIC0gQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGNvbnRvdXJcbiAqICAgdGhyZXNob2xkIHZhbHVlcyBzaG91bGQgYmUgYXV0b21hdGljYWxseSBhbGlnbmVkIHRvIFwibmljZVwiXG4gKiAgIGh1bWFuLWZyaWVuZGx5IHZhbHVlcy4gU2V0dGluZyB0aGlzIGZsYWcgbWF5IGNhdXNlIHRoZSBudW1iZXIgb2ZcbiAqICAgdGhyZXNob2xkcyB0byBkZXZpYXRlIGZyb20gdGhlIHNwZWNpZmllZCBsZXZlbHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5yZXNvbHZlXSAtIFRoZSBtZXRob2QgZm9yIHJlc29sdmluZyB0aHJlc2hvbGRzXG4gKiAgIGFjcm9zcyBtdWx0aXBsZSBpbnB1dCBncmlkcy4gSWYgJ2luZGVwZW5kZW50JyAodGhlIGRlZmF1bHQpLCB0aHJlc2hvbGRcbiAqICAgY2FsY3VsYXRpb24gd2lsbCBiZSBwZXJmb3JtZWQgc2VwYXJhdGVseSBmb3IgZWFjaCBncmlkLiBJZiAnc2hhcmVkJywgYVxuICogICBzaW5nbGUgc2V0IG9mIHRocmVzaG9sZCB2YWx1ZXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgaW5wdXQgZ3JpZHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuemVyb10gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgY29udG91clxuICogICB0aHJlc2hvbGQgdmFsdWVzIHNob3VsZCBpbmNsdWRlIHplcm8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc21vb3RoXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBjb250b3VyXG4gKiAgIHBvbHlnb25zIHNob3VsZCBiZSBzbW9vdGhlZCB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi4gVGhlIGRlZmF1bHQgaXNcbiAqICAgdHJ1ZS4gVGhlIHBhcmFtZXRlciBpcyBpZ25vcmVkIHdoZW4gdXNpbmcgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLnNjYWxlXSAtIE9wdGlvbmFsIG51bWVyaWNhbCB2YWx1ZSBieSB3aGljaCB0b1xuICogICBzY2FsZSB0aGUgb3V0cHV0IGlzb2NvbnRvdXIgY29vcmRpbmF0ZXMuIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSB1c2VmdWxcbiAqICAgdG8gc2NhbGUgdGhlIGNvbnRvdXJzIHRvIG1hdGNoIGEgZGVzaXJlZCBvdXRwdXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmFzPSdjb250b3VyJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgaXNvY29udG91ciBkYXRhIChkZWZhdWx0ICdjb250b3VyJykuXG4gKi9cblxuZnVuY3Rpb24gSXNvY29udG91cihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbklzb2NvbnRvdXIuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnSXNvY29udG91cicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0aHJlc2hvbGRzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2xldmVscycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnbmljZScsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncmVzb2x2ZScsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ3ZhbHVlcyc6IFsnc2hhcmVkJywgJ2luZGVwZW5kZW50J10sXG4gICAgJ2RlZmF1bHQnOiAnaW5kZXBlbmRlbnQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd6ZXJvJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3Ntb290aCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzY2FsZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3RyYW5zbGF0ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdkZWZhdWx0JzogJ2NvbnRvdXInXG4gIH1dXG59O1xuaW5oZXJpdHMoSXNvY29udG91ciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFwdWxzZS5jaGFuZ2VkKCkgJiYgIV8ubW9kaWZpZWQoKSkge1xuICAgICAgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgICAgZmllbGQgPSBfLmZpZWxkIHx8IGlkZW50aXR5LFxuICAgICAgICBjb250b3VyID0gY29udG91cnMoKS5zbW9vdGgoXy5zbW9vdGggIT09IGZhbHNlKSxcbiAgICAgICAgdHogPSBfLnRocmVzaG9sZHMgfHwgbGV2ZWxzKHNvdXJjZSwgZmllbGQsIF8pLFxuICAgICAgICBhcyA9IF8uYXMgPT09IG51bGwgPyBudWxsIDogXy5hcyB8fCAnY29udG91cicsXG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgIHNvdXJjZS5mb3JFYWNoKHQgPT4ge1xuICAgICAgY29uc3QgZ3JpZCA9IGZpZWxkKHQpOyAvLyBnZW5lcmF0ZSBjb250b3VyIHBhdGhzIGluIEdlb0pTT04gZm9ybWF0XG5cbiAgICAgIGNvbnN0IHBhdGhzID0gY29udG91ci5zaXplKFtncmlkLndpZHRoLCBncmlkLmhlaWdodF0pKGdyaWQudmFsdWVzLCBpc0FycmF5KHR6KSA/IHR6IDogdHooZ3JpZC52YWx1ZXMpKTsgLy8gYWRqdXN0IGNvbnRvdXIgcGF0aCBjb29yZGluYXRlcyBhcyBuZWVkZWRcblxuICAgICAgdHJhbnNmb3JtUGF0aHMocGF0aHMsIGdyaWQsIHQsIF8pOyAvLyBpbmdlc3Q7IGNvcHkgc291cmNlIGRhdGEgcHJvcGVydGllcyB0byBvdXRwdXRcblxuICAgICAgcGF0aHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgdmFsdWVzLnB1c2gocmVkZXJpdmUodCwgaW5nZXN0KGFzICE9IG51bGwgPyB7XG4gICAgICAgICAgW2FzXTogcFxuICAgICAgICB9IDogcCkpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnZhbHVlKSBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IG91dC5hZGQgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gbGV2ZWxzKHZhbHVlcywgZiwgXykge1xuICBjb25zdCBxID0gcXVhbnRpemUoXy5sZXZlbHMgfHwgMTAsIF8ubmljZSwgXy56ZXJvICE9PSBmYWxzZSk7XG4gIHJldHVybiBfLnJlc29sdmUgIT09ICdzaGFyZWQnID8gcSA6IHEodmFsdWVzLm1hcCh0ID0+IG1heChmKHQpLnZhbHVlcykpKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUGF0aHMocGF0aHMsIGdyaWQsIGRhdHVtLCBfKSB7XG4gIGxldCBzID0gXy5zY2FsZSB8fCBncmlkLnNjYWxlLFxuICAgICAgdCA9IF8udHJhbnNsYXRlIHx8IGdyaWQudHJhbnNsYXRlO1xuICBpZiAoaXNGdW5jdGlvbihzKSkgcyA9IHMoZGF0dW0sIF8pO1xuICBpZiAoaXNGdW5jdGlvbih0KSkgdCA9IHQoZGF0dW0sIF8pO1xuICBpZiAoKHMgPT09IDEgfHwgcyA9PSBudWxsKSAmJiAhdCkgcmV0dXJuO1xuICBjb25zdCBzeCA9IChpc051bWJlcihzKSA/IHMgOiBzWzBdKSB8fCAxLFxuICAgICAgICBzeSA9IChpc051bWJlcihzKSA/IHMgOiBzWzFdKSB8fCAxLFxuICAgICAgICB0eCA9IHQgJiYgdFswXSB8fCAwLFxuICAgICAgICB0eSA9IHQgJiYgdFsxXSB8fCAwO1xuICBwYXRocy5mb3JFYWNoKHRyYW5zZm9ybShncmlkLCBzeCwgc3ksIHR4LCB0eSkpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm0oZ3JpZCwgc3gsIHN5LCB0eCwgdHkpIHtcbiAgY29uc3QgeDEgPSBncmlkLngxIHx8IDAsXG4gICAgICAgIHkxID0gZ3JpZC55MSB8fCAwLFxuICAgICAgICBmbGlwID0gc3ggKiBzeSA8IDA7XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUG9seWdvbihjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtUmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1SaW5nKGNvb3JkaW5hdGVzKSB7XG4gICAgaWYgKGZsaXApIGNvb3JkaW5hdGVzLnJldmVyc2UoKTsgLy8gbWFpbnRhaW4gd2luZGluZyBvcmRlclxuXG4gICAgY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm1Qb2ludCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzWzBdID0gKGNvb3JkaW5hdGVzWzBdIC0geDEpICogc3ggKyB0eDtcbiAgICBjb29yZGluYXRlc1sxXSA9IChjb29yZGluYXRlc1sxXSAtIHkxKSAqIHN5ICsgdHk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm1Qb2x5Z29uKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJhZGl1cyhidywgZGF0YSwgZikge1xuICBjb25zdCB2ID0gYncgPj0gMCA/IGJ3IDogYmFuZHdpZHRoTlJEKGRhdGEsIGYpO1xuICByZXR1cm4gTWF0aC5yb3VuZCgoTWF0aC5zcXJ0KDQgKiB2ICogdiArIDEpIC0gMSkgLyAyKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKF8pIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oXykgPyBfIDogY29uc3RhbnQoK18pO1xufSAvLyBJbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb20gZDMvZDMtY29udG91ci4gVGhhbmtzIVxuXG5cbmZ1bmN0aW9uIGRlbnNpdHkyRCAoKSB7XG4gIHZhciB4ID0gZCA9PiBkWzBdLFxuICAgICAgeSA9IGQgPT4gZFsxXSxcbiAgICAgIHdlaWdodCA9IG9uZSxcbiAgICAgIGJhbmR3aWR0aCA9IFstMSwgLTFdLFxuICAgICAgZHggPSA5NjAsXG4gICAgICBkeSA9IDUwMCxcbiAgICAgIGsgPSAyOyAvLyBsb2cyKGNlbGxTaXplKVxuXG5cbiAgZnVuY3Rpb24gZGVuc2l0eShkYXRhLCBjb3VudHMpIHtcbiAgICBjb25zdCByeCA9IHJhZGl1cyhiYW5kd2lkdGhbMF0sIGRhdGEsIHgpID4+IGssXG4gICAgICAgICAgLy8gYmx1ciB4LXJhZGl1c1xuICAgIHJ5ID0gcmFkaXVzKGJhbmR3aWR0aFsxXSwgZGF0YSwgeSkgPj4gayxcbiAgICAgICAgICAvLyBibHVyIHktcmFkaXVzXG4gICAgb3ggPSByeCA/IHJ4ICsgMiA6IDAsXG4gICAgICAgICAgLy8geC1vZmZzZXQgcGFkZGluZyBmb3IgYmx1clxuICAgIG95ID0gcnkgPyByeSArIDIgOiAwLFxuICAgICAgICAgIC8vIHktb2Zmc2V0IHBhZGRpbmcgZm9yIGJsdXJcbiAgICBuID0gMiAqIG94ICsgKGR4ID4+IGspLFxuICAgICAgICAgIC8vIGdyaWQgd2lkdGhcbiAgICBtID0gMiAqIG95ICsgKGR5ID4+IGspLFxuICAgICAgICAgIC8vIGdyaWQgaGVpZ2h0XG4gICAgdmFsdWVzMCA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIG0pLFxuICAgICAgICAgIHZhbHVlczEgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBtKTtcbiAgICBsZXQgdmFsdWVzID0gdmFsdWVzMDtcbiAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICBjb25zdCB4aSA9IG94ICsgKCt4KGQpID4+IGspLFxuICAgICAgICAgICAgeWkgPSBveSArICgreShkKSA+PiBrKTtcblxuICAgICAgaWYgKHhpID49IDAgJiYgeGkgPCBuICYmIHlpID49IDAgJiYgeWkgPCBtKSB7XG4gICAgICAgIHZhbHVlczBbeGkgKyB5aSAqIG5dICs9ICt3ZWlnaHQoZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocnggPiAwICYmIHJ5ID4gMCkge1xuICAgICAgYmx1clgobiwgbSwgdmFsdWVzMCwgdmFsdWVzMSwgcngpO1xuICAgICAgYmx1clkobiwgbSwgdmFsdWVzMSwgdmFsdWVzMCwgcnkpO1xuICAgICAgYmx1clgobiwgbSwgdmFsdWVzMCwgdmFsdWVzMSwgcngpO1xuICAgICAgYmx1clkobiwgbSwgdmFsdWVzMSwgdmFsdWVzMCwgcnkpO1xuICAgICAgYmx1clgobiwgbSwgdmFsdWVzMCwgdmFsdWVzMSwgcngpO1xuICAgICAgYmx1clkobiwgbSwgdmFsdWVzMSwgdmFsdWVzMCwgcnkpO1xuICAgIH0gZWxzZSBpZiAocnggPiAwKSB7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeCk7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMxO1xuICAgIH0gZWxzZSBpZiAocnkgPiAwKSB7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeSk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeSk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeSk7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMxO1xuICAgIH0gLy8gc2NhbGUgZGVuc2l0eSBlc3RpbWF0ZXNcbiAgICAvLyBkZW5zaXR5IGluIHBvaW50cyBwZXIgc3F1YXJlIHBpeGVsIG9yIHByb2JhYmlsaXR5IGRlbnNpdHlcblxuXG4gICAgY29uc3QgcyA9IGNvdW50cyA/IE1hdGgucG93KDIsIC0yICogaykgOiAxIC8gc3VtKHZhbHVlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgc3ogPSBuICogbTsgaSA8IHN6OyArK2kpIHZhbHVlc1tpXSAqPSBzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgc2NhbGU6IDEgPDwgayxcbiAgICAgIHdpZHRoOiBuLFxuICAgICAgaGVpZ2h0OiBtLFxuICAgICAgeDE6IG94LFxuICAgICAgeTE6IG95LFxuICAgICAgeDI6IG94ICsgKGR4ID4+IGspLFxuICAgICAgeTI6IG95ICsgKGR5ID4+IGspXG4gICAgfTtcbiAgfVxuXG4gIGRlbnNpdHkueCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IG51bWJlcihfKSwgZGVuc2l0eSkgOiB4O1xuICB9O1xuXG4gIGRlbnNpdHkueSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IG51bWJlcihfKSwgZGVuc2l0eSkgOiB5O1xuICB9O1xuXG4gIGRlbnNpdHkud2VpZ2h0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3ZWlnaHQgPSBudW1iZXIoXyksIGRlbnNpdHkpIDogd2VpZ2h0O1xuICB9O1xuXG4gIGRlbnNpdHkuc2l6ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW2R4LCBkeV07XG5cbiAgICB2YXIgXzAgPSArX1swXSxcbiAgICAgICAgXzEgPSArX1sxXTtcblxuICAgIGlmICghKF8wID49IDAgJiYgXzEgPj0gMCkpIGVycm9yKCdpbnZhbGlkIHNpemUnKTtcbiAgICByZXR1cm4gZHggPSBfMCwgZHkgPSBfMSwgZGVuc2l0eTtcbiAgfTtcblxuICBkZW5zaXR5LmNlbGxTaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAxIDw8IGs7XG4gICAgaWYgKCEoKF8gPSArXykgPj0gMSkpIGVycm9yKCdpbnZhbGlkIGNlbGwgc2l6ZScpO1xuICAgIGsgPSBNYXRoLmZsb29yKE1hdGgubG9nKF8pIC8gTWF0aC5MTjIpO1xuICAgIHJldHVybiBkZW5zaXR5O1xuICB9O1xuXG4gIGRlbnNpdHkuYmFuZHdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiYW5kd2lkdGg7XG4gICAgXyA9IGFycmF5KF8pO1xuICAgIGlmIChfLmxlbmd0aCA9PT0gMSkgXyA9IFsrX1swXSwgK19bMF1dO1xuICAgIGlmIChfLmxlbmd0aCAhPT0gMikgZXJyb3IoJ2ludmFsaWQgYmFuZHdpZHRoJyk7XG4gICAgcmV0dXJuIGJhbmR3aWR0aCA9IF8sIGRlbnNpdHk7XG4gIH07XG5cbiAgcmV0dXJuIGRlbnNpdHk7XG59XG5cbmZ1bmN0aW9uIGJsdXJYKG4sIG0sIHNvdXJjZSwgdGFyZ2V0LCByKSB7XG4gIGNvbnN0IHcgPSAociA8PCAxKSArIDE7XG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKGxldCBpID0gMCwgc3IgPSAwOyBpIDwgbiArIHI7ICsraSkge1xuICAgICAgaWYgKGkgPCBuKSB7XG4gICAgICAgIHNyICs9IHNvdXJjZVtpICsgaiAqIG5dO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+PSByKSB7XG4gICAgICAgIGlmIChpID49IHcpIHtcbiAgICAgICAgICBzciAtPSBzb3VyY2VbaSAtIHcgKyBqICogbl07XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRbaSAtIHIgKyBqICogbl0gPSBzciAvIE1hdGgubWluKGkgKyAxLCBuIC0gMSArIHcgLSBpLCB3KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmx1clkobiwgbSwgc291cmNlLCB0YXJnZXQsIHIpIHtcbiAgY29uc3QgdyA9IChyIDw8IDEpICsgMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwLCBzciA9IDA7IGogPCBtICsgcjsgKytqKSB7XG4gICAgICBpZiAoaiA8IG0pIHtcbiAgICAgICAgc3IgKz0gc291cmNlW2kgKyBqICogbl07XG4gICAgICB9XG5cbiAgICAgIGlmIChqID49IHIpIHtcbiAgICAgICAgaWYgKGogPj0gdykge1xuICAgICAgICAgIHNyIC09IHNvdXJjZVtpICsgKGogLSB3KSAqIG5dO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0W2kgKyAoaiAtIHIpICogbl0gPSBzciAvIE1hdGgubWluKGogKyAxLCBtIC0gMSArIHcgLSBqLCB3KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtIDJEIGtlcm5lbC1kZW5zaXR5IGVzdGltYXRpb24gb2YgcG9pbnQgZGF0YS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYXJhbXMuc2l6ZSAtIFRoZSBbd2lkdGgsIGhlaWdodF0gZXh0ZW50IChpblxuICogICB1bml0cyBvZiBpbnB1dCBwaXhlbHMpIG92ZXIgd2hpY2ggdG8gcGVyZm9ybSBkZW5zaXR5IGVzdGltYXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG51bWJlcn0gcGFyYW1zLnggLSBUaGUgeC1jb29yZGluYXRlIGFjY2Vzc29yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBudW1iZXJ9IHBhcmFtcy55IC0gVGhlIHktY29vcmRpbmF0ZSBhY2Nlc3Nvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogbnVtYmVyfSBbcGFyYW1zLndlaWdodF0gLSBUaGUgd2VpZ2h0IGFjY2Vzc29yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29yc1xuICogICB0byBncm91cGJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuY2VsbFNpemVdIC0gQ29udG91ciBkZW5zaXR5IGNhbGN1bGF0aW9uIGNlbGwgc2l6ZS5cbiAqICAgVGhpcyBwYXJhbWV0ZXIgZGV0ZXJtaW5lcyB0aGUgbGV2ZWwgb2Ygc3BhdGlhbCBhcHByb3hpbWF0aW9uLiBGb3IgZXhhbXBsZSxcbiAqICAgdGhlIGRlZmF1bHQgdmFsdWUgb2YgNCBtYXBzIHRvIDJ4IHJlZHVjdGlvbnMgaW4gYm90aCB4LSBhbmQgeS0gZGltZW5zaW9ucy5cbiAqICAgQSB2YWx1ZSBvZiAxIHdpbGwgcmVzdWx0IGluIGFuIG91dHB1dCByYXN0ZXIgZ3JpZCB3aG9zZSBkaW1lbnNpb25zIGV4YWN0bHlcbiAqICAgbWF0Y2hlcyB0aGUgc2l6ZSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMuYmFuZHdpZHRoXSAtIFRoZSBLREUga2VybmVsIGJhbmR3aWR0aHMsXG4gKiAgIGluIHBpeGVscy4gVGhlIGlucHV0IGNhbiBiZSBhIHR3by1lbGVtZW50IGFycmF5IHNwZWNpZnlpbmcgc2VwYXJhdGVcbiAqICAgeCBhbmQgeSBiYW5kd2lkdGhzLCBvciBhIHNpbmdsZS1lbGVtZW50IGFycmF5IHNwZWNpZnlpbmcgYm90aC4gSWYgdGhlXG4gKiAgIGJhbmR3aWR0aCBpcyB1bnNwZWNpZmllZCBvciBsZXNzIHRoYW4gemVybywgdGhlIGJhbmR3aWR0aCB3aWxsIGJlXG4gKiAgIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5jb3VudHM9ZmFsc2VdIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGVcbiAqICAgb3V0cHV0IHZhbHVlcyBzaG91bGQgYmUgcHJvYmFiaWxpdHkgZXN0aW1hdGVzIChmYWxzZSwgZGVmYXVsdCkgb3JcbiAqICAgc21vb3RoZWQgY291bnRzICh0cnVlKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmFzPSdncmlkJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgcmFzdGVyIGdyaWQgKGRlZmF1bHQgJ2dyaWQnKS5cbiAqL1xuXG5mdW5jdGlvbiBLREUyRChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbktERTJELkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0tERTJEJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd4JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAneScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3dlaWdodCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnY2VsbFNpemUnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ2JhbmR3aWR0aCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdjb3VudHMnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ2dyaWQnXG4gIH1dXG59O1xuY29uc3QgUEFSQU1TID0gWyd4JywgJ3knLCAnd2VpZ2h0JywgJ3NpemUnLCAnY2VsbFNpemUnLCAnYmFuZHdpZHRoJ107XG5mdW5jdGlvbiBwYXJhbXMob2JqLCBfKSB7XG4gIFBBUkFNUy5mb3JFYWNoKHBhcmFtID0+IF9bcGFyYW1dICE9IG51bGwgPyBvYmpbcGFyYW1dKF9bcGFyYW1dKSA6IDApO1xuICByZXR1cm4gb2JqO1xufVxuaW5oZXJpdHMoS0RFMkQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhcHVsc2UuY2hhbmdlZCgpICYmICFfLm1vZGlmaWVkKCkpIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgdmFyIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSxcbiAgICAgICAgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbihzb3VyY2UsIF8uZ3JvdXBieSksXG4gICAgICAgIG5hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgIGtkZSA9IHBhcmFtcyhkZW5zaXR5MkQoKSwgXyksXG4gICAgICAgIGFzID0gXy5hcyB8fCAnZ3JpZCcsXG4gICAgICAgIHZhbHVlcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc2V0KHQsIHZhbHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHRbbmFtZXNbaV1dID0gdmFsc1tpXTtcblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfSAvLyBnZW5lcmF0ZSBkZW5zaXR5IHJhc3RlciBncmlkc1xuXG5cbiAgICB2YWx1ZXMgPSBncm91cHMubWFwKGcgPT4gaW5nZXN0KHNldCh7XG4gICAgICBbYXNdOiBrZGUoZywgXy5jb3VudHMpXG4gICAgfSwgZy5kaW1zKSkpO1xuICAgIGlmICh0aGlzLnZhbHVlKSBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IG91dC5hZGQgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcbmZ1bmN0aW9uIHBhcnRpdGlvbihkYXRhLCBncm91cGJ5KSB7XG4gIHZhciBncm91cHMgPSBbXSxcbiAgICAgIGdldCA9IGYgPT4gZih0KSxcbiAgICAgIG1hcCxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgdCxcbiAgICAgIGssXG4gICAgICBnOyAvLyBwYXJ0aXRpb24gZGF0YSBwb2ludHMgaW50byBncm91cHNcblxuXG4gIGlmIChncm91cGJ5ID09IG51bGwpIHtcbiAgICBncm91cHMucHVzaChkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcCA9IHt9LCBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gZGF0YVtpXTtcbiAgICAgIGsgPSBncm91cGJ5Lm1hcChnZXQpO1xuICAgICAgZyA9IG1hcFtrXTtcblxuICAgICAgaWYgKCFnKSB7XG4gICAgICAgIG1hcFtrXSA9IGcgPSBbXTtcbiAgICAgICAgZy5kaW1zID0gaztcbiAgICAgICAgZ3JvdXBzLnB1c2goZyk7XG4gICAgICB9XG5cbiAgICAgIGcucHVzaCh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ3JvdXBzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGNvbnRvdXJzIGJhc2VkIG9uIGtlcm5lbC1kZW5zaXR5IGVzdGltYXRpb24gb2YgcG9pbnQgZGF0YS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYXJhbXMuc2l6ZSAtIFRoZSBkaW1lbnNpb25zIFt3aWR0aCwgaGVpZ2h0XSBvdmVyIHdoaWNoIHRvIGNvbXB1dGUgY29udG91cnMuXG4gKiAgSWYgdGhlIHZhbHVlcyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoaXMgbXVzdCBiZSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgZGF0YS5cbiAqICBJZiBkZW5zaXR5IGVzdGltYXRpb24gaXMgcGVyZm9ybWVkLCB0aGlzIGlzIHRoZSBvdXRwdXQgdmlldyBkaW1lbnNpb25zIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy52YWx1ZXNdIC0gQW4gYXJyYXkgb2YgbnVtZXJpYyB2YWx1ZXMgcmVwcmVzZW50aW5nIGFuXG4gKiAgd2lkdGggeCBoZWlnaHQgZ3JpZCBvZiB2YWx1ZXMgb3ZlciB3aGljaCB0byBjb21wdXRlIGNvbnRvdXJzLiBJZiB1bnNwZWNpZmllZCwgdGhpc1xuICogIHRyYW5zZm9ybSB3aWxsIGluc3RlYWQgYXR0ZW1wdCB0byBjb21wdXRlIGNvbnRvdXJzIGZvciB0aGUga2VybmVsIGRlbnNpdHkgZXN0aW1hdGVcbiAqICB1c2luZyB2YWx1ZXMgZHJhd24gZnJvbSBkYXRhIHR1cGxlcyBpbiB0aGUgaW5wdXQgcHVsc2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG51bWJlcn0gW3BhcmFtcy54XSAtIFRoZSBwaXhlbCB4LWNvb3JkaW5hdGUgYWNjZXNzb3IgZm9yIGRlbnNpdHkgZXN0aW1hdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogbnVtYmVyfSBbcGFyYW1zLnldIC0gVGhlIHBpeGVsIHktY29vcmRpbmF0ZSBhY2Nlc3NvciBmb3IgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBudW1iZXJ9IFtwYXJhbXMud2VpZ2h0XSAtIFRoZSBkYXRhIHBvaW50IHdlaWdodCBhY2Nlc3NvciBmb3IgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuY2VsbFNpemVdIC0gQ29udG91ciBkZW5zaXR5IGNhbGN1bGF0aW9uIGNlbGwgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmJhbmR3aWR0aF0gLSBLZXJuZWwgZGVuc2l0eSBlc3RpbWF0aW9uIGJhbmR3aWR0aC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy50aHJlc2hvbGRzXSAtIENvbnRvdXIgdGhyZXNob2xkIGFycmF5LiBJZlxuICogICB0aGlzIHBhcmFtZXRlciBpcyBzZXQsIHRoZSBjb3VudCBhbmQgbmljZSBwYXJhbWV0ZXJzIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmNvdW50XSAtIFRoZSBkZXNpcmVkIG51bWJlciBvZiBjb250b3Vycy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5uaWNlXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBjb250b3VyXG4gKiAgIHRocmVzaG9sZCB2YWx1ZXMgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgYWxpZ25lZCB0byBcIm5pY2VcIlxuICogICBodW1hbi1mcmllbmRseSB2YWx1ZXMuIFNldHRpbmcgdGhpcyBmbGFnIG1heSBjYXVzZSB0aGUgbnVtYmVyIG9mXG4gKiAgIHRocmVzaG9sZHMgdG8gZGV2aWF0ZSBmcm9tIHRoZSBzcGVjaWZpZWQgY291bnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc21vb3RoXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBjb250b3VyXG4gKiAgIHBvbHlnb25zIHNob3VsZCBiZSBzbW9vdGhlZCB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi4gVGhlIGRlZmF1bHQgaXNcbiAqICAgdHJ1ZS4gVGhlIHBhcmFtZXRlciBpcyBpZ25vcmVkIHdoZW4gdXNpbmcgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIENvbnRvdXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Db250b3VyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0NvbnRvdXInLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3ZhbHVlcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd4JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3knLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnd2VpZ2h0JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ2NlbGxTaXplJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdiYW5kd2lkdGgnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ2NvdW50JyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICduaWNlJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IGZhbHNlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0aHJlc2hvbGRzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3Ntb290aCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoQ29udG91ciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFwdWxzZS5jaGFuZ2VkKCkgJiYgIV8ubW9kaWZpZWQoKSkge1xuICAgICAgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICBjb250b3VyID0gY29udG91cnMoKS5zbW9vdGgoXy5zbW9vdGggIT09IGZhbHNlKSxcbiAgICAgICAgdmFsdWVzID0gXy52YWx1ZXMsXG4gICAgICAgIHRocmVzaCA9IF8udGhyZXNob2xkcyB8fCBxdWFudGl6ZShfLmNvdW50IHx8IDEwLCBfLm5pY2UsICEhdmFsdWVzKSxcbiAgICAgICAgc2l6ZSA9IF8uc2l6ZSxcbiAgICAgICAgZ3JpZCxcbiAgICAgICAgcG9zdDtcblxuICAgIGlmICghdmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZTtcbiAgICAgIGdyaWQgPSBwYXJhbXMoZGVuc2l0eTJEKCksIF8pKHZhbHVlcywgdHJ1ZSk7XG4gICAgICBwb3N0ID0gdHJhbnNmb3JtKGdyaWQsIGdyaWQuc2NhbGUgfHwgMSwgZ3JpZC5zY2FsZSB8fCAxLCAwLCAwKTtcbiAgICAgIHNpemUgPSBbZ3JpZC53aWR0aCwgZ3JpZC5oZWlnaHRdO1xuICAgICAgdmFsdWVzID0gZ3JpZC52YWx1ZXM7XG4gICAgfVxuXG4gICAgdGhyZXNoID0gaXNBcnJheSh0aHJlc2gpID8gdGhyZXNoIDogdGhyZXNoKHZhbHVlcyk7XG4gICAgdmFsdWVzID0gY29udG91ci5zaXplKHNpemUpKHZhbHVlcywgdGhyZXNoKTtcbiAgICBpZiAocG9zdCkgdmFsdWVzLmZvckVhY2gocG9zdCk7XG4gICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZCA9ICh2YWx1ZXMgfHwgW10pLm1hcChpbmdlc3QpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmNvbnN0IEZlYXR1cmUgPSAnRmVhdHVyZSc7XG5jb25zdCBGZWF0dXJlQ29sbGVjdGlvbiA9ICdGZWF0dXJlQ29sbGVjdGlvbic7XG5jb25zdCBNdWx0aVBvaW50ID0gJ011bHRpUG9pbnQnO1xuXG4vKipcbiAqIENvbnNvbGlkYXRlIGFuIGFycmF5IG9mIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBwb2ludHMgb3IgR2VvSlNPTiBmZWF0dXJlc1xuICogaW50byBhIGNvbWJpbmVkIEdlb0pTT04gb2JqZWN0LiBUaGlzIHRyYW5zZm9ybSBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvclxuICogY29tYmluaW5nIGdlbyBkYXRhIGZvciBhIFByb2plY3Rpb24ncyBmaXQgYXJndW1lbnQuIFRoZSByZXN1bHRpbmcgR2VvSlNPTlxuICogZGF0YSBpcyBhdmFpbGFibGUgYXMgdGhpcyB0cmFuc2Zvcm0ncyB2YWx1ZS4gSW5wdXQgcHVsc2VzIGFyZSB1bmNoYW5nZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZmllbGRzXSAtIEEgdHdvLWVsZW1lbnQgYXJyYXlcbiAqICAgb2YgZmllbGQgYWNjZXNzb3JzIGZvciB0aGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5nZW9qc29uIC0gQSBmaWVsZCBhY2Nlc3NvciBmb3JcbiAqICAgcmV0cmlldmluZyBHZW9KU09OIGZlYXR1cmUgZGF0YS5cbiAqL1xuXG5mdW5jdGlvbiBHZW9KU09OKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuR2VvSlNPTi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdHZW9KU09OJyxcbiAgJ21ldGFkYXRhJzoge30sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ2dlb2pzb24nLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9XVxufTtcbmluaGVyaXRzKEdlb0pTT04sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9mZWF0dXJlcyxcbiAgICAgICAgcG9pbnRzID0gdGhpcy5fcG9pbnRzLFxuICAgICAgICBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgICAgbG9uID0gZmllbGRzICYmIGZpZWxkc1swXSxcbiAgICAgICAgbGF0ID0gZmllbGRzICYmIGZpZWxkc1sxXSxcbiAgICAgICAgZ2VvanNvbiA9IF8uZ2VvanNvbiB8fCAhZmllbGRzICYmIGlkZW50aXR5LFxuICAgICAgICBmbGFnID0gcHVsc2UuQURELFxuICAgICAgICBtb2Q7XG4gICAgbW9kID0gXy5tb2RpZmllZCgpIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuUkVNKSB8fCBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyhnZW9qc29uKSkgfHwgbG9uICYmIHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKGxvbikpIHx8IGxhdCAmJiBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyhsYXQpKTtcblxuICAgIGlmICghdGhpcy52YWx1ZSB8fCBtb2QpIHtcbiAgICAgIGZsYWcgPSBwdWxzZS5TT1VSQ0U7XG4gICAgICB0aGlzLl9mZWF0dXJlcyA9IGZlYXR1cmVzID0gW107XG4gICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoZ2VvanNvbikge1xuICAgICAgcHVsc2UudmlzaXQoZmxhZywgdCA9PiBmZWF0dXJlcy5wdXNoKGdlb2pzb24odCkpKTtcbiAgICB9XG5cbiAgICBpZiAobG9uICYmIGxhdCkge1xuICAgICAgcHVsc2UudmlzaXQoZmxhZywgdCA9PiB7XG4gICAgICAgIHZhciB4ID0gbG9uKHQpLFxuICAgICAgICAgICAgeSA9IGxhdCh0KTtcblxuICAgICAgICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbCAmJiAoeCA9ICt4KSA9PT0geCAmJiAoeSA9ICt5KSA9PT0geSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKFt4LCB5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZmVhdHVyZXMgPSBmZWF0dXJlcy5jb25jYXQoe1xuICAgICAgICB0eXBlOiBGZWF0dXJlLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6IE11bHRpUG9pbnQsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHBvaW50c1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0ge1xuICAgICAgdHlwZTogRmVhdHVyZUNvbGxlY3Rpb24sXG4gICAgICBmZWF0dXJlczogZmVhdHVyZXNcbiAgICB9O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIE1hcCBHZW9KU09OIGRhdGEgdG8gYW4gU1ZHIHBhdGggc3RyaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogKn0gcGFyYW1zLnByb2plY3Rpb24gLSBUaGUgY2FydG9ncmFwaGljXG4gKiAgIHByb2plY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IFtwYXJhbXMuZmllbGRdIC0gVGhlIGZpZWxkIHdpdGggR2VvSlNPTiBkYXRhLFxuICogICBvciBudWxsIGlmIHRoZSB0dXBsZSBpdHNlbGYgaXMgYSBHZW9KU09OIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5hcz0ncGF0aCddIC0gVGhlIG91dHB1dCBmaWVsZCBpbiB3aGljaCB0byBzdG9yZVxuICogICB0aGUgZ2VuZXJhdGVkIHBhdGggZGF0YSAoZGVmYXVsdCAncGF0aCcpLlxuICovXG5cbmZ1bmN0aW9uIEdlb1BhdGgocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5HZW9QYXRoLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0dlb1BhdGgnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdwcm9qZWN0aW9uJyxcbiAgICAndHlwZSc6ICdwcm9qZWN0aW9uJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAncG9pbnRSYWRpdXMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2V4cHInOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdwYXRoJ1xuICB9XVxufTtcbmluaGVyaXRzKEdlb1BhdGgsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLFxuICAgICAgICBwYXRoID0gdGhpcy52YWx1ZSxcbiAgICAgICAgZmllbGQgPSBfLmZpZWxkIHx8IGlkZW50aXR5LFxuICAgICAgICBhcyA9IF8uYXMgfHwgJ3BhdGgnLFxuICAgICAgICBmbGFnID0gb3V0LlNPVVJDRTtcblxuICAgIGlmICghcGF0aCB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIC8vIHBhcmFtZXRlcnMgdXBkYXRlZCwgcmVzZXQgYW5kIHJlZmxvd1xuICAgICAgdGhpcy52YWx1ZSA9IHBhdGggPSBnZXRQcm9qZWN0aW9uUGF0aChfLnByb2plY3Rpb24pO1xuICAgICAgb3V0Lm1hdGVyaWFsaXplKCkucmVmbG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWcgPSBmaWVsZCA9PT0gaWRlbnRpdHkgfHwgcHVsc2UubW9kaWZpZWQoZmllbGQuZmllbGRzKSA/IG91dC5BRERfTU9EIDogb3V0LkFERDtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2ID0gaW5pdFBhdGgocGF0aCwgXy5wb2ludFJhZGl1cyk7XG4gICAgb3V0LnZpc2l0KGZsYWcsIHQgPT4gdFthc10gPSBwYXRoKGZpZWxkKHQpKSk7XG4gICAgcGF0aC5wb2ludFJhZGl1cyhwcmV2KTtcbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gaW5pdFBhdGgocGF0aCwgcG9pbnRSYWRpdXMpIHtcbiAgY29uc3QgcHJldiA9IHBhdGgucG9pbnRSYWRpdXMoKTtcbiAgcGF0aC5jb250ZXh0KG51bGwpO1xuXG4gIGlmIChwb2ludFJhZGl1cyAhPSBudWxsKSB7XG4gICAgcGF0aC5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gIH1cblxuICByZXR1cm4gcHJldjtcbn1cblxuLyoqXG4gKiBHZW8tY29kZSBhIGxvbmdpdHVkZS9sYXRpdHVkZSBwb2ludCB0byBhbiB4L3kgY29vcmRpbmF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcik6ICp9IHBhcmFtcy5wcm9qZWN0aW9uIC0gVGhlIGNhcnRvZ3JhcGhpY1xuICogICBwcm9qZWN0aW9uIHRvIGFwcGx5LlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gcGFyYW1zLmZpZWxkcyAtIEEgdHdvLWVsZW1lbnQgYXJyYXkgb2ZcbiAqICAgZmllbGQgYWNjZXNzb3JzIGZvciB0aGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gQSB0d28tZWxlbWVudCBhcnJheSBvZiBmaWVsZCBuYW1lc1xuICogICB1bmRlciB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LiBEZWZhdWx0cyB0byBbJ3gnLCd5J10uXG4gKi9cblxuZnVuY3Rpb24gR2VvUG9pbnQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5HZW9Qb2ludC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdHZW9Qb2ludCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3Byb2plY3Rpb24nLFxuICAgICd0eXBlJzogJ3Byb2plY3Rpb24nLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsneCcsICd5J11cbiAgfV1cbn07XG5pbmhlcml0cyhHZW9Qb2ludCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBwcm9qID0gXy5wcm9qZWN0aW9uLFxuICAgICAgICBsb24gPSBfLmZpZWxkc1swXSxcbiAgICAgICAgbGF0ID0gXy5maWVsZHNbMV0sXG4gICAgICAgIGFzID0gXy5hcyB8fCBbJ3gnLCAneSddLFxuICAgICAgICB4ID0gYXNbMF0sXG4gICAgICAgIHkgPSBhc1sxXSxcbiAgICAgICAgbW9kO1xuXG4gICAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICAgIGNvbnN0IHh5ID0gcHJvaihbbG9uKHQpLCBsYXQodCldKTtcblxuICAgICAgaWYgKHh5KSB7XG4gICAgICAgIHRbeF0gPSB4eVswXTtcbiAgICAgICAgdFt5XSA9IHh5WzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdFt4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdFt5XSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXy5tb2RpZmllZCgpKSB7XG4gICAgICAvLyBwYXJhbWV0ZXJzIHVwZGF0ZWQsIHJlZmxvd1xuICAgICAgcHVsc2UgPSBwdWxzZS5tYXRlcmlhbGl6ZSgpLnJlZmxvdyh0cnVlKS52aXNpdChwdWxzZS5TT1VSQ0UsIHNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZCA9IHB1bHNlLm1vZGlmaWVkKGxvbi5maWVsZHMpIHx8IHB1bHNlLm1vZGlmaWVkKGxhdC5maWVsZHMpO1xuICAgICAgcHVsc2UudmlzaXQobW9kID8gcHVsc2UuQUREX01PRCA6IHB1bHNlLkFERCwgc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2UubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEFubm90YXRlIGl0ZW1zIHdpdGggYSBnZW9wYXRoIHNoYXBlIGdlbmVyYXRvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcik6ICp9IHBhcmFtcy5wcm9qZWN0aW9uIC0gVGhlIGNhcnRvZ3JhcGhpY1xuICogICBwcm9qZWN0aW9uIHRvIGFwcGx5LlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBbcGFyYW1zLmZpZWxkXSAtIFRoZSBmaWVsZCB3aXRoIEdlb0pTT04gZGF0YSxcbiAqICAgb3IgbnVsbCBpZiB0aGUgdHVwbGUgaXRzZWxmIGlzIGEgR2VvSlNPTiBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuYXM9J3NoYXBlJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgcGF0aCBkYXRhIChkZWZhdWx0ICdzaGFwZScpLlxuICovXG5cbmZ1bmN0aW9uIEdlb1NoYXBlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuR2VvU2hhcGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnR2VvU2hhcGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZSxcbiAgICAnbm9tb2QnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3Byb2plY3Rpb24nLFxuICAgICd0eXBlJzogJ3Byb2plY3Rpb24nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdkZWZhdWx0JzogJ2RhdHVtJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAncG9pbnRSYWRpdXMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2V4cHInOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdzaGFwZSdcbiAgfV1cbn07XG5pbmhlcml0cyhHZW9TaGFwZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFMTCksXG4gICAgICAgIHNoYXBlID0gdGhpcy52YWx1ZSxcbiAgICAgICAgYXMgPSBfLmFzIHx8ICdzaGFwZScsXG4gICAgICAgIGZsYWcgPSBvdXQuQUREO1xuXG4gICAgaWYgKCFzaGFwZSB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIC8vIHBhcmFtZXRlcnMgdXBkYXRlZCwgcmVzZXQgYW5kIHJlZmxvd1xuICAgICAgdGhpcy52YWx1ZSA9IHNoYXBlID0gc2hhcGVHZW5lcmF0b3IoZ2V0UHJvamVjdGlvblBhdGgoXy5wcm9qZWN0aW9uKSwgXy5maWVsZCB8fCBmaWVsZCgnZGF0dW0nKSwgXy5wb2ludFJhZGl1cyk7XG4gICAgICBvdXQubWF0ZXJpYWxpemUoKS5yZWZsb3coKTtcbiAgICAgIGZsYWcgPSBvdXQuU09VUkNFO1xuICAgIH1cblxuICAgIG91dC52aXNpdChmbGFnLCB0ID0+IHRbYXNdID0gc2hhcGUpO1xuICAgIHJldHVybiBvdXQubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzaGFwZUdlbmVyYXRvcihwYXRoLCBmaWVsZCwgcG9pbnRSYWRpdXMpIHtcbiAgY29uc3Qgc2hhcGUgPSBwb2ludFJhZGl1cyA9PSBudWxsID8gXyA9PiBwYXRoKGZpZWxkKF8pKSA6IF8gPT4ge1xuICAgIHZhciBwcmV2ID0gcGF0aC5wb2ludFJhZGl1cygpLFxuICAgICAgICB2YWx1ZSA9IHBhdGgucG9pbnRSYWRpdXMocG9pbnRSYWRpdXMpKGZpZWxkKF8pKTtcbiAgICBwYXRoLnBvaW50UmFkaXVzKHByZXYpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBzaGFwZS5jb250ZXh0ID0gXyA9PiB7XG4gICAgcGF0aC5jb250ZXh0KF8pO1xuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcblxuICByZXR1cm4gc2hhcGU7XG59XG5cbi8qKlxuICogR2VvSlNPTiBmZWF0dXJlIGdlbmVyYXRvciBmb3IgY3JlYXRpbmcgZ3JhdGljdWxlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIEdyYXRpY3VsZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG4gIHRoaXMuZ2VuZXJhdG9yID0gZ2VvR3JhdGljdWxlKCk7XG59XG5HcmF0aWN1bGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnR3JhdGljdWxlJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdjaGFuZ2VzJzogdHJ1ZSxcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdleHRlbnQnLFxuICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdjb250ZW50Jzoge1xuICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICdhcnJheSc6IHRydWUsXG4gICAgICAnbGVuZ3RoJzogMlxuICAgIH1cbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudE1ham9yJyxcbiAgICAndHlwZSc6ICdhcnJheScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnY29udGVudCc6IHtcbiAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAnYXJyYXknOiB0cnVlLFxuICAgICAgJ2xlbmd0aCc6IDJcbiAgICB9XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdleHRlbnRNaW5vcicsXG4gICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2NvbnRlbnQnOiB7XG4gICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAgICdsZW5ndGgnOiAyXG4gICAgfVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwTWFqb3InLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFs5MCwgMzYwXVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcE1pbm9yJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBbMTAsIDEwXVxuICB9LCB7XG4gICAgJ25hbWUnOiAncHJlY2lzaW9uJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMi41XG4gIH1dXG59O1xuaW5oZXJpdHMoR3JhdGljdWxlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIHNyYyA9IHRoaXMudmFsdWUsXG4gICAgICAgIGdlbiA9IHRoaXMuZ2VuZXJhdG9yLFxuICAgICAgICB0O1xuXG4gICAgaWYgKCFzcmMubGVuZ3RoIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgZm9yIChjb25zdCBwcm9wIGluIF8pIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZ2VuW3Byb3BdKSkge1xuICAgICAgICAgIGdlbltwcm9wXShfW3Byb3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHQgPSBnZW4oKTtcblxuICAgIGlmIChzcmMubGVuZ3RoKSB7XG4gICAgICBwdWxzZS5tb2QucHVzaChyZXBsYWNlKHNyY1swXSwgdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWxzZS5hZGQucHVzaChpbmdlc3QodCkpO1xuICAgIH1cblxuICAgIHNyY1swXSA9IHQ7XG4gICAgcmV0dXJuIHB1bHNlO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFJlbmRlciBhIGhlYXRtYXAgaW1hZ2UgZm9yIGlucHV0IHJhc3RlciBncmlkIGRhdGEuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gW3BhcmFtcy5maWVsZF0gLSBUaGUgZmllbGQgd2l0aCByYXN0ZXIgZ3JpZFxuICogICBkYXRhLiBJZiB1bnNwZWNpZmllZCwgdGhlIHR1cGxlIGl0c2VsZiBpcyBpbnRlcnByZXRlZCBhcyBhIHJhc3RlciBncmlkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY29sb3JdIC0gQSBjb25zdGFudCBjb2xvciB2YWx1ZSBvciBmdW5jdGlvbiBmb3JcbiAqICAgaW5kaXZpZHVhbCBwaXhlbCBjb2xvci4gSWYgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gaW5wdXRcbiAqICAgb2JqZWN0IHRoYXQgaW5jbHVkZXMgJHgsICR5LCAkdmFsdWUsIGFuZCAkbWF4IGZpZWxkcyBmb3IgdGhlIGdyaWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5vcGFjaXR5XSAtIEEgY29uc3RhbnQgb3BhY2l0eSB2YWx1ZSBvciBmdW5jdGlvbiBmb3JcbiAqICAgaW5kaXZpZHVhbCBwaXhlbCBvcGFjaXR5LiBJZiBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCBhbiBpbnB1dFxuICogICBvYmplY3QgdGhhdCBpbmNsdWRlcyAkeCwgJHksICR2YWx1ZSwgYW5kICRtYXggZmllbGRzIGZvciB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnJlc29sdmVdIC0gVGhlIG1ldGhvZCBmb3IgcmVzb2x2aW5nIG1heGltdW0gdmFsdWVzXG4gKiAgIGFjcm9zcyBtdWx0aXBsZSBpbnB1dCBncmlkcy4gSWYgJ2luZGVwZW5kZW50JyAodGhlIGRlZmF1bHQpLCBtYXhpbXVtXG4gKiAgIGNhbGN1bGF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkIHNlcGFyYXRlbHkgZm9yIGVhY2ggZ3JpZC4gSWYgJ3NoYXJlZCcsXG4gKiAgIGEgc2luZ2xlIGdsb2JhbCBtYXhpbXVtIHdpbGwgYmUgdXNlZCBmb3IgYWxsIGlucHV0IGdyaWRzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuYXM9J2ltYWdlJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgYml0bWFwIGNhbnZhcyBpbWFnZXMgKGRlZmF1bHQgJ2ltYWdlJykuXG4gKi9cblxuZnVuY3Rpb24gSGVhdG1hcChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkhlYXRtYXAuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnaGVhdG1hcCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ2NvbG9yJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3BhY2l0eScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3Jlc29sdmUnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBbJ3NoYXJlZCcsICdpbmRlcGVuZGVudCddLFxuICAgICdkZWZhdWx0JzogJ2luZGVwZW5kZW50J1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAnaW1hZ2UnXG4gIH1dXG59O1xuaW5oZXJpdHMoSGVhdG1hcCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICghcHVsc2UuY2hhbmdlZCgpICYmICFfLm1vZGlmaWVkKCkpIHtcbiAgICAgIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICBzaGFyZWQgPSBfLnJlc29sdmUgPT09ICdzaGFyZWQnLFxuICAgICAgICBmaWVsZCA9IF8uZmllbGQgfHwgaWRlbnRpdHksXG4gICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5XyhfLm9wYWNpdHksIF8pLFxuICAgICAgICBjb2xvciA9IGNvbG9yXyhfLmNvbG9yLCBfKSxcbiAgICAgICAgYXMgPSBfLmFzIHx8ICdpbWFnZScsXG4gICAgICAgIG9iaiA9IHtcbiAgICAgICR4OiAwLFxuICAgICAgJHk6IDAsXG4gICAgICAkdmFsdWU6IDAsXG4gICAgICAkbWF4OiBzaGFyZWQgPyBtYXgoc291cmNlLm1hcCh0ID0+IG1heChmaWVsZCh0KS52YWx1ZXMpKSkgOiAwXG4gICAgfTtcbiAgICBzb3VyY2UuZm9yRWFjaCh0ID0+IHtcbiAgICAgIGNvbnN0IHYgPSBmaWVsZCh0KTsgLy8gYnVpbGQgcHJveHkgZGF0YSBvYmplY3RcblxuICAgICAgY29uc3QgbyA9IGV4dGVuZCh7fSwgdCwgb2JqKTsgLy8gc2V0IG1heGltdW0gdmFsdWUgaWYgbm90IGdsb2JhbGx5IHNoYXJlZFxuXG4gICAgICBpZiAoIXNoYXJlZCkgby4kbWF4ID0gbWF4KHYudmFsdWVzIHx8IFtdKTsgLy8gZ2VuZXJhdGUgY2FudmFzIGltYWdlXG4gICAgICAvLyBvcHRpbWl6ZSBjb2xvci9vcGFjaXR5IGlmIG5vdCBwaXhlbC1kZXBlbmRlbnRcblxuICAgICAgdFthc10gPSB0b0NhbnZhcyh2LCBvLCBjb2xvci5kZXAgPyBjb2xvciA6IGNvbnN0YW50KGNvbG9yKG8pKSwgb3BhY2l0eS5kZXAgPyBvcGFjaXR5IDogY29uc3RhbnQob3BhY2l0eShvKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3codHJ1ZSkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pOyAvLyBnZXQgaW1hZ2UgY29sb3IgZnVuY3Rpb25cblxuZnVuY3Rpb24gY29sb3JfKGNvbG9yLCBfKSB7XG4gIGxldCBmO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGNvbG9yKSkge1xuICAgIGYgPSBvYmogPT4gcmdiKGNvbG9yKG9iaiwgXykpO1xuXG4gICAgZi5kZXAgPSBkZXBlbmRlbmN5KGNvbG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBkZWZhdWx0IHRvIG1pZC1ncmV5XG4gICAgZiA9IGNvbnN0YW50KHJnYihjb2xvciB8fCAnIzg4OCcpKTtcbiAgfVxuXG4gIHJldHVybiBmO1xufSAvLyBnZXQgaW1hZ2Ugb3BhY2l0eSBmdW5jdGlvblxuXG5cbmZ1bmN0aW9uIG9wYWNpdHlfKG9wYWNpdHksIF8pIHtcbiAgbGV0IGY7XG5cbiAgaWYgKGlzRnVuY3Rpb24ob3BhY2l0eSkpIHtcbiAgICBmID0gb2JqID0+IG9wYWNpdHkob2JqLCBfKTtcblxuICAgIGYuZGVwID0gZGVwZW5kZW5jeShvcGFjaXR5KTtcbiAgfSBlbHNlIGlmIChvcGFjaXR5KSB7XG4gICAgZiA9IGNvbnN0YW50KG9wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlZmF1bHQgdG8gWzAsIG1heF0gb3BhY2l0eSBncmFkaWVudFxuICAgIGYgPSBvYmogPT4gb2JqLiR2YWx1ZSAvIG9iai4kbWF4IHx8IDA7XG5cbiAgICBmLmRlcCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZjtcbn0gLy8gY2hlY2sgaWYgZnVuY3Rpb24gZGVwZW5kcyBvbiBpbmRpdmlkdWFsIHBpeGVsIGRhdGFcblxuXG5mdW5jdGlvbiBkZXBlbmRlbmN5KGYpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGYpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHNldCA9IHRvU2V0KGFjY2Vzc29yRmllbGRzKGYpKTtcbiAgcmV0dXJuIHNldC4keCB8fCBzZXQuJHkgfHwgc2V0LiR2YWx1ZSB8fCBzZXQuJG1heDtcbn0gLy8gcmVuZGVyIHJhc3RlciBncmlkIHRvIGNhbnZhc1xuXG5cbmZ1bmN0aW9uIHRvQ2FudmFzKGdyaWQsIG9iaiwgY29sb3IsIG9wYWNpdHkpIHtcbiAgY29uc3QgbiA9IGdyaWQud2lkdGgsXG4gICAgICAgIG0gPSBncmlkLmhlaWdodCxcbiAgICAgICAgeDEgPSBncmlkLngxIHx8IDAsXG4gICAgICAgIHkxID0gZ3JpZC55MSB8fCAwLFxuICAgICAgICB4MiA9IGdyaWQueDIgfHwgbixcbiAgICAgICAgeTIgPSBncmlkLnkyIHx8IG0sXG4gICAgICAgIHZhbCA9IGdyaWQudmFsdWVzLFxuICAgICAgICB2YWx1ZSA9IHZhbCA/IGkgPT4gdmFsW2ldIDogemVybyxcbiAgICAgICAgY2FuID0gY2FudmFzKHgyIC0geDEsIHkyIC0geTEpLFxuICAgICAgICBjdHggPSBjYW4uZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgaW1nID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB4MiAtIHgxLCB5MiAtIHkxKSxcbiAgICAgICAgcGl4ID0gaW1nLmRhdGE7XG5cbiAgZm9yIChsZXQgaiA9IHkxLCBrID0gMDsgaiA8IHkyOyArK2opIHtcbiAgICBvYmouJHkgPSBqIC0geTE7XG5cbiAgICBmb3IgKGxldCBpID0geDEsIHIgPSBqICogbjsgaSA8IHgyOyArK2ksIGsgKz0gNCkge1xuICAgICAgb2JqLiR4ID0gaSAtIHgxO1xuICAgICAgb2JqLiR2YWx1ZSA9IHZhbHVlKGkgKyByKTtcbiAgICAgIGNvbnN0IHYgPSBjb2xvcihvYmopO1xuICAgICAgcGl4W2sgKyAwXSA9IHYucjtcbiAgICAgIHBpeFtrICsgMV0gPSB2Lmc7XG4gICAgICBwaXhbayArIDJdID0gdi5iO1xuICAgICAgcGl4W2sgKyAzXSA9IH5+KDI1NSAqIG9wYWNpdHkob2JqKSk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnB1dEltYWdlRGF0YShpbWcsIDAsIDApO1xuICByZXR1cm4gY2FuO1xufVxuXG4vKipcbiAqIE1haW50YWlucyBhIGNhcnRvZ3JhcGhpYyBwcm9qZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gUHJvamVjdGlvbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbiAgdGhpcy5tb2RpZmllZCh0cnVlKTsgLy8gYWx3YXlzIHRyZWF0IGFzIG1vZGlmaWVkXG59XG5pbmhlcml0cyhQcm9qZWN0aW9uLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgbGV0IHByb2ogPSB0aGlzLnZhbHVlO1xuXG4gICAgaWYgKCFwcm9qIHx8IF8ubW9kaWZpZWQoJ3R5cGUnKSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHByb2ogPSBjcmVhdGUoXy50eXBlKTtcbiAgICAgIHByb2plY3Rpb25Qcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIGlmIChfW3Byb3BdICE9IG51bGwpIHNldChwcm9qLCBwcm9wLCBfW3Byb3BdKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9qZWN0aW9uUHJvcGVydGllcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBpZiAoXy5tb2RpZmllZChwcm9wKSkgc2V0KHByb2osIHByb3AsIF9bcHJvcF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKF8ucG9pbnRSYWRpdXMgIT0gbnVsbCkgcHJvai5wYXRoLnBvaW50UmFkaXVzKF8ucG9pbnRSYWRpdXMpO1xuICAgIGlmIChfLmZpdCkgZml0KHByb2osIF8pO1xuICAgIHJldHVybiBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIGZpdChwcm9qLCBfKSB7XG4gIGNvbnN0IGRhdGEgPSBjb2xsZWN0R2VvSlNPTihfLmZpdCk7XG4gIF8uZXh0ZW50ID8gcHJvai5maXRFeHRlbnQoXy5leHRlbnQsIGRhdGEpIDogXy5zaXplID8gcHJvai5maXRTaXplKF8uc2l6ZSwgZGF0YSkgOiAwO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSkge1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IHByb2plY3Rpb24oKHR5cGUgfHwgJ21lcmNhdG9yJykudG9Mb3dlckNhc2UoKSk7XG4gIGlmICghY29uc3RydWN0b3IpIGVycm9yKCdVbnJlY29nbml6ZWQgcHJvamVjdGlvbiB0eXBlOiAnICsgdHlwZSk7XG4gIHJldHVybiBjb25zdHJ1Y3RvcigpO1xufVxuXG5mdW5jdGlvbiBzZXQocHJvaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGdW5jdGlvbihwcm9qW2tleV0pKSBwcm9qW2tleV0odmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0R2VvSlNPTihkYXRhKSB7XG4gIGRhdGEgPSBhcnJheShkYXRhKTtcbiAgcmV0dXJuIGRhdGEubGVuZ3RoID09PSAxID8gZGF0YVswXSA6IHtcbiAgICB0eXBlOiBGZWF0dXJlQ29sbGVjdGlvbixcbiAgICBmZWF0dXJlczogZGF0YS5yZWR1Y2UoKGEsIGYpID0+IGEuY29uY2F0KGZlYXR1cml6ZShmKSksIFtdKVxuICB9O1xufVxuXG5mdW5jdGlvbiBmZWF0dXJpemUoZikge1xuICByZXR1cm4gZi50eXBlID09PSBGZWF0dXJlQ29sbGVjdGlvbiA/IGYuZmVhdHVyZXMgOiBhcnJheShmKS5maWx0ZXIoZCA9PiBkICE9IG51bGwpLm1hcChkID0+IGQudHlwZSA9PT0gRmVhdHVyZSA/IGQgOiB7XG4gICAgdHlwZTogRmVhdHVyZSxcbiAgICBnZW9tZXRyeTogZFxuICB9KTtcbn1cblxuZXhwb3J0IHsgQ29udG91ciBhcyBjb250b3VyLCBHZW9KU09OIGFzIGdlb2pzb24sIEdlb1BhdGggYXMgZ2VvcGF0aCwgR2VvUG9pbnQgYXMgZ2VvcG9pbnQsIEdlb1NoYXBlIGFzIGdlb3NoYXBlLCBHcmF0aWN1bGUgYXMgZ3JhdGljdWxlLCBIZWF0bWFwIGFzIGhlYXRtYXAsIElzb2NvbnRvdXIgYXMgaXNvY29udG91ciwgS0RFMkQgYXMga2RlMmQsIFByb2plY3Rpb24gYXMgcHJvamVjdGlvbiB9O1xuIiwiaW1wb3J0IHsgVHJhbnNmb3JtLCBpc1R1cGxlLCBpbmdlc3QsIHR1cGxlaWQsIHN0YWJsZUNvbXBhcmUgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGluaGVyaXRzLCBlcnJvciwgYXJyYXksIG9uZSwgdHJ1dGh5LCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBoaWVyYXJjaHksIHBhY2ssIHBhcnRpdGlvbiwgc3RyYXRpZnksIHRyZWUsIGNsdXN0ZXIsIHRyZWVtYXAsIHRyZWVtYXBCaW5hcnksIHRyZWVtYXBEaWNlLCB0cmVlbWFwU2xpY2UsIHRyZWVtYXBTbGljZURpY2UsIHRyZWVtYXBTcXVhcmlmeSwgdHJlZW1hcFJlc3F1YXJpZnkgfSBmcm9tICdkMy1oaWVyYXJjaHknO1xuXG4vLyBCdWlsZCBsb29rdXAgdGFibGUgbWFwcGluZyB0dXBsZSBrZXlzIHRvIHRyZWUgbm9kZSBpbnN0YW5jZXNcbmZ1bmN0aW9uIGxvb2t1cCAodHJlZSwga2V5LCBmaWx0ZXIpIHtcbiAgY29uc3QgbWFwID0ge307XG4gIHRyZWUuZWFjaChub2RlID0+IHtcbiAgICBjb25zdCB0ID0gbm9kZS5kYXRhO1xuICAgIGlmIChmaWx0ZXIodCkpIG1hcFtrZXkodCldID0gbm9kZTtcbiAgfSk7XG4gIHRyZWUubG9va3VwID0gbWFwO1xuICByZXR1cm4gdHJlZTtcbn1cblxuLyoqXG4gKiBOZXN0IHR1cGxlcyBpbnRvIGEgdHJlZSBzdHJ1Y3R1cmUsIGdyb3VwZWQgYnkga2V5IHZhbHVlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gcGFyYW1zLmtleXMgLSBUaGUga2V5IGZpZWxkcyB0byBuZXN0IGJ5LCBpbiBvcmRlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5nZW5lcmF0ZT1mYWxzZV0gLSBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmXG4gKiAgIG5vbi1sZWFmIG5vZGVzIGdlbmVyYXRlZCBieSB0aGlzIHRyYW5zZm9ybSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlXG4gKiAgIG91dHB1dC4gVGhlIGRlZmF1bHQgKGZhbHNlKSBpbmNsdWRlcyBvbmx5IHRoZSBpbnB1dCBkYXRhIChsZWFmIG5vZGVzKVxuICogICBpbiB0aGUgZGF0YSBzdHJlYW0uXG4gKi9cblxuZnVuY3Rpb24gTmVzdChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbk5lc3QuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnTmVzdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZXNvdXJjZSc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2tleXMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdnZW5lcmF0ZScsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbidcbiAgfV1cbn07XG5cbmNvbnN0IGNoaWxkcmVuID0gbiA9PiBuLnZhbHVlcztcblxuaW5oZXJpdHMoTmVzdCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICghcHVsc2Uuc291cmNlKSB7XG4gICAgICBlcnJvcignTmVzdCB0cmFuc2Zvcm0gcmVxdWlyZXMgYW4gdXBzdHJlYW0gZGF0YSBzb3VyY2UuJyk7XG4gICAgfVxuXG4gICAgdmFyIGdlbiA9IF8uZ2VuZXJhdGUsXG4gICAgICAgIG1vZCA9IF8ubW9kaWZpZWQoKSxcbiAgICAgICAgb3V0ID0gcHVsc2UuY2xvbmUoKSxcbiAgICAgICAgdHJlZSA9IHRoaXMudmFsdWU7XG5cbiAgICBpZiAoIXRyZWUgfHwgbW9kIHx8IHB1bHNlLmNoYW5nZWQoKSkge1xuICAgICAgLy8gY29sbGVjdCBub2RlcyB0byByZW1vdmVcbiAgICAgIGlmICh0cmVlKSB7XG4gICAgICAgIHRyZWUuZWFjaChub2RlID0+IHtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiBpc1R1cGxlKG5vZGUuZGF0YSkpIHtcbiAgICAgICAgICAgIG91dC5yZW0ucHVzaChub2RlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIGdlbmVyYXRlIG5ldyB0cmVlIHN0cnVjdHVyZVxuXG5cbiAgICAgIHRoaXMudmFsdWUgPSB0cmVlID0gaGllcmFyY2h5KHtcbiAgICAgICAgdmFsdWVzOiBhcnJheShfLmtleXMpLnJlZHVjZSgobiwgaykgPT4ge1xuICAgICAgICAgIG4ua2V5KGspO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9LCBuZXN0KCkpLmVudHJpZXMob3V0LnNvdXJjZSlcbiAgICAgIH0sIGNoaWxkcmVuKTsgLy8gY29sbGVjdCBub2RlcyB0byBhZGRcblxuICAgICAgaWYgKGdlbikge1xuICAgICAgICB0cmVlLmVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG5vZGUgPSBpbmdlc3Qobm9kZS5kYXRhKTtcbiAgICAgICAgICAgIG91dC5hZGQucHVzaChub2RlKTtcbiAgICAgICAgICAgIG91dC5zb3VyY2UucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBidWlsZCBsb29rdXAgdGFibGVcblxuXG4gICAgICBsb29rdXAodHJlZSwgdHVwbGVpZCwgdHVwbGVpZCk7XG4gICAgfVxuXG4gICAgb3V0LnNvdXJjZS5yb290ID0gdHJlZTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBuZXN0KCkge1xuICBjb25zdCBrZXlzID0gW10sXG4gICAgICAgIG5lc3QgPSB7XG4gICAgZW50cmllczogYXJyYXkgPT4gZW50cmllcyhhcHBseShhcnJheSwgMCksIDApLFxuICAgIGtleTogZCA9PiAoa2V5cy5wdXNoKGQpLCBuZXN0KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGFwcGx5KGFycmF5LCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIGNvbnN0IG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAga2V5ID0ga2V5c1tkZXB0aCsrXSxcbiAgICAgICAgICB2YWx1ZXNCeUtleSA9IHt9LFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgIGxldCBpID0gLTEsXG4gICAgICAgIGtleVZhbHVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWVzO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGtleVZhbHVlID0ga2V5KHZhbHVlID0gYXJyYXlbaV0pICsgJyc7XG5cbiAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleVtrZXlWYWx1ZV0pIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQnlLZXlba2V5VmFsdWVdID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGtleVZhbHVlIGluIHZhbHVlc0J5S2V5KSB7XG4gICAgICByZXN1bHRba2V5VmFsdWVdID0gYXBwbHkodmFsdWVzQnlLZXlba2V5VmFsdWVdLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVudHJpZXMobWFwLCBkZXB0aCkge1xuICAgIGlmICgrK2RlcHRoID4ga2V5cy5sZW5ndGgpIHJldHVybiBtYXA7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVzOiBlbnRyaWVzKG1hcFtrZXldLCBkZXB0aClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIHJldHVybiBuZXN0O1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGZvciB0cmVlIGxheW91dC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIEhpZXJhcmNoeUxheW91dChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblxuY29uc3QgZGVmYXVsdFNlcGFyYXRpb24gPSAoYSwgYikgPT4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XG5cbmluaGVyaXRzKEhpZXJhcmNoeUxheW91dCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICghcHVsc2Uuc291cmNlIHx8ICFwdWxzZS5zb3VyY2Uucm9vdCkge1xuICAgICAgZXJyb3IodGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyB0cmFuc2Zvcm0gcmVxdWlyZXMgYSBiYWNraW5nIHRyZWUgZGF0YSBzb3VyY2UuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5sYXlvdXQoXy5tZXRob2QpLFxuICAgICAgICAgIGZpZWxkcyA9IHRoaXMuZmllbGRzLFxuICAgICAgICAgIHJvb3QgPSBwdWxzZS5zb3VyY2Uucm9vdCxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgZmllbGRzO1xuICAgIGlmIChfLmZpZWxkKSByb290LnN1bShfLmZpZWxkKTtlbHNlIHJvb3QuY291bnQoKTtcbiAgICBpZiAoXy5zb3J0KSByb290LnNvcnQoc3RhYmxlQ29tcGFyZShfLnNvcnQsIGQgPT4gZC5kYXRhKSk7XG4gICAgc2V0UGFyYW1zKGxheW91dCwgdGhpcy5wYXJhbXMsIF8pO1xuXG4gICAgaWYgKGxheW91dC5zZXBhcmF0aW9uKSB7XG4gICAgICBsYXlvdXQuc2VwYXJhdGlvbihfLnNlcGFyYXRpb24gIT09IGZhbHNlID8gZGVmYXVsdFNlcGFyYXRpb24gOiBvbmUpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnZhbHVlID0gbGF5b3V0KHJvb3QpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICByb290LmVhY2gobm9kZSA9PiBzZXRGaWVsZHMobm9kZSwgZmllbGRzLCBhcykpO1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3coXy5tb2RpZmllZCgpKS5tb2RpZmllcyhhcykubW9kaWZpZXMoJ2xlYWYnKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gc2V0UGFyYW1zKGxheW91dCwgcGFyYW1zLCBfKSB7XG4gIGZvciAobGV0IHAsIGkgPSAwLCBuID0gcGFyYW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHAgPSBwYXJhbXNbaV07XG4gICAgaWYgKHAgaW4gXykgbGF5b3V0W3BdKF9bcF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEZpZWxkcyhub2RlLCBmaWVsZHMsIGFzKSB7XG4gIGNvbnN0IHQgPSBub2RlLmRhdGEsXG4gICAgICAgIG4gPSBmaWVsZHMubGVuZ3RoIC0gMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHRbYXNbaV1dID0gbm9kZVtmaWVsZHNbaV1dO1xuICB9XG5cbiAgdFthc1tuXV0gPSBub2RlLmNoaWxkcmVuID8gbm9kZS5jaGlsZHJlbi5sZW5ndGggOiAwO1xufVxuXG5jb25zdCBPdXRwdXQgPSBbJ3gnLCAneScsICdyJywgJ2RlcHRoJywgJ2NoaWxkcmVuJ107XG4vKipcbiAqIFBhY2tlZCBjaXJjbGUgdHJlZSBsYXlvdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIHNpemUgbm9kZXMuXG4gKi9cblxuZnVuY3Rpb24gUGFjayhwYXJhbXMpIHtcbiAgSGllcmFyY2h5TGF5b3V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cblBhY2suRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUGFjaycsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZSc6IHRydWUsXG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3JhZGl1cycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdkZWZhdWx0JzogbnVsbFxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiBPdXRwdXQubGVuZ3RoLFxuICAgICdkZWZhdWx0JzogT3V0cHV0XG4gIH1dXG59O1xuaW5oZXJpdHMoUGFjaywgSGllcmFyY2h5TGF5b3V0LCB7XG4gIGxheW91dDogcGFjayxcbiAgcGFyYW1zOiBbJ3JhZGl1cycsICdzaXplJywgJ3BhZGRpbmcnXSxcbiAgZmllbGRzOiBPdXRwdXRcbn0pO1xuXG5jb25zdCBPdXRwdXQkMSA9IFsneDAnLCAneTAnLCAneDEnLCAneTEnLCAnZGVwdGgnLCAnY2hpbGRyZW4nXTtcbi8qKlxuICogUGFydGl0aW9uIHRyZWUgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBzaXplIG5vZGVzLlxuICovXG5cbmZ1bmN0aW9uIFBhcnRpdGlvbihwYXJhbXMpIHtcbiAgSGllcmFyY2h5TGF5b3V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cblBhcnRpdGlvbi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdQYXJ0aXRpb24nLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3RyZWUnOiB0cnVlLFxuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmcnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyb3VuZCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiBPdXRwdXQkMS5sZW5ndGgsXG4gICAgJ2RlZmF1bHQnOiBPdXRwdXQkMVxuICB9XVxufTtcbmluaGVyaXRzKFBhcnRpdGlvbiwgSGllcmFyY2h5TGF5b3V0LCB7XG4gIGxheW91dDogcGFydGl0aW9uLFxuICBwYXJhbXM6IFsnc2l6ZScsICdyb3VuZCcsICdwYWRkaW5nJ10sXG4gIGZpZWxkczogT3V0cHV0JDFcbn0pO1xuXG4vKipcbiAqIFN0cmF0aWZ5IGEgY29sbGVjdGlvbiBvZiB0dXBsZXMgaW50byBhIHRyZWUgc3RydWN0dXJlIGJhc2VkIG9uXG4gKiBpZCBhbmQgcGFyZW50IGlkIGZpZWxkcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMua2V5IC0gVW5pcXVlIGtleSBmaWVsZCBmb3IgZWFjaCB0dXBsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLnBhcmVudEtleSAtIEZpZWxkIHdpdGgga2V5IGZvciBwYXJlbnQgdHVwbGUuXG4gKi9cblxuZnVuY3Rpb24gU3RyYXRpZnkocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5TdHJhdGlmeS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdTdHJhdGlmeScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZXNvdXJjZSc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAna2V5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFyZW50S2V5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKFN0cmF0aWZ5LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKCFwdWxzZS5zb3VyY2UpIHtcbiAgICAgIGVycm9yKCdTdHJhdGlmeSB0cmFuc2Zvcm0gcmVxdWlyZXMgYW4gdXBzdHJlYW0gZGF0YSBzb3VyY2UuJyk7XG4gICAgfVxuXG4gICAgbGV0IHRyZWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgY29uc3QgbW9kID0gXy5tb2RpZmllZCgpLFxuICAgICAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUxMKS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLFxuICAgICAgICAgIHJ1biA9ICF0cmVlIHx8IG1vZCB8fCBwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERF9SRU0pIHx8IHB1bHNlLm1vZGlmaWVkKF8ua2V5LmZpZWxkcykgfHwgcHVsc2UubW9kaWZpZWQoXy5wYXJlbnRLZXkuZmllbGRzKTsgLy8gcHJldmVudCB1cHN0cmVhbSBzb3VyY2UgcG9sbHV0aW9uXG5cblxuICAgIG91dC5zb3VyY2UgPSBvdXQuc291cmNlLnNsaWNlKCk7XG5cbiAgICBpZiAocnVuKSB7XG4gICAgICB0cmVlID0gb3V0LnNvdXJjZS5sZW5ndGggPyBsb29rdXAoc3RyYXRpZnkoKS5pZChfLmtleSkucGFyZW50SWQoXy5wYXJlbnRLZXkpKG91dC5zb3VyY2UpLCBfLmtleSwgdHJ1dGh5KSA6IGxvb2t1cChzdHJhdGlmeSgpKFt7fV0pLCBfLmtleSwgXy5rZXkpO1xuICAgIH1cblxuICAgIG91dC5zb3VyY2Uucm9vdCA9IHRoaXMudmFsdWUgPSB0cmVlO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmNvbnN0IExheW91dHMgPSB7XG4gIHRpZHk6IHRyZWUsXG4gIGNsdXN0ZXI6IGNsdXN0ZXJcbn07XG5jb25zdCBPdXRwdXQkMiA9IFsneCcsICd5JywgJ2RlcHRoJywgJ2NoaWxkcmVuJ107XG4vKipcbiAqIFRyZWUgbGF5b3V0LiBEZXBlbmRpbmcgb24gdGhlIG1ldGhvZCBwYXJhbWV0ZXIsIHBlcmZvcm1zIGVpdGhlclxuICogUmVpbmdvbGQtVGlsZm9yZCAndGlkeScgbGF5b3V0IG9yIGRlbmRyb2dyYW0gJ2NsdXN0ZXInIGxheW91dC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIFRyZWUocGFyYW1zKSB7XG4gIEhpZXJhcmNoeUxheW91dC5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5UcmVlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1RyZWUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3RyZWUnOiB0cnVlLFxuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ21ldGhvZCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAndGlkeScsXG4gICAgJ3ZhbHVlcyc6IFsndGlkeScsICdjbHVzdGVyJ11cbiAgfSwge1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnbm9kZVNpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2VwYXJhdGlvbicsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiBPdXRwdXQkMi5sZW5ndGgsXG4gICAgJ2RlZmF1bHQnOiBPdXRwdXQkMlxuICB9XVxufTtcbmluaGVyaXRzKFRyZWUsIEhpZXJhcmNoeUxheW91dCwge1xuICAvKipcbiAgICogVHJlZSBsYXlvdXQgZ2VuZXJhdG9yLiBTdXBwb3J0cyBib3RoICd0aWR5JyBhbmQgJ2NsdXN0ZXInIGxheW91dHMuXG4gICAqL1xuICBsYXlvdXQobWV0aG9kKSB7XG4gICAgY29uc3QgbSA9IG1ldGhvZCB8fCAndGlkeSc7XG4gICAgaWYgKGhhc093blByb3BlcnR5KExheW91dHMsIG0pKSByZXR1cm4gTGF5b3V0c1ttXSgpO2Vsc2UgZXJyb3IoJ1VucmVjb2duaXplZCBUcmVlIGxheW91dCBtZXRob2Q6ICcgKyBtKTtcbiAgfSxcblxuICBwYXJhbXM6IFsnc2l6ZScsICdub2RlU2l6ZSddLFxuICBmaWVsZHM6IE91dHB1dCQyXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0dXBsZXMgcmVwcmVzZW50aW5nIGxpbmtzIGJldHdlZW4gdHJlZSBub2Rlcy5cbiAqIFRoZSByZXN1bHRpbmcgdHVwbGVzIHdpbGwgY29udGFpbiAnc291cmNlJyBhbmQgJ3RhcmdldCcgZmllbGRzLFxuICogd2hpY2ggcG9pbnQgdG8gcGFyZW50IGFuZCBjaGlsZCBub2RlIHR1cGxlcywgcmVzcGVjdGl2ZWx5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gVHJlZUxpbmtzKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbn1cblRyZWVMaW5rcy5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdUcmVlTGlua3MnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3RyZWUnOiB0cnVlLFxuICAgICdnZW5lcmF0ZXMnOiB0cnVlLFxuICAgICdjaGFuZ2VzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW11cbn07XG5pbmhlcml0cyhUcmVlTGlua3MsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBsaW5rcyA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgdHJlZSA9IHB1bHNlLnNvdXJjZSAmJiBwdWxzZS5zb3VyY2Uucm9vdCxcbiAgICAgICAgICBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksXG4gICAgICAgICAgbHV0ID0ge307XG4gICAgaWYgKCF0cmVlKSBlcnJvcignVHJlZUxpbmtzIHRyYW5zZm9ybSByZXF1aXJlcyBhIHRyZWUgZGF0YSBzb3VyY2UuJyk7XG5cbiAgICBpZiAocHVsc2UuY2hhbmdlZChwdWxzZS5BRERfUkVNKSkge1xuICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIGxpbmtzXG4gICAgICBvdXQucmVtID0gbGlua3M7IC8vIGJ1aWxkIGxvb2t1cCB0YWJsZSBvZiB2YWxpZCB0dXBsZXNcblxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IGx1dFt0dXBsZWlkKHQpXSA9IDEpOyAvLyBnZW5lcmF0ZSBsaW5rcyBmb3IgYWxsIGVkZ2VzIGluY2lkZW50IG9uIHZhbGlkIHR1cGxlc1xuXG4gICAgICB0cmVlLmVhY2gobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHQgPSBub2RlLmRhdGEsXG4gICAgICAgICAgICAgIHAgPSBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5kYXRhO1xuXG4gICAgICAgIGlmIChwICYmIGx1dFt0dXBsZWlkKHQpXSAmJiBsdXRbdHVwbGVpZChwKV0pIHtcbiAgICAgICAgICBvdXQuYWRkLnB1c2goaW5nZXN0KHtcbiAgICAgICAgICAgIHNvdXJjZTogcCxcbiAgICAgICAgICAgIHRhcmdldDogdFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnZhbHVlID0gb3V0LmFkZDtcbiAgICB9IGVsc2UgaWYgKHB1bHNlLmNoYW5nZWQocHVsc2UuTU9EKSkge1xuICAgICAgLy8gYnVpbGQgbG9va3VwIHRhYmxlIG9mIG1vZGlmaWVkIHR1cGxlc1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IGx1dFt0dXBsZWlkKHQpXSA9IDEpOyAvLyBnYXRoZXIgbGlua3MgaW5jaWRlbnQgb24gbW9kaWZpZWQgdHVwbGVzXG5cbiAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgIGlmIChsdXRbdHVwbGVpZChsaW5rLnNvdXJjZSldIHx8IGx1dFt0dXBsZWlkKGxpbmsudGFyZ2V0KV0pIHtcbiAgICAgICAgICBvdXQubW9kLnB1c2gobGluayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmNvbnN0IFRpbGVzID0ge1xuICBiaW5hcnk6IHRyZWVtYXBCaW5hcnksXG4gIGRpY2U6IHRyZWVtYXBEaWNlLFxuICBzbGljZTogdHJlZW1hcFNsaWNlLFxuICBzbGljZWRpY2U6IHRyZWVtYXBTbGljZURpY2UsXG4gIHNxdWFyaWZ5OiB0cmVlbWFwU3F1YXJpZnksXG4gIHJlc3F1YXJpZnk6IHRyZWVtYXBSZXNxdWFyaWZ5XG59O1xuY29uc3QgT3V0cHV0JDMgPSBbJ3gwJywgJ3kwJywgJ3gxJywgJ3kxJywgJ2RlcHRoJywgJ2NoaWxkcmVuJ107XG4vKipcbiAqIFRyZWVtYXAgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBzaXplIG5vZGVzLlxuICovXG5cbmZ1bmN0aW9uIFRyZWVtYXAocGFyYW1zKSB7XG4gIEhpZXJhcmNoeUxheW91dC5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5UcmVlbWFwLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1RyZWVtYXAnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3RyZWUnOiB0cnVlLFxuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ21ldGhvZCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAnc3F1YXJpZnknLFxuICAgICd2YWx1ZXMnOiBbJ3NxdWFyaWZ5JywgJ3Jlc3F1YXJpZnknLCAnYmluYXJ5JywgJ2RpY2UnLCAnc2xpY2UnLCAnc2xpY2VkaWNlJ11cbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmcnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nSW5uZXInLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nT3V0ZXInLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nVG9wJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZ1JpZ2h0JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZ0JvdHRvbScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmdMZWZ0JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncmF0aW8nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxLjYxODAzMzk4ODc0OTg5NVxuICB9LCB7XG4gICAgJ25hbWUnOiAncm91bmQnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogT3V0cHV0JDMubGVuZ3RoLFxuICAgICdkZWZhdWx0JzogT3V0cHV0JDNcbiAgfV1cbn07XG5pbmhlcml0cyhUcmVlbWFwLCBIaWVyYXJjaHlMYXlvdXQsIHtcbiAgLyoqXG4gICAqIFRyZWVtYXAgbGF5b3V0IGdlbmVyYXRvci4gQWRkcyAnbWV0aG9kJyBhbmQgJ3JhdGlvJyBwYXJhbWV0ZXJzXG4gICAqIHRvIGNvbmZpZ3VyZSB0aGUgdW5kZXJseWluZyB0aWxlIG1ldGhvZC5cbiAgICovXG4gIGxheW91dCgpIHtcbiAgICBjb25zdCB4ID0gdHJlZW1hcCgpO1xuXG4gICAgeC5yYXRpbyA9IF8gPT4ge1xuICAgICAgY29uc3QgdCA9IHgudGlsZSgpO1xuICAgICAgaWYgKHQucmF0aW8pIHgudGlsZSh0LnJhdGlvKF8pKTtcbiAgICB9O1xuXG4gICAgeC5tZXRob2QgPSBfID0+IHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShUaWxlcywgXykpIHgudGlsZShUaWxlc1tfXSk7ZWxzZSBlcnJvcignVW5yZWNvZ25pemVkIFRyZWVtYXAgbGF5b3V0IG1ldGhvZDogJyArIF8pO1xuICAgIH07XG5cbiAgICByZXR1cm4geDtcbiAgfSxcblxuICBwYXJhbXM6IFsnbWV0aG9kJywgJ3JhdGlvJywgJ3NpemUnLCAncm91bmQnLCAncGFkZGluZycsICdwYWRkaW5nSW5uZXInLCAncGFkZGluZ091dGVyJywgJ3BhZGRpbmdUb3AnLCAncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nLCAncGFkZGluZ0xlZnQnXSxcbiAgZmllbGRzOiBPdXRwdXQkM1xufSk7XG5cbmV4cG9ydCB7IE5lc3QgYXMgbmVzdCwgUGFjayBhcyBwYWNrLCBQYXJ0aXRpb24gYXMgcGFydGl0aW9uLCBTdHJhdGlmeSBhcyBzdHJhdGlmeSwgVHJlZSBhcyB0cmVlLCBUcmVlTGlua3MgYXMgdHJlZWxpbmtzLCBUcmVlbWFwIGFzIHRyZWVtYXAgfTtcbiIsImltcG9ydCB7IGNhbnZhcyB9IGZyb20gJ3ZlZ2EtY2FudmFzJztcbmltcG9ydCB7IHJlZGVyaXZlLCBUcmFuc2Zvcm0gfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IE1hcmtzLCB0ZXh0TWV0cmljcyB9IGZyb20gJ3ZlZ2Etc2NlbmVncmFwaCc7XG5pbXBvcnQgeyBpbmhlcml0cywgaXNGdW5jdGlvbiwgZXJyb3IsIGFycmF5IH0gZnJvbSAndmVnYS11dGlsJztcblxuY29uc3QgQUxQSEFfTUFTSyA9IDB4ZmYwMDAwMDA7IC8vIGFscGhhIHZhbHVlIGVxdWl2YWxlbnQgdG8gb3BhY2l0eSAwLjA2MjVcblxuY29uc3QgSU5TSURFX09QQUNJVFlfSU5fQUxQSEEgPSAweDEwMDAwMDAwO1xuY29uc3QgSU5TSURFX09QQUNJVFkgPSAwLjA2MjU7XG5mdW5jdGlvbiBiYXNlQml0bWFwcygkLCBkYXRhKSB7XG4gIGNvbnN0IGJpdG1hcCA9ICQuYml0bWFwKCk7IC8vIHdoZW4gdGhlcmUgaXMgbm8gYmFzZSBtYXJrIGJ1dCBkYXRhIHBvaW50cyBhcmUgdG8gYmUgYXZvaWRlZFxuXG4gIChkYXRhIHx8IFtdKS5mb3JFYWNoKGQgPT4gYml0bWFwLnNldCgkKGQuYm91bmRhcnlbMF0pLCAkKGQuYm91bmRhcnlbM10pKSk7XG4gIHJldHVybiBbYml0bWFwLCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gbWFya0JpdG1hcHMoJCwgYXZvaWRNYXJrcywgbGFiZWxJbnNpZGUsIGlzR3JvdXBBcmVhKSB7XG4gIC8vIGNyZWF0ZSBjYW52YXNcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSAkLmhlaWdodCxcbiAgICAgICAgYm9yZGVyID0gbGFiZWxJbnNpZGUgfHwgaXNHcm91cEFyZWEsXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMod2lkdGgsIGhlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTsgLy8gcmVuZGVyIGFsbCBtYXJrcyB0byBiZSBhdm9pZGVkIGludG8gY2FudmFzXG5cbiAgYXZvaWRNYXJrcy5mb3JFYWNoKGl0ZW1zID0+IGRyYXcoY29udGV4dCwgaXRlbXMsIGJvcmRlcikpOyAvLyBnZXQgY2FudmFzIGJ1ZmZlciwgY3JlYXRlIGJpdG1hcHNcblxuICBjb25zdCBidWZmZXIgPSBuZXcgVWludDMyQXJyYXkoY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YS5idWZmZXIpLFxuICAgICAgICBsYXllcjEgPSAkLmJpdG1hcCgpLFxuICAgICAgICBsYXllcjIgPSBib3JkZXIgJiYgJC5iaXRtYXAoKTsgLy8gcG9wdWxhdGUgYml0bWFwIGxheWVyc1xuXG4gIGxldCB4LCB5LCB1LCB2LCBhbHBoYTtcblxuICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgYWxwaGEgPSBidWZmZXJbeSAqIHdpZHRoICsgeF0gJiBBTFBIQV9NQVNLO1xuXG4gICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgdSA9ICQoeCk7XG4gICAgICAgIHYgPSAkKHkpO1xuICAgICAgICBpZiAoIWlzR3JvdXBBcmVhKSBsYXllcjEuc2V0KHUsIHYpOyAvLyB1cGRhdGUgaW50ZXJpb3IgYml0bWFwXG5cbiAgICAgICAgaWYgKGJvcmRlciAmJiBhbHBoYSBeIElOU0lERV9PUEFDSVRZX0lOX0FMUEhBKSBsYXllcjIuc2V0KHUsIHYpOyAvLyB1cGRhdGUgYm9yZGVyIGJpdG1hcFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbGF5ZXIxLCBsYXllcjJdO1xufVxuXG5mdW5jdGlvbiBkcmF3KGNvbnRleHQsIGl0ZW1zLCBpbnRlcmlvcikge1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICBjb25zdCB0eXBlID0gaXRlbXNbMF0ubWFyay5tYXJrdHlwZTtcblxuICBpZiAodHlwZSA9PT0gJ2dyb3VwJykge1xuICAgIGl0ZW1zLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgZ3JvdXAuaXRlbXMuZm9yRWFjaChtYXJrID0+IGRyYXcoY29udGV4dCwgbWFyay5pdGVtcywgaW50ZXJpb3IpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBNYXJrc1t0eXBlXS5kcmF3KGNvbnRleHQsIHtcbiAgICAgIGl0ZW1zOiBpbnRlcmlvciA/IGl0ZW1zLm1hcChwcmVwYXJlKSA6IGl0ZW1zXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogUHJlcGFyZSBpdGVtIGJlZm9yZSBkcmF3aW5nIGludG8gY2FudmFzIChzZXR0aW5nIHN0cm9rZSBhbmQgb3BhY2l0eSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgaXRlbSB0byBiZSBwcmVwYXJlZFxuICogQHJldHVybnMgcHJlcGFyZWQgaXRlbVxuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZShzb3VyY2UpIHtcbiAgY29uc3QgaXRlbSA9IHJlZGVyaXZlKHNvdXJjZSwge30pO1xuXG4gIGlmIChpdGVtLnN0cm9rZSkge1xuICAgIGl0ZW0uc3Ryb2tlT3BhY2l0eSA9IDE7XG4gIH1cblxuICBpZiAoaXRlbS5maWxsKSB7XG4gICAgaXRlbS5maWxsT3BhY2l0eSA9IElOU0lERV9PUEFDSVRZO1xuICAgIGl0ZW0uc3Ryb2tlID0gJyMwMDAnO1xuICAgIGl0ZW0uc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgaXRlbS5zdHJva2VXaWR0aCA9IDI7XG4gIH1cblxuICByZXR1cm4gaXRlbTtcbn1cblxuY29uc3QgRElWID0gNSxcbiAgICAgIC8vIGJpdCBzaGlmdCBmcm9tIHgsIHkgaW5kZXggdG8gYml0IHZlY3RvciBhcnJheSBpbmRleFxuTU9EID0gMzEsXG4gICAgICAvLyBiaXQgbWFzayBmb3IgaW5kZXggbG9va3VwIHdpdGhpbiBhIGJpdCB2ZWN0b3JcblNJWkUgPSAzMixcbiAgICAgIC8vIGluZGl2aWR1YWwgYml0IHZlY3RvciBzaXplXG5SSUdIVDAgPSBuZXcgVWludDMyQXJyYXkoU0laRSArIDEpLFxuICAgICAgLy8gbGVmdC1hbmNob3JlZCBiaXQgdmVjdG9ycywgZnVsbCAtPiAwXG5SSUdIVDEgPSBuZXcgVWludDMyQXJyYXkoU0laRSArIDEpOyAvLyByaWdodC1hbmNob3JlZCBiaXQgdmVjdG9ycywgMCAtPiBmdWxsXG5cblJJR0hUMVswXSA9IDA7XG5SSUdIVDBbMF0gPSB+UklHSFQxWzBdO1xuXG5mb3IgKGxldCBpID0gMTsgaSA8PSBTSVpFOyArK2kpIHtcbiAgUklHSFQxW2ldID0gUklHSFQxW2kgLSAxXSA8PCAxIHwgMTtcbiAgUklHSFQwW2ldID0gflJJR0hUMVtpXTtcbn1cblxuZnVuY3Rpb24gQml0bWFwICh3LCBoKSB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KH5+KCh3ICogaCArIFNJWkUpIC8gU0laRSkpO1xuXG4gIGZ1bmN0aW9uIF9zZXQoaW5kZXgsIG1hc2spIHtcbiAgICBhcnJheVtpbmRleF0gfD0gbWFzaztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGVhcihpbmRleCwgbWFzaykge1xuICAgIGFycmF5W2luZGV4XSAmPSBtYXNrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhcnJheTogYXJyYXksXG4gICAgZ2V0OiAoeCwgeSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB5ICogdyArIHg7XG4gICAgICByZXR1cm4gYXJyYXlbaW5kZXggPj4+IERJVl0gJiAxIDw8IChpbmRleCAmIE1PRCk7XG4gICAgfSxcbiAgICBzZXQ6ICh4LCB5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHkgKiB3ICsgeDtcblxuICAgICAgX3NldChpbmRleCA+Pj4gRElWLCAxIDw8IChpbmRleCAmIE1PRCkpO1xuICAgIH0sXG4gICAgY2xlYXI6ICh4LCB5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHkgKiB3ICsgeDtcblxuICAgICAgX2NsZWFyKGluZGV4ID4+PiBESVYsIH4oMSA8PCAoaW5kZXggJiBNT0QpKSk7XG4gICAgfSxcbiAgICBnZXRSYW5nZTogKHgsIHksIHgyLCB5MikgPT4ge1xuICAgICAgbGV0IHIgPSB5MixcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgaW5kZXhTdGFydCxcbiAgICAgICAgICBpbmRleEVuZDtcblxuICAgICAgZm9yICg7IHIgPj0geTsgLS1yKSB7XG4gICAgICAgIHN0YXJ0ID0gciAqIHcgKyB4O1xuICAgICAgICBlbmQgPSByICogdyArIHgyO1xuICAgICAgICBpbmRleFN0YXJ0ID0gc3RhcnQgPj4+IERJVjtcbiAgICAgICAgaW5kZXhFbmQgPSBlbmQgPj4+IERJVjtcblxuICAgICAgICBpZiAoaW5kZXhTdGFydCA9PT0gaW5kZXhFbmQpIHtcbiAgICAgICAgICBpZiAoYXJyYXlbaW5kZXhTdGFydF0gJiBSSUdIVDBbc3RhcnQgJiBNT0RdICYgUklHSFQxWyhlbmQgJiBNT0QpICsgMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYXJyYXlbaW5kZXhTdGFydF0gJiBSSUdIVDBbc3RhcnQgJiBNT0RdKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBpZiAoYXJyYXlbaW5kZXhFbmRdICYgUklHSFQxWyhlbmQgJiBNT0QpICsgMV0pIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4U3RhcnQgKyAxOyBpIDwgaW5kZXhFbmQ7ICsraSkge1xuICAgICAgICAgICAgaWYgKGFycmF5W2ldKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgc2V0UmFuZ2U6ICh4LCB5LCB4MiwgeTIpID0+IHtcbiAgICAgIGxldCBzdGFydCwgZW5kLCBpbmRleFN0YXJ0LCBpbmRleEVuZCwgaTtcblxuICAgICAgZm9yICg7IHkgPD0geTI7ICsreSkge1xuICAgICAgICBzdGFydCA9IHkgKiB3ICsgeDtcbiAgICAgICAgZW5kID0geSAqIHcgKyB4MjtcbiAgICAgICAgaW5kZXhTdGFydCA9IHN0YXJ0ID4+PiBESVY7XG4gICAgICAgIGluZGV4RW5kID0gZW5kID4+PiBESVY7XG5cbiAgICAgICAgaWYgKGluZGV4U3RhcnQgPT09IGluZGV4RW5kKSB7XG4gICAgICAgICAgX3NldChpbmRleFN0YXJ0LCBSSUdIVDBbc3RhcnQgJiBNT0RdICYgUklHSFQxWyhlbmQgJiBNT0QpICsgMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zZXQoaW5kZXhTdGFydCwgUklHSFQwW3N0YXJ0ICYgTU9EXSk7XG5cbiAgICAgICAgICBfc2V0KGluZGV4RW5kLCBSSUdIVDFbKGVuZCAmIE1PRCkgKyAxXSk7XG5cbiAgICAgICAgICBmb3IgKGkgPSBpbmRleFN0YXJ0ICsgMTsgaSA8IGluZGV4RW5kOyArK2kpIF9zZXQoaSwgMHhmZmZmZmZmZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFyUmFuZ2U6ICh4LCB5LCB4MiwgeTIpID0+IHtcbiAgICAgIGxldCBzdGFydCwgZW5kLCBpbmRleFN0YXJ0LCBpbmRleEVuZCwgaTtcblxuICAgICAgZm9yICg7IHkgPD0geTI7ICsreSkge1xuICAgICAgICBzdGFydCA9IHkgKiB3ICsgeDtcbiAgICAgICAgZW5kID0geSAqIHcgKyB4MjtcbiAgICAgICAgaW5kZXhTdGFydCA9IHN0YXJ0ID4+PiBESVY7XG4gICAgICAgIGluZGV4RW5kID0gZW5kID4+PiBESVY7XG5cbiAgICAgICAgaWYgKGluZGV4U3RhcnQgPT09IGluZGV4RW5kKSB7XG4gICAgICAgICAgX2NsZWFyKGluZGV4U3RhcnQsIFJJR0hUMVtzdGFydCAmIE1PRF0gfCBSSUdIVDBbKGVuZCAmIE1PRCkgKyAxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2NsZWFyKGluZGV4U3RhcnQsIFJJR0hUMVtzdGFydCAmIE1PRF0pO1xuXG4gICAgICAgICAgX2NsZWFyKGluZGV4RW5kLCBSSUdIVDBbKGVuZCAmIE1PRCkgKyAxXSk7XG5cbiAgICAgICAgICBmb3IgKGkgPSBpbmRleFN0YXJ0ICsgMTsgaSA8IGluZGV4RW5kOyArK2kpIF9jbGVhcihpLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb3V0T2ZCb3VuZHM6ICh4LCB5LCB4MiwgeTIpID0+IHggPCAwIHx8IHkgPCAwIHx8IHkyID49IGggfHwgeDIgPj0gd1xuICB9O1xufVxuXG5mdW5jdGlvbiBzY2FsZXIgKHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgY29uc3QgcmF0aW8gPSBNYXRoLm1heCgxLCBNYXRoLnNxcnQod2lkdGggKiBoZWlnaHQgLyAxZTYpKSxcbiAgICAgICAgdyA9IH5+KCh3aWR0aCArIDIgKiBwYWRkaW5nICsgcmF0aW8pIC8gcmF0aW8pLFxuICAgICAgICBoID0gfn4oKGhlaWdodCArIDIgKiBwYWRkaW5nICsgcmF0aW8pIC8gcmF0aW8pLFxuICAgICAgICBzY2FsZSA9IF8gPT4gfn4oKF8gKyBwYWRkaW5nKSAvIHJhdGlvKTtcblxuICBzY2FsZS5pbnZlcnQgPSBfID0+IF8gKiByYXRpbyAtIHBhZGRpbmc7XG5cbiAgc2NhbGUuYml0bWFwID0gKCkgPT4gQml0bWFwKHcsIGgpO1xuXG4gIHNjYWxlLnJhdGlvID0gcmF0aW87XG4gIHNjYWxlLnBhZGRpbmcgPSBwYWRkaW5nO1xuICBzY2FsZS53aWR0aCA9IHdpZHRoO1xuICBzY2FsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gcGxhY2VBcmVhTGFiZWxOYWl2ZSAoJCwgYml0bWFwcywgYXZvaWRCYXNlTWFyaywgbWFya0luZGV4KSB7XG4gIGNvbnN0IHdpZHRoID0gJC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gJC5oZWlnaHQ7IC8vIHRyeSB0byBwbGFjZSBhIGxhYmVsIHdpdGhpbiBhbiBpbnB1dCBhcmVhIG1hcmtcblxuICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICBjb25zdCBpdGVtcyA9IGQuZGF0dW0uZGF0dW0uaXRlbXNbbWFya0luZGV4XS5pdGVtcyxcbiAgICAgICAgICAvLyBhcmVhIHBvaW50c1xuICAgIG4gPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgLy8gbnVtYmVyIG9mIHBvaW50c1xuICAgIHRleHRIZWlnaHQgPSBkLmRhdHVtLmZvbnRTaXplLFxuICAgICAgICAgIC8vIGxhYmVsIHdpZHRoXG4gICAgdGV4dFdpZHRoID0gdGV4dE1ldHJpY3Mud2lkdGgoZC5kYXR1bSwgZC5kYXR1bS50ZXh0KTsgLy8gbGFiZWwgaGVpZ2h0XG5cbiAgICBsZXQgbWF4QXJlYVdpZHRoID0gMCxcbiAgICAgICAgeDEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MSxcbiAgICAgICAgeTIsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFyZWFXaWR0aDsgLy8gZm9yIGVhY2ggYXJlYSBzYW1wbGUgcG9pbnRcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB4MSA9IGl0ZW1zW2ldLng7XG4gICAgICB5MSA9IGl0ZW1zW2ldLnk7XG4gICAgICB4MiA9IGl0ZW1zW2ldLngyID09PSB1bmRlZmluZWQgPyB4MSA6IGl0ZW1zW2ldLngyO1xuICAgICAgeTIgPSBpdGVtc1tpXS55MiA9PT0gdW5kZWZpbmVkID8geTEgOiBpdGVtc1tpXS55MjtcbiAgICAgIHggPSAoeDEgKyB4MikgLyAyO1xuICAgICAgeSA9ICh5MSArIHkyKSAvIDI7XG4gICAgICBhcmVhV2lkdGggPSBNYXRoLmFicyh4MiAtIHgxICsgeTIgLSB5MSk7XG5cbiAgICAgIGlmIChhcmVhV2lkdGggPj0gbWF4QXJlYVdpZHRoKSB7XG4gICAgICAgIG1heEFyZWFXaWR0aCA9IGFyZWFXaWR0aDtcbiAgICAgICAgZC54ID0geDtcbiAgICAgICAgZC55ID0geTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4ID0gdGV4dFdpZHRoIC8gMjtcbiAgICB5ID0gdGV4dEhlaWdodCAvIDI7XG4gICAgeDEgPSBkLnggLSB4O1xuICAgIHgyID0gZC54ICsgeDtcbiAgICB5MSA9IGQueSAtIHk7XG4gICAgeTIgPSBkLnkgKyB5O1xuICAgIGQuYWxpZ24gPSAnY2VudGVyJztcblxuICAgIGlmICh4MSA8IDAgJiYgeDIgPD0gd2lkdGgpIHtcbiAgICAgIGQuYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICgwIDw9IHgxICYmIHdpZHRoIDwgeDIpIHtcbiAgICAgIGQuYWxpZ24gPSAncmlnaHQnO1xuICAgIH1cblxuICAgIGQuYmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIGlmICh5MSA8IDAgJiYgeTIgPD0gaGVpZ2h0KSB7XG4gICAgICBkLmJhc2VsaW5lID0gJ3RvcCc7XG4gICAgfSBlbHNlIGlmICgwIDw9IHkxICYmIGhlaWdodCA8IHkyKSB7XG4gICAgICBkLmJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG91dE9mQm91bmRzKHgsIHksIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgciA9IHRleHRXaWR0aCAvIDI7XG4gIHJldHVybiB4IC0gciA8IDAgfHwgeCArIHIgPiB3aWR0aCB8fCB5IC0gKHIgPSB0ZXh0SGVpZ2h0IC8gMikgPCAwIHx8IHkgKyByID4gaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBfb3V0T2ZCb3VuZHMoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgaCwgYm0wLCBibTEpIHtcbiAgY29uc3QgdyA9IHRleHRXaWR0aCAqIGggLyAodGV4dEhlaWdodCAqIDIpLFxuICAgICAgICB4MSA9ICQoeCAtIHcpLFxuICAgICAgICB4MiA9ICQoeCArIHcpLFxuICAgICAgICB5MSA9ICQoeSAtIChoID0gaCAvIDIpKSxcbiAgICAgICAgeTIgPSAkKHkgKyBoKTtcbiAgcmV0dXJuIGJtMC5vdXRPZkJvdW5kcyh4MSwgeTEsIHgyLCB5MikgfHwgYm0wLmdldFJhbmdlKHgxLCB5MSwgeDIsIHkyKSB8fCBibTEgJiYgYm0xLmdldFJhbmdlKHgxLCB5MSwgeDIsIHkyKTtcbn1cblxuZnVuY3Rpb24gX2NvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIGgsIGJtMCwgYm0xKSB7XG4gIGNvbnN0IHcgPSB0ZXh0V2lkdGggKiBoIC8gKHRleHRIZWlnaHQgKiAyKTtcbiAgbGV0IHgxID0gJCh4IC0gdyksXG4gICAgICB4MiA9ICQoeCArIHcpLFxuICAgICAgeTEgPSAkKHkgLSAoaCA9IGggLyAyKSksXG4gICAgICB5MiA9ICQoeSArIGgpO1xuICB4MSA9IHgxID4gMCA/IHgxIDogMDtcbiAgeTEgPSB5MSA+IDAgPyB5MSA6IDA7XG4gIHgyID0geDIgPCAkLndpZHRoID8geDIgOiAkLndpZHRoIC0gMTtcbiAgeTIgPSB5MiA8ICQuaGVpZ2h0ID8geTIgOiAkLmhlaWdodCAtIDE7XG4gIHJldHVybiBibTAuZ2V0UmFuZ2UoeDEsIHkxLCB4MiwgeTIpIHx8IGJtMSAmJiBibTEuZ2V0UmFuZ2UoeDEsIHkxLCB4MiwgeTIpO1xufVxuXG5mdW5jdGlvbiBnZXRUZXN0cyhpbmZQYWRkaW5nKSB7XG4gIHJldHVybiBpbmZQYWRkaW5nID8gW19jb2xsaXNpb24sIF9vdXRPZkJvdW5kc10gOiBbY29sbGlzaW9uLCBvdXRPZkJvdW5kc107XG59XG5cbmZ1bmN0aW9uIHBsYWNlQXJlYUxhYmVsUmVkdWNlZFNlYXJjaCAoJCwgYml0bWFwcywgYXZvaWRCYXNlTWFyaywgbWFya0luZGV4LCBpbmZQYWRkaW5nKSB7XG4gIGNvbnN0IHdpZHRoID0gJC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gJC5oZWlnaHQsXG4gICAgICAgIFtjb2xsaXNpb24sIG91dE9mQm91bmRzXSA9IGdldFRlc3RzKGluZlBhZGRpbmcpLFxuICAgICAgICBibTAgPSBiaXRtYXBzWzBdLFxuICAgICAgICAvLyB3aGVyZSBsYWJlbHMgaGF2ZSBiZWVuIHBsYWNlZFxuICBibTEgPSBiaXRtYXBzWzFdOyAvLyBhcmVhIG91dGxpbmVzXG5cbiAgZnVuY3Rpb24gdHJ5TGFiZWwoX3gsIF95LCBtYXhTaXplLCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQpIHtcbiAgICBjb25zdCB4ID0gJC5pbnZlcnQoX3gpLFxuICAgICAgICAgIHkgPSAkLmludmVydChfeSk7XG4gICAgbGV0IGxvID0gbWF4U2l6ZSxcbiAgICAgICAgaGkgPSBoZWlnaHQsXG4gICAgICAgIG1pZDtcblxuICAgIGlmICghb3V0T2ZCb3VuZHMoeCwgeSwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KSAmJiAhY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgbG8sIGJtMCwgYm0xKSAmJiAhY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgYm0wLCBudWxsKSkge1xuICAgICAgLy8gaWYgdGhlIGxhYmVsIGZpdHMgYXQgdGhlIGN1cnJlbnQgc2FtcGxlIHBvaW50LFxuICAgICAgLy8gcGVyZm9ybSBiaW5hcnkgc2VhcmNoIHRvIGZpbmQgdGhlIGxhcmdlc3QgZm9udCBzaXplIHRoYXQgZml0c1xuICAgICAgd2hpbGUgKGhpIC0gbG8gPj0gMSkge1xuICAgICAgICBtaWQgPSAobG8gKyBoaSkgLyAyO1xuXG4gICAgICAgIGlmIChjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCBtaWQsIGJtMCwgYm0xKSkge1xuICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9IC8vIHBsYWNlIGxhYmVsIGlmIGN1cnJlbnQgbG93ZXIgYm91bmQgZXhjZWVkcyBwcmlvciBtYXggZm9udCBzaXplXG5cblxuICAgICAgaWYgKGxvID4gbWF4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW3gsIHksIGxvLCB0cnVlXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gdHJ5IHRvIHBsYWNlIGEgbGFiZWwgd2l0aGluIGFuIGlucHV0IGFyZWEgbWFya1xuXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgY29uc3QgaXRlbXMgPSBkLmRhdHVtLmRhdHVtLml0ZW1zW21hcmtJbmRleF0uaXRlbXMsXG4gICAgICAgICAgLy8gYXJlYSBwb2ludHNcbiAgICBuID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIC8vIG51bWJlciBvZiBwb2ludHNcbiAgICB0ZXh0SGVpZ2h0ID0gZC5kYXR1bS5mb250U2l6ZSxcbiAgICAgICAgICAvLyBsYWJlbCB3aWR0aFxuICAgIHRleHRXaWR0aCA9IHRleHRNZXRyaWNzLndpZHRoKGQuZGF0dW0sIGQuZGF0dW0udGV4dCk7IC8vIGxhYmVsIGhlaWdodFxuXG4gICAgbGV0IG1heFNpemUgPSBhdm9pZEJhc2VNYXJrID8gdGV4dEhlaWdodCA6IDAsXG4gICAgICAgIGxhYmVsUGxhY2VkID0gZmFsc2UsXG4gICAgICAgIGxhYmVsUGxhY2VkMiA9IGZhbHNlLFxuICAgICAgICBtYXhBcmVhV2lkdGggPSAwLFxuICAgICAgICB4MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkxLFxuICAgICAgICB5MixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgX3gsXG4gICAgICAgIF95LFxuICAgICAgICBfeDEsXG4gICAgICAgIF94TWlkLFxuICAgICAgICBfeDIsXG4gICAgICAgIF95MSxcbiAgICAgICAgX3lNaWQsXG4gICAgICAgIF95MixcbiAgICAgICAgYXJlYVdpZHRoLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHN3YXBUbXA7IC8vIGZvciBlYWNoIGFyZWEgc2FtcGxlIHBvaW50XG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB4MSA9IGl0ZW1zW2ldLng7XG4gICAgICB5MSA9IGl0ZW1zW2ldLnk7XG4gICAgICB4MiA9IGl0ZW1zW2ldLngyID09PSB1bmRlZmluZWQgPyB4MSA6IGl0ZW1zW2ldLngyO1xuICAgICAgeTIgPSBpdGVtc1tpXS55MiA9PT0gdW5kZWZpbmVkID8geTEgOiBpdGVtc1tpXS55MjtcblxuICAgICAgaWYgKHgxID4geDIpIHtcbiAgICAgICAgc3dhcFRtcCA9IHgxO1xuICAgICAgICB4MSA9IHgyO1xuICAgICAgICB4MiA9IHN3YXBUbXA7XG4gICAgICB9XG5cbiAgICAgIGlmICh5MSA+IHkyKSB7XG4gICAgICAgIHN3YXBUbXAgPSB5MTtcbiAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgeTIgPSBzd2FwVG1wO1xuICAgICAgfVxuXG4gICAgICBfeDEgPSAkKHgxKTtcbiAgICAgIF94MiA9ICQoeDIpO1xuICAgICAgX3hNaWQgPSB+figoX3gxICsgX3gyKSAvIDIpO1xuICAgICAgX3kxID0gJCh5MSk7XG4gICAgICBfeTIgPSAkKHkyKTtcbiAgICAgIF95TWlkID0gfn4oKF95MSArIF95MikgLyAyKTsgLy8gc2VhcmNoIGFsb25nIHRoZSBsaW5lIGZyb20gbWlkIHBvaW50IGJldHdlZW4gdGhlIDIgYm9yZGVyIHRvIGxvd2VyIGJvcmRlclxuXG4gICAgICBmb3IgKF94ID0gX3hNaWQ7IF94ID49IF94MTsgLS1feCkge1xuICAgICAgICBmb3IgKF95ID0gX3lNaWQ7IF95ID49IF95MTsgLS1feSkge1xuICAgICAgICAgIHJlc3VsdCA9IHRyeUxhYmVsKF94LCBfeSwgbWF4U2l6ZSwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIFtkLngsIGQueSwgbWF4U2l6ZSwgbGFiZWxQbGFjZWRdID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBzZWFyY2ggYWxvbmcgdGhlIGxpbmUgZnJvbSBtaWQgcG9pbnQgYmV0d2VlbiB0aGUgMiBib3JkZXIgdG8gdXBwZXIgYm9yZGVyXG5cblxuICAgICAgZm9yIChfeCA9IF94TWlkOyBfeCA8PSBfeDI7ICsrX3gpIHtcbiAgICAgICAgZm9yIChfeSA9IF95TWlkOyBfeSA8PSBfeTI7ICsrX3kpIHtcbiAgICAgICAgICByZXN1bHQgPSB0cnlMYWJlbChfeCwgX3ksIG1heFNpemUsIHRleHRXaWR0aCwgdGV4dEhlaWdodCk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBbZC54LCBkLnksIG1heFNpemUsIGxhYmVsUGxhY2VkXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcGxhY2UgbGFiZWwgYXQgc2xpY2UgY2VudGVyIGlmIG5vdCBwbGFjZWQgdGhyb3VnaCBvdGhlciBtZWFuc1xuICAgICAgLy8gYW5kIGlmIHdlJ3JlIG5vdCBhdm9pZGluZyBvdmVybGFwIHdpdGggb3RoZXIgYXJlYXNcblxuXG4gICAgICBpZiAoIWxhYmVsUGxhY2VkICYmICFhdm9pZEJhc2VNYXJrKSB7XG4gICAgICAgIC8vIG9uZSBzcGFuIGlzIHplcm8sIGhlbmNlIHdlIGNhbiBhZGRcbiAgICAgICAgYXJlYVdpZHRoID0gTWF0aC5hYnMoeDIgLSB4MSArIHkyIC0geTEpO1xuICAgICAgICB4ID0gKHgxICsgeDIpIC8gMjtcbiAgICAgICAgeSA9ICh5MSArIHkyKSAvIDI7IC8vIHBsYWNlIGxhYmVsIGlmIGl0IGZpdHMgYW5kIGltcHJvdmVzIHRoZSBtYXggYXJlYSB3aWR0aFxuXG4gICAgICAgIGlmIChhcmVhV2lkdGggPj0gbWF4QXJlYVdpZHRoICYmICFvdXRPZkJvdW5kcyh4LCB5LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIHdpZHRoLCBoZWlnaHQpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCBibTAsIG51bGwpKSB7XG4gICAgICAgICAgbWF4QXJlYVdpZHRoID0gYXJlYVdpZHRoO1xuICAgICAgICAgIGQueCA9IHg7XG4gICAgICAgICAgZC55ID0geTtcbiAgICAgICAgICBsYWJlbFBsYWNlZDIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyByZWNvcmQgY3VycmVudCBsYWJlbCBwbGFjZW1lbnQgaW5mb3JtYXRpb24sIHVwZGF0ZSBsYWJlbCBiaXRtYXBcblxuXG4gICAgaWYgKGxhYmVsUGxhY2VkIHx8IGxhYmVsUGxhY2VkMikge1xuICAgICAgeCA9IHRleHRXaWR0aCAvIDI7XG4gICAgICB5ID0gdGV4dEhlaWdodCAvIDI7XG4gICAgICBibTAuc2V0UmFuZ2UoJChkLnggLSB4KSwgJChkLnkgLSB5KSwgJChkLnggKyB4KSwgJChkLnkgKyB5KSk7XG4gICAgICBkLmFsaWduID0gJ2NlbnRlcic7XG4gICAgICBkLmJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgWF9ESVIgPSBbLTEsIC0xLCAxLCAxXTtcbmNvbnN0IFlfRElSID0gWy0xLCAxLCAtMSwgMV07XG5mdW5jdGlvbiBwbGFjZUFyZWFMYWJlbEZsb29kRmlsbCAoJCwgYml0bWFwcywgYXZvaWRCYXNlTWFyaywgbWFya0luZGV4LCBpbmZQYWRkaW5nKSB7XG4gIGNvbnN0IHdpZHRoID0gJC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gJC5oZWlnaHQsXG4gICAgICAgIFtjb2xsaXNpb24sIG91dE9mQm91bmRzXSA9IGdldFRlc3RzKGluZlBhZGRpbmcpLFxuICAgICAgICBibTAgPSBiaXRtYXBzWzBdLFxuICAgICAgICAvLyB3aGVyZSBsYWJlbHMgaGF2ZSBiZWVuIHBsYWNlZFxuICBibTEgPSBiaXRtYXBzWzFdLFxuICAgICAgICAvLyBhcmVhIG91dGxpbmVzXG4gIGJtMiA9ICQuYml0bWFwKCk7IC8vIGZsb29kLWZpbGwgdmlzaXRhdGlvbnNcbiAgLy8gdHJ5IHRvIHBsYWNlIGEgbGFiZWwgd2l0aGluIGFuIGlucHV0IGFyZWEgbWFya1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGNvbnN0IGl0ZW1zID0gZC5kYXR1bS5kYXR1bS5pdGVtc1ttYXJrSW5kZXhdLml0ZW1zLFxuICAgICAgICAgIC8vIGFyZWEgcG9pbnRzXG4gICAgbiA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAvLyBudW1iZXIgb2YgcG9pbnRzXG4gICAgdGV4dEhlaWdodCA9IGQuZGF0dW0uZm9udFNpemUsXG4gICAgICAgICAgLy8gbGFiZWwgd2lkdGhcbiAgICB0ZXh0V2lkdGggPSB0ZXh0TWV0cmljcy53aWR0aChkLmRhdHVtLCBkLmRhdHVtLnRleHQpLFxuICAgICAgICAgIC8vIGxhYmVsIGhlaWdodFxuICAgIHN0YWNrID0gW107IC8vIGZsb29kIGZpbGwgc3RhY2tcblxuICAgIGxldCBtYXhTaXplID0gYXZvaWRCYXNlTWFyayA/IHRleHRIZWlnaHQgOiAwLFxuICAgICAgICBsYWJlbFBsYWNlZCA9IGZhbHNlLFxuICAgICAgICBsYWJlbFBsYWNlZDIgPSBmYWxzZSxcbiAgICAgICAgbWF4QXJlYVdpZHRoID0gMCxcbiAgICAgICAgeDEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MSxcbiAgICAgICAgeTIsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIF94LFxuICAgICAgICBfeSxcbiAgICAgICAgbG8sXG4gICAgICAgIGhpLFxuICAgICAgICBtaWQsXG4gICAgICAgIGFyZWFXaWR0aDsgLy8gZm9yIGVhY2ggYXJlYSBzYW1wbGUgcG9pbnRcblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHgxID0gaXRlbXNbaV0ueDtcbiAgICAgIHkxID0gaXRlbXNbaV0ueTtcbiAgICAgIHgyID0gaXRlbXNbaV0ueDIgPT09IHVuZGVmaW5lZCA/IHgxIDogaXRlbXNbaV0ueDI7XG4gICAgICB5MiA9IGl0ZW1zW2ldLnkyID09PSB1bmRlZmluZWQgPyB5MSA6IGl0ZW1zW2ldLnkyOyAvLyBhZGQgc2NhbGVkIGNlbnRlciBwb2ludCB0byBzdGFja1xuXG4gICAgICBzdGFjay5wdXNoKFskKCh4MSArIHgyKSAvIDIpLCAkKCh5MSArIHkyKSAvIDIpXSk7IC8vIHBlcmZvcm0gZmxvb2QgZmlsbCwgdmlzaXQgcG9pbnRzXG5cbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgW194LCBfeV0gPSBzdGFjay5wb3AoKTsgLy8gZXhpdCBpZiBwb2ludCBhbHJlYWR5IG1hcmtlZFxuXG4gICAgICAgIGlmIChibTAuZ2V0KF94LCBfeSkgfHwgYm0xLmdldChfeCwgX3kpIHx8IGJtMi5nZXQoX3gsIF95KSkgY29udGludWU7IC8vIG1hcmsgcG9pbnQgaW4gZmxvb2QgZmlsbCBiaXRtYXBcbiAgICAgICAgLy8gYWRkIHNlYXJjaCBwb2ludHMgZm9yIGFsbCAoaW4gYm91bmQpIGRpcmVjdGlvbnNcblxuICAgICAgICBibTIuc2V0KF94LCBfeSk7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcbiAgICAgICAgICB4ID0gX3ggKyBYX0RJUltqXTtcbiAgICAgICAgICB5ID0gX3kgKyBZX0RJUltqXTtcbiAgICAgICAgICBpZiAoIWJtMi5vdXRPZkJvdW5kcyh4LCB5LCB4LCB5KSkgc3RhY2sucHVzaChbeCwgeV0pO1xuICAgICAgICB9IC8vIHVuc2NhbGUgcG9pbnQgYmFjayB0byB4LCB5IHNwYWNlXG5cblxuICAgICAgICB4ID0gJC5pbnZlcnQoX3gpO1xuICAgICAgICB5ID0gJC5pbnZlcnQoX3kpO1xuICAgICAgICBsbyA9IG1heFNpemU7XG4gICAgICAgIGhpID0gaGVpZ2h0OyAvLyBUT0RPOiBtYWtlIHRoaXMgYm91bmQgc21hbGxlclxuXG4gICAgICAgIGlmICghb3V0T2ZCb3VuZHMoeCwgeSwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KSAmJiAhY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgbG8sIGJtMCwgYm0xKSAmJiAhY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgYm0wLCBudWxsKSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCBmaXRzIGF0IHRoZSBjdXJyZW50IHNhbXBsZSBwb2ludCxcbiAgICAgICAgICAvLyBwZXJmb3JtIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgbGFyZ2VzdCBmb250IHNpemUgdGhhdCBmaXRzXG4gICAgICAgICAgd2hpbGUgKGhpIC0gbG8gPj0gMSkge1xuICAgICAgICAgICAgbWlkID0gKGxvICsgaGkpIC8gMjtcblxuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIG1pZCwgYm0wLCBibTEpKSB7XG4gICAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG8gPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBwbGFjZSBsYWJlbCBpZiBjdXJyZW50IGxvd2VyIGJvdW5kIGV4Y2VlZHMgcHJpb3IgbWF4IGZvbnQgc2l6ZVxuXG5cbiAgICAgICAgICBpZiAobG8gPiBtYXhTaXplKSB7XG4gICAgICAgICAgICBkLnggPSB4O1xuICAgICAgICAgICAgZC55ID0geTtcbiAgICAgICAgICAgIG1heFNpemUgPSBsbztcbiAgICAgICAgICAgIGxhYmVsUGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcGxhY2UgbGFiZWwgYXQgc2xpY2UgY2VudGVyIGlmIG5vdCBwbGFjZWQgdGhyb3VnaCBvdGhlciBtZWFuc1xuICAgICAgLy8gYW5kIGlmIHdlJ3JlIG5vdCBhdm9pZGluZyBvdmVybGFwIHdpdGggb3RoZXIgYXJlYXNcblxuXG4gICAgICBpZiAoIWxhYmVsUGxhY2VkICYmICFhdm9pZEJhc2VNYXJrKSB7XG4gICAgICAgIC8vIG9uZSBzcGFuIGlzIHplcm8sIGhlbmNlIHdlIGNhbiBhZGRcbiAgICAgICAgYXJlYVdpZHRoID0gTWF0aC5hYnMoeDIgLSB4MSArIHkyIC0geTEpO1xuICAgICAgICB4ID0gKHgxICsgeDIpIC8gMjtcbiAgICAgICAgeSA9ICh5MSArIHkyKSAvIDI7IC8vIHBsYWNlIGxhYmVsIGlmIGl0IGZpdHMgYW5kIGltcHJvdmVzIHRoZSBtYXggYXJlYSB3aWR0aFxuXG4gICAgICAgIGlmIChhcmVhV2lkdGggPj0gbWF4QXJlYVdpZHRoICYmICFvdXRPZkJvdW5kcyh4LCB5LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIHdpZHRoLCBoZWlnaHQpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCBibTAsIG51bGwpKSB7XG4gICAgICAgICAgbWF4QXJlYVdpZHRoID0gYXJlYVdpZHRoO1xuICAgICAgICAgIGQueCA9IHg7XG4gICAgICAgICAgZC55ID0geTtcbiAgICAgICAgICBsYWJlbFBsYWNlZDIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyByZWNvcmQgY3VycmVudCBsYWJlbCBwbGFjZW1lbnQgaW5mb3JtYXRpb24sIHVwZGF0ZSBsYWJlbCBiaXRtYXBcblxuXG4gICAgaWYgKGxhYmVsUGxhY2VkIHx8IGxhYmVsUGxhY2VkMikge1xuICAgICAgeCA9IHRleHRXaWR0aCAvIDI7XG4gICAgICB5ID0gdGV4dEhlaWdodCAvIDI7XG4gICAgICBibTAuc2V0UmFuZ2UoJChkLnggLSB4KSwgJChkLnkgLSB5KSwgJChkLnggKyB4KSwgJChkLnkgKyB5KSk7XG4gICAgICBkLmFsaWduID0gJ2NlbnRlcic7XG4gICAgICBkLmJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgQWxpZ25zID0gWydyaWdodCcsICdjZW50ZXInLCAnbGVmdCddLFxuICAgICAgQmFzZWxpbmVzID0gWydib3R0b20nLCAnbWlkZGxlJywgJ3RvcCddO1xuZnVuY3Rpb24gcGxhY2VNYXJrTGFiZWwgKCQsIGJpdG1hcHMsIGFuY2hvcnMsIG9mZnNldHMsIGluZlBhZGRpbmcpIHtcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSAkLmhlaWdodCxcbiAgICAgICAgYm0wID0gYml0bWFwc1swXSxcbiAgICAgICAgYm0xID0gYml0bWFwc1sxXSxcbiAgICAgICAgbiA9IG9mZnNldHMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICBjb25zdCBib3VuZGFyeSA9IGQuYm91bmRhcnksXG4gICAgICAgICAgdGV4dEhlaWdodCA9IGQuZGF0dW0uZm9udFNpemU7IC8vIGNhbiBub3QgYmUgcGxhY2VkIGlmIHRoZSBtYXJrIGlzIG5vdCB2aXNpYmxlIGluIHRoZSBncmFwaCBib3VuZFxuXG4gICAgaWYgKCFpbmZQYWRkaW5nICYmIChib3VuZGFyeVsyXSA8IDAgfHwgYm91bmRhcnlbNV0gPCAwIHx8IGJvdW5kYXJ5WzBdID4gd2lkdGggfHwgYm91bmRhcnlbM10gPiBoZWlnaHQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHRleHRXaWR0aCA9IDAsXG4gICAgICAgIGR4LFxuICAgICAgICBkeSxcbiAgICAgICAgaXNJbnNpZGUsXG4gICAgICAgIHNpemVGYWN0b3IsXG4gICAgICAgIGluc2lkZUZhY3RvcixcbiAgICAgICAgeDEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MSxcbiAgICAgICAgeTIsXG4gICAgICAgIHhjLFxuICAgICAgICB5YyxcbiAgICAgICAgX3gxLFxuICAgICAgICBfeDIsXG4gICAgICAgIF95MSxcbiAgICAgICAgX3kyOyAvLyBmb3IgZWFjaCBhbmNob3IgYW5kIG9mZnNldFxuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZHggPSAoYW5jaG9yc1tpXSAmIDB4MykgLSAxO1xuICAgICAgZHkgPSAoYW5jaG9yc1tpXSA+Pj4gMHgyICYgMHgzKSAtIDE7XG4gICAgICBpc0luc2lkZSA9IGR4ID09PSAwICYmIGR5ID09PSAwIHx8IG9mZnNldHNbaV0gPCAwO1xuICAgICAgc2l6ZUZhY3RvciA9IGR4ICYmIGR5ID8gTWF0aC5TUVJUMV8yIDogMTtcbiAgICAgIGluc2lkZUZhY3RvciA9IG9mZnNldHNbaV0gPCAwID8gLTEgOiAxO1xuICAgICAgeDEgPSBib3VuZGFyeVsxICsgZHhdICsgb2Zmc2V0c1tpXSAqIGR4ICogc2l6ZUZhY3RvcjtcbiAgICAgIHljID0gYm91bmRhcnlbNCArIGR5XSArIGluc2lkZUZhY3RvciAqIHRleHRIZWlnaHQgKiBkeSAvIDIgKyBvZmZzZXRzW2ldICogZHkgKiBzaXplRmFjdG9yO1xuICAgICAgeTEgPSB5YyAtIHRleHRIZWlnaHQgLyAyO1xuICAgICAgeTIgPSB5YyArIHRleHRIZWlnaHQgLyAyO1xuICAgICAgX3gxID0gJCh4MSk7XG4gICAgICBfeTEgPSAkKHkxKTtcbiAgICAgIF95MiA9ICQoeTIpO1xuXG4gICAgICBpZiAoaW5mUGFkZGluZykge1xuICAgICAgICBfeDEgPSBfeDEgPCAwID8gMCA6IF94MTtcbiAgICAgICAgX3kxID0gX3kxIDwgMCA/IDAgOiBfeTE7XG4gICAgICAgIF95MiA9IF95MiA+PSAkLmhlaWdodCA/ICQuaGVpZ2h0IC0gMSA6IF95MjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICAgICAgLy8gdG8gYXZvaWQgZmluZGluZyB3aWR0aCBvZiB0ZXh0IGxhYmVsLFxuICAgICAgICBpZiAoIXRlc3QoX3gxLCBfeDEsIF95MSwgX3kyLCBibTAsIGJtMSwgeDEsIHgxLCB5MSwgeTIsIGJvdW5kYXJ5LCBpc0luc2lkZSkpIHtcbiAgICAgICAgICAvLyBza2lwIHRoaXMgYW5jaG9yL29mZnNldCBvcHRpb24gaWYgd2UgZmFpbCB0byBwbGFjZSBhIGxhYmVsIHdpdGggMXB4IHdpZHRoXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBmaW5kIHRoZSBsYWJlbCB3aWR0aFxuICAgICAgICAgIHRleHRXaWR0aCA9IHRleHRNZXRyaWNzLndpZHRoKGQuZGF0dW0sIGQuZGF0dW0udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeGMgPSB4MSArIGluc2lkZUZhY3RvciAqIHRleHRXaWR0aCAqIGR4IC8gMjtcbiAgICAgIHgxID0geGMgLSB0ZXh0V2lkdGggLyAyO1xuICAgICAgeDIgPSB4YyArIHRleHRXaWR0aCAvIDI7XG4gICAgICBfeDEgPSAkKHgxKTtcbiAgICAgIF94MiA9ICQoeDIpO1xuXG4gICAgICBpZiAoaW5mUGFkZGluZykge1xuICAgICAgICBfeDEgPSBfeDEgPCAwID8gMCA6IF94MTtcbiAgICAgICAgX3gyID0gX3gyID49ICQud2lkdGggPyAkLndpZHRoIC0gMSA6IF94MjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRlc3QoX3gxLCBfeDIsIF95MSwgX3kyLCBibTAsIGJtMSwgeDEsIHgyLCB5MSwgeTIsIGJvdW5kYXJ5LCBpc0luc2lkZSkpIHtcbiAgICAgICAgLy8gcGxhY2UgbGFiZWwgaWYgdGhlIHBvc2l0aW9uIGlzIHBsYWNlYWJsZVxuICAgICAgICBkLnggPSAhZHggPyB4YyA6IGR4ICogaW5zaWRlRmFjdG9yIDwgMCA/IHgyIDogeDE7XG4gICAgICAgIGQueSA9ICFkeSA/IHljIDogZHkgKiBpbnNpZGVGYWN0b3IgPCAwID8geTIgOiB5MTtcbiAgICAgICAgZC5hbGlnbiA9IEFsaWduc1tkeCAqIGluc2lkZUZhY3RvciArIDFdO1xuICAgICAgICBkLmJhc2VsaW5lID0gQmFzZWxpbmVzW2R5ICogaW5zaWRlRmFjdG9yICsgMV07XG4gICAgICAgIGJtMC5zZXRSYW5nZShfeDEsIF95MSwgX3gyLCBfeTIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59IC8vIFRlc3QgaWYgYSBsYWJlbCB3aXRoIHRoZSBnaXZlbiBkaW1lbnNpb25zIGNhbiBiZSBhZGRlZCB3aXRob3V0IG92ZXJsYXBcblxuZnVuY3Rpb24gdGVzdChfeDEsIF94MiwgX3kxLCBfeTIsIGJtMCwgYm0xLCB4MSwgeDIsIHkxLCB5MiwgYm91bmRhcnksIGlzSW5zaWRlKSB7XG4gIHJldHVybiAhKGJtMC5vdXRPZkJvdW5kcyhfeDEsIF95MSwgX3gyLCBfeTIpIHx8IChpc0luc2lkZSAmJiBibTEgPyBibTEuZ2V0UmFuZ2UoX3gxLCBfeTEsIF94MiwgX3kyKSB8fCAhaXNJbk1hcmtCb3VuZCh4MSwgeTEsIHgyLCB5MiwgYm91bmRhcnkpIDogYm0wLmdldFJhbmdlKF94MSwgX3kxLCBfeDIsIF95MikpKTtcbn1cblxuZnVuY3Rpb24gaXNJbk1hcmtCb3VuZCh4MSwgeTEsIHgyLCB5MiwgYm91bmRhcnkpIHtcbiAgcmV0dXJuIGJvdW5kYXJ5WzBdIDw9IHgxICYmIHgyIDw9IGJvdW5kYXJ5WzJdICYmIGJvdW5kYXJ5WzNdIDw9IHkxICYmIHkyIDw9IGJvdW5kYXJ5WzVdO1xufVxuXG5jb25zdCBUT1AgPSAweDAsXG4gICAgICBNSURETEUgPSAweDQsXG4gICAgICBCT1RUT00gPSAweDgsXG4gICAgICBMRUZUID0gMHgwLFxuICAgICAgQ0VOVEVSID0gMHgxLFxuICAgICAgUklHSFQgPSAweDI7IC8vIE1hcHBpbmcgZnJvbSB0ZXh0IGFuY2hvciB0byBudW1iZXIgcmVwcmVzZW50YXRpb25cblxuY29uc3QgYW5jaG9yQ29kZSA9IHtcbiAgJ3RvcC1sZWZ0JzogVE9QICsgTEVGVCxcbiAgJ3RvcCc6IFRPUCArIENFTlRFUixcbiAgJ3RvcC1yaWdodCc6IFRPUCArIFJJR0hULFxuICAnbGVmdCc6IE1JRERMRSArIExFRlQsXG4gICdtaWRkbGUnOiBNSURETEUgKyBDRU5URVIsXG4gICdyaWdodCc6IE1JRERMRSArIFJJR0hULFxuICAnYm90dG9tLWxlZnQnOiBCT1RUT00gKyBMRUZULFxuICAnYm90dG9tJzogQk9UVE9NICsgQ0VOVEVSLFxuICAnYm90dG9tLXJpZ2h0JzogQk9UVE9NICsgUklHSFRcbn07XG5jb25zdCBwbGFjZUFyZWFMYWJlbCA9IHtcbiAgJ25haXZlJzogcGxhY2VBcmVhTGFiZWxOYWl2ZSxcbiAgJ3JlZHVjZWQtc2VhcmNoJzogcGxhY2VBcmVhTGFiZWxSZWR1Y2VkU2VhcmNoLFxuICAnZmxvb2RmaWxsJzogcGxhY2VBcmVhTGFiZWxGbG9vZEZpbGxcbn07XG5mdW5jdGlvbiBsYWJlbExheW91dCAodGV4dHMsIHNpemUsIGNvbXBhcmUsIG9mZnNldCwgYW5jaG9yLCBhdm9pZE1hcmtzLCBhdm9pZEJhc2VNYXJrLCBsaW5lQW5jaG9yLCBtYXJrSW5kZXgsIHBhZGRpbmcsIG1ldGhvZCkge1xuICAvLyBlYXJseSBleGl0IGZvciBlbXB0eSBkYXRhXG4gIGlmICghdGV4dHMubGVuZ3RoKSByZXR1cm4gdGV4dHM7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IE1hdGgubWF4KG9mZnNldC5sZW5ndGgsIGFuY2hvci5sZW5ndGgpLFxuICAgICAgICBvZmZzZXRzID0gZ2V0T2Zmc2V0cyhvZmZzZXQsIHBvc2l0aW9ucyksXG4gICAgICAgIGFuY2hvcnMgPSBnZXRBbmNob3JzKGFuY2hvciwgcG9zaXRpb25zKSxcbiAgICAgICAgbWFya3R5cGUgPSBtYXJrVHlwZSh0ZXh0c1swXS5kYXR1bSksXG4gICAgICAgIGdyb3VwdHlwZSA9IG1hcmt0eXBlID09PSAnZ3JvdXAnICYmIHRleHRzWzBdLmRhdHVtLml0ZW1zW21hcmtJbmRleF0ubWFya3R5cGUsXG4gICAgICAgIGlzR3JvdXBBcmVhID0gZ3JvdXB0eXBlID09PSAnYXJlYScsXG4gICAgICAgIGJvdW5kYXJ5ID0gbWFya0JvdW5kYXJ5KG1hcmt0eXBlLCBncm91cHR5cGUsIGxpbmVBbmNob3IsIG1hcmtJbmRleCksXG4gICAgICAgIGluZlBhZGRpbmcgPSBwYWRkaW5nID09PSBudWxsIHx8IHBhZGRpbmcgPT09IEluZmluaXR5LFxuICAgICAgICAkID0gc2NhbGVyKHNpemVbMF0sIHNpemVbMV0sIGluZlBhZGRpbmcgPyAwIDogcGFkZGluZyksXG4gICAgICAgIGlzTmFpdmVHcm91cEFyZWEgPSBpc0dyb3VwQXJlYSAmJiBtZXRob2QgPT09ICduYWl2ZSc7IC8vIHByZXBhcmUgdGV4dCBtYXJrIGRhdGEgZm9yIHBsYWNpbmdcblxuICBjb25zdCBkYXRhID0gdGV4dHMubWFwKGQgPT4gKHtcbiAgICBkYXR1bTogZCxcbiAgICBvcGFjaXR5OiAwLFxuICAgIHg6IHVuZGVmaW5lZCxcbiAgICB5OiB1bmRlZmluZWQsXG4gICAgYWxpZ246IHVuZGVmaW5lZCxcbiAgICBiYXNlbGluZTogdW5kZWZpbmVkLFxuICAgIGJvdW5kYXJ5OiBib3VuZGFyeShkKVxuICB9KSk7XG4gIGxldCBiaXRtYXBzO1xuXG4gIGlmICghaXNOYWl2ZUdyb3VwQXJlYSkge1xuICAgIC8vIHNvcnQgbGFiZWxzIGluIHByaW9yaXR5IG9yZGVyLCBpZiBjb21wYXJhdG9yIGlzIHByb3ZpZGVkXG4gICAgaWYgKGNvbXBhcmUpIHtcbiAgICAgIGRhdGEuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLmRhdHVtLCBiLmRhdHVtKSk7XG4gICAgfSAvLyBmbGFnIGluZGljYXRpbmcgaWYgbGFiZWwgY2FuIGJlIHBsYWNlZCBpbnNpZGUgaXRzIGJhc2UgbWFya1xuXG5cbiAgICBsZXQgbGFiZWxJbnNpZGUgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW5jaG9ycy5sZW5ndGggJiYgIWxhYmVsSW5zaWRlOyArK2kpIHtcbiAgICAgIC8vIGxhYmVsIGluc2lkZSBpZiBhbmNob3IgaXMgYXQgY2VudGVyXG4gICAgICAvLyBsYWJlbCBpbnNpZGUgaWYgb2Zmc2V0IHRvIGJlIGluc2lkZSB0aGUgbWFyayBib3VuZFxuICAgICAgbGFiZWxJbnNpZGUgPSBhbmNob3JzW2ldID09PSAweDUgfHwgb2Zmc2V0c1tpXSA8IDA7XG4gICAgfSAvLyBleHRyYWN0IGRhdGEgaW5mb3JtYXRpb24gZnJvbSBiYXNlIG1hcmsgd2hlbiBiYXNlIG1hcmsgaXMgdG8gYmUgYXZvaWRlZFxuICAgIC8vIGJhc2UgbWFyayBpcyBpbXBsaWNpdGx5IGF2b2lkZWQgaWYgaXQgaXMgYSBncm91cCBhcmVhXG5cblxuICAgIGlmIChtYXJrdHlwZSAmJiAoYXZvaWRCYXNlTWFyayB8fCBpc0dyb3VwQXJlYSkpIHtcbiAgICAgIGF2b2lkTWFya3MgPSBbdGV4dHMubWFwKGQgPT4gZC5kYXR1bSldLmNvbmNhdChhdm9pZE1hcmtzKTtcbiAgICB9IC8vIGdlbmVyYXRlIGJpdG1hcHMgZm9yIGxheW91dCBjYWxjdWxhdGlvblxuXG5cbiAgICBiaXRtYXBzID0gYXZvaWRNYXJrcy5sZW5ndGggPyBtYXJrQml0bWFwcygkLCBhdm9pZE1hcmtzLCBsYWJlbEluc2lkZSwgaXNHcm91cEFyZWEpIDogYmFzZUJpdG1hcHMoJCwgYXZvaWRCYXNlTWFyayAmJiBkYXRhKTtcbiAgfSAvLyBnZW5lcmF0ZSBsYWJlbCBwbGFjZW1lbnQgZnVuY3Rpb25cblxuXG4gIGNvbnN0IHBsYWNlID0gaXNHcm91cEFyZWEgPyBwbGFjZUFyZWFMYWJlbFttZXRob2RdKCQsIGJpdG1hcHMsIGF2b2lkQmFzZU1hcmssIG1hcmtJbmRleCwgaW5mUGFkZGluZykgOiBwbGFjZU1hcmtMYWJlbCgkLCBiaXRtYXBzLCBhbmNob3JzLCBvZmZzZXRzLCBpbmZQYWRkaW5nKTsgLy8gcGxhY2UgYWxsIGxhYmVsc1xuXG4gIGRhdGEuZm9yRWFjaChkID0+IGQub3BhY2l0eSA9ICtwbGFjZShkKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRzKF8sIGNvdW50KSB7XG4gIGNvbnN0IG9mZnNldHMgPSBuZXcgRmxvYXQ2NEFycmF5KGNvdW50KSxcbiAgICAgICAgbiA9IF8ubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBvZmZzZXRzW2ldID0gX1tpXSB8fCAwO1xuXG4gIGZvciAobGV0IGkgPSBuOyBpIDwgY291bnQ7ICsraSkgb2Zmc2V0c1tpXSA9IG9mZnNldHNbbiAtIDFdO1xuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRBbmNob3JzKF8sIGNvdW50KSB7XG4gIGNvbnN0IGFuY2hvcnMgPSBuZXcgSW50OEFycmF5KGNvdW50KSxcbiAgICAgICAgbiA9IF8ubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBhbmNob3JzW2ldIHw9IGFuY2hvckNvZGVbX1tpXV07XG5cbiAgZm9yIChsZXQgaSA9IG47IGkgPCBjb3VudDsgKytpKSBhbmNob3JzW2ldID0gYW5jaG9yc1tuIC0gMV07XG5cbiAgcmV0dXJuIGFuY2hvcnM7XG59XG5cbmZ1bmN0aW9uIG1hcmtUeXBlKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5tYXJrICYmIGl0ZW0ubWFyay5tYXJrdHlwZTtcbn1cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgZnVuY3Rpb24gZm9yIGdldHRpbmcgYmFzZSBtYXJrIGJvdW5kYXJ5LCBkZXBlbmRpbmdcbiAqIG9uIG1hcmsgYW5kIGdyb3VwIHR5cGUuIFdoZW4gbWFyayB0eXBlIGlzIHVuZGVmaW5lZCwgbGluZSBvciBhcmVhOiBib3VuZGFyeVxuICogaXMgdGhlIGNvb3JkaW5hdGUgb2YgZWFjaCBkYXRhIHBvaW50LiBXaGVuIGJhc2UgbWFyayBpcyBncm91cGVkIGxpbmUsXG4gKiBib3VuZGFyeSBpcyBlaXRoZXIgYXQgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIGxpbmUgZGVwZW5kaW5nIG9uIHRoZVxuICogdmFsdWUgb2YgbGluZUFuY2hvci4gT3RoZXJ3aXNlLCB1c2UgYm91bmRzIG9mIGJhc2UgbWFyay5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hcmtCb3VuZGFyeShtYXJrdHlwZSwgZ3JvdXB0eXBlLCBsaW5lQW5jaG9yLCBtYXJrSW5kZXgpIHtcbiAgY29uc3QgeHkgPSBkID0+IFtkLngsIGQueCwgZC54LCBkLnksIGQueSwgZC55XTtcblxuICBpZiAoIW1hcmt0eXBlKSB7XG4gICAgcmV0dXJuIHh5OyAvLyBubyByZWFjdGl2ZSBnZW9tZXRyeVxuICB9IGVsc2UgaWYgKG1hcmt0eXBlID09PSAnbGluZScgfHwgbWFya3R5cGUgPT09ICdhcmVhJykge1xuICAgIHJldHVybiBkID0+IHh5KGQuZGF0dW0pO1xuICB9IGVsc2UgaWYgKGdyb3VwdHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgcmV0dXJuIGQgPT4ge1xuICAgICAgY29uc3QgaXRlbXMgPSBkLmRhdHVtLml0ZW1zW21hcmtJbmRleF0uaXRlbXM7XG4gICAgICByZXR1cm4geHkoaXRlbXMubGVuZ3RoID8gaXRlbXNbbGluZUFuY2hvciA9PT0gJ3N0YXJ0JyA/IDAgOiBpdGVtcy5sZW5ndGggLSAxXSA6IHtcbiAgICAgICAgeDogTmFOLFxuICAgICAgICB5OiBOYU5cbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGQgPT4ge1xuICAgICAgY29uc3QgYiA9IGQuZGF0dW0uYm91bmRzO1xuICAgICAgcmV0dXJuIFtiLngxLCAoYi54MSArIGIueDIpIC8gMiwgYi54MiwgYi55MSwgKGIueTEgKyBiLnkyKSAvIDIsIGIueTJdO1xuICAgIH07XG4gIH1cbn1cblxuY29uc3QgT3V0cHV0ID0gWyd4JywgJ3knLCAnb3BhY2l0eScsICdhbGlnbicsICdiYXNlbGluZSddO1xuY29uc3QgQW5jaG9ycyA9IFsndG9wLWxlZnQnLCAnbGVmdCcsICdib3R0b20tbGVmdCcsICd0b3AnLCAnYm90dG9tJywgJ3RvcC1yaWdodCcsICdyaWdodCcsICdib3R0b20tcmlnaHQnXTtcbi8qKlxuICogQ29tcHV0ZSB0ZXh0IGxhYmVsIGxheW91dCB0byBhbm5vdGF0ZSBtYXJrcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYXJhbXMuc2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBsYXlvdXQsIHByb3ZpZGVkIGFzIGEgW3dpZHRoLCBoZWlnaHRdIGFycmF5LlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCopOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBbiBvcHRpb25hbFxuICogICBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGxhYmVsIGRhdGEgaW4gcHJpb3JpdHkgb3JkZXIuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYW5jaG9yXSAtIExhYmVsIGFuY2hvciBwb2ludHMgcmVsYXRpdmUgdG8gdGhlIGJhc2UgbWFyayBib3VuZGluZyBib3guXG4gKiAgIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmUgJ3RvcC1sZWZ0JywgJ2xlZnQnLCAnYm90dG9tLWxlZnQnLCAndG9wJyxcbiAqICAgJ2JvdHRvbScsICd0b3AtcmlnaHQnLCAncmlnaHQnLCAnYm90dG9tLXJpZ2h0JywgJ21pZGRsZScuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMub2Zmc2V0XSAtIExhYmVsIG9mZnNldHMgKGluIHBpeGVscykgZnJvbSB0aGUgYmFzZSBtYXJrIGJvdW5kaW5nIGJveC5cbiAqICAgVGhpcyBwYXJhbWV0ZXIgaXMgcGFyYWxsZWwgdG8gdGhlIGxpc3Qgb2YgYW5jaG9yIHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW3BhcmFtcy5wYWRkaW5nPTBdIC0gVGhlIGFtb3VudCAoaW4gcGl4ZWxzKSB0aGF0IGEgbGFiZWwgbWF5IGV4Y2VlZCB0aGUgbGF5b3V0IHNpemUuXG4gKiAgIElmIHRoaXMgcGFyYW1ldGVyIGlzIG51bGwsIGEgbGFiZWwgbWF5IGV4Y2VlZCB0aGUgbGF5b3V0IHNpemUgd2l0aG91dCBhbnkgYm91bmRhcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5saW5lQW5jaG9yPSdlbmQnXSAtIEZvciBncm91cCBsaW5lIG1hcmsgbGFiZWxzIG9ubHksIGluZGljYXRlcyB0aGUgYW5jaG9yXG4gKiAgIHBvc2l0aW9uIGZvciBsYWJlbHMuIE9uZSBvZiAnc3RhcnQnIG9yICdlbmQnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMubWFya0luZGV4PTBdIC0gRm9yIGdyb3VwIG1hcmsgbGFiZWxzIG9ubHksIGFuIGluZGV4IGluZGljYXRpbmdcbiAqICAgd2hpY2ggbWFyayB3aXRoaW4gdGhlIGdyb3VwIHNob3VsZCBiZSBsYWJlbGVkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLmF2b2lkTWFya3NdIC0gQSBsaXN0IG9mIGFkZGl0aW9uYWwgbWFyayBuYW1lcyBmb3Igd2hpY2ggdGhlIGxhYmVsXG4gKiAgIGxheW91dCBzaG91bGQgYXZvaWQgb3ZlcmxhcC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5hdm9pZEJhc2VNYXJrPXRydWVdIC0gQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgbGFiZWxzIHNob3VsZCBhdm9pZFxuICogICBvdmVybGFwIHdpdGggdGhlIHVuZGVybHlpbmcgYmFzZSBtYXJrIGJlaW5nIGxhYmVsZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5tZXRob2Q9J25haXZlJ10gLSBGb3IgYXJlYSBtYWtlIGxhYmVscyBvbmx5LCBhIG1ldGhvZCBmb3JcbiAqICAgcGxhY2UgbGFiZWxzLiBPbmUgb2YgJ25haXZlJywgJ3JlZHVjZWQtc2VhcmNoJywgb3IgJ2Zsb29kZmlsbCcuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gVGhlIG91dHB1dCBmaWVsZHMgd3JpdHRlbiBieSB0aGUgdHJhbnNmb3JtLlxuICogICBUaGUgZGVmYXVsdCBpcyBbJ3gnLCAneScsICdvcGFjaXR5JywgJ2FsaWduJywgJ2Jhc2VsaW5lJ10uXG4gKi9cblxuZnVuY3Rpb24gTGFiZWwocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5MYWJlbC5EZWZpbml0aW9uID0ge1xuICB0eXBlOiAnTGFiZWwnLFxuICBtZXRhZGF0YToge1xuICAgIG1vZGlmaWVzOiB0cnVlXG4gIH0sXG4gIHBhcmFtczogW3tcbiAgICBuYW1lOiAnc2l6ZScsXG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgYXJyYXk6IHRydWUsXG4gICAgbGVuZ3RoOiAyLFxuICAgIHJlcXVpcmVkOiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAnc29ydCcsXG4gICAgdHlwZTogJ2NvbXBhcmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnYW5jaG9yJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBhcnJheTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBBbmNob3JzXG4gIH0sIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBhcnJheTogdHJ1ZSxcbiAgICBkZWZhdWx0OiBbMV1cbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nJyxcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiAwLFxuICAgIG51bGw6IHRydWVcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lQW5jaG9yJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWx1ZXM6IFsnc3RhcnQnLCAnZW5kJ10sXG4gICAgZGVmYXVsdDogJ2VuZCdcbiAgfSwge1xuICAgIG5hbWU6ICdtYXJrSW5kZXgnLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIG5hbWU6ICdhdm9pZEJhc2VNYXJrJyxcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogdHJ1ZVxuICB9LCB7XG4gICAgbmFtZTogJ2F2b2lkTWFya3MnLFxuICAgIHR5cGU6ICdkYXRhJyxcbiAgICBhcnJheTogdHJ1ZVxuICB9LCB7XG4gICAgbmFtZTogJ21ldGhvZCcsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgZGVmYXVsdDogJ25haXZlJ1xuICB9LCB7XG4gICAgbmFtZTogJ2FzJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBhcnJheTogdHJ1ZSxcbiAgICBsZW5ndGg6IE91dHB1dC5sZW5ndGgsXG4gICAgZGVmYXVsdDogT3V0cHV0XG4gIH1dXG59O1xuaW5oZXJpdHMoTGFiZWwsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBmdW5jdGlvbiBtb2RwKHBhcmFtKSB7XG4gICAgICBjb25zdCBwID0gX1twYXJhbV07XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihwKSAmJiBwdWxzZS5tb2RpZmllZChwLmZpZWxkcyk7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kID0gXy5tb2RpZmllZCgpO1xuXG4gICAgaWYgKCEobW9kIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSkgfHwgbW9kcCgnc29ydCcpKSkgcmV0dXJuO1xuXG4gICAgaWYgKCFfLnNpemUgfHwgXy5zaXplLmxlbmd0aCAhPT0gMikge1xuICAgICAgZXJyb3IoJ1NpemUgcGFyYW1ldGVyIHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgYSBbd2lkdGgsIGhlaWdodF0gYXJyYXkuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXMgPSBfLmFzIHx8IE91dHB1dDsgLy8gcnVuIGxhYmVsIGxheW91dFxuXG4gICAgbGFiZWxMYXlvdXQocHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UgfHwgW10sIF8uc2l6ZSwgXy5zb3J0LCBhcnJheShfLm9mZnNldCA9PSBudWxsID8gMSA6IF8ub2Zmc2V0KSwgYXJyYXkoXy5hbmNob3IgfHwgQW5jaG9ycyksIF8uYXZvaWRNYXJrcyB8fCBbXSwgXy5hdm9pZEJhc2VNYXJrICE9PSBmYWxzZSwgXy5saW5lQW5jaG9yIHx8ICdlbmQnLCBfLm1hcmtJbmRleCB8fCAwLCBfLnBhZGRpbmcgPT09IHVuZGVmaW5lZCA/IDAgOiBfLnBhZGRpbmcsIF8ubWV0aG9kIHx8ICduYWl2ZScpLmZvckVhY2gobCA9PiB7XG4gICAgICAvLyB3cml0ZSBsYXlvdXQgcmVzdWx0cyB0byBkYXRhIHN0cmVhbVxuICAgICAgY29uc3QgdCA9IGwuZGF0dW07XG4gICAgICB0W2FzWzBdXSA9IGwueDtcbiAgICAgIHRbYXNbMV1dID0gbC55O1xuICAgICAgdFthc1syXV0gPSBsLm9wYWNpdHk7XG4gICAgICB0W2FzWzNdXSA9IGwuYWxpZ247XG4gICAgICB0W2FzWzRdXSA9IGwuYmFzZWxpbmU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhtb2QpLm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuZXhwb3J0IHsgTGFiZWwgYXMgbGFiZWwgfTtcbiIsImltcG9ydCB7IGV4dGVuZCwgZXJyb3IsIGlzRnVuY3Rpb24sIHN0cmluZ1ZhbHVlLCB0b0Jvb2xlYW4sIHRvTnVtYmVyLCB0b0RhdGUsIHRvU3RyaW5nLCBpZGVudGl0eSwgZmllbGQsIGlzT2JqZWN0LCBpc0FycmF5LCBpc0l0ZXJhYmxlLCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBkc3ZGb3JtYXQgfSBmcm9tICdkMy1kc3YnO1xuaW1wb3J0IHsgZmVhdHVyZSwgbWVzaCB9IGZyb20gJ3RvcG9qc29uLWNsaWVudCc7XG5pbXBvcnQgeyB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSB9IGZyb20gJ3ZlZ2EtZm9ybWF0JztcblxuLy8gICBodHRwczovLy4uLiAgICBmaWxlOi8vLi4uICAgIC8vLi4uXG5cbmNvbnN0IHByb3RvY29sX3JlID0gL14oZGF0YTp8KFtBLVphLXpdKzopP1xcL1xcLykvOyAvLyBNYXRjaGVzIGFsbG93ZWQgVVJJcy4gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3VyZTUzL0RPTVB1cmlmeS9ibG9iL21hc3Rlci9zcmMvcmVnZXhwLmpzIHdpdGggYWRkZWQgZmlsZTovL1xuXG5jb25zdCBhbGxvd2VkX3JlID0gL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98Y2lkfHhtcHB8ZmlsZXxkYXRhKTp8W15hLXpdfFthLXorLlxcLV0rKD86W15hLXorLlxcLTpdfCQpKS9pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbmNvbnN0IHdoaXRlc3BhY2VfcmUgPSAvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNWZcXHUzMDAwXS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbi8vIFNwZWNpYWwgdHJlYXRtZW50IGluIG5vZGUuanMgZm9yIHRoZSBmaWxlOiBwcm90b2NvbFxuXG5jb25zdCBmaWxlUHJvdG9jb2wgPSAnZmlsZTovLyc7XG4vKipcbiAqIEZhY3RvcnkgZm9yIGEgbG9hZGVyIGNvbnN0cnVjdG9yIHRoYXQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgcmVxdWVzdGluZ1xuICogZmlsZXMgZnJvbSBlaXRoZXIgdGhlIG5ldHdvcmsgb3IgZGlzaywgYW5kIGZvciBzYW5pdGl6aW5nIHJlcXVlc3QgVVJJcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZldGNoIC0gVGhlIEZldGNoIEFQSSBmb3IgSFRUUCBuZXR3b3JrIHJlcXVlc3RzLlxuICogICBJZiBudWxsIG9yIHVuZGVmaW5lZCwgSFRUUCBsb2FkaW5nIHdpbGwgYmUgZGlzYWJsZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gZnMgLSBUaGUgZmlsZSBzeXN0ZW0gaW50ZXJmYWNlIGZvciBmaWxlIGxvYWRpbmcuXG4gKiAgIElmIG51bGwgb3IgdW5kZWZpbmVkLCBsb2NhbCBmaWxlIGxvYWRpbmcgd2lsbCBiZSBkaXNhYmxlZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBBIGxvYWRlciBjb25zdHJ1Y3RvciB3aXRoIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICogICBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBkZWZhdWx0IGxvYWRpbmcgb3B0aW9ucyB0byB1c2UuXG4gKiAgIHJldHVybiB7b2JqZWN0fSAtIEEgbmV3IGxvYWRlciBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBsb2FkZXJGYWN0b3J5IChmZXRjaCwgZnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPT4gKHtcbiAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9LFxuICAgIHNhbml0aXplOiBzYW5pdGl6ZSxcbiAgICBsb2FkOiBsb2FkLFxuICAgIGZpbGVBY2Nlc3M6ICEhZnMsXG4gICAgZmlsZTogZmlsZUxvYWRlcihmcyksXG4gICAgaHR0cDogaHR0cExvYWRlcihmZXRjaClcbiAgfSk7XG59XG4vKipcbiAqIExvYWQgYW4gZXh0ZXJuYWwgcmVzb3VyY2UsIHR5cGljYWxseSBlaXRoZXIgZnJvbSB0aGUgd2ViIG9yIGZyb20gdGhlIGxvY2FsXG4gKiBmaWxlc3lzdGVtLiBUaGlzIGZ1bmN0aW9uIHVzZXMge0BsaW5rIHNhbml0aXplfSB0byBmaXJzdCBzYW5pdGl6ZSB0aGUgdXJpLFxuICogdGhlbiBjYWxscyBlaXRoZXIge0BsaW5rIGh0dHB9IChmb3Igd2ViIHJlcXVlc3RzKSBvciB7QGxpbmsgZmlsZX0gKGZvclxuICogZmlsZXN5c3RlbSBsb2FkaW5nKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgcmVzb3VyY2UgaW5kaWNhdG9yIChlLmcuLCBVUkwgb3IgZmlsZW5hbWUpLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGxvYWRpbmcgb3B0aW9ucy4gVGhlc2Ugb3B0aW9ucyB3aWxsXG4gKiAgIG92ZXJyaWRlIGFueSBleGlzdGluZyBkZWZhdWx0IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsb2FkZWQgY29udGVudC5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBsb2FkKHVyaSwgb3B0aW9ucykge1xuICBjb25zdCBvcHQgPSBhd2FpdCB0aGlzLnNhbml0aXplKHVyaSwgb3B0aW9ucyksXG4gICAgICAgIHVybCA9IG9wdC5ocmVmO1xuICByZXR1cm4gb3B0LmxvY2FsRmlsZSA/IHRoaXMuZmlsZSh1cmwpIDogdGhpcy5odHRwKHVybCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIFVSSSBzYW5pdGl6ZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpIC0gVGhlIHVyaSAodXJsIG9yIGZpbGVuYW1lKSB0byBjaGVjay5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQW4gb3B0aW9ucyBoYXNoLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3QgY29udGFpbmluZ1xuICogIHNhbml0aXplZCB1cmkgZGF0YSwgb3IgcmVqZWN0cyBpdCB0aGUgaW5wdXQgdXJpIGlzIGRlZW1lZCBpbnZhbGlkLlxuICogIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSByZXNvbHZlZCBvYmplY3QgYXJlIGFzc3VtZWQgdG8gYmVcbiAqICB2YWxpZCBhdHRyaWJ1dGVzIGZvciBhbiBIVE1MICdhJyB0YWcuIFRoZSBzYW5pdGl6ZWQgdXJpICptdXN0KiBiZVxuICogIHByb3ZpZGVkIGJ5IHRoZSAnaHJlZicgcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIG9iamVjdC5cbiAqL1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHNhbml0aXplKHVyaSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICBjb25zdCBmaWxlQWNjZXNzID0gdGhpcy5maWxlQWNjZXNzLFxuICAgICAgICByZXN1bHQgPSB7XG4gICAgaHJlZjogbnVsbFxuICB9O1xuICBsZXQgaXNGaWxlLCBsb2FkRmlsZSwgYmFzZTtcbiAgY29uc3QgaXNBbGxvd2VkID0gYWxsb3dlZF9yZS50ZXN0KHVyaS5yZXBsYWNlKHdoaXRlc3BhY2VfcmUsICcnKSk7XG5cbiAgaWYgKHVyaSA9PSBudWxsIHx8IHR5cGVvZiB1cmkgIT09ICdzdHJpbmcnIHx8ICFpc0FsbG93ZWQpIHtcbiAgICBlcnJvcignU2FuaXRpemUgZmFpbHVyZSwgaW52YWxpZCBVUkk6ICcgKyBzdHJpbmdWYWx1ZSh1cmkpKTtcbiAgfVxuXG4gIGNvbnN0IGhhc1Byb3RvY29sID0gcHJvdG9jb2xfcmUudGVzdCh1cmkpOyAvLyBpZiByZWxhdGl2ZSB1cmwgKG5vIHByb3RvY29sL2hvc3QpLCBwcmVwZW5kIGJhc2VVUkxcblxuICBpZiAoKGJhc2UgPSBvcHRpb25zLmJhc2VVUkwpICYmICFoYXNQcm90b2NvbCkge1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGEgc2xhc2ggYmV0d2VlbiB0aGUgYmFzZVVSTCAoZS5nLiBob3N0bmFtZSkgYW5kIHVybFxuICAgIGlmICghdXJpLnN0YXJ0c1dpdGgoJy8nKSAmJiAhYmFzZS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICB1cmkgPSAnLycgKyB1cmk7XG4gICAgfVxuXG4gICAgdXJpID0gYmFzZSArIHVyaTtcbiAgfSAvLyBzaG91bGQgd2UgbG9hZCBmcm9tIGZpbGUgc3lzdGVtP1xuXG5cbiAgbG9hZEZpbGUgPSAoaXNGaWxlID0gdXJpLnN0YXJ0c1dpdGgoZmlsZVByb3RvY29sKSkgfHwgb3B0aW9ucy5tb2RlID09PSAnZmlsZScgfHwgb3B0aW9ucy5tb2RlICE9PSAnaHR0cCcgJiYgIWhhc1Byb3RvY29sICYmIGZpbGVBY2Nlc3M7XG5cbiAgaWYgKGlzRmlsZSkge1xuICAgIC8vIHN0cmlwIGZpbGUgcHJvdG9jb2xcbiAgICB1cmkgPSB1cmkuc2xpY2UoZmlsZVByb3RvY29sLmxlbmd0aCk7XG4gIH0gZWxzZSBpZiAodXJpLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgPT09ICdmaWxlJykge1xuICAgICAgLy8gaWYgaXMgZmlsZSwgc3RyaXAgcHJvdG9jb2wgYW5kIHNldCBsb2FkRmlsZSBmbGFnXG4gICAgICB1cmkgPSB1cmkuc2xpY2UoMik7XG4gICAgICBsb2FkRmlsZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHJlbGF0aXZlIHByb3RvY29sIChzdGFydHMgd2l0aCAnLy8nKSwgcHJlcGVuZCBkZWZhdWx0IHByb3RvY29sXG4gICAgICB1cmkgPSAob3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgfHwgJ2h0dHAnKSArICc6JyArIHVyaTtcbiAgICB9XG4gIH0gLy8gc2V0IG5vbi1lbnVtZXJhYmxlIG1vZGUgZmxhZyB0byBpbmRpY2F0ZSBsb2NhbCBmaWxlIGxvYWRcblxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsICdsb2NhbEZpbGUnLCB7XG4gICAgdmFsdWU6ICEhbG9hZEZpbGVcbiAgfSk7IC8vIHNldCB1cmlcblxuICByZXN1bHQuaHJlZiA9IHVyaTsgLy8gc2V0IGRlZmF1bHQgcmVzdWx0IHRhcmdldCwgaWYgc3BlY2lmaWVkXG5cbiAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgcmVzdWx0LnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0ICsgJyc7XG4gIH0gLy8gc2V0IGRlZmF1bHQgcmVzdWx0IHJlbCwgaWYgc3BlY2lmaWVkICgjMTU0MilcblxuXG4gIGlmIChvcHRpb25zLnJlbCkge1xuICAgIHJlc3VsdC5yZWwgPSBvcHRpb25zLnJlbCArICcnO1xuICB9IC8vIHByb3ZpZGUgY29udHJvbCBvdmVyIGNyb3NzLW9yaWdpbiBpbWFnZSBoYW5kbGluZyAoIzIyMzgpXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlXG5cblxuICBpZiAob3B0aW9ucy5jb250ZXh0ID09PSAnaW1hZ2UnICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcbiAgICByZXN1bHQuY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luICsgJyc7XG4gIH0gLy8gcmV0dXJuXG5cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBGaWxlIHN5c3RlbSBsb2FkZXIgZmFjdG9yeS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBmcyAtIFRoZSBmaWxlIHN5c3RlbSBpbnRlcmZhY2UuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gLSBBIGZpbGUgbG9hZGVyIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKiAgIHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gVGhlIGZpbGUgc3lzdGVtIHBhdGggdG8gbG9hZC5cbiAqICAgcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBUaGUgZmlsZSBzeXN0ZW0gcGF0aCB0byBsb2FkLlxuICogICByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaWxlIGNvbnRlbnRzLlxuICovXG5cblxuZnVuY3Rpb24gZmlsZUxvYWRlcihmcykge1xuICByZXR1cm4gZnMgPyBmaWxlbmFtZSA9PiBuZXcgUHJvbWlzZSgoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkRmlsZShmaWxlbmFtZSwgKGVycm9yLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHJlamVjdChlcnJvcik7ZWxzZSBhY2NlcHQoZGF0YSk7XG4gICAgfSk7XG4gIH0pIDogZmlsZVJlamVjdDtcbn1cbi8qKlxuICogRGVmYXVsdCBmaWxlIHN5c3RlbSBsb2FkZXIgdGhhdCBzaW1wbHkgcmVqZWN0cy5cbiAqL1xuXG5cbmFzeW5jIGZ1bmN0aW9uIGZpbGVSZWplY3QoKSB7XG4gIGVycm9yKCdObyBmaWxlIHN5c3RlbSBhY2Nlc3MuJyk7XG59XG4vKipcbiAqIEhUVFAgcmVxdWVzdCBoYW5kbGVyIGZhY3RvcnkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmZXRjaCAtIFRoZSBGZXRjaCBBUEkgbWV0aG9kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IC0gQW4gaHR0cCBsb2FkZXIgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqICAgcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHVybCB0byByZXF1ZXN0LlxuICogICBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQW4gb3B0aW9ucyBoYXNoLlxuICogICByZXR1cm4ge1Byb21pc2V9IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZpbGUgY29udGVudHMuXG4gKi9cblxuXG5mdW5jdGlvbiBodHRwTG9hZGVyKGZldGNoKSB7XG4gIHJldHVybiBmZXRjaCA/IGFzeW5jIGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHQgPSBleHRlbmQoe30sIHRoaXMub3B0aW9ucy5odHRwLCBvcHRpb25zKSxcbiAgICAgICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc3BvbnNlLFxuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBvcHQpO1xuICAgIHJldHVybiAhcmVzcG9uc2Uub2sgPyBlcnJvcihyZXNwb25zZS5zdGF0dXMgKyAnJyArIHJlc3BvbnNlLnN0YXR1c1RleHQpIDogaXNGdW5jdGlvbihyZXNwb25zZVt0eXBlXSkgPyByZXNwb25zZVt0eXBlXSgpIDogcmVzcG9uc2UudGV4dCgpO1xuICB9IDogaHR0cFJlamVjdDtcbn1cbi8qKlxuICogRGVmYXVsdCBodHRwIHJlcXVlc3QgaGFuZGxlciB0aGF0IHNpbXBseSByZWplY3RzLlxuICovXG5cblxuYXN5bmMgZnVuY3Rpb24gaHR0cFJlamVjdCgpIHtcbiAgZXJyb3IoJ05vIEhUVFAgZmV0Y2ggbWV0aG9kIGF2YWlsYWJsZS4nKTtcbn1cblxuY29uc3QgaXNWYWxpZCA9IF8gPT4gXyAhPSBudWxsICYmIF8gPT09IF87XG5cbmNvbnN0IGlzQm9vbGVhbiA9IF8gPT4gXyA9PT0gJ3RydWUnIHx8IF8gPT09ICdmYWxzZScgfHwgXyA9PT0gdHJ1ZSB8fCBfID09PSBmYWxzZTtcblxuY29uc3QgaXNEYXRlID0gXyA9PiAhTnVtYmVyLmlzTmFOKERhdGUucGFyc2UoXykpO1xuXG5jb25zdCBpc051bWJlciA9IF8gPT4gIU51bWJlci5pc05hTigrXykgJiYgIShfIGluc3RhbmNlb2YgRGF0ZSk7XG5cbmNvbnN0IGlzSW50ZWdlciA9IF8gPT4gaXNOdW1iZXIoXykgJiYgTnVtYmVyLmlzSW50ZWdlcigrXyk7XG5cbmNvbnN0IHR5cGVQYXJzZXJzID0ge1xuICBib29sZWFuOiB0b0Jvb2xlYW4sXG4gIGludGVnZXI6IHRvTnVtYmVyLFxuICBudW1iZXI6IHRvTnVtYmVyLFxuICBkYXRlOiB0b0RhdGUsXG4gIHN0cmluZzogdG9TdHJpbmcsXG4gIHVua25vd246IGlkZW50aXR5XG59O1xuY29uc3QgdHlwZVRlc3RzID0gW2lzQm9vbGVhbiwgaXNJbnRlZ2VyLCBpc051bWJlciwgaXNEYXRlXTtcbmNvbnN0IHR5cGVMaXN0ID0gWydib29sZWFuJywgJ2ludGVnZXInLCAnbnVtYmVyJywgJ2RhdGUnXTtcbmZ1bmN0aW9uIGluZmVyVHlwZSh2YWx1ZXMsIGZpZWxkKSB7XG4gIGlmICghdmFsdWVzIHx8ICF2YWx1ZXMubGVuZ3RoKSByZXR1cm4gJ3Vua25vd24nO1xuICBjb25zdCBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgbSA9IHR5cGVUZXN0cy5sZW5ndGgsXG4gICAgICAgIGEgPSB0eXBlVGVzdHMubWFwKChfLCBpKSA9PiBpICsgMSk7XG5cbiAgZm9yIChsZXQgaSA9IDAsIHQgPSAwLCBqLCB2YWx1ZTsgaSA8IG47ICsraSkge1xuICAgIHZhbHVlID0gZmllbGQgPyB2YWx1ZXNbaV1bZmllbGRdIDogdmFsdWVzW2ldO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKGFbal0gJiYgaXNWYWxpZCh2YWx1ZSkgJiYgIXR5cGVUZXN0c1tqXSh2YWx1ZSkpIHtcbiAgICAgICAgYVtqXSA9IDA7XG4gICAgICAgICsrdDtcbiAgICAgICAgaWYgKHQgPT09IHR5cGVUZXN0cy5sZW5ndGgpIHJldHVybiAnc3RyaW5nJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHlwZUxpc3RbYS5yZWR1Y2UoKHUsIHYpID0+IHUgPT09IDAgPyB2IDogdSwgMCkgLSAxXTtcbn1cbmZ1bmN0aW9uIGluZmVyVHlwZXMoZGF0YSwgZmllbGRzKSB7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKCh0eXBlcywgZmllbGQpID0+IHtcbiAgICB0eXBlc1tmaWVsZF0gPSBpbmZlclR5cGUoZGF0YSwgZmllbGQpO1xuICAgIHJldHVybiB0eXBlcztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBkZWxpbWl0ZWRGb3JtYXQoZGVsaW1pdGVyKSB7XG4gIGNvbnN0IHBhcnNlID0gZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgIGNvbnN0IGRlbGltID0ge1xuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXJcbiAgICB9O1xuICAgIHJldHVybiBkc3YoZGF0YSwgZm9ybWF0ID8gZXh0ZW5kKGZvcm1hdCwgZGVsaW0pIDogZGVsaW0pO1xuICB9O1xuXG4gIHBhcnNlLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgcmV0dXJuIHBhcnNlO1xufVxuZnVuY3Rpb24gZHN2KGRhdGEsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0LmhlYWRlcikge1xuICAgIGRhdGEgPSBmb3JtYXQuaGVhZGVyLm1hcChzdHJpbmdWYWx1ZSkuam9pbihmb3JtYXQuZGVsaW1pdGVyKSArICdcXG4nICsgZGF0YTtcbiAgfVxuXG4gIHJldHVybiBkc3ZGb3JtYXQoZm9ybWF0LmRlbGltaXRlcikucGFyc2UoZGF0YSArICcnKTtcbn1cbmRzdi5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKF8pIHtcbiAgcmV0dXJuIHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgaXNGdW5jdGlvbihCdWZmZXIuaXNCdWZmZXIpID8gQnVmZmVyLmlzQnVmZmVyKF8pIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGpzb24oZGF0YSwgZm9ybWF0KSB7XG4gIGNvbnN0IHByb3AgPSBmb3JtYXQgJiYgZm9ybWF0LnByb3BlcnR5ID8gZmllbGQoZm9ybWF0LnByb3BlcnR5KSA6IGlkZW50aXR5O1xuICByZXR1cm4gaXNPYmplY3QoZGF0YSkgJiYgIWlzQnVmZmVyKGRhdGEpID8gcGFyc2VKU09OKHByb3AoZGF0YSksIGZvcm1hdCkgOiBwcm9wKEpTT04ucGFyc2UoZGF0YSkpO1xufVxuanNvbi5yZXNwb25zZVR5cGUgPSAnanNvbic7XG5cbmZ1bmN0aW9uIHBhcnNlSlNPTihkYXRhLCBmb3JtYXQpIHtcbiAgaWYgKCFpc0FycmF5KGRhdGEpICYmIGlzSXRlcmFibGUoZGF0YSkpIHtcbiAgICBkYXRhID0gWy4uLmRhdGFdO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdCAmJiBmb3JtYXQuY29weSA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpIDogZGF0YTtcbn1cblxuY29uc3QgZmlsdGVycyA9IHtcbiAgaW50ZXJpb3I6IChhLCBiKSA9PiBhICE9PSBiLFxuICBleHRlcmlvcjogKGEsIGIpID0+IGEgPT09IGJcbn07XG5mdW5jdGlvbiB0b3BvanNvbihkYXRhLCBmb3JtYXQpIHtcbiAgbGV0IG1ldGhvZCwgb2JqZWN0LCBwcm9wZXJ0eSwgZmlsdGVyO1xuICBkYXRhID0ganNvbihkYXRhLCBmb3JtYXQpO1xuXG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LmZlYXR1cmUpIHtcbiAgICBtZXRob2QgPSBmZWF0dXJlO1xuICAgIHByb3BlcnR5ID0gZm9ybWF0LmZlYXR1cmU7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ICYmIGZvcm1hdC5tZXNoKSB7XG4gICAgbWV0aG9kID0gbWVzaDtcbiAgICBwcm9wZXJ0eSA9IGZvcm1hdC5tZXNoO1xuICAgIGZpbHRlciA9IGZpbHRlcnNbZm9ybWF0LmZpbHRlcl07XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ01pc3NpbmcgVG9wb0pTT04gZmVhdHVyZSBvciBtZXNoIHBhcmFtZXRlci4nKTtcbiAgfVxuXG4gIG9iamVjdCA9IChvYmplY3QgPSBkYXRhLm9iamVjdHNbcHJvcGVydHldKSA/IG1ldGhvZChkYXRhLCBvYmplY3QsIGZpbHRlcikgOiBlcnJvcignSW52YWxpZCBUb3BvSlNPTiBvYmplY3Q6ICcgKyBwcm9wZXJ0eSk7XG4gIHJldHVybiBvYmplY3QgJiYgb2JqZWN0LmZlYXR1cmVzIHx8IFtvYmplY3RdO1xufVxudG9wb2pzb24ucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuXG5jb25zdCBmb3JtYXQgPSB7XG4gIGRzdjogZHN2LFxuICBjc3Y6IGRlbGltaXRlZEZvcm1hdCgnLCcpLFxuICB0c3Y6IGRlbGltaXRlZEZvcm1hdCgnXFx0JyksXG4gIGpzb246IGpzb24sXG4gIHRvcG9qc29uOiB0b3BvanNvblxufTtcbmZ1bmN0aW9uIGZvcm1hdHMobmFtZSwgcmVhZGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGZvcm1hdFtuYW1lXSA9IHJlYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkoZm9ybWF0LCBuYW1lKSA/IGZvcm1hdFtuYW1lXSA6IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3BvbnNlVHlwZSh0eXBlKSB7XG4gIGNvbnN0IGYgPSBmb3JtYXRzKHR5cGUpO1xuICByZXR1cm4gZiAmJiBmLnJlc3BvbnNlVHlwZSB8fCAndGV4dCc7XG59XG5cbmZ1bmN0aW9uIHJlYWQgKGRhdGEsIHNjaGVtYSwgdGltZVBhcnNlciwgdXRjUGFyc2VyKSB7XG4gIHNjaGVtYSA9IHNjaGVtYSB8fCB7fTtcbiAgY29uc3QgcmVhZGVyID0gZm9ybWF0cyhzY2hlbWEudHlwZSB8fCAnanNvbicpO1xuICBpZiAoIXJlYWRlcikgZXJyb3IoJ1Vua25vd24gZGF0YSBmb3JtYXQgdHlwZTogJyArIHNjaGVtYS50eXBlKTtcbiAgZGF0YSA9IHJlYWRlcihkYXRhLCBzY2hlbWEpO1xuICBpZiAoc2NoZW1hLnBhcnNlKSBwYXJzZShkYXRhLCBzY2hlbWEucGFyc2UsIHRpbWVQYXJzZXIsIHV0Y1BhcnNlcik7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eShkYXRhLCAnY29sdW1ucycpKSBkZWxldGUgZGF0YS5jb2x1bW5zO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoZGF0YSwgdHlwZXMsIHRpbWVQYXJzZXIsIHV0Y1BhcnNlcikge1xuICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm47IC8vIGVhcmx5IGV4aXQgZm9yIGVtcHR5IGRhdGFcblxuICBjb25zdCBsb2NhbGUgPSB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuICB0aW1lUGFyc2VyID0gdGltZVBhcnNlciB8fCBsb2NhbGUudGltZVBhcnNlO1xuICB1dGNQYXJzZXIgPSB1dGNQYXJzZXIgfHwgbG9jYWxlLnV0Y1BhcnNlO1xuICBsZXQgZmllbGRzID0gZGF0YS5jb2x1bW5zIHx8IE9iamVjdC5rZXlzKGRhdGFbMF0pLFxuICAgICAgZGF0dW0sXG4gICAgICBmaWVsZCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgbixcbiAgICAgIG07XG4gIGlmICh0eXBlcyA9PT0gJ2F1dG8nKSB0eXBlcyA9IGluZmVyVHlwZXMoZGF0YSwgZmllbGRzKTtcbiAgZmllbGRzID0gT2JqZWN0LmtleXModHlwZXMpO1xuICBjb25zdCBwYXJzZXJzID0gZmllbGRzLm1hcChmaWVsZCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVzW2ZpZWxkXTtcbiAgICBsZXQgcGFydHMsIHBhdHRlcm47XG5cbiAgICBpZiAodHlwZSAmJiAodHlwZS5zdGFydHNXaXRoKCdkYXRlOicpIHx8IHR5cGUuc3RhcnRzV2l0aCgndXRjOicpKSkge1xuICAgICAgcGFydHMgPSB0eXBlLnNwbGl0KC86KC4rKT8vLCAyKTsgLy8gc3BsaXQgb24gZmlyc3QgOlxuXG4gICAgICBwYXR0ZXJuID0gcGFydHNbMV07XG5cbiAgICAgIGlmIChwYXR0ZXJuWzBdID09PSAnXFwnJyAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoIC0gMV0gPT09ICdcXCcnIHx8IHBhdHRlcm5bMF0gPT09ICdcIicgJiYgcGF0dGVybltwYXR0ZXJuLmxlbmd0aCAtIDFdID09PSAnXCInKSB7XG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2UgPSBwYXJ0c1swXSA9PT0gJ3V0YycgPyB1dGNQYXJzZXIgOiB0aW1lUGFyc2VyO1xuICAgICAgcmV0dXJuIHBhcnNlKHBhdHRlcm4pO1xuICAgIH1cblxuICAgIGlmICghdHlwZVBhcnNlcnNbdHlwZV0pIHtcbiAgICAgIHRocm93IEVycm9yKCdJbGxlZ2FsIGZvcm1hdCBwYXR0ZXJuOiAnICsgZmllbGQgKyAnOicgKyB0eXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZVBhcnNlcnNbdHlwZV07XG4gIH0pO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGZpZWxkcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBkYXR1bSA9IGRhdGFbaV07XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmaWVsZCA9IGZpZWxkc1tqXTtcbiAgICAgIGRhdHVtW2ZpZWxkXSA9IHBhcnNlcnNbal0oZGF0dW1bZmllbGRdKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbG9hZGVyID0gbG9hZGVyRmFjdG9yeSh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnICYmIGZldGNoLCAvLyB1c2UgYnVpbHQtaW4gZmV0Y2ggQVBJXG5udWxsIC8vIG5vIGZpbGUgc3lzdGVtIGFjY2Vzc1xuKTtcblxuZXhwb3J0IHsgZm9ybWF0LCBmb3JtYXRzLCBpbmZlclR5cGUsIGluZmVyVHlwZXMsIGxvYWRlciwgcmVhZCwgcmVzcG9uc2VUeXBlLCB0eXBlUGFyc2VycyB9O1xuIiwiaW1wb3J0IHsgaXNPYmplY3QsIGlzQXJyYXksIGV4dGVuZCwgaGFzT3duUHJvcGVydHksIGFycmF5LCBzdHJpbmdWYWx1ZSwgcGVlaywgaXNTdHJpbmcsIGVycm9yLCBzcGxpdEFjY2Vzc1BhdGgsIG1lcmdlQ29uZmlnIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHBhcnNlRXhwcmVzc2lvbiB9IGZyb20gJ3ZlZ2EtZnVuY3Rpb25zJztcbmltcG9ydCB7IHBhcnNlU2VsZWN0b3IgfSBmcm9tICd2ZWdhLWV2ZW50LXNlbGVjdG9yJztcbmltcG9ydCB7IGlzVmFsaWRTY2FsZVR5cGUsIGlzRGlzY3JldGUsIGlzUXVhbnRpbGUsIGlzRGlzY3JldGl6aW5nLCBpc0NvbnRpbnVvdXMgfSBmcm9tICd2ZWdhLXNjYWxlJztcbmltcG9ydCB7IGRlZmluaXRpb24gYXMgZGVmaW5pdGlvbiQxIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5cbmZ1bmN0aW9uIHBhcnNlQXV0b3NpemUgKHNwZWMpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHNwZWMpID8gc3BlYyA6IHtcbiAgICB0eXBlOiBzcGVjIHx8ICdwYWQnXG4gIH07XG59XG5cbmNvbnN0IG51bWJlciA9IF8gPT4gK18gfHwgMDtcblxuY29uc3QgcGFkZGluZ09iamVjdCA9IF8gPT4gKHtcbiAgdG9wOiBfLFxuICBib3R0b206IF8sXG4gIGxlZnQ6IF8sXG4gIHJpZ2h0OiBfXG59KTtcblxuZnVuY3Rpb24gcGFyc2VQYWRkaW5nIChzcGVjKSB7XG4gIHJldHVybiAhaXNPYmplY3Qoc3BlYykgPyBwYWRkaW5nT2JqZWN0KG51bWJlcihzcGVjKSkgOiBzcGVjLnNpZ25hbCA/IHNwZWMgOiB7XG4gICAgdG9wOiBudW1iZXIoc3BlYy50b3ApLFxuICAgIGJvdHRvbTogbnVtYmVyKHNwZWMuYm90dG9tKSxcbiAgICBsZWZ0OiBudW1iZXIoc3BlYy5sZWZ0KSxcbiAgICByaWdodDogbnVtYmVyKHNwZWMucmlnaHQpXG4gIH07XG59XG5cbmNvbnN0IGVuY29kZXIgPSBfID0+IGlzT2JqZWN0KF8pICYmICFpc0FycmF5KF8pID8gZXh0ZW5kKHt9LCBfKSA6IHtcbiAgdmFsdWU6IF9cbn07XG5mdW5jdGlvbiBhZGRFbmNvZGUob2JqZWN0LCBuYW1lLCB2YWx1ZSwgc2V0KSB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgY29uc3QgaXNFbmNvZGVyID0gaXNPYmplY3QodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggJiYgaXNPYmplY3QodmFsdWVbMF0pOyAvLyBBbHdheXMgYXNzaWduIHNpZ25hbCB0byB1cGRhdGUsIGV2ZW4gaWYgdGhlIHNpZ25hbCBpcyBmcm9tIHRoZSBlbnRlciBibG9ja1xuXG4gICAgaWYgKGlzRW5jb2Rlcikge1xuICAgICAgb2JqZWN0LnVwZGF0ZVtuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3Rbc2V0IHx8ICdlbnRlciddW25hbWVdID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEVuY29kZXJzKG9iamVjdCwgZW50ZXIsIHVwZGF0ZSkge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gZW50ZXIpIHtcbiAgICBhZGRFbmNvZGUob2JqZWN0LCBuYW1lLCBlbnRlcltuYW1lXSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IG5hbWUgaW4gdXBkYXRlKSB7XG4gICAgYWRkRW5jb2RlKG9iamVjdCwgbmFtZSwgdXBkYXRlW25hbWVdLCAndXBkYXRlJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4dGVuZEVuY29kZShlbmNvZGUsIGV4dHJhLCBza2lwKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBleHRyYSkge1xuICAgIGlmIChza2lwICYmIGhhc093blByb3BlcnR5KHNraXAsIG5hbWUpKSBjb250aW51ZTtcbiAgICBlbmNvZGVbbmFtZV0gPSBleHRlbmQoZW5jb2RlW25hbWVdIHx8IHt9LCBleHRyYVtuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gZW5jb2RlO1xufVxuZnVuY3Rpb24gaGFzKGtleSwgZW5jb2RlKSB7XG4gIHJldHVybiBlbmNvZGUgJiYgKGVuY29kZS5lbnRlciAmJiBlbmNvZGUuZW50ZXJba2V5XSB8fCBlbmNvZGUudXBkYXRlICYmIGVuY29kZS51cGRhdGVba2V5XSk7XG59XG5cbmNvbnN0IE1hcmtSb2xlID0gJ21hcmsnO1xuY29uc3QgRnJhbWVSb2xlID0gJ2ZyYW1lJztcbmNvbnN0IFNjb3BlUm9sZSA9ICdzY29wZSc7XG5jb25zdCBBeGlzUm9sZSA9ICdheGlzJztcbmNvbnN0IEF4aXNEb21haW5Sb2xlID0gJ2F4aXMtZG9tYWluJztcbmNvbnN0IEF4aXNHcmlkUm9sZSA9ICdheGlzLWdyaWQnO1xuY29uc3QgQXhpc0xhYmVsUm9sZSA9ICdheGlzLWxhYmVsJztcbmNvbnN0IEF4aXNUaWNrUm9sZSA9ICdheGlzLXRpY2snO1xuY29uc3QgQXhpc1RpdGxlUm9sZSA9ICdheGlzLXRpdGxlJztcbmNvbnN0IExlZ2VuZFJvbGUgPSAnbGVnZW5kJztcbmNvbnN0IExlZ2VuZEJhbmRSb2xlID0gJ2xlZ2VuZC1iYW5kJztcbmNvbnN0IExlZ2VuZEVudHJ5Um9sZSA9ICdsZWdlbmQtZW50cnknO1xuY29uc3QgTGVnZW5kR3JhZGllbnRSb2xlID0gJ2xlZ2VuZC1ncmFkaWVudCc7XG5jb25zdCBMZWdlbmRMYWJlbFJvbGUgPSAnbGVnZW5kLWxhYmVsJztcbmNvbnN0IExlZ2VuZFN5bWJvbFJvbGUgPSAnbGVnZW5kLXN5bWJvbCc7XG5jb25zdCBMZWdlbmRUaXRsZVJvbGUgPSAnbGVnZW5kLXRpdGxlJztcbmNvbnN0IFRpdGxlUm9sZSA9ICd0aXRsZSc7XG5jb25zdCBUaXRsZVRleHRSb2xlID0gJ3RpdGxlLXRleHQnO1xuY29uc3QgVGl0bGVTdWJ0aXRsZVJvbGUgPSAndGl0bGUtc3VidGl0bGUnO1xuXG5mdW5jdGlvbiBhcHBseURlZmF1bHRzIChlbmNvZGUsIHR5cGUsIHJvbGUsIHN0eWxlLCBjb25maWcpIHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7fSxcbiAgICAgICAgZW50ZXIgPSB7fTtcbiAgbGV0IHVwZGF0ZSwga2V5LCBza2lwLCBwcm9wczsgLy8gaWYgdGV4dCBtYXJrLCBhcHBseSBnbG9iYWwgbGluZUJyZWFrIHNldHRpbmdzICgjMjM3MClcblxuICBrZXkgPSAnbGluZUJyZWFrJztcblxuICBpZiAodHlwZSA9PT0gJ3RleHQnICYmIGNvbmZpZ1trZXldICE9IG51bGwgJiYgIWhhcyhrZXksIGVuY29kZSkpIHtcbiAgICBhcHBseURlZmF1bHQoZGVmYXVsdHMsIGtleSwgY29uZmlnW2tleV0pO1xuICB9IC8vIGlnbm9yZSBsZWdlbmQgYW5kIGF4aXMgcm9sZXNcblxuXG4gIGlmIChyb2xlID09ICdsZWdlbmQnIHx8IFN0cmluZyhyb2xlKS5zdGFydHNXaXRoKCdheGlzJykpIHtcbiAgICByb2xlID0gbnVsbDtcbiAgfSAvLyByZXNvbHZlIG1hcmsgY29uZmlnXG5cblxuICBwcm9wcyA9IHJvbGUgPT09IEZyYW1lUm9sZSA/IGNvbmZpZy5ncm91cCA6IHJvbGUgPT09IE1hcmtSb2xlID8gZXh0ZW5kKHt9LCBjb25maWcubWFyaywgY29uZmlnW3R5cGVdKSA6IG51bGw7XG5cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICAvLyBkbyBub3QgYXBwbHkgZGVmYXVsdHMgaWYgcmVsZXZhbnQgZmllbGRzIGFyZSBkZWZpbmVkXG4gICAgc2tpcCA9IGhhcyhrZXksIGVuY29kZSkgfHwgKGtleSA9PT0gJ2ZpbGwnIHx8IGtleSA9PT0gJ3N0cm9rZScpICYmIChoYXMoJ2ZpbGwnLCBlbmNvZGUpIHx8IGhhcygnc3Ryb2tlJywgZW5jb2RlKSk7XG4gICAgaWYgKCFza2lwKSBhcHBseURlZmF1bHQoZGVmYXVsdHMsIGtleSwgcHJvcHNba2V5XSk7XG4gIH0gLy8gcmVzb2x2ZSBzdHlsZXMsIGFwcGx5IHdpdGggaW5jcmVhc2luZyBwcmVjZWRlbmNlXG5cblxuICBhcnJheShzdHlsZSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IGNvbmZpZy5zdHlsZSAmJiBjb25maWcuc3R5bGVbbmFtZV07XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFoYXMoa2V5LCBlbmNvZGUpKSB7XG4gICAgICAgIGFwcGx5RGVmYXVsdChkZWZhdWx0cywga2V5LCBwcm9wc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBlbmNvZGUgPSBleHRlbmQoe30sIGVuY29kZSk7IC8vIGRlZmVuc2l2ZSBjb3B5XG5cbiAgZm9yIChrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBwcm9wcyA9IGRlZmF1bHRzW2tleV07XG5cbiAgICBpZiAocHJvcHMuc2lnbmFsKSB7XG4gICAgICAodXBkYXRlID0gdXBkYXRlIHx8IHt9KVtrZXldID0gcHJvcHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2tleV0gPSBwcm9wcztcbiAgICB9XG4gIH1cblxuICBlbmNvZGUuZW50ZXIgPSBleHRlbmQoZW50ZXIsIGVuY29kZS5lbnRlcik7XG4gIGlmICh1cGRhdGUpIGVuY29kZS51cGRhdGUgPSBleHRlbmQodXBkYXRlLCBlbmNvZGUudXBkYXRlKTtcbiAgcmV0dXJuIGVuY29kZTtcbn1cblxuZnVuY3Rpb24gYXBwbHlEZWZhdWx0KGRlZmF1bHRzLCBrZXksIHZhbHVlKSB7XG4gIGRlZmF1bHRzW2tleV0gPSB2YWx1ZSAmJiB2YWx1ZS5zaWduYWwgPyB7XG4gICAgc2lnbmFsOiB2YWx1ZS5zaWduYWxcbiAgfSA6IHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn1cblxuY29uc3Qgc2NhbGVSZWYgPSBzY2FsZSA9PiBpc1N0cmluZyhzY2FsZSkgPyBzdHJpbmdWYWx1ZShzY2FsZSkgOiBzY2FsZS5zaWduYWwgPyBgKCR7c2NhbGUuc2lnbmFsfSlgIDogZmllbGQoc2NhbGUpO1xuXG5mdW5jdGlvbiBlbnRyeSQxKGVuYykge1xuICBpZiAoZW5jLmdyYWRpZW50ICE9IG51bGwpIHtcbiAgICByZXR1cm4gZ3JhZGllbnQoZW5jKTtcbiAgfVxuXG4gIGxldCB2YWx1ZSA9IGVuYy5zaWduYWwgPyBgKCR7ZW5jLnNpZ25hbH0pYCA6IGVuYy5jb2xvciA/IGNvbG9yKGVuYy5jb2xvcikgOiBlbmMuZmllbGQgIT0gbnVsbCA/IGZpZWxkKGVuYy5maWVsZCkgOiBlbmMudmFsdWUgIT09IHVuZGVmaW5lZCA/IHN0cmluZ1ZhbHVlKGVuYy52YWx1ZSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGVuYy5zY2FsZSAhPSBudWxsKSB7XG4gICAgdmFsdWUgPSBzY2FsZShlbmMsIHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBudWxsO1xuICB9XG5cbiAgaWYgKGVuYy5leHBvbmVudCAhPSBudWxsKSB7XG4gICAgdmFsdWUgPSBgcG93KCR7dmFsdWV9LCR7cHJvcGVydHkoZW5jLmV4cG9uZW50KX0pYDtcbiAgfVxuXG4gIGlmIChlbmMubXVsdCAhPSBudWxsKSB7XG4gICAgdmFsdWUgKz0gYCoke3Byb3BlcnR5KGVuYy5tdWx0KX1gO1xuICB9XG5cbiAgaWYgKGVuYy5vZmZzZXQgIT0gbnVsbCkge1xuICAgIHZhbHVlICs9IGArJHtwcm9wZXJ0eShlbmMub2Zmc2V0KX1gO1xuICB9XG5cbiAgaWYgKGVuYy5yb3VuZCkge1xuICAgIHZhbHVlID0gYHJvdW5kKCR7dmFsdWV9KWA7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmNvbnN0IF9jb2xvciA9ICh0eXBlLCB4LCB5LCB6KSA9PiBgKCR7dHlwZX0oJHtbeCwgeSwgel0ubWFwKGVudHJ5JDEpLmpvaW4oJywnKX0pKycnKWA7XG5cbmZ1bmN0aW9uIGNvbG9yKGVuYykge1xuICByZXR1cm4gZW5jLmMgPyBfY29sb3IoJ2hjbCcsIGVuYy5oLCBlbmMuYywgZW5jLmwpIDogZW5jLmggfHwgZW5jLnMgPyBfY29sb3IoJ2hzbCcsIGVuYy5oLCBlbmMucywgZW5jLmwpIDogZW5jLmwgfHwgZW5jLmEgPyBfY29sb3IoJ2xhYicsIGVuYy5sLCBlbmMuYSwgZW5jLmIpIDogZW5jLnIgfHwgZW5jLmcgfHwgZW5jLmIgPyBfY29sb3IoJ3JnYicsIGVuYy5yLCBlbmMuZywgZW5jLmIpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ3JhZGllbnQoZW5jKSB7XG4gIC8vIG1hcCB1bmRlZmluZWQgdG8gbnVsbDsgZXhwcmVzc2lvbiBsYW5nIGRvZXMgbm90IGFsbG93IHVuZGVmaW5lZFxuICBjb25zdCBhcmdzID0gW2VuYy5zdGFydCwgZW5jLnN0b3AsIGVuYy5jb3VudF0ubWFwKF8gPT4gXyA9PSBudWxsID8gbnVsbCA6IHN0cmluZ1ZhbHVlKF8pKTsgLy8gdHJpbSBudWxsIGlucHV0cyBmcm9tIHRoZSBlbmRcblxuICB3aGlsZSAoYXJncy5sZW5ndGggJiYgcGVlayhhcmdzKSA9PSBudWxsKSBhcmdzLnBvcCgpO1xuXG4gIGFyZ3MudW5zaGlmdChzY2FsZVJlZihlbmMuZ3JhZGllbnQpKTtcbiAgcmV0dXJuIGBncmFkaWVudCgke2FyZ3Muam9pbignLCcpfSlgO1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eShwcm9wZXJ0eSkge1xuICByZXR1cm4gaXNPYmplY3QocHJvcGVydHkpID8gJygnICsgZW50cnkkMShwcm9wZXJ0eSkgKyAnKScgOiBwcm9wZXJ0eTtcbn1cblxuZnVuY3Rpb24gZmllbGQocmVmKSB7XG4gIHJldHVybiByZXNvbHZlRmllbGQoaXNPYmplY3QocmVmKSA/IHJlZiA6IHtcbiAgICBkYXR1bTogcmVmXG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRmllbGQocmVmKSB7XG4gIGxldCBvYmplY3QsIGxldmVsLCBmaWVsZDtcblxuICBpZiAocmVmLnNpZ25hbCkge1xuICAgIG9iamVjdCA9ICdkYXR1bSc7XG4gICAgZmllbGQgPSByZWYuc2lnbmFsO1xuICB9IGVsc2UgaWYgKHJlZi5ncm91cCB8fCByZWYucGFyZW50KSB7XG4gICAgbGV2ZWwgPSBNYXRoLm1heCgxLCByZWYubGV2ZWwgfHwgMSk7XG4gICAgb2JqZWN0ID0gJ2l0ZW0nO1xuXG4gICAgd2hpbGUgKGxldmVsLS0gPiAwKSB7XG4gICAgICBvYmplY3QgKz0gJy5tYXJrLmdyb3VwJztcbiAgICB9XG5cbiAgICBpZiAocmVmLnBhcmVudCkge1xuICAgICAgZmllbGQgPSByZWYucGFyZW50O1xuICAgICAgb2JqZWN0ICs9ICcuZGF0dW0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZCA9IHJlZi5ncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVmLmRhdHVtKSB7XG4gICAgb2JqZWN0ID0gJ2RhdHVtJztcbiAgICBmaWVsZCA9IHJlZi5kYXR1bTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcignSW52YWxpZCBmaWVsZCByZWZlcmVuY2U6ICcgKyBzdHJpbmdWYWx1ZShyZWYpKTtcbiAgfVxuXG4gIGlmICghcmVmLnNpZ25hbCkge1xuICAgIGZpZWxkID0gaXNTdHJpbmcoZmllbGQpID8gc3BsaXRBY2Nlc3NQYXRoKGZpZWxkKS5tYXAoc3RyaW5nVmFsdWUpLmpvaW4oJ11bJykgOiByZXNvbHZlRmllbGQoZmllbGQpO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdCArICdbJyArIGZpZWxkICsgJ10nO1xufVxuXG5mdW5jdGlvbiBzY2FsZShlbmMsIHZhbHVlKSB7XG4gIGNvbnN0IHNjYWxlID0gc2NhbGVSZWYoZW5jLnNjYWxlKTtcblxuICBpZiAoZW5jLnJhbmdlICE9IG51bGwpIHtcbiAgICAvLyBwdWxsIHZhbHVlIGZyb20gc2NhbGUgcmFuZ2VcbiAgICB2YWx1ZSA9IGBsZXJwKF9yYW5nZSgke3NjYWxlfSksICR7K2VuYy5yYW5nZX0pYDtcbiAgfSBlbHNlIHtcbiAgICAvLyBydW4gdmFsdWUgdGhyb3VnaCBzY2FsZSBhbmQvb3IgcHVsbCBzY2FsZSBiYW5kd2lkdGhcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgdmFsdWUgPSBgX3NjYWxlKCR7c2NhbGV9LCAke3ZhbHVlfSlgO1xuXG4gICAgaWYgKGVuYy5iYW5kKSB7XG4gICAgICB2YWx1ZSA9ICh2YWx1ZSA/IHZhbHVlICsgJysnIDogJycpICsgYF9iYW5kd2lkdGgoJHtzY2FsZX0pYCArICgrZW5jLmJhbmQgPT09IDEgPyAnJyA6ICcqJyArIHByb3BlcnR5KGVuYy5iYW5kKSk7XG5cbiAgICAgIGlmIChlbmMuZXh0cmEpIHtcbiAgICAgICAgLy8gaW5jbHVkZSBsb2dpYyB0byBoYW5kbGUgZXh0cmFuZW91cyBlbGVtZW50c1xuICAgICAgICB2YWx1ZSA9IGAoZGF0dW0uZXh0cmEgPyBfc2NhbGUoJHtzY2FsZX0sIGRhdHVtLmV4dHJhLnZhbHVlKSA6ICR7dmFsdWV9KWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHZhbHVlID0gJzAnO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBydWxlIChlbmMpIHtcbiAgbGV0IGNvZGUgPSAnJztcbiAgZW5jLmZvckVhY2gocnVsZSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBlbnRyeSQxKHJ1bGUpO1xuICAgIGNvZGUgKz0gcnVsZS50ZXN0ID8gYCgke3J1bGUudGVzdH0pPyR7dmFsdWV9OmAgOiB2YWx1ZTtcbiAgfSk7IC8vIGlmIG5vIGVsc2UgY2xhdXNlLCB0ZXJtaW5hdGUgd2l0aCBudWxsICgjMTM2NilcblxuICBpZiAocGVlayhjb2RlKSA9PT0gJzonKSB7XG4gICAgY29kZSArPSAnbnVsbCc7XG4gIH1cblxuICByZXR1cm4gY29kZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VFbmNvZGUgKGVuY29kZSwgdHlwZSwgcm9sZSwgc3R5bGUsIHNjb3BlLCBwYXJhbXMpIHtcbiAgY29uc3QgZW5jID0ge307XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgcGFyYW1zLmVuY29kZXJzID0ge1xuICAgICRlbmNvZGU6IGVuY1xuICB9O1xuICBlbmNvZGUgPSBhcHBseURlZmF1bHRzKGVuY29kZSwgdHlwZSwgcm9sZSwgc3R5bGUsIHNjb3BlLmNvbmZpZyk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gZW5jb2RlKSB7XG4gICAgZW5jW2tleV0gPSBwYXJzZUJsb2NrKGVuY29kZVtrZXldLCB0eXBlLCBwYXJhbXMsIHNjb3BlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQmxvY2soYmxvY2ssIG1hcmt0eXBlLCBwYXJhbXMsIHNjb3BlKSB7XG4gIGNvbnN0IGNoYW5uZWxzID0ge30sXG4gICAgICAgIGZpZWxkcyA9IHt9O1xuXG4gIGZvciAoY29uc3QgbmFtZSBpbiBibG9jaykge1xuICAgIGlmIChibG9ja1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAvLyBza2lwIGFueSBudWxsIGVudHJpZXNcbiAgICAgIGNoYW5uZWxzW25hbWVdID0gcGFyc2UkMShleHByKGJsb2NrW25hbWVdKSwgc2NvcGUsIHBhcmFtcywgZmllbGRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgICRleHByOiB7XG4gICAgICBtYXJrdHlwZSxcbiAgICAgIGNoYW5uZWxzXG4gICAgfSxcbiAgICAkZmllbGRzOiBPYmplY3Qua2V5cyhmaWVsZHMpLFxuICAgICRvdXRwdXQ6IE9iamVjdC5rZXlzKGJsb2NrKVxuICB9O1xufVxuXG5mdW5jdGlvbiBleHByKGVuYykge1xuICByZXR1cm4gaXNBcnJheShlbmMpID8gcnVsZShlbmMpIDogZW50cnkkMShlbmMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZSQxKGNvZGUsIHNjb3BlLCBwYXJhbXMsIGZpZWxkcykge1xuICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKGNvZGUsIHNjb3BlKTtcbiAgZXhwci4kZmllbGRzLmZvckVhY2gobmFtZSA9PiBmaWVsZHNbbmFtZV0gPSAxKTtcbiAgZXh0ZW5kKHBhcmFtcywgZXhwci4kcGFyYW1zKTtcbiAgcmV0dXJuIGV4cHIuJGV4cHI7XG59XG5cbmNvbnN0IE9VVEVSID0gJ291dGVyJyxcbiAgICAgIE9VVEVSX0lOVkFMSUQgPSBbJ3ZhbHVlJywgJ3VwZGF0ZScsICdpbml0JywgJ3JlYWN0JywgJ2JpbmQnXTtcblxuZnVuY3Rpb24gb3V0ZXJFcnJvcihwcmVmaXgsIG5hbWUpIHtcbiAgZXJyb3IocHJlZml4ICsgJyBmb3IgXCJvdXRlclwiIHB1c2g6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2lnbmFsIChzaWduYWwsIHNjb3BlKSB7XG4gIGNvbnN0IG5hbWUgPSBzaWduYWwubmFtZTtcblxuICBpZiAoc2lnbmFsLnB1c2ggPT09IE9VVEVSKSB7XG4gICAgLy8gc2lnbmFsIG11c3QgYWxyZWFkeSBiZSBkZWZpbmVkLCByYWlzZSBlcnJvciBpZiBub3RcbiAgICBpZiAoIXNjb3BlLnNpZ25hbHNbbmFtZV0pIG91dGVyRXJyb3IoJ05vIHByaW9yIHNpZ25hbCBkZWZpbml0aW9uJywgbmFtZSk7IC8vIHNpZ25hbCBwdXNoIG11c3Qgbm90IHVzZSBwcm9wZXJ0aWVzIHJlc2VydmVkIGZvciBzdGFuZGFyZCBkZWZpbml0aW9uXG5cbiAgICBPVVRFUl9JTlZBTElELmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBpZiAoc2lnbmFsW3Byb3BdICE9PSB1bmRlZmluZWQpIG91dGVyRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgJywgcHJvcCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVmaW5lIGEgbmV3IHNpZ25hbCBpbiB0aGUgY3VycmVudCBzY29wZVxuICAgIGNvbnN0IG9wID0gc2NvcGUuYWRkU2lnbmFsKG5hbWUsIHNpZ25hbC52YWx1ZSk7XG4gICAgaWYgKHNpZ25hbC5yZWFjdCA9PT0gZmFsc2UpIG9wLnJlYWN0ID0gZmFsc2U7XG4gICAgaWYgKHNpZ25hbC5iaW5kKSBzY29wZS5hZGRCaW5kaW5nKG5hbWUsIHNpZ25hbC5iaW5kKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBFbnRyeSh0eXBlLCB2YWx1ZSwgcGFyYW1zLCBwYXJlbnQpIHtcbiAgdGhpcy5pZCA9IC0xO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICBpZiAocGFyZW50KSB0aGlzLnBhcmVudCA9IHBhcmVudDtcbn1cbmZ1bmN0aW9uIGVudHJ5KHR5cGUsIHZhbHVlLCBwYXJhbXMsIHBhcmVudCkge1xuICByZXR1cm4gbmV3IEVudHJ5KHR5cGUsIHZhbHVlLCBwYXJhbXMsIHBhcmVudCk7XG59XG5mdW5jdGlvbiBvcGVyYXRvcih2YWx1ZSwgcGFyYW1zKSB7XG4gIHJldHVybiBlbnRyeSgnb3BlcmF0b3InLCB2YWx1ZSwgcGFyYW1zKTtcbn0gLy8gLS0tLS1cblxuZnVuY3Rpb24gcmVmKG9wKSB7XG4gIGNvbnN0IHJlZiA9IHtcbiAgICAkcmVmOiBvcC5pZFxuICB9OyAvLyBpZiBvcGVyYXRvciBub3QgeWV0IHJlZ2lzdGVyZWQsIGNhY2hlIHJlZiB0byByZXNvbHZlIGxhdGVyXG5cbiAgaWYgKG9wLmlkIDwgMCkgKG9wLnJlZnMgPSBvcC5yZWZzIHx8IFtdKS5wdXNoKHJlZik7XG4gIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiBmaWVsZFJlZiQxKGZpZWxkLCBuYW1lKSB7XG4gIHJldHVybiBuYW1lID8ge1xuICAgICRmaWVsZDogZmllbGQsXG4gICAgJG5hbWU6IG5hbWVcbiAgfSA6IHtcbiAgICAkZmllbGQ6IGZpZWxkXG4gIH07XG59XG5jb25zdCBrZXlGaWVsZFJlZiA9IGZpZWxkUmVmJDEoJ2tleScpO1xuZnVuY3Rpb24gY29tcGFyZVJlZihmaWVsZHMsIG9yZGVycykge1xuICByZXR1cm4ge1xuICAgICRjb21wYXJlOiBmaWVsZHMsXG4gICAgJG9yZGVyOiBvcmRlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGtleVJlZihmaWVsZHMsIGZsYXQpIHtcbiAgY29uc3QgcmVmID0ge1xuICAgICRrZXk6IGZpZWxkc1xuICB9O1xuICBpZiAoZmxhdCkgcmVmLiRmbGF0ID0gdHJ1ZTtcbiAgcmV0dXJuIHJlZjtcbn0gLy8gLS0tLS1cblxuY29uc3QgQXNjZW5kaW5nID0gJ2FzY2VuZGluZyc7XG5jb25zdCBEZXNjZW5kaW5nID0gJ2Rlc2NlbmRpbmcnO1xuZnVuY3Rpb24gc29ydEtleShzb3J0KSB7XG4gIHJldHVybiAhaXNPYmplY3Qoc29ydCkgPyAnJyA6IChzb3J0Lm9yZGVyID09PSBEZXNjZW5kaW5nID8gJy0nIDogJysnKSArIGFnZ3JGaWVsZChzb3J0Lm9wLCBzb3J0LmZpZWxkKTtcbn1cbmZ1bmN0aW9uIGFnZ3JGaWVsZChvcCwgZmllbGQpIHtcbiAgcmV0dXJuIChvcCAmJiBvcC5zaWduYWwgPyAnJCcgKyBvcC5zaWduYWwgOiBvcCB8fCAnJykgKyAob3AgJiYgZmllbGQgPyAnXycgOiAnJykgKyAoZmllbGQgJiYgZmllbGQuc2lnbmFsID8gJyQnICsgZmllbGQuc2lnbmFsIDogZmllbGQgfHwgJycpO1xufSAvLyAtLS0tLVxuXG5jb25zdCBTY29wZSQxID0gJ3Njb3BlJztcbmNvbnN0IFZpZXcgPSAndmlldyc7XG5mdW5jdGlvbiBpc1NpZ25hbChfKSB7XG4gIHJldHVybiBfICYmIF8uc2lnbmFsO1xufVxuZnVuY3Rpb24gaXNFeHByJDEoXykge1xuICByZXR1cm4gXyAmJiBfLmV4cHI7XG59XG5mdW5jdGlvbiBoYXNTaWduYWwoXykge1xuICBpZiAoaXNTaWduYWwoXykpIHJldHVybiB0cnVlO1xuICBpZiAoaXNPYmplY3QoXykpIGZvciAoY29uc3Qga2V5IGluIF8pIHtcbiAgICBpZiAoaGFzU2lnbmFsKF9ba2V5XSkpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHZhbHVlKHNwZWNWYWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBzcGVjVmFsdWUgIT0gbnVsbCA/IHNwZWNWYWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGRlcmVmKHYpIHtcbiAgcmV0dXJuIHYgJiYgdi5zaWduYWwgfHwgdjtcbn1cblxuY29uc3QgVGltZXIgPSAndGltZXInO1xuZnVuY3Rpb24gcGFyc2VTdHJlYW0oc3RyZWFtLCBzY29wZSkge1xuICBjb25zdCBtZXRob2QgPSBzdHJlYW0ubWVyZ2UgPyBtZXJnZVN0cmVhbSA6IHN0cmVhbS5zdHJlYW0gPyBuZXN0ZWRTdHJlYW0gOiBzdHJlYW0udHlwZSA/IGV2ZW50U3RyZWFtIDogZXJyb3IoJ0ludmFsaWQgc3RyZWFtIHNwZWNpZmljYXRpb246ICcgKyBzdHJpbmdWYWx1ZShzdHJlYW0pKTtcbiAgcmV0dXJuIG1ldGhvZChzdHJlYW0sIHNjb3BlKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRTb3VyY2Uoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgPT09IFNjb3BlJDEgPyBWaWV3IDogc291cmNlIHx8IFZpZXc7XG59XG5cbmZ1bmN0aW9uIG1lcmdlU3RyZWFtKHN0cmVhbSwgc2NvcGUpIHtcbiAgY29uc3QgbGlzdCA9IHN0cmVhbS5tZXJnZS5tYXAocyA9PiBwYXJzZVN0cmVhbShzLCBzY29wZSkpLFxuICAgICAgICBlbnRyeSA9IHN0cmVhbVBhcmFtZXRlcnMoe1xuICAgIG1lcmdlOiBsaXN0XG4gIH0sIHN0cmVhbSwgc2NvcGUpO1xuICByZXR1cm4gc2NvcGUuYWRkU3RyZWFtKGVudHJ5KS5pZDtcbn1cblxuZnVuY3Rpb24gbmVzdGVkU3RyZWFtKHN0cmVhbSwgc2NvcGUpIHtcbiAgY29uc3QgaWQgPSBwYXJzZVN0cmVhbShzdHJlYW0uc3RyZWFtLCBzY29wZSksXG4gICAgICAgIGVudHJ5ID0gc3RyZWFtUGFyYW1ldGVycyh7XG4gICAgc3RyZWFtOiBpZFxuICB9LCBzdHJlYW0sIHNjb3BlKTtcbiAgcmV0dXJuIHNjb3BlLmFkZFN0cmVhbShlbnRyeSkuaWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50U3RyZWFtKHN0cmVhbSwgc2NvcGUpIHtcbiAgbGV0IGlkO1xuXG4gIGlmIChzdHJlYW0udHlwZSA9PT0gVGltZXIpIHtcbiAgICBpZCA9IHNjb3BlLmV2ZW50KFRpbWVyLCBzdHJlYW0udGhyb3R0bGUpO1xuICAgIHN0cmVhbSA9IHtcbiAgICAgIGJldHdlZW46IHN0cmVhbS5iZXR3ZWVuLFxuICAgICAgZmlsdGVyOiBzdHJlYW0uZmlsdGVyXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IHNjb3BlLmV2ZW50KGV2ZW50U291cmNlKHN0cmVhbS5zb3VyY2UpLCBzdHJlYW0udHlwZSk7XG4gIH1cblxuICBjb25zdCBlbnRyeSA9IHN0cmVhbVBhcmFtZXRlcnMoe1xuICAgIHN0cmVhbTogaWRcbiAgfSwgc3RyZWFtLCBzY29wZSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhlbnRyeSkubGVuZ3RoID09PSAxID8gaWQgOiBzY29wZS5hZGRTdHJlYW0oZW50cnkpLmlkO1xufVxuXG5mdW5jdGlvbiBzdHJlYW1QYXJhbWV0ZXJzKGVudHJ5LCBzdHJlYW0sIHNjb3BlKSB7XG4gIGxldCBwYXJhbSA9IHN0cmVhbS5iZXR3ZWVuO1xuXG4gIGlmIChwYXJhbSkge1xuICAgIGlmIChwYXJhbS5sZW5ndGggIT09IDIpIHtcbiAgICAgIGVycm9yKCdTdHJlYW0gXCJiZXR3ZWVuXCIgcGFyYW1ldGVyIG11c3QgaGF2ZSAyIGVudHJpZXM6ICcgKyBzdHJpbmdWYWx1ZShzdHJlYW0pKTtcbiAgICB9XG5cbiAgICBlbnRyeS5iZXR3ZWVuID0gW3BhcnNlU3RyZWFtKHBhcmFtWzBdLCBzY29wZSksIHBhcnNlU3RyZWFtKHBhcmFtWzFdLCBzY29wZSldO1xuICB9XG5cbiAgcGFyYW0gPSBzdHJlYW0uZmlsdGVyID8gW10uY29uY2F0KHN0cmVhbS5maWx0ZXIpIDogW107XG5cbiAgaWYgKHN0cmVhbS5tYXJrdHlwZSB8fCBzdHJlYW0ubWFya25hbWUgfHwgc3RyZWFtLm1hcmtyb2xlKSB7XG4gICAgLy8gYWRkIGZpbHRlciBmb3IgbWFyayB0eXBlLCBuYW1lIGFuZC9vciByb2xlXG4gICAgcGFyYW0ucHVzaChmaWx0ZXJNYXJrKHN0cmVhbS5tYXJrdHlwZSwgc3RyZWFtLm1hcmtuYW1lLCBzdHJlYW0ubWFya3JvbGUpKTtcbiAgfVxuXG4gIGlmIChzdHJlYW0uc291cmNlID09PSBTY29wZSQxKSB7XG4gICAgLy8gYWRkIGZpbHRlciB0byBsaW1pdCBldmVudHMgZnJvbSBzdWItc2NvcGUgb25seVxuICAgIHBhcmFtLnB1c2goJ2luU2NvcGUoZXZlbnQuaXRlbSknKTtcbiAgfVxuXG4gIGlmIChwYXJhbS5sZW5ndGgpIHtcbiAgICBlbnRyeS5maWx0ZXIgPSBwYXJzZUV4cHJlc3Npb24oJygnICsgcGFyYW0uam9pbignKSYmKCcpICsgJyknLCBzY29wZSkuJGV4cHI7XG4gIH1cblxuICBpZiAoKHBhcmFtID0gc3RyZWFtLnRocm90dGxlKSAhPSBudWxsKSB7XG4gICAgZW50cnkudGhyb3R0bGUgPSArcGFyYW07XG4gIH1cblxuICBpZiAoKHBhcmFtID0gc3RyZWFtLmRlYm91bmNlKSAhPSBudWxsKSB7XG4gICAgZW50cnkuZGVib3VuY2UgPSArcGFyYW07XG4gIH1cblxuICBpZiAoc3RyZWFtLmNvbnN1bWUpIHtcbiAgICBlbnRyeS5jb25zdW1lID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBlbnRyeTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyTWFyayh0eXBlLCBuYW1lLCByb2xlKSB7XG4gIGNvbnN0IGl0ZW0gPSAnZXZlbnQuaXRlbSc7XG4gIHJldHVybiBpdGVtICsgKHR5cGUgJiYgdHlwZSAhPT0gJyonID8gJyYmJyArIGl0ZW0gKyAnLm1hcmsubWFya3R5cGU9PT1cXCcnICsgdHlwZSArICdcXCcnIDogJycpICsgKHJvbGUgPyAnJiYnICsgaXRlbSArICcubWFyay5yb2xlPT09XFwnJyArIHJvbGUgKyAnXFwnJyA6ICcnKSArIChuYW1lID8gJyYmJyArIGl0ZW0gKyAnLm1hcmsubmFtZT09PVxcJycgKyBuYW1lICsgJ1xcJycgOiAnJyk7XG59XG5cbmNvbnN0IE9QX1ZBTFVFX0VYUFIgPSB7XG4gIGNvZGU6ICdfLiR2YWx1ZScsXG4gIGFzdDoge1xuICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICB2YWx1ZTogJ3ZhbHVlJ1xuICB9XG59O1xuZnVuY3Rpb24gcGFyc2VVcGRhdGUgKHNwZWMsIHNjb3BlLCB0YXJnZXQpIHtcbiAgY29uc3QgZW5jb2RlID0gc3BlYy5lbmNvZGUsXG4gICAgICAgIGVudHJ5ID0ge1xuICAgIHRhcmdldDogdGFyZ2V0XG4gIH07XG4gIGxldCBldmVudHMgPSBzcGVjLmV2ZW50cyxcbiAgICAgIHVwZGF0ZSA9IHNwZWMudXBkYXRlLFxuICAgICAgc291cmNlcyA9IFtdO1xuXG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXJyb3IoJ1NpZ25hbCB1cGRhdGUgbWlzc2luZyBldmVudHMgc3BlY2lmaWNhdGlvbi4nKTtcbiAgfSAvLyBpbnRlcnByZXQgYXMgYW4gZXZlbnQgc2VsZWN0b3Igc3RyaW5nXG5cblxuICBpZiAoaXNTdHJpbmcoZXZlbnRzKSkge1xuICAgIGV2ZW50cyA9IHBhcnNlU2VsZWN0b3IoZXZlbnRzLCBzY29wZS5pc1N1YnNjb3BlKCkgPyBTY29wZSQxIDogVmlldyk7XG4gIH0gLy8gc2VwYXJhdGUgZXZlbnQgc3RyZWFtcyBmcm9tIHNpZ25hbCB1cGRhdGVzXG5cblxuICBldmVudHMgPSBhcnJheShldmVudHMpLmZpbHRlcihzID0+IHMuc2lnbmFsIHx8IHMuc2NhbGUgPyAoc291cmNlcy5wdXNoKHMpLCAwKSA6IDEpOyAvLyBtZXJnZSBpbnRlcm5hbCBvcGVyYXRvciBsaXN0ZW5lcnNcblxuICBpZiAoc291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgc291cmNlcyA9IFttZXJnZVNvdXJjZXMoc291cmNlcyldO1xuICB9IC8vIG1lcmdlIGV2ZW50IHN0cmVhbXMsIGluY2x1ZGUgYXMgc291cmNlXG5cblxuICBpZiAoZXZlbnRzLmxlbmd0aCkge1xuICAgIHNvdXJjZXMucHVzaChldmVudHMubGVuZ3RoID4gMSA/IHtcbiAgICAgIG1lcmdlOiBldmVudHNcbiAgICB9IDogZXZlbnRzWzBdKTtcbiAgfVxuXG4gIGlmIChlbmNvZGUgIT0gbnVsbCkge1xuICAgIGlmICh1cGRhdGUpIGVycm9yKCdTaWduYWwgZW5jb2RlIGFuZCB1cGRhdGUgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4nKTtcbiAgICB1cGRhdGUgPSAnZW5jb2RlKGl0ZW0oKSwnICsgc3RyaW5nVmFsdWUoZW5jb2RlKSArICcpJztcbiAgfSAvLyByZXNvbHZlIHVwZGF0ZSB2YWx1ZVxuXG5cbiAgZW50cnkudXBkYXRlID0gaXNTdHJpbmcodXBkYXRlKSA/IHBhcnNlRXhwcmVzc2lvbih1cGRhdGUsIHNjb3BlKSA6IHVwZGF0ZS5leHByICE9IG51bGwgPyBwYXJzZUV4cHJlc3Npb24odXBkYXRlLmV4cHIsIHNjb3BlKSA6IHVwZGF0ZS52YWx1ZSAhPSBudWxsID8gdXBkYXRlLnZhbHVlIDogdXBkYXRlLnNpZ25hbCAhPSBudWxsID8ge1xuICAgICRleHByOiBPUF9WQUxVRV9FWFBSLFxuICAgICRwYXJhbXM6IHtcbiAgICAgICR2YWx1ZTogc2NvcGUuc2lnbmFsUmVmKHVwZGF0ZS5zaWduYWwpXG4gICAgfVxuICB9IDogZXJyb3IoJ0ludmFsaWQgc2lnbmFsIHVwZGF0ZSBzcGVjaWZpY2F0aW9uLicpO1xuXG4gIGlmIChzcGVjLmZvcmNlKSB7XG4gICAgZW50cnkub3B0aW9ucyA9IHtcbiAgICAgIGZvcmNlOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIHNvdXJjZXMuZm9yRWFjaChzb3VyY2UgPT4gc2NvcGUuYWRkVXBkYXRlKGV4dGVuZChzdHJlYW1Tb3VyY2Uoc291cmNlLCBzY29wZSksIGVudHJ5KSkpO1xufVxuXG5mdW5jdGlvbiBzdHJlYW1Tb3VyY2Uoc3RyZWFtLCBzY29wZSkge1xuICByZXR1cm4ge1xuICAgIHNvdXJjZTogc3RyZWFtLnNpZ25hbCA/IHNjb3BlLnNpZ25hbFJlZihzdHJlYW0uc2lnbmFsKSA6IHN0cmVhbS5zY2FsZSA/IHNjb3BlLnNjYWxlUmVmKHN0cmVhbS5zY2FsZSkgOiBwYXJzZVN0cmVhbShzdHJlYW0sIHNjb3BlKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZVNvdXJjZXMoc291cmNlcykge1xuICByZXR1cm4ge1xuICAgIHNpZ25hbDogJ1snICsgc291cmNlcy5tYXAocyA9PiBzLnNjYWxlID8gJ3NjYWxlKFwiJyArIHMuc2NhbGUgKyAnXCIpJyA6IHMuc2lnbmFsKSArICddJ1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVNpZ25hbFVwZGF0ZXMgKHNpZ25hbCwgc2NvcGUpIHtcbiAgY29uc3Qgb3AgPSBzY29wZS5nZXRTaWduYWwoc2lnbmFsLm5hbWUpO1xuICBsZXQgZXhwciA9IHNpZ25hbC51cGRhdGU7XG5cbiAgaWYgKHNpZ25hbC5pbml0KSB7XG4gICAgaWYgKGV4cHIpIHtcbiAgICAgIGVycm9yKCdTaWduYWxzIGNhbiBub3QgaW5jbHVkZSBib3RoIGluaXQgYW5kIHVwZGF0ZSBleHByZXNzaW9ucy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwciA9IHNpZ25hbC5pbml0O1xuICAgICAgb3AuaW5pdG9ubHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHByKSB7XG4gICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbihleHByLCBzY29wZSk7XG4gICAgb3AudXBkYXRlID0gZXhwci4kZXhwcjtcbiAgICBvcC5wYXJhbXMgPSBleHByLiRwYXJhbXM7XG4gIH1cblxuICBpZiAoc2lnbmFsLm9uKSB7XG4gICAgc2lnbmFsLm9uLmZvckVhY2goXyA9PiBwYXJzZVVwZGF0ZShfLCBzY29wZSwgb3AuaWQpKTtcbiAgfVxufVxuXG5jb25zdCB0cmFuc2Zvcm0gPSBuYW1lID0+IChwYXJhbXMsIHZhbHVlLCBwYXJlbnQpID0+IGVudHJ5KG5hbWUsIHZhbHVlLCBwYXJhbXMgfHwgdW5kZWZpbmVkLCBwYXJlbnQpO1xuXG5jb25zdCBBZ2dyZWdhdGUgPSB0cmFuc2Zvcm0oJ2FnZ3JlZ2F0ZScpO1xuY29uc3QgQXhpc1RpY2tzID0gdHJhbnNmb3JtKCdheGlzdGlja3MnKTtcbmNvbnN0IEJvdW5kID0gdHJhbnNmb3JtKCdib3VuZCcpO1xuY29uc3QgQ29sbGVjdCA9IHRyYW5zZm9ybSgnY29sbGVjdCcpO1xuY29uc3QgQ29tcGFyZSA9IHRyYW5zZm9ybSgnY29tcGFyZScpO1xuY29uc3QgRGF0YUpvaW4gPSB0cmFuc2Zvcm0oJ2RhdGFqb2luJyk7XG5jb25zdCBFbmNvZGUgPSB0cmFuc2Zvcm0oJ2VuY29kZScpO1xuY29uc3QgRXhwcmVzc2lvbiA9IHRyYW5zZm9ybSgnZXhwcmVzc2lvbicpO1xuY29uc3QgRmFjZXQgPSB0cmFuc2Zvcm0oJ2ZhY2V0Jyk7XG5jb25zdCBGaWVsZCA9IHRyYW5zZm9ybSgnZmllbGQnKTtcbmNvbnN0IEtleSA9IHRyYW5zZm9ybSgna2V5Jyk7XG5jb25zdCBMZWdlbmRFbnRyaWVzID0gdHJhbnNmb3JtKCdsZWdlbmRlbnRyaWVzJyk7XG5jb25zdCBMb2FkID0gdHJhbnNmb3JtKCdsb2FkJyk7XG5jb25zdCBNYXJrID0gdHJhbnNmb3JtKCdtYXJrJyk7XG5jb25zdCBNdWx0aUV4dGVudCA9IHRyYW5zZm9ybSgnbXVsdGlleHRlbnQnKTtcbmNvbnN0IE11bHRpVmFsdWVzID0gdHJhbnNmb3JtKCdtdWx0aXZhbHVlcycpO1xuY29uc3QgT3ZlcmxhcCA9IHRyYW5zZm9ybSgnb3ZlcmxhcCcpO1xuY29uc3QgUGFyYW1zID0gdHJhbnNmb3JtKCdwYXJhbXMnKTtcbmNvbnN0IFByZUZhY2V0ID0gdHJhbnNmb3JtKCdwcmVmYWNldCcpO1xuY29uc3QgUHJvamVjdGlvbiA9IHRyYW5zZm9ybSgncHJvamVjdGlvbicpO1xuY29uc3QgUHJveHkgPSB0cmFuc2Zvcm0oJ3Byb3h5Jyk7XG5jb25zdCBSZWxheSA9IHRyYW5zZm9ybSgncmVsYXknKTtcbmNvbnN0IFJlbmRlciA9IHRyYW5zZm9ybSgncmVuZGVyJyk7XG5jb25zdCBTY2FsZSA9IHRyYW5zZm9ybSgnc2NhbGUnKTtcbmNvbnN0IFNpZXZlID0gdHJhbnNmb3JtKCdzaWV2ZScpO1xuY29uc3QgU29ydEl0ZW1zID0gdHJhbnNmb3JtKCdzb3J0aXRlbXMnKTtcbmNvbnN0IFZpZXdMYXlvdXQgPSB0cmFuc2Zvcm0oJ3ZpZXdsYXlvdXQnKTtcbmNvbnN0IFZhbHVlcyA9IHRyYW5zZm9ybSgndmFsdWVzJyk7XG5cbmxldCBGSUVMRF9SRUZfSUQgPSAwO1xuY29uc3QgTVVMVElET01BSU5fU09SVF9PUFMgPSB7XG4gIG1pbjogJ21pbicsXG4gIG1heDogJ21heCcsXG4gIGNvdW50OiAnc3VtJ1xufTtcbmZ1bmN0aW9uIGluaXRTY2FsZShzcGVjLCBzY29wZSkge1xuICBjb25zdCB0eXBlID0gc3BlYy50eXBlIHx8ICdsaW5lYXInO1xuXG4gIGlmICghaXNWYWxpZFNjYWxlVHlwZSh0eXBlKSkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgc2NhbGUgdHlwZTogJyArIHN0cmluZ1ZhbHVlKHR5cGUpKTtcbiAgfVxuXG4gIHNjb3BlLmFkZFNjYWxlKHNwZWMubmFtZSwge1xuICAgIHR5cGUsXG4gICAgZG9tYWluOiB1bmRlZmluZWRcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVNjYWxlKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IHBhcmFtcyA9IHNjb3BlLmdldFNjYWxlKHNwZWMubmFtZSkucGFyYW1zO1xuICBsZXQga2V5O1xuICBwYXJhbXMuZG9tYWluID0gcGFyc2VTY2FsZURvbWFpbihzcGVjLmRvbWFpbiwgc3BlYywgc2NvcGUpO1xuXG4gIGlmIChzcGVjLnJhbmdlICE9IG51bGwpIHtcbiAgICBwYXJhbXMucmFuZ2UgPSBwYXJzZVNjYWxlUmFuZ2Uoc3BlYywgc2NvcGUsIHBhcmFtcyk7XG4gIH1cblxuICBpZiAoc3BlYy5pbnRlcnBvbGF0ZSAhPSBudWxsKSB7XG4gICAgcGFyc2VTY2FsZUludGVycG9sYXRlKHNwZWMuaW50ZXJwb2xhdGUsIHBhcmFtcyk7XG4gIH1cblxuICBpZiAoc3BlYy5uaWNlICE9IG51bGwpIHtcbiAgICBwYXJhbXMubmljZSA9IHBhcnNlU2NhbGVOaWNlKHNwZWMubmljZSk7XG4gIH1cblxuICBpZiAoc3BlYy5iaW5zICE9IG51bGwpIHtcbiAgICBwYXJhbXMuYmlucyA9IHBhcnNlU2NhbGVCaW5zKHNwZWMuYmlucywgc2NvcGUpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gc3BlYykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShwYXJhbXMsIGtleSkgfHwga2V5ID09PSAnbmFtZScpIGNvbnRpbnVlO1xuICAgIHBhcmFtc1trZXldID0gcGFyc2VMaXRlcmFsKHNwZWNba2V5XSwgc2NvcGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGl0ZXJhbCh2LCBzY29wZSkge1xuICByZXR1cm4gIWlzT2JqZWN0KHYpID8gdiA6IHYuc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKHYuc2lnbmFsKSA6IGVycm9yKCdVbnN1cHBvcnRlZCBvYmplY3Q6ICcgKyBzdHJpbmdWYWx1ZSh2KSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXJyYXkodiwgc2NvcGUpIHtcbiAgcmV0dXJuIHYuc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKHYuc2lnbmFsKSA6IHYubWFwKHYgPT4gcGFyc2VMaXRlcmFsKHYsIHNjb3BlKSk7XG59XG5cbmZ1bmN0aW9uIGRhdGFMb29rdXBFcnJvcihuYW1lKSB7XG4gIGVycm9yKCdDYW4gbm90IGZpbmQgZGF0YSBzZXQ6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG59IC8vIC0tIFNDQUxFIERPTUFJTiAtLS0tXG5cblxuZnVuY3Rpb24gcGFyc2VTY2FsZURvbWFpbihkb21haW4sIHNwZWMsIHNjb3BlKSB7XG4gIGlmICghZG9tYWluKSB7XG4gICAgaWYgKHNwZWMuZG9tYWluTWluICE9IG51bGwgfHwgc3BlYy5kb21haW5NYXggIT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ05vIHNjYWxlIGRvbWFpbiBkZWZpbmVkIGZvciBkb21haW5NaW4vZG9tYWluTWF4IHRvIG92ZXJyaWRlLicpO1xuICAgIH1cblxuICAgIHJldHVybjsgLy8gZGVmYXVsdCBkb21haW5cbiAgfVxuXG4gIHJldHVybiBkb21haW4uc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKGRvbWFpbi5zaWduYWwpIDogKGlzQXJyYXkoZG9tYWluKSA/IGV4cGxpY2l0RG9tYWluIDogZG9tYWluLmZpZWxkcyA/IG11bHRpcGxlRG9tYWluIDogc2luZ3VsYXJEb21haW4pKGRvbWFpbiwgc3BlYywgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBleHBsaWNpdERvbWFpbihkb21haW4sIHNwZWMsIHNjb3BlKSB7XG4gIHJldHVybiBkb21haW4ubWFwKHYgPT4gcGFyc2VMaXRlcmFsKHYsIHNjb3BlKSk7XG59XG5cbmZ1bmN0aW9uIHNpbmd1bGFyRG9tYWluKGRvbWFpbiwgc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgZGF0YSA9IHNjb3BlLmdldERhdGEoZG9tYWluLmRhdGEpO1xuICBpZiAoIWRhdGEpIGRhdGFMb29rdXBFcnJvcihkb21haW4uZGF0YSk7XG4gIHJldHVybiBpc0Rpc2NyZXRlKHNwZWMudHlwZSkgPyBkYXRhLnZhbHVlc1JlZihzY29wZSwgZG9tYWluLmZpZWxkLCBwYXJzZVNvcnQoZG9tYWluLnNvcnQsIGZhbHNlKSkgOiBpc1F1YW50aWxlKHNwZWMudHlwZSkgPyBkYXRhLmRvbWFpblJlZihzY29wZSwgZG9tYWluLmZpZWxkKSA6IGRhdGEuZXh0ZW50UmVmKHNjb3BlLCBkb21haW4uZmllbGQpO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZURvbWFpbihkb21haW4sIHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IGRhdGEgPSBkb21haW4uZGF0YSxcbiAgICAgICAgZmllbGRzID0gZG9tYWluLmZpZWxkcy5yZWR1Y2UoKGRvbSwgZCkgPT4ge1xuICAgIGQgPSBpc1N0cmluZyhkKSA/IHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBmaWVsZDogZFxuICAgIH0gOiBpc0FycmF5KGQpIHx8IGQuc2lnbmFsID8gZmllbGRSZWYoZCwgc2NvcGUpIDogZDtcbiAgICBkb20ucHVzaChkKTtcbiAgICByZXR1cm4gZG9tO1xuICB9LCBbXSk7XG4gIHJldHVybiAoaXNEaXNjcmV0ZShzcGVjLnR5cGUpID8gb3JkaW5hbE11bHRpcGxlRG9tYWluIDogaXNRdWFudGlsZShzcGVjLnR5cGUpID8gcXVhbnRpbGVNdWx0aXBsZURvbWFpbiA6IG51bWVyaWNNdWx0aXBsZURvbWFpbikoZG9tYWluLCBzY29wZSwgZmllbGRzKTtcbn1cblxuZnVuY3Rpb24gZmllbGRSZWYoZGF0YSwgc2NvcGUpIHtcbiAgY29uc3QgbmFtZSA9ICdfOnZlZ2E6XycgKyBGSUVMRF9SRUZfSUQrKyxcbiAgICAgICAgY29sbCA9IENvbGxlY3Qoe30pO1xuXG4gIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgY29sbC52YWx1ZSA9IHtcbiAgICAgICRpbmdlc3Q6IGRhdGFcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRhdGEuc2lnbmFsKSB7XG4gICAgY29uc3QgY29kZSA9ICdzZXRkYXRhKCcgKyBzdHJpbmdWYWx1ZShuYW1lKSArICcsJyArIGRhdGEuc2lnbmFsICsgJyknO1xuICAgIGNvbGwucGFyYW1zLmlucHV0ID0gc2NvcGUuc2lnbmFsUmVmKGNvZGUpO1xuICB9XG5cbiAgc2NvcGUuYWRkRGF0YVBpcGVsaW5lKG5hbWUsIFtjb2xsLCBTaWV2ZSh7fSldKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBuYW1lLFxuICAgIGZpZWxkOiAnZGF0YSdcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3JkaW5hbE11bHRpcGxlRG9tYWluKGRvbWFpbiwgc2NvcGUsIGZpZWxkcykge1xuICBjb25zdCBzb3J0ID0gcGFyc2VTb3J0KGRvbWFpbi5zb3J0LCB0cnVlKTtcbiAgbGV0IGEsIHY7IC8vIGdldCB2YWx1ZSBjb3VudHMgZm9yIGVhY2ggZG9tYWluIGZpZWxkXG5cbiAgY29uc3QgY291bnRzID0gZmllbGRzLm1hcChmID0+IHtcbiAgICBjb25zdCBkYXRhID0gc2NvcGUuZ2V0RGF0YShmLmRhdGEpO1xuICAgIGlmICghZGF0YSkgZGF0YUxvb2t1cEVycm9yKGYuZGF0YSk7XG4gICAgcmV0dXJuIGRhdGEuY291bnRzUmVmKHNjb3BlLCBmLmZpZWxkLCBzb3J0KTtcbiAgfSk7IC8vIGFnZ3JlZ2F0ZSB0aGUgcmVzdWx0cyBmcm9tIGVhY2ggZG9tYWluIGZpZWxkXG5cbiAgY29uc3QgcCA9IHtcbiAgICBncm91cGJ5OiBrZXlGaWVsZFJlZixcbiAgICBwdWxzZTogY291bnRzXG4gIH07XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBhID0gc29ydC5vcCB8fCAnY291bnQnO1xuICAgIHYgPSBzb3J0LmZpZWxkID8gYWdnckZpZWxkKGEsIHNvcnQuZmllbGQpIDogJ2NvdW50JztcbiAgICBwLm9wcyA9IFtNVUxUSURPTUFJTl9TT1JUX09QU1thXV07XG4gICAgcC5maWVsZHMgPSBbc2NvcGUuZmllbGRSZWYodildO1xuICAgIHAuYXMgPSBbdl07XG4gIH1cblxuICBhID0gc2NvcGUuYWRkKEFnZ3JlZ2F0ZShwKSk7IC8vIGNvbGxlY3QgYWdncmVnYXRlIG91dHB1dFxuXG4gIGNvbnN0IGMgPSBzY29wZS5hZGQoQ29sbGVjdCh7XG4gICAgcHVsc2U6IHJlZihhKVxuICB9KSk7IC8vIGV4dHJhY3QgdmFsdWVzIGZvciBjb21iaW5lZCBkb21haW5cblxuICB2ID0gc2NvcGUuYWRkKFZhbHVlcyh7XG4gICAgZmllbGQ6IGtleUZpZWxkUmVmLFxuICAgIHNvcnQ6IHNjb3BlLnNvcnRSZWYoc29ydCksXG4gICAgcHVsc2U6IHJlZihjKVxuICB9KSk7XG4gIHJldHVybiByZWYodik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU29ydChzb3J0LCBtdWx0aWRvbWFpbikge1xuICBpZiAoc29ydCkge1xuICAgIGlmICghc29ydC5maWVsZCAmJiAhc29ydC5vcCkge1xuICAgICAgaWYgKGlzT2JqZWN0KHNvcnQpKSBzb3J0LmZpZWxkID0gJ2tleSc7ZWxzZSBzb3J0ID0ge1xuICAgICAgICBmaWVsZDogJ2tleSdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghc29ydC5maWVsZCAmJiBzb3J0Lm9wICE9PSAnY291bnQnKSB7XG4gICAgICBlcnJvcignTm8gZmllbGQgcHJvdmlkZWQgZm9yIHNvcnQgYWdncmVnYXRlIG9wOiAnICsgc29ydC5vcCk7XG4gICAgfSBlbHNlIGlmIChtdWx0aWRvbWFpbiAmJiBzb3J0LmZpZWxkKSB7XG4gICAgICBpZiAoc29ydC5vcCAmJiAhTVVMVElET01BSU5fU09SVF9PUFNbc29ydC5vcF0pIHtcbiAgICAgICAgZXJyb3IoJ011bHRpcGxlIGRvbWFpbiBzY2FsZXMgY2FuIG5vdCBiZSBzb3J0ZWQgdXNpbmcgJyArIHNvcnQub3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3J0O1xufVxuXG5mdW5jdGlvbiBxdWFudGlsZU11bHRpcGxlRG9tYWluKGRvbWFpbiwgc2NvcGUsIGZpZWxkcykge1xuICAvLyBnZXQgdmFsdWUgYXJyYXlzIGZvciBlYWNoIGRvbWFpbiBmaWVsZFxuICBjb25zdCB2YWx1ZXMgPSBmaWVsZHMubWFwKGYgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBzY29wZS5nZXREYXRhKGYuZGF0YSk7XG4gICAgaWYgKCFkYXRhKSBkYXRhTG9va3VwRXJyb3IoZi5kYXRhKTtcbiAgICByZXR1cm4gZGF0YS5kb21haW5SZWYoc2NvcGUsIGYuZmllbGQpO1xuICB9KTsgLy8gY29tYmluZSB2YWx1ZSBhcnJheXNcblxuICByZXR1cm4gcmVmKHNjb3BlLmFkZChNdWx0aVZhbHVlcyh7XG4gICAgdmFsdWVzOiB2YWx1ZXNcbiAgfSkpKTtcbn1cblxuZnVuY3Rpb24gbnVtZXJpY011bHRpcGxlRG9tYWluKGRvbWFpbiwgc2NvcGUsIGZpZWxkcykge1xuICAvLyBnZXQgZXh0ZW50cyBmb3IgZWFjaCBkb21haW4gZmllbGRcbiAgY29uc3QgZXh0ZW50cyA9IGZpZWxkcy5tYXAoZiA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHNjb3BlLmdldERhdGEoZi5kYXRhKTtcbiAgICBpZiAoIWRhdGEpIGRhdGFMb29rdXBFcnJvcihmLmRhdGEpO1xuICAgIHJldHVybiBkYXRhLmV4dGVudFJlZihzY29wZSwgZi5maWVsZCk7XG4gIH0pOyAvLyBjb21iaW5lIGV4dGVudHNcblxuICByZXR1cm4gcmVmKHNjb3BlLmFkZChNdWx0aUV4dGVudCh7XG4gICAgZXh0ZW50czogZXh0ZW50c1xuICB9KSkpO1xufSAvLyAtLSBTQ0FMRSBCSU5TIC0tLS0tXG5cblxuZnVuY3Rpb24gcGFyc2VTY2FsZUJpbnModiwgc2NvcGUpIHtcbiAgcmV0dXJuIHYuc2lnbmFsIHx8IGlzQXJyYXkodikgPyBwYXJzZUFycmF5KHYsIHNjb3BlKSA6IHNjb3BlLm9iamVjdFByb3BlcnR5KHYpO1xufSAvLyAtLSBTQ0FMRSBOSUNFIC0tLS0tXG5cblxuZnVuY3Rpb24gcGFyc2VTY2FsZU5pY2UobmljZSkge1xuICByZXR1cm4gaXNPYmplY3QobmljZSkgPyB7XG4gICAgaW50ZXJ2YWw6IHBhcnNlTGl0ZXJhbChuaWNlLmludGVydmFsKSxcbiAgICBzdGVwOiBwYXJzZUxpdGVyYWwobmljZS5zdGVwKVxuICB9IDogcGFyc2VMaXRlcmFsKG5pY2UpO1xufSAvLyAtLSBTQ0FMRSBJTlRFUlBPTEFUSU9OIC0tLS0tXG5cblxuZnVuY3Rpb24gcGFyc2VTY2FsZUludGVycG9sYXRlKGludGVycG9sYXRlLCBwYXJhbXMpIHtcbiAgcGFyYW1zLmludGVycG9sYXRlID0gcGFyc2VMaXRlcmFsKGludGVycG9sYXRlLnR5cGUgfHwgaW50ZXJwb2xhdGUpO1xuXG4gIGlmIChpbnRlcnBvbGF0ZS5nYW1tYSAhPSBudWxsKSB7XG4gICAgcGFyYW1zLmludGVycG9sYXRlR2FtbWEgPSBwYXJzZUxpdGVyYWwoaW50ZXJwb2xhdGUuZ2FtbWEpO1xuICB9XG59IC8vIC0tIFNDQUxFIFJBTkdFIC0tLS0tXG5cblxuZnVuY3Rpb24gcGFyc2VTY2FsZVJhbmdlKHNwZWMsIHNjb3BlLCBwYXJhbXMpIHtcbiAgY29uc3QgY29uZmlnID0gc2NvcGUuY29uZmlnLnJhbmdlO1xuICBsZXQgcmFuZ2UgPSBzcGVjLnJhbmdlO1xuXG4gIGlmIChyYW5nZS5zaWduYWwpIHtcbiAgICByZXR1cm4gc2NvcGUuc2lnbmFsUmVmKHJhbmdlLnNpZ25hbCk7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcocmFuZ2UpKSB7XG4gICAgaWYgKGNvbmZpZyAmJiBoYXNPd25Qcm9wZXJ0eShjb25maWcsIHJhbmdlKSkge1xuICAgICAgc3BlYyA9IGV4dGVuZCh7fSwgc3BlYywge1xuICAgICAgICByYW5nZTogY29uZmlnW3JhbmdlXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyc2VTY2FsZVJhbmdlKHNwZWMsIHNjb3BlLCBwYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09ICd3aWR0aCcpIHtcbiAgICAgIHJhbmdlID0gWzAsIHtcbiAgICAgICAgc2lnbmFsOiAnd2lkdGgnXG4gICAgICB9XTtcbiAgICB9IGVsc2UgaWYgKHJhbmdlID09PSAnaGVpZ2h0Jykge1xuICAgICAgcmFuZ2UgPSBpc0Rpc2NyZXRlKHNwZWMudHlwZSkgPyBbMCwge1xuICAgICAgICBzaWduYWw6ICdoZWlnaHQnXG4gICAgICB9XSA6IFt7XG4gICAgICAgIHNpZ25hbDogJ2hlaWdodCdcbiAgICAgIH0sIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcignVW5yZWNvZ25pemVkIHNjYWxlIHJhbmdlIHZhbHVlOiAnICsgc3RyaW5nVmFsdWUocmFuZ2UpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmFuZ2Uuc2NoZW1lKSB7XG4gICAgcGFyYW1zLnNjaGVtZSA9IGlzQXJyYXkocmFuZ2Uuc2NoZW1lKSA/IHBhcnNlQXJyYXkocmFuZ2Uuc2NoZW1lLCBzY29wZSkgOiBwYXJzZUxpdGVyYWwocmFuZ2Uuc2NoZW1lLCBzY29wZSk7XG4gICAgaWYgKHJhbmdlLmV4dGVudCkgcGFyYW1zLnNjaGVtZUV4dGVudCA9IHBhcnNlQXJyYXkocmFuZ2UuZXh0ZW50LCBzY29wZSk7XG4gICAgaWYgKHJhbmdlLmNvdW50KSBwYXJhbXMuc2NoZW1lQ291bnQgPSBwYXJzZUxpdGVyYWwocmFuZ2UuY291bnQsIHNjb3BlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocmFuZ2Uuc3RlcCkge1xuICAgIHBhcmFtcy5yYW5nZVN0ZXAgPSBwYXJzZUxpdGVyYWwocmFuZ2Uuc3RlcCwgc2NvcGUpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpc0Rpc2NyZXRlKHNwZWMudHlwZSkgJiYgIWlzQXJyYXkocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHBhcnNlU2NhbGVEb21haW4ocmFuZ2UsIHNwZWMsIHNjb3BlKTtcbiAgfSBlbHNlIGlmICghaXNBcnJheShyYW5nZSkpIHtcbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgcmFuZ2UgdHlwZTogJyArIHN0cmluZ1ZhbHVlKHJhbmdlKSk7XG4gIH1cblxuICByZXR1cm4gcmFuZ2UubWFwKHYgPT4gKGlzQXJyYXkodikgPyBwYXJzZUFycmF5IDogcGFyc2VMaXRlcmFsKSh2LCBzY29wZSkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVByb2plY3Rpb24gKHByb2osIHNjb3BlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHNjb3BlLmNvbmZpZy5wcm9qZWN0aW9uIHx8IHt9LFxuICAgICAgICBwYXJhbXMgPSB7fTtcblxuICBmb3IgKGNvbnN0IG5hbWUgaW4gcHJvaikge1xuICAgIGlmIChuYW1lID09PSAnbmFtZScpIGNvbnRpbnVlO1xuICAgIHBhcmFtc1tuYW1lXSA9IHBhcnNlUGFyYW1ldGVyJDEocHJvaltuYW1lXSwgbmFtZSwgc2NvcGUpO1xuICB9IC8vIGFwcGx5IHByb2plY3Rpb24gZGVmYXVsdHMgZnJvbSBjb25maWdcblxuXG4gIGZvciAoY29uc3QgbmFtZSBpbiBjb25maWcpIHtcbiAgICBpZiAocGFyYW1zW25hbWVdID09IG51bGwpIHtcbiAgICAgIHBhcmFtc1tuYW1lXSA9IHBhcnNlUGFyYW1ldGVyJDEoY29uZmlnW25hbWVdLCBuYW1lLCBzY29wZSk7XG4gICAgfVxuICB9XG5cbiAgc2NvcGUuYWRkUHJvamVjdGlvbihwcm9qLm5hbWUsIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyJDEoXywgbmFtZSwgc2NvcGUpIHtcbiAgcmV0dXJuIGlzQXJyYXkoXykgPyBfLm1hcChfID0+IHBhcnNlUGFyYW1ldGVyJDEoXywgbmFtZSwgc2NvcGUpKSA6ICFpc09iamVjdChfKSA/IF8gOiBfLnNpZ25hbCA/IHNjb3BlLnNpZ25hbFJlZihfLnNpZ25hbCkgOiBuYW1lID09PSAnZml0JyA/IF8gOiBlcnJvcignVW5zdXBwb3J0ZWQgcGFyYW1ldGVyIG9iamVjdDogJyArIHN0cmluZ1ZhbHVlKF8pKTtcbn1cblxuY29uc3QgVG9wID0gJ3RvcCc7XG5jb25zdCBMZWZ0ID0gJ2xlZnQnO1xuY29uc3QgUmlnaHQgPSAncmlnaHQnO1xuY29uc3QgQm90dG9tID0gJ2JvdHRvbSc7XG5jb25zdCBDZW50ZXIgPSAnY2VudGVyJztcbmNvbnN0IFZlcnRpY2FsID0gJ3ZlcnRpY2FsJztcbmNvbnN0IFN0YXJ0ID0gJ3N0YXJ0JztcbmNvbnN0IE1pZGRsZSA9ICdtaWRkbGUnO1xuY29uc3QgRW5kID0gJ2VuZCc7XG5jb25zdCBJbmRleCA9ICdpbmRleCc7XG5jb25zdCBMYWJlbCA9ICdsYWJlbCc7XG5jb25zdCBPZmZzZXQgPSAnb2Zmc2V0JztcbmNvbnN0IFBlcmMgPSAncGVyYyc7XG5jb25zdCBQZXJjMiA9ICdwZXJjMic7XG5jb25zdCBWYWx1ZSA9ICd2YWx1ZSc7XG5jb25zdCBHdWlkZUxhYmVsU3R5bGUgPSAnZ3VpZGUtbGFiZWwnO1xuY29uc3QgR3VpZGVUaXRsZVN0eWxlID0gJ2d1aWRlLXRpdGxlJztcbmNvbnN0IEdyb3VwVGl0bGVTdHlsZSA9ICdncm91cC10aXRsZSc7XG5jb25zdCBHcm91cFN1YnRpdGxlU3R5bGUgPSAnZ3JvdXAtc3VidGl0bGUnO1xuY29uc3QgU3ltYm9scyA9ICdzeW1ib2wnO1xuY29uc3QgR3JhZGllbnQgPSAnZ3JhZGllbnQnO1xuY29uc3QgRGlzY3JldGUgPSAnZGlzY3JldGUnO1xuY29uc3QgU2l6ZSA9ICdzaXplJztcbmNvbnN0IFNoYXBlID0gJ3NoYXBlJztcbmNvbnN0IEZpbGwgPSAnZmlsbCc7XG5jb25zdCBTdHJva2UgPSAnc3Ryb2tlJztcbmNvbnN0IFN0cm9rZVdpZHRoID0gJ3N0cm9rZVdpZHRoJztcbmNvbnN0IFN0cm9rZURhc2ggPSAnc3Ryb2tlRGFzaCc7XG5jb25zdCBPcGFjaXR5ID0gJ29wYWNpdHknOyAvLyBFbmNvZGluZyBjaGFubmVscyBzdXBwb3J0ZWQgYnkgbGVnZW5kc1xuLy8gSW4gcHJpb3JpdHkgb3JkZXIgb2YgJ2Nhbm9uaWNhbCcgc2NhbGVcblxuY29uc3QgTGVnZW5kU2NhbGVzID0gW1NpemUsIFNoYXBlLCBGaWxsLCBTdHJva2UsIFN0cm9rZVdpZHRoLCBTdHJva2VEYXNoLCBPcGFjaXR5XTtcbmNvbnN0IFNraXAgPSB7XG4gIG5hbWU6IDEsXG4gIHN0eWxlOiAxLFxuICBpbnRlcmFjdGl2ZTogMVxufTtcbmNvbnN0IHplcm8gPSB7XG4gIHZhbHVlOiAwXG59O1xuY29uc3Qgb25lID0ge1xuICB2YWx1ZTogMVxufTtcblxuY29uc3QgR3JvdXBNYXJrID0gJ2dyb3VwJztcbmNvbnN0IFJlY3RNYXJrID0gJ3JlY3QnO1xuY29uc3QgUnVsZU1hcmsgPSAncnVsZSc7XG5jb25zdCBTeW1ib2xNYXJrID0gJ3N5bWJvbCc7XG5jb25zdCBUZXh0TWFyayA9ICd0ZXh0JztcblxuZnVuY3Rpb24gZ3VpZGVHcm91cCAobWFyaykge1xuICBtYXJrLnR5cGUgPSBHcm91cE1hcms7XG4gIG1hcmsuaW50ZXJhY3RpdmUgPSBtYXJrLmludGVyYWN0aXZlIHx8IGZhbHNlO1xuICByZXR1cm4gbWFyaztcbn1cblxuZnVuY3Rpb24gbG9va3VwKHNwZWMsIGNvbmZpZykge1xuICBjb25zdCBfID0gKG5hbWUsIGRmbHQpID0+IHZhbHVlKHNwZWNbbmFtZV0sIHZhbHVlKGNvbmZpZ1tuYW1lXSwgZGZsdCkpO1xuXG4gIF8uaXNWZXJ0aWNhbCA9IHMgPT4gVmVydGljYWwgPT09IHZhbHVlKHNwZWMuZGlyZWN0aW9uLCBjb25maWcuZGlyZWN0aW9uIHx8IChzID8gY29uZmlnLnN5bWJvbERpcmVjdGlvbiA6IGNvbmZpZy5ncmFkaWVudERpcmVjdGlvbikpO1xuXG4gIF8uZ3JhZGllbnRMZW5ndGggPSAoKSA9PiB2YWx1ZShzcGVjLmdyYWRpZW50TGVuZ3RoLCBjb25maWcuZ3JhZGllbnRMZW5ndGggfHwgY29uZmlnLmdyYWRpZW50V2lkdGgpO1xuXG4gIF8uZ3JhZGllbnRUaGlja25lc3MgPSAoKSA9PiB2YWx1ZShzcGVjLmdyYWRpZW50VGhpY2tuZXNzLCBjb25maWcuZ3JhZGllbnRUaGlja25lc3MgfHwgY29uZmlnLmdyYWRpZW50SGVpZ2h0KTtcblxuICBfLmVudHJ5Q29sdW1ucyA9ICgpID0+IHZhbHVlKHNwZWMuY29sdW1ucywgdmFsdWUoY29uZmlnLmNvbHVtbnMsICtfLmlzVmVydGljYWwodHJ1ZSkpKTtcblxuICByZXR1cm4gXztcbn1cbmZ1bmN0aW9uIGdldEVuY29kaW5nKG5hbWUsIGVuY29kZSkge1xuICBjb25zdCB2ID0gZW5jb2RlICYmIChlbmNvZGUudXBkYXRlICYmIGVuY29kZS51cGRhdGVbbmFtZV0gfHwgZW5jb2RlLmVudGVyICYmIGVuY29kZS5lbnRlcltuYW1lXSk7XG4gIHJldHVybiB2ICYmIHYuc2lnbmFsID8gdiA6IHYgPyB2LnZhbHVlIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlKG5hbWUsIHNjb3BlLCBzdHlsZSkge1xuICBjb25zdCBzID0gc2NvcGUuY29uZmlnLnN0eWxlW3N0eWxlXTtcbiAgcmV0dXJuIHMgJiYgc1tuYW1lXTtcbn1cbmZ1bmN0aW9uIGFuY2hvckV4cHIocywgZSwgbSkge1xuICByZXR1cm4gYGl0ZW0uYW5jaG9yID09PSAnJHtTdGFydH0nID8gJHtzfSA6IGl0ZW0uYW5jaG9yID09PSAnJHtFbmR9JyA/ICR7ZX0gOiAke219YDtcbn1cbmNvbnN0IGFsaWduRXhwciQxID0gYW5jaG9yRXhwcihzdHJpbmdWYWx1ZShMZWZ0KSwgc3RyaW5nVmFsdWUoUmlnaHQpLCBzdHJpbmdWYWx1ZShDZW50ZXIpKTtcbmZ1bmN0aW9uIHRpY2tCYW5kKF8pIHtcbiAgY29uc3QgdiA9IF8oJ3RpY2tCYW5kJyk7XG5cbiAgbGV0IG9mZnNldCA9IF8oJ3RpY2tPZmZzZXQnKSxcbiAgICAgIGJhbmQsXG4gICAgICBleHRyYTtcblxuICBpZiAoIXYpIHtcbiAgICAvLyBpZiBubyB0aWNrIGJhbmQgZW50cnksIGZhbGwgYmFjayBvbiBvdGhlciBwcm9wZXJ0aWVzXG4gICAgYmFuZCA9IF8oJ2JhbmRQb3NpdGlvbicpO1xuICAgIGV4dHJhID0gXygndGlja0V4dHJhJyk7XG4gIH0gZWxzZSBpZiAodi5zaWduYWwpIHtcbiAgICAvLyBpZiBzaWduYWwsIGF1Z21lbnQgY29kZSB0byBpbnRlcnByZXQgdmFsdWVzXG4gICAgYmFuZCA9IHtcbiAgICAgIHNpZ25hbDogYCgke3Yuc2lnbmFsfSkgPT09ICdleHRlbnQnID8gMSA6IDAuNWBcbiAgICB9O1xuICAgIGV4dHJhID0ge1xuICAgICAgc2lnbmFsOiBgKCR7di5zaWduYWx9KSA9PT0gJ2V4dGVudCdgXG4gICAgfTtcblxuICAgIGlmICghaXNPYmplY3Qob2Zmc2V0KSkge1xuICAgICAgb2Zmc2V0ID0ge1xuICAgICAgICBzaWduYWw6IGAoJHt2LnNpZ25hbH0pID09PSAnZXh0ZW50JyA/IDAgOiAke29mZnNldH1gXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICh2ID09PSAnZXh0ZW50Jykge1xuICAgIC8vIGlmIGNvbnN0YW50LCBzaW1wbHkgc2V0IHZhbHVlc1xuICAgIGJhbmQgPSAxO1xuICAgIGV4dHJhID0gdHJ1ZTtcbiAgICBvZmZzZXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGJhbmQgPSAwLjU7XG4gICAgZXh0cmEgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXh0cmEsXG4gICAgYmFuZCxcbiAgICBvZmZzZXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4dGVuZE9mZnNldCh2YWx1ZSwgb2Zmc2V0KSB7XG4gIHJldHVybiAhb2Zmc2V0ID8gdmFsdWUgOiAhdmFsdWUgPyBvZmZzZXQgOiAhaXNPYmplY3QodmFsdWUpID8ge1xuICAgIHZhbHVlLFxuICAgIG9mZnNldFxuICB9IDogT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUsIHtcbiAgICBvZmZzZXQ6IGV4dGVuZE9mZnNldCh2YWx1ZS5vZmZzZXQsIG9mZnNldClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGd1aWRlTWFyayAobWFyaywgZXh0cmFzKSB7XG4gIGlmIChleHRyYXMpIHtcbiAgICBtYXJrLm5hbWUgPSBleHRyYXMubmFtZTtcbiAgICBtYXJrLnN0eWxlID0gZXh0cmFzLnN0eWxlIHx8IG1hcmsuc3R5bGU7XG4gICAgbWFyay5pbnRlcmFjdGl2ZSA9ICEhZXh0cmFzLmludGVyYWN0aXZlO1xuICAgIG1hcmsuZW5jb2RlID0gZXh0ZW5kRW5jb2RlKG1hcmsuZW5jb2RlLCBleHRyYXMsIFNraXApO1xuICB9IGVsc2Uge1xuICAgIG1hcmsuaW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBtYXJrO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRHcmFkaWVudCAoc3BlYywgc2NhbGUsIGNvbmZpZywgdXNlckVuY29kZSkge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIHZlcnRpY2FsID0gXy5pc1ZlcnRpY2FsKCksXG4gICAgICAgIHRoaWNrbmVzcyA9IF8uZ3JhZGllbnRUaGlja25lc3MoKSxcbiAgICAgICAgbGVuZ3RoID0gXy5ncmFkaWVudExlbmd0aCgpO1xuXG4gIGxldCBlbnRlciwgc3RhcnQsIHN0b3AsIHdpZHRoLCBoZWlnaHQ7XG5cbiAgaWYgKHZlcnRpY2FsKSB7XG4gICAgc3RhcnQgPSBbMCwgMV07XG4gICAgc3RvcCA9IFswLCAwXTtcbiAgICB3aWR0aCA9IHRoaWNrbmVzcztcbiAgICBoZWlnaHQgPSBsZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBbMCwgMF07XG4gICAgc3RvcCA9IFsxLCAwXTtcbiAgICB3aWR0aCA9IGxlbmd0aDtcbiAgICBoZWlnaHQgPSB0aGlja25lc3M7XG4gIH1cblxuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVybyxcbiAgICAgIHg6IHplcm8sXG4gICAgICB5OiB6ZXJvLFxuICAgICAgd2lkdGg6IGVuY29kZXIod2lkdGgpLFxuICAgICAgaGVpZ2h0OiBlbmNvZGVyKGhlaWdodClcbiAgICB9LFxuICAgIHVwZGF0ZTogZXh0ZW5kKHt9LCBlbnRlciwge1xuICAgICAgb3BhY2l0eTogb25lLFxuICAgICAgZmlsbDoge1xuICAgICAgICBncmFkaWVudDogc2NhbGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgc3RvcDogc3RvcFxuICAgICAgfVxuICAgIH0pLFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHN0cm9rZTogXygnZ3JhZGllbnRTdHJva2VDb2xvcicpLFxuICAgIHN0cm9rZVdpZHRoOiBfKCdncmFkaWVudFN0cm9rZVdpZHRoJylcbiAgfSwge1xuICAgIC8vIHVwZGF0ZVxuICAgIG9wYWNpdHk6IF8oJ2dyYWRpZW50T3BhY2l0eScpXG4gIH0pO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBSZWN0TWFyayxcbiAgICByb2xlOiBMZWdlbmRHcmFkaWVudFJvbGUsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRHcmFkaWVudERpc2NyZXRlIChzcGVjLCBzY2FsZSwgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgdmVydGljYWwgPSBfLmlzVmVydGljYWwoKSxcbiAgICAgICAgdGhpY2tuZXNzID0gXy5ncmFkaWVudFRoaWNrbmVzcygpLFxuICAgICAgICBsZW5ndGggPSBfLmdyYWRpZW50TGVuZ3RoKCk7XG5cbiAgbGV0IHUsXG4gICAgICB2LFxuICAgICAgdXUsXG4gICAgICB2dixcbiAgICAgIGFkanVzdCA9ICcnO1xuICB2ZXJ0aWNhbCA/ICh1ID0gJ3knLCB1dSA9ICd5MicsIHYgPSAneCcsIHZ2ID0gJ3dpZHRoJywgYWRqdXN0ID0gJzEtJykgOiAodSA9ICd4JywgdXUgPSAneDInLCB2ID0gJ3knLCB2diA9ICdoZWlnaHQnKTtcbiAgY29uc3QgZW50ZXIgPSB7XG4gICAgb3BhY2l0eTogemVybyxcbiAgICBmaWxsOiB7XG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBmaWVsZDogVmFsdWVcbiAgICB9XG4gIH07XG4gIGVudGVyW3VdID0ge1xuICAgIHNpZ25hbDogYWRqdXN0ICsgJ2RhdHVtLicgKyBQZXJjLFxuICAgIG11bHQ6IGxlbmd0aFxuICB9O1xuICBlbnRlclt2XSA9IHplcm87XG4gIGVudGVyW3V1XSA9IHtcbiAgICBzaWduYWw6IGFkanVzdCArICdkYXR1bS4nICsgUGVyYzIsXG4gICAgbXVsdDogbGVuZ3RoXG4gIH07XG4gIGVudGVyW3Z2XSA9IGVuY29kZXIodGhpY2tuZXNzKTtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiBlbnRlcixcbiAgICB1cGRhdGU6IGV4dGVuZCh7fSwgZW50ZXIsIHtcbiAgICAgIG9wYWNpdHk6IG9uZVxuICAgIH0pLFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHN0cm9rZTogXygnZ3JhZGllbnRTdHJva2VDb2xvcicpLFxuICAgIHN0cm9rZVdpZHRoOiBfKCdncmFkaWVudFN0cm9rZVdpZHRoJylcbiAgfSwge1xuICAgIC8vIHVwZGF0ZVxuICAgIG9wYWNpdHk6IF8oJ2dyYWRpZW50T3BhY2l0eScpXG4gIH0pO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBSZWN0TWFyayxcbiAgICByb2xlOiBMZWdlbmRCYW5kUm9sZSxcbiAgICBrZXk6IFZhbHVlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5jb25zdCBhbGlnbkV4cHIgPSBgZGF0dW0uJHtQZXJjfTw9MD9cIiR7TGVmdH1cIjpkYXR1bS4ke1BlcmN9Pj0xP1wiJHtSaWdodH1cIjpcIiR7Q2VudGVyfVwiYCxcbiAgICAgIGJhc2VsaW5lRXhwciA9IGBkYXR1bS4ke1BlcmN9PD0wP1wiJHtCb3R0b219XCI6ZGF0dW0uJHtQZXJjfT49MT9cIiR7VG9wfVwiOlwiJHtNaWRkbGV9XCJgO1xuZnVuY3Rpb24gbGVnZW5kR3JhZGllbnRMYWJlbHMgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZikge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIHZlcnRpY2FsID0gXy5pc1ZlcnRpY2FsKCksXG4gICAgICAgIHRoaWNrbmVzcyA9IGVuY29kZXIoXy5ncmFkaWVudFRoaWNrbmVzcygpKSxcbiAgICAgICAgbGVuZ3RoID0gXy5ncmFkaWVudExlbmd0aCgpO1xuXG4gIGxldCBvdmVybGFwID0gXygnbGFiZWxPdmVybGFwJyksXG4gICAgICBlbnRlcixcbiAgICAgIHVwZGF0ZSxcbiAgICAgIHUsXG4gICAgICB2LFxuICAgICAgYWRqdXN0ID0gJyc7XG5cbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiBlbnRlciA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9LFxuICAgIHVwZGF0ZTogdXBkYXRlID0ge1xuICAgICAgb3BhY2l0eTogb25lLFxuICAgICAgdGV4dDoge1xuICAgICAgICBmaWVsZDogTGFiZWxcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGZpbGw6IF8oJ2xhYmVsQ29sb3InKSxcbiAgICBmaWxsT3BhY2l0eTogXygnbGFiZWxPcGFjaXR5JyksXG4gICAgZm9udDogXygnbGFiZWxGb250JyksXG4gICAgZm9udFNpemU6IF8oJ2xhYmVsRm9udFNpemUnKSxcbiAgICBmb250U3R5bGU6IF8oJ2xhYmVsRm9udFN0eWxlJyksXG4gICAgZm9udFdlaWdodDogXygnbGFiZWxGb250V2VpZ2h0JyksXG4gICAgbGltaXQ6IHZhbHVlKHNwZWMubGFiZWxMaW1pdCwgY29uZmlnLmdyYWRpZW50TGFiZWxMaW1pdClcbiAgfSk7XG5cbiAgaWYgKHZlcnRpY2FsKSB7XG4gICAgZW50ZXIuYWxpZ24gPSB7XG4gICAgICB2YWx1ZTogJ2xlZnQnXG4gICAgfTtcbiAgICBlbnRlci5iYXNlbGluZSA9IHVwZGF0ZS5iYXNlbGluZSA9IHtcbiAgICAgIHNpZ25hbDogYmFzZWxpbmVFeHByXG4gICAgfTtcbiAgICB1ID0gJ3knO1xuICAgIHYgPSAneCc7XG4gICAgYWRqdXN0ID0gJzEtJztcbiAgfSBlbHNlIHtcbiAgICBlbnRlci5hbGlnbiA9IHVwZGF0ZS5hbGlnbiA9IHtcbiAgICAgIHNpZ25hbDogYWxpZ25FeHByXG4gICAgfTtcbiAgICBlbnRlci5iYXNlbGluZSA9IHtcbiAgICAgIHZhbHVlOiAndG9wJ1xuICAgIH07XG4gICAgdSA9ICd4JztcbiAgICB2ID0gJ3knO1xuICB9XG5cbiAgZW50ZXJbdV0gPSB1cGRhdGVbdV0gPSB7XG4gICAgc2lnbmFsOiBhZGp1c3QgKyAnZGF0dW0uJyArIFBlcmMsXG4gICAgbXVsdDogbGVuZ3RoXG4gIH07XG4gIGVudGVyW3ZdID0gdXBkYXRlW3ZdID0gdGhpY2tuZXNzO1xuICB0aGlja25lc3Mub2Zmc2V0ID0gdmFsdWUoc3BlYy5sYWJlbE9mZnNldCwgY29uZmlnLmdyYWRpZW50TGFiZWxPZmZzZXQpIHx8IDA7XG4gIG92ZXJsYXAgPSBvdmVybGFwID8ge1xuICAgIHNlcGFyYXRpb246IF8oJ2xhYmVsU2VwYXJhdGlvbicpLFxuICAgIG1ldGhvZDogb3ZlcmxhcCxcbiAgICBvcmRlcjogJ2RhdHVtLicgKyBJbmRleFxuICB9IDogdW5kZWZpbmVkOyAvLyB0eXBlLCByb2xlLCBzdHlsZSwga2V5LCBkYXRhUmVmLCBlbmNvZGUsIGV4dHJhc1xuXG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IExlZ2VuZExhYmVsUm9sZSxcbiAgICBzdHlsZTogR3VpZGVMYWJlbFN0eWxlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGUsXG4gICAgb3ZlcmxhcFxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gbGVnZW5kU3ltYm9sR3JvdXBzIChzcGVjLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYsIGNvbHVtbnMpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgICAgICBlbnRyaWVzID0gdXNlckVuY29kZS5lbnRyaWVzLFxuICAgICAgICBpbnRlcmFjdGl2ZSA9ICEhKGVudHJpZXMgJiYgZW50cmllcy5pbnRlcmFjdGl2ZSksXG4gICAgICAgIG5hbWUgPSBlbnRyaWVzID8gZW50cmllcy5uYW1lIDogdW5kZWZpbmVkLFxuICAgICAgICBoZWlnaHQgPSBfKCdjbGlwSGVpZ2h0JyksXG4gICAgICAgIHN5bWJvbE9mZnNldCA9IF8oJ3N5bWJvbE9mZnNldCcpLFxuICAgICAgICB2YWx1ZVJlZiA9IHtcbiAgICBkYXRhOiAndmFsdWUnXG4gIH0sXG4gICAgICAgIHhTaWduYWwgPSBgKCR7Y29sdW1uc30pID8gZGF0dW0uJHtPZmZzZXR9IDogZGF0dW0uJHtTaXplfWAsXG4gICAgICAgIHlFbmNvZGUgPSBoZWlnaHQgPyBlbmNvZGVyKGhlaWdodCkgOiB7XG4gICAgZmllbGQ6IFNpemVcbiAgfSxcbiAgICAgICAgaW5kZXggPSBgZGF0dW0uJHtJbmRleH1gLFxuICAgICAgICBuY29scyA9IGBtYXgoMSwgJHtjb2x1bW5zfSlgO1xuXG4gIGxldCBlbmNvZGUsIGVudGVyLCB1cGRhdGUsIG5yb3dzLCBzb3J0O1xuICB5RW5jb2RlLm11bHQgPSAwLjU7IC8vIC0tIExFR0VORCBTWU1CT0xTIC0tXG5cbiAgZW5jb2RlID0ge1xuICAgIGVudGVyOiBlbnRlciA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm8sXG4gICAgICB4OiB7XG4gICAgICAgIHNpZ25hbDogeFNpZ25hbCxcbiAgICAgICAgbXVsdDogMC41LFxuICAgICAgICBvZmZzZXQ6IHN5bWJvbE9mZnNldFxuICAgICAgfSxcbiAgICAgIHk6IHlFbmNvZGVcbiAgICB9LFxuICAgIHVwZGF0ZTogdXBkYXRlID0ge1xuICAgICAgb3BhY2l0eTogb25lLFxuICAgICAgeDogZW50ZXIueCxcbiAgICAgIHk6IGVudGVyLnlcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGxldCBiYXNlRmlsbCA9IG51bGwsXG4gICAgICBiYXNlU3Ryb2tlID0gbnVsbDtcblxuICBpZiAoIXNwZWMuZmlsbCkge1xuICAgIGJhc2VGaWxsID0gY29uZmlnLnN5bWJvbEJhc2VGaWxsQ29sb3I7XG4gICAgYmFzZVN0cm9rZSA9IGNvbmZpZy5zeW1ib2xCYXNlU3Ryb2tlQ29sb3I7XG4gIH1cblxuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBmaWxsOiBfKCdzeW1ib2xGaWxsQ29sb3InLCBiYXNlRmlsbCksXG4gICAgc2hhcGU6IF8oJ3N5bWJvbFR5cGUnKSxcbiAgICBzaXplOiBfKCdzeW1ib2xTaXplJyksXG4gICAgc3Ryb2tlOiBfKCdzeW1ib2xTdHJva2VDb2xvcicsIGJhc2VTdHJva2UpLFxuICAgIHN0cm9rZURhc2g6IF8oJ3N5bWJvbERhc2gnKSxcbiAgICBzdHJva2VEYXNoT2Zmc2V0OiBfKCdzeW1ib2xEYXNoT2Zmc2V0JyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ3N5bWJvbFN0cm9rZVdpZHRoJylcbiAgfSwge1xuICAgIC8vIHVwZGF0ZVxuICAgIG9wYWNpdHk6IF8oJ3N5bWJvbE9wYWNpdHknKVxuICB9KTtcbiAgTGVnZW5kU2NhbGVzLmZvckVhY2goc2NhbGUgPT4ge1xuICAgIGlmIChzcGVjW3NjYWxlXSkge1xuICAgICAgdXBkYXRlW3NjYWxlXSA9IGVudGVyW3NjYWxlXSA9IHtcbiAgICAgICAgc2NhbGU6IHNwZWNbc2NhbGVdLFxuICAgICAgICBmaWVsZDogVmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3ltYm9scyA9IGd1aWRlTWFyayh7XG4gICAgdHlwZTogU3ltYm9sTWFyayxcbiAgICByb2xlOiBMZWdlbmRTeW1ib2xSb2xlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogdmFsdWVSZWYsXG4gICAgY2xpcDogaGVpZ2h0ID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZS5zeW1ib2xzKTsgLy8gLS0gTEVHRU5EIExBQkVMUyAtLVxuXG4gIGNvbnN0IGxhYmVsT2Zmc2V0ID0gZW5jb2RlcihzeW1ib2xPZmZzZXQpO1xuICBsYWJlbE9mZnNldC5vZmZzZXQgPSBfKCdsYWJlbE9mZnNldCcpO1xuICBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVybyxcbiAgICAgIHg6IHtcbiAgICAgICAgc2lnbmFsOiB4U2lnbmFsLFxuICAgICAgICBvZmZzZXQ6IGxhYmVsT2Zmc2V0XG4gICAgICB9LFxuICAgICAgeTogeUVuY29kZVxuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB0ZXh0OiB7XG4gICAgICAgIGZpZWxkOiBMYWJlbFxuICAgICAgfSxcbiAgICAgIHg6IGVudGVyLngsXG4gICAgICB5OiBlbnRlci55XG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBhbGlnbjogXygnbGFiZWxBbGlnbicpLFxuICAgIGJhc2VsaW5lOiBfKCdsYWJlbEJhc2VsaW5lJyksXG4gICAgZmlsbDogXygnbGFiZWxDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCdsYWJlbE9wYWNpdHknKSxcbiAgICBmb250OiBfKCdsYWJlbEZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnbGFiZWxGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygnbGFiZWxGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdsYWJlbEZvbnRXZWlnaHQnKSxcbiAgICBsaW1pdDogXygnbGFiZWxMaW1pdCcpXG4gIH0pO1xuICBjb25zdCBsYWJlbHMgPSBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IExlZ2VuZExhYmVsUm9sZSxcbiAgICBzdHlsZTogR3VpZGVMYWJlbFN0eWxlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogdmFsdWVSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUubGFiZWxzKTsgLy8gLS0gTEVHRU5EIEVOVFJZIEdST1VQUyAtLVxuXG4gIGVuY29kZSA9IHtcbiAgICBlbnRlcjoge1xuICAgICAgbm9Cb3VuZDoge1xuICAgICAgICB2YWx1ZTogIWhlaWdodFxuICAgICAgfSxcbiAgICAgIC8vIGlnbm9yZSB3aWR0aC9oZWlnaHQgaW4gYm91bmRzIGNhbGNcbiAgICAgIHdpZHRoOiB6ZXJvLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgPyBlbmNvZGVyKGhlaWdodCkgOiB6ZXJvLFxuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICByb3c6IHtcbiAgICAgICAgc2lnbmFsOiBudWxsXG4gICAgICB9LFxuICAgICAgY29sdW1uOiB7XG4gICAgICAgIHNpZ25hbDogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gYW5ub3RhdGUgYW5kIHNvcnQgZ3JvdXBzIHRvIGVuc3VyZSBjb3JyZWN0IG9yZGVyaW5nXG5cbiAgaWYgKF8uaXNWZXJ0aWNhbCh0cnVlKSkge1xuICAgIG5yb3dzID0gYGNlaWwoaXRlbS5tYXJrLml0ZW1zLmxlbmd0aCAvICR7bmNvbHN9KWA7XG4gICAgdXBkYXRlLnJvdy5zaWduYWwgPSBgJHtpbmRleH0lJHtucm93c31gO1xuICAgIHVwZGF0ZS5jb2x1bW4uc2lnbmFsID0gYGZsb29yKCR7aW5kZXh9IC8gJHtucm93c30pYDtcbiAgICBzb3J0ID0ge1xuICAgICAgZmllbGQ6IFsncm93JywgaW5kZXhdXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUucm93LnNpZ25hbCA9IGBmbG9vcigke2luZGV4fSAvICR7bmNvbHN9KWA7XG4gICAgdXBkYXRlLmNvbHVtbi5zaWduYWwgPSBgJHtpbmRleH0gJSAke25jb2xzfWA7XG4gICAgc29ydCA9IHtcbiAgICAgIGZpZWxkOiBpbmRleFxuICAgIH07XG4gIH0gLy8gaGFuZGxlIHplcm8gY29sdW1uIGNhc2UgKGltcGxpZXMgaW5maW5pdGUgY29sdW1ucylcblxuXG4gIHVwZGF0ZS5jb2x1bW4uc2lnbmFsID0gYCgke2NvbHVtbnN9KT8ke3VwZGF0ZS5jb2x1bW4uc2lnbmFsfToke2luZGV4fWA7IC8vIGZhY2V0IGxlZ2VuZCBlbnRyaWVzIGludG8gc3ViLWdyb3Vwc1xuXG4gIGRhdGFSZWYgPSB7XG4gICAgZmFjZXQ6IHtcbiAgICAgIGRhdGE6IGRhdGFSZWYsXG4gICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgZ3JvdXBieTogSW5kZXhcbiAgICB9XG4gIH07XG4gIHJldHVybiBndWlkZUdyb3VwKHtcbiAgICByb2xlOiBTY29wZVJvbGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGU6IGV4dGVuZEVuY29kZShlbmNvZGUsIGVudHJpZXMsIFNraXApLFxuICAgIG1hcmtzOiBbc3ltYm9scywgbGFiZWxzXSxcbiAgICBuYW1lLFxuICAgIGludGVyYWN0aXZlLFxuICAgIHNvcnRcbiAgfSk7XG59XG5mdW5jdGlvbiBsZWdlbmRTeW1ib2xMYXlvdXQoc3BlYywgY29uZmlnKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKTsgLy8gbGF5b3V0IHBhcmFtZXRlcnMgZm9yIGxlZ2VuZCBlbnRyaWVzXG5cblxuICByZXR1cm4ge1xuICAgIGFsaWduOiBfKCdncmlkQWxpZ24nKSxcbiAgICBjb2x1bW5zOiBfLmVudHJ5Q29sdW1ucygpLFxuICAgIGNlbnRlcjoge1xuICAgICAgcm93OiB0cnVlLFxuICAgICAgY29sdW1uOiBmYWxzZVxuICAgIH0sXG4gICAgcGFkZGluZzoge1xuICAgICAgcm93OiBfKCdyb3dQYWRkaW5nJyksXG4gICAgICBjb2x1bW46IF8oJ2NvbHVtblBhZGRpbmcnKVxuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgaXNMID0gJ2l0ZW0ub3JpZW50ID09PSBcImxlZnRcIicsXG4gICAgICBpc1IgPSAnaXRlbS5vcmllbnQgPT09IFwicmlnaHRcIicsXG4gICAgICBpc0xSID0gYCgke2lzTH0gfHwgJHtpc1J9KWAsXG4gICAgICBpc1ZHID0gYGRhdHVtLnZncmFkICYmICR7aXNMUn1gLFxuICAgICAgYmFzZWxpbmUgPSBhbmNob3JFeHByKCdcInRvcFwiJywgJ1wiYm90dG9tXCInLCAnXCJtaWRkbGVcIicpLFxuICAgICAgYWxpZ25GbGlwID0gYW5jaG9yRXhwcignXCJyaWdodFwiJywgJ1wibGVmdFwiJywgJ1wiY2VudGVyXCInKSxcbiAgICAgIGV4cHJBbGlnbiA9IGBkYXR1bS52Z3JhZCAmJiAke2lzUn0gPyAoJHthbGlnbkZsaXB9KSA6ICgke2lzTFJ9ICYmICEoZGF0dW0udmdyYWQgJiYgJHtpc0x9KSkgPyBcImxlZnRcIiA6ICR7YWxpZ25FeHByJDF9YCxcbiAgICAgIGV4cHJBbmNob3IgPSBgaXRlbS5fYW5jaG9yIHx8ICgke2lzTFJ9ID8gXCJtaWRkbGVcIiA6IFwic3RhcnRcIilgLFxuICAgICAgZXhwckFuZ2xlID0gYCR7aXNWR30gPyAoJHtpc0x9ID8gLTkwIDogOTApIDogMGAsXG4gICAgICBleHByQmFzZWxpbmUgPSBgJHtpc0xSfSA/IChkYXR1bS52Z3JhZCA/ICgke2lzUn0gPyBcImJvdHRvbVwiIDogXCJ0b3BcIikgOiAke2Jhc2VsaW5lfSkgOiBcInRvcFwiYDtcbmZ1bmN0aW9uIGxlZ2VuZFRpdGxlIChzcGVjLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpO1xuXG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB4OiB7XG4gICAgICAgIGZpZWxkOiB7XG4gICAgICAgICAgZ3JvdXA6ICdwYWRkaW5nJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBmaWVsZDoge1xuICAgICAgICAgIGdyb3VwOiAncGFkZGluZydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgb3JpZW50OiBfKCd0aXRsZU9yaWVudCcpLFxuICAgIF9hbmNob3I6IF8oJ3RpdGxlQW5jaG9yJyksXG4gICAgYW5jaG9yOiB7XG4gICAgICBzaWduYWw6IGV4cHJBbmNob3JcbiAgICB9LFxuICAgIGFuZ2xlOiB7XG4gICAgICBzaWduYWw6IGV4cHJBbmdsZVxuICAgIH0sXG4gICAgYWxpZ246IHtcbiAgICAgIHNpZ25hbDogZXhwckFsaWduXG4gICAgfSxcbiAgICBiYXNlbGluZToge1xuICAgICAgc2lnbmFsOiBleHByQmFzZWxpbmVcbiAgICB9LFxuICAgIHRleHQ6IHNwZWMudGl0bGUsXG4gICAgZmlsbDogXygndGl0bGVDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCd0aXRsZU9wYWNpdHknKSxcbiAgICBmb250OiBfKCd0aXRsZUZvbnQnKSxcbiAgICBmb250U2l6ZTogXygndGl0bGVGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygndGl0bGVGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCd0aXRsZUZvbnRXZWlnaHQnKSxcbiAgICBsaW1pdDogXygndGl0bGVMaW1pdCcpLFxuICAgIGxpbmVIZWlnaHQ6IF8oJ3RpdGxlTGluZUhlaWdodCcpXG4gIH0sIHtcbiAgICAvLyByZXF1aXJlIHVwZGF0ZVxuICAgIGFsaWduOiBfKCd0aXRsZUFsaWduJyksXG4gICAgYmFzZWxpbmU6IF8oJ3RpdGxlQmFzZWxpbmUnKVxuICB9KTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogTGVnZW5kVGl0bGVSb2xlLFxuICAgIHN0eWxlOiBHdWlkZVRpdGxlU3R5bGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGNsaXAgKGNsaXAsIHNjb3BlKSB7XG4gIGxldCBleHByO1xuXG4gIGlmIChpc09iamVjdChjbGlwKSkge1xuICAgIGlmIChjbGlwLnNpZ25hbCkge1xuICAgICAgZXhwciA9IGNsaXAuc2lnbmFsO1xuICAgIH0gZWxzZSBpZiAoY2xpcC5wYXRoKSB7XG4gICAgICBleHByID0gJ3BhdGhTaGFwZSgnICsgcGFyYW0oY2xpcC5wYXRoKSArICcpJztcbiAgICB9IGVsc2UgaWYgKGNsaXAuc3BoZXJlKSB7XG4gICAgICBleHByID0gJ2dlb1NoYXBlKCcgKyBwYXJhbShjbGlwLnNwaGVyZSkgKyAnLCB7dHlwZTogXCJTcGhlcmVcIn0pJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwciA/IHNjb3BlLnNpZ25hbFJlZihleHByKSA6ICEhY2xpcDtcbn1cblxuZnVuY3Rpb24gcGFyYW0odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5zaWduYWwgPyB2YWx1ZS5zaWduYWwgOiBzdHJpbmdWYWx1ZSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFJvbGUgKHNwZWMpIHtcbiAgY29uc3Qgcm9sZSA9IHNwZWMucm9sZSB8fCAnJztcbiAgcmV0dXJuICFyb2xlLmluZGV4T2YoJ2F4aXMnKSB8fCAhcm9sZS5pbmRleE9mKCdsZWdlbmQnKSB8fCAhcm9sZS5pbmRleE9mKCd0aXRsZScpID8gcm9sZSA6IHNwZWMudHlwZSA9PT0gR3JvdXBNYXJrID8gU2NvcGVSb2xlIDogcm9sZSB8fCBNYXJrUm9sZTtcbn1cblxuZnVuY3Rpb24gZGVmaW5pdGlvbiAoc3BlYykge1xuICByZXR1cm4ge1xuICAgIG1hcmt0eXBlOiBzcGVjLnR5cGUsXG4gICAgbmFtZTogc3BlYy5uYW1lIHx8IHVuZGVmaW5lZCxcbiAgICByb2xlOiBzcGVjLnJvbGUgfHwgZ2V0Um9sZShzcGVjKSxcbiAgICB6aW5kZXg6ICtzcGVjLnppbmRleCB8fCB1bmRlZmluZWQsXG4gICAgYXJpYTogc3BlYy5hcmlhLFxuICAgIGRlc2NyaXB0aW9uOiBzcGVjLmRlc2NyaXB0aW9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGludGVyYWN0aXZlIChzcGVjLCBzY29wZSkge1xuICByZXR1cm4gc3BlYyAmJiBzcGVjLnNpZ25hbCA/IHNjb3BlLnNpZ25hbFJlZihzcGVjLnNpZ25hbCkgOiBzcGVjID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGRhdGEgdHJhbnNmb3JtIHNwZWNpZmljYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm0gKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IGRlZiA9IGRlZmluaXRpb24kMShzcGVjLnR5cGUpO1xuICBpZiAoIWRlZikgZXJyb3IoJ1VucmVjb2duaXplZCB0cmFuc2Zvcm0gdHlwZTogJyArIHN0cmluZ1ZhbHVlKHNwZWMudHlwZSkpO1xuICBjb25zdCB0ID0gZW50cnkoZGVmLnR5cGUudG9Mb3dlckNhc2UoKSwgbnVsbCwgcGFyc2VQYXJhbWV0ZXJzKGRlZiwgc3BlYywgc2NvcGUpKTtcbiAgaWYgKHNwZWMuc2lnbmFsKSBzY29wZS5hZGRTaWduYWwoc3BlYy5zaWduYWwsIHNjb3BlLnByb3h5KHQpKTtcbiAgdC5tZXRhZGF0YSA9IGRlZi5tZXRhZGF0YSB8fCB7fTtcbiAgcmV0dXJuIHQ7XG59XG4vKipcbiAqIFBhcnNlIGFsbCBwYXJhbWV0ZXJzIG9mIGEgZGF0YSB0cmFuc2Zvcm0uXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXJzKGRlZiwgc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgcGFyYW1zID0ge30sXG4gICAgICAgIG4gPSBkZWYucGFyYW1zLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IHBkZWYgPSBkZWYucGFyYW1zW2ldO1xuICAgIHBhcmFtc1twZGVmLm5hbWVdID0gcGFyc2VQYXJhbWV0ZXIocGRlZiwgc3BlYywgc2NvcGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cbi8qKlxuICogUGFyc2UgYSBkYXRhIHRyYW5zZm9ybSBwYXJhbWV0ZXIuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcihkZWYsIHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IHR5cGUgPSBkZWYudHlwZSxcbiAgICAgICAgdmFsdWUgPSBzcGVjW2RlZi5uYW1lXTtcblxuICBpZiAodHlwZSA9PT0gJ2luZGV4Jykge1xuICAgIHJldHVybiBwYXJzZUluZGV4UGFyYW1ldGVyKGRlZiwgc3BlYywgc2NvcGUpO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGVmLnJlcXVpcmVkKSB7XG4gICAgICBlcnJvcignTWlzc2luZyByZXF1aXJlZCAnICsgc3RyaW5nVmFsdWUoc3BlYy50eXBlKSArICcgcGFyYW1ldGVyOiAnICsgc3RyaW5nVmFsdWUoZGVmLm5hbWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3BhcmFtJykge1xuICAgIHJldHVybiBwYXJzZVN1YlBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3Byb2plY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNjb3BlLnByb2plY3Rpb25SZWYoc3BlY1tkZWYubmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRlZi5hcnJheSAmJiAhaXNTaWduYWwodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gcGFyYW1ldGVyVmFsdWUoZGVmLCB2LCBzY29wZSkpIDogcGFyYW1ldGVyVmFsdWUoZGVmLCB2YWx1ZSwgc2NvcGUpO1xufVxuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJWYWx1ZShkZWYsIHZhbHVlLCBzY29wZSkge1xuICBjb25zdCB0eXBlID0gZGVmLnR5cGU7XG5cbiAgaWYgKGlzU2lnbmFsKHZhbHVlKSkge1xuICAgIHJldHVybiBpc0V4cHIodHlwZSkgPyBlcnJvcignRXhwcmVzc2lvbiByZWZlcmVuY2VzIGNhbiBub3QgYmUgc2lnbmFscy4nKSA6IGlzRmllbGQodHlwZSkgPyBzY29wZS5maWVsZFJlZih2YWx1ZSkgOiBpc0NvbXBhcmUodHlwZSkgPyBzY29wZS5jb21wYXJlUmVmKHZhbHVlKSA6IHNjb3BlLnNpZ25hbFJlZih2YWx1ZS5zaWduYWwpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGV4cHIgPSBkZWYuZXhwciB8fCBpc0ZpZWxkKHR5cGUpO1xuICAgIHJldHVybiBleHByICYmIG91dGVyRXhwcih2YWx1ZSkgPyBzY29wZS5leHByUmVmKHZhbHVlLmV4cHIsIHZhbHVlLmFzKSA6IGV4cHIgJiYgb3V0ZXJGaWVsZCh2YWx1ZSkgPyBmaWVsZFJlZiQxKHZhbHVlLmZpZWxkLCB2YWx1ZS5hcykgOiBpc0V4cHIodHlwZSkgPyBwYXJzZUV4cHJlc3Npb24odmFsdWUsIHNjb3BlKSA6IGlzRGF0YSh0eXBlKSA/IHJlZihzY29wZS5nZXREYXRhKHZhbHVlKS52YWx1ZXMpIDogaXNGaWVsZCh0eXBlKSA/IGZpZWxkUmVmJDEodmFsdWUpIDogaXNDb21wYXJlKHR5cGUpID8gc2NvcGUuY29tcGFyZVJlZih2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBQYXJzZSBwYXJhbWV0ZXIgZm9yIGFjY2Vzc2luZyBhbiBpbmRleCBvZiBhbm90aGVyIGRhdGEgc2V0LlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VJbmRleFBhcmFtZXRlcihkZWYsIHNwZWMsIHNjb3BlKSB7XG4gIGlmICghaXNTdHJpbmcoc3BlYy5mcm9tKSkge1xuICAgIGVycm9yKCdMb29rdXAgXCJmcm9tXCIgcGFyYW1ldGVyIG11c3QgYmUgYSBzdHJpbmcgbGl0ZXJhbC4nKTtcbiAgfVxuXG4gIHJldHVybiBzY29wZS5nZXREYXRhKHNwZWMuZnJvbSkubG9va3VwUmVmKHNjb3BlLCBzcGVjLmtleSk7XG59XG4vKipcbiAqIFBhcnNlIGEgcGFyYW1ldGVyIHRoYXQgY29udGFpbnMgb25lIG9yIG1vcmUgc3ViLXBhcmFtZXRlciBvYmplY3RzLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VTdWJQYXJhbWV0ZXJzKGRlZiwgc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgdmFsdWUgPSBzcGVjW2RlZi5uYW1lXTtcblxuICBpZiAoZGVmLmFycmF5KSB7XG4gICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gc2lnbmFscyBub3QgYWxsb3dlZCFcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSBvZiBzdWItcGFyYW1ldGVycy4gSW5zdGVhZDogJyArIHN0cmluZ1ZhbHVlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLm1hcCh2ID0+IHBhcnNlU3ViUGFyYW1ldGVyKGRlZiwgdiwgc2NvcGUpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VTdWJQYXJhbWV0ZXIoZGVmLCB2YWx1ZSwgc2NvcGUpO1xuICB9XG59XG4vKipcbiAqIFBhcnNlIGEgc3ViLXBhcmFtZXRlciBvYmplY3QuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVN1YlBhcmFtZXRlcihkZWYsIHZhbHVlLCBzY29wZSkge1xuICBjb25zdCBuID0gZGVmLnBhcmFtcy5sZW5ndGg7XG4gIGxldCBwZGVmOyAvLyBsb29wIG92ZXIgZGVmcyB0byBmaW5kIG1hdGNoaW5nIGtleVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgcGRlZiA9IGRlZi5wYXJhbXNbaV07XG5cbiAgICBmb3IgKGNvbnN0IGsgaW4gcGRlZi5rZXkpIHtcbiAgICAgIGlmIChwZGVmLmtleVtrXSAhPT0gdmFsdWVba10pIHtcbiAgICAgICAgcGRlZiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwZGVmKSBicmVhaztcbiAgfSAvLyByYWlzZSBlcnJvciBpZiBtYXRjaGluZyBrZXkgbm90IGZvdW5kXG5cblxuICBpZiAoIXBkZWYpIGVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXI6ICcgKyBzdHJpbmdWYWx1ZSh2YWx1ZSkpOyAvLyBwYXJzZSBwYXJhbXMsIGNyZWF0ZSBQYXJhbXMgdHJhbnNmb3JtLCByZXR1cm4gcmVmXG5cbiAgY29uc3QgcGFyYW1zID0gZXh0ZW5kKHBhcnNlUGFyYW1ldGVycyhwZGVmLCB2YWx1ZSwgc2NvcGUpLCBwZGVmLmtleSk7XG4gIHJldHVybiByZWYoc2NvcGUuYWRkKFBhcmFtcyhwYXJhbXMpKSk7XG59IC8vIC0tIFV0aWxpdGllcyAtLS0tLVxuXG5cbmNvbnN0IG91dGVyRXhwciA9IF8gPT4gXyAmJiBfLmV4cHI7XG5jb25zdCBvdXRlckZpZWxkID0gXyA9PiBfICYmIF8uZmllbGQ7XG5jb25zdCBpc0RhdGEgPSBfID0+IF8gPT09ICdkYXRhJztcbmNvbnN0IGlzRXhwciA9IF8gPT4gXyA9PT0gJ2V4cHInO1xuY29uc3QgaXNGaWVsZCA9IF8gPT4gXyA9PT0gJ2ZpZWxkJztcbmNvbnN0IGlzQ29tcGFyZSA9IF8gPT4gXyA9PT0gJ2NvbXBhcmUnO1xuXG5mdW5jdGlvbiBwYXJzZURhdGEkMSAoZnJvbSwgZ3JvdXAsIHNjb3BlKSB7XG4gIGxldCBmYWNldCwga2V5LCBvcCwgZGF0YVJlZiwgcGFyZW50OyAvLyBpZiBubyBzb3VyY2UgZGF0YSwgZ2VuZXJhdGUgc2luZ2xldG9uIGRhdHVtXG5cbiAgaWYgKCFmcm9tKSB7XG4gICAgZGF0YVJlZiA9IHJlZihzY29wZS5hZGQoQ29sbGVjdChudWxsLCBbe31dKSkpO1xuICB9IC8vIGlmIGZhY2V0ZWQsIHByb2Nlc3MgZmFjZXQgc3BlY2lmaWNhdGlvblxuICBlbHNlIGlmIChmYWNldCA9IGZyb20uZmFjZXQpIHtcbiAgICBpZiAoIWdyb3VwKSBlcnJvcignT25seSBncm91cCBtYXJrcyBjYW4gYmUgZmFjZXRlZC4nKTsgLy8gdXNlIHByZS1mYWNldGVkIHNvdXJjZSBkYXRhLCBpZiBhdmFpbGFibGVcblxuICAgIGlmIChmYWNldC5maWVsZCAhPSBudWxsKSB7XG4gICAgICBkYXRhUmVmID0gcGFyZW50ID0gZ2V0RGF0YVJlZihmYWNldCwgc2NvcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZW5lcmF0ZSBmYWNldCBhZ2dyZWdhdGVzIGlmIG5vIGRpcmVjdCBkYXRhIHNwZWNpZmljYXRpb25cbiAgICAgIGlmICghZnJvbS5kYXRhKSB7XG4gICAgICAgIG9wID0gcGFyc2VUcmFuc2Zvcm0oZXh0ZW5kKHtcbiAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICBncm91cGJ5OiBhcnJheShmYWNldC5ncm91cGJ5KVxuICAgICAgICB9LCBmYWNldC5hZ2dyZWdhdGUpLCBzY29wZSk7XG4gICAgICAgIG9wLnBhcmFtcy5rZXkgPSBzY29wZS5rZXlSZWYoZmFjZXQuZ3JvdXBieSk7XG4gICAgICAgIG9wLnBhcmFtcy5wdWxzZSA9IGdldERhdGFSZWYoZmFjZXQsIHNjb3BlKTtcbiAgICAgICAgZGF0YVJlZiA9IHBhcmVudCA9IHJlZihzY29wZS5hZGQob3ApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IHJlZihzY29wZS5nZXREYXRhKGZyb20uZGF0YSkuYWdncmVnYXRlKTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gc2NvcGUua2V5UmVmKGZhY2V0Lmdyb3VwYnksIHRydWUpO1xuICAgIH1cbiAgfSAvLyBpZiBub3QgeWV0IGRlZmluZWQsIGdldCBzb3VyY2UgZGF0YSByZWZlcmVuY2VcblxuXG4gIGlmICghZGF0YVJlZikge1xuICAgIGRhdGFSZWYgPSBnZXREYXRhUmVmKGZyb20sIHNjb3BlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAga2V5OiBrZXksXG4gICAgcHVsc2U6IGRhdGFSZWYsXG4gICAgcGFyZW50OiBwYXJlbnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERhdGFSZWYoZnJvbSwgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb20uJHJlZiA/IGZyb20gOiBmcm9tLmRhdGEgJiYgZnJvbS5kYXRhLiRyZWYgPyBmcm9tLmRhdGEgOiByZWYoc2NvcGUuZ2V0RGF0YShmcm9tLmRhdGEpLm91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIERhdGFTY29wZShzY29wZSwgaW5wdXQsIG91dHB1dCwgdmFsdWVzLCBhZ2dyKSB7XG4gIHRoaXMuc2NvcGUgPSBzY29wZTsgLy8gcGFyZW50IHNjb3BlIG9iamVjdFxuXG4gIHRoaXMuaW5wdXQgPSBpbnB1dDsgLy8gZmlyc3Qgb3BlcmF0b3IgaW4gcGlwZWxpbmUgKHR1cGxlIGlucHV0KVxuXG4gIHRoaXMub3V0cHV0ID0gb3V0cHV0OyAvLyBsYXN0IG9wZXJhdG9yIGluIHBpcGVsaW5lICh0dXBsZSBvdXRwdXQpXG5cbiAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7IC8vIG9wZXJhdG9yIGZvciBhY2Nlc3NpbmcgdHVwbGVzIChidXQgbm90IHR1cGxlIGZsb3cpXG4gIC8vIGxhc3QgYWdncmVnYXRlIGluIHRyYW5zZm9ybSBwaXBlbGluZVxuXG4gIHRoaXMuYWdncmVnYXRlID0gYWdncjsgLy8gbG9va3VwIHRhYmxlIG9mIGZpZWxkIGluZGljZXNcblxuICB0aGlzLmluZGV4ID0ge307XG59XG5cbkRhdGFTY29wZS5mcm9tRW50cmllcyA9IGZ1bmN0aW9uIChzY29wZSwgZW50cmllcykge1xuICBjb25zdCBuID0gZW50cmllcy5sZW5ndGgsXG4gICAgICAgIHZhbHVlcyA9IGVudHJpZXNbbiAtIDFdLFxuICAgICAgICBvdXRwdXQgPSBlbnRyaWVzW24gLSAyXTtcbiAgbGV0IGlucHV0ID0gZW50cmllc1swXSxcbiAgICAgIGFnZ3IgPSBudWxsLFxuICAgICAgaSA9IDE7XG5cbiAgaWYgKGlucHV0ICYmIGlucHV0LnR5cGUgPT09ICdsb2FkJykge1xuICAgIGlucHV0ID0gZW50cmllc1sxXTtcbiAgfSAvLyBhZGQgb3BlcmF0b3IgZW50cmllcyB0byB0aGlzIHNjb3BlLCB3aXJlIHVwIHB1bHNlIGNoYWluXG5cblxuICBzY29wZS5hZGQoZW50cmllc1swXSk7XG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBlbnRyaWVzW2ldLnBhcmFtcy5wdWxzZSA9IHJlZihlbnRyaWVzW2kgLSAxXSk7XG4gICAgc2NvcGUuYWRkKGVudHJpZXNbaV0pO1xuICAgIGlmIChlbnRyaWVzW2ldLnR5cGUgPT09ICdhZ2dyZWdhdGUnKSBhZ2dyID0gZW50cmllc1tpXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0YVNjb3BlKHNjb3BlLCBpbnB1dCwgb3V0cHV0LCB2YWx1ZXMsIGFnZ3IpO1xufTtcblxuZnVuY3Rpb24gZmllbGRLZXkoZmllbGQpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKGZpZWxkKSA/IGZpZWxkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gYWRkU29ydEZpZWxkKHNjb3BlLCBwLCBzb3J0KSB7XG4gIGNvbnN0IGFzID0gYWdnckZpZWxkKHNvcnQub3AsIHNvcnQuZmllbGQpO1xuICBsZXQgcztcblxuICBpZiAocC5vcHMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHAuYXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAocC5hc1tpXSA9PT0gYXMpIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5vcHMgPSBbJ2NvdW50J107XG4gICAgcC5maWVsZHMgPSBbbnVsbF07XG4gICAgcC5hcyA9IFsnY291bnQnXTtcbiAgfVxuXG4gIGlmIChzb3J0Lm9wKSB7XG4gICAgcC5vcHMucHVzaCgocyA9IHNvcnQub3Auc2lnbmFsKSA/IHNjb3BlLnNpZ25hbFJlZihzKSA6IHNvcnQub3ApO1xuICAgIHAuZmllbGRzLnB1c2goc2NvcGUuZmllbGRSZWYoc29ydC5maWVsZCkpO1xuICAgIHAuYXMucHVzaChhcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGUoc2NvcGUsIGRzLCBuYW1lLCBvcHR5cGUsIGZpZWxkLCBjb3VudHMsIGluZGV4KSB7XG4gIGNvbnN0IGNhY2hlID0gZHNbbmFtZV0gfHwgKGRzW25hbWVdID0ge30pLFxuICAgICAgICBzb3J0ID0gc29ydEtleShjb3VudHMpO1xuICBsZXQgayA9IGZpZWxkS2V5KGZpZWxkKSxcbiAgICAgIHYsXG4gICAgICBvcDtcblxuICBpZiAoayAhPSBudWxsKSB7XG4gICAgc2NvcGUgPSBkcy5zY29wZTtcbiAgICBrID0gayArIChzb3J0ID8gJ3wnICsgc29ydCA6ICcnKTtcbiAgICB2ID0gY2FjaGVba107XG4gIH1cblxuICBpZiAoIXYpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBjb3VudHMgPyB7XG4gICAgICBmaWVsZDoga2V5RmllbGRSZWYsXG4gICAgICBwdWxzZTogZHMuY291bnRzUmVmKHNjb3BlLCBmaWVsZCwgY291bnRzKVxuICAgIH0gOiB7XG4gICAgICBmaWVsZDogc2NvcGUuZmllbGRSZWYoZmllbGQpLFxuICAgICAgcHVsc2U6IHJlZihkcy5vdXRwdXQpXG4gICAgfTtcbiAgICBpZiAoc29ydCkgcGFyYW1zLnNvcnQgPSBzY29wZS5zb3J0UmVmKGNvdW50cyk7XG4gICAgb3AgPSBzY29wZS5hZGQoZW50cnkob3B0eXBlLCB1bmRlZmluZWQsIHBhcmFtcykpO1xuICAgIGlmIChpbmRleCkgZHMuaW5kZXhbZmllbGRdID0gb3A7XG4gICAgdiA9IHJlZihvcCk7XG4gICAgaWYgKGsgIT0gbnVsbCkgY2FjaGVba10gPSB2O1xuICB9XG5cbiAgcmV0dXJuIHY7XG59XG5cbkRhdGFTY29wZS5wcm90b3R5cGUgPSB7XG4gIGNvdW50c1JlZihzY29wZSwgZmllbGQsIHNvcnQpIHtcbiAgICBjb25zdCBkcyA9IHRoaXMsXG4gICAgICAgICAgY2FjaGUgPSBkcy5jb3VudHMgfHwgKGRzLmNvdW50cyA9IHt9KSxcbiAgICAgICAgICBrID0gZmllbGRLZXkoZmllbGQpO1xuICAgIGxldCB2LCBhLCBwO1xuXG4gICAgaWYgKGsgIT0gbnVsbCkge1xuICAgICAgc2NvcGUgPSBkcy5zY29wZTtcbiAgICAgIHYgPSBjYWNoZVtrXTtcbiAgICB9XG5cbiAgICBpZiAoIXYpIHtcbiAgICAgIHAgPSB7XG4gICAgICAgIGdyb3VwYnk6IHNjb3BlLmZpZWxkUmVmKGZpZWxkLCAna2V5JyksXG4gICAgICAgIHB1bHNlOiByZWYoZHMub3V0cHV0KVxuICAgICAgfTtcbiAgICAgIGlmIChzb3J0ICYmIHNvcnQuZmllbGQpIGFkZFNvcnRGaWVsZChzY29wZSwgcCwgc29ydCk7XG4gICAgICBhID0gc2NvcGUuYWRkKEFnZ3JlZ2F0ZShwKSk7XG4gICAgICB2ID0gc2NvcGUuYWRkKENvbGxlY3Qoe1xuICAgICAgICBwdWxzZTogcmVmKGEpXG4gICAgICB9KSk7XG4gICAgICB2ID0ge1xuICAgICAgICBhZ2c6IGEsXG4gICAgICAgIHJlZjogcmVmKHYpXG4gICAgICB9O1xuICAgICAgaWYgKGsgIT0gbnVsbCkgY2FjaGVba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoc29ydCAmJiBzb3J0LmZpZWxkKSB7XG4gICAgICBhZGRTb3J0RmllbGQoc2NvcGUsIHYuYWdnLnBhcmFtcywgc29ydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHYucmVmO1xuICB9LFxuXG4gIHR1cGxlc1JlZigpIHtcbiAgICByZXR1cm4gcmVmKHRoaXMudmFsdWVzKTtcbiAgfSxcblxuICBleHRlbnRSZWYoc2NvcGUsIGZpZWxkKSB7XG4gICAgcmV0dXJuIGNhY2hlKHNjb3BlLCB0aGlzLCAnZXh0ZW50JywgJ2V4dGVudCcsIGZpZWxkLCBmYWxzZSk7XG4gIH0sXG5cbiAgZG9tYWluUmVmKHNjb3BlLCBmaWVsZCkge1xuICAgIHJldHVybiBjYWNoZShzY29wZSwgdGhpcywgJ2RvbWFpbicsICd2YWx1ZXMnLCBmaWVsZCwgZmFsc2UpO1xuICB9LFxuXG4gIHZhbHVlc1JlZihzY29wZSwgZmllbGQsIHNvcnQpIHtcbiAgICByZXR1cm4gY2FjaGUoc2NvcGUsIHRoaXMsICd2YWxzJywgJ3ZhbHVlcycsIGZpZWxkLCBzb3J0IHx8IHRydWUpO1xuICB9LFxuXG4gIGxvb2t1cFJlZihzY29wZSwgZmllbGQpIHtcbiAgICByZXR1cm4gY2FjaGUoc2NvcGUsIHRoaXMsICdsb29rdXAnLCAndHVwbGVpbmRleCcsIGZpZWxkLCBmYWxzZSk7XG4gIH0sXG5cbiAgaW5kYXRhUmVmKHNjb3BlLCBmaWVsZCkge1xuICAgIHJldHVybiBjYWNoZShzY29wZSwgdGhpcywgJ2luZGF0YScsICd0dXBsZWluZGV4JywgZmllbGQsIHRydWUsIHRydWUpO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIHBhcnNlRmFjZXQgKHNwZWMsIHNjb3BlLCBncm91cCkge1xuICBjb25zdCBmYWNldCA9IHNwZWMuZnJvbS5mYWNldCxcbiAgICAgICAgbmFtZSA9IGZhY2V0Lm5hbWUsXG4gICAgICAgIGRhdGEgPSBnZXREYXRhUmVmKGZhY2V0LCBzY29wZSk7XG4gIGxldCBvcDtcblxuICBpZiAoIWZhY2V0Lm5hbWUpIHtcbiAgICBlcnJvcignRmFjZXQgbXVzdCBoYXZlIGEgbmFtZTogJyArIHN0cmluZ1ZhbHVlKGZhY2V0KSk7XG4gIH1cblxuICBpZiAoIWZhY2V0LmRhdGEpIHtcbiAgICBlcnJvcignRmFjZXQgbXVzdCByZWZlcmVuY2UgYSBkYXRhIHNldDogJyArIHN0cmluZ1ZhbHVlKGZhY2V0KSk7XG4gIH1cblxuICBpZiAoZmFjZXQuZmllbGQpIHtcbiAgICBvcCA9IHNjb3BlLmFkZChQcmVGYWNldCh7XG4gICAgICBmaWVsZDogc2NvcGUuZmllbGRSZWYoZmFjZXQuZmllbGQpLFxuICAgICAgcHVsc2U6IGRhdGFcbiAgICB9KSk7XG4gIH0gZWxzZSBpZiAoZmFjZXQuZ3JvdXBieSkge1xuICAgIG9wID0gc2NvcGUuYWRkKEZhY2V0KHtcbiAgICAgIGtleTogc2NvcGUua2V5UmVmKGZhY2V0Lmdyb3VwYnkpLFxuICAgICAgZ3JvdXA6IHJlZihzY29wZS5wcm94eShncm91cC5wYXJlbnQpKSxcbiAgICAgIHB1bHNlOiBkYXRhXG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKCdGYWNldCBtdXN0IHNwZWNpZnkgZ3JvdXBieSBvciBmaWVsZDogJyArIHN0cmluZ1ZhbHVlKGZhY2V0KSk7XG4gIH0gLy8gaW5pdGlhbGl6ZSBmYWNldCBzdWJzY29wZVxuXG5cbiAgY29uc3Qgc3Vic2NvcGUgPSBzY29wZS5mb3JrKCksXG4gICAgICAgIHNvdXJjZSA9IHN1YnNjb3BlLmFkZChDb2xsZWN0KCkpLFxuICAgICAgICB2YWx1ZXMgPSBzdWJzY29wZS5hZGQoU2lldmUoe1xuICAgIHB1bHNlOiByZWYoc291cmNlKVxuICB9KSk7XG4gIHN1YnNjb3BlLmFkZERhdGEobmFtZSwgbmV3IERhdGFTY29wZShzdWJzY29wZSwgc291cmNlLCBzb3VyY2UsIHZhbHVlcykpO1xuICBzdWJzY29wZS5hZGRTaWduYWwoJ3BhcmVudCcsIG51bGwpOyAvLyBwYXJzZSBmYWNldGVkIHN1YmZsb3dcblxuICBvcC5wYXJhbXMuc3ViZmxvdyA9IHtcbiAgICAkc3ViZmxvdzogc3Vic2NvcGUucGFyc2Uoc3BlYykudG9SdW50aW1lKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdWJmbG93IChzcGVjLCBzY29wZSwgaW5wdXQpIHtcbiAgY29uc3Qgb3AgPSBzY29wZS5hZGQoUHJlRmFjZXQoe1xuICAgIHB1bHNlOiBpbnB1dC5wdWxzZVxuICB9KSksXG4gICAgICAgIHN1YnNjb3BlID0gc2NvcGUuZm9yaygpO1xuICBzdWJzY29wZS5hZGQoU2lldmUoKSk7XG4gIHN1YnNjb3BlLmFkZFNpZ25hbCgncGFyZW50JywgbnVsbCk7IC8vIHBhcnNlIGdyb3VwIG1hcmsgc3ViZmxvd1xuXG4gIG9wLnBhcmFtcy5zdWJmbG93ID0ge1xuICAgICRzdWJmbG93OiBzdWJzY29wZS5wYXJzZShzcGVjKS50b1J1bnRpbWUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVRyaWdnZXIgKHNwZWMsIHNjb3BlLCBuYW1lKSB7XG4gIGNvbnN0IHJlbW92ZSA9IHNwZWMucmVtb3ZlLFxuICAgICAgICBpbnNlcnQgPSBzcGVjLmluc2VydCxcbiAgICAgICAgdG9nZ2xlID0gc3BlYy50b2dnbGUsXG4gICAgICAgIG1vZGlmeSA9IHNwZWMubW9kaWZ5LFxuICAgICAgICB2YWx1ZXMgPSBzcGVjLnZhbHVlcyxcbiAgICAgICAgb3AgPSBzY29wZS5hZGQob3BlcmF0b3IoKSk7XG4gIGNvbnN0IHVwZGF0ZSA9ICdpZignICsgc3BlYy50cmlnZ2VyICsgJyxtb2RpZnkoXCInICsgbmFtZSArICdcIiwnICsgW2luc2VydCwgcmVtb3ZlLCB0b2dnbGUsIG1vZGlmeSwgdmFsdWVzXS5tYXAoXyA9PiBfID09IG51bGwgPyAnbnVsbCcgOiBfKS5qb2luKCcsJykgKyAnKSwwKSc7XG4gIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHJlc3Npb24odXBkYXRlLCBzY29wZSk7XG4gIG9wLnVwZGF0ZSA9IGV4cHIuJGV4cHI7XG4gIG9wLnBhcmFtcyA9IGV4cHIuJHBhcmFtcztcbn1cblxuZnVuY3Rpb24gcGFyc2VNYXJrIChzcGVjLCBzY29wZSkge1xuICBjb25zdCByb2xlID0gZ2V0Um9sZShzcGVjKSxcbiAgICAgICAgZ3JvdXAgPSBzcGVjLnR5cGUgPT09IEdyb3VwTWFyayxcbiAgICAgICAgZmFjZXQgPSBzcGVjLmZyb20gJiYgc3BlYy5mcm9tLmZhY2V0LFxuICAgICAgICBvdmVybGFwID0gc3BlYy5vdmVybGFwO1xuICBsZXQgbGF5b3V0ID0gc3BlYy5sYXlvdXQgfHwgcm9sZSA9PT0gU2NvcGVSb2xlIHx8IHJvbGUgPT09IEZyYW1lUm9sZSxcbiAgICAgIG9wcyxcbiAgICAgIG9wLFxuICAgICAgc3RvcmUsXG4gICAgICBlbmMsXG4gICAgICBuYW1lLFxuICAgICAgbGF5b3V0UmVmLFxuICAgICAgYm91bmRSZWY7XG4gIGNvbnN0IG5lc3RlZCA9IHJvbGUgPT09IE1hcmtSb2xlIHx8IGxheW91dCB8fCBmYWNldDsgLy8gcmVzb2x2ZSBpbnB1dCBkYXRhXG5cbiAgY29uc3QgaW5wdXQgPSBwYXJzZURhdGEkMShzcGVjLmZyb20sIGdyb3VwLCBzY29wZSk7IC8vIGRhdGEgam9pbiB0byBtYXAgdHVwbGVzIHRvIHZpc3VhbCBpdGVtc1xuXG4gIG9wID0gc2NvcGUuYWRkKERhdGFKb2luKHtcbiAgICBrZXk6IGlucHV0LmtleSB8fCAoc3BlYy5rZXkgPyBmaWVsZFJlZiQxKHNwZWMua2V5KSA6IHVuZGVmaW5lZCksXG4gICAgcHVsc2U6IGlucHV0LnB1bHNlLFxuICAgIGNsZWFuOiAhZ3JvdXBcbiAgfSkpO1xuICBjb25zdCBqb2luUmVmID0gcmVmKG9wKTsgLy8gY29sbGVjdCB2aXN1YWwgaXRlbXNcblxuICBvcCA9IHN0b3JlID0gc2NvcGUuYWRkKENvbGxlY3Qoe1xuICAgIHB1bHNlOiBqb2luUmVmXG4gIH0pKTsgLy8gY29ubmVjdCB2aXN1YWwgaXRlbXMgdG8gc2NlbmVncmFwaFxuXG4gIG9wID0gc2NvcGUuYWRkKE1hcmsoe1xuICAgIG1hcmtkZWY6IGRlZmluaXRpb24oc3BlYyksXG4gICAgaW50ZXJhY3RpdmU6IGludGVyYWN0aXZlKHNwZWMuaW50ZXJhY3RpdmUsIHNjb3BlKSxcbiAgICBjbGlwOiBjbGlwKHNwZWMuY2xpcCwgc2NvcGUpLFxuICAgIGNvbnRleHQ6IHtcbiAgICAgICRjb250ZXh0OiB0cnVlXG4gICAgfSxcbiAgICBncm91cHM6IHNjb3BlLmxvb2t1cCgpLFxuICAgIHBhcmVudDogc2NvcGUuc2lnbmFscy5wYXJlbnQgPyBzY29wZS5zaWduYWxSZWYoJ3BhcmVudCcpIDogbnVsbCxcbiAgICBpbmRleDogc2NvcGUubWFya3BhdGgoKSxcbiAgICBwdWxzZTogcmVmKG9wKVxuICB9KSk7XG4gIGNvbnN0IG1hcmtSZWYgPSByZWYob3ApOyAvLyBhZGQgdmlzdWFsIGVuY29kZXJzXG5cbiAgb3AgPSBlbmMgPSBzY29wZS5hZGQoRW5jb2RlKHBhcnNlRW5jb2RlKHNwZWMuZW5jb2RlLCBzcGVjLnR5cGUsIHJvbGUsIHNwZWMuc3R5bGUsIHNjb3BlLCB7XG4gICAgbW9kOiBmYWxzZSxcbiAgICBwdWxzZTogbWFya1JlZlxuICB9KSkpOyAvLyBtb25pdG9yIHBhcmVudCBtYXJrcyB0byBwcm9wYWdhdGUgY2hhbmdlc1xuXG4gIG9wLnBhcmFtcy5wYXJlbnQgPSBzY29wZS5lbmNvZGUoKTsgLy8gYWRkIHBvc3QtZW5jb2RpbmcgdHJhbnNmb3JtcywgaWYgZGVmaW5lZFxuXG4gIGlmIChzcGVjLnRyYW5zZm9ybSkge1xuICAgIHNwZWMudHJhbnNmb3JtLmZvckVhY2goXyA9PiB7XG4gICAgICBjb25zdCB0eCA9IHBhcnNlVHJhbnNmb3JtKF8sIHNjb3BlKSxcbiAgICAgICAgICAgIG1kID0gdHgubWV0YWRhdGE7XG5cbiAgICAgIGlmIChtZC5nZW5lcmF0ZXMgfHwgbWQuY2hhbmdlcykge1xuICAgICAgICBlcnJvcignTWFyayB0cmFuc2Zvcm1zIHNob3VsZCBub3QgZ2VuZXJhdGUgbmV3IGRhdGEuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWQubm9tb2QpIGVuYy5wYXJhbXMubW9kID0gdHJ1ZTsgLy8gdXBkYXRlIGVuY29kZSBtb2QgaGFuZGxpbmdcblxuICAgICAgdHgucGFyYW1zLnB1bHNlID0gcmVmKG9wKTtcbiAgICAgIHNjb3BlLmFkZChvcCA9IHR4KTtcbiAgICB9KTtcbiAgfSAvLyBpZiBpdGVtIHNvcnQgc3BlY2lmaWVkLCBwZXJmb3JtIHBvc3QtZW5jb2RpbmdcblxuXG4gIGlmIChzcGVjLnNvcnQpIHtcbiAgICBvcCA9IHNjb3BlLmFkZChTb3J0SXRlbXMoe1xuICAgICAgc29ydDogc2NvcGUuY29tcGFyZVJlZihzcGVjLnNvcnQpLFxuICAgICAgcHVsc2U6IHJlZihvcClcbiAgICB9KSk7XG4gIH1cblxuICBjb25zdCBlbmNvZGVSZWYgPSByZWYob3ApOyAvLyBhZGQgdmlldyBsYXlvdXQgb3BlcmF0b3IgaWYgbmVlZGVkXG5cbiAgaWYgKGZhY2V0IHx8IGxheW91dCkge1xuICAgIGxheW91dCA9IHNjb3BlLmFkZChWaWV3TGF5b3V0KHtcbiAgICAgIGxheW91dDogc2NvcGUub2JqZWN0UHJvcGVydHkoc3BlYy5sYXlvdXQpLFxuICAgICAgbGVnZW5kczogc2NvcGUubGVnZW5kcyxcbiAgICAgIG1hcms6IG1hcmtSZWYsXG4gICAgICBwdWxzZTogZW5jb2RlUmVmXG4gICAgfSkpO1xuICAgIGxheW91dFJlZiA9IHJlZihsYXlvdXQpO1xuICB9IC8vIGNvbXB1dGUgYm91bmRpbmcgYm94ZXNcblxuXG4gIGNvbnN0IGJvdW5kID0gc2NvcGUuYWRkKEJvdW5kKHtcbiAgICBtYXJrOiBtYXJrUmVmLFxuICAgIHB1bHNlOiBsYXlvdXRSZWYgfHwgZW5jb2RlUmVmXG4gIH0pKTtcbiAgYm91bmRSZWYgPSByZWYoYm91bmQpOyAvLyBpZiBncm91cCBtYXJrLCByZWN1cnNlIHRvIHBhcnNlIG5lc3RlZCBjb250ZW50XG5cbiAgaWYgKGdyb3VwKSB7XG4gICAgLy8ganVnZ2xlIGxheW91dCAmIGJvdW5kcyB0byBlbnN1cmUgdGhleSBydW4gKmFmdGVyKiBhbnkgZmFjZXRpbmcgdHJhbnNmb3Jtc1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIG9wcyA9IHNjb3BlLm9wZXJhdG9ycztcbiAgICAgIG9wcy5wb3AoKTtcbiAgICAgIGlmIChsYXlvdXQpIG9wcy5wb3AoKTtcbiAgICB9XG5cbiAgICBzY29wZS5wdXNoU3RhdGUoZW5jb2RlUmVmLCBsYXlvdXRSZWYgfHwgYm91bmRSZWYsIGpvaW5SZWYpO1xuICAgIGZhY2V0ID8gcGFyc2VGYWNldChzcGVjLCBzY29wZSwgaW5wdXQpIC8vIGV4cGxpY2l0IGZhY2V0XG4gICAgOiBuZXN0ZWQgPyBwYXJzZVN1YmZsb3coc3BlYywgc2NvcGUsIGlucHV0KSAvLyBzdGFuZGFyZCBtYXJrIGdyb3VwXG4gICAgOiBzY29wZS5wYXJzZShzcGVjKTsgLy8gZ3VpZGUgZ3JvdXAsIHdlIGNhbiBhdm9pZCBuZXN0ZWQgc2NvcGVzXG5cbiAgICBzY29wZS5wb3BTdGF0ZSgpO1xuXG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgaWYgKGxheW91dCkgb3BzLnB1c2gobGF5b3V0KTtcbiAgICAgIG9wcy5wdXNoKGJvdW5kKTtcbiAgICB9XG4gIH0gLy8gaWYgcmVxdWVzdGVkLCBhZGQgb3ZlcmxhcCByZW1vdmFsIHRyYW5zZm9ybVxuXG5cbiAgaWYgKG92ZXJsYXApIHtcbiAgICBib3VuZFJlZiA9IHBhcnNlT3ZlcmxhcChvdmVybGFwLCBib3VuZFJlZiwgc2NvcGUpO1xuICB9IC8vIHJlbmRlciAvIHNpZXZlIGl0ZW1zXG5cblxuICBjb25zdCByZW5kZXIgPSBzY29wZS5hZGQoUmVuZGVyKHtcbiAgICBwdWxzZTogYm91bmRSZWZcbiAgfSkpLFxuICAgICAgICBzaWV2ZSA9IHNjb3BlLmFkZChTaWV2ZSh7XG4gICAgcHVsc2U6IHJlZihyZW5kZXIpXG4gIH0sIHVuZGVmaW5lZCwgc2NvcGUucGFyZW50KCkpKTsgLy8gaWYgbWFyayBpcyBuYW1lZCwgbWFrZSBhY2Nlc3NpYmxlIGFzIHJlYWN0aXZlIGdlb21ldHJ5XG4gIC8vIGFkZCB0cmlnZ2VyIHVwZGF0ZXMgaWYgZGVmaW5lZFxuXG4gIGlmIChzcGVjLm5hbWUgIT0gbnVsbCkge1xuICAgIG5hbWUgPSBzcGVjLm5hbWU7XG4gICAgc2NvcGUuYWRkRGF0YShuYW1lLCBuZXcgRGF0YVNjb3BlKHNjb3BlLCBzdG9yZSwgcmVuZGVyLCBzaWV2ZSkpO1xuICAgIGlmIChzcGVjLm9uKSBzcGVjLm9uLmZvckVhY2gob24gPT4ge1xuICAgICAgaWYgKG9uLmluc2VydCB8fCBvbi5yZW1vdmUgfHwgb24udG9nZ2xlKSB7XG4gICAgICAgIGVycm9yKCdNYXJrcyBvbmx5IHN1cHBvcnQgbW9kaWZ5IHRyaWdnZXJzLicpO1xuICAgICAgfVxuXG4gICAgICBwYXJzZVRyaWdnZXIob24sIHNjb3BlLCBuYW1lKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU92ZXJsYXAob3ZlcmxhcCwgc291cmNlLCBzY29wZSkge1xuICBjb25zdCBtZXRob2QgPSBvdmVybGFwLm1ldGhvZCxcbiAgICAgICAgYm91bmQgPSBvdmVybGFwLmJvdW5kLFxuICAgICAgICBzZXAgPSBvdmVybGFwLnNlcGFyYXRpb247XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICBzZXBhcmF0aW9uOiBpc1NpZ25hbChzZXApID8gc2NvcGUuc2lnbmFsUmVmKHNlcC5zaWduYWwpIDogc2VwLFxuICAgIG1ldGhvZDogaXNTaWduYWwobWV0aG9kKSA/IHNjb3BlLnNpZ25hbFJlZihtZXRob2Quc2lnbmFsKSA6IG1ldGhvZCxcbiAgICBwdWxzZTogc291cmNlXG4gIH07XG5cbiAgaWYgKG92ZXJsYXAub3JkZXIpIHtcbiAgICBwYXJhbXMuc29ydCA9IHNjb3BlLmNvbXBhcmVSZWYoe1xuICAgICAgZmllbGQ6IG92ZXJsYXAub3JkZXJcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChib3VuZCkge1xuICAgIGNvbnN0IHRvbCA9IGJvdW5kLnRvbGVyYW5jZTtcbiAgICBwYXJhbXMuYm91bmRUb2xlcmFuY2UgPSBpc1NpZ25hbCh0b2wpID8gc2NvcGUuc2lnbmFsUmVmKHRvbC5zaWduYWwpIDogK3RvbDtcbiAgICBwYXJhbXMuYm91bmRTY2FsZSA9IHNjb3BlLnNjYWxlUmVmKGJvdW5kLnNjYWxlKTtcbiAgICBwYXJhbXMuYm91bmRPcmllbnQgPSBib3VuZC5vcmllbnQ7XG4gIH1cblxuICByZXR1cm4gcmVmKHNjb3BlLmFkZChPdmVybGFwKHBhcmFtcykpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMZWdlbmQgKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHNjb3BlLmNvbmZpZy5sZWdlbmQsXG4gICAgICAgIGVuY29kZSA9IHNwZWMuZW5jb2RlIHx8IHt9LFxuICAgICAgICBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIGxlZ2VuZEVuY29kZSA9IGVuY29kZS5sZWdlbmQgfHwge30sXG4gICAgICAgIG5hbWUgPSBsZWdlbmRFbmNvZGUubmFtZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGludGVyYWN0aXZlID0gbGVnZW5kRW5jb2RlLmludGVyYWN0aXZlLFxuICAgICAgICBzdHlsZSA9IGxlZ2VuZEVuY29kZS5zdHlsZSxcbiAgICAgICAgc2NhbGVzID0ge307XG5cbiAgbGV0IHNjYWxlID0gMCxcbiAgICAgIGVudHJ5TGF5b3V0LFxuICAgICAgcGFyYW1zLFxuICAgICAgY2hpbGRyZW47IC8vIHJlc29sdmUgc2NhbGVzIGFuZCAnY2Fub25pY2FsJyBzY2FsZSBuYW1lXG5cbiAgTGVnZW5kU2NhbGVzLmZvckVhY2gocyA9PiBzcGVjW3NdID8gKHNjYWxlc1tzXSA9IHNwZWNbc10sIHNjYWxlID0gc2NhbGUgfHwgc3BlY1tzXSkgOiAwKTtcbiAgaWYgKCFzY2FsZSkgZXJyb3IoJ01pc3NpbmcgdmFsaWQgc2NhbGUgZm9yIGxlZ2VuZC4nKTsgLy8gcmVzb2x2ZSBsZWdlbmQgdHlwZSAoc3ltYm9sLCBncmFkaWVudCwgb3IgZGlzY3JldGUgZ3JhZGllbnQpXG5cbiAgY29uc3QgdHlwZSA9IGxlZ2VuZFR5cGUoc3BlYywgc2NvcGUuc2NhbGVUeXBlKHNjYWxlKSk7IC8vIHNpbmdsZS1lbGVtZW50IGRhdGEgc291cmNlIGZvciBsZWdlbmQgZ3JvdXBcblxuICBjb25zdCBkYXR1bSA9IHtcbiAgICB0aXRsZTogc3BlYy50aXRsZSAhPSBudWxsLFxuICAgIHNjYWxlczogc2NhbGVzLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgdmdyYWQ6IHR5cGUgIT09ICdzeW1ib2wnICYmIF8uaXNWZXJ0aWNhbCgpXG4gIH07XG4gIGNvbnN0IGRhdGFSZWYgPSByZWYoc2NvcGUuYWRkKENvbGxlY3QobnVsbCwgW2RhdHVtXSkpKTsgLy8gZW5jb2RpbmcgcHJvcGVydGllcyBmb3IgbGVnZW5kIGVudHJ5IHN1Yi1ncm91cFxuXG4gIGNvbnN0IGVudHJ5RW5jb2RlID0ge1xuICAgIGVudGVyOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB2YWx1ZTogMFxuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gZGF0YSBzb3VyY2UgZm9yIGxlZ2VuZCB2YWx1ZXNcblxuICBjb25zdCBlbnRyeVJlZiA9IHJlZihzY29wZS5hZGQoTGVnZW5kRW50cmllcyhwYXJhbXMgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzY2FsZTogc2NvcGUuc2NhbGVSZWYoc2NhbGUpLFxuICAgIGNvdW50OiBzY29wZS5vYmplY3RQcm9wZXJ0eShfKCd0aWNrQ291bnQnKSksXG4gICAgbGltaXQ6IHNjb3BlLnByb3BlcnR5KF8oJ3N5bWJvbExpbWl0JykpLFxuICAgIHZhbHVlczogc2NvcGUub2JqZWN0UHJvcGVydHkoc3BlYy52YWx1ZXMpLFxuICAgIG1pbnN0ZXA6IHNjb3BlLnByb3BlcnR5KHNwZWMudGlja01pblN0ZXApLFxuICAgIGZvcm1hdFR5cGU6IHNjb3BlLnByb3BlcnR5KHNwZWMuZm9ybWF0VHlwZSksXG4gICAgZm9ybWF0U3BlY2lmaWVyOiBzY29wZS5wcm9wZXJ0eShzcGVjLmZvcm1hdClcbiAgfSkpKTsgLy8gY29udGludW91cyBncmFkaWVudCBsZWdlbmRcblxuICBpZiAodHlwZSA9PT0gR3JhZGllbnQpIHtcbiAgICBjaGlsZHJlbiA9IFtsZWdlbmRHcmFkaWVudChzcGVjLCBzY2FsZSwgY29uZmlnLCBlbmNvZGUuZ3JhZGllbnQpLCBsZWdlbmRHcmFkaWVudExhYmVscyhzcGVjLCBjb25maWcsIGVuY29kZS5sYWJlbHMsIGVudHJ5UmVmKV07IC8vIGFkanVzdCBkZWZhdWx0IHRpY2sgY291bnQgYmFzZWQgb24gdGhlIGdyYWRpZW50IGxlbmd0aFxuXG4gICAgcGFyYW1zLmNvdW50ID0gcGFyYW1zLmNvdW50IHx8IHNjb3BlLnNpZ25hbFJlZihgbWF4KDIsMipmbG9vcigoJHtkZXJlZihfLmdyYWRpZW50TGVuZ3RoKCkpfSkvMTAwKSlgKTtcbiAgfSAvLyBkaXNjcmV0ZSBncmFkaWVudCBsZWdlbmRcbiAgZWxzZSBpZiAodHlwZSA9PT0gRGlzY3JldGUpIHtcbiAgICBjaGlsZHJlbiA9IFtsZWdlbmRHcmFkaWVudERpc2NyZXRlKHNwZWMsIHNjYWxlLCBjb25maWcsIGVuY29kZS5ncmFkaWVudCwgZW50cnlSZWYpLCBsZWdlbmRHcmFkaWVudExhYmVscyhzcGVjLCBjb25maWcsIGVuY29kZS5sYWJlbHMsIGVudHJ5UmVmKV07XG4gIH0gLy8gc3ltYm9sIGxlZ2VuZFxuICBlbHNlIHtcbiAgICAvLyBkZXRlcm1pbmUgbGVnZW5kIHN5bWJvbCBncm91cCBsYXlvdXRcbiAgICBlbnRyeUxheW91dCA9IGxlZ2VuZFN5bWJvbExheW91dChzcGVjLCBjb25maWcpO1xuICAgIGNoaWxkcmVuID0gW2xlZ2VuZFN5bWJvbEdyb3VwcyhzcGVjLCBjb25maWcsIGVuY29kZSwgZW50cnlSZWYsIGRlcmVmKGVudHJ5TGF5b3V0LmNvbHVtbnMpKV07IC8vIHBhc3Mgc3ltYm9sIHNpemUgaW5mb3JtYXRpb24gdG8gbGVnZW5kIGVudHJ5IGdlbmVyYXRvclxuXG4gICAgcGFyYW1zLnNpemUgPSBzaXplRXhwcmVzc2lvbihzcGVjLCBzY29wZSwgY2hpbGRyZW5bMF0ubWFya3MpO1xuICB9IC8vIGdlbmVyYXRlIGxlZ2VuZCBtYXJrc1xuXG5cbiAgY2hpbGRyZW4gPSBbZ3VpZGVHcm91cCh7XG4gICAgcm9sZTogTGVnZW5kRW50cnlSb2xlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlOiBlbnRyeUVuY29kZSxcbiAgICBtYXJrczogY2hpbGRyZW4sXG4gICAgbGF5b3V0OiBlbnRyeUxheW91dCxcbiAgICBpbnRlcmFjdGl2ZVxuICB9KV07IC8vIGluY2x1ZGUgbGVnZW5kIHRpdGxlIGlmIGRlZmluZWRcblxuICBpZiAoZGF0dW0udGl0bGUpIHtcbiAgICBjaGlsZHJlbi5wdXNoKGxlZ2VuZFRpdGxlKHNwZWMsIGNvbmZpZywgZW5jb2RlLnRpdGxlLCBkYXRhUmVmKSk7XG4gIH0gLy8gcGFyc2UgbGVnZW5kIHNwZWNpZmljYXRpb25cblxuXG4gIHJldHVybiBwYXJzZU1hcmsoZ3VpZGVHcm91cCh7XG4gICAgcm9sZTogTGVnZW5kUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZXh0ZW5kRW5jb2RlKGJ1aWxkTGVnZW5kRW5jb2RlKF8sIHNwZWMsIGNvbmZpZyksIGxlZ2VuZEVuY29kZSwgU2tpcCksXG4gICAgbWFya3M6IGNoaWxkcmVuLFxuICAgIGFyaWE6IF8oJ2FyaWEnKSxcbiAgICBkZXNjcmlwdGlvbjogXygnZGVzY3JpcHRpb24nKSxcbiAgICB6aW5kZXg6IF8oJ3ppbmRleCcpLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc3R5bGVcbiAgfSksIHNjb3BlKTtcbn1cblxuZnVuY3Rpb24gbGVnZW5kVHlwZShzcGVjLCBzY2FsZVR5cGUpIHtcbiAgbGV0IHR5cGUgPSBzcGVjLnR5cGUgfHwgU3ltYm9scztcblxuICBpZiAoIXNwZWMudHlwZSAmJiBzY2FsZUNvdW50KHNwZWMpID09PSAxICYmIChzcGVjLmZpbGwgfHwgc3BlYy5zdHJva2UpKSB7XG4gICAgdHlwZSA9IGlzQ29udGludW91cyhzY2FsZVR5cGUpID8gR3JhZGllbnQgOiBpc0Rpc2NyZXRpemluZyhzY2FsZVR5cGUpID8gRGlzY3JldGUgOiBTeW1ib2xzO1xuICB9XG5cbiAgcmV0dXJuIHR5cGUgIT09IEdyYWRpZW50ID8gdHlwZSA6IGlzRGlzY3JldGl6aW5nKHNjYWxlVHlwZSkgPyBEaXNjcmV0ZSA6IEdyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBzY2FsZUNvdW50KHNwZWMpIHtcbiAgcmV0dXJuIExlZ2VuZFNjYWxlcy5yZWR1Y2UoKGNvdW50LCB0eXBlKSA9PiBjb3VudCArIChzcGVjW3R5cGVdID8gMSA6IDApLCAwKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRMZWdlbmRFbmNvZGUoXywgc3BlYywgY29uZmlnKSB7XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjoge30sXG4gICAgdXBkYXRlOiB7fVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBvcmllbnQ6IF8oJ29yaWVudCcpLFxuICAgIG9mZnNldDogXygnb2Zmc2V0JyksXG4gICAgcGFkZGluZzogXygncGFkZGluZycpLFxuICAgIHRpdGxlUGFkZGluZzogXygndGl0bGVQYWRkaW5nJyksXG4gICAgY29ybmVyUmFkaXVzOiBfKCdjb3JuZXJSYWRpdXMnKSxcbiAgICBmaWxsOiBfKCdmaWxsQ29sb3InKSxcbiAgICBzdHJva2U6IF8oJ3N0cm9rZUNvbG9yJyksXG4gICAgc3Ryb2tlV2lkdGg6IGNvbmZpZy5zdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoOiBjb25maWcuc3Ryb2tlRGFzaCxcbiAgICB4OiBfKCdsZWdlbmRYJyksXG4gICAgeTogXygnbGVnZW5kWScpLFxuICAgIC8vIGFjY2Vzc2liaWxpdHkgc3VwcG9ydFxuICAgIGZvcm1hdDogc3BlYy5mb3JtYXQsXG4gICAgZm9ybWF0VHlwZTogc3BlYy5mb3JtYXRUeXBlXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlO1xufVxuXG5mdW5jdGlvbiBzaXplRXhwcmVzc2lvbihzcGVjLCBzY29wZSwgbWFya3MpIHtcbiAgY29uc3Qgc2l6ZSA9IGRlcmVmKGdldENoYW5uZWwoJ3NpemUnLCBzcGVjLCBtYXJrcykpLFxuICAgICAgICBzdHJva2VXaWR0aCA9IGRlcmVmKGdldENoYW5uZWwoJ3N0cm9rZVdpZHRoJywgc3BlYywgbWFya3MpKSxcbiAgICAgICAgZm9udFNpemUgPSBkZXJlZihnZXRGb250U2l6ZShtYXJrc1sxXS5lbmNvZGUsIHNjb3BlLCBHdWlkZUxhYmVsU3R5bGUpKTtcbiAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbihgbWF4KGNlaWwoc3FydCgke3NpemV9KSske3N0cm9rZVdpZHRofSksJHtmb250U2l6ZX0pYCwgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFubmVsKG5hbWUsIHNwZWMsIG1hcmtzKSB7XG4gIHJldHVybiBzcGVjW25hbWVdID8gYHNjYWxlKFwiJHtzcGVjW25hbWVdfVwiLGRhdHVtKWAgOiBnZXRFbmNvZGluZyhuYW1lLCBtYXJrc1swXS5lbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRGb250U2l6ZShlbmNvZGUsIHNjb3BlLCBzdHlsZSkge1xuICByZXR1cm4gZ2V0RW5jb2RpbmcoJ2ZvbnRTaXplJywgZW5jb2RlKSB8fCBnZXRTdHlsZSgnZm9udFNpemUnLCBzY29wZSwgc3R5bGUpO1xufVxuXG5jb25zdCBhbmdsZUV4cHIgPSBgaXRlbS5vcmllbnQ9PT1cIiR7TGVmdH1cIj8tOTA6aXRlbS5vcmllbnQ9PT1cIiR7UmlnaHR9XCI/OTA6MGA7XG5mdW5jdGlvbiBwYXJzZVRpdGxlIChzcGVjLCBzY29wZSkge1xuICBzcGVjID0gaXNTdHJpbmcoc3BlYykgPyB7XG4gICAgdGV4dDogc3BlY1xuICB9IDogc3BlYztcblxuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIHNjb3BlLmNvbmZpZy50aXRsZSksXG4gICAgICAgIGVuY29kZSA9IHNwZWMuZW5jb2RlIHx8IHt9LFxuICAgICAgICB1c2VyRW5jb2RlID0gZW5jb2RlLmdyb3VwIHx8IHt9LFxuICAgICAgICBuYW1lID0gdXNlckVuY29kZS5uYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgaW50ZXJhY3RpdmUgPSB1c2VyRW5jb2RlLmludGVyYWN0aXZlLFxuICAgICAgICBzdHlsZSA9IHVzZXJFbmNvZGUuc3R5bGUsXG4gICAgICAgIGNoaWxkcmVuID0gW107IC8vIHNpbmdsZS1lbGVtZW50IGRhdGEgc291cmNlIGZvciBncm91cCB0aXRsZVxuXG5cbiAgY29uc3QgZGF0dW0gPSB7fSxcbiAgICAgICAgZGF0YVJlZiA9IHJlZihzY29wZS5hZGQoQ29sbGVjdChudWxsLCBbZGF0dW1dKSkpOyAvLyBpbmNsdWRlIHRpdGxlIHRleHRcblxuICBjaGlsZHJlbi5wdXNoKGJ1aWxkVGl0bGUoc3BlYywgXywgdGl0bGVFbmNvZGUoc3BlYyksIGRhdGFSZWYpKTsgLy8gaW5jbHVkZSBzdWJ0aXRsZSB0ZXh0XG5cbiAgaWYgKHNwZWMuc3VidGl0bGUpIHtcbiAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkU3ViVGl0bGUoc3BlYywgXywgZW5jb2RlLnN1YnRpdGxlLCBkYXRhUmVmKSk7XG4gIH0gLy8gcGFyc2UgdGl0bGUgc3BlY2lmaWNhdGlvblxuXG5cbiAgcmV0dXJuIHBhcnNlTWFyayhndWlkZUdyb3VwKHtcbiAgICByb2xlOiBUaXRsZVJvbGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGU6IGdyb3VwRW5jb2RlKF8sIHVzZXJFbmNvZGUpLFxuICAgIG1hcmtzOiBjaGlsZHJlbixcbiAgICBhcmlhOiBfKCdhcmlhJyksXG4gICAgZGVzY3JpcHRpb246IF8oJ2Rlc2NyaXB0aW9uJyksXG4gICAgemluZGV4OiBfKCd6aW5kZXgnKSxcbiAgICBuYW1lLFxuICAgIGludGVyYWN0aXZlLFxuICAgIHN0eWxlXG4gIH0pLCBzY29wZSk7XG59IC8vIHByb3ZpZGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRpdGxlIGN1c3RvbSBlbmNvZGU7XG4vLyB0aGUgdG9wLWxldmVsIGVuY29kZSBibG9jayBoYXMgYmVlbiAqZGVwcmVjYXRlZCouXG5cbmZ1bmN0aW9uIHRpdGxlRW5jb2RlKHNwZWMpIHtcbiAgY29uc3QgZW5jb2RlID0gc3BlYy5lbmNvZGU7XG4gIHJldHVybiBlbmNvZGUgJiYgZW5jb2RlLnRpdGxlIHx8IGV4dGVuZCh7XG4gICAgbmFtZTogc3BlYy5uYW1lLFxuICAgIGludGVyYWN0aXZlOiBzcGVjLmludGVyYWN0aXZlLFxuICAgIHN0eWxlOiBzcGVjLnN0eWxlXG4gIH0sIGVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwRW5jb2RlKF8sIHVzZXJFbmNvZGUpIHtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7fSxcbiAgICB1cGRhdGU6IHt9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIG9yaWVudDogXygnb3JpZW50JyksXG4gICAgYW5jaG9yOiBfKCdhbmNob3InKSxcbiAgICBhbGlnbjoge1xuICAgICAgc2lnbmFsOiBhbGlnbkV4cHIkMVxuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgIHNpZ25hbDogYW5nbGVFeHByXG4gICAgfSxcbiAgICBsaW1pdDogXygnbGltaXQnKSxcbiAgICBmcmFtZTogXygnZnJhbWUnKSxcbiAgICBvZmZzZXQ6IF8oJ29mZnNldCcpIHx8IDAsXG4gICAgcGFkZGluZzogXygnc3VidGl0bGVQYWRkaW5nJylcbiAgfSk7XG4gIHJldHVybiBleHRlbmRFbmNvZGUoZW5jb2RlLCB1c2VyRW5jb2RlLCBTa2lwKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRUaXRsZShzcGVjLCBfLCB1c2VyRW5jb2RlLCBkYXRhUmVmKSB7XG4gIGNvbnN0IHplcm8gPSB7XG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgICAgICAgdGV4dCA9IHNwZWMudGV4dCxcbiAgICAgICAgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHtcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgdmFsdWU6IDFcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHRleHQ6IHRleHQsXG4gICAgYWxpZ246IHtcbiAgICAgIHNpZ25hbDogJ2l0ZW0ubWFyay5ncm91cC5hbGlnbidcbiAgICB9LFxuICAgIGFuZ2xlOiB7XG4gICAgICBzaWduYWw6ICdpdGVtLm1hcmsuZ3JvdXAuYW5nbGUnXG4gICAgfSxcbiAgICBsaW1pdDoge1xuICAgICAgc2lnbmFsOiAnaXRlbS5tYXJrLmdyb3VwLmxpbWl0J1xuICAgIH0sXG4gICAgYmFzZWxpbmU6ICd0b3AnLFxuICAgIGR4OiBfKCdkeCcpLFxuICAgIGR5OiBfKCdkeScpLFxuICAgIGZpbGw6IF8oJ2NvbG9yJyksXG4gICAgZm9udDogXygnZm9udCcpLFxuICAgIGZvbnRTaXplOiBfKCdmb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygnZm9udFN0eWxlJyksXG4gICAgZm9udFdlaWdodDogXygnZm9udFdlaWdodCcpLFxuICAgIGxpbmVIZWlnaHQ6IF8oJ2xpbmVIZWlnaHQnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgYWxpZ246IF8oJ2FsaWduJyksXG4gICAgYW5nbGU6IF8oJ2FuZ2xlJyksXG4gICAgYmFzZWxpbmU6IF8oJ2Jhc2VsaW5lJylcbiAgfSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IFRpdGxlVGV4dFJvbGUsXG4gICAgc3R5bGU6IEdyb3VwVGl0bGVTdHlsZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTdWJUaXRsZShzcGVjLCBfLCB1c2VyRW5jb2RlLCBkYXRhUmVmKSB7XG4gIGNvbnN0IHplcm8gPSB7XG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgICAgICAgdGV4dCA9IHNwZWMuc3VidGl0bGUsXG4gICAgICAgIGVuY29kZSA9IHtcbiAgICBlbnRlcjoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB7XG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIHZhbHVlOiAxXG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIGFsaWduOiB7XG4gICAgICBzaWduYWw6ICdpdGVtLm1hcmsuZ3JvdXAuYWxpZ24nXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgc2lnbmFsOiAnaXRlbS5tYXJrLmdyb3VwLmFuZ2xlJ1xuICAgIH0sXG4gICAgbGltaXQ6IHtcbiAgICAgIHNpZ25hbDogJ2l0ZW0ubWFyay5ncm91cC5saW1pdCdcbiAgICB9LFxuICAgIGJhc2VsaW5lOiAndG9wJyxcbiAgICBkeDogXygnZHgnKSxcbiAgICBkeTogXygnZHknKSxcbiAgICBmaWxsOiBfKCdzdWJ0aXRsZUNvbG9yJyksXG4gICAgZm9udDogXygnc3VidGl0bGVGb250JyksXG4gICAgZm9udFNpemU6IF8oJ3N1YnRpdGxlRm9udFNpemUnKSxcbiAgICBmb250U3R5bGU6IF8oJ3N1YnRpdGxlRm9udFN0eWxlJyksXG4gICAgZm9udFdlaWdodDogXygnc3VidGl0bGVGb250V2VpZ2h0JyksXG4gICAgbGluZUhlaWdodDogXygnc3VidGl0bGVMaW5lSGVpZ2h0JylcbiAgfSwge1xuICAgIC8vIHVwZGF0ZVxuICAgIGFsaWduOiBfKCdhbGlnbicpLFxuICAgIGFuZ2xlOiBfKCdhbmdsZScpLFxuICAgIGJhc2VsaW5lOiBfKCdiYXNlbGluZScpXG4gIH0pO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBUZXh0TWFyayxcbiAgICByb2xlOiBUaXRsZVN1YnRpdGxlUm9sZSxcbiAgICBzdHlsZTogR3JvdXBTdWJ0aXRsZVN0eWxlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZURhdGEoZGF0YSwgc2NvcGUpIHtcbiAgY29uc3QgdHJhbnNmb3JtcyA9IFtdO1xuXG4gIGlmIChkYXRhLnRyYW5zZm9ybSkge1xuICAgIGRhdGEudHJhbnNmb3JtLmZvckVhY2godHggPT4ge1xuICAgICAgdHJhbnNmb3Jtcy5wdXNoKHBhcnNlVHJhbnNmb3JtKHR4LCBzY29wZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGRhdGEub24pIHtcbiAgICBkYXRhLm9uLmZvckVhY2gob24gPT4ge1xuICAgICAgcGFyc2VUcmlnZ2VyKG9uLCBzY29wZSwgZGF0YS5uYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNjb3BlLmFkZERhdGFQaXBlbGluZShkYXRhLm5hbWUsIGFuYWx5emUoZGF0YSwgc2NvcGUsIHRyYW5zZm9ybXMpKTtcbn1cbi8qKlxuICogQW5hbHl6ZSBhIGRhdGEgcGlwZWxpbmUsIGFkZCBuZWVkZWQgb3BlcmF0b3JzLlxuICovXG5cbmZ1bmN0aW9uIGFuYWx5emUoZGF0YSwgc2NvcGUsIG9wcykge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgbGV0IHNvdXJjZSA9IG51bGwsXG4gICAgICBtb2RpZnkgPSBmYWxzZSxcbiAgICAgIGdlbmVyYXRlID0gZmFsc2UsXG4gICAgICB1cHN0cmVhbSxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgdCxcbiAgICAgIG07XG5cbiAgaWYgKGRhdGEudmFsdWVzKSB7XG4gICAgLy8gaGFyZC13aXJlZCBpbnB1dCBkYXRhIHNldFxuICAgIGlmIChpc1NpZ25hbChkYXRhLnZhbHVlcykgfHwgaGFzU2lnbmFsKGRhdGEuZm9ybWF0KSkge1xuICAgICAgLy8gaWYgZWl0aGVyIHZhbHVlcyBpcyBzaWduYWwgb3IgZm9ybWF0IGhhcyBzaWduYWwsIHVzZSBkeW5hbWljIGxvYWRlclxuICAgICAgb3V0cHV0LnB1c2gobG9hZChzY29wZSwgZGF0YSkpO1xuICAgICAgb3V0cHV0LnB1c2goc291cmNlID0gY29sbGVjdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlLCBpbmdlc3QgdXBvbiBkYXRhZmxvdyBpbml0XG4gICAgICBvdXRwdXQucHVzaChzb3VyY2UgPSBjb2xsZWN0KHtcbiAgICAgICAgJGluZ2VzdDogZGF0YS52YWx1ZXMsXG4gICAgICAgICRmb3JtYXQ6IGRhdGEuZm9ybWF0XG4gICAgICB9KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEudXJsKSB7XG4gICAgLy8gbG9hZCBkYXRhIGZyb20gZXh0ZXJuYWwgc291cmNlXG4gICAgaWYgKGhhc1NpZ25hbChkYXRhLnVybCkgfHwgaGFzU2lnbmFsKGRhdGEuZm9ybWF0KSkge1xuICAgICAgLy8gaWYgZWl0aGVyIHVybCBvciBmb3JtYXQgaGFzIHNpZ25hbCwgdXNlIGR5bmFtaWMgbG9hZGVyXG4gICAgICBvdXRwdXQucHVzaChsb2FkKHNjb3BlLCBkYXRhKSk7XG4gICAgICBvdXRwdXQucHVzaChzb3VyY2UgPSBjb2xsZWN0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIHJlcXVlc3QgbG9hZCB1cG9uIGRhdGFmbG93IGluaXRcbiAgICAgIG91dHB1dC5wdXNoKHNvdXJjZSA9IGNvbGxlY3Qoe1xuICAgICAgICAkcmVxdWVzdDogZGF0YS51cmwsXG4gICAgICAgICRmb3JtYXQ6IGRhdGEuZm9ybWF0XG4gICAgICB9KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEuc291cmNlKSB7XG4gICAgLy8gZGVyaXZlcyBmcm9tIG9uZSBvciBtb3JlIG90aGVyIGRhdGEgc2V0c1xuICAgIHNvdXJjZSA9IHVwc3RyZWFtID0gYXJyYXkoZGF0YS5zb3VyY2UpLm1hcChkID0+IHJlZihzY29wZS5nZXREYXRhKGQpLm91dHB1dCkpO1xuICAgIG91dHB1dC5wdXNoKG51bGwpOyAvLyBwb3B1bGF0ZSBsYXRlclxuICB9IC8vIHNjYW4gZGF0YSB0cmFuc2Zvcm1zLCBhZGQgY29sbGVjdG9ycyBhcyBuZWVkZWRcblxuXG4gIGZvciAoaSA9IDAsIG4gPSBvcHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgdCA9IG9wc1tpXTtcbiAgICBtID0gdC5tZXRhZGF0YTtcblxuICAgIGlmICghc291cmNlICYmICFtLnNvdXJjZSkge1xuICAgICAgb3V0cHV0LnB1c2goc291cmNlID0gY29sbGVjdCgpKTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHVzaCh0KTtcbiAgICBpZiAobS5nZW5lcmF0ZXMpIGdlbmVyYXRlID0gdHJ1ZTtcbiAgICBpZiAobS5tb2RpZmllcyAmJiAhZ2VuZXJhdGUpIG1vZGlmeSA9IHRydWU7XG4gICAgaWYgKG0uc291cmNlKSBzb3VyY2UgPSB0O2Vsc2UgaWYgKG0uY2hhbmdlcykgc291cmNlID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cHN0cmVhbSkge1xuICAgIG4gPSB1cHN0cmVhbS5sZW5ndGggLSAxO1xuICAgIG91dHB1dFswXSA9IFJlbGF5KHtcbiAgICAgIGRlcml2ZTogbW9kaWZ5LFxuICAgICAgcHVsc2U6IG4gPyB1cHN0cmVhbSA6IHVwc3RyZWFtWzBdXG4gICAgfSk7XG5cbiAgICBpZiAobW9kaWZ5IHx8IG4pIHtcbiAgICAgIC8vIGNvbGxlY3QgZGVyaXZlZCBhbmQgbXVsdGktcHVsc2UgdHVwbGVzXG4gICAgICBvdXRwdXQuc3BsaWNlKDEsIDAsIGNvbGxlY3QoKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzb3VyY2UpIG91dHB1dC5wdXNoKGNvbGxlY3QoKSk7XG4gIG91dHB1dC5wdXNoKFNpZXZlKHt9KSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3QodmFsdWVzKSB7XG4gIGNvbnN0IHMgPSBDb2xsZWN0KHt9LCB2YWx1ZXMpO1xuICBzLm1ldGFkYXRhID0ge1xuICAgIHNvdXJjZTogdHJ1ZVxuICB9O1xuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gbG9hZChzY29wZSwgZGF0YSkge1xuICByZXR1cm4gTG9hZCh7XG4gICAgdXJsOiBkYXRhLnVybCA/IHNjb3BlLnByb3BlcnR5KGRhdGEudXJsKSA6IHVuZGVmaW5lZCxcbiAgICBhc3luYzogZGF0YS5hc3luYyA/IHNjb3BlLnByb3BlcnR5KGRhdGEuYXN5bmMpIDogdW5kZWZpbmVkLFxuICAgIHZhbHVlczogZGF0YS52YWx1ZXMgPyBzY29wZS5wcm9wZXJ0eShkYXRhLnZhbHVlcykgOiB1bmRlZmluZWQsXG4gICAgZm9ybWF0OiBzY29wZS5vYmplY3RQcm9wZXJ0eShkYXRhLmZvcm1hdClcbiAgfSk7XG59XG5cbmNvbnN0IGlzWCA9IG9yaWVudCA9PiBvcmllbnQgPT09IEJvdHRvbSB8fCBvcmllbnQgPT09IFRvcDsgLy8gZ2V0IHNpZ24gY29lZmZpY2llbnQgYmFzZWQgb24gYXhpcyBvcmllbnRcblxuXG5jb25zdCBnZXRTaWduID0gKG9yaWVudCwgYSwgYikgPT4gaXNTaWduYWwob3JpZW50KSA/IGlmTGVmdFRvcEV4cHIob3JpZW50LnNpZ25hbCwgYSwgYikgOiBvcmllbnQgPT09IExlZnQgfHwgb3JpZW50ID09PSBUb3AgPyBhIDogYjsgLy8gY29uZGl0aW9uIG9uIGF4aXMgeC1kaXJlY3Rpb25cblxuY29uc3QgaWZYID0gKG9yaWVudCwgYSwgYikgPT4gaXNTaWduYWwob3JpZW50KSA/IGlmWEVuYyhvcmllbnQuc2lnbmFsLCBhLCBiKSA6IGlzWChvcmllbnQpID8gYSA6IGI7IC8vIGNvbmRpdGlvbiBvbiBheGlzIHktZGlyZWN0aW9uXG5cbmNvbnN0IGlmWSA9IChvcmllbnQsIGEsIGIpID0+IGlzU2lnbmFsKG9yaWVudCkgPyBpZllFbmMob3JpZW50LnNpZ25hbCwgYSwgYikgOiBpc1gob3JpZW50KSA/IGIgOiBhO1xuY29uc3QgaWZUb3AgPSAob3JpZW50LCBhLCBiKSA9PiBpc1NpZ25hbChvcmllbnQpID8gaWZUb3BFeHByKG9yaWVudC5zaWduYWwsIGEsIGIpIDogb3JpZW50ID09PSBUb3AgPyB7XG4gIHZhbHVlOiBhXG59IDoge1xuICB2YWx1ZTogYlxufTtcbmNvbnN0IGlmUmlnaHQgPSAob3JpZW50LCBhLCBiKSA9PiBpc1NpZ25hbChvcmllbnQpID8gaWZSaWdodEV4cHIob3JpZW50LnNpZ25hbCwgYSwgYikgOiBvcmllbnQgPT09IFJpZ2h0ID8ge1xuICB2YWx1ZTogYVxufSA6IHtcbiAgdmFsdWU6IGJcbn07XG5cbmNvbnN0IGlmWEVuYyA9ICgkb3JpZW50LCBhLCBiKSA9PiBpZkVuYyhgJHskb3JpZW50fSA9PT0gJyR7VG9wfScgfHwgJHskb3JpZW50fSA9PT0gJyR7Qm90dG9tfSdgLCBhLCBiKTtcblxuY29uc3QgaWZZRW5jID0gKCRvcmllbnQsIGEsIGIpID0+IGlmRW5jKGAkeyRvcmllbnR9ICE9PSAnJHtUb3B9JyAmJiAkeyRvcmllbnR9ICE9PSAnJHtCb3R0b219J2AsIGEsIGIpO1xuXG5jb25zdCBpZkxlZnRUb3BFeHByID0gKCRvcmllbnQsIGEsIGIpID0+IGlmRXhwcihgJHskb3JpZW50fSA9PT0gJyR7TGVmdH0nIHx8ICR7JG9yaWVudH0gPT09ICcke1RvcH0nYCwgYSwgYik7XG5cbmNvbnN0IGlmVG9wRXhwciA9ICgkb3JpZW50LCBhLCBiKSA9PiBpZkV4cHIoYCR7JG9yaWVudH0gPT09ICcke1RvcH0nYCwgYSwgYik7XG5cbmNvbnN0IGlmUmlnaHRFeHByID0gKCRvcmllbnQsIGEsIGIpID0+IGlmRXhwcihgJHskb3JpZW50fSA9PT0gJyR7UmlnaHR9J2AsIGEsIGIpO1xuXG5jb25zdCBpZkVuYyA9ICh0ZXN0LCBhLCBiKSA9PiB7XG4gIC8vIGVuc3VyZSBpbnB1dHMgYXJlIGVuY29kZXIgb2JqZWN0cyAob3IgbnVsbClcbiAgYSA9IGEgIT0gbnVsbCA/IGVuY29kZXIoYSkgOiBhO1xuICBiID0gYiAhPSBudWxsID8gZW5jb2RlcihiKSA6IGI7XG5cbiAgaWYgKGlzU2ltcGxlKGEpICYmIGlzU2ltcGxlKGIpKSB7XG4gICAgLy8gaWYgcG9zc2libGUgZ2VuZXJhdGUgc2ltcGxlIHNpZ25hbCBleHByZXNzaW9uXG4gICAgYSA9IGEgPyBhLnNpZ25hbCB8fCBzdHJpbmdWYWx1ZShhLnZhbHVlKSA6IG51bGw7XG4gICAgYiA9IGIgPyBiLnNpZ25hbCB8fCBzdHJpbmdWYWx1ZShiLnZhbHVlKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ25hbDogYCR7dGVzdH0gPyAoJHthfSkgOiAoJHtifSlgXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UgZ2VuZXJhdGUgcnVsZSBzZXRcbiAgICByZXR1cm4gW2V4dGVuZCh7XG4gICAgICB0ZXN0XG4gICAgfSwgYSldLmNvbmNhdChiIHx8IFtdKTtcbiAgfVxufTtcblxuY29uc3QgaXNTaW1wbGUgPSBlbmMgPT4gZW5jID09IG51bGwgfHwgT2JqZWN0LmtleXMoZW5jKS5sZW5ndGggPT09IDE7XG5cbmNvbnN0IGlmRXhwciA9ICh0ZXN0LCBhLCBiKSA9PiAoe1xuICBzaWduYWw6IGAke3Rlc3R9ID8gKCR7dG9FeHByKGEpfSkgOiAoJHt0b0V4cHIoYil9KWBcbn0pO1xuXG5jb25zdCBpZk9yaWVudCA9ICgkb3JpZW50LCB0LCBiLCBsLCByKSA9PiAoe1xuICBzaWduYWw6IChsICE9IG51bGwgPyBgJHskb3JpZW50fSA9PT0gJyR7TGVmdH0nID8gKCR7dG9FeHByKGwpfSkgOiBgIDogJycpICsgKGIgIT0gbnVsbCA/IGAkeyRvcmllbnR9ID09PSAnJHtCb3R0b219JyA/ICgke3RvRXhwcihiKX0pIDogYCA6ICcnKSArIChyICE9IG51bGwgPyBgJHskb3JpZW50fSA9PT0gJyR7UmlnaHR9JyA/ICgke3RvRXhwcihyKX0pIDogYCA6ICcnKSArICh0ICE9IG51bGwgPyBgJHskb3JpZW50fSA9PT0gJyR7VG9wfScgPyAoJHt0b0V4cHIodCl9KSA6IGAgOiAnJykgKyAnKG51bGwpJ1xufSk7XG5cbmNvbnN0IHRvRXhwciA9IHYgPT4gaXNTaWduYWwodikgPyB2LnNpZ25hbCA6IHYgPT0gbnVsbCA/IG51bGwgOiBzdHJpbmdWYWx1ZSh2KTtcblxuY29uc3QgbXVsdCA9IChzaWduLCB2YWx1ZSkgPT4gdmFsdWUgPT09IDAgPyAwIDogaXNTaWduYWwoc2lnbikgPyB7XG4gIHNpZ25hbDogYCgke3NpZ24uc2lnbmFsfSkgKiAke3ZhbHVlfWBcbn0gOiB7XG4gIHZhbHVlOiBzaWduICogdmFsdWVcbn07XG5jb25zdCBwYXRjaCA9ICh2YWx1ZSwgYmFzZSkgPT4ge1xuICBjb25zdCBzID0gdmFsdWUuc2lnbmFsO1xuICByZXR1cm4gcyAmJiBzLmVuZHNXaXRoKCcobnVsbCknKSA/IHtcbiAgICBzaWduYWw6IHMuc2xpY2UoMCwgLTYpICsgYmFzZS5zaWduYWxcbiAgfSA6IHZhbHVlO1xufTtcblxuZnVuY3Rpb24gZmFsbGJhY2socHJvcCwgY29uZmlnLCBheGlzQ29uZmlnLCBzdHlsZSkge1xuICBsZXQgc3R5bGVQcm9wO1xuXG4gIGlmIChjb25maWcgJiYgaGFzT3duUHJvcGVydHkoY29uZmlnLCBwcm9wKSkge1xuICAgIHJldHVybiBjb25maWdbcHJvcF07XG4gIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoYXhpc0NvbmZpZywgcHJvcCkpIHtcbiAgICByZXR1cm4gYXhpc0NvbmZpZ1twcm9wXTtcbiAgfSBlbHNlIGlmIChwcm9wLnN0YXJ0c1dpdGgoJ3RpdGxlJykpIHtcbiAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgIGNhc2UgJ3RpdGxlQ29sb3InOlxuICAgICAgICBzdHlsZVByb3AgPSAnZmlsbCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0aXRsZUZvbnQnOlxuICAgICAgY2FzZSAndGl0bGVGb250U2l6ZSc6XG4gICAgICBjYXNlICd0aXRsZUZvbnRXZWlnaHQnOlxuICAgICAgICBzdHlsZVByb3AgPSBwcm9wWzVdLnRvTG93ZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDYpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZVtHdWlkZVRpdGxlU3R5bGVdW3N0eWxlUHJvcF07XG4gIH0gZWxzZSBpZiAocHJvcC5zdGFydHNXaXRoKCdsYWJlbCcpKSB7XG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICBjYXNlICdsYWJlbENvbG9yJzpcbiAgICAgICAgc3R5bGVQcm9wID0gJ2ZpbGwnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbGFiZWxGb250JzpcbiAgICAgIGNhc2UgJ2xhYmVsRm9udFNpemUnOlxuICAgICAgICBzdHlsZVByb3AgPSBwcm9wWzVdLnRvTG93ZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDYpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZVtHdWlkZUxhYmVsU3R5bGVdW3N0eWxlUHJvcF07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24ga2V5cyhvYmplY3RzKSB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuXG4gIGZvciAoY29uc3Qgb2JqIG9mIG9iamVjdHMpIHtcbiAgICBpZiAoIW9iaikgY29udGludWU7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIG1hcFtrZXldID0gMTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufVxuXG5mdW5jdGlvbiBheGlzQ29uZmlnIChzcGVjLCBzY29wZSkge1xuICB2YXIgY29uZmlnID0gc2NvcGUuY29uZmlnLFxuICAgICAgc3R5bGUgPSBjb25maWcuc3R5bGUsXG4gICAgICBheGlzID0gY29uZmlnLmF4aXMsXG4gICAgICBiYW5kID0gc2NvcGUuc2NhbGVUeXBlKHNwZWMuc2NhbGUpID09PSAnYmFuZCcgJiYgY29uZmlnLmF4aXNCYW5kLFxuICAgICAgb3JpZW50ID0gc3BlYy5vcmllbnQsXG4gICAgICB4eSxcbiAgICAgIG9yLFxuICAgICAga2V5O1xuXG4gIGlmIChpc1NpZ25hbChvcmllbnQpKSB7XG4gICAgY29uc3QgeHlLZXlzID0ga2V5cyhbY29uZmlnLmF4aXNYLCBjb25maWcuYXhpc1ldKSxcbiAgICAgICAgICBvcmllbnRLZXlzID0ga2V5cyhbY29uZmlnLmF4aXNUb3AsIGNvbmZpZy5heGlzQm90dG9tLCBjb25maWcuYXhpc0xlZnQsIGNvbmZpZy5heGlzUmlnaHRdKTtcbiAgICB4eSA9IHt9O1xuXG4gICAgZm9yIChrZXkgb2YgeHlLZXlzKSB7XG4gICAgICB4eVtrZXldID0gaWZYKG9yaWVudCwgZmFsbGJhY2soa2V5LCBjb25maWcuYXhpc1gsIGF4aXMsIHN0eWxlKSwgZmFsbGJhY2soa2V5LCBjb25maWcuYXhpc1ksIGF4aXMsIHN0eWxlKSk7XG4gICAgfVxuXG4gICAgb3IgPSB7fTtcblxuICAgIGZvciAoa2V5IG9mIG9yaWVudEtleXMpIHtcbiAgICAgIG9yW2tleV0gPSBpZk9yaWVudChvcmllbnQuc2lnbmFsLCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzVG9wLCBheGlzLCBzdHlsZSksIGZhbGxiYWNrKGtleSwgY29uZmlnLmF4aXNCb3R0b20sIGF4aXMsIHN0eWxlKSwgZmFsbGJhY2soa2V5LCBjb25maWcuYXhpc0xlZnQsIGF4aXMsIHN0eWxlKSwgZmFsbGJhY2soa2V5LCBjb25maWcuYXhpc1JpZ2h0LCBheGlzLCBzdHlsZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB4eSA9IG9yaWVudCA9PT0gVG9wIHx8IG9yaWVudCA9PT0gQm90dG9tID8gY29uZmlnLmF4aXNYIDogY29uZmlnLmF4aXNZO1xuICAgIG9yID0gY29uZmlnWydheGlzJyArIG9yaWVudFswXS50b1VwcGVyQ2FzZSgpICsgb3JpZW50LnNsaWNlKDEpXTtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHh5IHx8IG9yIHx8IGJhbmQgPyBleHRlbmQoe30sIGF4aXMsIHh5LCBvciwgYmFuZCkgOiBheGlzO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBheGlzRG9tYWluIChzcGVjLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgICAgICBvcmllbnQgPSBzcGVjLm9yaWVudDtcblxuICBsZXQgZW50ZXIsIHVwZGF0ZTtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiBlbnRlciA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9LFxuICAgIHVwZGF0ZTogdXBkYXRlID0ge1xuICAgICAgb3BhY2l0eTogb25lXG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBzdHJva2U6IF8oJ2RvbWFpbkNvbG9yJyksXG4gICAgc3Ryb2tlQ2FwOiBfKCdkb21haW5DYXAnKSxcbiAgICBzdHJva2VEYXNoOiBfKCdkb21haW5EYXNoJyksXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogXygnZG9tYWluRGFzaE9mZnNldCcpLFxuICAgIHN0cm9rZVdpZHRoOiBfKCdkb21haW5XaWR0aCcpLFxuICAgIHN0cm9rZU9wYWNpdHk6IF8oJ2RvbWFpbk9wYWNpdHknKVxuICB9KTtcbiAgY29uc3QgcG9zMCA9IHBvc2l0aW9uKHNwZWMsIDApO1xuICBjb25zdCBwb3MxID0gcG9zaXRpb24oc3BlYywgMSk7XG4gIGVudGVyLnggPSB1cGRhdGUueCA9IGlmWChvcmllbnQsIHBvczAsIHplcm8pO1xuICBlbnRlci54MiA9IHVwZGF0ZS54MiA9IGlmWChvcmllbnQsIHBvczEpO1xuICBlbnRlci55ID0gdXBkYXRlLnkgPSBpZlkob3JpZW50LCBwb3MwLCB6ZXJvKTtcbiAgZW50ZXIueTIgPSB1cGRhdGUueTIgPSBpZlkob3JpZW50LCBwb3MxKTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogUnVsZU1hcmssXG4gICAgcm9sZTogQXhpc0RvbWFpblJvbGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uKHNwZWMsIHBvcykge1xuICByZXR1cm4ge1xuICAgIHNjYWxlOiBzcGVjLnNjYWxlLFxuICAgIHJhbmdlOiBwb3NcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXhpc0dyaWQgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZiwgYmFuZCkge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIG9yaWVudCA9IHNwZWMub3JpZW50LFxuICAgICAgICB2c2NhbGUgPSBzcGVjLmdyaWRTY2FsZSxcbiAgICAgICAgc2lnbiA9IGdldFNpZ24ob3JpZW50LCAxLCAtMSksXG4gICAgICAgIG9mZnNldCA9IG9mZnNldFZhbHVlKHNwZWMub2Zmc2V0LCBzaWduKTtcblxuICBsZXQgZW50ZXIsIGV4aXQsIHVwZGF0ZTtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiBlbnRlciA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9LFxuICAgIHVwZGF0ZTogdXBkYXRlID0ge1xuICAgICAgb3BhY2l0eTogb25lXG4gICAgfSxcbiAgICBleGl0OiBleGl0ID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgc3Ryb2tlOiBfKCdncmlkQ29sb3InKSxcbiAgICBzdHJva2VDYXA6IF8oJ2dyaWRDYXAnKSxcbiAgICBzdHJva2VEYXNoOiBfKCdncmlkRGFzaCcpLFxuICAgIHN0cm9rZURhc2hPZmZzZXQ6IF8oJ2dyaWREYXNoT2Zmc2V0JyksXG4gICAgc3Ryb2tlT3BhY2l0eTogXygnZ3JpZE9wYWNpdHknKSxcbiAgICBzdHJva2VXaWR0aDogXygnZ3JpZFdpZHRoJylcbiAgfSk7XG4gIGNvbnN0IHRpY2tQb3MgPSB7XG4gICAgc2NhbGU6IHNwZWMuc2NhbGUsXG4gICAgZmllbGQ6IFZhbHVlLFxuICAgIGJhbmQ6IGJhbmQuYmFuZCxcbiAgICBleHRyYTogYmFuZC5leHRyYSxcbiAgICBvZmZzZXQ6IGJhbmQub2Zmc2V0LFxuICAgIHJvdW5kOiBfKCd0aWNrUm91bmQnKVxuICB9O1xuICBjb25zdCBzeiA9IGlmWChvcmllbnQsIHtcbiAgICBzaWduYWw6ICdoZWlnaHQnXG4gIH0sIHtcbiAgICBzaWduYWw6ICd3aWR0aCdcbiAgfSk7XG4gIGNvbnN0IGdyaWRTdGFydCA9IHZzY2FsZSA/IHtcbiAgICBzY2FsZTogdnNjYWxlLFxuICAgIHJhbmdlOiAwLFxuICAgIG11bHQ6IHNpZ24sXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfSA6IHtcbiAgICB2YWx1ZTogMCxcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9O1xuICBjb25zdCBncmlkRW5kID0gdnNjYWxlID8ge1xuICAgIHNjYWxlOiB2c2NhbGUsXG4gICAgcmFuZ2U6IDEsXG4gICAgbXVsdDogc2lnbixcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9IDogZXh0ZW5kKHN6LCB7XG4gICAgbXVsdDogc2lnbixcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9KTtcbiAgZW50ZXIueCA9IHVwZGF0ZS54ID0gaWZYKG9yaWVudCwgdGlja1BvcywgZ3JpZFN0YXJ0KTtcbiAgZW50ZXIueSA9IHVwZGF0ZS55ID0gaWZZKG9yaWVudCwgdGlja1BvcywgZ3JpZFN0YXJ0KTtcbiAgZW50ZXIueDIgPSB1cGRhdGUueDIgPSBpZlkob3JpZW50LCBncmlkRW5kKTtcbiAgZW50ZXIueTIgPSB1cGRhdGUueTIgPSBpZlgob3JpZW50LCBncmlkRW5kKTtcbiAgZXhpdC54ID0gaWZYKG9yaWVudCwgdGlja1Bvcyk7XG4gIGV4aXQueSA9IGlmWShvcmllbnQsIHRpY2tQb3MpO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBSdWxlTWFyayxcbiAgICByb2xlOiBBeGlzR3JpZFJvbGUsXG4gICAga2V5OiBWYWx1ZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0VmFsdWUob2Zmc2V0LCBzaWduKSB7XG4gIGlmIChzaWduID09PSAxKSA7IGVsc2UgaWYgKCFpc09iamVjdChvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gaXNTaWduYWwoc2lnbikgPyB7XG4gICAgICBzaWduYWw6IGAoJHtzaWduLnNpZ25hbH0pICogKCR7b2Zmc2V0IHx8IDB9KWBcbiAgICB9IDogc2lnbiAqIChvZmZzZXQgfHwgMCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGVudHJ5ID0gb2Zmc2V0ID0gZXh0ZW5kKHt9LCBvZmZzZXQpO1xuXG4gICAgd2hpbGUgKGVudHJ5Lm11bHQgIT0gbnVsbCkge1xuICAgICAgaWYgKCFpc09iamVjdChlbnRyeS5tdWx0KSkge1xuICAgICAgICBlbnRyeS5tdWx0ID0gaXNTaWduYWwoc2lnbikgLy8gbm8gb2Zmc2V0IGlmIHNpZ24gPT09IDFcbiAgICAgICAgPyB7XG4gICAgICAgICAgc2lnbmFsOiBgKCR7ZW50cnkubXVsdH0pICogKCR7c2lnbi5zaWduYWx9KWBcbiAgICAgICAgfSA6IGVudHJ5Lm11bHQgKiBzaWduO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnkgPSBlbnRyeS5tdWx0ID0gZXh0ZW5kKHt9LCBlbnRyeS5tdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnRyeS5tdWx0ID0gc2lnbjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGF4aXNUaWNrcyAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmLCBzaXplLCBiYW5kKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgb3JpZW50ID0gc3BlYy5vcmllbnQsXG4gICAgICAgIHNpZ24gPSBnZXRTaWduKG9yaWVudCwgLTEsIDEpO1xuXG4gIGxldCBlbnRlciwgZXhpdCwgdXBkYXRlO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmVcbiAgICB9LFxuICAgIGV4aXQ6IGV4aXQgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBzdHJva2U6IF8oJ3RpY2tDb2xvcicpLFxuICAgIHN0cm9rZUNhcDogXygndGlja0NhcCcpLFxuICAgIHN0cm9rZURhc2g6IF8oJ3RpY2tEYXNoJyksXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogXygndGlja0Rhc2hPZmZzZXQnKSxcbiAgICBzdHJva2VPcGFjaXR5OiBfKCd0aWNrT3BhY2l0eScpLFxuICAgIHN0cm9rZVdpZHRoOiBfKCd0aWNrV2lkdGgnKVxuICB9KTtcbiAgY29uc3QgdGlja1NpemUgPSBlbmNvZGVyKHNpemUpO1xuICB0aWNrU2l6ZS5tdWx0ID0gc2lnbjtcbiAgY29uc3QgdGlja1BvcyA9IHtcbiAgICBzY2FsZTogc3BlYy5zY2FsZSxcbiAgICBmaWVsZDogVmFsdWUsXG4gICAgYmFuZDogYmFuZC5iYW5kLFxuICAgIGV4dHJhOiBiYW5kLmV4dHJhLFxuICAgIG9mZnNldDogYmFuZC5vZmZzZXQsXG4gICAgcm91bmQ6IF8oJ3RpY2tSb3VuZCcpXG4gIH07XG4gIHVwZGF0ZS55ID0gZW50ZXIueSA9IGlmWChvcmllbnQsIHplcm8sIHRpY2tQb3MpO1xuICB1cGRhdGUueTIgPSBlbnRlci55MiA9IGlmWChvcmllbnQsIHRpY2tTaXplKTtcbiAgZXhpdC54ID0gaWZYKG9yaWVudCwgdGlja1Bvcyk7XG4gIHVwZGF0ZS54ID0gZW50ZXIueCA9IGlmWShvcmllbnQsIHplcm8sIHRpY2tQb3MpO1xuICB1cGRhdGUueDIgPSBlbnRlci54MiA9IGlmWShvcmllbnQsIHRpY2tTaXplKTtcbiAgZXhpdC55ID0gaWZZKG9yaWVudCwgdGlja1Bvcyk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJ1bGVNYXJrLFxuICAgIHJvbGU6IEF4aXNUaWNrUm9sZSxcbiAgICBrZXk6IFZhbHVlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBmbHVzaEV4cHIoc2NhbGUsIHRocmVzaG9sZCwgYSwgYiwgYykge1xuICByZXR1cm4ge1xuICAgIHNpZ25hbDogJ2ZsdXNoKHJhbmdlKFwiJyArIHNjYWxlICsgJ1wiKSwgJyArICdzY2FsZShcIicgKyBzY2FsZSArICdcIiwgZGF0dW0udmFsdWUpLCAnICsgdGhyZXNob2xkICsgJywnICsgYSArICcsJyArIGIgKyAnLCcgKyBjICsgJyknXG4gIH07XG59XG5cbmZ1bmN0aW9uIGF4aXNMYWJlbHMgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZiwgc2l6ZSwgYmFuZCkge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIG9yaWVudCA9IHNwZWMub3JpZW50LFxuICAgICAgICBzY2FsZSA9IHNwZWMuc2NhbGUsXG4gICAgICAgIHNpZ24gPSBnZXRTaWduKG9yaWVudCwgLTEsIDEpLFxuICAgICAgICBmbHVzaCA9IGRlcmVmKF8oJ2xhYmVsRmx1c2gnKSksXG4gICAgICAgIGZsdXNoT2Zmc2V0ID0gZGVyZWYoXygnbGFiZWxGbHVzaE9mZnNldCcpKSxcbiAgICAgICAgbGFiZWxBbGlnbiA9IF8oJ2xhYmVsQWxpZ24nKSxcbiAgICAgICAgbGFiZWxCYXNlbGluZSA9IF8oJ2xhYmVsQmFzZWxpbmUnKTtcblxuICBsZXQgZmx1c2hPbiA9IGZsdXNoID09PSAwIHx8ICEhZmx1c2gsXG4gICAgICB1cGRhdGU7XG4gIGNvbnN0IHRpY2tTaXplID0gZW5jb2RlcihzaXplKTtcbiAgdGlja1NpemUubXVsdCA9IHNpZ247XG4gIHRpY2tTaXplLm9mZnNldCA9IGVuY29kZXIoXygnbGFiZWxQYWRkaW5nJykgfHwgMCk7XG4gIHRpY2tTaXplLm9mZnNldC5tdWx0ID0gc2lnbjtcbiAgY29uc3QgdGlja1BvcyA9IHtcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgZmllbGQ6IFZhbHVlLFxuICAgIGJhbmQ6IDAuNSxcbiAgICBvZmZzZXQ6IGV4dGVuZE9mZnNldChiYW5kLm9mZnNldCwgXygnbGFiZWxPZmZzZXQnKSlcbiAgfTtcbiAgY29uc3QgYWxpZ24gPSBpZlgob3JpZW50LCBmbHVzaE9uID8gZmx1c2hFeHByKHNjYWxlLCBmbHVzaCwgJ1wibGVmdFwiJywgJ1wicmlnaHRcIicsICdcImNlbnRlclwiJykgOiB7XG4gICAgdmFsdWU6ICdjZW50ZXInXG4gIH0sIGlmUmlnaHQob3JpZW50LCAnbGVmdCcsICdyaWdodCcpKTtcbiAgY29uc3QgYmFzZWxpbmUgPSBpZlgob3JpZW50LCBpZlRvcChvcmllbnQsICdib3R0b20nLCAndG9wJyksIGZsdXNoT24gPyBmbHVzaEV4cHIoc2NhbGUsIGZsdXNoLCAnXCJ0b3BcIicsICdcImJvdHRvbVwiJywgJ1wibWlkZGxlXCInKSA6IHtcbiAgICB2YWx1ZTogJ21pZGRsZSdcbiAgfSk7XG4gIGNvbnN0IG9mZnNldEV4cHIgPSBmbHVzaEV4cHIoc2NhbGUsIGZsdXNoLCBgLSgke2ZsdXNoT2Zmc2V0fSlgLCBmbHVzaE9mZnNldCwgMCk7XG4gIGZsdXNoT24gPSBmbHVzaE9uICYmIGZsdXNoT2Zmc2V0O1xuICBjb25zdCBlbnRlciA9IHtcbiAgICBvcGFjaXR5OiB6ZXJvLFxuICAgIHg6IGlmWChvcmllbnQsIHRpY2tQb3MsIHRpY2tTaXplKSxcbiAgICB5OiBpZlkob3JpZW50LCB0aWNrUG9zLCB0aWNrU2l6ZSlcbiAgfTtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiBlbnRlcixcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IG9uZSxcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgZmllbGQ6IExhYmVsXG4gICAgICB9LFxuICAgICAgeDogZW50ZXIueCxcbiAgICAgIHk6IGVudGVyLnksXG4gICAgICBhbGlnbixcbiAgICAgIGJhc2VsaW5lXG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvLFxuICAgICAgeDogZW50ZXIueCxcbiAgICAgIHk6IGVudGVyLnlcbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGR4OiAhbGFiZWxBbGlnbiAmJiBmbHVzaE9uID8gaWZYKG9yaWVudCwgb2Zmc2V0RXhwcikgOiBudWxsLFxuICAgIGR5OiAhbGFiZWxCYXNlbGluZSAmJiBmbHVzaE9uID8gaWZZKG9yaWVudCwgb2Zmc2V0RXhwcikgOiBudWxsXG4gIH0pO1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBhbmdsZTogXygnbGFiZWxBbmdsZScpLFxuICAgIGZpbGw6IF8oJ2xhYmVsQ29sb3InKSxcbiAgICBmaWxsT3BhY2l0eTogXygnbGFiZWxPcGFjaXR5JyksXG4gICAgZm9udDogXygnbGFiZWxGb250JyksXG4gICAgZm9udFNpemU6IF8oJ2xhYmVsRm9udFNpemUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdsYWJlbEZvbnRXZWlnaHQnKSxcbiAgICBmb250U3R5bGU6IF8oJ2xhYmVsRm9udFN0eWxlJyksXG4gICAgbGltaXQ6IF8oJ2xhYmVsTGltaXQnKSxcbiAgICBsaW5lSGVpZ2h0OiBfKCdsYWJlbExpbmVIZWlnaHQnKVxuICB9LCB7XG4gICAgYWxpZ246IGxhYmVsQWxpZ24sXG4gICAgYmFzZWxpbmU6IGxhYmVsQmFzZWxpbmVcbiAgfSk7XG5cbiAgY29uc3QgYm91bmQgPSBfKCdsYWJlbEJvdW5kJyk7XG5cbiAgbGV0IG92ZXJsYXAgPSBfKCdsYWJlbE92ZXJsYXAnKTsgLy8gaWYgb3ZlcmxhcCBtZXRob2Qgb3IgYm91bmQgZGVmaW5lZCwgcmVxdWVzdCBsYWJlbCBvdmVybGFwIHJlbW92YWxcblxuXG4gIG92ZXJsYXAgPSBvdmVybGFwIHx8IGJvdW5kID8ge1xuICAgIHNlcGFyYXRpb246IF8oJ2xhYmVsU2VwYXJhdGlvbicpLFxuICAgIG1ldGhvZDogb3ZlcmxhcCxcbiAgICBvcmRlcjogJ2RhdHVtLmluZGV4JyxcbiAgICBib3VuZDogYm91bmQgPyB7XG4gICAgICBzY2FsZSxcbiAgICAgIG9yaWVudCxcbiAgICAgIHRvbGVyYW5jZTogYm91bmRcbiAgICB9IDogbnVsbFxuICB9IDogdW5kZWZpbmVkO1xuXG4gIGlmICh1cGRhdGUuYWxpZ24gIT09IGFsaWduKSB7XG4gICAgdXBkYXRlLmFsaWduID0gcGF0Y2godXBkYXRlLmFsaWduLCBhbGlnbik7XG4gIH1cblxuICBpZiAodXBkYXRlLmJhc2VsaW5lICE9PSBiYXNlbGluZSkge1xuICAgIHVwZGF0ZS5iYXNlbGluZSA9IHBhdGNoKHVwZGF0ZS5iYXNlbGluZSwgYmFzZWxpbmUpO1xuICB9XG5cbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogQXhpc0xhYmVsUm9sZSxcbiAgICBzdHlsZTogR3VpZGVMYWJlbFN0eWxlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGUsXG4gICAgb3ZlcmxhcFxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gYXhpc1RpdGxlIChzcGVjLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgICAgICBvcmllbnQgPSBzcGVjLm9yaWVudCxcbiAgICAgICAgc2lnbiA9IGdldFNpZ24ob3JpZW50LCAtMSwgMSk7XG5cbiAgbGV0IGVudGVyLCB1cGRhdGU7XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvLFxuICAgICAgYW5jaG9yOiBlbmNvZGVyKF8oJ3RpdGxlQW5jaG9yJywgbnVsbCkpLFxuICAgICAgYWxpZ246IHtcbiAgICAgICAgc2lnbmFsOiBhbGlnbkV4cHIkMVxuICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSBleHRlbmQoe30sIGVudGVyLCB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB0ZXh0OiBlbmNvZGVyKHNwZWMudGl0bGUpXG4gICAgfSksXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdGl0bGVQb3MgPSB7XG4gICAgc2lnbmFsOiBgbGVycChyYW5nZShcIiR7c3BlYy5zY2FsZX1cIiksICR7YW5jaG9yRXhwcigwLCAxLCAwLjUpfSlgXG4gIH07XG4gIHVwZGF0ZS54ID0gaWZYKG9yaWVudCwgdGl0bGVQb3MpO1xuICB1cGRhdGUueSA9IGlmWShvcmllbnQsIHRpdGxlUG9zKTtcbiAgZW50ZXIuYW5nbGUgPSBpZlgob3JpZW50LCB6ZXJvLCBtdWx0KHNpZ24sIDkwKSk7XG4gIGVudGVyLmJhc2VsaW5lID0gaWZYKG9yaWVudCwgaWZUb3Aob3JpZW50LCBCb3R0b20sIFRvcCksIHtcbiAgICB2YWx1ZTogQm90dG9tXG4gIH0pO1xuICB1cGRhdGUuYW5nbGUgPSBlbnRlci5hbmdsZTtcbiAgdXBkYXRlLmJhc2VsaW5lID0gZW50ZXIuYmFzZWxpbmU7XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGZpbGw6IF8oJ3RpdGxlQ29sb3InKSxcbiAgICBmaWxsT3BhY2l0eTogXygndGl0bGVPcGFjaXR5JyksXG4gICAgZm9udDogXygndGl0bGVGb250JyksXG4gICAgZm9udFNpemU6IF8oJ3RpdGxlRm9udFNpemUnKSxcbiAgICBmb250U3R5bGU6IF8oJ3RpdGxlRm9udFN0eWxlJyksXG4gICAgZm9udFdlaWdodDogXygndGl0bGVGb250V2VpZ2h0JyksXG4gICAgbGltaXQ6IF8oJ3RpdGxlTGltaXQnKSxcbiAgICBsaW5lSGVpZ2h0OiBfKCd0aXRsZUxpbmVIZWlnaHQnKVxuICB9LCB7XG4gICAgLy8gcmVxdWlyZSB1cGRhdGVcbiAgICBhbGlnbjogXygndGl0bGVBbGlnbicpLFxuICAgIGFuZ2xlOiBfKCd0aXRsZUFuZ2xlJyksXG4gICAgYmFzZWxpbmU6IF8oJ3RpdGxlQmFzZWxpbmUnKVxuICB9KTtcbiAgYXV0b0xheW91dChfLCBvcmllbnQsIGVuY29kZSwgdXNlckVuY29kZSk7XG4gIGVuY29kZS51cGRhdGUuYWxpZ24gPSBwYXRjaChlbmNvZGUudXBkYXRlLmFsaWduLCBlbnRlci5hbGlnbik7XG4gIGVuY29kZS51cGRhdGUuYW5nbGUgPSBwYXRjaChlbmNvZGUudXBkYXRlLmFuZ2xlLCBlbnRlci5hbmdsZSk7XG4gIGVuY29kZS51cGRhdGUuYmFzZWxpbmUgPSBwYXRjaChlbmNvZGUudXBkYXRlLmJhc2VsaW5lLCBlbnRlci5iYXNlbGluZSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IEF4aXNUaXRsZVJvbGUsXG4gICAgc3R5bGU6IEd1aWRlVGl0bGVTdHlsZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gYXV0b0xheW91dChfLCBvcmllbnQsIGVuY29kZSwgdXNlckVuY29kZSkge1xuICBjb25zdCBhdXRvID0gKHZhbHVlLCBkaW0pID0+IHZhbHVlICE9IG51bGwgPyAoZW5jb2RlLnVwZGF0ZVtkaW1dID0gcGF0Y2goZW5jb2Rlcih2YWx1ZSksIGVuY29kZS51cGRhdGVbZGltXSksIGZhbHNlKSA6ICFoYXMoZGltLCB1c2VyRW5jb2RlKSA/IHRydWUgOiBmYWxzZTtcblxuICBjb25zdCBhdXRvWSA9IGF1dG8oXygndGl0bGVYJyksICd4JyksXG4gICAgICAgIGF1dG9YID0gYXV0byhfKCd0aXRsZVknKSwgJ3knKTtcbiAgZW5jb2RlLmVudGVyLmF1dG8gPSBhdXRvWCA9PT0gYXV0b1kgPyBlbmNvZGVyKGF1dG9YKSA6IGlmWChvcmllbnQsIGVuY29kZXIoYXV0b1gpLCBlbmNvZGVyKGF1dG9ZKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXhpcyAoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgY29uZmlnID0gYXhpc0NvbmZpZyhzcGVjLCBzY29wZSksXG4gICAgICAgIGVuY29kZSA9IHNwZWMuZW5jb2RlIHx8IHt9LFxuICAgICAgICBheGlzRW5jb2RlID0gZW5jb2RlLmF4aXMgfHwge30sXG4gICAgICAgIG5hbWUgPSBheGlzRW5jb2RlLm5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBpbnRlcmFjdGl2ZSA9IGF4aXNFbmNvZGUuaW50ZXJhY3RpdmUsXG4gICAgICAgIHN0eWxlID0gYXhpc0VuY29kZS5zdHlsZSxcbiAgICAgICAgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgICAgICBiYW5kID0gdGlja0JhbmQoXyk7IC8vIHNpbmdsZS1lbGVtZW50IGRhdGEgc291cmNlIGZvciBheGlzIGdyb3VwXG5cblxuICBjb25zdCBkYXR1bSA9IHtcbiAgICBzY2FsZTogc3BlYy5zY2FsZSxcbiAgICB0aWNrczogISFfKCd0aWNrcycpLFxuICAgIGxhYmVsczogISFfKCdsYWJlbHMnKSxcbiAgICBncmlkOiAhIV8oJ2dyaWQnKSxcbiAgICBkb21haW46ICEhXygnZG9tYWluJyksXG4gICAgdGl0bGU6IHNwZWMudGl0bGUgIT0gbnVsbFxuICB9O1xuICBjb25zdCBkYXRhUmVmID0gcmVmKHNjb3BlLmFkZChDb2xsZWN0KHt9LCBbZGF0dW1dKSkpOyAvLyBkYXRhIHNvdXJjZSBmb3IgYXhpcyB0aWNrc1xuXG4gIGNvbnN0IHRpY2tzUmVmID0gcmVmKHNjb3BlLmFkZChBeGlzVGlja3Moe1xuICAgIHNjYWxlOiBzY29wZS5zY2FsZVJlZihzcGVjLnNjYWxlKSxcbiAgICBleHRyYTogc2NvcGUucHJvcGVydHkoYmFuZC5leHRyYSksXG4gICAgY291bnQ6IHNjb3BlLm9iamVjdFByb3BlcnR5KHNwZWMudGlja0NvdW50KSxcbiAgICB2YWx1ZXM6IHNjb3BlLm9iamVjdFByb3BlcnR5KHNwZWMudmFsdWVzKSxcbiAgICBtaW5zdGVwOiBzY29wZS5wcm9wZXJ0eShzcGVjLnRpY2tNaW5TdGVwKSxcbiAgICBmb3JtYXRUeXBlOiBzY29wZS5wcm9wZXJ0eShzcGVjLmZvcm1hdFR5cGUpLFxuICAgIGZvcm1hdFNwZWNpZmllcjogc2NvcGUucHJvcGVydHkoc3BlYy5mb3JtYXQpXG4gIH0pKSk7IC8vIGdlbmVyYXRlIGF4aXMgbWFya3NcblxuICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICBsZXQgc2l6ZTsgLy8gaW5jbHVkZSBheGlzIGdyaWRsaW5lcyBpZiByZXF1ZXN0ZWRcblxuICBpZiAoZGF0dW0uZ3JpZCkge1xuICAgIGNoaWxkcmVuLnB1c2goYXhpc0dyaWQoc3BlYywgY29uZmlnLCBlbmNvZGUuZ3JpZCwgdGlja3NSZWYsIGJhbmQpKTtcbiAgfSAvLyBpbmNsdWRlIGF4aXMgdGlja3MgaWYgcmVxdWVzdGVkXG5cblxuICBpZiAoZGF0dW0udGlja3MpIHtcbiAgICBzaXplID0gXygndGlja1NpemUnKTtcbiAgICBjaGlsZHJlbi5wdXNoKGF4aXNUaWNrcyhzcGVjLCBjb25maWcsIGVuY29kZS50aWNrcywgdGlja3NSZWYsIHNpemUsIGJhbmQpKTtcbiAgfSAvLyBpbmNsdWRlIGF4aXMgbGFiZWxzIGlmIHJlcXVlc3RlZFxuXG5cbiAgaWYgKGRhdHVtLmxhYmVscykge1xuICAgIHNpemUgPSBkYXR1bS50aWNrcyA/IHNpemUgOiAwO1xuICAgIGNoaWxkcmVuLnB1c2goYXhpc0xhYmVscyhzcGVjLCBjb25maWcsIGVuY29kZS5sYWJlbHMsIHRpY2tzUmVmLCBzaXplLCBiYW5kKSk7XG4gIH0gLy8gaW5jbHVkZSBheGlzIGRvbWFpbiBwYXRoIGlmIHJlcXVlc3RlZFxuXG5cbiAgaWYgKGRhdHVtLmRvbWFpbikge1xuICAgIGNoaWxkcmVuLnB1c2goYXhpc0RvbWFpbihzcGVjLCBjb25maWcsIGVuY29kZS5kb21haW4sIGRhdGFSZWYpKTtcbiAgfSAvLyBpbmNsdWRlIGF4aXMgdGl0bGUgaWYgZGVmaW5lZFxuXG5cbiAgaWYgKGRhdHVtLnRpdGxlKSB7XG4gICAgY2hpbGRyZW4ucHVzaChheGlzVGl0bGUoc3BlYywgY29uZmlnLCBlbmNvZGUudGl0bGUsIGRhdGFSZWYpKTtcbiAgfSAvLyBwYXJzZSBheGlzIHNwZWNpZmljYXRpb25cblxuXG4gIHJldHVybiBwYXJzZU1hcmsoZ3VpZGVHcm91cCh7XG4gICAgcm9sZTogQXhpc1JvbGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGU6IGV4dGVuZEVuY29kZShidWlsZEF4aXNFbmNvZGUoXywgc3BlYyksIGF4aXNFbmNvZGUsIFNraXApLFxuICAgIG1hcmtzOiBjaGlsZHJlbixcbiAgICBhcmlhOiBfKCdhcmlhJyksXG4gICAgZGVzY3JpcHRpb246IF8oJ2Rlc2NyaXB0aW9uJyksXG4gICAgemluZGV4OiBfKCd6aW5kZXgnKSxcbiAgICBuYW1lLFxuICAgIGludGVyYWN0aXZlLFxuICAgIHN0eWxlXG4gIH0pLCBzY29wZSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQXhpc0VuY29kZShfLCBzcGVjKSB7XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjoge30sXG4gICAgdXBkYXRlOiB7fVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBvcmllbnQ6IF8oJ29yaWVudCcpLFxuICAgIG9mZnNldDogXygnb2Zmc2V0JykgfHwgMCxcbiAgICBwb3NpdGlvbjogdmFsdWUoc3BlYy5wb3NpdGlvbiwgMCksXG4gICAgdGl0bGVQYWRkaW5nOiBfKCd0aXRsZVBhZGRpbmcnKSxcbiAgICBtaW5FeHRlbnQ6IF8oJ21pbkV4dGVudCcpLFxuICAgIG1heEV4dGVudDogXygnbWF4RXh0ZW50JyksXG4gICAgcmFuZ2U6IHtcbiAgICAgIHNpZ25hbDogYGFicyhzcGFuKHJhbmdlKFwiJHtzcGVjLnNjYWxlfVwiKSkpYFxuICAgIH0sXG4gICAgdHJhbnNsYXRlOiBfKCd0cmFuc2xhdGUnKSxcbiAgICAvLyBhY2Nlc3NpYmlsaXR5IHN1cHBvcnRcbiAgICBmb3JtYXQ6IHNwZWMuZm9ybWF0LFxuICAgIGZvcm1hdFR5cGU6IHNwZWMuZm9ybWF0VHlwZVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTY29wZSAoc3BlYywgc2NvcGUsIHByZXByb2Nlc3NlZCkge1xuICBjb25zdCBzaWduYWxzID0gYXJyYXkoc3BlYy5zaWduYWxzKSxcbiAgICAgICAgc2NhbGVzID0gYXJyYXkoc3BlYy5zY2FsZXMpOyAvLyBwYXJzZSBzaWduYWwgZGVmaW5pdGlvbnMsIGlmIG5vdCBhbHJlYWR5IHByZXByb2Nlc3NlZFxuXG4gIGlmICghcHJlcHJvY2Vzc2VkKSBzaWduYWxzLmZvckVhY2goXyA9PiBwYXJzZVNpZ25hbChfLCBzY29wZSkpOyAvLyBwYXJzZSBjYXJ0b2dyYXBoaWMgcHJvamVjdGlvbiBkZWZpbml0aW9uc1xuXG4gIGFycmF5KHNwZWMucHJvamVjdGlvbnMpLmZvckVhY2goXyA9PiBwYXJzZVByb2plY3Rpb24oXywgc2NvcGUpKTsgLy8gaW5pdGlhbGl6ZSBzY2FsZSByZWZlcmVuY2VzXG5cbiAgc2NhbGVzLmZvckVhY2goXyA9PiBpbml0U2NhbGUoXywgc2NvcGUpKTsgLy8gcGFyc2UgZGF0YSBzb3VyY2VzXG5cbiAgYXJyYXkoc3BlYy5kYXRhKS5mb3JFYWNoKF8gPT4gcGFyc2VEYXRhKF8sIHNjb3BlKSk7IC8vIHBhcnNlIHNjYWxlIGRlZmluaXRpb25zXG5cbiAgc2NhbGVzLmZvckVhY2goXyA9PiBwYXJzZVNjYWxlKF8sIHNjb3BlKSk7IC8vIHBhcnNlIHNpZ25hbCB1cGRhdGVzXG5cbiAgKHByZXByb2Nlc3NlZCB8fCBzaWduYWxzKS5mb3JFYWNoKF8gPT4gcGFyc2VTaWduYWxVcGRhdGVzKF8sIHNjb3BlKSk7IC8vIHBhcnNlIGF4aXMgZGVmaW5pdGlvbnNcblxuICBhcnJheShzcGVjLmF4ZXMpLmZvckVhY2goXyA9PiBwYXJzZUF4aXMoXywgc2NvcGUpKTsgLy8gcGFyc2UgbWFyayBkZWZpbml0aW9uc1xuXG4gIGFycmF5KHNwZWMubWFya3MpLmZvckVhY2goXyA9PiBwYXJzZU1hcmsoXywgc2NvcGUpKTsgLy8gcGFyc2UgbGVnZW5kIGRlZmluaXRpb25zXG5cbiAgYXJyYXkoc3BlYy5sZWdlbmRzKS5mb3JFYWNoKF8gPT4gcGFyc2VMZWdlbmQoXywgc2NvcGUpKTsgLy8gcGFyc2UgdGl0bGUsIGlmIGRlZmluZWRcblxuICBpZiAoc3BlYy50aXRsZSkgcGFyc2VUaXRsZShzcGVjLnRpdGxlLCBzY29wZSk7IC8vIHBhcnNlIGNvbGxlY3RlZCBsYW1iZGEgKGFub255bW91cykgZXhwcmVzc2lvbnNcblxuICBzY29wZS5wYXJzZUxhbWJkYXMoKTtcbiAgcmV0dXJuIHNjb3BlO1xufVxuXG5jb25zdCByb290RW5jb2RlID0gc3BlYyA9PiBleHRlbmRFbmNvZGUoe1xuICBlbnRlcjoge1xuICAgIHg6IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB2YWx1ZTogMFxuICAgIH1cbiAgfSxcbiAgdXBkYXRlOiB7XG4gICAgd2lkdGg6IHtcbiAgICAgIHNpZ25hbDogJ3dpZHRoJ1xuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICBzaWduYWw6ICdoZWlnaHQnXG4gICAgfVxuICB9XG59LCBzcGVjKTtcblxuZnVuY3Rpb24gcGFyc2VWaWV3KHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHNjb3BlLmNvbmZpZzsgLy8gYWRkIHNjZW5lZ3JhcGggcm9vdFxuXG4gIGNvbnN0IHJvb3QgPSByZWYoc2NvcGUucm9vdCA9IHNjb3BlLmFkZChvcGVyYXRvcigpKSk7IC8vIHBhcnNlIHRvcC1sZXZlbCBzaWduYWwgZGVmaW5pdGlvbnNcblxuICBjb25zdCBzaWduYWxzID0gY29sbGVjdFNpZ25hbHMoc3BlYywgY29uZmlnKTtcbiAgc2lnbmFscy5mb3JFYWNoKF8gPT4gcGFyc2VTaWduYWwoXywgc2NvcGUpKTsgLy8gYXNzaWduIGRlc2NyaXB0aW9uLCBldmVudCwgbGVnZW5kLCBhbmQgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuICBzY29wZS5kZXNjcmlwdGlvbiA9IHNwZWMuZGVzY3JpcHRpb24gfHwgY29uZmlnLmRlc2NyaXB0aW9uO1xuICBzY29wZS5ldmVudENvbmZpZyA9IGNvbmZpZy5ldmVudHM7XG4gIHNjb3BlLmxlZ2VuZHMgPSBzY29wZS5vYmplY3RQcm9wZXJ0eShjb25maWcubGVnZW5kICYmIGNvbmZpZy5sZWdlbmQubGF5b3V0KTtcbiAgc2NvcGUubG9jYWxlID0gY29uZmlnLmxvY2FsZTsgLy8gc3RvcmUgcm9vdCBncm91cCBpdGVtXG5cbiAgY29uc3QgaW5wdXQgPSBzY29wZS5hZGQoQ29sbGVjdCgpKTsgLy8gZW5jb2RlIHJvb3QgZ3JvdXAgaXRlbVxuXG4gIGNvbnN0IGVuY29kZSA9IHNjb3BlLmFkZChFbmNvZGUocGFyc2VFbmNvZGUocm9vdEVuY29kZShzcGVjLmVuY29kZSksIEdyb3VwTWFyaywgRnJhbWVSb2xlLCBzcGVjLnN0eWxlLCBzY29wZSwge1xuICAgIHB1bHNlOiByZWYoaW5wdXQpXG4gIH0pKSk7IC8vIHBlcmZvcm0gdmlldyBsYXlvdXRcblxuICBjb25zdCBwYXJlbnQgPSBzY29wZS5hZGQoVmlld0xheW91dCh7XG4gICAgbGF5b3V0OiBzY29wZS5vYmplY3RQcm9wZXJ0eShzcGVjLmxheW91dCksXG4gICAgbGVnZW5kczogc2NvcGUubGVnZW5kcyxcbiAgICBhdXRvc2l6ZTogc2NvcGUuc2lnbmFsUmVmKCdhdXRvc2l6ZScpLFxuICAgIG1hcms6IHJvb3QsXG4gICAgcHVsc2U6IHJlZihlbmNvZGUpXG4gIH0pKTtcbiAgc2NvcGUub3BlcmF0b3JzLnBvcCgpOyAvLyBwYXJzZSByZW1haW5kZXIgb2Ygc3BlY2lmaWNhdGlvblxuXG4gIHNjb3BlLnB1c2hTdGF0ZShyZWYoZW5jb2RlKSwgcmVmKHBhcmVudCksIG51bGwpO1xuICBwYXJzZVNjb3BlKHNwZWMsIHNjb3BlLCBzaWduYWxzKTtcbiAgc2NvcGUub3BlcmF0b3JzLnB1c2gocGFyZW50KTsgLy8gYm91bmQgLyByZW5kZXIgLyBzaWV2ZSByb290IGl0ZW1cblxuICBsZXQgb3AgPSBzY29wZS5hZGQoQm91bmQoe1xuICAgIG1hcms6IHJvb3QsXG4gICAgcHVsc2U6IHJlZihwYXJlbnQpXG4gIH0pKTtcbiAgb3AgPSBzY29wZS5hZGQoUmVuZGVyKHtcbiAgICBwdWxzZTogcmVmKG9wKVxuICB9KSk7XG4gIG9wID0gc2NvcGUuYWRkKFNpZXZlKHtcbiAgICBwdWxzZTogcmVmKG9wKVxuICB9KSk7IC8vIHRyYWNrIG1ldGFkYXRhIGZvciByb290IGl0ZW1cblxuICBzY29wZS5hZGREYXRhKCdyb290JywgbmV3IERhdGFTY29wZShzY29wZSwgaW5wdXQsIGlucHV0LCBvcCkpO1xuICByZXR1cm4gc2NvcGU7XG59XG5cbmZ1bmN0aW9uIHNpZ25hbE9iamVjdChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuc2lnbmFsID8ge1xuICAgIG5hbWUsXG4gICAgdXBkYXRlOiB2YWx1ZS5zaWduYWxcbiAgfSA6IHtcbiAgICBuYW1lLFxuICAgIHZhbHVlXG4gIH07XG59XG4vKipcbiAqIENvbGxlY3QgdG9wLWxldmVsIHNpZ25hbHMsIG1lcmdpbmcgdmFsdWVzIGFzIG5lZWRlZC4gU2lnbmFsc1xuICogZGVmaW5lZCBpbiB0aGUgY29uZmlnIHNpZ25hbHMgYXJyYXlzIGFyZSBhZGRlZCBvbmx5IGlmIHRoYXRcbiAqIHNpZ25hbCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkIGluIHRoZSBzcGVjaWZpY2F0aW9uLlxuICogQnVpbHQtaW4gc2lnbmFscyAoYXV0b3NpemUsIGJhY2tncm91bmQsIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQpXG4gKiByZWNlaXZlIHNwZWNpYWwgdHJlYXRtZW50LiBUaGV5IGFyZSBpbml0aWFsaXplZCB1c2luZyB0aGVcbiAqIHRvcC1sZXZlbCBzcGVjIHByb3BlcnR5LCBvciwgaWYgdW5kZWZpbmVkIGluIHRoZSBzcGVjLCB1c2luZ1xuICogdGhlIGNvcnJlc3BvbmRpbmcgdG9wLWxldmVsIGNvbmZpZyBwcm9wZXJ0eS4gSWYgdGhpcyBwcm9wZXJ0eVxuICogaXMgYSBzaWduYWwgcmVmZXJlbmNlIG9iamVjdCwgdGhlIHNpZ25hbCBleHByZXNzaW9uIG1hcHMgdG8gdGhlXG4gKiBzaWduYWwgJ3VwZGF0ZScgcHJvcGVydHkuIElmIHRoZSBzcGVjJ3MgdG9wLWxldmVsIHNpZ25hbCBhcnJheVxuICogY29udGFpbnMgYW4gZW50cnkgdGhhdCBtYXRjaGVzIGEgYnVpbHQtaW4gc2lnbmFsLCB0aGF0IGVudHJ5XG4gKiB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBidWlsdC1pbiBzcGVjaWZpY2F0aW9uLCBwb3RlbnRpYWxseVxuICogb3ZlcndyaXRpbmcgZXhpc3RpbmcgJ3ZhbHVlJyBvciAndXBkYXRlJyBwcm9wZXJ0aWVzLlxuICovXG5cblxuZnVuY3Rpb24gY29sbGVjdFNpZ25hbHMoc3BlYywgY29uZmlnKSB7XG4gIGNvbnN0IF8gPSBuYW1lID0+IHZhbHVlKHNwZWNbbmFtZV0sIGNvbmZpZ1tuYW1lXSksXG4gICAgICAgIHNpZ25hbHMgPSBbc2lnbmFsT2JqZWN0KCdiYWNrZ3JvdW5kJywgXygnYmFja2dyb3VuZCcpKSwgc2lnbmFsT2JqZWN0KCdhdXRvc2l6ZScsIHBhcnNlQXV0b3NpemUoXygnYXV0b3NpemUnKSkpLCBzaWduYWxPYmplY3QoJ3BhZGRpbmcnLCBwYXJzZVBhZGRpbmcoXygncGFkZGluZycpKSksIHNpZ25hbE9iamVjdCgnd2lkdGgnLCBfKCd3aWR0aCcpIHx8IDApLCBzaWduYWxPYmplY3QoJ2hlaWdodCcsIF8oJ2hlaWdodCcpIHx8IDApXSxcbiAgICAgICAgcHJlID0gc2lnbmFscy5yZWR1Y2UoKHAsIHMpID0+IChwW3MubmFtZV0gPSBzLCBwKSwge30pLFxuICAgICAgICBtYXAgPSB7fTsgLy8gYWRkIHNwZWMgc2lnbmFsIGFycmF5XG5cblxuICBhcnJheShzcGVjLnNpZ25hbHMpLmZvckVhY2gocyA9PiB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHByZSwgcy5uYW1lKSkge1xuICAgICAgLy8gbWVyZ2UgaWYgYnVpbHQtaW4gc2lnbmFsXG4gICAgICBzID0gZXh0ZW5kKHByZVtzLm5hbWVdLCBzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGFkZCB0byBzaWduYWwgbGlzdFxuICAgICAgc2lnbmFscy5wdXNoKHMpO1xuICAgIH1cblxuICAgIG1hcFtzLm5hbWVdID0gcztcbiAgfSk7IC8vIGFkZCBjb25maWcgc2lnbmFsIGFycmF5XG5cbiAgYXJyYXkoY29uZmlnLnNpZ25hbHMpLmZvckVhY2gocyA9PiB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShtYXAsIHMubmFtZSkgJiYgIWhhc093blByb3BlcnR5KHByZSwgcy5uYW1lKSkge1xuICAgICAgLy8gYWRkIHRvIHNpZ25hbCBsaXN0IGlmIG5vdCBhbHJlYWR5IGRlZmluZWRcbiAgICAgIHNpZ25hbHMucHVzaChzKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2lnbmFscztcbn1cblxuZnVuY3Rpb24gU2NvcGUoY29uZmlnLCBvcHRpb25zKSB7XG4gIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLmJpbmRpbmdzID0gW107XG4gIHRoaXMuZmllbGQgPSB7fTtcbiAgdGhpcy5zaWduYWxzID0ge307XG4gIHRoaXMubGFtYmRhcyA9IHt9O1xuICB0aGlzLnNjYWxlcyA9IHt9O1xuICB0aGlzLmV2ZW50cyA9IHt9O1xuICB0aGlzLmRhdGEgPSB7fTtcbiAgdGhpcy5zdHJlYW1zID0gW107XG4gIHRoaXMudXBkYXRlcyA9IFtdO1xuICB0aGlzLm9wZXJhdG9ycyA9IFtdO1xuICB0aGlzLmV2ZW50Q29uZmlnID0gbnVsbDtcbiAgdGhpcy5sb2NhbGUgPSBudWxsO1xuICB0aGlzLl9pZCA9IDA7XG4gIHRoaXMuX3N1YmlkID0gMDtcbiAgdGhpcy5fbmV4dHN1YiA9IFswXTtcbiAgdGhpcy5fcGFyZW50ID0gW107XG4gIHRoaXMuX2VuY29kZSA9IFtdO1xuICB0aGlzLl9sb29rdXAgPSBbXTtcbiAgdGhpcy5fbWFya3BhdGggPSBbXTtcbn1cblxuZnVuY3Rpb24gU3Vic2NvcGUoc2NvcGUpIHtcbiAgdGhpcy5jb25maWcgPSBzY29wZS5jb25maWc7XG4gIHRoaXMub3B0aW9ucyA9IHNjb3BlLm9wdGlvbnM7XG4gIHRoaXMubGVnZW5kcyA9IHNjb3BlLmxlZ2VuZHM7XG4gIHRoaXMuZmllbGQgPSBPYmplY3QuY3JlYXRlKHNjb3BlLmZpZWxkKTtcbiAgdGhpcy5zaWduYWxzID0gT2JqZWN0LmNyZWF0ZShzY29wZS5zaWduYWxzKTtcbiAgdGhpcy5sYW1iZGFzID0gT2JqZWN0LmNyZWF0ZShzY29wZS5sYW1iZGFzKTtcbiAgdGhpcy5zY2FsZXMgPSBPYmplY3QuY3JlYXRlKHNjb3BlLnNjYWxlcyk7XG4gIHRoaXMuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShzY29wZS5ldmVudHMpO1xuICB0aGlzLmRhdGEgPSBPYmplY3QuY3JlYXRlKHNjb3BlLmRhdGEpO1xuICB0aGlzLnN0cmVhbXMgPSBbXTtcbiAgdGhpcy51cGRhdGVzID0gW107XG4gIHRoaXMub3BlcmF0b3JzID0gW107XG4gIHRoaXMuX2lkID0gMDtcbiAgdGhpcy5fc3ViaWQgPSArK3Njb3BlLl9uZXh0c3ViWzBdO1xuICB0aGlzLl9uZXh0c3ViID0gc2NvcGUuX25leHRzdWI7XG4gIHRoaXMuX3BhcmVudCA9IHNjb3BlLl9wYXJlbnQuc2xpY2UoKTtcbiAgdGhpcy5fZW5jb2RlID0gc2NvcGUuX2VuY29kZS5zbGljZSgpO1xuICB0aGlzLl9sb29rdXAgPSBzY29wZS5fbG9va3VwLnNsaWNlKCk7XG4gIHRoaXMuX21hcmtwYXRoID0gc2NvcGUuX21hcmtwYXRoO1xufVxuXG5TY29wZS5wcm90b3R5cGUgPSBTdWJzY29wZS5wcm90b3R5cGUgPSB7XG4gIHBhcnNlKHNwZWMpIHtcbiAgICByZXR1cm4gcGFyc2VTY29wZShzcGVjLCB0aGlzKTtcbiAgfSxcblxuICBmb3JrKCkge1xuICAgIHJldHVybiBuZXcgU3Vic2NvcGUodGhpcyk7XG4gIH0sXG5cbiAgaXNTdWJzY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ViaWQgPiAwO1xuICB9LFxuXG4gIHRvUnVudGltZSgpIHtcbiAgICB0aGlzLmZpbmlzaCgpO1xuICAgIHJldHVybiB7XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG9wZXJhdG9yczogdGhpcy5vcGVyYXRvcnMsXG4gICAgICBzdHJlYW1zOiB0aGlzLnN0cmVhbXMsXG4gICAgICB1cGRhdGVzOiB0aGlzLnVwZGF0ZXMsXG4gICAgICBiaW5kaW5nczogdGhpcy5iaW5kaW5ncyxcbiAgICAgIGV2ZW50Q29uZmlnOiB0aGlzLmV2ZW50Q29uZmlnLFxuICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZVxuICAgIH07XG4gIH0sXG5cbiAgaWQoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9zdWJpZCA/IHRoaXMuX3N1YmlkICsgJzonIDogMCkgKyB0aGlzLl9pZCsrO1xuICB9LFxuXG4gIGFkZChvcCkge1xuICAgIHRoaXMub3BlcmF0b3JzLnB1c2gob3ApO1xuICAgIG9wLmlkID0gdGhpcy5pZCgpOyAvLyBpZiBwcmUtcmVnaXN0cmF0aW9uIHJlZmVyZW5jZXMgZXhpc3QsIHJlc29sdmUgdGhlbSBub3dcblxuICAgIGlmIChvcC5yZWZzKSB7XG4gICAgICBvcC5yZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgcmVmLiRyZWYgPSBvcC5pZDtcbiAgICAgIH0pO1xuICAgICAgb3AucmVmcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wO1xuICB9LFxuXG4gIHByb3h5KG9wKSB7XG4gICAgY29uc3QgdnJlZiA9IG9wIGluc3RhbmNlb2YgRW50cnkgPyByZWYob3ApIDogb3A7XG4gICAgcmV0dXJuIHRoaXMuYWRkKFByb3h5KHtcbiAgICAgIHZhbHVlOiB2cmVmXG4gICAgfSkpO1xuICB9LFxuXG4gIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLnN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgIHN0cmVhbS5pZCA9IHRoaXMuaWQoKTtcbiAgICByZXR1cm4gc3RyZWFtO1xuICB9LFxuXG4gIGFkZFVwZGF0ZSh1cGRhdGUpIHtcbiAgICB0aGlzLnVwZGF0ZXMucHVzaCh1cGRhdGUpO1xuICAgIHJldHVybiB1cGRhdGU7XG4gIH0sXG5cbiAgLy8gQXBwbHkgbWV0YWRhdGFcbiAgZmluaXNoKCkge1xuICAgIGxldCBuYW1lLCBkczsgLy8gYW5ub3RhdGUgcm9vdFxuXG4gICAgaWYgKHRoaXMucm9vdCkgdGhpcy5yb290LnJvb3QgPSB0cnVlOyAvLyBhbm5vdGF0ZSBzaWduYWxzXG5cbiAgICBmb3IgKG5hbWUgaW4gdGhpcy5zaWduYWxzKSB7XG4gICAgICB0aGlzLnNpZ25hbHNbbmFtZV0uc2lnbmFsID0gbmFtZTtcbiAgICB9IC8vIGFubm90YXRlIHNjYWxlc1xuXG5cbiAgICBmb3IgKG5hbWUgaW4gdGhpcy5zY2FsZXMpIHtcbiAgICAgIHRoaXMuc2NhbGVzW25hbWVdLnNjYWxlID0gbmFtZTtcbiAgICB9IC8vIGFubm90YXRlIGRhdGEgc2V0c1xuXG5cbiAgICBmdW5jdGlvbiBhbm5vdGF0ZShvcCwgbmFtZSwgdHlwZSkge1xuICAgICAgbGV0IGRhdGEsIGxpc3Q7XG5cbiAgICAgIGlmIChvcCkge1xuICAgICAgICBkYXRhID0gb3AuZGF0YSB8fCAob3AuZGF0YSA9IHt9KTtcbiAgICAgICAgbGlzdCA9IGRhdGFbbmFtZV0gfHwgKGRhdGFbbmFtZV0gPSBbXSk7XG4gICAgICAgIGxpc3QucHVzaCh0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKG5hbWUgaW4gdGhpcy5kYXRhKSB7XG4gICAgICBkcyA9IHRoaXMuZGF0YVtuYW1lXTtcbiAgICAgIGFubm90YXRlKGRzLmlucHV0LCBuYW1lLCAnaW5wdXQnKTtcbiAgICAgIGFubm90YXRlKGRzLm91dHB1dCwgbmFtZSwgJ291dHB1dCcpO1xuICAgICAgYW5ub3RhdGUoZHMudmFsdWVzLCBuYW1lLCAndmFsdWVzJyk7XG5cbiAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gZHMuaW5kZXgpIHtcbiAgICAgICAgYW5ub3RhdGUoZHMuaW5kZXhbZmllbGRdLCBuYW1lLCAnaW5kZXg6JyArIGZpZWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyAtLS0tXG4gIHB1c2hTdGF0ZShlbmNvZGUsIHBhcmVudCwgbG9va3VwKSB7XG4gICAgdGhpcy5fZW5jb2RlLnB1c2gocmVmKHRoaXMuYWRkKFNpZXZlKHtcbiAgICAgIHB1bHNlOiBlbmNvZGVcbiAgICB9KSkpKTtcblxuICAgIHRoaXMuX3BhcmVudC5wdXNoKHBhcmVudCk7XG5cbiAgICB0aGlzLl9sb29rdXAucHVzaChsb29rdXAgPyByZWYodGhpcy5wcm94eShsb29rdXApKSA6IG51bGwpO1xuXG4gICAgdGhpcy5fbWFya3BhdGgucHVzaCgtMSk7XG4gIH0sXG5cbiAgcG9wU3RhdGUoKSB7XG4gICAgdGhpcy5fZW5jb2RlLnBvcCgpO1xuXG4gICAgdGhpcy5fcGFyZW50LnBvcCgpO1xuXG4gICAgdGhpcy5fbG9va3VwLnBvcCgpO1xuXG4gICAgdGhpcy5fbWFya3BhdGgucG9wKCk7XG4gIH0sXG5cbiAgcGFyZW50KCkge1xuICAgIHJldHVybiBwZWVrKHRoaXMuX3BhcmVudCk7XG4gIH0sXG5cbiAgZW5jb2RlKCkge1xuICAgIHJldHVybiBwZWVrKHRoaXMuX2VuY29kZSk7XG4gIH0sXG5cbiAgbG9va3VwKCkge1xuICAgIHJldHVybiBwZWVrKHRoaXMuX2xvb2t1cCk7XG4gIH0sXG5cbiAgbWFya3BhdGgoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX21hcmtwYXRoO1xuICAgIHJldHVybiArK3BbcC5sZW5ndGggLSAxXTtcbiAgfSxcblxuICAvLyAtLS0tXG4gIGZpZWxkUmVmKGZpZWxkLCBuYW1lKSB7XG4gICAgaWYgKGlzU3RyaW5nKGZpZWxkKSkgcmV0dXJuIGZpZWxkUmVmJDEoZmllbGQsIG5hbWUpO1xuXG4gICAgaWYgKCFmaWVsZC5zaWduYWwpIHtcbiAgICAgIGVycm9yKCdVbnN1cHBvcnRlZCBmaWVsZCByZWZlcmVuY2U6ICcgKyBzdHJpbmdWYWx1ZShmaWVsZCkpO1xuICAgIH1cblxuICAgIGNvbnN0IHMgPSBmaWVsZC5zaWduYWw7XG4gICAgbGV0IGYgPSB0aGlzLmZpZWxkW3NdO1xuXG4gICAgaWYgKCFmKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuc2lnbmFsUmVmKHMpXG4gICAgICB9O1xuICAgICAgaWYgKG5hbWUpIHBhcmFtcy5hcyA9IG5hbWU7XG4gICAgICB0aGlzLmZpZWxkW3NdID0gZiA9IHJlZih0aGlzLmFkZChGaWVsZChwYXJhbXMpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGY7XG4gIH0sXG5cbiAgY29tcGFyZVJlZihjbXApIHtcbiAgICBsZXQgc2lnbmFsID0gZmFsc2U7XG5cbiAgICBjb25zdCBjaGVjayA9IF8gPT4gaXNTaWduYWwoXykgPyAoc2lnbmFsID0gdHJ1ZSwgdGhpcy5zaWduYWxSZWYoXy5zaWduYWwpKSA6IGlzRXhwciQxKF8pID8gKHNpZ25hbCA9IHRydWUsIHRoaXMuZXhwclJlZihfLmV4cHIpKSA6IF87XG5cbiAgICBjb25zdCBmaWVsZHMgPSBhcnJheShjbXAuZmllbGQpLm1hcChjaGVjayksXG4gICAgICAgICAgb3JkZXJzID0gYXJyYXkoY21wLm9yZGVyKS5tYXAoY2hlY2spO1xuICAgIHJldHVybiBzaWduYWwgPyByZWYodGhpcy5hZGQoQ29tcGFyZSh7XG4gICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgIG9yZGVyczogb3JkZXJzXG4gICAgfSkpKSA6IGNvbXBhcmVSZWYoZmllbGRzLCBvcmRlcnMpO1xuICB9LFxuXG4gIGtleVJlZihmaWVsZHMsIGZsYXQpIHtcbiAgICBsZXQgc2lnbmFsID0gZmFsc2U7XG5cbiAgICBjb25zdCBjaGVjayA9IF8gPT4gaXNTaWduYWwoXykgPyAoc2lnbmFsID0gdHJ1ZSwgcmVmKHNpZ1tfLnNpZ25hbF0pKSA6IF87XG5cbiAgICBjb25zdCBzaWcgPSB0aGlzLnNpZ25hbHM7XG4gICAgZmllbGRzID0gYXJyYXkoZmllbGRzKS5tYXAoY2hlY2spO1xuICAgIHJldHVybiBzaWduYWwgPyByZWYodGhpcy5hZGQoS2V5KHtcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgZmxhdDogZmxhdFxuICAgIH0pKSkgOiBrZXlSZWYoZmllbGRzLCBmbGF0KTtcbiAgfSxcblxuICBzb3J0UmVmKHNvcnQpIHtcbiAgICBpZiAoIXNvcnQpIHJldHVybiBzb3J0OyAvLyBpbmNsdWRpbmcgaWQgZW5zdXJlcyBzdGFibGUgc29ydGluZ1xuXG4gICAgY29uc3QgYSA9IGFnZ3JGaWVsZChzb3J0Lm9wLCBzb3J0LmZpZWxkKSxcbiAgICAgICAgICBvID0gc29ydC5vcmRlciB8fCBBc2NlbmRpbmc7XG4gICAgcmV0dXJuIG8uc2lnbmFsID8gcmVmKHRoaXMuYWRkKENvbXBhcmUoe1xuICAgICAgZmllbGRzOiBhLFxuICAgICAgb3JkZXJzOiB0aGlzLnNpZ25hbFJlZihvLnNpZ25hbClcbiAgICB9KSkpIDogY29tcGFyZVJlZihhLCBvKTtcbiAgfSxcblxuICAvLyAtLS0tXG4gIGV2ZW50KHNvdXJjZSwgdHlwZSkge1xuICAgIGNvbnN0IGtleSA9IHNvdXJjZSArICc6JyArIHR5cGU7XG5cbiAgICBpZiAoIXRoaXMuZXZlbnRzW2tleV0pIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5pZCgpO1xuICAgICAgdGhpcy5zdHJlYW1zLnB1c2goe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZXZlbnRzW2tleV0gPSBpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ldmVudHNba2V5XTtcbiAgfSxcblxuICAvLyAtLS0tXG4gIGhhc093blNpZ25hbChuYW1lKSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5KHRoaXMuc2lnbmFscywgbmFtZSk7XG4gIH0sXG5cbiAgYWRkU2lnbmFsKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaGFzT3duU2lnbmFsKG5hbWUpKSB7XG4gICAgICBlcnJvcignRHVwbGljYXRlIHNpZ25hbCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wID0gdmFsdWUgaW5zdGFuY2VvZiBFbnRyeSA/IHZhbHVlIDogdGhpcy5hZGQob3BlcmF0b3IodmFsdWUpKTtcbiAgICByZXR1cm4gdGhpcy5zaWduYWxzW25hbWVdID0gb3A7XG4gIH0sXG5cbiAgZ2V0U2lnbmFsKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuc2lnbmFsc1tuYW1lXSkge1xuICAgICAgZXJyb3IoJ1VucmVjb2duaXplZCBzaWduYWwgbmFtZTogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zaWduYWxzW25hbWVdO1xuICB9LFxuXG4gIHNpZ25hbFJlZihzKSB7XG4gICAgaWYgKHRoaXMuc2lnbmFsc1tzXSkge1xuICAgICAgcmV0dXJuIHJlZih0aGlzLnNpZ25hbHNbc10pO1xuICAgIH0gZWxzZSBpZiAoIWhhc093blByb3BlcnR5KHRoaXMubGFtYmRhcywgcykpIHtcbiAgICAgIHRoaXMubGFtYmRhc1tzXSA9IHRoaXMuYWRkKG9wZXJhdG9yKG51bGwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmKHRoaXMubGFtYmRhc1tzXSk7XG4gIH0sXG5cbiAgcGFyc2VMYW1iZGFzKCkge1xuICAgIGNvbnN0IGNvZGUgPSBPYmplY3Qua2V5cyh0aGlzLmxhbWJkYXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjb2RlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgcyA9IGNvZGVbaV0sXG4gICAgICAgICAgICBlID0gcGFyc2VFeHByZXNzaW9uKHMsIHRoaXMpLFxuICAgICAgICAgICAgb3AgPSB0aGlzLmxhbWJkYXNbc107XG4gICAgICBvcC5wYXJhbXMgPSBlLiRwYXJhbXM7XG4gICAgICBvcC51cGRhdGUgPSBlLiRleHByO1xuICAgIH1cbiAgfSxcblxuICBwcm9wZXJ0eShzcGVjKSB7XG4gICAgcmV0dXJuIHNwZWMgJiYgc3BlYy5zaWduYWwgPyB0aGlzLnNpZ25hbFJlZihzcGVjLnNpZ25hbCkgOiBzcGVjO1xuICB9LFxuXG4gIG9iamVjdFByb3BlcnR5KHNwZWMpIHtcbiAgICByZXR1cm4gIXNwZWMgfHwgIWlzT2JqZWN0KHNwZWMpID8gc3BlYyA6IHRoaXMuc2lnbmFsUmVmKHNwZWMuc2lnbmFsIHx8IHByb3BlcnR5TGFtYmRhKHNwZWMpKTtcbiAgfSxcblxuICBleHByUmVmKGNvZGUsIG5hbWUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBleHByOiBwYXJzZUV4cHJlc3Npb24oY29kZSwgdGhpcylcbiAgICB9O1xuICAgIGlmIChuYW1lKSBwYXJhbXMuZXhwci4kbmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHJlZih0aGlzLmFkZChFeHByZXNzaW9uKHBhcmFtcykpKTtcbiAgfSxcblxuICBhZGRCaW5kaW5nKG5hbWUsIGJpbmQpIHtcbiAgICBpZiAoIXRoaXMuYmluZGluZ3MpIHtcbiAgICAgIGVycm9yKCdOZXN0ZWQgc2lnbmFscyBkbyBub3Qgc3VwcG9ydCBiaW5kaW5nOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHRoaXMuYmluZGluZ3MucHVzaChleHRlbmQoe1xuICAgICAgc2lnbmFsOiBuYW1lXG4gICAgfSwgYmluZCkpO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgYWRkU2NhbGVQcm9qKG5hbWUsIHRyYW5zZm9ybSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh0aGlzLnNjYWxlcywgbmFtZSkpIHtcbiAgICAgIGVycm9yKCdEdXBsaWNhdGUgc2NhbGUgb3IgcHJvamVjdGlvbiBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHRoaXMuc2NhbGVzW25hbWVdID0gdGhpcy5hZGQodHJhbnNmb3JtKTtcbiAgfSxcblxuICBhZGRTY2FsZShuYW1lLCBwYXJhbXMpIHtcbiAgICB0aGlzLmFkZFNjYWxlUHJvaihuYW1lLCBTY2FsZShwYXJhbXMpKTtcbiAgfSxcblxuICBhZGRQcm9qZWN0aW9uKG5hbWUsIHBhcmFtcykge1xuICAgIHRoaXMuYWRkU2NhbGVQcm9qKG5hbWUsIFByb2plY3Rpb24ocGFyYW1zKSk7XG4gIH0sXG5cbiAgZ2V0U2NhbGUobmFtZSkge1xuICAgIGlmICghdGhpcy5zY2FsZXNbbmFtZV0pIHtcbiAgICAgIGVycm9yKCdVbnJlY29nbml6ZWQgc2NhbGUgbmFtZTogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zY2FsZXNbbmFtZV07XG4gIH0sXG5cbiAgc2NhbGVSZWYobmFtZSkge1xuICAgIHJldHVybiByZWYodGhpcy5nZXRTY2FsZShuYW1lKSk7XG4gIH0sXG5cbiAgc2NhbGVUeXBlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY2FsZShuYW1lKS5wYXJhbXMudHlwZTtcbiAgfSxcblxuICBwcm9qZWN0aW9uUmVmKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZVJlZihuYW1lKTtcbiAgfSxcblxuICBwcm9qZWN0aW9uVHlwZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVUeXBlKG5hbWUpO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgYWRkRGF0YShuYW1lLCBkYXRhU2NvcGUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodGhpcy5kYXRhLCBuYW1lKSkge1xuICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBkYXRhIHNldCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFbbmFtZV0gPSBkYXRhU2NvcGU7XG4gIH0sXG5cbiAgZ2V0RGF0YShuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmRhdGFbbmFtZV0pIHtcbiAgICAgIGVycm9yKCdVbmRlZmluZWQgZGF0YSBzZXQgbmFtZTogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhW25hbWVdO1xuICB9LFxuXG4gIGFkZERhdGFQaXBlbGluZShuYW1lLCBlbnRyaWVzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHRoaXMuZGF0YSwgbmFtZSkpIHtcbiAgICAgIGVycm9yKCdEdXBsaWNhdGUgZGF0YSBzZXQgbmFtZTogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hZGREYXRhKG5hbWUsIERhdGFTY29wZS5mcm9tRW50cmllcyh0aGlzLCBlbnRyaWVzKSk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gcHJvcGVydHlMYW1iZGEoc3BlYykge1xuICByZXR1cm4gKGlzQXJyYXkoc3BlYykgPyBhcnJheUxhbWJkYSA6IG9iamVjdExhbWJkYSkoc3BlYyk7XG59XG5cbmZ1bmN0aW9uIGFycmF5TGFtYmRhKGFycmF5KSB7XG4gIGNvbnN0IG4gPSBhcnJheS5sZW5ndGg7XG4gIGxldCBjb2RlID0gJ1snO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhcnJheVtpXTtcbiAgICBjb2RlICs9IChpID4gMCA/ICcsJyA6ICcnKSArIChpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZS5zaWduYWwgfHwgcHJvcGVydHlMYW1iZGEodmFsdWUpIDogc3RyaW5nVmFsdWUodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiBjb2RlICsgJ10nO1xufVxuXG5mdW5jdGlvbiBvYmplY3RMYW1iZGEob2JqKSB7XG4gIGxldCBjb2RlID0gJ3snLFxuICAgICAgaSA9IDAsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZTtcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICB2YWx1ZSA9IG9ialtrZXldO1xuICAgIGNvZGUgKz0gKCsraSA+IDEgPyAnLCcgOiAnJykgKyBzdHJpbmdWYWx1ZShrZXkpICsgJzonICsgKGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlLnNpZ25hbCB8fCBwcm9wZXJ0eUxhbWJkYSh2YWx1ZSkgOiBzdHJpbmdWYWx1ZSh2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIGNvZGUgKyAnfSc7XG59XG5cbi8qKlxuICogU3RhbmRhcmQgY29uZmlndXJhdGlvbiBkZWZhdWx0cyBmb3IgVmVnYSBzcGVjaWZpY2F0aW9uIHBhcnNpbmcuXG4gKiBVc2VycyBjYW4gcHJvdmlkZSB0aGVpciBvd24gKHN1Yi0pc2V0IG9mIHRoZXNlIGRlZmF1bHQgdmFsdWVzXG4gKiBieSBwYXNzaW5nIGluIGEgY29uZmlnIG9iamVjdCB0byB0aGUgdG9wLWxldmVsIHBhcnNlIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdHMgKCkge1xuICBjb25zdCBkZWZhdWx0Rm9udCA9ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgZGVmYXVsdFN5bWJvbFNpemUgPSAzMCxcbiAgICAgICAgZGVmYXVsdFN0cm9rZVdpZHRoID0gMixcbiAgICAgICAgZGVmYXVsdENvbG9yID0gJyM0Yzc4YTgnLFxuICAgICAgICBibGFjayA9ICcjMDAwJyxcbiAgICAgICAgZ3JheSA9ICcjODg4JyxcbiAgICAgICAgbGlnaHRHcmF5ID0gJyNkZGQnO1xuICByZXR1cm4ge1xuICAgIC8vIGRlZmF1bHQgdmlzdWFsaXphdGlvbiBkZXNjcmlwdGlvblxuICAgIGRlc2NyaXB0aW9uOiAnVmVnYSB2aXN1YWxpemF0aW9uJyxcbiAgICAvLyBkZWZhdWx0IHBhZGRpbmcgYXJvdW5kIHZpc3VhbGl6YXRpb25cbiAgICBwYWRkaW5nOiAwLFxuICAgIC8vIGRlZmF1bHQgZm9yIGF1dG9tYXRpYyBzaXppbmc7IG9wdGlvbnM6ICdub25lJywgJ3BhZCcsICdmaXQnXG4gICAgLy8gb3IgcHJvdmlkZSBhbiBvYmplY3QgKGUuZy4sIHsndHlwZSc6ICdwYWQnLCAncmVzaXplJzogdHJ1ZX0pXG4gICAgYXV0b3NpemU6ICdwYWQnLFxuICAgIC8vIGRlZmF1bHQgdmlldyBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgLy8gY292ZXJzIHRoZSBlbnRpcmUgdmlldyBjb21wb25lbnRcbiAgICBiYWNrZ3JvdW5kOiBudWxsLFxuICAgIC8vIGRlZmF1bHQgZXZlbnQgaGFuZGxpbmcgY29uZmlndXJhdGlvblxuICAgIC8vIHByZXZlbnREZWZhdWx0IGZvciB2aWV3LXNvdXJjZWQgZXZlbnQgdHlwZXMgZXhjZXB0ICd3aGVlbCdcbiAgICBldmVudHM6IHtcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGFsbG93OiBbJ3doZWVsJ11cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciB0b3AtbGV2ZWwgZ3JvdXAgbWFya3NcbiAgICAvLyBhY2NlcHRzIG1hcmsgcHJvcGVydGllcyAoZmlsbCwgc3Ryb2tlLCBldGMpXG4gICAgLy8gY292ZXJzIHRoZSBkYXRhIHJlY3RhbmdsZSB3aXRoaW4gZ3JvdXAgd2lkdGgvaGVpZ2h0XG4gICAgZ3JvdXA6IG51bGwsXG4gICAgLy8gZGVmYXVsdHMgZm9yIGJhc2ljIG1hcmsgdHlwZXNcbiAgICAvLyBlYWNoIHN1YnNldCBhY2NlcHRzIG1hcmsgcHJvcGVydGllcyAoZmlsbCwgc3Ryb2tlLCBldGMpXG4gICAgbWFyazogbnVsbCxcbiAgICBhcmM6IHtcbiAgICAgIGZpbGw6IGRlZmF1bHRDb2xvclxuICAgIH0sXG4gICAgYXJlYToge1xuICAgICAgZmlsbDogZGVmYXVsdENvbG9yXG4gICAgfSxcbiAgICBpbWFnZTogbnVsbCxcbiAgICBsaW5lOiB7XG4gICAgICBzdHJva2U6IGRlZmF1bHRDb2xvcixcbiAgICAgIHN0cm9rZVdpZHRoOiBkZWZhdWx0U3Ryb2tlV2lkdGhcbiAgICB9LFxuICAgIHBhdGg6IHtcbiAgICAgIHN0cm9rZTogZGVmYXVsdENvbG9yXG4gICAgfSxcbiAgICByZWN0OiB7XG4gICAgICBmaWxsOiBkZWZhdWx0Q29sb3JcbiAgICB9LFxuICAgIHJ1bGU6IHtcbiAgICAgIHN0cm9rZTogYmxhY2tcbiAgICB9LFxuICAgIHNoYXBlOiB7XG4gICAgICBzdHJva2U6IGRlZmF1bHRDb2xvclxuICAgIH0sXG4gICAgc3ltYm9sOiB7XG4gICAgICBmaWxsOiBkZWZhdWx0Q29sb3IsXG4gICAgICBzaXplOiA2NFxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgZmlsbDogYmxhY2ssXG4gICAgICBmb250OiBkZWZhdWx0Rm9udCxcbiAgICAgIGZvbnRTaXplOiAxMVxuICAgIH0sXG4gICAgdHJhaWw6IHtcbiAgICAgIGZpbGw6IGRlZmF1bHRDb2xvcixcbiAgICAgIHNpemU6IGRlZmF1bHRTdHJva2VXaWR0aFxuICAgIH0sXG4gICAgLy8gc3R5bGUgZGVmaW5pdGlvbnNcbiAgICBzdHlsZToge1xuICAgICAgLy8gYXhpcyAmIGxlZ2VuZCBsYWJlbHNcbiAgICAgICdndWlkZS1sYWJlbCc6IHtcbiAgICAgICAgZmlsbDogYmxhY2ssXG4gICAgICAgIGZvbnQ6IGRlZmF1bHRGb250LFxuICAgICAgICBmb250U2l6ZTogMTBcbiAgICAgIH0sXG4gICAgICAvLyBheGlzICYgbGVnZW5kIHRpdGxlc1xuICAgICAgJ2d1aWRlLXRpdGxlJzoge1xuICAgICAgICBmaWxsOiBibGFjayxcbiAgICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICAgIGZvbnRTaXplOiAxMSxcbiAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICB9LFxuICAgICAgLy8gaGVhZGVycywgaW5jbHVkaW5nIGNoYXJ0IHRpdGxlXG4gICAgICAnZ3JvdXAtdGl0bGUnOiB7XG4gICAgICAgIGZpbGw6IGJsYWNrLFxuICAgICAgICBmb250OiBkZWZhdWx0Rm9udCxcbiAgICAgICAgZm9udFNpemU6IDEzLFxuICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCdcbiAgICAgIH0sXG4gICAgICAvLyBjaGFydCBzdWJ0aXRsZVxuICAgICAgJ2dyb3VwLXN1YnRpdGxlJzoge1xuICAgICAgICBmaWxsOiBibGFjayxcbiAgICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICAgIGZvbnRTaXplOiAxMlxuICAgICAgfSxcbiAgICAgIC8vIGRlZmF1bHRzIGZvciBzdHlsZWQgcG9pbnQgbWFya3MgaW4gVmVnYS1MaXRlXG4gICAgICBwb2ludDoge1xuICAgICAgICBzaXplOiBkZWZhdWx0U3ltYm9sU2l6ZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IGRlZmF1bHRTdHJva2VXaWR0aCxcbiAgICAgICAgc2hhcGU6ICdjaXJjbGUnXG4gICAgICB9LFxuICAgICAgY2lyY2xlOiB7XG4gICAgICAgIHNpemU6IGRlZmF1bHRTeW1ib2xTaXplLFxuICAgICAgICBzdHJva2VXaWR0aDogZGVmYXVsdFN0cm9rZVdpZHRoXG4gICAgICB9LFxuICAgICAgc3F1YXJlOiB7XG4gICAgICAgIHNpemU6IGRlZmF1bHRTeW1ib2xTaXplLFxuICAgICAgICBzdHJva2VXaWR0aDogZGVmYXVsdFN0cm9rZVdpZHRoLFxuICAgICAgICBzaGFwZTogJ3NxdWFyZSdcbiAgICAgIH0sXG4gICAgICAvLyBkZWZhdWx0cyBmb3Igc3R5bGVkIGdyb3VwIG1hcmtzIGluIFZlZ2EtTGl0ZVxuICAgICAgY2VsbDoge1xuICAgICAgICBmaWxsOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBzdHJva2U6IGxpZ2h0R3JheVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gZGVmYXVsdHMgZm9yIHRpdGxlXG4gICAgdGl0bGU6IHtcbiAgICAgIG9yaWVudDogJ3RvcCcsXG4gICAgICBhbmNob3I6ICdtaWRkbGUnLFxuICAgICAgb2Zmc2V0OiA0LFxuICAgICAgc3VidGl0bGVQYWRkaW5nOiAzXG4gICAgfSxcbiAgICAvLyBkZWZhdWx0cyBmb3IgYXhlc1xuICAgIGF4aXM6IHtcbiAgICAgIG1pbkV4dGVudDogMCxcbiAgICAgIG1heEV4dGVudDogMjAwLFxuICAgICAgYmFuZFBvc2l0aW9uOiAwLjUsXG4gICAgICBkb21haW46IHRydWUsXG4gICAgICBkb21haW5XaWR0aDogMSxcbiAgICAgIGRvbWFpbkNvbG9yOiBncmF5LFxuICAgICAgZ3JpZDogZmFsc2UsXG4gICAgICBncmlkV2lkdGg6IDEsXG4gICAgICBncmlkQ29sb3I6IGxpZ2h0R3JheSxcbiAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgIGxhYmVsQW5nbGU6IDAsXG4gICAgICBsYWJlbExpbWl0OiAxODAsXG4gICAgICBsYWJlbE9mZnNldDogMCxcbiAgICAgIGxhYmVsUGFkZGluZzogMixcbiAgICAgIHRpY2tzOiB0cnVlLFxuICAgICAgdGlja0NvbG9yOiBncmF5LFxuICAgICAgdGlja09mZnNldDogMCxcbiAgICAgIHRpY2tSb3VuZDogdHJ1ZSxcbiAgICAgIHRpY2tTaXplOiA1LFxuICAgICAgdGlja1dpZHRoOiAxLFxuICAgICAgdGl0bGVQYWRkaW5nOiA0XG4gICAgfSxcbiAgICAvLyBjb3JyZWN0aW9uIGZvciBjZW50ZXJpbmcgYmlhc1xuICAgIGF4aXNCYW5kOiB7XG4gICAgICB0aWNrT2Zmc2V0OiAtMC41XG4gICAgfSxcbiAgICAvLyBkZWZhdWx0cyBmb3IgY2FydG9ncmFwaGljIHByb2plY3Rpb25cbiAgICBwcm9qZWN0aW9uOiB7XG4gICAgICB0eXBlOiAnbWVyY2F0b3InXG4gICAgfSxcbiAgICAvLyBkZWZhdWx0cyBmb3IgbGVnZW5kc1xuICAgIGxlZ2VuZDoge1xuICAgICAgb3JpZW50OiAncmlnaHQnLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIGdyaWRBbGlnbjogJ2VhY2gnLFxuICAgICAgY29sdW1uUGFkZGluZzogMTAsXG4gICAgICByb3dQYWRkaW5nOiAyLFxuICAgICAgc3ltYm9sRGlyZWN0aW9uOiAndmVydGljYWwnLFxuICAgICAgZ3JhZGllbnREaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gICAgICBncmFkaWVudExlbmd0aDogMjAwLFxuICAgICAgZ3JhZGllbnRUaGlja25lc3M6IDE2LFxuICAgICAgZ3JhZGllbnRTdHJva2VDb2xvcjogbGlnaHRHcmF5LFxuICAgICAgZ3JhZGllbnRTdHJva2VXaWR0aDogMCxcbiAgICAgIGdyYWRpZW50TGFiZWxPZmZzZXQ6IDIsXG4gICAgICBsYWJlbEFsaWduOiAnbGVmdCcsXG4gICAgICBsYWJlbEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIGxhYmVsTGltaXQ6IDE2MCxcbiAgICAgIGxhYmVsT2Zmc2V0OiA0LFxuICAgICAgbGFiZWxPdmVybGFwOiB0cnVlLFxuICAgICAgc3ltYm9sTGltaXQ6IDMwLFxuICAgICAgc3ltYm9sVHlwZTogJ2NpcmNsZScsXG4gICAgICBzeW1ib2xTaXplOiAxMDAsXG4gICAgICBzeW1ib2xPZmZzZXQ6IDAsXG4gICAgICBzeW1ib2xTdHJva2VXaWR0aDogMS41LFxuICAgICAgc3ltYm9sQmFzZUZpbGxDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgIHN5bWJvbEJhc2VTdHJva2VDb2xvcjogZ3JheSxcbiAgICAgIHRpdGxlTGltaXQ6IDE4MCxcbiAgICAgIHRpdGxlT3JpZW50OiAndG9wJyxcbiAgICAgIHRpdGxlUGFkZGluZzogNSxcbiAgICAgIGxheW91dDoge1xuICAgICAgICBvZmZzZXQ6IDE4LFxuICAgICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgbGVmdDoge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJ1xuICAgICAgICB9LFxuICAgICAgICByaWdodDoge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBkZWZhdWx0cyBmb3Igc2NhbGUgcmFuZ2VzXG4gICAgcmFuZ2U6IHtcbiAgICAgIGNhdGVnb3J5OiB7XG4gICAgICAgIHNjaGVtZTogJ3RhYmxlYXUxMCdcbiAgICAgIH0sXG4gICAgICBvcmRpbmFsOiB7XG4gICAgICAgIHNjaGVtZTogJ2JsdWVzJ1xuICAgICAgfSxcbiAgICAgIGhlYXRtYXA6IHtcbiAgICAgICAgc2NoZW1lOiAneWVsbG93Z3JlZW5ibHVlJ1xuICAgICAgfSxcbiAgICAgIHJhbXA6IHtcbiAgICAgICAgc2NoZW1lOiAnYmx1ZXMnXG4gICAgICB9LFxuICAgICAgZGl2ZXJnaW5nOiB7XG4gICAgICAgIHNjaGVtZTogJ2JsdWVvcmFuZ2UnLFxuICAgICAgICBleHRlbnQ6IFsxLCAwXVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogWydjaXJjbGUnLCAnc3F1YXJlJywgJ3RyaWFuZ2xlLXVwJywgJ2Nyb3NzJywgJ2RpYW1vbmQnLCAndHJpYW5nbGUtcmlnaHQnLCAndHJpYW5nbGUtZG93bicsICd0cmlhbmdsZS1sZWZ0J11cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlIChzcGVjLCBjb25maWcsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc09iamVjdChzcGVjKSkge1xuICAgIGVycm9yKCdJbnB1dCBWZWdhIHNwZWNpZmljYXRpb24gbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyhkZWZhdWx0cygpLCBjb25maWcsIHNwZWMuY29uZmlnKTtcbiAgcmV0dXJuIHBhcnNlVmlldyhzcGVjLCBuZXcgU2NvcGUoY29uZmlnLCBvcHRpb25zKSkudG9SdW50aW1lKCk7XG59XG5cbmV4cG9ydCB7IEF4aXNEb21haW5Sb2xlLCBBeGlzR3JpZFJvbGUsIEF4aXNMYWJlbFJvbGUsIEF4aXNSb2xlLCBBeGlzVGlja1JvbGUsIEF4aXNUaXRsZVJvbGUsIERhdGFTY29wZSwgRnJhbWVSb2xlLCBMZWdlbmRFbnRyeVJvbGUsIExlZ2VuZExhYmVsUm9sZSwgTGVnZW5kUm9sZSwgTGVnZW5kU3ltYm9sUm9sZSwgTGVnZW5kVGl0bGVSb2xlLCBNYXJrUm9sZSwgU2NvcGUsIFNjb3BlUm9sZSwgZGVmYXVsdHMgYXMgY29uZmlnLCBwYXJzZSwgcGFyc2VTaWduYWwgYXMgc2lnbmFsLCBwYXJzZVNpZ25hbFVwZGF0ZXMgYXMgc2lnbmFsVXBkYXRlcywgcGFyc2VTdHJlYW0gYXMgc3RyZWFtIH07XG4iLCJpbXBvcnQgeyBnZW9QYXRoLCBnZW9BbGJlcnMsIGdlb0FsYmVyc1VzYSwgZ2VvQXppbXV0aGFsRXF1YWxBcmVhLCBnZW9BemltdXRoYWxFcXVpZGlzdGFudCwgZ2VvQ29uaWNDb25mb3JtYWwsIGdlb0NvbmljRXF1YWxBcmVhLCBnZW9Db25pY0VxdWlkaXN0YW50LCBnZW9FcXVhbEVhcnRoLCBnZW9FcXVpcmVjdGFuZ3VsYXIsIGdlb0dub21vbmljLCBnZW9JZGVudGl0eSwgZ2VvTWVyY2F0b3IsIGdlb05hdHVyYWxFYXJ0aDEsIGdlb09ydGhvZ3JhcGhpYywgZ2VvU3RlcmVvZ3JhcGhpYywgZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yIH0gZnJvbSAnZDMtZ2VvJztcbmltcG9ydCB7IGdlb01vbGx3ZWlkZSB9IGZyb20gJ2QzLWdlby1wcm9qZWN0aW9uJztcblxuY29uc3QgZGVmYXVsdFBhdGggPSBnZW9QYXRoKCk7XG5jb25zdCBwcm9qZWN0aW9uUHJvcGVydGllcyA9IFsvLyBzdGFuZGFyZCBwcm9wZXJ0aWVzIGluIGQzLWdlb1xuJ2NsaXBBbmdsZScsICdjbGlwRXh0ZW50JywgJ3NjYWxlJywgJ3RyYW5zbGF0ZScsICdjZW50ZXInLCAncm90YXRlJywgJ3BhcmFsbGVscycsICdwcmVjaXNpb24nLCAncmVmbGVjdFgnLCAncmVmbGVjdFknLCAvLyBleHRlbmRlZCBwcm9wZXJ0aWVzIGluIGQzLWdlby1wcm9qZWN0aW9uc1xuJ2NvZWZmaWNpZW50JywgJ2Rpc3RhbmNlJywgJ2ZyYWN0aW9uJywgJ2xvYmVzJywgJ3BhcmFsbGVsJywgJ3JhZGl1cycsICdyYXRpbycsICdzcGFjaW5nJywgJ3RpbHQnXTtcbi8qKlxuICogQXVnbWVudCBwcm9qZWN0aW9ucyB3aXRoIHRoZWlyIHR5cGUgYW5kIGEgY29weSBtZXRob2QuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHR5cGUsIGNvbnN0cnVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcm9qZWN0aW9uKCkge1xuICAgIGNvbnN0IHAgPSBjb25zdHJ1Y3RvcigpO1xuICAgIHAudHlwZSA9IHR5cGU7XG4gICAgcC5wYXRoID0gZ2VvUGF0aCgpLnByb2plY3Rpb24ocCk7XG5cbiAgICBwLmNvcHkgPSBwLmNvcHkgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgYyA9IHByb2plY3Rpb24oKTtcbiAgICAgIHByb2plY3Rpb25Qcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIGlmIChwW3Byb3BdKSBjW3Byb3BdKHBbcHJvcF0oKSk7XG4gICAgICB9KTtcbiAgICAgIGMucGF0aC5wb2ludFJhZGl1cyhwLnBhdGgucG9pbnRSYWRpdXMoKSk7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2plY3Rpb24odHlwZSwgcHJvaikge1xuICBpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aW9uIHR5cGUgbXVzdCBiZSBhIG5hbWUgc3RyaW5nLicpO1xuICB9XG5cbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBwcm9qZWN0aW9uc1t0eXBlXSA9IGNyZWF0ZSh0eXBlLCBwcm9qKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvamVjdGlvbnNbdHlwZV0gfHwgbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UHJvamVjdGlvblBhdGgocHJvaikge1xuICByZXR1cm4gcHJvaiAmJiBwcm9qLnBhdGggfHwgZGVmYXVsdFBhdGg7XG59XG5jb25zdCBwcm9qZWN0aW9ucyA9IHtcbiAgLy8gYmFzZSBkMy1nZW8gcHJvamVjdGlvbiB0eXBlc1xuICBhbGJlcnM6IGdlb0FsYmVycyxcbiAgYWxiZXJzdXNhOiBnZW9BbGJlcnNVc2EsXG4gIGF6aW11dGhhbGVxdWFsYXJlYTogZ2VvQXppbXV0aGFsRXF1YWxBcmVhLFxuICBhemltdXRoYWxlcXVpZGlzdGFudDogZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnQsXG4gIGNvbmljY29uZm9ybWFsOiBnZW9Db25pY0NvbmZvcm1hbCxcbiAgY29uaWNlcXVhbGFyZWE6IGdlb0NvbmljRXF1YWxBcmVhLFxuICBjb25pY2VxdWlkaXN0YW50OiBnZW9Db25pY0VxdWlkaXN0YW50LFxuICBlcXVhbEVhcnRoOiBnZW9FcXVhbEVhcnRoLFxuICBlcXVpcmVjdGFuZ3VsYXI6IGdlb0VxdWlyZWN0YW5ndWxhcixcbiAgZ25vbW9uaWM6IGdlb0dub21vbmljLFxuICBpZGVudGl0eTogZ2VvSWRlbnRpdHksXG4gIG1lcmNhdG9yOiBnZW9NZXJjYXRvcixcbiAgbW9sbHdlaWRlOiBnZW9Nb2xsd2VpZGUsXG4gIG5hdHVyYWxFYXJ0aDE6IGdlb05hdHVyYWxFYXJ0aDEsXG4gIG9ydGhvZ3JhcGhpYzogZ2VvT3J0aG9ncmFwaGljLFxuICBzdGVyZW9ncmFwaGljOiBnZW9TdGVyZW9ncmFwaGljLFxuICB0cmFuc3ZlcnNlbWVyY2F0b3I6IGdlb1RyYW5zdmVyc2VNZXJjYXRvclxufTtcblxuZm9yIChjb25zdCBrZXkgaW4gcHJvamVjdGlvbnMpIHtcbiAgcHJvamVjdGlvbihrZXksIHByb2plY3Rpb25zW2tleV0pO1xufVxuXG5leHBvcnQgeyBnZXRQcm9qZWN0aW9uUGF0aCwgcHJvamVjdGlvbiwgcHJvamVjdGlvblByb3BlcnRpZXMgfTtcbiIsImltcG9ydCB7IHJlZ3Jlc3Npb25Mb2Vzcywgc2FtcGxlQ3VydmUsIHJlZ3Jlc3Npb25MaW5lYXIsIHJlZ3Jlc3Npb25Mb2csIHJlZ3Jlc3Npb25FeHAsIHJlZ3Jlc3Npb25Qb3csIHJlZ3Jlc3Npb25RdWFkLCByZWdyZXNzaW9uUG9seSB9IGZyb20gJ3ZlZ2Etc3RhdGlzdGljcyc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0sIGluZ2VzdCB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGFjY2Vzc29yTmFtZSwgaGFzT3duUHJvcGVydHksIGVycm9yLCBleHRlbnQgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5mdW5jdGlvbiBwYXJ0aXRpb24gKGRhdGEsIGdyb3VwYnkpIHtcbiAgdmFyIGdyb3VwcyA9IFtdLFxuICAgICAgZ2V0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gZih0KTtcbiAgfSxcbiAgICAgIG1hcCxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgdCxcbiAgICAgIGssXG4gICAgICBnOyAvLyBwYXJ0aXRpb24gZGF0YSBwb2ludHMgaW50byBzdGFjayBncm91cHNcblxuXG4gIGlmIChncm91cGJ5ID09IG51bGwpIHtcbiAgICBncm91cHMucHVzaChkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcCA9IHt9LCBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gZGF0YVtpXTtcbiAgICAgIGsgPSBncm91cGJ5Lm1hcChnZXQpO1xuICAgICAgZyA9IG1hcFtrXTtcblxuICAgICAgaWYgKCFnKSB7XG4gICAgICAgIG1hcFtrXSA9IGcgPSBbXTtcbiAgICAgICAgZy5kaW1zID0gaztcbiAgICAgICAgZ3JvdXBzLnB1c2goZyk7XG4gICAgICB9XG5cbiAgICAgIGcucHVzaCh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ3JvdXBzO1xufVxuXG4vKipcbiAqIENvbXB1dGUgbG9jYWxseS13ZWlnaHRlZCByZWdyZXNzaW9uIGZpdHMgZm9yIG9uZSBvciBtb3JlIGRhdGEgZ3JvdXBzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy54IC0gQW4gYWNjZXNzb3IgZm9yIHRoZSBwcmVkaWN0b3IgZGF0YSBmaWVsZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLnkgLSBBbiBhY2Nlc3NvciBmb3IgdGhlIHByZWRpY3RlZCBkYXRhIGZpZWxkLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29ycyB0byBncm91cGJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuYmFuZHdpZHRoPTAuM10gLSBUaGUgbG9lc3MgYmFuZHdpZHRoLlxuICovXG5cbmZ1bmN0aW9uIExvZXNzKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuTG9lc3MuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnTG9lc3MnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAneCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3knLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYmFuZHdpZHRoJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMC4zXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoTG9lc3MsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG5cbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgcHVsc2UuY2hhbmdlZCgpIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgICAgICBncm91cHMgPSBwYXJ0aXRpb24oc291cmNlLCBfLmdyb3VwYnkpLFxuICAgICAgICAgICAgbmFtZXMgPSAoXy5ncm91cGJ5IHx8IFtdKS5tYXAoYWNjZXNzb3JOYW1lKSxcbiAgICAgICAgICAgIG0gPSBuYW1lcy5sZW5ndGgsXG4gICAgICAgICAgICBhcyA9IF8uYXMgfHwgW2FjY2Vzc29yTmFtZShfLngpLCBhY2Nlc3Nvck5hbWUoXy55KV0sXG4gICAgICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgIGdyb3Vwcy5mb3JFYWNoKGcgPT4ge1xuICAgICAgICByZWdyZXNzaW9uTG9lc3MoZywgXy54LCBfLnksIF8uYmFuZHdpZHRoIHx8IDAuMykuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICBjb25zdCB0ID0ge307XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgICAgICAgdFtuYW1lc1tpXV0gPSBnLmRpbXNbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFthc1swXV0gPSBwWzBdO1xuICAgICAgICAgIHRbYXNbMV1dID0gcFsxXTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChpbmdlc3QodCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IG91dC5hZGQgPSBvdXQuc291cmNlID0gdmFsdWVzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmNvbnN0IE1ldGhvZHMgPSB7XG4gIGxpbmVhcjogcmVncmVzc2lvbkxpbmVhcixcbiAgbG9nOiByZWdyZXNzaW9uTG9nLFxuICBleHA6IHJlZ3Jlc3Npb25FeHAsXG4gIHBvdzogcmVncmVzc2lvblBvdyxcbiAgcXVhZDogcmVncmVzc2lvblF1YWQsXG4gIHBvbHk6IHJlZ3Jlc3Npb25Qb2x5XG59O1xuXG5jb25zdCBkZWdyZWVzT2ZGcmVlZG9tID0gKG1ldGhvZCwgb3JkZXIpID0+IG1ldGhvZCA9PT0gJ3BvbHknID8gb3JkZXIgOiBtZXRob2QgPT09ICdxdWFkJyA/IDIgOiAxO1xuLyoqXG4gKiBDb21wdXRlIHJlZ3Jlc3Npb24gZml0cyBmb3Igb25lIG9yIG1vcmUgZGF0YSBncm91cHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLnggLSBBbiBhY2Nlc3NvciBmb3IgdGhlIHByZWRpY3RvciBkYXRhIGZpZWxkLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMueSAtIEFuIGFjY2Vzc29yIGZvciB0aGUgcHJlZGljdGVkIGRhdGEgZmllbGQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5tZXRob2Q9J2xpbmVhciddIC0gVGhlIHJlZ3Jlc3Npb24gbWV0aG9kIHRvIGFwcGx5LlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29ycyB0byBncm91cGJ5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLmV4dGVudF0gLSBUaGUgZG9tYWluIGV4dGVudCBvdmVyIHdoaWNoIHRvIHBsb3QgdGhlIHJlZ3Jlc3Npb24gbGluZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLm9yZGVyPTNdIC0gVGhlIHBvbHlub21pYWwgb3JkZXIuIE9ubHkgYXBwbGllcyB0byB0aGUgJ3BvbHknIG1ldGhvZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIFJlZ3Jlc3Npb24ocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5SZWdyZXNzaW9uLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1JlZ3Jlc3Npb24nLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAneCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3knLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ2xpbmVhcicsXG4gICAgJ3ZhbHVlcyc6IE9iamVjdC5rZXlzKE1ldGhvZHMpXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcmRlcicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDNcbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYXJhbXMnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhSZWdyZXNzaW9uLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpO1xuXG4gICAgaWYgKCF0aGlzLnZhbHVlIHx8IHB1bHNlLmNoYW5nZWQoKSB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICAgICAgZ3JvdXBzID0gcGFydGl0aW9uKHNvdXJjZSwgXy5ncm91cGJ5KSxcbiAgICAgICAgICAgIG5hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgICAgICBtZXRob2QgPSBfLm1ldGhvZCB8fCAnbGluZWFyJyxcbiAgICAgICAgICAgIG9yZGVyID0gXy5vcmRlciB8fCAzLFxuICAgICAgICAgICAgZG9mID0gZGVncmVlc09mRnJlZWRvbShtZXRob2QsIG9yZGVyKSxcbiAgICAgICAgICAgIGFzID0gXy5hcyB8fCBbYWNjZXNzb3JOYW1lKF8ueCksIGFjY2Vzc29yTmFtZShfLnkpXSxcbiAgICAgICAgICAgIGZpdCA9IE1ldGhvZHNbbWV0aG9kXSxcbiAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgbGV0IGRvbWFpbiA9IF8uZXh0ZW50O1xuXG4gICAgICBpZiAoIWhhc093blByb3BlcnR5KE1ldGhvZHMsIG1ldGhvZCkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcmVncmVzc2lvbiBtZXRob2Q6ICcgKyBtZXRob2QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9tYWluICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2xvZycgJiYgZG9tYWluWzBdIDw9IDApIHtcbiAgICAgICAgICBwdWxzZS5kYXRhZmxvdy53YXJuKCdJZ25vcmluZyBleHRlbnQgd2l0aCB2YWx1ZXMgPD0gMCBmb3IgbG9nIHJlZ3Jlc3Npb24uJyk7XG4gICAgICAgICAgZG9tYWluID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBncm91cHMuZm9yRWFjaChnID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGcubGVuZ3RoO1xuXG4gICAgICAgIGlmIChuIDw9IGRvZikge1xuICAgICAgICAgIHB1bHNlLmRhdGFmbG93Lndhcm4oJ1NraXBwaW5nIHJlZ3Jlc3Npb24gd2l0aCBtb3JlIHBhcmFtZXRlcnMgdGhhbiBkYXRhIHBvaW50cy4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb2RlbCA9IGZpdChnLCBfLngsIF8ueSwgb3JkZXIpO1xuXG4gICAgICAgIGlmIChfLnBhcmFtcykge1xuICAgICAgICAgIC8vIGlmIHBhcmFtZXRlciB2ZWN0b3JzIHJlcXVlc3RlZCByZXR1cm4gdGhvc2VcbiAgICAgICAgICB2YWx1ZXMucHVzaChpbmdlc3Qoe1xuICAgICAgICAgICAga2V5czogZy5kaW1zLFxuICAgICAgICAgICAgY29lZjogbW9kZWwuY29lZixcbiAgICAgICAgICAgIHJTcXVhcmVkOiBtb2RlbC5yU3F1YXJlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkb20gPSBkb21haW4gfHwgZXh0ZW50KGcsIF8ueCksXG4gICAgICAgICAgICAgIGFkZCA9IHAgPT4ge1xuICAgICAgICAgIGNvbnN0IHQgPSB7fTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRbbmFtZXNbaV1dID0gZy5kaW1zW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRbYXNbMF1dID0gcFswXTtcbiAgICAgICAgICB0W2FzWzFdXSA9IHBbMV07XG4gICAgICAgICAgdmFsdWVzLnB1c2goaW5nZXN0KHQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWV0aG9kID09PSAnbGluZWFyJykge1xuICAgICAgICAgIC8vIGZvciBsaW5lYXIgcmVncmVzc2lvbiB3ZSBvbmx5IG5lZWQgdGhlIGVuZCBwb2ludHNcbiAgICAgICAgICBkb20uZm9yRWFjaCh4ID0+IGFkZChbeCwgbW9kZWwucHJlZGljdCh4KV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2UgcmV0dXJuIHRyZW5kIGxpbmUgc2FtcGxlIHBvaW50c1xuICAgICAgICAgIHNhbXBsZUN1cnZlKG1vZGVsLnByZWRpY3QsIGRvbSwgMjUsIDIwMCkuZm9yRWFjaChhZGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSBvdXQuYWRkID0gb3V0LnNvdXJjZSA9IHZhbHVlcztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5leHBvcnQgeyBMb2VzcyBhcyBsb2VzcywgUmVncmVzc2lvbiBhcyByZWdyZXNzaW9uIH07XG4iLCJpbXBvcnQgeyB0b1NldCwgc3RyaW5nVmFsdWUsIGVycm9yLCBpc0FycmF5LCBpc09iamVjdCwgaGFzT3duUHJvcGVydHksIGFjY2Vzc29yLCBrZXksIGZpZWxkLCBhcnJheSwgY29tcGFyZSwgdHJ1dGh5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHR1cGxlaWQgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcblxuLyoqXG4gKiBQYXJzZSBhIHNlcmlhbGl6ZWQgZGF0YWZsb3cgc3BlY2lmaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHNwZWMpIHtcbiAgY29uc3QgY3R4ID0gdGhpcyxcbiAgICAgICAgb3BlcmF0b3JzID0gc3BlYy5vcGVyYXRvcnMgfHwgW107IC8vIHBhcnNlIGJhY2tncm91bmRcblxuICBpZiAoc3BlYy5iYWNrZ3JvdW5kKSB7XG4gICAgY3R4LmJhY2tncm91bmQgPSBzcGVjLmJhY2tncm91bmQ7XG4gIH0gLy8gcGFyc2UgZXZlbnQgY29uZmlndXJhdGlvblxuXG5cbiAgaWYgKHNwZWMuZXZlbnRDb25maWcpIHtcbiAgICBjdHguZXZlbnRDb25maWcgPSBzcGVjLmV2ZW50Q29uZmlnO1xuICB9IC8vIHBhcnNlIGxvY2FsZSBjb25maWd1cmF0aW9uXG5cblxuICBpZiAoc3BlYy5sb2NhbGUpIHtcbiAgICBjdHgubG9jYWxlID0gc3BlYy5sb2NhbGU7XG4gIH0gLy8gcGFyc2Ugb3BlcmF0b3JzXG5cblxuICBvcGVyYXRvcnMuZm9yRWFjaChlbnRyeSA9PiBjdHgucGFyc2VPcGVyYXRvcihlbnRyeSkpOyAvLyBwYXJzZSBvcGVyYXRvciBwYXJhbWV0ZXJzXG5cbiAgb3BlcmF0b3JzLmZvckVhY2goZW50cnkgPT4gY3R4LnBhcnNlT3BlcmF0b3JQYXJhbWV0ZXJzKGVudHJ5KSk7IC8vIHBhcnNlIHN0cmVhbXNcblxuICAoc3BlYy5zdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGVudHJ5ID0+IGN0eC5wYXJzZVN0cmVhbShlbnRyeSkpOyAvLyBwYXJzZSB1cGRhdGVzXG5cbiAgKHNwZWMudXBkYXRlcyB8fCBbXSkuZm9yRWFjaChlbnRyeSA9PiBjdHgucGFyc2VVcGRhdGUoZW50cnkpKTtcbiAgcmV0dXJuIGN0eC5yZXNvbHZlKCk7XG59XG5cbmNvbnN0IFNraXAgPSB0b1NldChbJ3J1bGUnXSksXG4gICAgICBTd2FwID0gdG9TZXQoWydncm91cCcsICdpbWFnZScsICdyZWN0J10pO1xuZnVuY3Rpb24gYWRqdXN0U3BhdGlhbChlbmNvZGUsIG1hcmt0eXBlKSB7XG4gIGxldCBjb2RlID0gJyc7XG4gIGlmIChTa2lwW21hcmt0eXBlXSkgcmV0dXJuIGNvZGU7XG5cbiAgaWYgKGVuY29kZS54Mikge1xuICAgIGlmIChlbmNvZGUueCkge1xuICAgICAgaWYgKFN3YXBbbWFya3R5cGVdKSB7XG4gICAgICAgIGNvZGUgKz0gJ2lmKG8ueD5vLngyKSQ9by54LG8ueD1vLngyLG8ueDI9JDsnO1xuICAgICAgfVxuXG4gICAgICBjb2RlICs9ICdvLndpZHRoPW8ueDItby54Oyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gJ28ueD1vLngyLShvLndpZHRofHwwKTsnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmNvZGUueGMpIHtcbiAgICBjb2RlICs9ICdvLng9by54Yy0oby53aWR0aHx8MCkvMjsnO1xuICB9XG5cbiAgaWYgKGVuY29kZS55Mikge1xuICAgIGlmIChlbmNvZGUueSkge1xuICAgICAgaWYgKFN3YXBbbWFya3R5cGVdKSB7XG4gICAgICAgIGNvZGUgKz0gJ2lmKG8ueT5vLnkyKSQ9by55LG8ueT1vLnkyLG8ueTI9JDsnO1xuICAgICAgfVxuXG4gICAgICBjb2RlICs9ICdvLmhlaWdodD1vLnkyLW8ueTsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9ICdvLnk9by55Mi0oby5oZWlnaHR8fDApOyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuY29kZS55Yykge1xuICAgIGNvZGUgKz0gJ28ueT1vLnljLShvLmhlaWdodHx8MCkvMjsnO1xuICB9XG5cbiAgcmV0dXJuIGNvZGU7XG59XG5mdW5jdGlvbiBjYW5vbmljYWxUeXBlKHR5cGUpIHtcbiAgcmV0dXJuICh0eXBlICsgJycpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBpc09wZXJhdG9yKHR5cGUpIHtcbiAgcmV0dXJuIGNhbm9uaWNhbFR5cGUodHlwZSkgPT09ICdvcGVyYXRvcic7XG59XG5mdW5jdGlvbiBpc0NvbGxlY3QodHlwZSkge1xuICByZXR1cm4gY2Fub25pY2FsVHlwZSh0eXBlKSA9PT0gJ2NvbGxlY3QnO1xufVxuXG5mdW5jdGlvbiBleHByZXNzaW9uKGN0eCwgYXJncywgY29kZSkge1xuICAvLyB3cmFwIGNvZGUgaW4gcmV0dXJuIHN0YXRlbWVudCBpZiBleHByZXNzaW9uIGRvZXMgbm90IHRlcm1pbmF0ZVxuICBpZiAoY29kZVtjb2RlLmxlbmd0aCAtIDFdICE9PSAnOycpIHtcbiAgICBjb2RlID0gJ3JldHVybignICsgY29kZSArICcpOyc7XG4gIH1cblxuICBjb25zdCBmbiA9IEZ1bmN0aW9uKC4uLmFyZ3MuY29uY2F0KGNvZGUpKTtcbiAgcmV0dXJuIGN0eCAmJiBjdHguZnVuY3Rpb25zID8gZm4uYmluZChjdHguZnVuY3Rpb25zKSA6IGZuO1xufSAvLyBnZW5lcmF0ZSBjb2RlIGZvciBjb21wYXJpbmcgYSBzaW5nbGUgZmllbGRcblxuXG5mdW5jdGlvbiBfY29tcGFyZSh1LCB2LCBsdCwgZ3QpIHtcbiAgcmV0dXJuIFwiKCh1ID0gXCIuY29uY2F0KHUsIFwiKSA8ICh2ID0gXCIpLmNvbmNhdCh2LCBcIikgfHwgdSA9PSBudWxsKSAmJiB2ICE9IG51bGwgPyBcIikuY29uY2F0KGx0LCBcIlxcbiAgOiAodSA+IHYgfHwgdiA9PSBudWxsKSAmJiB1ICE9IG51bGwgPyBcIikuY29uY2F0KGd0LCBcIlxcbiAgOiAoKHYgPSB2IGluc3RhbmNlb2YgRGF0ZSA/ICt2IDogdiksICh1ID0gdSBpbnN0YW5jZW9mIERhdGUgPyArdSA6IHUpKSAhPT0gdSAmJiB2ID09PSB2ID8gXCIpLmNvbmNhdChsdCwgXCJcXG4gIDogdiAhPT0gdiAmJiB1ID09PSB1ID8gXCIpLmNvbmNhdChndCwgXCIgOiBcIik7XG59XG5cbnZhciBleHByZXNzaW9uQ29kZWdlbiA9IHtcbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gdXNlZCB0byB1cGRhdGUgYW4gb3BlcmF0b3IgdmFsdWUuXG4gICAqL1xuICBvcGVyYXRvcjogKGN0eCwgZXhwcikgPT4gZXhwcmVzc2lvbihjdHgsIFsnXyddLCBleHByLmNvZGUpLFxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBleHByZXNzaW9uIHByb3ZpZGVkIGFzIGFuIG9wZXJhdG9yIHBhcmFtZXRlciB2YWx1ZS5cbiAgICovXG4gIHBhcmFtZXRlcjogKGN0eCwgZXhwcikgPT4gZXhwcmVzc2lvbihjdHgsIFsnZGF0dW0nLCAnXyddLCBleHByLmNvZGUpLFxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBleHByZXNzaW9uIGFwcGxpZWQgdG8gYW4gZXZlbnQgc3RyZWFtLlxuICAgKi9cbiAgZXZlbnQ6IChjdHgsIGV4cHIpID0+IGV4cHJlc3Npb24oY3R4LCBbJ2V2ZW50J10sIGV4cHIuY29kZSksXG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gdXNlZCB0byBoYW5kbGUgYW4gZXZlbnQtZHJpdmVuIG9wZXJhdG9yIHVwZGF0ZS5cbiAgICovXG4gIGhhbmRsZXI6IChjdHgsIGV4cHIpID0+IHtcbiAgICBjb25zdCBjb2RlID0gXCJ2YXIgZGF0dW09ZXZlbnQuaXRlbSYmZXZlbnQuaXRlbS5kYXR1bTtyZXR1cm4gXCIuY29uY2F0KGV4cHIuY29kZSwgXCI7XCIpO1xuICAgIHJldHVybiBleHByZXNzaW9uKGN0eCwgWydfJywgJ2V2ZW50J10sIGNvZGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBleHByZXNzaW9uIHRoYXQgcGVyZm9ybXMgdmlzdWFsIGVuY29kaW5nLlxuICAgKi9cbiAgZW5jb2RlOiAoY3R4LCBlbmNvZGUpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtYXJrdHlwZSxcbiAgICAgIGNoYW5uZWxzXG4gICAgfSA9IGVuY29kZTtcbiAgICBsZXQgY29kZSA9ICd2YXIgbz1pdGVtLGRhdHVtPW8uZGF0dW0sbT0wLCQ7JztcblxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBjaGFubmVscykge1xuICAgICAgY29uc3QgbyA9ICdvWycgKyBzdHJpbmdWYWx1ZShuYW1lKSArICddJztcbiAgICAgIGNvZGUgKz0gXCIkPVwiLmNvbmNhdChjaGFubmVsc1tuYW1lXS5jb2RlLCBcIjtpZihcIikuY29uY2F0KG8sIFwiIT09JClcIikuY29uY2F0KG8sIFwiPSQsbT0xO1wiKTtcbiAgICB9XG5cbiAgICBjb2RlICs9IGFkanVzdFNwYXRpYWwoY2hhbm5lbHMsIG1hcmt0eXBlKTtcbiAgICBjb2RlICs9ICdyZXR1cm4gbTsnO1xuICAgIHJldHVybiBleHByZXNzaW9uKGN0eCwgWydpdGVtJywgJ18nXSwgY29kZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9wdGltaXplZCBjb2RlIGdlbmVyYXRvcnMgZm9yIGFjY2VzcyBhbmQgY29tcGFyaXNvbi5cbiAgICovXG4gIGNvZGVnZW46IHtcbiAgICBnZXQocGF0aCkge1xuICAgICAgY29uc3QgcmVmID0gXCJbXCIuY29uY2F0KHBhdGgubWFwKHN0cmluZ1ZhbHVlKS5qb2luKCddWycpLCBcIl1cIik7XG4gICAgICBjb25zdCBnZXQgPSBGdW5jdGlvbignXycsIFwicmV0dXJuIF9cIi5jb25jYXQocmVmLCBcIjtcIikpO1xuICAgICAgZ2V0LnBhdGggPSByZWY7XG4gICAgICByZXR1cm4gZ2V0O1xuICAgIH0sXG5cbiAgICBjb21wYXJhdG9yKGZpZWxkcywgb3JkZXJzKSB7XG4gICAgICBsZXQgdDtcblxuICAgICAgY29uc3QgbWFwID0gKGYsIGkpID0+IHtcbiAgICAgICAgY29uc3QgbyA9IG9yZGVyc1tpXTtcbiAgICAgICAgbGV0IHUsIHY7XG5cbiAgICAgICAgaWYgKGYucGF0aCkge1xuICAgICAgICAgIHUgPSBcImFcIi5jb25jYXQoZi5wYXRoKTtcbiAgICAgICAgICB2ID0gXCJiXCIuY29uY2F0KGYucGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKHQgPSB0IHx8IHt9KVsnZicgKyBpXSA9IGY7XG4gICAgICAgICAgdSA9IFwidGhpcy5mXCIuY29uY2F0KGksIFwiKGEpXCIpO1xuICAgICAgICAgIHYgPSBcInRoaXMuZlwiLmNvbmNhdChpLCBcIihiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfY29tcGFyZSh1LCB2LCAtbywgbyk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBmbiA9IEZ1bmN0aW9uKCdhJywgJ2InLCAndmFyIHUsIHY7IHJldHVybiAnICsgZmllbGRzLm1hcChtYXApLmpvaW4oJycpICsgJzA7Jyk7XG4gICAgICByZXR1cm4gdCA/IGZuLmJpbmQodCkgOiBmbjtcbiAgICB9XG5cbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIGRhdGFmbG93IG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlT3BlcmF0b3Ioc3BlYykge1xuICBjb25zdCBjdHggPSB0aGlzO1xuXG4gIGlmIChpc09wZXJhdG9yKHNwZWMudHlwZSkgfHwgIXNwZWMudHlwZSkge1xuICAgIGN0eC5vcGVyYXRvcihzcGVjLCBzcGVjLnVwZGF0ZSA/IGN0eC5vcGVyYXRvckV4cHJlc3Npb24oc3BlYy51cGRhdGUpIDogbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LnRyYW5zZm9ybShzcGVjLCBzcGVjLnR5cGUpO1xuICB9XG59XG4vKipcbiAqIFBhcnNlIGFuZCBhc3NpZ24gb3BlcmF0b3IgcGFyYW1ldGVycy5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU9wZXJhdG9yUGFyYW1ldGVycyhzcGVjKSB7XG4gIGNvbnN0IGN0eCA9IHRoaXM7XG5cbiAgaWYgKHNwZWMucGFyYW1zKSB7XG4gICAgY29uc3Qgb3AgPSBjdHguZ2V0KHNwZWMuaWQpO1xuICAgIGlmICghb3ApIGVycm9yKCdJbnZhbGlkIG9wZXJhdG9yIGlkOiAnICsgc3BlYy5pZCk7XG4gICAgY3R4LmRhdGFmbG93LmNvbm5lY3Qob3AsIG9wLnBhcmFtZXRlcnMoY3R4LnBhcnNlUGFyYW1ldGVycyhzcGVjLnBhcmFtcyksIHNwZWMucmVhY3QsIHNwZWMuaW5pdG9ubHkpKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgc2V0IG9mIG9wZXJhdG9yIHBhcmFtZXRlcnMuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXJzKHNwZWMsIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbnN0IGN0eCA9IHRoaXM7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc3BlYykge1xuICAgIGNvbnN0IHZhbHVlID0gc3BlY1trZXldO1xuICAgIHBhcmFtc1trZXldID0gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBwYXJzZVBhcmFtZXRlcih2LCBjdHgsIHBhcmFtcykpIDogcGFyc2VQYXJhbWV0ZXIodmFsdWUsIGN0eCwgcGFyYW1zKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHBhcmFtZXRlci5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcihzcGVjLCBjdHgsIHBhcmFtcykge1xuICBpZiAoIXNwZWMgfHwgIWlzT2JqZWN0KHNwZWMpKSByZXR1cm4gc3BlYztcblxuICBmb3IgKGxldCBpID0gMCwgbiA9IFBBUlNFUlMubGVuZ3RoLCBwOyBpIDwgbjsgKytpKSB7XG4gICAgcCA9IFBBUlNFUlNbaV07XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkoc3BlYywgcC5rZXkpKSB7XG4gICAgICByZXR1cm4gcC5wYXJzZShzcGVjLCBjdHgsIHBhcmFtcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNwZWM7XG59XG4vKiogUmVmZXJlbmNlIHBhcnNlcnMuICovXG5cblxudmFyIFBBUlNFUlMgPSBbe1xuICBrZXk6ICckcmVmJyxcbiAgcGFyc2U6IGdldE9wZXJhdG9yXG59LCB7XG4gIGtleTogJyRrZXknLFxuICBwYXJzZTogZ2V0S2V5XG59LCB7XG4gIGtleTogJyRleHByJyxcbiAgcGFyc2U6IGdldEV4cHJlc3Npb25cbn0sIHtcbiAga2V5OiAnJGZpZWxkJyxcbiAgcGFyc2U6IGdldEZpZWxkXG59LCB7XG4gIGtleTogJyRlbmNvZGUnLFxuICBwYXJzZTogZ2V0RW5jb2RlXG59LCB7XG4gIGtleTogJyRjb21wYXJlJyxcbiAgcGFyc2U6IGdldENvbXBhcmVcbn0sIHtcbiAga2V5OiAnJGNvbnRleHQnLFxuICBwYXJzZTogZ2V0Q29udGV4dFxufSwge1xuICBrZXk6ICckc3ViZmxvdycsXG4gIHBhcnNlOiBnZXRTdWJmbG93XG59LCB7XG4gIGtleTogJyR0dXBsZWlkJyxcbiAgcGFyc2U6IGdldFR1cGxlSWRcbn1dO1xuLyoqXG4gKiBSZXNvbHZlIGFuIG9wZXJhdG9yIHJlZmVyZW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRPcGVyYXRvcihfLCBjdHgpIHtcbiAgcmV0dXJuIGN0eC5nZXQoXy4kcmVmKSB8fCBlcnJvcignT3BlcmF0b3Igbm90IGRlZmluZWQ6ICcgKyBfLiRyZWYpO1xufVxuLyoqXG4gKiBSZXNvbHZlIGFuIGV4cHJlc3Npb24gcmVmZXJlbmNlLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RXhwcmVzc2lvbihfLCBjdHgsIHBhcmFtcykge1xuICBpZiAoXy4kcGFyYW1zKSB7XG4gICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBwYXJhbWV0ZXJzXG4gICAgY3R4LnBhcnNlUGFyYW1ldGVycyhfLiRwYXJhbXMsIHBhcmFtcyk7XG4gIH1cblxuICBjb25zdCBrID0gJ2U6JyArIF8uJGV4cHIuY29kZSArICdfJyArIF8uJG5hbWU7XG4gIHJldHVybiBjdHguZm5ba10gfHwgKGN0eC5mbltrXSA9IGFjY2Vzc29yKGN0eC5wYXJhbWV0ZXJFeHByZXNzaW9uKF8uJGV4cHIpLCBfLiRmaWVsZHMsIF8uJG5hbWUpKTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhIGtleSBhY2Nlc3NvciByZWZlcmVuY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRLZXkoXywgY3R4KSB7XG4gIGNvbnN0IGsgPSAnazonICsgXy4ka2V5ICsgJ18nICsgISFfLiRmbGF0O1xuICByZXR1cm4gY3R4LmZuW2tdIHx8IChjdHguZm5ba10gPSBrZXkoXy4ka2V5LCBfLiRmbGF0LCBjdHguZXhwci5jb2RlZ2VuKSk7XG59XG4vKipcbiAqIFJlc29sdmUgYSBmaWVsZCBhY2Nlc3NvciByZWZlcmVuY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRGaWVsZChfLCBjdHgpIHtcbiAgaWYgKCFfLiRmaWVsZCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGsgPSAnZjonICsgXy4kZmllbGQgKyAnXycgKyBfLiRuYW1lO1xuICByZXR1cm4gY3R4LmZuW2tdIHx8IChjdHguZm5ba10gPSBmaWVsZChfLiRmaWVsZCwgXy4kbmFtZSwgY3R4LmV4cHIuY29kZWdlbikpO1xufVxuLyoqXG4gKiBSZXNvbHZlIGEgY29tcGFyYXRvciBmdW5jdGlvbiByZWZlcmVuY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb21wYXJlKF8sIGN0eCkge1xuICAvLyBBcyBvZiBWZWdhIDUuNS4zLCAkdHVwbGVpZCBzb3J0IGlzIG5vIGxvbmdlciB1c2VkLlxuICAvLyBLZWVwIGhlcmUgZm9yIG5vdyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIGNvbnN0IGsgPSAnYzonICsgXy4kY29tcGFyZSArICdfJyArIF8uJG9yZGVyLFxuICAgICAgICBjID0gYXJyYXkoXy4kY29tcGFyZSkubWFwKF8gPT4gXyAmJiBfLiR0dXBsZWlkID8gdHVwbGVpZCA6IF8pO1xuICByZXR1cm4gY3R4LmZuW2tdIHx8IChjdHguZm5ba10gPSBjb21wYXJlKGMsIF8uJG9yZGVyLCBjdHguZXhwci5jb2RlZ2VuKSk7XG59XG4vKipcbiAqIFJlc29sdmUgYW4gZW5jb2RlIG9wZXJhdG9yIHJlZmVyZW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVuY29kZShfLCBjdHgpIHtcbiAgY29uc3Qgc3BlYyA9IF8uJGVuY29kZSxcbiAgICAgICAgZW5jb2RlID0ge307XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIHNwZWMpIHtcbiAgICBjb25zdCBlbmMgPSBzcGVjW25hbWVdO1xuICAgIGVuY29kZVtuYW1lXSA9IGFjY2Vzc29yKGN0eC5lbmNvZGVFeHByZXNzaW9uKGVuYy4kZXhwciksIGVuYy4kZmllbGRzKTtcbiAgICBlbmNvZGVbbmFtZV0ub3V0cHV0ID0gZW5jLiRvdXRwdXQ7XG4gIH1cblxuICByZXR1cm4gZW5jb2RlO1xufVxuLyoqXG4gKiBSZXNvbHZlIGEgY29udGV4dCByZWZlcmVuY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0KF8sIGN0eCkge1xuICByZXR1cm4gY3R4O1xufVxuLyoqXG4gKiBSZXNvbHZlIGEgcmVjdXJzaXZlIHN1YmZsb3cgc3BlY2lmaWNhdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFN1YmZsb3coXywgY3R4KSB7XG4gIGNvbnN0IHNwZWMgPSBfLiRzdWJmbG93O1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGFmbG93LCBrZXksIHBhcmVudCkge1xuICAgIGNvbnN0IHN1YmN0eCA9IGN0eC5mb3JrKCkucGFyc2Uoc3BlYyksXG4gICAgICAgICAgb3AgPSBzdWJjdHguZ2V0KHNwZWMub3BlcmF0b3JzWzBdLmlkKSxcbiAgICAgICAgICBwID0gc3ViY3R4LnNpZ25hbHMucGFyZW50O1xuICAgIGlmIChwKSBwLnNldChwYXJlbnQpO1xuXG4gICAgb3AuZGV0YWNoU3ViZmxvdyA9ICgpID0+IGN0eC5kZXRhY2goc3ViY3R4KTtcblxuICAgIHJldHVybiBvcDtcbiAgfTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhIHR1cGxlIGlkIHJlZmVyZW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFR1cGxlSWQoKSB7XG4gIHJldHVybiB0dXBsZWlkO1xufVxuXG4vKipcbiAqIFBhcnNlIGFuIGV2ZW50IHN0cmVhbSBzcGVjaWZpY2F0aW9uLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyZWFtIChzcGVjKSB7XG4gIHZhciBjdHggPSB0aGlzLFxuICAgICAgZmlsdGVyID0gc3BlYy5maWx0ZXIgIT0gbnVsbCA/IGN0eC5ldmVudEV4cHJlc3Npb24oc3BlYy5maWx0ZXIpIDogdW5kZWZpbmVkLFxuICAgICAgc3RyZWFtID0gc3BlYy5zdHJlYW0gIT0gbnVsbCA/IGN0eC5nZXQoc3BlYy5zdHJlYW0pIDogdW5kZWZpbmVkLFxuICAgICAgYXJncztcblxuICBpZiAoc3BlYy5zb3VyY2UpIHtcbiAgICBzdHJlYW0gPSBjdHguZXZlbnRzKHNwZWMuc291cmNlLCBzcGVjLnR5cGUsIGZpbHRlcik7XG4gIH0gZWxzZSBpZiAoc3BlYy5tZXJnZSkge1xuICAgIGFyZ3MgPSBzcGVjLm1lcmdlLm1hcChfID0+IGN0eC5nZXQoXykpO1xuICAgIHN0cmVhbSA9IGFyZ3NbMF0ubWVyZ2UuYXBwbHkoYXJnc1swXSwgYXJncy5zbGljZSgxKSk7XG4gIH1cblxuICBpZiAoc3BlYy5iZXR3ZWVuKSB7XG4gICAgYXJncyA9IHNwZWMuYmV0d2Vlbi5tYXAoXyA9PiBjdHguZ2V0KF8pKTtcbiAgICBzdHJlYW0gPSBzdHJlYW0uYmV0d2VlbihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxuXG4gIGlmIChzcGVjLmZpbHRlcikge1xuICAgIHN0cmVhbSA9IHN0cmVhbS5maWx0ZXIoZmlsdGVyKTtcbiAgfVxuXG4gIGlmIChzcGVjLnRocm90dGxlICE9IG51bGwpIHtcbiAgICBzdHJlYW0gPSBzdHJlYW0udGhyb3R0bGUoK3NwZWMudGhyb3R0bGUpO1xuICB9XG5cbiAgaWYgKHNwZWMuZGVib3VuY2UgIT0gbnVsbCkge1xuICAgIHN0cmVhbSA9IHN0cmVhbS5kZWJvdW5jZSgrc3BlYy5kZWJvdW5jZSk7XG4gIH1cblxuICBpZiAoc3RyZWFtID09IG51bGwpIHtcbiAgICBlcnJvcignSW52YWxpZCBzdHJlYW0gZGVmaW5pdGlvbjogJyArIEpTT04uc3RyaW5naWZ5KHNwZWMpKTtcbiAgfVxuXG4gIGlmIChzcGVjLmNvbnN1bWUpIHN0cmVhbS5jb25zdW1lKHRydWUpO1xuICBjdHguc3RyZWFtKHNwZWMsIHN0cmVhbSk7XG59XG5cbi8qKlxuICogUGFyc2UgYW4gZXZlbnQtZHJpdmVuIG9wZXJhdG9yIHVwZGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZSAoc3BlYykge1xuICB2YXIgY3R4ID0gdGhpcyxcbiAgICAgIHNyY2lkID0gaXNPYmplY3Qoc3JjaWQgPSBzcGVjLnNvdXJjZSkgPyBzcmNpZC4kcmVmIDogc3JjaWQsXG4gICAgICBzb3VyY2UgPSBjdHguZ2V0KHNyY2lkKSxcbiAgICAgIHRhcmdldCA9IG51bGwsXG4gICAgICB1cGRhdGUgPSBzcGVjLnVwZGF0ZSxcbiAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgaWYgKCFzb3VyY2UpIGVycm9yKCdTb3VyY2Ugbm90IGRlZmluZWQ6ICcgKyBzcGVjLnNvdXJjZSk7XG4gIHRhcmdldCA9IHNwZWMudGFyZ2V0ICYmIHNwZWMudGFyZ2V0LiRleHByID8gY3R4LmV2ZW50RXhwcmVzc2lvbihzcGVjLnRhcmdldC4kZXhwcikgOiBjdHguZ2V0KHNwZWMudGFyZ2V0KTtcblxuICBpZiAodXBkYXRlICYmIHVwZGF0ZS4kZXhwcikge1xuICAgIGlmICh1cGRhdGUuJHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gY3R4LnBhcnNlUGFyYW1ldGVycyh1cGRhdGUuJHBhcmFtcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlID0gY3R4LmhhbmRsZXJFeHByZXNzaW9uKHVwZGF0ZS4kZXhwcik7XG4gIH1cblxuICBjdHgudXBkYXRlKHNwZWMsIHNvdXJjZSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcyk7XG59XG5cbmNvbnN0IFNLSVAgPSB7XG4gIHNraXA6IHRydWVcbn07XG5mdW5jdGlvbiBnZXRTdGF0ZShvcHRpb25zKSB7XG4gIHZhciBjdHggPSB0aGlzLFxuICAgICAgc3RhdGUgPSB7fTtcblxuICBpZiAob3B0aW9ucy5zaWduYWxzKSB7XG4gICAgdmFyIHNpZ25hbHMgPSBzdGF0ZS5zaWduYWxzID0ge307XG4gICAgT2JqZWN0LmtleXMoY3R4LnNpZ25hbHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IG9wID0gY3R4LnNpZ25hbHNba2V5XTtcblxuICAgICAgaWYgKG9wdGlvbnMuc2lnbmFscyhrZXksIG9wKSkge1xuICAgICAgICBzaWduYWxzW2tleV0gPSBvcC52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICB2YXIgZGF0YSA9IHN0YXRlLmRhdGEgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjdHguZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGN0eC5kYXRhW2tleV07XG5cbiAgICAgIGlmIChvcHRpb25zLmRhdGEoa2V5LCBkYXRhc2V0KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBkYXRhc2V0LmlucHV0LnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGN0eC5zdWJjb250ZXh0ICYmIG9wdGlvbnMucmVjdXJzZSAhPT0gZmFsc2UpIHtcbiAgICBzdGF0ZS5zdWJjb250ZXh0ID0gY3R4LnN1YmNvbnRleHQubWFwKGN0eCA9PiBjdHguZ2V0U3RhdGUob3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgdmFyIGN0eCA9IHRoaXMsXG4gICAgICBkZiA9IGN0eC5kYXRhZmxvdyxcbiAgICAgIGRhdGEgPSBzdGF0ZS5kYXRhLFxuICAgICAgc2lnbmFscyA9IHN0YXRlLnNpZ25hbHM7XG4gIE9iamVjdC5rZXlzKHNpZ25hbHMgfHwge30pLmZvckVhY2goa2V5ID0+IHtcbiAgICBkZi51cGRhdGUoY3R4LnNpZ25hbHNba2V5XSwgc2lnbmFsc1trZXldLCBTS0lQKTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKGRhdGEgfHwge30pLmZvckVhY2goa2V5ID0+IHtcbiAgICBkZi5wdWxzZShjdHguZGF0YVtrZXldLmlucHV0LCBkZi5jaGFuZ2VzZXQoKS5yZW1vdmUodHJ1dGh5KS5pbnNlcnQoZGF0YVtrZXldKSk7XG4gIH0pO1xuICAoc3RhdGUuc3ViY29udGV4dCB8fCBbXSkuZm9yRWFjaCgoc3Vic3RhdGUsIGkpID0+IHtcbiAgICBjb25zdCBzdWJjdHggPSBjdHguc3ViY29udGV4dFtpXTtcbiAgICBpZiAoc3ViY3R4KSBzdWJjdHguc2V0U3RhdGUoc3Vic3RhdGUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb250ZXh0IG9iamVjdHMgc3RvcmUgdGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUuXG4gKiBFbmFibGVzIGxvb2t1cCBvZiBwYXJzZWQgb3BlcmF0b3JzLCBldmVudCBzdHJlYW1zLCBhY2Nlc3NvcnMsIGV0Yy5cbiAqIFByb3ZpZGVzIGEgJ2ZvcmsnIG1ldGhvZCBmb3IgY3JlYXRpbmcgY2hpbGQgY29udGV4dHMgZm9yIHN1YmZsb3dzLlxuICovXG5cbmZ1bmN0aW9uIGNvbnRleHQgKGRmLCB0cmFuc2Zvcm1zLCBmdW5jdGlvbnMsIGV4cHIpIHtcbiAgcmV0dXJuIG5ldyBDb250ZXh0KGRmLCB0cmFuc2Zvcm1zLCBmdW5jdGlvbnMsIGV4cHIpO1xufVxuXG5mdW5jdGlvbiBDb250ZXh0KGRmLCB0cmFuc2Zvcm1zLCBmdW5jdGlvbnMsIGV4cHIpIHtcbiAgdGhpcy5kYXRhZmxvdyA9IGRmO1xuICB0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xuICB0aGlzLmV2ZW50cyA9IGRmLmV2ZW50cy5iaW5kKGRmKTtcbiAgdGhpcy5leHByID0gZXhwciB8fCBleHByZXNzaW9uQ29kZWdlbiwgdGhpcy5zaWduYWxzID0ge307XG4gIHRoaXMuc2NhbGVzID0ge307XG4gIHRoaXMubm9kZXMgPSB7fTtcbiAgdGhpcy5kYXRhID0ge307XG4gIHRoaXMuZm4gPSB7fTtcblxuICBpZiAoZnVuY3Rpb25zKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBPYmplY3QuY3JlYXRlKGZ1bmN0aW9ucyk7XG4gICAgdGhpcy5mdW5jdGlvbnMuY29udGV4dCA9IHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gU3ViY29udGV4dChjdHgpIHtcbiAgdGhpcy5kYXRhZmxvdyA9IGN0eC5kYXRhZmxvdztcbiAgdGhpcy50cmFuc2Zvcm1zID0gY3R4LnRyYW5zZm9ybXM7XG4gIHRoaXMuZXZlbnRzID0gY3R4LmV2ZW50cztcbiAgdGhpcy5leHByID0gY3R4LmV4cHI7XG4gIHRoaXMuc2lnbmFscyA9IE9iamVjdC5jcmVhdGUoY3R4LnNpZ25hbHMpO1xuICB0aGlzLnNjYWxlcyA9IE9iamVjdC5jcmVhdGUoY3R4LnNjYWxlcyk7XG4gIHRoaXMubm9kZXMgPSBPYmplY3QuY3JlYXRlKGN0eC5ub2Rlcyk7XG4gIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUoY3R4LmRhdGEpO1xuICB0aGlzLmZuID0gT2JqZWN0LmNyZWF0ZShjdHguZm4pO1xuXG4gIGlmIChjdHguZnVuY3Rpb25zKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBPYmplY3QuY3JlYXRlKGN0eC5mdW5jdGlvbnMpO1xuICAgIHRoaXMuZnVuY3Rpb25zLmNvbnRleHQgPSB0aGlzO1xuICB9XG59XG5cbkNvbnRleHQucHJvdG90eXBlID0gU3ViY29udGV4dC5wcm90b3R5cGUgPSB7XG4gIGZvcmsoKSB7XG4gICAgY29uc3QgY3R4ID0gbmV3IFN1YmNvbnRleHQodGhpcyk7XG4gICAgKHRoaXMuc3ViY29udGV4dCB8fCAodGhpcy5zdWJjb250ZXh0ID0gW10pKS5wdXNoKGN0eCk7XG4gICAgcmV0dXJuIGN0eDtcbiAgfSxcblxuICBkZXRhY2goY3R4KSB7XG4gICAgdGhpcy5zdWJjb250ZXh0ID0gdGhpcy5zdWJjb250ZXh0LmZpbHRlcihjID0+IGMgIT09IGN0eCk7IC8vIGRpc2Nvbm5lY3QgYWxsIG5vZGVzIGluIHRoZSBzdWJjb250ZXh0XG4gICAgLy8gd2lwZSBvdXQgdGFyZ2V0cyBmaXJzdCBmb3IgYmV0dGVyIGVmZmljaWVuY3lcblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjdHgubm9kZXMpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykgY3R4Lm5vZGVzW2tleV0uX3RhcmdldHMgPSBudWxsO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykgY3R4Lm5vZGVzW2tleV0uZGV0YWNoKCk7XG5cbiAgICBjdHgubm9kZXMgPSBudWxsO1xuICB9LFxuXG4gIGdldChpZCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzW2lkXTtcbiAgfSxcblxuICBzZXQoaWQsIG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1tpZF0gPSBub2RlO1xuICB9LFxuXG4gIGFkZChzcGVjLCBvcCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMsXG4gICAgICAgICAgZGYgPSBjdHguZGF0YWZsb3csXG4gICAgICAgICAgZGF0YSA9IHNwZWMudmFsdWU7XG4gICAgY3R4LnNldChzcGVjLmlkLCBvcCk7XG5cbiAgICBpZiAoaXNDb2xsZWN0KHNwZWMudHlwZSkgJiYgZGF0YSkge1xuICAgICAgaWYgKGRhdGEuJGluZ2VzdCkge1xuICAgICAgICBkZi5pbmdlc3Qob3AsIGRhdGEuJGluZ2VzdCwgZGF0YS4kZm9ybWF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS4kcmVxdWVzdCkge1xuICAgICAgICBkZi5wcmVsb2FkKG9wLCBkYXRhLiRyZXF1ZXN0LCBkYXRhLiRmb3JtYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGYucHVsc2Uob3AsIGRmLmNoYW5nZXNldCgpLmluc2VydChkYXRhKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwZWMucm9vdCkge1xuICAgICAgY3R4LnJvb3QgPSBvcDtcbiAgICB9XG5cbiAgICBpZiAoc3BlYy5wYXJlbnQpIHtcbiAgICAgIGxldCBwID0gY3R4LmdldChzcGVjLnBhcmVudC4kcmVmKTtcblxuICAgICAgaWYgKHApIHtcbiAgICAgICAgZGYuY29ubmVjdChwLCBbb3BdKTtcbiAgICAgICAgb3AudGFyZ2V0cygpLmFkZChwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChjdHgudW5yZXNvbHZlZCA9IGN0eC51bnJlc29sdmVkIHx8IFtdKS5wdXNoKCgpID0+IHtcbiAgICAgICAgICBwID0gY3R4LmdldChzcGVjLnBhcmVudC4kcmVmKTtcbiAgICAgICAgICBkZi5jb25uZWN0KHAsIFtvcF0pO1xuICAgICAgICAgIG9wLnRhcmdldHMoKS5hZGQocCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGVjLnNpZ25hbCkge1xuICAgICAgY3R4LnNpZ25hbHNbc3BlYy5zaWduYWxdID0gb3A7XG4gICAgfVxuXG4gICAgaWYgKHNwZWMuc2NhbGUpIHtcbiAgICAgIGN0eC5zY2FsZXNbc3BlYy5zY2FsZV0gPSBvcDtcbiAgICB9XG5cbiAgICBpZiAoc3BlYy5kYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3BlYy5kYXRhKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZGF0YVtuYW1lXSB8fCAoY3R4LmRhdGFbbmFtZV0gPSB7fSk7XG4gICAgICAgIHNwZWMuZGF0YVtuYW1lXS5mb3JFYWNoKHJvbGUgPT4gZGF0YVtyb2xlXSA9IG9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVzb2x2ZSgpIHtcbiAgICAodGhpcy51bnJlc29sdmVkIHx8IFtdKS5mb3JFYWNoKGZuID0+IGZuKCkpO1xuICAgIGRlbGV0ZSB0aGlzLnVucmVzb2x2ZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb3BlcmF0b3Ioc3BlYywgdXBkYXRlKSB7XG4gICAgdGhpcy5hZGQoc3BlYywgdGhpcy5kYXRhZmxvdy5hZGQoc3BlYy52YWx1ZSwgdXBkYXRlKSk7XG4gIH0sXG5cbiAgdHJhbnNmb3JtKHNwZWMsIHR5cGUpIHtcbiAgICB0aGlzLmFkZChzcGVjLCB0aGlzLmRhdGFmbG93LmFkZCh0aGlzLnRyYW5zZm9ybXNbY2Fub25pY2FsVHlwZSh0eXBlKV0pKTtcbiAgfSxcblxuICBzdHJlYW0oc3BlYywgc3RyZWFtKSB7XG4gICAgdGhpcy5zZXQoc3BlYy5pZCwgc3RyZWFtKTtcbiAgfSxcblxuICB1cGRhdGUoc3BlYywgc3RyZWFtLCB0YXJnZXQsIHVwZGF0ZSwgcGFyYW1zKSB7XG4gICAgdGhpcy5kYXRhZmxvdy5vbihzdHJlYW0sIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMsIHNwZWMub3B0aW9ucyk7XG4gIH0sXG5cbiAgLy8gZXhwcmVzc2lvbiBwYXJzaW5nXG4gIG9wZXJhdG9yRXhwcmVzc2lvbihleHByKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwci5vcGVyYXRvcih0aGlzLCBleHByKTtcbiAgfSxcblxuICBwYXJhbWV0ZXJFeHByZXNzaW9uKGV4cHIpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLnBhcmFtZXRlcih0aGlzLCBleHByKTtcbiAgfSxcblxuICBldmVudEV4cHJlc3Npb24oZXhwcikge1xuICAgIHJldHVybiB0aGlzLmV4cHIuZXZlbnQodGhpcywgZXhwcik7XG4gIH0sXG5cbiAgaGFuZGxlckV4cHJlc3Npb24oZXhwcikge1xuICAgIHJldHVybiB0aGlzLmV4cHIuaGFuZGxlcih0aGlzLCBleHByKTtcbiAgfSxcblxuICBlbmNvZGVFeHByZXNzaW9uKGVuY29kZSkge1xuICAgIHJldHVybiB0aGlzLmV4cHIuZW5jb2RlKHRoaXMsIGVuY29kZSk7XG4gIH0sXG5cbiAgLy8gcGFyc2UgbWV0aG9kc1xuICBwYXJzZSxcbiAgcGFyc2VPcGVyYXRvcixcbiAgcGFyc2VPcGVyYXRvclBhcmFtZXRlcnMsXG4gIHBhcnNlUGFyYW1ldGVycyxcbiAgcGFyc2VTdHJlYW0sXG4gIHBhcnNlVXBkYXRlLFxuICAvLyBzdGF0ZSBtZXRob2RzXG4gIGdldFN0YXRlLFxuICBzZXRTdGF0ZVxufTtcblxuZXhwb3J0IHsgY29udGV4dCB9O1xuIiwiaW1wb3J0IHsgdG9OdW1iZXIsIHBlZWssIGhhc093blByb3BlcnR5LCB0b1NldCwgYXJyYXksIGNvbnN0YW50LCBpc051bWJlciwgc3BhbiwgaXNPYmplY3QsIGlzU3RyaW5nLCBlcnJvciwgaXNBcnJheSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBiaXNlY3RSaWdodCwgcmFuZ2UsIGJpc2VjdCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IHNjYWxlT3JkaW5hbCwgdGlja0Zvcm1hdCBhcyB0aWNrRm9ybWF0JDEsIHNjYWxlSWRlbnRpdHksIHNjYWxlTGluZWFyLCBzY2FsZUxvZywgc2NhbGVQb3csIHNjYWxlU3FydCwgc2NhbGVTeW1sb2csIHNjYWxlVGltZSwgc2NhbGVVdGMsIHNjYWxlU2VxdWVudGlhbCwgc2NhbGVTZXF1ZW50aWFsTG9nLCBzY2FsZVNlcXVlbnRpYWxQb3csIHNjYWxlU2VxdWVudGlhbFNxcnQsIHNjYWxlU2VxdWVudGlhbFN5bWxvZywgc2NhbGVEaXZlcmdpbmcsIHNjYWxlRGl2ZXJnaW5nTG9nLCBzY2FsZURpdmVyZ2luZ1Bvdywgc2NhbGVEaXZlcmdpbmdTcXJ0LCBzY2FsZURpdmVyZ2luZ1N5bWxvZywgc2NhbGVRdWFudGlsZSwgc2NhbGVRdWFudGl6ZSwgc2NhbGVUaHJlc2hvbGQgfSBmcm9tICdkMy1zY2FsZSc7XG5leHBvcnQgeyBzY2FsZUltcGxpY2l0IH0gZnJvbSAnZDMtc2NhbGUnO1xuaW1wb3J0ICogYXMgJCBmcm9tICdkMy1pbnRlcnBvbGF0ZSc7XG5pbXBvcnQgeyBwaWVjZXdpc2UgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSc7XG5pbXBvcnQgeyB0aW1lSW50ZXJ2YWwsIHV0Y0ludGVydmFsIH0gZnJvbSAndmVnYS10aW1lJztcblxuZnVuY3Rpb24gYmFuZFNwYWNlIChjb3VudCwgcGFkZGluZ0lubmVyLCBwYWRkaW5nT3V0ZXIpIHtcbiAgY29uc3Qgc3BhY2UgPSBjb3VudCAtIHBhZGRpbmdJbm5lciArIHBhZGRpbmdPdXRlciAqIDI7XG4gIHJldHVybiBjb3VudCA/IHNwYWNlID4gMCA/IHNwYWNlIDogMSA6IDA7XG59XG5cbmNvbnN0IElkZW50aXR5ID0gJ2lkZW50aXR5JztcbmNvbnN0IExpbmVhciA9ICdsaW5lYXInO1xuY29uc3QgTG9nID0gJ2xvZyc7XG5jb25zdCBQb3cgPSAncG93JztcbmNvbnN0IFNxcnQgPSAnc3FydCc7XG5jb25zdCBTeW1sb2cgPSAnc3ltbG9nJztcbmNvbnN0IFRpbWUgPSAndGltZSc7XG5jb25zdCBVVEMgPSAndXRjJztcbmNvbnN0IFNlcXVlbnRpYWwgPSAnc2VxdWVudGlhbCc7XG5jb25zdCBEaXZlcmdpbmcgPSAnZGl2ZXJnaW5nJztcbmNvbnN0IFF1YW50aWxlID0gJ3F1YW50aWxlJztcbmNvbnN0IFF1YW50aXplID0gJ3F1YW50aXplJztcbmNvbnN0IFRocmVzaG9sZCA9ICd0aHJlc2hvbGQnO1xuY29uc3QgT3JkaW5hbCA9ICdvcmRpbmFsJztcbmNvbnN0IFBvaW50ID0gJ3BvaW50JztcbmNvbnN0IEJhbmQgPSAnYmFuZCc7XG5jb25zdCBCaW5PcmRpbmFsID0gJ2Jpbi1vcmRpbmFsJzsgLy8gY2F0ZWdvcmllc1xuXG5jb25zdCBDb250aW51b3VzID0gJ2NvbnRpbnVvdXMnO1xuY29uc3QgRGlzY3JldGUgPSAnZGlzY3JldGUnO1xuY29uc3QgRGlzY3JldGl6aW5nID0gJ2Rpc2NyZXRpemluZyc7XG5jb25zdCBJbnRlcnBvbGF0aW5nID0gJ2ludGVycG9sYXRpbmcnO1xuY29uc3QgVGVtcG9yYWwgPSAndGVtcG9yYWwnO1xuXG5mdW5jdGlvbiBpbnZlcnRSYW5nZSAoc2NhbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfKSB7XG4gICAgbGV0IGxvID0gX1swXSxcbiAgICAgICAgaGkgPSBfWzFdLFxuICAgICAgICB0O1xuXG4gICAgaWYgKGhpIDwgbG8pIHtcbiAgICAgIHQgPSBsbztcbiAgICAgIGxvID0gaGk7XG4gICAgICBoaSA9IHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzY2FsZS5pbnZlcnQobG8pLCBzY2FsZS5pbnZlcnQoaGkpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VFeHRlbnQgKHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoXykge1xuICAgIGNvbnN0IHJhbmdlID0gc2NhbGUucmFuZ2UoKTtcbiAgICBsZXQgbG8gPSBfWzBdLFxuICAgICAgICBoaSA9IF9bMV0sXG4gICAgICAgIG1pbiA9IC0xLFxuICAgICAgICBtYXgsXG4gICAgICAgIHQsXG4gICAgICAgIGksXG4gICAgICAgIG47XG5cbiAgICBpZiAoaGkgPCBsbykge1xuICAgICAgdCA9IGxvO1xuICAgICAgbG8gPSBoaTtcbiAgICAgIGhpID0gdDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gcmFuZ2UubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAocmFuZ2VbaV0gPj0gbG8gJiYgcmFuZ2VbaV0gPD0gaGkpIHtcbiAgICAgICAgaWYgKG1pbiA8IDApIG1pbiA9IGk7XG4gICAgICAgIG1heCA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbiA8IDApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbG8gPSBzY2FsZS5pbnZlcnRFeHRlbnQocmFuZ2VbbWluXSk7XG4gICAgaGkgPSBzY2FsZS5pbnZlcnRFeHRlbnQocmFuZ2VbbWF4XSk7XG4gICAgcmV0dXJuIFtsb1swXSA9PT0gdW5kZWZpbmVkID8gbG9bMV0gOiBsb1swXSwgaGlbMV0gPT09IHVuZGVmaW5lZCA/IGhpWzBdIDogaGlbMV1dO1xuICB9O1xufVxuXG5mdW5jdGlvbiBiYW5kKCkge1xuICBjb25zdCBzY2FsZSA9IHNjYWxlT3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcbiAgICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxuICAgICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZTtcbiAgbGV0IHJhbmdlJDEgPSBbMCwgMV0sXG4gICAgICBzdGVwLFxuICAgICAgYmFuZHdpZHRoLFxuICAgICAgcm91bmQgPSBmYWxzZSxcbiAgICAgIHBhZGRpbmdJbm5lciA9IDAsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgICAgYWxpZ24gPSAwLjU7XG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgY29uc3QgbiA9IGRvbWFpbigpLmxlbmd0aCxcbiAgICAgICAgICByZXZlcnNlID0gcmFuZ2UkMVsxXSA8IHJhbmdlJDFbMF0sXG4gICAgICAgICAgc3RvcCA9IHJhbmdlJDFbMSAtIHJldmVyc2VdLFxuICAgICAgICAgIHNwYWNlID0gYmFuZFNwYWNlKG4sIHBhZGRpbmdJbm5lciwgcGFkZGluZ091dGVyKTtcbiAgICBsZXQgc3RhcnQgPSByYW5nZSQxW3JldmVyc2UgLSAwXTtcbiAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyAoc3BhY2UgfHwgMSk7XG5cbiAgICBpZiAocm91bmQpIHtcbiAgICAgIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgIH1cblxuICAgIHN0YXJ0ICs9IChzdG9wIC0gc3RhcnQgLSBzdGVwICogKG4gLSBwYWRkaW5nSW5uZXIpKSAqIGFsaWduO1xuICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG5cbiAgICBpZiAocm91bmQpIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5yb3VuZChzdGFydCk7XG4gICAgICBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWVzID0gcmFuZ2UobikubWFwKGkgPT4gc3RhcnQgKyBzdGVwICogaSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBkb21haW4oXyk7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9tYWluKCk7XG4gICAgfVxuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmFuZ2UkMSA9IFsrX1swXSwgK19bMV1dO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJhbmdlJDEuc2xpY2UoKTtcbiAgICB9XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmFuZ2UkMSA9IFsrX1swXSwgK19bMV1dO1xuICAgIHJvdW5kID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmJhbmR3aWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYmFuZHdpZHRoO1xuICB9O1xuXG4gIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG5cbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByb3VuZCA9ICEhXztcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb3VuZDtcbiAgICB9XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKTtcbiAgICAgIHBhZGRpbmdJbm5lciA9IHBhZGRpbmdPdXRlcjtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWRkaW5nSW5uZXI7XG4gICAgfVxuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHBhZGRpbmdJbm5lciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWRkaW5nSW5uZXI7XG4gICAgfVxuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWRkaW5nT3V0ZXI7XG4gICAgfVxuICB9O1xuXG4gIHNjYWxlLmFsaWduID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgYWxpZ24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSk7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfVxuICB9O1xuXG4gIHNjYWxlLmludmVydFJhbmdlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAvLyBiYWlsIGlmIHJhbmdlIGhhcyBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICBpZiAoX1swXSA9PSBudWxsIHx8IF9bMV0gPT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHJldmVyc2UgPSByYW5nZSQxWzFdIDwgcmFuZ2UkMVswXSxcbiAgICAgICAgICB2YWx1ZXMgPSByZXZlcnNlID8gb3JkaW5hbFJhbmdlKCkucmV2ZXJzZSgpIDogb3JkaW5hbFJhbmdlKCksXG4gICAgICAgICAgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICAgIGxldCBsbyA9ICtfWzBdLFxuICAgICAgICBoaSA9ICtfWzFdLFxuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICB0OyAvLyBiYWlsIGlmIGVpdGhlciByYW5nZSBlbmRwb2ludCBpcyBpbnZhbGlkXG5cbiAgICBpZiAobG8gIT09IGxvIHx8IGhpICE9PSBoaSkgcmV0dXJuOyAvLyBvcmRlciByYW5nZSBpbnB1dHMsIGJhaWwgaWYgb3V0c2lkZSBvZiBzY2FsZSByYW5nZVxuXG4gICAgaWYgKGhpIDwgbG8pIHtcbiAgICAgIHQgPSBsbztcbiAgICAgIGxvID0gaGk7XG4gICAgICBoaSA9IHQ7XG4gICAgfVxuXG4gICAgaWYgKGhpIDwgdmFsdWVzWzBdIHx8IGxvID4gcmFuZ2UkMVsxIC0gcmV2ZXJzZV0pIHJldHVybjsgLy8gYmluYXJ5IHNlYXJjaCB0byBpbmRleCBpbnRvIHNjYWxlIHJhbmdlXG5cbiAgICBhID0gTWF0aC5tYXgoMCwgYmlzZWN0UmlnaHQodmFsdWVzLCBsbykgLSAxKTtcbiAgICBiID0gbG8gPT09IGhpID8gYSA6IGJpc2VjdFJpZ2h0KHZhbHVlcywgaGkpIC0gMTsgLy8gaW5jcmVtZW50IGluZGV4IGEgaWYgbG8gaXMgd2l0aGluIHBhZGRpbmcgZ2FwXG5cbiAgICBpZiAobG8gLSB2YWx1ZXNbYV0gPiBiYW5kd2lkdGggKyAxZS0xMCkgKythO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIC8vIG1hcCArIHN3YXBcbiAgICAgIHQgPSBhO1xuICAgICAgYSA9IG4gLSBiO1xuICAgICAgYiA9IG4gLSB0O1xuICAgIH1cblxuICAgIHJldHVybiBhID4gYiA/IHVuZGVmaW5lZCA6IGRvbWFpbigpLnNsaWNlKGEsIGIgKyAxKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbiAoXykge1xuICAgIGNvbnN0IHZhbHVlID0gc2NhbGUuaW52ZXJ0UmFuZ2UoW18sIF9dKTtcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZVswXSA6IHZhbHVlO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJhbmQoKS5kb21haW4oZG9tYWluKCkpLnJhbmdlKHJhbmdlJDEpLnJvdW5kKHJvdW5kKS5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKS5wYWRkaW5nT3V0ZXIocGFkZGluZ091dGVyKS5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIHJlc2NhbGUoKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRpc2goc2NhbGUpIHtcbiAgY29uc3QgY29weSA9IHNjYWxlLmNvcHk7XG4gIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHBvaW50KCkge1xuICByZXR1cm4gcG9pbnRpc2goYmFuZCgpLnBhZGRpbmdJbm5lcigxKSk7XG59XG5cbnZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwO1xuZnVuY3Rpb24gbnVtYmVycyhfKSB7XG4gIHJldHVybiBtYXAuY2FsbChfLCB0b051bWJlcik7XG59XG5cbmNvbnN0IHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBzY2FsZUJpbk9yZGluYWwoKSB7XG4gIGxldCBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW107XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgfHwgeCAhPT0geCA/IHVuZGVmaW5lZCA6IHJhbmdlWyhiaXNlY3QoZG9tYWluLCB4KSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGRvbWFpbiA9IG51bWJlcnMoXyk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICB9XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByYW5nZSA9IHNsaWNlLmNhbGwoXyk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByYW5nZS5zbGljZSgpO1xuICAgIH1cbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24gKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gdGlja0Zvcm1hdCQxKGRvbWFpblswXSwgcGVlayhkb21haW4pLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzY2FsZUJpbk9yZGluYWwoKS5kb21haW4oc2NhbGUuZG9tYWluKCkpLnJhbmdlKHNjYWxlLnJhbmdlKCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuY29uc3Qgc2NhbGVzID0ge307XG4vKipcbiAqIEF1Z21lbnQgc2NhbGVzIHdpdGggdGhlaXIgdHlwZSBhbmQgbmVlZGVkIGludmVyc2UgbWV0aG9kcy5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSwgY29uc3RydWN0b3IsIG1ldGFkYXRhKSB7XG4gIGNvbnN0IGN0ciA9IGZ1bmN0aW9uIHNjYWxlKCkge1xuICAgIGNvbnN0IHMgPSBjb25zdHJ1Y3RvcigpO1xuXG4gICAgaWYgKCFzLmludmVydFJhbmdlKSB7XG4gICAgICBzLmludmVydFJhbmdlID0gcy5pbnZlcnQgPyBpbnZlcnRSYW5nZShzKSA6IHMuaW52ZXJ0RXh0ZW50ID8gaW52ZXJ0UmFuZ2VFeHRlbnQocykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcy50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gcztcbiAgfTtcblxuICBjdHIubWV0YWRhdGEgPSB0b1NldChhcnJheShtZXRhZGF0YSkpO1xuICByZXR1cm4gY3RyO1xufVxuXG5mdW5jdGlvbiBzY2FsZSh0eXBlLCBzY2FsZSwgbWV0YWRhdGEpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgc2NhbGVzW3R5cGVdID0gY3JlYXRlKHR5cGUsIHNjYWxlLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzVmFsaWRTY2FsZVR5cGUodHlwZSkgPyBzY2FsZXNbdHlwZV0gOiB1bmRlZmluZWQ7XG4gIH1cbn0gLy8gaWRlbnRpdHkgc2NhbGVcblxuc2NhbGUoSWRlbnRpdHksIHNjYWxlSWRlbnRpdHkpOyAvLyBjb250aW51b3VzIHNjYWxlc1xuXG5zY2FsZShMaW5lYXIsIHNjYWxlTGluZWFyLCBDb250aW51b3VzKTtcbnNjYWxlKExvZywgc2NhbGVMb2csIFtDb250aW51b3VzLCBMb2ddKTtcbnNjYWxlKFBvdywgc2NhbGVQb3csIENvbnRpbnVvdXMpO1xuc2NhbGUoU3FydCwgc2NhbGVTcXJ0LCBDb250aW51b3VzKTtcbnNjYWxlKFN5bWxvZywgc2NhbGVTeW1sb2csIENvbnRpbnVvdXMpO1xuc2NhbGUoVGltZSwgc2NhbGVUaW1lLCBbQ29udGludW91cywgVGVtcG9yYWxdKTtcbnNjYWxlKFVUQywgc2NhbGVVdGMsIFtDb250aW51b3VzLCBUZW1wb3JhbF0pOyAvLyBzZXF1ZW50aWFsIHNjYWxlc1xuXG5zY2FsZShTZXF1ZW50aWFsLCBzY2FsZVNlcXVlbnRpYWwsIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7IC8vIGJhY2t3YXJkcyBjb21wYXRcblxuc2NhbGUoXCJcIi5jb25jYXQoU2VxdWVudGlhbCwgXCItXCIpLmNvbmNhdChMaW5lYXIpLCBzY2FsZVNlcXVlbnRpYWwsIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5zY2FsZShcIlwiLmNvbmNhdChTZXF1ZW50aWFsLCBcIi1cIikuY29uY2F0KExvZyksIHNjYWxlU2VxdWVudGlhbExvZywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmcsIExvZ10pO1xuc2NhbGUoXCJcIi5jb25jYXQoU2VxdWVudGlhbCwgXCItXCIpLmNvbmNhdChQb3cpLCBzY2FsZVNlcXVlbnRpYWxQb3csIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5zY2FsZShcIlwiLmNvbmNhdChTZXF1ZW50aWFsLCBcIi1cIikuY29uY2F0KFNxcnQpLCBzY2FsZVNlcXVlbnRpYWxTcXJ0LCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pO1xuc2NhbGUoXCJcIi5jb25jYXQoU2VxdWVudGlhbCwgXCItXCIpLmNvbmNhdChTeW1sb2cpLCBzY2FsZVNlcXVlbnRpYWxTeW1sb2csIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7IC8vIGRpdmVyZ2luZyBzY2FsZXNcblxuc2NhbGUoXCJcIi5jb25jYXQoRGl2ZXJnaW5nLCBcIi1cIikuY29uY2F0KExpbmVhciksIHNjYWxlRGl2ZXJnaW5nLCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pO1xuc2NhbGUoXCJcIi5jb25jYXQoRGl2ZXJnaW5nLCBcIi1cIikuY29uY2F0KExvZyksIHNjYWxlRGl2ZXJnaW5nTG9nLCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZywgTG9nXSk7XG5zY2FsZShcIlwiLmNvbmNhdChEaXZlcmdpbmcsIFwiLVwiKS5jb25jYXQoUG93KSwgc2NhbGVEaXZlcmdpbmdQb3csIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5zY2FsZShcIlwiLmNvbmNhdChEaXZlcmdpbmcsIFwiLVwiKS5jb25jYXQoU3FydCksIHNjYWxlRGl2ZXJnaW5nU3FydCwgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTtcbnNjYWxlKFwiXCIuY29uY2F0KERpdmVyZ2luZywgXCItXCIpLmNvbmNhdChTeW1sb2cpLCBzY2FsZURpdmVyZ2luZ1N5bWxvZywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTsgLy8gZGlzY3JldGl6aW5nIHNjYWxlc1xuXG5zY2FsZShRdWFudGlsZSwgc2NhbGVRdWFudGlsZSwgW0Rpc2NyZXRpemluZywgUXVhbnRpbGVdKTtcbnNjYWxlKFF1YW50aXplLCBzY2FsZVF1YW50aXplLCBEaXNjcmV0aXppbmcpO1xuc2NhbGUoVGhyZXNob2xkLCBzY2FsZVRocmVzaG9sZCwgRGlzY3JldGl6aW5nKTsgLy8gZGlzY3JldGUgc2NhbGVzXG5cbnNjYWxlKEJpbk9yZGluYWwsIHNjYWxlQmluT3JkaW5hbCwgW0Rpc2NyZXRlLCBEaXNjcmV0aXppbmddKTtcbnNjYWxlKE9yZGluYWwsIHNjYWxlT3JkaW5hbCwgRGlzY3JldGUpO1xuc2NhbGUoQmFuZCwgYmFuZCwgRGlzY3JldGUpO1xuc2NhbGUoUG9pbnQsIHBvaW50LCBEaXNjcmV0ZSk7XG5mdW5jdGlvbiBpc1ZhbGlkU2NhbGVUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHNjYWxlcywgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIGhhc1R5cGUoa2V5LCB0eXBlKSB7XG4gIGNvbnN0IHMgPSBzY2FsZXNba2V5XTtcbiAgcmV0dXJuIHMgJiYgcy5tZXRhZGF0YVt0eXBlXTtcbn1cblxuZnVuY3Rpb24gaXNDb250aW51b3VzKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIENvbnRpbnVvdXMpO1xufVxuZnVuY3Rpb24gaXNEaXNjcmV0ZShrZXkpIHtcbiAgcmV0dXJuIGhhc1R5cGUoa2V5LCBEaXNjcmV0ZSk7XG59XG5mdW5jdGlvbiBpc0Rpc2NyZXRpemluZyhrZXkpIHtcbiAgcmV0dXJuIGhhc1R5cGUoa2V5LCBEaXNjcmV0aXppbmcpO1xufVxuZnVuY3Rpb24gaXNMb2dhcml0aG1pYyhrZXkpIHtcbiAgcmV0dXJuIGhhc1R5cGUoa2V5LCBMb2cpO1xufVxuZnVuY3Rpb24gaXNUZW1wb3JhbChrZXkpIHtcbiAgcmV0dXJuIGhhc1R5cGUoa2V5LCBUZW1wb3JhbCk7XG59XG5mdW5jdGlvbiBpc0ludGVycG9sYXRpbmcoa2V5KSB7XG4gIHJldHVybiBoYXNUeXBlKGtleSwgSW50ZXJwb2xhdGluZyk7XG59XG5mdW5jdGlvbiBpc1F1YW50aWxlKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIFF1YW50aWxlKTtcbn1cblxuY29uc3Qgc2NhbGVQcm9wcyA9IFsnY2xhbXAnLCAnYmFzZScsICdjb25zdGFudCcsICdleHBvbmVudCddO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVSYW5nZShpbnRlcnBvbGF0b3IsIHJhbmdlKSB7XG4gIGNvbnN0IHN0YXJ0ID0gcmFuZ2VbMF0sXG4gICAgICAgIHNwYW4gPSBwZWVrKHJhbmdlKSAtIHN0YXJ0O1xuICByZXR1cm4gZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdG9yKHN0YXJ0ICsgaSAqIHNwYW4pO1xuICB9O1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVDb2xvcnMoY29sb3JzLCB0eXBlLCBnYW1tYSkge1xuICByZXR1cm4gcGllY2V3aXNlKGludGVycG9sYXRlKHR5cGUgfHwgJ3JnYicsIGdhbW1hKSwgY29sb3JzKTtcbn1cbmZ1bmN0aW9uIHF1YW50aXplSW50ZXJwb2xhdG9yKGludGVycG9sYXRvciwgY291bnQpIHtcbiAgY29uc3Qgc2FtcGxlcyA9IG5ldyBBcnJheShjb3VudCksXG4gICAgICAgIG4gPSBjb3VudCArIDE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDspIHNhbXBsZXNbaV0gPSBpbnRlcnBvbGF0b3IoKytpIC8gbik7XG5cbiAgcmV0dXJuIHNhbXBsZXM7XG59XG5mdW5jdGlvbiBzY2FsZUNvcHkoc2NhbGUpIHtcbiAgY29uc3QgdCA9IHNjYWxlLnR5cGUsXG4gICAgICAgIHMgPSBzY2FsZS5jb3B5KCk7XG4gIHMudHlwZSA9IHQ7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gc2NhbGVGcmFjdGlvbihzY2FsZSQxLCBtaW4sIG1heCkge1xuICBjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcbiAgbGV0IGksIHQsIHM7XG5cbiAgaWYgKCFkZWx0YSB8fCAhTnVtYmVyLmlzRmluaXRlKGRlbHRhKSkge1xuICAgIHJldHVybiBjb25zdGFudCgwLjUpO1xuICB9IGVsc2Uge1xuICAgIGkgPSAodCA9IHNjYWxlJDEudHlwZSkuaW5kZXhPZignLScpO1xuICAgIHQgPSBpIDwgMCA/IHQgOiB0LnNsaWNlKGkgKyAxKTtcbiAgICBzID0gc2NhbGUodCkoKS5kb21haW4oW21pbiwgbWF4XSkucmFuZ2UoWzAsIDFdKTtcbiAgICBzY2FsZVByb3BzLmZvckVhY2gobSA9PiBzY2FsZSQxW21dID8gc1ttXShzY2FsZSQxW21dKCkpIDogMCk7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKHR5cGUsIGdhbW1hKSB7XG4gIGNvbnN0IGludGVycCA9ICRbbWV0aG9kKHR5cGUpXTtcbiAgcmV0dXJuIGdhbW1hICE9IG51bGwgJiYgaW50ZXJwICYmIGludGVycC5nYW1tYSA/IGludGVycC5nYW1tYShnYW1tYSkgOiBpbnRlcnA7XG59XG5cbmZ1bmN0aW9uIG1ldGhvZCh0eXBlKSB7XG4gIHJldHVybiAnaW50ZXJwb2xhdGUnICsgdHlwZS50b0xvd2VyQ2FzZSgpLnNwbGl0KCctJykubWFwKHMgPT4gc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKSkuam9pbignJyk7XG59XG5cbmNvbnN0IGNvbnRpbnVvdXMgPSB7XG4gIGJsdWVzOiAnY2ZlMWYyYmVkOGVjYThjZWU1OGZjMWRlNzRiMmQ3NWJhM2NmNDU5MmM2MzE4MWJkMjA2ZmIyMTI1Y2E0MGE0YTkwJyxcbiAgZ3JlZW5zOiAnZDNlZWNkYzBlNmJhYWJkZGE1OTRkMzkxN2JjNzdkNjBiYTZjNDZhYjVlMzI5YTUxMjA4OTQzMGU3NzM1MDM2NDI5JyxcbiAgZ3JleXM6ICdlMmUyZTJkNGQ0ZDRjNGM0YzRiMWIxYjE5ZDlkOWQ4ODg4ODg3NTc1NzU2MjYyNjI0ZDRkNGQzNTM1MzUxZTFlMWUnLFxuICBvcmFuZ2VzOiAnZmRkOGIzZmRjOTk4ZmRiODdiZmRhNTVlZmM5MjQ0Zjg3ZjJjZjA2YjE4ZTQ1ODBiZDE0OTA0YjkzZDAyOWYzMzAzJyxcbiAgcHVycGxlczogJ2UyZTFlZmQ0ZDRlOGM0YzVlMGI0YjNkNmEzYTBjYzkyOGVjMzgyN2NiOTc1NjZhZTY4NGVhMjVjMzY5NjUwMWY4YycsXG4gIHJlZHM6ICdmZGM5YjRmY2I0OWFmYzllODBmYzg3NjdmYTcwNTFmNjU3M2ZlYzNmMmZkYzJhMjVjODFiMWRiMjEyMTg5NzBiMTMnLFxuICBibHVlR3JlZW46ICdkNWVmZWRjMWU4ZTBhN2RkZDE4YmQyYmU3MGM2YTk1OGJhOTE0NGFkNzczMTljNWQyMDg5NDYwZTc3MzYwMzY0MjknLFxuICBibHVlUHVycGxlOiAnY2NkZGVjYmFkMGU0YThjMmRkOWFiMGQ0OTE5Y2M5OGQ4NWJlOGI2ZGIyOGE1NWE2ODczYzk5ODIyMjg3NzMwZjcxJyxcbiAgZ3JlZW5CbHVlOiAnZDNlZWNlYzVlOGMzYjFlMWJiOWJkOGJiODJjZWMyNjljMmNhNTFiMmNkM2M5ZmM3Mjg4YWJkMTY3NWIxMGI2MGExJyxcbiAgb3JhbmdlUmVkOiAnZmRkY2FmZmRjZjliZmRjMThhZmRhZDc3ZmI5NTYyZjY3ZDUzZWU2NTQ1ZTI0OTMyZDMyZDFlYmYxMzBkYTcwNDAzJyxcbiAgcHVycGxlQmx1ZTogJ2RiZGFlYmM4Y2VlNGIxYzNkZTk3YjdkODdiYWNkMTViOWZjOTNhOTBjMDFlN2ZiNzBiNzBhYjA1NjE5OTA0NTI4MScsXG4gIHB1cnBsZUJsdWVHcmVlbjogJ2RiZDhlYWM4Y2VlNGIwYzNkZTkzYjdkODcyYWNkMTU0OWZjODM4OTJiYjFjODhhMzA5N2Y4NzAyNzM2YjAxNjM1MycsXG4gIHB1cnBsZVJlZDogJ2RjYzllMmQzYjNkN2NlOWVjY2QxODZjMGRhNmJiMmUxNGRhMGUyMzE4OWQ5MWU2ZmM2MTE1OWFiMDc0OThmMDIzYScsXG4gIHJlZFB1cnBsZTogJ2ZjY2ZjY2ZjYmVjMGZhYTliOGY5OGZhZmY1NzFhNWVjNTM5ZGRiMzY5NWM0MWI4YWE5MDg4MDhkMDE3OTcwMDE3NCcsXG4gIHllbGxvd0dyZWVuOiAnZTRmNGFjZDFlY2EwYjllMjk0OWVkNjg4ODBjOTdjNjJiYjZlNDdhYTVlMzI5NzUwMjA4MzQ0MGU3MjNiMDM2MDM0JyxcbiAgeWVsbG93T3JhbmdlQnJvd246ICdmZWVhYTFmZWRkODRmZWNjNjNmZWI3NDZmY2EwMzFmNjg5MjFlYjcyMTVkYjVlMGJjNTRjMDVhYjNkMDM4ZjMyMDQnLFxuICB5ZWxsb3dPcmFuZ2VSZWQ6ICdmZWUwODdmZWQxNmZmZWJkNTlmZWE4NDlmZDkwM2VmYzczMzVmOTUyMmJlZTM0MjNkZTFiMjBjYTBiMjJhZjAyMjUnLFxuICBibHVlT3JhbmdlOiAnMTM0Yjg1MmY3OGIzNWRhMmNiOWRjYWUxZDJlNWVmZjJmMGViZmNlMGJhZmJiZjc0ZTg5MzJmYzU2OTBkOTk0YTA3JyxcbiAgYnJvd25CbHVlR3JlZW46ICc3MDQxMDhhMDY1MWFjNzk1NDhlM2M3OGFmM2U2YzZlZWYxZWFjOWU5ZTQ4ZWQxYzc0ZGE3OWUxODdhNzIwMjUxNDcnLFxuICBwdXJwbGVHcmVlbjogJzViMTY2NzgzNDc5MmE2N2ZiNmM5YWVkM2U2ZDZlOGVmZjBlZmQ5ZWZkNWFlZGRhOTcxYmI3NTM2OGU0OTBlNWUyOScsXG4gIHB1cnBsZU9yYW5nZTogJzQxMTQ2OTY2NDc5NjhmODNiN2I5YjRkNmRhZGJlYmYzZWVlYWZjZTBiYWZiYmY3NGU4OTMyZmM1NjkwZDk5NGEwNycsXG4gIHJlZEJsdWU6ICc4YzBkMjViZjM2M2FkZjc0NWVmNGFlOTFmYmRiYzlmMmVmZWVkMmU1ZWY5ZGNhZTE1ZGEyY2IyZjc4YjMxMzRiODUnLFxuICByZWRHcmV5OiAnOGMwZDI1YmYzNjNhZGY3NDVlZjRhZTkxZmNkY2NiZmFmNGYxZTJlMmUyYzBjMGMwOTY5Njk2NjQ2NDY0MzQzNDM0JyxcbiAgeWVsbG93R3JlZW5CbHVlOiAnZWZmOWJkZGJmMWI0YmRlNWI1OTRkNWI5NjljNWJlNDViNGMyMmM5ZWMwMjE4MmI4MjE2M2FhMjM0NzljMWMzMTg1JyxcbiAgcmVkWWVsbG93Qmx1ZTogJ2E1MDAyNmQ0MzIyY2YxNmU0M2ZjYWM2NGZlZGQ5MGZhZjhjMWRjZjFlY2FiZDZlODc1YWJkMDRhNzRiNDMxMzY5NScsXG4gIHJlZFllbGxvd0dyZWVuOiAnYTUwMDI2ZDQzMjJjZjE2ZTQzZmNhYzYzZmVkZDhkZjlmN2FlZDdlZThlYTRkODZlNjRiYzYxMjI5NjRmMDA2ODM3JyxcbiAgcGlua1llbGxvd0dyZWVuOiAnOGUwMTUyYzAyNjdlZGQ3MmFkZjBiM2Q2ZmFkZGVkZjVmM2VmZTFmMmNhYjZkZTg3ODBiYjQ3NGY5MTI1Mjc2NDE5JyxcbiAgc3BlY3RyYWw6ICc5ZTAxNDJkMTNjNGJmMDcwNGFmY2FjNjNmZWRkOGRmYmY4YjBlMGYzYTFhOWRkYTI2OWJkYTk0Mjg4YjU1ZTRmYTInLFxuICB2aXJpZGlzOiAnNDQwMTU0NDcwZTYxNDgxYTZjNDgyNTc1NDcyZjdkNDQzYTgzNDE0NDg3M2Q0ZThhMzk1NjhjMzU2MDhkMzE2ODhlMmQ3MDhlMmE3ODhlMjc4MThlMjM4ODhlMjE5MThkMWY5ODhiMWZhMDg4MjJhODg0MmFiMDdmMzViNzc5NDNiZjcxNTRjNTY4NjZjYzVkN2FkMTUxOGZkNzQ0YTVkYjM2YmNkZjI3ZDJlMjFiZTllNTFhZmRlNzI1JyxcbiAgbWFnbWE6ICcwMDAwMDQwNDA0MTMwYjA5MjQxNTBlMzcyMDExNGIyYzExNjAzYjBmNzA0YTEwNzk1NzE1N2U2NTFhODA3MjFmODE3ZjI0ODI4YzI5ODE5YTJlODBhODMyN2RiNjM3N2FjNDNjNzVkMTQyNmZkZTQ5NjhlOTU0NjJmMTYwNWRmNzZmNWNmYTdmNWVmYzhmNjVmZTlmNmRmZWFmNzhmZWJmODRmZWNlOTFmZGRlYTBmY2VkYWZmY2ZkYmYnLFxuICBpbmZlcm5vOiAnMDAwMDA0MDQwMzEzMGMwODI2MTcwYzNiMjQwYzRmMzMwYTVmNDIwYTY4NTAwZDZjNWQxMjZlNmIxNzZlNzgxYzZkODYyMTZiOTMyNjY3YTEyYjYyYWUzMDVjYmIzNzU1YzczZTRjZDI0NjQ0ZGQ1MTNhZTY1YzMwZWQ2OTI1ZjM3NzFhZjg4NTBmZmI5NTA2ZmNhNTBhZmNiNTE5ZmFjNjJkZjZkNjQ1ZjJlNjYxZjNmNDg0ZmNmZmE0JyxcbiAgcGxhc21hOiAnMGQwODg3MjMwNjkwMzMwNTk3NDIwMzlkNTAwMmEyNWQwMWE2NmEwMGE4NzgwMWE4ODQwNWE3OTAwZGE0OWMxNzllYTcyMTk4YjEyYTkwYmEzNDg4YzMzZDgwY2I0Nzc5ZDM1MTcxZGE1YTY5ZTE2NDYyZTc2ZTViZWQ3OTUzZjI4MzRjZjY4ZjQ0ZmE5YTNkZmNhNjM2ZmRiMzJmZmVjMDI5ZmNjZTI1ZjlkYzI0ZjVlYTI3ZjBmOTIxJyxcbiAgY2l2aWRpczogJzAwMjA1MTAwMjM1ODAwMjY1ZDAwMjk2MTAxMmI2NTA0MmU2NzA4MzE2OTBkMzQ2YjExMzY2YzE2Mzk2ZDFjM2M2ZTIxM2Y2ZTI2NDI2ZTJjNDU2ZTMxNDc2ZTM3NGE2ZTNjNGQ2ZTQyNTA2ZTQ3NTM2ZDRjNTY2ZDUxNTg2ZTU1NWI2ZTVhNWU2ZTVlNjE2ZTYyNjQ2ZjY2Njc2ZjZhNmE3MDZlNmQ3MTcyNzA3MTc1NzM3Mjc5NzY3MzdjNzk3NDdmN2M3NTgyN2Y3NTg2ODI3Njg5ODU3NzhjODg3NzkwOGI3ODkzOGU3ODk2OTE3ODlhOTQ3ODllOTc3OGExOWI3OGE1OWU3N2E5YTE3N2FlYTU3NWIyYTg3NGI2YWI3M2JiYWY3MWMwYjI2ZmM1YjY2ZGM5Yjk2YWNlYmQ2OGQzYzA2NWQ4YzQ2MmRkYzg1ZmUyY2I1Y2U3Y2Y1OGViZDM1NWYwZDY1MmYzZGE0ZmY3ZGU0Y2ZhZTI0OWZjZTY0NycsXG4gIHJhaW5ib3c6ICc2ZTQwYWE4ODNlYjFhNDNkYjNiZjNjYWZkODNmYTRlZTQzOTVmZTRiODNmZjU3NmVmZjY2NTlmZjc4NDdmZjhjMzhmM2ExMzBlMmI3MmZjZmNjMzZiZWUwNDRhZmYwNWI4ZmY0NTc2ZmY2NWI1MmY2NjczYWYyNzgyOGVhOGQxZGRmYTMxOWQwYjgxY2JlY2IyM2FiZDgyZjk2ZTAzZDgyZTE0YzZlZGI1YTVkZDA2NjRkYmY2ZTQwYWEnLFxuICBzaW5lYm93OiAnZmY0MDQwZmM1ODJhZjQ3MjE4ZTc4ZDBiZDVhNzAzYmZiZjAwYTdkNTAzOGRlNzBiNzJmNDE4NThmYzJhNDBmZjQwMmFmYzU4MThmNDcyMGJlNzhkMDNkNWE3MDBiZmJmMDNhN2Q1MGI4ZGU3MTg3MmY0MmE1OGZjNDA0MGZmNTgyYWZjNzIxOGY0OGQwYmU3YTcwM2Q1YmYwMGJmZDUwM2E3ZTcwYjhkZjQxODcyZmMyYTU4ZmY0MDQwJyxcbiAgdHVyYm86ICcyMzE3MWIzMjIwNGEzZTJhNzE0NTM0OTM0OTNlYWU0YjQ5YzU0YTUzZDc0ODVlZTQ0NTY5ZWU0MDc0ZjUzYzdmZjgzNzhhZjkzMjk1ZjcyZTlmZjQyYmE5ZWYyOGIzZTkyNmJjZTEyNWM1ZDkyNWNkY2YyN2Q1YzYyOWRjYmMyZGUzYjIzMmU5YTczOGVlOWQzZmYzOTM0N2Y2ODk1MGY5ODA1YWZjNzc2NWZkNmU3MGZlNjY3Y2ZkNWU4OGZjNTc5NWZiNTFhMWY4NGJhZGY1NDViOWYxNDBjNWVjM2NkMGU2MzdkYWUwMzRlNGQ5MzFlY2QxMmVmNGM5MmJmYWMwMjlmZmI2MjZmZmFkMjRmZmEyMjNmZjk4MjFmZjhkMWZmZjgyMWRmZjc3MWNmZDZjMWFmNzYxMThmMDU2MTZlODRiMTRkZjQxMTFkNTM4MGZjYjJmMGRjMDI2MGFiNjFmMDdhYzE4MDVhMzEzMDI5YjBmMDA5NTBjMDA5MTBiMDAnLFxuICBicm93bnM6ICdlZWRiYmRlY2NhOTZlOWI5N2FlNGE4NjVkYzk4NTZkMTg5NTRjNzc4NGNjMDY3M2ZiODU1MzZhZDQ0MzM5ZjM2MzInLFxuICB0ZWFsQmx1ZXM6ICdiY2U0ZDg5ZGQzZDE4MWMzY2I2NWIzYzI0NWEyYjkzNjhmYWUzNDdkYTAzMDZhOTMyYzU5ODUnLFxuICB0ZWFsczogJ2JiZGZkZmEyZDRkNThhYzljOTc1YmNiYjYxYjBhZjRkYTVhNDM3OTk5ODJiOGI4YzFlN2Y3ZjEyNzI3MzAwNjY2NycsXG4gIHdhcm1HcmV5czogJ2RjZDRkMGNlYzVjMWMwYjhiNGIzYWFhN2E1OWM5OTk4OTA4YzhiODI3ZjdlNzY3MzcyNjg2NjY2NWM1YTU5NTA0ZScsXG4gIGdvbGRHcmVlbjogJ2Y0ZDE2NmQ1Y2E2MGI2YzM1Yzk4YmI1OTdjYjI1NzYwYTY1NjRiOWM1MzNmOGY0ZjMzODM0YTI1Nzc0MDE0NmMzNicsXG4gIGdvbGRPcmFuZ2U6ICdmNGQxNjZmOGJlNWNmOGFhNGNmNTk4M2JmMzg1MmFlZjcwMWJlMjYyMWZkNjUzMjJjNTQ5MjNiMTQyMjM5ZTNhMjYnLFxuICBnb2xkUmVkOiAnZjRkMTY2ZjZiZTU5ZjlhYTUxZmM5NjRlZjY4MzRiZWU3MzRhZTU2MjQ5ZGI1MjQ3Y2Y0MjQ0YzQzMTQxYjcxZDNlJyxcbiAgbGlnaHRHcmV5UmVkOiAnZWZlOWU2ZTFkYWQ3ZDVjYmM4YzhiZGI5YmJhZWE5Y2Q5NjdkZGM3YjQzZTE1ZjE5ZGY0MDExZGMwMDBiJyxcbiAgbGlnaHRHcmV5VGVhbDogJ2U0ZWFlYWQ2ZGNkZGM4Y2VkMmI3YzJjN2E2YjRiYzY0YjBiZjIyYTZjMzIyOTVjMTFmODViZTE4NzZiYycsXG4gIGxpZ2h0TXVsdGk6ICdlMGYxZjJjNGU5ZDBiMGRlOWZkMGUxODFmNmUwNzJmNmMwNTNmMzk5M2VmNzc0NDBlZjRhM2MnLFxuICBsaWdodE9yYW5nZTogJ2YyZTdkYWY3ZDViYWY5YzQ5OWZhYjE4NGZhOWM3M2Y2ODk2N2VmNzg2MGU4NjQ1YmRlNTE1YmQ0M2Q1YicsXG4gIGxpZ2h0VGVhbEJsdWU6ICdlM2U5ZTBjMGRjY2Y5YWNlY2E3YWJmYzg1OWFmYzAzODlmYjkzMjhkYWQyZjdjYTAyNzZiOTUyNTU5ODgnLFxuICBkYXJrQmx1ZTogJzMyMzIzMjJkNDY2ODFhNWM5MzAwNzRhZjAwOGNiZjA1YTdjZTI1YzBkZDM4ZGFlZDUwZjNmYWZmZmZmZicsXG4gIGRhcmtHb2xkOiAnM2MzYzNjNTg0YjM3NzI1ZTM0OGM3NjMxYWU4YjJiY2ZhNDI0ZWNjMzFlZjlkZTMwZmZmMTg0ZmZmZmZmJyxcbiAgZGFya0dyZWVuOiAnM2EzYTNhMjE1NzQ4MDA2ZjRkMDQ4OTQyNDg5ZTQyNzZiMzQwYTZjNjNkZDJkODM2ZmZlYjJjZmZmZmFhJyxcbiAgZGFya011bHRpOiAnMzczNzM3MWY1Mjg3MTk3ZDhjMjlhODY5OTVjZTNmZmZlODAwZmZmZmZmJyxcbiAgZGFya1JlZDogJzM0MzQzNDcwMzYzMzllM2MzOGNjNDAzN2U3NWQxZWVjODYyMGVlYWIyOWYwY2UzMmZmZWIyYydcbn07XG5jb25zdCBkaXNjcmV0ZSA9IHtcbiAgY2F0ZWdvcnkxMDogJzFmNzdiNGZmN2YwZTJjYTAyY2Q2MjcyODk0NjdiZDhjNTY0YmUzNzdjMjdmN2Y3ZmJjYmQyMjE3YmVjZicsXG4gIGNhdGVnb3J5MjA6ICcxZjc3YjRhZWM3ZThmZjdmMGVmZmJiNzgyY2EwMmM5OGRmOGFkNjI3MjhmZjk4OTY5NDY3YmRjNWIwZDU4YzU2NGJjNDljOTRlMzc3YzJmN2I2ZDI3ZjdmN2ZjN2M3YzdiY2JkMjJkYmRiOGQxN2JlY2Y5ZWRhZTUnLFxuICBjYXRlZ29yeTIwYjogJzM5M2I3OTUyNTRhMzZiNmVjZjljOWVkZTYzNzkzOThjYTI1MmI1Y2Y2YmNlZGI5YzhjNmQzMWJkOWUzOWU3YmE1MmU3Y2I5NDg0M2MzOWFkNDk0YWQ2NjE2YmU3OTY5YzdiNDE3M2E1NTE5NGNlNmRiZGRlOWVkNicsXG4gIGNhdGVnb3J5MjBjOiAnMzE4MmJkNmJhZWQ2OWVjYWUxYzZkYmVmZTY1NTBkZmQ4ZDNjZmRhZTZiZmRkMGEyMzFhMzU0NzRjNDc2YTFkOTliYzdlOWMwNzU2YmIxOWU5YWM4YmNiZGRjZGFkYWViNjM2MzYzOTY5Njk2YmRiZGJkZDlkOWQ5JyxcbiAgdGFibGVhdTEwOiAnNGM3OGE4ZjU4NTE4ZTQ1NzU2NzJiN2IyNTRhMjRiZWVjYTNiYjI3OWEyZmY5ZGE2OWQ3NTVkYmFiMGFjJyxcbiAgdGFibGVhdTIwOiAnNGM3OGE4OWVjYWU5ZjU4NTE4ZmZiZjc5NTRhMjRiODhkMjdhYjc5YTIwZjJjZjViNDM5ODk0ODNiY2I2ZTQ1NzU2ZmY5ZDk4Nzk3MDZlYmFiMGFjZDY3MTk1ZmNiZmQyYjI3OWEyZDZhNWM5OWU3NjVmZDhiNWE1JyxcbiAgYWNjZW50OiAnN2ZjOTdmYmVhZWQ0ZmRjMDg2ZmZmZjk5Mzg2Y2IwZjAwMjdmYmY1YjE3NjY2NjY2JyxcbiAgZGFyazI6ICcxYjllNzdkOTVmMDI3NTcwYjNlNzI5OGE2NmE2MWVlNmFiMDJhNjc2MWQ2NjY2NjYnLFxuICBwYWlyZWQ6ICdhNmNlZTMxZjc4YjRiMmRmOGEzM2EwMmNmYjlhOTllMzFhMWNmZGJmNmZmZjdmMDBjYWIyZDY2YTNkOWFmZmZmOTliMTU5MjgnLFxuICBwYXN0ZWwxOiAnZmJiNGFlYjNjZGUzY2NlYmM1ZGVjYmU0ZmVkOWE2ZmZmZmNjZTVkOGJkZmRkYWVjZjJmMmYyJyxcbiAgcGFzdGVsMjogJ2IzZTJjZGZkY2RhY2NiZDVlOGY0Y2FlNGU2ZjVjOWZmZjJhZWYxZTJjY2NjY2NjYycsXG4gIHNldDE6ICdlNDFhMWMzNzdlYjg0ZGFmNGE5ODRlYTNmZjdmMDBmZmZmMzNhNjU2MjhmNzgxYmY5OTk5OTknLFxuICBzZXQyOiAnNjZjMmE1ZmM4ZDYyOGRhMGNiZTc4YWMzYTZkODU0ZmZkOTJmZTVjNDk0YjNiM2IzJyxcbiAgc2V0MzogJzhkZDNjN2ZmZmZiM2JlYmFkYWZiODA3MjgwYjFkM2ZkYjQ2MmIzZGU2OWZjY2RlNWQ5ZDlkOWJjODBiZGNjZWJjNWZmZWQ2Zidcbn07XG5cbmZ1bmN0aW9uIGNvbG9ycyhwYWxldHRlKSB7XG4gIGNvbnN0IG4gPSBwYWxldHRlLmxlbmd0aCAvIDYgfCAwLFxuICAgICAgICBjID0gbmV3IEFycmF5KG4pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjspIHtcbiAgICBjW2ldID0gJyMnICsgcGFsZXR0ZS5zbGljZShpICogNiwgKytpICogNik7XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gYXBwbHkoXywgZikge1xuICBmb3IgKGNvbnN0IGsgaW4gXykgc2NoZW1lKGssIGYoX1trXSkpO1xufVxuXG5jb25zdCBzY2hlbWVzID0ge307XG5hcHBseShkaXNjcmV0ZSwgY29sb3JzKTtcbmFwcGx5KGNvbnRpbnVvdXMsIF8gPT4gaW50ZXJwb2xhdGVDb2xvcnMoY29sb3JzKF8pKSk7XG5mdW5jdGlvbiBzY2hlbWUobmFtZSwgc2NoZW1lKSB7XG4gIG5hbWUgPSBuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBzY2hlbWVzW25hbWVdID0gc2NoZW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzY2hlbWVzW25hbWVdO1xuICB9XG59XG5cbmNvbnN0IFN5bWJvbExlZ2VuZCA9ICdzeW1ib2wnO1xuY29uc3QgRGlzY3JldGVMZWdlbmQgPSAnZGlzY3JldGUnO1xuY29uc3QgR3JhZGllbnRMZWdlbmQgPSAnZ3JhZGllbnQnO1xuXG5jb25zdCBkZWZhdWx0Rm9ybWF0dGVyID0gdmFsdWUgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBTdHJpbmcodikpIDogU3RyaW5nKHZhbHVlKTtcblxuY29uc3QgYXNjZW5kaW5nID0gKGEsIGIpID0+IGFbMV0gLSBiWzFdO1xuXG5jb25zdCBkZXNjZW5kaW5nID0gKGEsIGIpID0+IGJbMV0gLSBhWzFdO1xuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHRpY2sgY291bnQgb3IgaW50ZXJ2YWwgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZSAtIFRoZSBzY2FsZSBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgdGljayB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IGNvdW50IC0gVGhlIGRlc2lyZWQgdGljayBjb3VudCBvciBpbnRlcnZhbCBzcGVjaWZpZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3RlcCAtIFRoZSBkZXNpcmVkIG1pbmltdW0gc3RlcCBiZXR3ZWVuIHRpY2sgdmFsdWVzLlxuICogQHJldHVybiB7Kn0gLSBUaGUgdGljayBjb3VudCBvciBpbnRlcnZhbCBmdW5jdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRpY2tDb3VudChzY2FsZSwgY291bnQsIG1pblN0ZXApIHtcbiAgbGV0IHN0ZXA7XG5cbiAgaWYgKGlzTnVtYmVyKGNvdW50KSkge1xuICAgIGlmIChzY2FsZS5iaW5zKSB7XG4gICAgICBjb3VudCA9IE1hdGgubWF4KGNvdW50LCBzY2FsZS5iaW5zLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKG1pblN0ZXAgIT0gbnVsbCkge1xuICAgICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgTWF0aC5mbG9vcihzcGFuKHNjYWxlLmRvbWFpbigpKSAvIG1pblN0ZXAgfHwgMSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc09iamVjdChjb3VudCkpIHtcbiAgICBzdGVwID0gY291bnQuc3RlcDtcbiAgICBjb3VudCA9IGNvdW50LmludGVydmFsO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKGNvdW50KSkge1xuICAgIGNvdW50ID0gc2NhbGUudHlwZSA9PT0gVGltZSA/IHRpbWVJbnRlcnZhbChjb3VudCkgOiBzY2FsZS50eXBlID09IFVUQyA/IHV0Y0ludGVydmFsKGNvdW50KSA6IGVycm9yKCdPbmx5IHRpbWUgYW5kIHV0YyBzY2FsZXMgYWNjZXB0IGludGVydmFsIHN0cmluZ3MuJyk7XG4gICAgaWYgKHN0ZXApIGNvdW50ID0gY291bnQuZXZlcnkoc3RlcCk7XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG59XG4vKipcbiAqIEZpbHRlciBhIHNldCBvZiBjYW5kaWRhdGUgdGljayB2YWx1ZXMsIGVuc3VyaW5nIHRoYXQgb25seSB0aWNrIHZhbHVlc1xuICogdGhhdCBsaWUgd2l0aGluIHRoZSBzY2FsZSByYW5nZSBhcmUgaW5jbHVkZWQuXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZSAtIFRoZSBzY2FsZSBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgdGljayB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSB0aWNrcyAtIFRoZSBjYW5kaWRhdGUgdGljayB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IGNvdW50IC0gVGhlIHRpY2sgY291bnQgb3IgaW50ZXJ2YWwgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheTwqPn0gLSBUaGUgZmlsdGVyZWQgdGljayB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRUaWNrcyhzY2FsZSwgdGlja3MsIGNvdW50KSB7XG4gIGxldCByYW5nZSA9IHNjYWxlLnJhbmdlKCksXG4gICAgICBsbyA9IHJhbmdlWzBdLFxuICAgICAgaGkgPSBwZWVrKHJhbmdlKSxcbiAgICAgIGNtcCA9IGFzY2VuZGluZztcblxuICBpZiAobG8gPiBoaSkge1xuICAgIHJhbmdlID0gaGk7XG4gICAgaGkgPSBsbztcbiAgICBsbyA9IHJhbmdlO1xuICAgIGNtcCA9IGRlc2NlbmRpbmc7XG4gIH1cblxuICBsbyA9IE1hdGguZmxvb3IobG8pO1xuICBoaSA9IE1hdGguY2VpbChoaSk7IC8vIGZpbHRlciB0aWNrcyB0byB2YWxpZCB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZVxuICAvLyBhZGRpdGlvbmFsbHkgc29ydCB0aWNrcyBpbiByYW5nZSBvcmRlciAoIzI1NzkpXG5cbiAgdGlja3MgPSB0aWNrcy5tYXAodiA9PiBbdiwgc2NhbGUodildKS5maWx0ZXIoXyA9PiBsbyA8PSBfWzFdICYmIF9bMV0gPD0gaGkpLnNvcnQoY21wKS5tYXAoXyA9PiBfWzBdKTtcblxuICBpZiAoY291bnQgPiAwICYmIHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBlbmRwb2ludHMgPSBbdGlja3NbMF0sIHBlZWsodGlja3MpXTtcblxuICAgIHdoaWxlICh0aWNrcy5sZW5ndGggPiBjb3VudCAmJiB0aWNrcy5sZW5ndGggPj0gMykge1xuICAgICAgdGlja3MgPSB0aWNrcy5maWx0ZXIoKF8sIGkpID0+ICEoaSAlIDIpKTtcbiAgICB9XG5cbiAgICBpZiAodGlja3MubGVuZ3RoIDwgMykge1xuICAgICAgdGlja3MgPSBlbmRwb2ludHM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSB0aWNrIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHNjYWxlIGFuZCBhcHByb3hpbWF0ZSB0aWNrIGNvdW50IG9yXG4gKiBpbnRlcnZhbCB2YWx1ZS4gSWYgdGhlIHNjYWxlIGhhcyBhICd0aWNrcycgbWV0aG9kLCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAqIGdlbmVyYXRlIHRoZSB0aWNrcywgd2l0aCB0aGUgY291bnQgYXJndW1lbnQgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLiBJZiB0aGVcbiAqIHNjYWxlIGxhY2tzIGEgJ3RpY2tzJyBtZXRob2QsIHRoZSBmdWxsIHNjYWxlIGRvbWFpbiB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGUgLSBUaGUgc2NhbGUgZm9yIHdoaWNoIHRvIGdlbmVyYXRlIHRpY2sgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbY291bnRdIC0gVGhlIGFwcHJveGltYXRlIG51bWJlciBvZiBkZXNpcmVkIHRpY2tzLlxuICogQHJldHVybiB7QXJyYXk8Kj59IC0gVGhlIGdlbmVyYXRlZCB0aWNrIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiB0aWNrVmFsdWVzKHNjYWxlLCBjb3VudCkge1xuICByZXR1cm4gc2NhbGUuYmlucyA/IHZhbGlkVGlja3Moc2NhbGUsIHNjYWxlLmJpbnMpIDogc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcyhjb3VudCkgOiBzY2FsZS5kb21haW4oKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBsYWJlbCBmb3JtYXQgZnVuY3Rpb24gZm9yIGEgc2NhbGUuIElmIHRoZSBzY2FsZSBoYXMgYVxuICogJ3RpY2tGb3JtYXQnIG1ldGhvZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBmb3JtYXR0ZXIsIHdpdGggdGhlXG4gKiBjb3VudCBhbmQgc3BlY2lmaWVyIGFyZ3VtZW50cyBwYXNzZWQgYXMgcGFyYW1ldGVycy4gSWYgdGhlIHNjYWxlIGxhY2tzIGFcbiAqICd0aWNrRm9ybWF0JyBtZXRob2QsIHRoZSByZXR1cm5lZCBmb3JtYXR0ZXIgcGVyZm9ybXMgc2ltcGxlIHN0cmluZyBjb2VyY2lvbi5cbiAqIElmIHRoZSBpbnB1dCBzY2FsZSBpcyBhIGxvZ2FyaXRobWljIHNjYWxlIGFuZCB0aGUgZm9ybWF0IHNwZWNpZmllciBkb2VzIG5vdFxuICogaW5kaWNhdGUgYSBkZXNpcmVkIGRlY2ltYWwgcHJlY2lzaW9uLCBhIHNwZWNpYWwgdmFyaWFibGUgcHJlY2lzaW9uIGZvcm1hdHRlclxuICogdGhhdCBhdXRvbWF0aWNhbGx5IHRyaW1zIHRyYWlsaW5nIHplcm9lcyB3aWxsIGJlIGdlbmVyYXRlZC5cbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlIC0gVGhlIHNjYWxlIGZvciB3aGljaCB0byBnZW5lcmF0ZSB0aGUgbGFiZWwgZm9ybWF0dGVyLlxuICogQHBhcmFtIHsqfSBbY291bnRdIC0gVGhlIGFwcHJveGltYXRlIG51bWJlciBvZiBkZXNpcmVkIHRpY2tzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzcGVjaWZpZXJdIC0gVGhlIGZvcm1hdCBzcGVjaWZpZXIuIE11c3QgYmUgYSBsZWdhbCBkM1xuICogICBzcGVjaWZpZXIgc3RyaW5nIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWZvcm1hdCNmb3JtYXRTcGVjaWZpZXIpIG9yXG4gKiAgIHRpbWUgbXVsdGktZm9ybWF0IHNwZWNpZmllciBvYmplY3QuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigqKTpzdHJpbmd9IC0gVGhlIGdlbmVyYXRlZCBsYWJlbCBmb3JtYXR0ZXIuXG4gKi9cblxuZnVuY3Rpb24gdGlja0Zvcm1hdChsb2NhbGUsIHNjYWxlLCBjb3VudCwgc3BlY2lmaWVyLCBmb3JtYXRUeXBlLCBub1NraXApIHtcbiAgY29uc3QgdHlwZSA9IHNjYWxlLnR5cGU7XG4gIGxldCBmb3JtYXQgPSBkZWZhdWx0Rm9ybWF0dGVyO1xuXG4gIGlmICh0eXBlID09PSBUaW1lIHx8IGZvcm1hdFR5cGUgPT09IFRpbWUpIHtcbiAgICBmb3JtYXQgPSBsb2NhbGUudGltZUZvcm1hdChzcGVjaWZpZXIpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFVUQyB8fCBmb3JtYXRUeXBlID09PSBVVEMpIHtcbiAgICBmb3JtYXQgPSBsb2NhbGUudXRjRm9ybWF0KHNwZWNpZmllcik7XG4gIH0gZWxzZSBpZiAoaXNMb2dhcml0aG1pYyh0eXBlKSkge1xuICAgIGNvbnN0IHZhcmZtdCA9IGxvY2FsZS5mb3JtYXRGbG9hdChzcGVjaWZpZXIpO1xuXG4gICAgaWYgKG5vU2tpcCB8fCBzY2FsZS5iaW5zKSB7XG4gICAgICBmb3JtYXQgPSB2YXJmbXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRlc3QgPSB0aWNrTG9nKHNjYWxlLCBjb3VudCwgZmFsc2UpO1xuXG4gICAgICBmb3JtYXQgPSBfID0+IHRlc3QoXykgPyB2YXJmbXQoXykgOiAnJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2NhbGUudGlja0Zvcm1hdCkge1xuICAgIC8vIGlmIGQzIHNjYWxlIGhhcyB0aWNrRm9ybWF0LCBpdCBtdXN0IGJlIGNvbnRpbnVvdXNcbiAgICBjb25zdCBkID0gc2NhbGUuZG9tYWluKCk7XG4gICAgZm9ybWF0ID0gbG9jYWxlLmZvcm1hdFNwYW4oZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfSBlbHNlIGlmIChzcGVjaWZpZXIpIHtcbiAgICBmb3JtYXQgPSBsb2NhbGUuZm9ybWF0KHNwZWNpZmllcik7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0O1xufVxuZnVuY3Rpb24gdGlja0xvZyhzY2FsZSwgY291bnQsIHZhbHVlcykge1xuICBjb25zdCB0aWNrcyA9IHRpY2tWYWx1ZXMoc2NhbGUsIGNvdW50KSxcbiAgICAgICAgYmFzZSA9IHNjYWxlLmJhc2UoKSxcbiAgICAgICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgICAgICBrID0gTWF0aC5tYXgoMSwgYmFzZSAqIGNvdW50IC8gdGlja3MubGVuZ3RoKTsgLy8gYXBwbHkgZDMtc2NhbGUncyBsb2cgZm9ybWF0IGZpbHRlciBjcml0ZXJpYVxuXG4gIGNvbnN0IHRlc3QgPSBkID0+IHtcbiAgICBsZXQgaSA9IGQgLyBNYXRoLnBvdyhiYXNlLCBNYXRoLnJvdW5kKE1hdGgubG9nKGQpIC8gbG9nYikpO1xuICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAwLjUpIGkgKj0gYmFzZTtcbiAgICByZXR1cm4gaSA8PSBrO1xuICB9O1xuXG4gIHJldHVybiB2YWx1ZXMgPyB0aWNrcy5maWx0ZXIodGVzdCkgOiB0ZXN0O1xufVxuXG5jb25zdCBzeW1ib2xzID0ge1xuICBbUXVhbnRpbGVdOiAncXVhbnRpbGVzJyxcbiAgW1F1YW50aXplXTogJ3RocmVzaG9sZHMnLFxuICBbVGhyZXNob2xkXTogJ2RvbWFpbidcbn07XG5jb25zdCBmb3JtYXRzID0ge1xuICBbUXVhbnRpbGVdOiAncXVhbnRpbGVzJyxcbiAgW1F1YW50aXplXTogJ2RvbWFpbidcbn07XG5mdW5jdGlvbiBsYWJlbFZhbHVlcyhzY2FsZSwgY291bnQpIHtcbiAgcmV0dXJuIHNjYWxlLmJpbnMgPyBiaW5WYWx1ZXMoc2NhbGUuYmlucykgOiBzY2FsZS50eXBlID09PSBMb2cgPyB0aWNrTG9nKHNjYWxlLCBjb3VudCwgdHJ1ZSkgOiBzeW1ib2xzW3NjYWxlLnR5cGVdID8gdGhyZXNob2xkVmFsdWVzKHNjYWxlW3N5bWJvbHNbc2NhbGUudHlwZV1dKCkpIDogdGlja1ZhbHVlcyhzY2FsZSwgY291bnQpO1xufVxuZnVuY3Rpb24gdGhyZXNob2xkRm9ybWF0KGxvY2FsZSwgc2NhbGUsIHNwZWNpZmllcikge1xuICBjb25zdCBfID0gc2NhbGVbZm9ybWF0c1tzY2FsZS50eXBlXV0oKSxcbiAgICAgICAgbiA9IF8ubGVuZ3RoO1xuXG4gIGxldCBkID0gbiA+IDEgPyBfWzFdIC0gX1swXSA6IF9bMF0sXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICBkID0gTWF0aC5taW4oZCwgX1tpXSAtIF9baSAtIDFdKTtcbiAgfSAvLyB0aWNrQ291bnQgPSAzIHRpY2tzIHRpbWVzIDEwIGZvciBpbmNyZWFzZWQgcmVzb2x1dGlvblxuXG5cbiAgcmV0dXJuIGxvY2FsZS5mb3JtYXRTcGFuKDAsIGQsIDMgKiAxMCwgc3BlY2lmaWVyKTtcbn1cblxuZnVuY3Rpb24gdGhyZXNob2xkVmFsdWVzKHRocmVzaG9sZHMpIHtcbiAgY29uc3QgdmFsdWVzID0gWy1JbmZpbml0eV0uY29uY2F0KHRocmVzaG9sZHMpO1xuICB2YWx1ZXMubWF4ID0gK0luZmluaXR5O1xuICByZXR1cm4gdmFsdWVzO1xufVxuXG5mdW5jdGlvbiBiaW5WYWx1ZXMoYmlucykge1xuICBjb25zdCB2YWx1ZXMgPSBiaW5zLnNsaWNlKDAsIC0xKTtcbiAgdmFsdWVzLm1heCA9IHBlZWsoYmlucyk7XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbmNvbnN0IGlzRGlzY3JldGVSYW5nZSA9IHNjYWxlID0+IHN5bWJvbHNbc2NhbGUudHlwZV0gfHwgc2NhbGUuYmlucztcblxuZnVuY3Rpb24gbGFiZWxGb3JtYXQobG9jYWxlLCBzY2FsZSwgY291bnQsIHR5cGUsIHNwZWNpZmllciwgZm9ybWF0VHlwZSwgbm9Ta2lwKSB7XG4gIGNvbnN0IGZvcm1hdCA9IGZvcm1hdHNbc2NhbGUudHlwZV0gJiYgZm9ybWF0VHlwZSAhPT0gVGltZSAmJiBmb3JtYXRUeXBlICE9PSBVVEMgPyB0aHJlc2hvbGRGb3JtYXQobG9jYWxlLCBzY2FsZSwgc3BlY2lmaWVyKSA6IHRpY2tGb3JtYXQobG9jYWxlLCBzY2FsZSwgY291bnQsIHNwZWNpZmllciwgZm9ybWF0VHlwZSwgbm9Ta2lwKTtcbiAgcmV0dXJuIHR5cGUgPT09IFN5bWJvbExlZ2VuZCAmJiBpc0Rpc2NyZXRlUmFuZ2Uoc2NhbGUpID8gZm9ybWF0UmFuZ2UoZm9ybWF0KSA6IHR5cGUgPT09IERpc2NyZXRlTGVnZW5kID8gZm9ybWF0RGlzY3JldGUoZm9ybWF0KSA6IGZvcm1hdFBvaW50KGZvcm1hdCk7XG59XG5cbmNvbnN0IGZvcm1hdFJhbmdlID0gZm9ybWF0ID0+ICh2YWx1ZSwgaW5kZXgsIGFycmF5KSA9PiB7XG4gIGNvbnN0IGxpbWl0ID0gZ2V0KGFycmF5W2luZGV4ICsgMV0sIGdldChhcnJheS5tYXgsICtJbmZpbml0eSkpLFxuICAgICAgICBsbyA9IGZvcm1hdFZhbHVlKHZhbHVlLCBmb3JtYXQpLFxuICAgICAgICBoaSA9IGZvcm1hdFZhbHVlKGxpbWl0LCBmb3JtYXQpO1xuICByZXR1cm4gbG8gJiYgaGkgPyBsbyArICcgXFx1MjAxMyAnICsgaGkgOiBoaSA/ICc8ICcgKyBoaSA6ICdcXHUyMjY1ICcgKyBsbztcbn07XG5cbmNvbnN0IGdldCA9ICh2YWx1ZSwgZGZsdCkgPT4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogZGZsdDtcblxuY29uc3QgZm9ybWF0RGlzY3JldGUgPSBmb3JtYXQgPT4gKHZhbHVlLCBpbmRleCkgPT4gaW5kZXggPyBmb3JtYXQodmFsdWUpIDogbnVsbDtcblxuY29uc3QgZm9ybWF0UG9pbnQgPSBmb3JtYXQgPT4gdmFsdWUgPT4gZm9ybWF0KHZhbHVlKTtcblxuY29uc3QgZm9ybWF0VmFsdWUgPSAodmFsdWUsIGZvcm1hdCkgPT4gTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA/IGZvcm1hdCh2YWx1ZSkgOiBudWxsO1xuXG5mdW5jdGlvbiBsYWJlbEZyYWN0aW9uKHNjYWxlKSB7XG4gIGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgICBjb3VudCA9IGRvbWFpbi5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSArZG9tYWluWzBdLFxuICAgICAgaGkgPSArcGVlayhkb21haW4pLFxuICAgICAgc3BhbiA9IGhpIC0gbG87XG5cbiAgaWYgKHNjYWxlLnR5cGUgPT09IFRocmVzaG9sZCkge1xuICAgIGNvbnN0IGFkanVzdCA9IGNvdW50ID8gc3BhbiAvIGNvdW50IDogMC4xO1xuICAgIGxvIC09IGFkanVzdDtcbiAgICBoaSArPSBhZGp1c3Q7XG4gICAgc3BhbiA9IGhpIC0gbG87XG4gIH1cblxuICByZXR1cm4gdmFsdWUgPT4gKHZhbHVlIC0gbG8pIC8gc3Bhbjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KGxvY2FsZSwgc2NhbGUsIHNwZWNpZmllciwgZm9ybWF0VHlwZSkge1xuICBjb25zdCB0eXBlID0gZm9ybWF0VHlwZSB8fCBzY2FsZS50eXBlOyAvLyByZXBsYWNlIGFiYnJldmlhdGVkIHRpbWUgc3BlY2lmaWVycyB0byBpbXByb3ZlIHNjcmVlbiByZWFkZXIgZXhwZXJpZW5jZVxuXG4gIGlmIChpc1N0cmluZyhzcGVjaWZpZXIpICYmIGlzVGVtcG9yYWwodHlwZSkpIHtcbiAgICBzcGVjaWZpZXIgPSBzcGVjaWZpZXIucmVwbGFjZSgvJWEvZywgJyVBJykucmVwbGFjZSgvJWIvZywgJyVCJyk7XG4gIH1cblxuICByZXR1cm4gIXNwZWNpZmllciAmJiB0eXBlID09PSBUaW1lID8gbG9jYWxlLnRpbWVGb3JtYXQoJyVBLCAlZCAlQiAlWSwgJVgnKSA6ICFzcGVjaWZpZXIgJiYgdHlwZSA9PT0gVVRDID8gbG9jYWxlLnV0Y0Zvcm1hdCgnJUEsICVkICVCICVZLCAlWCBVVEMnKSA6IGxhYmVsRm9ybWF0KGxvY2FsZSwgc2NhbGUsIDUsIG51bGwsIHNwZWNpZmllciwgZm9ybWF0VHlwZSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGRvbWFpbkNhcHRpb24obG9jYWxlLCBzY2FsZSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoMywgb3B0Lm1heGxlbiB8fCA3KSxcbiAgICAgICAgZm10ID0gZm9ybWF0KGxvY2FsZSwgc2NhbGUsIG9wdC5mb3JtYXQsIG9wdC5mb3JtYXRUeXBlKTsgLy8gaWYgc2NhbGUgYnJlYWtzIGRvbWFpbiBpbnRvIGJpbnMsIGRlc2NyaWJlIGJvdW5kYXJpZXNcblxuICBpZiAoaXNEaXNjcmV0aXppbmcoc2NhbGUudHlwZSkpIHtcbiAgICBjb25zdCB2ID0gbGFiZWxWYWx1ZXMoc2NhbGUpLnNsaWNlKDEpLm1hcChmbXQpLFxuICAgICAgICAgIG4gPSB2Lmxlbmd0aDtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQobiwgXCIgYm91bmRhclwiKS5jb25jYXQobiA9PT0gMSA/ICd5JyA6ICdpZXMnLCBcIjogXCIpLmNvbmNhdCh2LmpvaW4oJywgJykpO1xuICB9IC8vIGlmIHNjYWxlIGRvbWFpbiBpcyBkaXNjcmV0ZSwgbGlzdCB2YWx1ZXNcbiAgZWxzZSBpZiAoaXNEaXNjcmV0ZShzY2FsZS50eXBlKSkge1xuICAgICAgY29uc3QgZCA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgICAgICAgbiA9IGQubGVuZ3RoLFxuICAgICAgICAgICAgdiA9IG4gPiBtYXggPyBkLnNsaWNlKDAsIG1heCAtIDIpLm1hcChmbXQpLmpvaW4oJywgJykgKyAnLCBlbmRpbmcgd2l0aCAnICsgZC5zbGljZSgtMSkubWFwKGZtdCkgOiBkLm1hcChmbXQpLmpvaW4oJywgJyk7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobiwgXCIgdmFsdWVcIikuY29uY2F0KG4gPT09IDEgPyAnJyA6ICdzJywgXCI6IFwiKS5jb25jYXQodik7XG4gICAgfSAvLyBpZiBzY2FsZSBkb21haW4gaXMgY29udGludW91cywgZGVzY3JpYmUgdmFsdWUgcmFuZ2VcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZCA9IHNjYWxlLmRvbWFpbigpO1xuICAgICAgICByZXR1cm4gXCJ2YWx1ZXMgZnJvbSBcIi5jb25jYXQoZm10KGRbMF0pLCBcIiB0byBcIikuY29uY2F0KGZtdChwZWVrKGQpKSk7XG4gICAgICB9XG59XG5cbmV4cG9ydCB7IEJhbmQsIEJpbk9yZGluYWwsIERpc2NyZXRlTGVnZW5kLCBEaXZlcmdpbmcsIEdyYWRpZW50TGVnZW5kLCBJZGVudGl0eSwgTGluZWFyLCBMb2csIE9yZGluYWwsIFBvaW50LCBQb3csIFF1YW50aWxlLCBRdWFudGl6ZSwgU2VxdWVudGlhbCwgU3FydCwgU3ltYm9sTGVnZW5kLCBTeW1sb2csIFRocmVzaG9sZCwgVGltZSwgVVRDLCBiYW5kU3BhY2UsIGRvbWFpbkNhcHRpb24sIGludGVycG9sYXRlLCBpbnRlcnBvbGF0ZUNvbG9ycywgaW50ZXJwb2xhdGVSYW5nZSwgaXNDb250aW51b3VzLCBpc0Rpc2NyZXRlLCBpc0Rpc2NyZXRpemluZywgaXNJbnRlcnBvbGF0aW5nLCBpc0xvZ2FyaXRobWljLCBpc1F1YW50aWxlLCBpc1RlbXBvcmFsLCBpc1ZhbGlkU2NhbGVUeXBlLCBsYWJlbEZvcm1hdCwgbGFiZWxGcmFjdGlvbiwgbGFiZWxWYWx1ZXMsIHF1YW50aXplSW50ZXJwb2xhdG9yLCBzY2FsZSwgc2NhbGVDb3B5LCBzY2FsZUZyYWN0aW9uLCBzY2hlbWUsIHRpY2tDb3VudCwgdGlja0Zvcm1hdCwgdGlja1ZhbHVlcywgdmFsaWRUaWNrcyB9O1xuIiwiaW1wb3J0IHsgaGFzT3duUHJvcGVydHksIGlzRnVuY3Rpb24sIGluaGVyaXRzLCB0cnV0aHksIGxydUNhY2hlLCBpc0FycmF5LCBlcnJvciwgdG9TZXQsIGFycmF5LCBwZWVrLCBleHRlbmQsIGlzTnVtYmVyLCBpc09iamVjdCB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBjdXJ2ZUJhc2lzLCBjdXJ2ZUJhc2lzQ2xvc2VkLCBjdXJ2ZUJhc2lzT3BlbiwgY3VydmVCdW5kbGUsIGN1cnZlQ2FyZGluYWwsIGN1cnZlQ2FyZGluYWxPcGVuLCBjdXJ2ZUNhcmRpbmFsQ2xvc2VkLCBjdXJ2ZUNhdG11bGxSb20sIGN1cnZlQ2F0bXVsbFJvbUNsb3NlZCwgY3VydmVDYXRtdWxsUm9tT3BlbiwgY3VydmVMaW5lYXIsIGN1cnZlTGluZWFyQ2xvc2VkLCBjdXJ2ZU1vbm90b25lWSwgY3VydmVNb25vdG9uZVgsIGN1cnZlTmF0dXJhbCwgY3VydmVTdGVwLCBjdXJ2ZVN0ZXBBZnRlciwgY3VydmVTdGVwQmVmb3JlLCBhcmMgYXMgYXJjJDIsIGFyZWEgYXMgYXJlYSQyLCBsaW5lIGFzIGxpbmUkMiwgc3ltYm9sIGFzIHN5bWJvbCQyIH0gZnJvbSAnZDMtc2hhcGUnO1xuaW1wb3J0IHsgcGF0aCBhcyBwYXRoJDMgfSBmcm9tICdkMy1wYXRoJztcbmltcG9ydCB7IGltYWdlIGFzIGltYWdlJDEsIGNhbnZhcyB9IGZyb20gJ3ZlZ2EtY2FudmFzJztcbmltcG9ydCB7IGxvYWRlciB9IGZyb20gJ3ZlZ2EtbG9hZGVyJztcbmltcG9ydCB7IGlzRGlzY3JldGUsIGRvbWFpbkNhcHRpb24gfSBmcm9tICd2ZWdhLXNjYWxlJztcblxubGV0IGdyYWRpZW50X2lkID0gMDtcbmZ1bmN0aW9uIHJlc2V0U1ZHR3JhZGllbnRJZCgpIHtcbiAgZ3JhZGllbnRfaWQgPSAwO1xufVxuY29uc3QgcGF0dGVyblByZWZpeCA9ICdwXyc7XG5mdW5jdGlvbiBpc0dyYWRpZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5ncmFkaWVudDtcbn1cbmZ1bmN0aW9uIGdyYWRpZW50UmVmKGcsIGRlZnMsIGJhc2UpIHtcbiAgY29uc3QgdHlwZSA9IGcuZ3JhZGllbnQ7XG4gIGxldCBpZCA9IGcuaWQsXG4gICAgICBwcmVmaXggPSB0eXBlID09PSAncmFkaWFsJyA/IHBhdHRlcm5QcmVmaXggOiAnJzsgLy8gY2hlY2sgaWQsIGFzc2lnbiBkZWZhdWx0IHZhbHVlcyBhcyBuZWVkZWRcblxuICBpZiAoIWlkKSB7XG4gICAgaWQgPSBnLmlkID0gJ2dyYWRpZW50XycgKyBncmFkaWVudF9pZCsrO1xuXG4gICAgaWYgKHR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICBnLngxID0gZ2V0KGcueDEsIDAuNSk7XG4gICAgICBnLnkxID0gZ2V0KGcueTEsIDAuNSk7XG4gICAgICBnLnIxID0gZ2V0KGcucjEsIDApO1xuICAgICAgZy54MiA9IGdldChnLngyLCAwLjUpO1xuICAgICAgZy55MiA9IGdldChnLnkyLCAwLjUpO1xuICAgICAgZy5yMiA9IGdldChnLnIyLCAwLjUpO1xuICAgICAgcHJlZml4ID0gcGF0dGVyblByZWZpeDtcbiAgICB9IGVsc2Uge1xuICAgICAgZy54MSA9IGdldChnLngxLCAwKTtcbiAgICAgIGcueTEgPSBnZXQoZy55MSwgMCk7XG4gICAgICBnLngyID0gZ2V0KGcueDIsIDEpO1xuICAgICAgZy55MiA9IGdldChnLnkyLCAwKTtcbiAgICB9XG4gIH0gLy8gcmVnaXN0ZXIgZGVmaW5pdGlvblxuXG5cbiAgZGVmc1tpZF0gPSBnOyAvLyByZXR1cm4gdXJsIHJlZmVyZW5jZVxuXG4gIHJldHVybiAndXJsKCcgKyAoYmFzZSB8fCAnJykgKyAnIycgKyBwcmVmaXggKyBpZCArICcpJztcbn1cblxuZnVuY3Rpb24gZ2V0KHZhbCwgZGVmKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbCA6IGRlZjtcbn1cblxuZnVuY3Rpb24gR3JhZGllbnQgKHAwLCBwMSkge1xuICB2YXIgc3RvcHMgPSBbXSxcbiAgICAgIGdyYWRpZW50O1xuICByZXR1cm4gZ3JhZGllbnQgPSB7XG4gICAgZ3JhZGllbnQ6ICdsaW5lYXInLFxuICAgIHgxOiBwMCA/IHAwWzBdIDogMCxcbiAgICB5MTogcDAgPyBwMFsxXSA6IDAsXG4gICAgeDI6IHAxID8gcDFbMF0gOiAxLFxuICAgIHkyOiBwMSA/IHAxWzFdIDogMCxcbiAgICBzdG9wczogc3RvcHMsXG4gICAgc3RvcDogZnVuY3Rpb24gKG9mZnNldCwgY29sb3IpIHtcbiAgICAgIHN0b3BzLnB1c2goe1xuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgY29sb3I6IGNvbG9yXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IGxvb2t1cCA9IHtcbiAgJ2Jhc2lzJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUJhc2lzXG4gIH0sXG4gICdiYXNpcy1jbG9zZWQnOiB7XG4gICAgY3VydmU6IGN1cnZlQmFzaXNDbG9zZWRcbiAgfSxcbiAgJ2Jhc2lzLW9wZW4nOiB7XG4gICAgY3VydmU6IGN1cnZlQmFzaXNPcGVuXG4gIH0sXG4gICdidW5kbGUnOiB7XG4gICAgY3VydmU6IGN1cnZlQnVuZGxlLFxuICAgIHRlbnNpb246ICdiZXRhJyxcbiAgICB2YWx1ZTogMC44NVxuICB9LFxuICAnY2FyZGluYWwnOiB7XG4gICAgY3VydmU6IGN1cnZlQ2FyZGluYWwsXG4gICAgdGVuc2lvbjogJ3RlbnNpb24nLFxuICAgIHZhbHVlOiAwXG4gIH0sXG4gICdjYXJkaW5hbC1vcGVuJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUNhcmRpbmFsT3BlbixcbiAgICB0ZW5zaW9uOiAndGVuc2lvbicsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgJ2NhcmRpbmFsLWNsb3NlZCc6IHtcbiAgICBjdXJ2ZTogY3VydmVDYXJkaW5hbENsb3NlZCxcbiAgICB0ZW5zaW9uOiAndGVuc2lvbicsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgJ2NhdG11bGwtcm9tJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUNhdG11bGxSb20sXG4gICAgdGVuc2lvbjogJ2FscGhhJyxcbiAgICB2YWx1ZTogMC41XG4gIH0sXG4gICdjYXRtdWxsLXJvbS1jbG9zZWQnOiB7XG4gICAgY3VydmU6IGN1cnZlQ2F0bXVsbFJvbUNsb3NlZCxcbiAgICB0ZW5zaW9uOiAnYWxwaGEnLFxuICAgIHZhbHVlOiAwLjVcbiAgfSxcbiAgJ2NhdG11bGwtcm9tLW9wZW4nOiB7XG4gICAgY3VydmU6IGN1cnZlQ2F0bXVsbFJvbU9wZW4sXG4gICAgdGVuc2lvbjogJ2FscGhhJyxcbiAgICB2YWx1ZTogMC41XG4gIH0sXG4gICdsaW5lYXInOiB7XG4gICAgY3VydmU6IGN1cnZlTGluZWFyXG4gIH0sXG4gICdsaW5lYXItY2xvc2VkJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUxpbmVhckNsb3NlZFxuICB9LFxuICAnbW9ub3RvbmUnOiB7XG4gICAgaG9yaXpvbnRhbDogY3VydmVNb25vdG9uZVksXG4gICAgdmVydGljYWw6IGN1cnZlTW9ub3RvbmVYXG4gIH0sXG4gICduYXR1cmFsJzoge1xuICAgIGN1cnZlOiBjdXJ2ZU5hdHVyYWxcbiAgfSxcbiAgJ3N0ZXAnOiB7XG4gICAgY3VydmU6IGN1cnZlU3RlcFxuICB9LFxuICAnc3RlcC1hZnRlcic6IHtcbiAgICBjdXJ2ZTogY3VydmVTdGVwQWZ0ZXJcbiAgfSxcbiAgJ3N0ZXAtYmVmb3JlJzoge1xuICAgIGN1cnZlOiBjdXJ2ZVN0ZXBCZWZvcmVcbiAgfVxufTtcbmZ1bmN0aW9uIGN1cnZlcyh0eXBlLCBvcmllbnRhdGlvbiwgdGVuc2lvbikge1xuICB2YXIgZW50cnkgPSBoYXNPd25Qcm9wZXJ0eShsb29rdXAsIHR5cGUpICYmIGxvb2t1cFt0eXBlXSxcbiAgICAgIGN1cnZlID0gbnVsbDtcblxuICBpZiAoZW50cnkpIHtcbiAgICBjdXJ2ZSA9IGVudHJ5LmN1cnZlIHx8IGVudHJ5W29yaWVudGF0aW9uIHx8ICd2ZXJ0aWNhbCddO1xuXG4gICAgaWYgKGVudHJ5LnRlbnNpb24gJiYgdGVuc2lvbiAhPSBudWxsKSB7XG4gICAgICBjdXJ2ZSA9IGN1cnZlW2VudHJ5LnRlbnNpb25dKHRlbnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJ2ZTtcbn1cblxuLy8gUGF0aCBwYXJzaW5nIGFuZCByZW5kZXJpbmcgY29kZSBhZGFwdGVkIGZyb20gZmFicmljLmpzIC0tIFRoYW5rcyFcbmNvbnN0IGNtZGxlbiA9IHtcbiAgbTogMixcbiAgbDogMixcbiAgaDogMSxcbiAgdjogMSxcbiAgYzogNixcbiAgczogNCxcbiAgcTogNCxcbiAgdDogMixcbiAgYTogN1xufSxcbiAgICAgIHJlZ2V4cCA9IFsvKFtNTEhWQ1NRVEFabWxodmNzcXRhel0pL2csIC8jIyMvLCAvKFxcLlxcZCspKFxcLlxcZCkvZywgLyhcXGQpKFstK10pL2csIC9cXHN8LHwjIyMvXTtcbmZ1bmN0aW9uIHBhdGhQYXJzZSAocGF0aHN0cikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGN1cnIsIGNodW5rcywgcGFyc2VkLCBwYXJhbSwgY21kLCBsZW4sIGksIGosIG4sIG07IC8vIEZpcnN0LCBicmVhayBwYXRoIGludG8gY29tbWFuZCBzZXF1ZW5jZVxuXG4gIGNvbnN0IHBhdGggPSBwYXRoc3RyLnNsaWNlKCkucmVwbGFjZShyZWdleHBbMF0sICcjIyMkMScpLnNwbGl0KHJlZ2V4cFsxXSkuc2xpY2UoMSk7IC8vIE5leHQsIHBhcnNlIGVhY2ggY29tbWFuZCBpbiB0dXJuXG5cbiAgZm9yIChpID0gMCwgbiA9IHBhdGgubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY3VyciA9IHBhdGhbaV07XG4gICAgY2h1bmtzID0gY3Vyci5zbGljZSgxKS50cmltKCkucmVwbGFjZShyZWdleHBbMl0sICckMSMjIyQyJykucmVwbGFjZShyZWdleHBbM10sICckMSMjIyQyJykuc3BsaXQocmVnZXhwWzRdKTtcbiAgICBjbWQgPSBjdXJyLmNoYXJBdCgwKTtcbiAgICBwYXJzZWQgPSBbY21kXTtcblxuICAgIGZvciAoaiA9IDAsIG0gPSBjaHVua3MubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKHBhcmFtID0gK2NodW5rc1tqXSkgPT09IHBhcmFtKSB7XG4gICAgICAgIC8vIG5vdCBOYU5cbiAgICAgICAgcGFyc2VkLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxlbiA9IGNtZGxlbltjbWQudG9Mb3dlckNhc2UoKV07XG5cbiAgICBpZiAocGFyc2VkLmxlbmd0aCAtIDEgPiBsZW4pIHtcbiAgICAgIGNvbnN0IG0gPSBwYXJzZWQubGVuZ3RoO1xuICAgICAgaiA9IDE7XG4gICAgICByZXN1bHQucHVzaChbY21kXS5jb25jYXQocGFyc2VkLnNsaWNlKGosIGogKz0gbGVuKSkpOyAvLyBoYW5kbGUgaW1wbGljaXQgbGluZVRvICgjMjgwMylcblxuICAgICAgY21kID0gY21kID09PSAnTScgPyAnTCcgOiBjbWQgPT09ICdtJyA/ICdsJyA6IGNtZDtcblxuICAgICAgZm9yICg7IGogPCBtOyBqICs9IGxlbikge1xuICAgICAgICByZXN1bHQucHVzaChbY21kXS5jb25jYXQocGFyc2VkLnNsaWNlKGosIGogKyBsZW4pKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgRGVnVG9SYWQgPSBNYXRoLlBJIC8gMTgwO1xuY29uc3QgRXBzaWxvbiA9IDFlLTE0O1xuY29uc3QgSGFsZlBpID0gTWF0aC5QSSAvIDI7XG5jb25zdCBUYXUgPSBNYXRoLlBJICogMjtcbmNvbnN0IEhhbGZTcXJ0MyA9IE1hdGguc3FydCgzKSAvIDI7XG5cbnZhciBzZWdtZW50Q2FjaGUgPSB7fTtcbnZhciBiZXppZXJDYWNoZSA9IHt9O1xudmFyIGpvaW4gPSBbXS5qb2luOyAvLyBDb3BpZWQgZnJvbSBJbmtzY2FwZSBzdmd0b3BkZiwgdGhhbmtzIVxuXG5mdW5jdGlvbiBzZWdtZW50cyh4LCB5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90YXRlWCwgb3gsIG95KSB7XG4gIGNvbnN0IGtleSA9IGpvaW4uY2FsbChhcmd1bWVudHMpO1xuXG4gIGlmIChzZWdtZW50Q2FjaGVba2V5XSkge1xuICAgIHJldHVybiBzZWdtZW50Q2FjaGVba2V5XTtcbiAgfVxuXG4gIGNvbnN0IHRoID0gcm90YXRlWCAqIERlZ1RvUmFkO1xuICBjb25zdCBzaW5fdGggPSBNYXRoLnNpbih0aCk7XG4gIGNvbnN0IGNvc190aCA9IE1hdGguY29zKHRoKTtcbiAgcnggPSBNYXRoLmFicyhyeCk7XG4gIHJ5ID0gTWF0aC5hYnMocnkpO1xuICBjb25zdCBweCA9IGNvc190aCAqIChveCAtIHgpICogMC41ICsgc2luX3RoICogKG95IC0geSkgKiAwLjU7XG4gIGNvbnN0IHB5ID0gY29zX3RoICogKG95IC0geSkgKiAwLjUgLSBzaW5fdGggKiAob3ggLSB4KSAqIDAuNTtcbiAgbGV0IHBsID0gcHggKiBweCAvIChyeCAqIHJ4KSArIHB5ICogcHkgLyAocnkgKiByeSk7XG5cbiAgaWYgKHBsID4gMSkge1xuICAgIHBsID0gTWF0aC5zcXJ0KHBsKTtcbiAgICByeCAqPSBwbDtcbiAgICByeSAqPSBwbDtcbiAgfVxuXG4gIGNvbnN0IGEwMCA9IGNvc190aCAvIHJ4O1xuICBjb25zdCBhMDEgPSBzaW5fdGggLyByeDtcbiAgY29uc3QgYTEwID0gLXNpbl90aCAvIHJ5O1xuICBjb25zdCBhMTEgPSBjb3NfdGggLyByeTtcbiAgY29uc3QgeDAgPSBhMDAgKiBveCArIGEwMSAqIG95O1xuICBjb25zdCB5MCA9IGExMCAqIG94ICsgYTExICogb3k7XG4gIGNvbnN0IHgxID0gYTAwICogeCArIGEwMSAqIHk7XG4gIGNvbnN0IHkxID0gYTEwICogeCArIGExMSAqIHk7XG4gIGNvbnN0IGQgPSAoeDEgLSB4MCkgKiAoeDEgLSB4MCkgKyAoeTEgLSB5MCkgKiAoeTEgLSB5MCk7XG4gIGxldCBzZmFjdG9yX3NxID0gMSAvIGQgLSAwLjI1O1xuICBpZiAoc2ZhY3Rvcl9zcSA8IDApIHNmYWN0b3Jfc3EgPSAwO1xuICBsZXQgc2ZhY3RvciA9IE1hdGguc3FydChzZmFjdG9yX3NxKTtcbiAgaWYgKHN3ZWVwID09IGxhcmdlKSBzZmFjdG9yID0gLXNmYWN0b3I7XG4gIGNvbnN0IHhjID0gMC41ICogKHgwICsgeDEpIC0gc2ZhY3RvciAqICh5MSAtIHkwKTtcbiAgY29uc3QgeWMgPSAwLjUgKiAoeTAgKyB5MSkgKyBzZmFjdG9yICogKHgxIC0geDApO1xuICBjb25zdCB0aDAgPSBNYXRoLmF0YW4yKHkwIC0geWMsIHgwIC0geGMpO1xuICBjb25zdCB0aDEgPSBNYXRoLmF0YW4yKHkxIC0geWMsIHgxIC0geGMpO1xuICBsZXQgdGhfYXJjID0gdGgxIC0gdGgwO1xuXG4gIGlmICh0aF9hcmMgPCAwICYmIHN3ZWVwID09PSAxKSB7XG4gICAgdGhfYXJjICs9IFRhdTtcbiAgfSBlbHNlIGlmICh0aF9hcmMgPiAwICYmIHN3ZWVwID09PSAwKSB7XG4gICAgdGhfYXJjIC09IFRhdTtcbiAgfVxuXG4gIGNvbnN0IHNlZ3MgPSBNYXRoLmNlaWwoTWF0aC5hYnModGhfYXJjIC8gKEhhbGZQaSArIDAuMDAxKSkpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3M7ICsraSkge1xuICAgIGNvbnN0IHRoMiA9IHRoMCArIGkgKiB0aF9hcmMgLyBzZWdzO1xuICAgIGNvbnN0IHRoMyA9IHRoMCArIChpICsgMSkgKiB0aF9hcmMgLyBzZWdzO1xuICAgIHJlc3VsdFtpXSA9IFt4YywgeWMsIHRoMiwgdGgzLCByeCwgcnksIHNpbl90aCwgY29zX3RoXTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50Q2FjaGVba2V5XSA9IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJlemllcihwYXJhbXMpIHtcbiAgY29uc3Qga2V5ID0gam9pbi5jYWxsKHBhcmFtcyk7XG5cbiAgaWYgKGJlemllckNhY2hlW2tleV0pIHtcbiAgICByZXR1cm4gYmV6aWVyQ2FjaGVba2V5XTtcbiAgfVxuXG4gIHZhciBjeCA9IHBhcmFtc1swXSxcbiAgICAgIGN5ID0gcGFyYW1zWzFdLFxuICAgICAgdGgwID0gcGFyYW1zWzJdLFxuICAgICAgdGgxID0gcGFyYW1zWzNdLFxuICAgICAgcnggPSBwYXJhbXNbNF0sXG4gICAgICByeSA9IHBhcmFtc1s1XSxcbiAgICAgIHNpbl90aCA9IHBhcmFtc1s2XSxcbiAgICAgIGNvc190aCA9IHBhcmFtc1s3XTtcbiAgY29uc3QgYTAwID0gY29zX3RoICogcng7XG4gIGNvbnN0IGEwMSA9IC1zaW5fdGggKiByeTtcbiAgY29uc3QgYTEwID0gc2luX3RoICogcng7XG4gIGNvbnN0IGExMSA9IGNvc190aCAqIHJ5O1xuICBjb25zdCBjb3NfdGgwID0gTWF0aC5jb3ModGgwKTtcbiAgY29uc3Qgc2luX3RoMCA9IE1hdGguc2luKHRoMCk7XG4gIGNvbnN0IGNvc190aDEgPSBNYXRoLmNvcyh0aDEpO1xuICBjb25zdCBzaW5fdGgxID0gTWF0aC5zaW4odGgxKTtcbiAgY29uc3QgdGhfaGFsZiA9IDAuNSAqICh0aDEgLSB0aDApO1xuICBjb25zdCBzaW5fdGhfaDIgPSBNYXRoLnNpbih0aF9oYWxmICogMC41KTtcbiAgY29uc3QgdCA9IDggLyAzICogc2luX3RoX2gyICogc2luX3RoX2gyIC8gTWF0aC5zaW4odGhfaGFsZik7XG4gIGNvbnN0IHgxID0gY3ggKyBjb3NfdGgwIC0gdCAqIHNpbl90aDA7XG4gIGNvbnN0IHkxID0gY3kgKyBzaW5fdGgwICsgdCAqIGNvc190aDA7XG4gIGNvbnN0IHgzID0gY3ggKyBjb3NfdGgxO1xuICBjb25zdCB5MyA9IGN5ICsgc2luX3RoMTtcbiAgY29uc3QgeDIgPSB4MyArIHQgKiBzaW5fdGgxO1xuICBjb25zdCB5MiA9IHkzIC0gdCAqIGNvc190aDE7XG4gIHJldHVybiBiZXppZXJDYWNoZVtrZXldID0gW2EwMCAqIHgxICsgYTAxICogeTEsIGExMCAqIHgxICsgYTExICogeTEsIGEwMCAqIHgyICsgYTAxICogeTIsIGExMCAqIHgyICsgYTExICogeTIsIGEwMCAqIHgzICsgYTAxICogeTMsIGExMCAqIHgzICsgYTExICogeTNdO1xufVxuXG5jb25zdCB0ZW1wID0gWydsJywgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG5cbmZ1bmN0aW9uIHNjYWxlJDEoY3VycmVudCwgc1gsIHNZKSB7XG4gIGNvbnN0IGMgPSB0ZW1wWzBdID0gY3VycmVudFswXTtcblxuICBpZiAoYyA9PT0gJ2EnIHx8IGMgPT09ICdBJykge1xuICAgIHRlbXBbMV0gPSBzWCAqIGN1cnJlbnRbMV07XG4gICAgdGVtcFsyXSA9IHNZICogY3VycmVudFsyXTtcbiAgICB0ZW1wWzNdID0gY3VycmVudFszXTtcbiAgICB0ZW1wWzRdID0gY3VycmVudFs0XTtcbiAgICB0ZW1wWzVdID0gY3VycmVudFs1XTtcbiAgICB0ZW1wWzZdID0gc1ggKiBjdXJyZW50WzZdO1xuICAgIHRlbXBbN10gPSBzWSAqIGN1cnJlbnRbN107XG4gIH0gZWxzZSBpZiAoYyA9PT0gJ2gnIHx8IGMgPT09ICdIJykge1xuICAgIHRlbXBbMV0gPSBzWCAqIGN1cnJlbnRbMV07XG4gIH0gZWxzZSBpZiAoYyA9PT0gJ3YnIHx8IGMgPT09ICdWJykge1xuICAgIHRlbXBbMV0gPSBzWSAqIGN1cnJlbnRbMV07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDEsIG4gPSBjdXJyZW50Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdGVtcFtpXSA9IChpICUgMiA9PSAxID8gc1ggOiBzWSkgKiBjdXJyZW50W2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZW1wO1xufVxuXG5mdW5jdGlvbiBwYXRoUmVuZGVyIChjb250ZXh0LCBwYXRoLCBsLCB0LCBzWCwgc1kpIHtcbiAgdmFyIGN1cnJlbnQsXG4gICAgICAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gIHByZXZpb3VzID0gbnVsbCxcbiAgICAgIHggPSAwLFxuICAgICAgLy8gY3VycmVudCB4XG4gIHkgPSAwLFxuICAgICAgLy8gY3VycmVudCB5XG4gIGNvbnRyb2xYID0gMCxcbiAgICAgIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB4XG4gIGNvbnRyb2xZID0gMCxcbiAgICAgIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gIHRlbXBYLFxuICAgICAgdGVtcFksXG4gICAgICB0ZW1wQ29udHJvbFgsXG4gICAgICB0ZW1wQ29udHJvbFk7XG4gIGlmIChsID09IG51bGwpIGwgPSAwO1xuICBpZiAodCA9PSBudWxsKSB0ID0gMDtcbiAgaWYgKHNYID09IG51bGwpIHNYID0gMTtcbiAgaWYgKHNZID09IG51bGwpIHNZID0gc1g7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGN1cnJlbnQgPSBwYXRoW2ldO1xuXG4gICAgaWYgKHNYICE9PSAxIHx8IHNZICE9PSAxKSB7XG4gICAgICBjdXJyZW50ID0gc2NhbGUkMShjdXJyZW50LCBzWCwgc1kpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudFswXSkge1xuICAgICAgLy8gZmlyc3QgbGV0dGVyXG4gICAgICBjYXNlICdsJzpcbiAgICAgICAgLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnSCc6XG4gICAgICAgIC8vIGhvcml6b250YWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHkgKz0gY3VycmVudFsxXTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRleHQubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgLy8gbW92ZVRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzVdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeCArIGN1cnJlbnRbMV0gKyBsLCAvLyB4MVxuICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsIC8vIHkxXG4gICAgICAgIGNvbnRyb2xYICsgbCwgLy8geDJcbiAgICAgICAgY29udHJvbFkgKyB0LCAvLyB5MlxuICAgICAgICB0ZW1wWCArIGwsIHRlbXBZICsgdCk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQyc6XG4gICAgICAgIC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjdXJyZW50WzFdICsgbCwgY3VycmVudFsyXSArIHQsIGNvbnRyb2xYICsgbCwgY29udHJvbFkgKyB0LCB4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncyc6XG4gICAgICAgIC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07IC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG5cbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjb250cm9sWCArIGwsIGNvbnRyb2xZICsgdCwgeCArIGN1cnJlbnRbMV0gKyBsLCB5ICsgY3VycmVudFsyXSArIHQsIHRlbXBYICsgbCwgdGVtcFkgKyB0KTsgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZlxuICAgICAgICAvLyB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmVcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG5cbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdTJzpcbiAgICAgICAgLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdOyAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIGN1cnJlbnRbMV0gKyBsLCBjdXJyZW50WzJdICsgdCwgdGVtcFggKyBsLCB0ZW1wWSArIHQpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTsgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZlxuICAgICAgICAvLyB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmVcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG5cbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdxJzpcbiAgICAgICAgLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIHRlbXBYICsgbCwgdGVtcFkgKyB0KTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50WzFdICsgbCwgY3VycmVudFsyXSArIHQsIHRlbXBYICsgbCwgdGVtcFkgKyB0KTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndCc6XG4gICAgICAgIC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3QnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHRcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gdGVtcENvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSB0ZW1wQ29udHJvbFk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICdxJykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciBxXG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBDb250cm9sWCA9IGNvbnRyb2xYO1xuICAgICAgICB0ZW1wQ29udHJvbFkgPSBjb250cm9sWTtcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xYICsgbCwgY29udHJvbFkgKyB0LCB0ZW1wWCArIGwsIHRlbXBZICsgdCk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVCc6XG4gICAgICAgIHRlbXBYID0gY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdOyAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIHRlbXBYICsgbCwgdGVtcFkgKyB0KTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgZHJhd0FyYyhjb250ZXh0LCB4ICsgbCwgeSArIHQsIFtjdXJyZW50WzFdLCBjdXJyZW50WzJdLCBjdXJyZW50WzNdLCBjdXJyZW50WzRdLCBjdXJyZW50WzVdLCBjdXJyZW50WzZdICsgeCArIGwsIGN1cnJlbnRbN10gKyB5ICsgdF0pO1xuICAgICAgICB4ICs9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICBkcmF3QXJjKGNvbnRleHQsIHggKyBsLCB5ICsgdCwgW2N1cnJlbnRbMV0sIGN1cnJlbnRbMl0sIGN1cnJlbnRbM10sIGN1cnJlbnRbNF0sIGN1cnJlbnRbNV0sIGN1cnJlbnRbNl0gKyBsLCBjdXJyZW50WzddICsgdF0pO1xuICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd6JzpcbiAgICAgIGNhc2UgJ1onOlxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0FyYyhjb250ZXh0LCB4LCB5LCBjb29yZHMpIHtcbiAgY29uc3Qgc2VnID0gc2VnbWVudHMoY29vcmRzWzVdLCAvLyBlbmQgeFxuICBjb29yZHNbNl0sIC8vIGVuZCB5XG4gIGNvb3Jkc1swXSwgLy8gcmFkaXVzIHhcbiAgY29vcmRzWzFdLCAvLyByYWRpdXMgeVxuICBjb29yZHNbM10sIC8vIGxhcmdlIGZsYWdcbiAgY29vcmRzWzRdLCAvLyBzd2VlcCBmbGFnXG4gIGNvb3Jkc1syXSwgLy8gcm90YXRpb25cbiAgeCwgeSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWcubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBiZXogPSBiZXppZXIoc2VnW2ldKTtcbiAgICBjb250ZXh0LmJlemllckN1cnZlVG8oYmV6WzBdLCBiZXpbMV0sIGJlelsyXSwgYmV6WzNdLCBiZXpbNF0sIGJlels1XSk7XG4gIH1cbn1cblxuY29uc3QgVGFuMzAgPSAwLjU3NzM1MDI2OTE4OTYyNTc7XG5jb25zdCBidWlsdGlucyA9IHtcbiAgJ2NpcmNsZSc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgY29uc3QgciA9IE1hdGguc3FydChzaXplKSAvIDI7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhyLCAwKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIsIDAsIFRhdSk7XG4gICAgfVxuICB9LFxuICAnY3Jvc3MnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMixcbiAgICAgICAgICBzID0gciAvIDIuNTtcbiAgICAgIGNvbnRleHQubW92ZVRvKC1yLCAtcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtciwgcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtcywgcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtcywgcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzLCByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMsIHMpO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhyLCAtcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzLCAtcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzLCAtcik7XG4gICAgICBjb250ZXh0LmxpbmVUbygtcywgLXIpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXMsIC1zKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAnZGlhbW9uZCc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgY29uc3QgciA9IE1hdGguc3FydChzaXplKSAvIDI7XG4gICAgICBjb250ZXh0Lm1vdmVUbygtciwgMCk7XG4gICAgICBjb250ZXh0LmxpbmVUbygwLCAtcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhyLCAwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKDAsIHIpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICdzcXVhcmUnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciB3ID0gTWF0aC5zcXJ0KHNpemUpLFxuICAgICAgICAgIHggPSAtdyAvIDI7XG4gICAgICBjb250ZXh0LnJlY3QoeCwgeCwgdywgdyk7XG4gICAgfVxuICB9LFxuICAnYXJyb3cnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMixcbiAgICAgICAgICBzID0gciAvIDcsXG4gICAgICAgICAgdCA9IHIgLyAyLjUsXG4gICAgICAgICAgdiA9IHIgLyA4O1xuICAgICAgY29udGV4dC5tb3ZlVG8oLXMsIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8ocywgcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzLCAtdik7XG4gICAgICBjb250ZXh0LmxpbmVUbyh0LCAtdik7XG4gICAgICBjb250ZXh0LmxpbmVUbygwLCAtcik7XG4gICAgICBjb250ZXh0LmxpbmVUbygtdCwgLXYpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXMsIC12KTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAnd2VkZ2UnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMixcbiAgICAgICAgICBoID0gSGFsZlNxcnQzICogcixcbiAgICAgICAgICBvID0gaCAtIHIgKiBUYW4zMCxcbiAgICAgICAgICBiID0gciAvIDQ7XG4gICAgICBjb250ZXh0Lm1vdmVUbygwLCAtaCAtIG8pO1xuICAgICAgY29udGV4dC5saW5lVG8oLWIsIGggLSBvKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGIsIGggLSBvKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAndHJpYW5nbGUnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMixcbiAgICAgICAgICBoID0gSGFsZlNxcnQzICogcixcbiAgICAgICAgICBvID0gaCAtIHIgKiBUYW4zMDtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIC1oIC0gbyk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtciwgaCAtIG8pO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgaCAtIG8pO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICd0cmlhbmdsZS11cCc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICAgIGggPSBIYWxmU3FydDMgKiByO1xuICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLWgpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXIsIGgpO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgaCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3RyaWFuZ2xlLWRvd24nOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMixcbiAgICAgICAgICBoID0gSGFsZlNxcnQzICogcjtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIGgpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXIsIC1oKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHIsIC1oKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAndHJpYW5nbGUtcmlnaHQnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMixcbiAgICAgICAgICBoID0gSGFsZlNxcnQzICogcjtcbiAgICAgIGNvbnRleHQubW92ZVRvKGgsIDApO1xuICAgICAgY29udGV4dC5saW5lVG8oLWgsIC1yKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1oLCByKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAndHJpYW5nbGUtbGVmdCc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICAgIGggPSBIYWxmU3FydDMgKiByO1xuICAgICAgY29udGV4dC5tb3ZlVG8oLWgsIDApO1xuICAgICAgY29udGV4dC5saW5lVG8oaCwgLXIpO1xuICAgICAgY29udGV4dC5saW5lVG8oaCwgcik7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3N0cm9rZSc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgY29uc3QgciA9IE1hdGguc3FydChzaXplKSAvIDI7XG4gICAgICBjb250ZXh0Lm1vdmVUbygtciwgMCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhyLCAwKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzeW1ib2xzKF8pIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KGJ1aWx0aW5zLCBfKSA/IGJ1aWx0aW5zW19dIDogY3VzdG9tU3ltYm9sKF8pO1xufVxudmFyIGN1c3RvbSA9IHt9O1xuXG5mdW5jdGlvbiBjdXN0b21TeW1ib2wocGF0aCkge1xuICBpZiAoIWhhc093blByb3BlcnR5KGN1c3RvbSwgcGF0aCkpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXRoUGFyc2UocGF0aCk7XG4gICAgY3VzdG9tW3BhdGhdID0ge1xuICAgICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgICAgcGF0aFJlbmRlcihjb250ZXh0LCBwYXJzZWQsIDAsIDAsIE1hdGguc3FydChzaXplKSAvIDIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gY3VzdG9tW3BhdGhdO1xufVxuXG5jb25zdCBDID0gMC40NDgwODQ5NzU1MDY7IC8vIEMgPSAxIC0gY1xuXG5mdW5jdGlvbiByZWN0YW5nbGVYKGQpIHtcbiAgcmV0dXJuIGQueDtcbn1cblxuZnVuY3Rpb24gcmVjdGFuZ2xlWShkKSB7XG4gIHJldHVybiBkLnk7XG59XG5cbmZ1bmN0aW9uIHJlY3RhbmdsZVdpZHRoKGQpIHtcbiAgcmV0dXJuIGQud2lkdGg7XG59XG5cbmZ1bmN0aW9uIHJlY3RhbmdsZUhlaWdodChkKSB7XG4gIHJldHVybiBkLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKF8pIHtcbiAgcmV0dXJuIHR5cGVvZiBfID09PSAnZnVuY3Rpb24nID8gXyA6ICgpID0+ICtfO1xufVxuXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xufVxuXG5mdW5jdGlvbiB2Z19yZWN0ICgpIHtcbiAgdmFyIHggPSByZWN0YW5nbGVYLFxuICAgICAgeSA9IHJlY3RhbmdsZVksXG4gICAgICB3aWR0aCA9IHJlY3RhbmdsZVdpZHRoLFxuICAgICAgaGVpZ2h0ID0gcmVjdGFuZ2xlSGVpZ2h0LFxuICAgICAgY3JUTCA9IG51bWJlcigwKSxcbiAgICAgIGNyVFIgPSBjclRMLFxuICAgICAgY3JCTCA9IGNyVEwsXG4gICAgICBjckJSID0gY3JUTCxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlY3RhbmdsZShfLCB4MCwgeTApIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICB4MSA9IHgwICE9IG51bGwgPyB4MCA6ICt4LmNhbGwodGhpcywgXyksXG4gICAgICAgIHkxID0geTAgIT0gbnVsbCA/IHkwIDogK3kuY2FsbCh0aGlzLCBfKSxcbiAgICAgICAgdyA9ICt3aWR0aC5jYWxsKHRoaXMsIF8pLFxuICAgICAgICBoID0gK2hlaWdodC5jYWxsKHRoaXMsIF8pLFxuICAgICAgICBzID0gTWF0aC5taW4odywgaCkgLyAyLFxuICAgICAgICB0bCA9IGNsYW1wKCtjclRMLmNhbGwodGhpcywgXyksIDAsIHMpLFxuICAgICAgICB0ciA9IGNsYW1wKCtjclRSLmNhbGwodGhpcywgXyksIDAsIHMpLFxuICAgICAgICBibCA9IGNsYW1wKCtjckJMLmNhbGwodGhpcywgXyksIDAsIHMpLFxuICAgICAgICBiciA9IGNsYW1wKCtjckJSLmNhbGwodGhpcywgXyksIDAsIHMpO1xuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgkMygpO1xuXG4gICAgaWYgKHRsIDw9IDAgJiYgdHIgPD0gMCAmJiBibCA8PSAwICYmIGJyIDw9IDApIHtcbiAgICAgIGNvbnRleHQucmVjdCh4MSwgeTEsIHcsIGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeDIgPSB4MSArIHcsXG4gICAgICAgICAgeTIgPSB5MSArIGg7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4MSArIHRsLCB5MSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4MiAtIHRyLCB5MSk7XG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeDIgLSBDICogdHIsIHkxLCB4MiwgeTEgKyBDICogdHIsIHgyLCB5MSArIHRyKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHgyLCB5MiAtIGJyKTtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MiwgeTIgLSBDICogYnIsIHgyIC0gQyAqIGJyLCB5MiwgeDIgLSBiciwgeTIpO1xuICAgICAgY29udGV4dC5saW5lVG8oeDEgKyBibCwgeTIpO1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgxICsgQyAqIGJsLCB5MiwgeDEsIHkyIC0gQyAqIGJsLCB4MSwgeTIgLSBibCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEgKyB0bCk7XG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxICsgQyAqIHRsLCB4MSArIEMgKiB0bCwgeTEsIHgxICsgdGwsIHkxKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikge1xuICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgICByZXR1cm4gYnVmZmVyICsgJycgfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICByZWN0YW5nbGUueCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHggPSBudW1iZXIoXyk7XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH07XG5cbiAgcmVjdGFuZ2xlLnkgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB5ID0gbnVtYmVyKF8pO1xuICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHk7XG4gICAgfVxuICB9O1xuXG4gIHJlY3RhbmdsZS53aWR0aCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHdpZHRoID0gbnVtYmVyKF8pO1xuICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cbiAgfTtcblxuICByZWN0YW5nbGUuaGVpZ2h0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaGVpZ2h0ID0gbnVtYmVyKF8pO1xuICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG4gIH07XG5cbiAgcmVjdGFuZ2xlLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uICh0bCwgdHIsIGJyLCBibCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjclRMID0gbnVtYmVyKHRsKTtcbiAgICAgIGNyVFIgPSB0ciAhPSBudWxsID8gbnVtYmVyKHRyKSA6IGNyVEw7XG4gICAgICBjckJSID0gYnIgIT0gbnVsbCA/IG51bWJlcihicikgOiBjclRMO1xuICAgICAgY3JCTCA9IGJsICE9IG51bGwgPyBudW1iZXIoYmwpIDogY3JUUjtcbiAgICAgIHJldHVybiByZWN0YW5nbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjclRMO1xuICAgIH1cbiAgfTtcblxuICByZWN0YW5nbGUuY29udGV4dCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXztcbiAgICAgIHJldHVybiByZWN0YW5nbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcmVjdGFuZ2xlO1xufVxuXG5mdW5jdGlvbiB2Z190cmFpbCAoKSB7XG4gIHZhciB4LFxuICAgICAgeSxcbiAgICAgIHNpemUsXG4gICAgICBkZWZpbmVkLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICByZWFkeSxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICByMTtcblxuICBmdW5jdGlvbiBwb2ludCh4MiwgeTIsIHcyKSB7XG4gICAgY29uc3QgcjIgPSB3MiAvIDI7XG5cbiAgICBpZiAocmVhZHkpIHtcbiAgICAgIHZhciB1eCA9IHkxIC0geTIsXG4gICAgICAgICAgdXkgPSB4MiAtIHgxO1xuXG4gICAgICBpZiAodXggfHwgdXkpIHtcbiAgICAgICAgLy8gZ2V0IG5vcm1hbCB2ZWN0b3JcbiAgICAgICAgdmFyIHVkID0gTWF0aC5zcXJ0KHV4ICogdXggKyB1eSAqIHV5KSxcbiAgICAgICAgICAgIHJ4ID0gKHV4IC89IHVkKSAqIHIxLFxuICAgICAgICAgICAgcnkgPSAodXkgLz0gdWQpICogcjEsXG4gICAgICAgICAgICB0ID0gTWF0aC5hdGFuMih1eSwgdXgpOyAvLyBkcmF3IHNlZ21lbnRcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MSAtIHJ4LCB5MSAtIHJ5KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDIgLSB1eCAqIHIyLCB5MiAtIHV5ICogcjIpO1xuICAgICAgICBjb250ZXh0LmFyYyh4MiwgeTIsIHIyLCB0IC0gTWF0aC5QSSwgdCk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgxICsgcngsIHkxICsgcnkpO1xuICAgICAgICBjb250ZXh0LmFyYyh4MSwgeTEsIHIxLCB0LCB0ICsgTWF0aC5QSSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmFyYyh4MiwgeTIsIHIyLCAwLCBUYXUpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFkeSA9IDE7XG4gICAgfVxuXG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICAgIHIxID0gcjI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbChkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyO1xuICAgIGlmIChjb250ZXh0ID09IG51bGwpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoJDMoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkgcmVhZHkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5lZDApIHBvaW50KCt4KGQsIGksIGRhdGEpLCAreShkLCBpLCBkYXRhKSwgK3NpemUoZCwgaSwgZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgcmV0dXJuIGJ1ZmZlciArICcnIHx8IG51bGw7XG4gICAgfVxuICB9XG5cbiAgdHJhaWwueCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHggPSBfO1xuICAgICAgcmV0dXJuIHRyYWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH07XG5cbiAgdHJhaWwueSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHkgPSBfO1xuICAgICAgcmV0dXJuIHRyYWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gIH07XG5cbiAgdHJhaWwuc2l6ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNpemUgPSBfO1xuICAgICAgcmV0dXJuIHRyYWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH07XG5cbiAgdHJhaWwuZGVmaW5lZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGRlZmluZWQgPSBfO1xuICAgICAgcmV0dXJuIHRyYWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgdHJhaWwuY29udGV4dCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmIChfID09IG51bGwpIHtcbiAgICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0ID0gXztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRyYWlsO1xufVxuXG5mdW5jdGlvbiB2YWx1ZSQxKGEsIGIpIHtcbiAgcmV0dXJuIGEgIT0gbnVsbCA/IGEgOiBiO1xufVxuXG5jb25zdCB4ID0gaXRlbSA9PiBpdGVtLnggfHwgMCxcbiAgICAgIHkgPSBpdGVtID0+IGl0ZW0ueSB8fCAwLFxuICAgICAgdyA9IGl0ZW0gPT4gaXRlbS53aWR0aCB8fCAwLFxuICAgICAgaCA9IGl0ZW0gPT4gaXRlbS5oZWlnaHQgfHwgMCxcbiAgICAgIHh3ID0gaXRlbSA9PiAoaXRlbS54IHx8IDApICsgKGl0ZW0ud2lkdGggfHwgMCksXG4gICAgICB5aCA9IGl0ZW0gPT4gKGl0ZW0ueSB8fCAwKSArIChpdGVtLmhlaWdodCB8fCAwKSxcbiAgICAgIHNhID0gaXRlbSA9PiBpdGVtLnN0YXJ0QW5nbGUgfHwgMCxcbiAgICAgIGVhID0gaXRlbSA9PiBpdGVtLmVuZEFuZ2xlIHx8IDAsXG4gICAgICBwYSA9IGl0ZW0gPT4gaXRlbS5wYWRBbmdsZSB8fCAwLFxuICAgICAgaXIgPSBpdGVtID0+IGl0ZW0uaW5uZXJSYWRpdXMgfHwgMCxcbiAgICAgIG9yID0gaXRlbSA9PiBpdGVtLm91dGVyUmFkaXVzIHx8IDAsXG4gICAgICBjciA9IGl0ZW0gPT4gaXRlbS5jb3JuZXJSYWRpdXMgfHwgMCxcbiAgICAgIHRsID0gaXRlbSA9PiB2YWx1ZSQxKGl0ZW0uY29ybmVyUmFkaXVzVG9wTGVmdCwgaXRlbS5jb3JuZXJSYWRpdXMpIHx8IDAsXG4gICAgICB0ciA9IGl0ZW0gPT4gdmFsdWUkMShpdGVtLmNvcm5lclJhZGl1c1RvcFJpZ2h0LCBpdGVtLmNvcm5lclJhZGl1cykgfHwgMCxcbiAgICAgIGJyID0gaXRlbSA9PiB2YWx1ZSQxKGl0ZW0uY29ybmVyUmFkaXVzQm90dG9tUmlnaHQsIGl0ZW0uY29ybmVyUmFkaXVzKSB8fCAwLFxuICAgICAgYmwgPSBpdGVtID0+IHZhbHVlJDEoaXRlbS5jb3JuZXJSYWRpdXNCb3R0b21MZWZ0LCBpdGVtLmNvcm5lclJhZGl1cykgfHwgMCxcbiAgICAgIHN6ID0gaXRlbSA9PiB2YWx1ZSQxKGl0ZW0uc2l6ZSwgNjQpLFxuICAgICAgdHMgPSBpdGVtID0+IGl0ZW0uc2l6ZSB8fCAxLFxuICAgICAgZGVmID0gaXRlbSA9PiAhKGl0ZW0uZGVmaW5lZCA9PT0gZmFsc2UpLFxuICAgICAgdHlwZSA9IGl0ZW0gPT4gc3ltYm9scyhpdGVtLnNoYXBlIHx8ICdjaXJjbGUnKTtcblxuY29uc3QgYXJjU2hhcGUgPSBhcmMkMigpLnN0YXJ0QW5nbGUoc2EpLmVuZEFuZ2xlKGVhKS5wYWRBbmdsZShwYSkuaW5uZXJSYWRpdXMoaXIpLm91dGVyUmFkaXVzKG9yKS5jb3JuZXJSYWRpdXMoY3IpLFxuICAgICAgYXJlYXZTaGFwZSA9IGFyZWEkMigpLngoeCkueTEoeSkueTAoeWgpLmRlZmluZWQoZGVmKSxcbiAgICAgIGFyZWFoU2hhcGUgPSBhcmVhJDIoKS55KHkpLngxKHgpLngwKHh3KS5kZWZpbmVkKGRlZiksXG4gICAgICBsaW5lU2hhcGUgPSBsaW5lJDIoKS54KHgpLnkoeSkuZGVmaW5lZChkZWYpLFxuICAgICAgcmVjdFNoYXBlID0gdmdfcmVjdCgpLngoeCkueSh5KS53aWR0aCh3KS5oZWlnaHQoaCkuY29ybmVyUmFkaXVzKHRsLCB0ciwgYnIsIGJsKSxcbiAgICAgIHN5bWJvbFNoYXBlID0gc3ltYm9sJDIoKS50eXBlKHR5cGUpLnNpemUoc3opLFxuICAgICAgdHJhaWxTaGFwZSA9IHZnX3RyYWlsKCkueCh4KS55KHkpLmRlZmluZWQoZGVmKS5zaXplKHRzKTtcbmZ1bmN0aW9uIGhhc0Nvcm5lclJhZGl1cyhpdGVtKSB7XG4gIHJldHVybiBpdGVtLmNvcm5lclJhZGl1cyB8fCBpdGVtLmNvcm5lclJhZGl1c1RvcExlZnQgfHwgaXRlbS5jb3JuZXJSYWRpdXNUb3BSaWdodCB8fCBpdGVtLmNvcm5lclJhZGl1c0JvdHRvbVJpZ2h0IHx8IGl0ZW0uY29ybmVyUmFkaXVzQm90dG9tTGVmdDtcbn1cbmZ1bmN0aW9uIGFyYyQxKGNvbnRleHQsIGl0ZW0pIHtcbiAgcmV0dXJuIGFyY1NoYXBlLmNvbnRleHQoY29udGV4dCkoaXRlbSk7XG59XG5mdW5jdGlvbiBhcmVhJDEoY29udGV4dCwgaXRlbXMpIHtcbiAgY29uc3QgaXRlbSA9IGl0ZW1zWzBdLFxuICAgICAgICBpbnRlcnAgPSBpdGVtLmludGVycG9sYXRlIHx8ICdsaW5lYXInO1xuICByZXR1cm4gKGl0ZW0ub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBhcmVhaFNoYXBlIDogYXJlYXZTaGFwZSkuY3VydmUoY3VydmVzKGludGVycCwgaXRlbS5vcmllbnQsIGl0ZW0udGVuc2lvbikpLmNvbnRleHQoY29udGV4dCkoaXRlbXMpO1xufVxuZnVuY3Rpb24gbGluZSQxKGNvbnRleHQsIGl0ZW1zKSB7XG4gIGNvbnN0IGl0ZW0gPSBpdGVtc1swXSxcbiAgICAgICAgaW50ZXJwID0gaXRlbS5pbnRlcnBvbGF0ZSB8fCAnbGluZWFyJztcbiAgcmV0dXJuIGxpbmVTaGFwZS5jdXJ2ZShjdXJ2ZXMoaW50ZXJwLCBpdGVtLm9yaWVudCwgaXRlbS50ZW5zaW9uKSkuY29udGV4dChjb250ZXh0KShpdGVtcyk7XG59XG5mdW5jdGlvbiByZWN0YW5nbGUoY29udGV4dCwgaXRlbSwgeCwgeSkge1xuICByZXR1cm4gcmVjdFNoYXBlLmNvbnRleHQoY29udGV4dCkoaXRlbSwgeCwgeSk7XG59XG5mdW5jdGlvbiBzaGFwZSQxKGNvbnRleHQsIGl0ZW0pIHtcbiAgcmV0dXJuIChpdGVtLm1hcmsuc2hhcGUgfHwgaXRlbS5zaGFwZSkuY29udGV4dChjb250ZXh0KShpdGVtKTtcbn1cbmZ1bmN0aW9uIHN5bWJvbCQxKGNvbnRleHQsIGl0ZW0pIHtcbiAgcmV0dXJuIHN5bWJvbFNoYXBlLmNvbnRleHQoY29udGV4dCkoaXRlbSk7XG59XG5mdW5jdGlvbiB0cmFpbCQxKGNvbnRleHQsIGl0ZW1zKSB7XG4gIHJldHVybiB0cmFpbFNoYXBlLmNvbnRleHQoY29udGV4dCkoaXRlbXMpO1xufVxuXG52YXIgY2xpcF9pZCA9IDE7XG5mdW5jdGlvbiByZXNldFNWR0NsaXBJZCgpIHtcbiAgY2xpcF9pZCA9IDE7XG59XG5mdW5jdGlvbiBjbGlwJDEgKHJlbmRlcmVyLCBpdGVtLCBzaXplKSB7XG4gIHZhciBjbGlwID0gaXRlbS5jbGlwLFxuICAgICAgZGVmcyA9IHJlbmRlcmVyLl9kZWZzLFxuICAgICAgaWQgPSBpdGVtLmNsaXBfaWQgfHwgKGl0ZW0uY2xpcF9pZCA9ICdjbGlwJyArIGNsaXBfaWQrKyksXG4gICAgICBjID0gZGVmcy5jbGlwcGluZ1tpZF0gfHwgKGRlZnMuY2xpcHBpbmdbaWRdID0ge1xuICAgIGlkOiBpZFxuICB9KTtcblxuICBpZiAoaXNGdW5jdGlvbihjbGlwKSkge1xuICAgIGMucGF0aCA9IGNsaXAobnVsbCk7XG4gIH0gZWxzZSBpZiAoaGFzQ29ybmVyUmFkaXVzKHNpemUpKSB7XG4gICAgYy5wYXRoID0gcmVjdGFuZ2xlKG51bGwsIHNpemUsIDAsIDApO1xuICB9IGVsc2Uge1xuICAgIGMud2lkdGggPSBzaXplLndpZHRoIHx8IDA7XG4gICAgYy5oZWlnaHQgPSBzaXplLmhlaWdodCB8fCAwO1xuICB9XG5cbiAgcmV0dXJuICd1cmwoIycgKyBpZCArICcpJztcbn1cblxuZnVuY3Rpb24gQm91bmRzKGIpIHtcbiAgdGhpcy5jbGVhcigpO1xuICBpZiAoYikgdGhpcy51bmlvbihiKTtcbn1cbkJvdW5kcy5wcm90b3R5cGUgPSB7XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRzKHRoaXMpO1xuICB9LFxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMueDEgPSArTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLnkxID0gK051bWJlci5NQVhfVkFMVUU7XG4gICAgdGhpcy54MiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHRoaXMueTIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy54MSA9PT0gK051bWJlci5NQVhfVkFMVUUgJiYgdGhpcy55MSA9PT0gK051bWJlci5NQVhfVkFMVUUgJiYgdGhpcy54MiA9PT0gLU51bWJlci5NQVhfVkFMVUUgJiYgdGhpcy55MiA9PT0gLU51bWJlci5NQVhfVkFMVUU7XG4gIH0sXG5cbiAgZXF1YWxzKGIpIHtcbiAgICByZXR1cm4gdGhpcy54MSA9PT0gYi54MSAmJiB0aGlzLnkxID09PSBiLnkxICYmIHRoaXMueDIgPT09IGIueDIgJiYgdGhpcy55MiA9PT0gYi55MjtcbiAgfSxcblxuICBzZXQoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBpZiAoeDIgPCB4MSkge1xuICAgICAgdGhpcy54MiA9IHgxO1xuICAgICAgdGhpcy54MSA9IHgyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLngxID0geDE7XG4gICAgICB0aGlzLngyID0geDI7XG4gICAgfVxuXG4gICAgaWYgKHkyIDwgeTEpIHtcbiAgICAgIHRoaXMueTIgPSB5MTtcbiAgICAgIHRoaXMueTEgPSB5MjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy55MSA9IHkxO1xuICAgICAgdGhpcy55MiA9IHkyO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFkZCh4LCB5KSB7XG4gICAgaWYgKHggPCB0aGlzLngxKSB0aGlzLngxID0geDtcbiAgICBpZiAoeSA8IHRoaXMueTEpIHRoaXMueTEgPSB5O1xuICAgIGlmICh4ID4gdGhpcy54MikgdGhpcy54MiA9IHg7XG4gICAgaWYgKHkgPiB0aGlzLnkyKSB0aGlzLnkyID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBleHBhbmQoZCkge1xuICAgIHRoaXMueDEgLT0gZDtcbiAgICB0aGlzLnkxIC09IGQ7XG4gICAgdGhpcy54MiArPSBkO1xuICAgIHRoaXMueTIgKz0gZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByb3VuZCgpIHtcbiAgICB0aGlzLngxID0gTWF0aC5mbG9vcih0aGlzLngxKTtcbiAgICB0aGlzLnkxID0gTWF0aC5mbG9vcih0aGlzLnkxKTtcbiAgICB0aGlzLngyID0gTWF0aC5jZWlsKHRoaXMueDIpO1xuICAgIHRoaXMueTIgPSBNYXRoLmNlaWwodGhpcy55Mik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2NhbGUocykge1xuICAgIHRoaXMueDEgKj0gcztcbiAgICB0aGlzLnkxICo9IHM7XG4gICAgdGhpcy54MiAqPSBzO1xuICAgIHRoaXMueTIgKj0gcztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0cmFuc2xhdGUoZHgsIGR5KSB7XG4gICAgdGhpcy54MSArPSBkeDtcbiAgICB0aGlzLngyICs9IGR4O1xuICAgIHRoaXMueTEgKz0gZHk7XG4gICAgdGhpcy55MiArPSBkeTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByb3RhdGUoYW5nbGUsIHgsIHkpIHtcbiAgICBjb25zdCBwID0gdGhpcy5yb3RhdGVkUG9pbnRzKGFuZ2xlLCB4LCB5KTtcbiAgICByZXR1cm4gdGhpcy5jbGVhcigpLmFkZChwWzBdLCBwWzFdKS5hZGQocFsyXSwgcFszXSkuYWRkKHBbNF0sIHBbNV0pLmFkZChwWzZdLCBwWzddKTtcbiAgfSxcblxuICByb3RhdGVkUG9pbnRzKGFuZ2xlLCB4LCB5KSB7XG4gICAgdmFyIHtcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyXG4gICAgfSA9IHRoaXMsXG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICBjeCA9IHggLSB4ICogY29zICsgeSAqIHNpbixcbiAgICAgICAgY3kgPSB5IC0geCAqIHNpbiAtIHkgKiBjb3M7XG4gICAgcmV0dXJuIFtjb3MgKiB4MSAtIHNpbiAqIHkxICsgY3gsIHNpbiAqIHgxICsgY29zICogeTEgKyBjeSwgY29zICogeDEgLSBzaW4gKiB5MiArIGN4LCBzaW4gKiB4MSArIGNvcyAqIHkyICsgY3ksIGNvcyAqIHgyIC0gc2luICogeTEgKyBjeCwgc2luICogeDIgKyBjb3MgKiB5MSArIGN5LCBjb3MgKiB4MiAtIHNpbiAqIHkyICsgY3gsIHNpbiAqIHgyICsgY29zICogeTIgKyBjeV07XG4gIH0sXG5cbiAgdW5pb24oYikge1xuICAgIGlmIChiLngxIDwgdGhpcy54MSkgdGhpcy54MSA9IGIueDE7XG4gICAgaWYgKGIueTEgPCB0aGlzLnkxKSB0aGlzLnkxID0gYi55MTtcbiAgICBpZiAoYi54MiA+IHRoaXMueDIpIHRoaXMueDIgPSBiLngyO1xuICAgIGlmIChiLnkyID4gdGhpcy55MikgdGhpcy55MiA9IGIueTI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW50ZXJzZWN0KGIpIHtcbiAgICBpZiAoYi54MSA+IHRoaXMueDEpIHRoaXMueDEgPSBiLngxO1xuICAgIGlmIChiLnkxID4gdGhpcy55MSkgdGhpcy55MSA9IGIueTE7XG4gICAgaWYgKGIueDIgPCB0aGlzLngyKSB0aGlzLngyID0gYi54MjtcbiAgICBpZiAoYi55MiA8IHRoaXMueTIpIHRoaXMueTIgPSBiLnkyO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGVuY2xvc2VzKGIpIHtcbiAgICByZXR1cm4gYiAmJiB0aGlzLngxIDw9IGIueDEgJiYgdGhpcy54MiA+PSBiLngyICYmIHRoaXMueTEgPD0gYi55MSAmJiB0aGlzLnkyID49IGIueTI7XG4gIH0sXG5cbiAgYWxpZ25zV2l0aChiKSB7XG4gICAgcmV0dXJuIGIgJiYgKHRoaXMueDEgPT0gYi54MSB8fCB0aGlzLngyID09IGIueDIgfHwgdGhpcy55MSA9PSBiLnkxIHx8IHRoaXMueTIgPT0gYi55Mik7XG4gIH0sXG5cbiAgaW50ZXJzZWN0cyhiKSB7XG4gICAgcmV0dXJuIGIgJiYgISh0aGlzLngyIDwgYi54MSB8fCB0aGlzLngxID4gYi54MiB8fCB0aGlzLnkyIDwgYi55MSB8fCB0aGlzLnkxID4gYi55Mik7XG4gIH0sXG5cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIHJldHVybiAhKHggPCB0aGlzLngxIHx8IHggPiB0aGlzLngyIHx8IHkgPCB0aGlzLnkxIHx8IHkgPiB0aGlzLnkyKTtcbiAgfSxcblxuICB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy54MiAtIHRoaXMueDE7XG4gIH0sXG5cbiAgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnkyIC0gdGhpcy55MTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBJdGVtKG1hcmspIHtcbiAgdGhpcy5tYXJrID0gbWFyaztcbiAgdGhpcy5ib3VuZHMgPSB0aGlzLmJvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG59XG5cbmZ1bmN0aW9uIEdyb3VwSXRlbShtYXJrKSB7XG4gIEl0ZW0uY2FsbCh0aGlzLCBtYXJrKTtcbiAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG59XG5pbmhlcml0cyhHcm91cEl0ZW0sIEl0ZW0pO1xuXG5mdW5jdGlvbiBSZXNvdXJjZUxvYWRlcihjdXN0b21Mb2FkZXIpIHtcbiAgdGhpcy5fcGVuZGluZyA9IDA7XG4gIHRoaXMuX2xvYWRlciA9IGN1c3RvbUxvYWRlciB8fCBsb2FkZXIoKTtcbn1cblxuZnVuY3Rpb24gaW5jcmVtZW50KGxvYWRlcikge1xuICBsb2FkZXIuX3BlbmRpbmcgKz0gMTtcbn1cblxuZnVuY3Rpb24gZGVjcmVtZW50KGxvYWRlcikge1xuICBsb2FkZXIuX3BlbmRpbmcgLT0gMTtcbn1cblxuUmVzb3VyY2VMb2FkZXIucHJvdG90eXBlID0ge1xuICBwZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nO1xuICB9LFxuXG4gIHNhbml0aXplVVJMKHVyaSkge1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXM7XG4gICAgaW5jcmVtZW50KGxvYWRlcik7XG4gICAgcmV0dXJuIGxvYWRlci5fbG9hZGVyLnNhbml0aXplKHVyaSwge1xuICAgICAgY29udGV4dDogJ2hyZWYnXG4gICAgfSkudGhlbihvcHQgPT4ge1xuICAgICAgZGVjcmVtZW50KGxvYWRlcik7XG4gICAgICByZXR1cm4gb3B0O1xuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIGRlY3JlbWVudChsb2FkZXIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gIH0sXG5cbiAgbG9hZEltYWdlKHVyaSkge1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMsXG4gICAgICAgICAgSW1hZ2UgPSBpbWFnZSQxKCk7XG4gICAgaW5jcmVtZW50KGxvYWRlcik7XG4gICAgcmV0dXJuIGxvYWRlci5fbG9hZGVyLnNhbml0aXplKHVyaSwge1xuICAgICAgY29udGV4dDogJ2ltYWdlJ1xuICAgIH0pLnRoZW4ob3B0ID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IG9wdC5ocmVmO1xuICAgICAgaWYgKCF1cmwgfHwgIUltYWdlKSB0aHJvdyB7XG4gICAgICAgIHVybDogdXJsXG4gICAgICB9O1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7IC8vIHNldCBjcm9zc09yaWdpbiBvbmx5IGlmIGNvcnMgaXMgZGVmaW5lZDsgZW1wdHkgc3RyaW5nIHNldHMgYW5vbnltb3VzIG1vZGVcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50L2Nyb3NzT3JpZ2luXG5cbiAgICAgIGNvbnN0IGNvcnMgPSBoYXNPd25Qcm9wZXJ0eShvcHQsICdjcm9zc09yaWdpbicpID8gb3B0LmNyb3NzT3JpZ2luIDogJ2Fub255bW91cyc7XG4gICAgICBpZiAoY29ycyAhPSBudWxsKSBpbWcuY3Jvc3NPcmlnaW4gPSBjb3JzOyAvLyBhdHRlbXB0IHRvIGxvYWQgaW1hZ2UgcmVzb3VyY2VcblxuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IGRlY3JlbWVudChsb2FkZXIpO1xuXG4gICAgICBpbWcub25lcnJvciA9ICgpID0+IGRlY3JlbWVudChsb2FkZXIpO1xuXG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgcmV0dXJuIGltZztcbiAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgIGRlY3JlbWVudChsb2FkZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBzcmM6IGUgJiYgZS51cmwgfHwgJydcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVhZHkoKSB7XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYWNjZXB0ID0+IHtcbiAgICAgIGZ1bmN0aW9uIHBvbGwodmFsdWUpIHtcbiAgICAgICAgaWYgKCFsb2FkZXIucGVuZGluZygpKSBhY2NlcHQodmFsdWUpO2Vsc2Ugc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcG9sbCh0cnVlKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfVxuXG4gICAgICBwb2xsKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBib3VuZFN0cm9rZSAoYm91bmRzLCBpdGVtLCBtaXRlcikge1xuICBpZiAoaXRlbS5zdHJva2UgJiYgaXRlbS5vcGFjaXR5ICE9PSAwICYmIGl0ZW0uc3Ryb2tlT3BhY2l0eSAhPT0gMCkge1xuICAgIGNvbnN0IHN3ID0gaXRlbS5zdHJva2VXaWR0aCAhPSBudWxsID8gK2l0ZW0uc3Ryb2tlV2lkdGggOiAxO1xuICAgIGJvdW5kcy5leHBhbmQoc3cgKyAobWl0ZXIgPyBtaXRlckFkanVzdG1lbnQoaXRlbSwgc3cpIDogMCkpO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gbWl0ZXJBZGp1c3RtZW50KGl0ZW0sIHN0cm9rZVdpZHRoKSB7XG4gIC8vIFRPRE86IG1vcmUgc29waGlzdGljYXRlZCBhZGp1c3RtZW50PyBPciBtaXRlciBzdXBwb3J0IGluIGJvdW5kQ29udGV4dD9cbiAgcmV0dXJuIGl0ZW0uc3Ryb2tlSm9pbiAmJiBpdGVtLnN0cm9rZUpvaW4gIT09ICdtaXRlcicgPyAwIDogc3Ryb2tlV2lkdGg7XG59XG5cbmNvbnN0IGNpcmNsZVRocmVzaG9sZCA9IFRhdSAtIDFlLTg7XG5sZXQgYm91bmRzLCBseCwgbHksIHJvdCwgbWEsIG1iLCBtYywgbWQ7XG5cbmNvbnN0IGFkZCA9ICh4LCB5KSA9PiBib3VuZHMuYWRkKHgsIHkpO1xuXG5jb25zdCBhZGRMID0gKHgsIHkpID0+IGFkZChseCA9IHgsIGx5ID0geSk7XG5cbmNvbnN0IGFkZFggPSB4ID0+IGFkZCh4LCBib3VuZHMueTEpO1xuXG5jb25zdCBhZGRZID0geSA9PiBhZGQoYm91bmRzLngxLCB5KTtcblxuY29uc3QgcHggPSAoeCwgeSkgPT4gbWEgKiB4ICsgbWMgKiB5O1xuXG5jb25zdCBweSA9ICh4LCB5KSA9PiBtYiAqIHggKyBtZCAqIHk7XG5cbmNvbnN0IGFkZHAgPSAoeCwgeSkgPT4gYWRkKHB4KHgsIHkpLCBweSh4LCB5KSk7XG5cbmNvbnN0IGFkZHBMID0gKHgsIHkpID0+IGFkZEwocHgoeCwgeSksIHB5KHgsIHkpKTtcblxuZnVuY3Rpb24gYm91bmRDb250ZXh0IChfLCBkZWcpIHtcbiAgYm91bmRzID0gXztcblxuICBpZiAoZGVnKSB7XG4gICAgcm90ID0gZGVnICogRGVnVG9SYWQ7XG4gICAgbWEgPSBtZCA9IE1hdGguY29zKHJvdCk7XG4gICAgbWIgPSBNYXRoLnNpbihyb3QpO1xuICAgIG1jID0gLW1iO1xuICB9IGVsc2Uge1xuICAgIG1hID0gbWQgPSAxO1xuICAgIHJvdCA9IG1iID0gbWMgPSAwO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQkMTtcbn1cbmNvbnN0IGNvbnRleHQkMSA9IHtcbiAgYmVnaW5QYXRoKCkge30sXG5cbiAgY2xvc2VQYXRoKCkge30sXG5cbiAgbW92ZVRvOiBhZGRwTCxcbiAgbGluZVRvOiBhZGRwTCxcblxuICByZWN0KHgsIHksIHcsIGgpIHtcbiAgICBpZiAocm90KSB7XG4gICAgICBhZGRwKHggKyB3LCB5KTtcbiAgICAgIGFkZHAoeCArIHcsIHkgKyBoKTtcbiAgICAgIGFkZHAoeCwgeSArIGgpO1xuICAgICAgYWRkcEwoeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZCh4ICsgdywgeSArIGgpO1xuICAgICAgYWRkTCh4LCB5KTtcbiAgICB9XG4gIH0sXG5cbiAgcXVhZHJhdGljQ3VydmVUbyh4MSwgeTEsIHgyLCB5Mikge1xuICAgIGNvbnN0IHB4MSA9IHB4KHgxLCB5MSksXG4gICAgICAgICAgcHkxID0gcHkoeDEsIHkxKSxcbiAgICAgICAgICBweDIgPSBweCh4MiwgeTIpLFxuICAgICAgICAgIHB5MiA9IHB5KHgyLCB5Mik7XG4gICAgcXVhZEV4dHJlbWEobHgsIHB4MSwgcHgyLCBhZGRYKTtcbiAgICBxdWFkRXh0cmVtYShseSwgcHkxLCBweTIsIGFkZFkpO1xuICAgIGFkZEwocHgyLCBweTIpO1xuICB9LFxuXG4gIGJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIGNvbnN0IHB4MSA9IHB4KHgxLCB5MSksXG4gICAgICAgICAgcHkxID0gcHkoeDEsIHkxKSxcbiAgICAgICAgICBweDIgPSBweCh4MiwgeTIpLFxuICAgICAgICAgIHB5MiA9IHB5KHgyLCB5MiksXG4gICAgICAgICAgcHgzID0gcHgoeDMsIHkzKSxcbiAgICAgICAgICBweTMgPSBweSh4MywgeTMpO1xuICAgIGN1YmljRXh0cmVtYShseCwgcHgxLCBweDIsIHB4MywgYWRkWCk7XG4gICAgY3ViaWNFeHRyZW1hKGx5LCBweTEsIHB5MiwgcHkzLCBhZGRZKTtcbiAgICBhZGRMKHB4MywgcHkzKTtcbiAgfSxcblxuICBhcmMoY3gsIGN5LCByLCBzYSwgZWEsIGNjdykge1xuICAgIHNhICs9IHJvdDtcbiAgICBlYSArPSByb3Q7IC8vIHN0b3JlIGxhc3QgcG9pbnQgb24gcGF0aFxuXG4gICAgbHggPSByICogTWF0aC5jb3MoZWEpICsgY3g7XG4gICAgbHkgPSByICogTWF0aC5zaW4oZWEpICsgY3k7XG5cbiAgICBpZiAoTWF0aC5hYnMoZWEgLSBzYSkgPiBjaXJjbGVUaHJlc2hvbGQpIHtcbiAgICAgIC8vIHRyZWF0IGFzIGZ1bGwgY2lyY2xlXG4gICAgICBhZGQoY3ggLSByLCBjeSAtIHIpO1xuICAgICAgYWRkKGN4ICsgciwgY3kgKyByKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdXBkYXRlID0gYSA9PiBhZGQociAqIE1hdGguY29zKGEpICsgY3gsIHIgKiBNYXRoLnNpbihhKSArIGN5KTtcblxuICAgICAgbGV0IHMsIGk7IC8vIHNhbXBsZSBlbmQgcG9pbnRzXG5cbiAgICAgIHVwZGF0ZShzYSk7XG4gICAgICB1cGRhdGUoZWEpOyAvLyBzYW1wbGUgaW50ZXJpb3IgcG9pbnRzIGFsaWduZWQgd2l0aCA5MCBkZWdyZWVzXG5cbiAgICAgIGlmIChlYSAhPT0gc2EpIHtcbiAgICAgICAgc2EgPSBzYSAlIFRhdTtcbiAgICAgICAgaWYgKHNhIDwgMCkgc2EgKz0gVGF1O1xuICAgICAgICBlYSA9IGVhICUgVGF1O1xuICAgICAgICBpZiAoZWEgPCAwKSBlYSArPSBUYXU7XG5cbiAgICAgICAgaWYgKGVhIDwgc2EpIHtcbiAgICAgICAgICBjY3cgPSAhY2N3OyAvLyBmbGlwIGRpcmVjdGlvblxuXG4gICAgICAgICAgcyA9IHNhO1xuICAgICAgICAgIHNhID0gZWE7XG4gICAgICAgICAgZWEgPSBzOyAvLyBzd2FwIGVuZC1wb2ludHNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjY3cpIHtcbiAgICAgICAgICBlYSAtPSBUYXU7XG4gICAgICAgICAgcyA9IHNhIC0gc2EgJSBIYWxmUGk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNCAmJiBzID4gZWE7ICsraSwgcyAtPSBIYWxmUGkpIHVwZGF0ZShzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzID0gc2EgLSBzYSAlIEhhbGZQaSArIEhhbGZQaTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0ICYmIHMgPCBlYTsgKytpLCBzID0gcyArIEhhbGZQaSkgdXBkYXRlKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbmZ1bmN0aW9uIHF1YWRFeHRyZW1hKHgwLCB4MSwgeDIsIGNiKSB7XG4gIGNvbnN0IHQgPSAoeDAgLSB4MSkgLyAoeDAgKyB4MiAtIDIgKiB4MSk7XG4gIGlmICgwIDwgdCAmJiB0IDwgMSkgY2IoeDAgKyAoeDEgLSB4MCkgKiB0KTtcbn1cblxuZnVuY3Rpb24gY3ViaWNFeHRyZW1hKHgwLCB4MSwgeDIsIHgzLCBjYikge1xuICBjb25zdCBhID0geDMgLSB4MCArIDMgKiB4MSAtIDMgKiB4MixcbiAgICAgICAgYiA9IHgwICsgeDIgLSAyICogeDEsXG4gICAgICAgIGMgPSB4MCAtIHgxO1xuICBsZXQgdDAgPSAwLFxuICAgICAgdDEgPSAwLFxuICAgICAgcjsgLy8gc29sdmUgZm9yIHBhcmFtZXRlciB0XG5cbiAgaWYgKE1hdGguYWJzKGEpID4gRXBzaWxvbikge1xuICAgIC8vIHF1YWRyYXRpYyBlcXVhdGlvblxuICAgIHIgPSBiICogYiArIGMgKiBhO1xuXG4gICAgaWYgKHIgPj0gMCkge1xuICAgICAgciA9IE1hdGguc3FydChyKTtcbiAgICAgIHQwID0gKC1iICsgcikgLyBhO1xuICAgICAgdDEgPSAoLWIgLSByKSAvIGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGxpbmVhciBlcXVhdGlvblxuICAgIHQwID0gMC41ICogYyAvIGI7XG4gIH0gLy8gY2FsY3VsYXRlIHBvc2l0aW9uXG5cblxuICBpZiAoMCA8IHQwICYmIHQwIDwgMSkgY2IoY3ViaWModDAsIHgwLCB4MSwgeDIsIHgzKSk7XG4gIGlmICgwIDwgdDEgJiYgdDEgPCAxKSBjYihjdWJpYyh0MSwgeDAsIHgxLCB4MiwgeDMpKTtcbn1cblxuZnVuY3Rpb24gY3ViaWModCwgeDAsIHgxLCB4MiwgeDMpIHtcbiAgY29uc3QgcyA9IDEgLSB0LFxuICAgICAgICBzMiA9IHMgKiBzLFxuICAgICAgICB0MiA9IHQgKiB0O1xuICByZXR1cm4gczIgKiBzICogeDAgKyAzICogczIgKiB0ICogeDEgKyAzICogcyAqIHQyICogeDIgKyB0MiAqIHQgKiB4Mztcbn1cblxudmFyIGNvbnRleHQgPSAoY29udGV4dCA9IGNhbnZhcygxLCAxKSkgPyBjb250ZXh0LmdldENvbnRleHQoJzJkJykgOiBudWxsO1xuXG5jb25zdCBiID0gbmV3IEJvdW5kcygpO1xuZnVuY3Rpb24gaW50ZXJzZWN0UGF0aChkcmF3KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXRlbSwgYnJ1c2gpIHtcbiAgICAvLyByZWx5IG9uIChpbmFjY3VyYXRlKSBib3VuZHMgaW50ZXJzZWN0aW9uIGlmIG5vIGNvbnRleHRcbiAgICBpZiAoIWNvbnRleHQpIHJldHVybiB0cnVlOyAvLyBhZGQgcGF0aCB0byBvZmZzY3JlZW4gZ3JhcGhpY3MgY29udGV4dFxuXG4gICAgZHJhdyhjb250ZXh0LCBpdGVtKTsgLy8gZ2V0IGJvdW5kcyBpbnRlcnNlY3Rpb24gcmVnaW9uXG5cbiAgICBiLmNsZWFyKCkudW5pb24oaXRlbS5ib3VuZHMpLmludGVyc2VjdChicnVzaCkucm91bmQoKTtcbiAgICBjb25zdCB7XG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MlxuICAgIH0gPSBiOyAvLyBpdGVyYXRlIG92ZXIgaW50ZXJzZWN0aW9uIHJlZ2lvblxuICAgIC8vIHBlcmZvcm0gZmluZSBncmFpbmVkIGluY2x1c2lvbiB0ZXN0XG5cbiAgICBmb3IgKGxldCB5ID0geTE7IHkgPD0geTI7ICsreSkge1xuICAgICAgZm9yIChsZXQgeCA9IHgxOyB4IDw9IHgyOyArK3gpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuaXNQb2ludEluUGF0aCh4LCB5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBmYWxzZSBpZiBubyBoaXRzIGluIGludGVyc2VjdGlvbiByZWdpb25cblxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0UG9pbnQoaXRlbSwgYm94KSB7XG4gIHJldHVybiBib3guY29udGFpbnMoaXRlbS54IHx8IDAsIGl0ZW0ueSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFJlY3QoaXRlbSwgYm94KSB7XG4gIGNvbnN0IHggPSBpdGVtLnggfHwgMCxcbiAgICAgICAgeSA9IGl0ZW0ueSB8fCAwLFxuICAgICAgICB3ID0gaXRlbS53aWR0aCB8fCAwLFxuICAgICAgICBoID0gaXRlbS5oZWlnaHQgfHwgMDtcbiAgcmV0dXJuIGJveC5pbnRlcnNlY3RzKGIuc2V0KHgsIHksIHggKyB3LCB5ICsgaCkpO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0UnVsZShpdGVtLCBib3gpIHtcbiAgY29uc3QgeCA9IGl0ZW0ueCB8fCAwLFxuICAgICAgICB5ID0gaXRlbS55IHx8IDAsXG4gICAgICAgIHgyID0gaXRlbS54MiAhPSBudWxsID8gaXRlbS54MiA6IHgsXG4gICAgICAgIHkyID0gaXRlbS55MiAhPSBudWxsID8gaXRlbS55MiA6IHk7XG4gIHJldHVybiBpbnRlcnNlY3RCb3hMaW5lKGJveCwgeCwgeSwgeDIsIHkyKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdEJveExpbmUoYm94LCB4LCB5LCB1LCB2KSB7XG4gIGNvbnN0IHtcbiAgICB4MSxcbiAgICB5MSxcbiAgICB4MixcbiAgICB5MlxuICB9ID0gYm94LFxuICAgICAgICBkeCA9IHUgLSB4LFxuICAgICAgICBkeSA9IHYgLSB5O1xuICBsZXQgdDAgPSAwLFxuICAgICAgdDEgPSAxLFxuICAgICAgcCxcbiAgICAgIHEsXG4gICAgICByLFxuICAgICAgZTtcblxuICBmb3IgKGUgPSAwOyBlIDwgNDsgKytlKSB7XG4gICAgaWYgKGUgPT09IDApIHtcbiAgICAgIHAgPSAtZHg7XG4gICAgICBxID0gLSh4MSAtIHgpO1xuICAgIH1cblxuICAgIGlmIChlID09PSAxKSB7XG4gICAgICBwID0gZHg7XG4gICAgICBxID0geDIgLSB4O1xuICAgIH1cblxuICAgIGlmIChlID09PSAyKSB7XG4gICAgICBwID0gLWR5O1xuICAgICAgcSA9IC0oeTEgLSB5KTtcbiAgICB9XG5cbiAgICBpZiAoZSA9PT0gMykge1xuICAgICAgcCA9IGR5O1xuICAgICAgcSA9IHkyIC0geTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnMocCkgPCAxZS0xMCAmJiBxIDwgMCkgcmV0dXJuIGZhbHNlO1xuICAgIHIgPSBxIC8gcDtcblxuICAgIGlmIChwIDwgMCkge1xuICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuIGZhbHNlO2Vsc2UgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgIH0gZWxzZSBpZiAocCA+IDApIHtcbiAgICAgIGlmIChyIDwgdDApIHJldHVybiBmYWxzZTtlbHNlIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYmxlbmQgKGNvbnRleHQsIGl0ZW0pIHtcbiAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBpdGVtLmJsZW5kIHx8ICdzb3VyY2Utb3Zlcic7XG59XG5cbmZ1bmN0aW9uIHZhbHVlICh2YWx1ZSwgZGZsdCkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IGRmbHQgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYWRkU3RvcHMoZ3JhZGllbnQsIHN0b3BzKSB7XG4gIGNvbnN0IG4gPSBzdG9wcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcHNbaV0ub2Zmc2V0LCBzdG9wc1tpXS5jb2xvcik7XG4gIH1cblxuICByZXR1cm4gZ3JhZGllbnQ7XG59XG5cbmZ1bmN0aW9uIGdyYWRpZW50IChjb250ZXh0LCBzcGVjLCBib3VuZHMpIHtcbiAgY29uc3QgdyA9IGJvdW5kcy53aWR0aCgpLFxuICAgICAgICBoID0gYm91bmRzLmhlaWdodCgpO1xuICBsZXQgZ3JhZGllbnQ7XG5cbiAgaWYgKHNwZWMuZ3JhZGllbnQgPT09ICdyYWRpYWwnKSB7XG4gICAgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGJvdW5kcy54MSArIHZhbHVlKHNwZWMueDEsIDAuNSkgKiB3LCBib3VuZHMueTEgKyB2YWx1ZShzcGVjLnkxLCAwLjUpICogaCwgTWF0aC5tYXgodywgaCkgKiB2YWx1ZShzcGVjLnIxLCAwKSwgYm91bmRzLngxICsgdmFsdWUoc3BlYy54MiwgMC41KSAqIHcsIGJvdW5kcy55MSArIHZhbHVlKHNwZWMueTIsIDAuNSkgKiBoLCBNYXRoLm1heCh3LCBoKSAqIHZhbHVlKHNwZWMucjIsIDAuNSkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGxpbmVhciBncmFkaWVudFxuICAgIGNvbnN0IHgxID0gdmFsdWUoc3BlYy54MSwgMCksXG4gICAgICAgICAgeTEgPSB2YWx1ZShzcGVjLnkxLCAwKSxcbiAgICAgICAgICB4MiA9IHZhbHVlKHNwZWMueDIsIDEpLFxuICAgICAgICAgIHkyID0gdmFsdWUoc3BlYy55MiwgMCk7XG5cbiAgICBpZiAoeDEgPT09IHgyIHx8IHkxID09PSB5MiB8fCB3ID09PSBoKSB7XG4gICAgICAvLyBheGlzIGFsaWduZWQ6IHVzZSBub3JtYWwgZ3JhZGllbnRcbiAgICAgIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChib3VuZHMueDEgKyB4MSAqIHcsIGJvdW5kcy55MSArIHkxICogaCwgYm91bmRzLngxICsgeDIgKiB3LCBib3VuZHMueTEgKyB5MiAqIGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3QgYXhpcyBhbGlnbmVkOiByZW5kZXIgZ3JhZGllbnQgaW50byBhIHBhdHRlcm4gKCMyMzY1KVxuICAgICAgLy8gdGhpcyBhbGxvd3MgdXMgdG8gdXNlIG5vcm1hbGl6ZWQgYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzXG4gICAgICBjb25zdCBpbWFnZSA9IGNhbnZhcyhNYXRoLmNlaWwodyksIE1hdGguY2VpbChoKSksXG4gICAgICAgICAgICBpY3R4ID0gaW1hZ2UuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGljdHguc2NhbGUodywgaCk7XG4gICAgICBpY3R4LmZpbGxTdHlsZSA9IGFkZFN0b3BzKGljdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpLCBzcGVjLnN0b3BzKTtcbiAgICAgIGljdHguZmlsbFJlY3QoMCwgMCwgdywgaCk7XG4gICAgICByZXR1cm4gY29udGV4dC5jcmVhdGVQYXR0ZXJuKGltYWdlLCAnbm8tcmVwZWF0Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFkZFN0b3BzKGdyYWRpZW50LCBzcGVjLnN0b3BzKTtcbn1cblxuZnVuY3Rpb24gY29sb3IgKGNvbnRleHQsIGl0ZW0sIHZhbHVlKSB7XG4gIHJldHVybiBpc0dyYWRpZW50KHZhbHVlKSA/IGdyYWRpZW50KGNvbnRleHQsIHZhbHVlLCBpdGVtLmJvdW5kcykgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZmlsbCAoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkge1xuICBvcGFjaXR5ICo9IGl0ZW0uZmlsbE9wYWNpdHkgPT0gbnVsbCA/IDEgOiBpdGVtLmZpbGxPcGFjaXR5O1xuXG4gIGlmIChvcGFjaXR5ID4gMCkge1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IoY29udGV4dCwgaXRlbSwgaXRlbS5maWxsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIEVtcHR5ID0gW107XG5mdW5jdGlvbiBzdHJva2UgKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpIHtcbiAgdmFyIGx3ID0gKGx3ID0gaXRlbS5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogMTtcbiAgaWYgKGx3IDw9IDApIHJldHVybiBmYWxzZTtcbiAgb3BhY2l0eSAqPSBpdGVtLnN0cm9rZU9wYWNpdHkgPT0gbnVsbCA/IDEgOiBpdGVtLnN0cm9rZU9wYWNpdHk7XG5cbiAgaWYgKG9wYWNpdHkgPiAwKSB7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yKGNvbnRleHQsIGl0ZW0sIGl0ZW0uc3Ryb2tlKTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGx3O1xuICAgIGNvbnRleHQubGluZUNhcCA9IGl0ZW0uc3Ryb2tlQ2FwIHx8ICdidXR0JztcbiAgICBjb250ZXh0LmxpbmVKb2luID0gaXRlbS5zdHJva2VKb2luIHx8ICdtaXRlcic7XG4gICAgY29udGV4dC5taXRlckxpbWl0ID0gaXRlbS5zdHJva2VNaXRlckxpbWl0IHx8IDEwO1xuXG4gICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgIGNvbnRleHQuc2V0TGluZURhc2goaXRlbS5zdHJva2VEYXNoIHx8IEVtcHR5KTtcbiAgICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBpdGVtLnN0cm9rZURhc2hPZmZzZXQgfHwgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhLnppbmRleCAtIGIuemluZGV4IHx8IGEuaW5kZXggLSBiLmluZGV4O1xufVxuXG5mdW5jdGlvbiB6b3JkZXIoc2NlbmUpIHtcbiAgaWYgKCFzY2VuZS56ZGlydHkpIHJldHVybiBzY2VuZS56aXRlbXM7XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgb3V0cHV0ID0gW10sXG4gICAgICBpdGVtLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgZm9yIChpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBpdGVtLmluZGV4ID0gaTtcbiAgICBpZiAoaXRlbS56aW5kZXgpIG91dHB1dC5wdXNoKGl0ZW0pO1xuICB9XG5cbiAgc2NlbmUuemRpcnR5ID0gZmFsc2U7XG4gIHJldHVybiBzY2VuZS56aXRlbXMgPSBvdXRwdXQuc29ydChjb21wYXJlKTtcbn1cbmZ1bmN0aW9uIHZpc2l0KHNjZW5lLCB2aXNpdG9yKSB7XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgaSxcbiAgICAgIG47XG4gIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICBjb25zdCB6aXRlbXMgPSB6b3JkZXIoc2NlbmUpO1xuXG4gIGlmICh6aXRlbXMgJiYgeml0ZW1zLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICghaXRlbXNbaV0uemluZGV4KSB2aXNpdG9yKGl0ZW1zW2ldKTtcbiAgICB9XG5cbiAgICBpdGVtcyA9IHppdGVtcztcbiAgfVxuXG4gIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB2aXNpdG9yKGl0ZW1zW2ldKTtcbiAgfVxufVxuZnVuY3Rpb24gcGlja1Zpc2l0KHNjZW5lLCB2aXNpdG9yKSB7XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgaGl0LFxuICAgICAgaTtcbiAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgY29uc3Qgeml0ZW1zID0gem9yZGVyKHNjZW5lKTtcbiAgaWYgKHppdGVtcyAmJiB6aXRlbXMubGVuZ3RoKSBpdGVtcyA9IHppdGVtcztcblxuICBmb3IgKGkgPSBpdGVtcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgIGlmIChoaXQgPSB2aXNpdG9yKGl0ZW1zW2ldKSkgcmV0dXJuIGhpdDtcbiAgfVxuXG4gIGlmIChpdGVtcyA9PT0geml0ZW1zKSB7XG4gICAgZm9yIChpdGVtcyA9IHNjZW5lLml0ZW1zLCBpID0gaXRlbXMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgIGlmICghaXRlbXNbaV0uemluZGV4KSB7XG4gICAgICAgIGlmIChoaXQgPSB2aXNpdG9yKGl0ZW1zW2ldKSkgcmV0dXJuIGhpdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZHJhd0FsbChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgc2NlbmUsIGJvdW5kcykge1xuICAgIHZpc2l0KHNjZW5lLCBpdGVtID0+IHtcbiAgICAgIGlmICghYm91bmRzIHx8IGJvdW5kcy5pbnRlcnNlY3RzKGl0ZW0uYm91bmRzKSkge1xuICAgICAgICBkcmF3UGF0aChwYXRoLCBjb250ZXh0LCBpdGVtLCBpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRyYXdPbmUocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBpZiAoc2NlbmUuaXRlbXMubGVuZ3RoICYmICghYm91bmRzIHx8IGJvdW5kcy5pbnRlcnNlY3RzKHNjZW5lLmJvdW5kcykpKSB7XG4gICAgICBkcmF3UGF0aChwYXRoLCBjb250ZXh0LCBzY2VuZS5pdGVtc1swXSwgc2NlbmUuaXRlbXMpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZHJhd1BhdGgocGF0aCwgY29udGV4dCwgaXRlbSwgaXRlbXMpIHtcbiAgdmFyIG9wYWNpdHkgPSBpdGVtLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBpdGVtLm9wYWNpdHk7XG4gIGlmIChvcGFjaXR5ID09PSAwKSByZXR1cm47XG4gIGlmIChwYXRoKGNvbnRleHQsIGl0ZW1zKSkgcmV0dXJuO1xuICBibGVuZChjb250ZXh0LCBpdGVtKTtcblxuICBpZiAoaXRlbS5maWxsICYmIGZpbGwoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkpIHtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuXG4gIGlmIChpdGVtLnN0cm9rZSAmJiBzdHJva2UoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkpIHtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBpY2skMSh0ZXN0KSB7XG4gIHRlc3QgPSB0ZXN0IHx8IHRydXRoeTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gICAgeCAqPSBjb250ZXh0LnBpeGVsUmF0aW87XG4gICAgeSAqPSBjb250ZXh0LnBpeGVsUmF0aW87XG4gICAgcmV0dXJuIHBpY2tWaXNpdChzY2VuZSwgaXRlbSA9PiB7XG4gICAgICBjb25zdCBiID0gaXRlbS5ib3VuZHM7IC8vIGZpcnN0IGhpdCB0ZXN0IGFnYWluc3QgYm91bmRpbmcgYm94XG5cbiAgICAgIGlmIChiICYmICFiLmNvbnRhaW5zKGd4LCBneSkgfHwgIWIpIHJldHVybjsgLy8gaWYgaW4gYm91bmRpbmcgYm94LCBwZXJmb3JtIG1vcmUgY2FyZWZ1bCB0ZXN0XG5cbiAgICAgIGlmICh0ZXN0KGNvbnRleHQsIGl0ZW0sIHgsIHksIGd4LCBneSkpIHJldHVybiBpdGVtO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gaGl0UGF0aChwYXRoLCBmaWxsZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBvLCB4LCB5KSB7XG4gICAgdmFyIGl0ZW0gPSBBcnJheS5pc0FycmF5KG8pID8gb1swXSA6IG8sXG4gICAgICAgIGZpbGwgPSBmaWxsZWQgPT0gbnVsbCA/IGl0ZW0uZmlsbCA6IGZpbGxlZCxcbiAgICAgICAgc3Ryb2tlID0gaXRlbS5zdHJva2UgJiYgY29udGV4dC5pc1BvaW50SW5TdHJva2UsXG4gICAgICAgIGx3LFxuICAgICAgICBsYztcblxuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGx3ID0gaXRlbS5zdHJva2VXaWR0aDtcbiAgICAgIGxjID0gaXRlbS5zdHJva2VDYXA7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGx3ICE9IG51bGwgPyBsdyA6IDE7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSBsYyAhPSBudWxsID8gbGMgOiAnYnV0dCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGgoY29udGV4dCwgbykgPyBmYWxzZSA6IGZpbGwgJiYgY29udGV4dC5pc1BvaW50SW5QYXRoKHgsIHkpIHx8IHN0cm9rZSAmJiBjb250ZXh0LmlzUG9pbnRJblN0cm9rZSh4LCB5KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHBpY2tQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBpY2skMShoaXRQYXRoKHBhdGgpKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlKHgsIHkpIHtcbiAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHggKyAnLCcgKyB5ICsgJyknO1xufVxuZnVuY3Rpb24gcm90YXRlKGEpIHtcbiAgcmV0dXJuICdyb3RhdGUoJyArIGEgKyAnKSc7XG59XG5mdW5jdGlvbiBzY2FsZShzY2FsZVgsIHNjYWxlWSkge1xuICByZXR1cm4gJ3NjYWxlKCcgKyBzY2FsZVggKyAnLCcgKyBzY2FsZVkgKyAnKSc7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVJdGVtKGl0ZW0pIHtcbiAgcmV0dXJuIHRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xufVxuZnVuY3Rpb24gcm90YXRlSXRlbShpdGVtKSB7XG4gIHJldHVybiB0cmFuc2xhdGUoaXRlbS54IHx8IDAsIGl0ZW0ueSB8fCAwKSArIChpdGVtLmFuZ2xlID8gJyAnICsgcm90YXRlKGl0ZW0uYW5nbGUpIDogJycpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtSXRlbShpdGVtKSB7XG4gIHJldHVybiB0cmFuc2xhdGUoaXRlbS54IHx8IDAsIGl0ZW0ueSB8fCAwKSArIChpdGVtLmFuZ2xlID8gJyAnICsgcm90YXRlKGl0ZW0uYW5nbGUpIDogJycpICsgKGl0ZW0uc2NhbGVYIHx8IGl0ZW0uc2NhbGVZID8gJyAnICsgc2NhbGUoaXRlbS5zY2FsZVggfHwgMSwgaXRlbS5zY2FsZVkgfHwgMSkgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIG1hcmtJdGVtUGF0aCAodHlwZSwgc2hhcGUsIGlzZWN0KSB7XG4gIGZ1bmN0aW9uIGF0dHIoZW1pdCwgaXRlbSkge1xuICAgIGVtaXQoJ3RyYW5zZm9ybScsIHJvdGF0ZUl0ZW0oaXRlbSkpO1xuICAgIGVtaXQoJ2QnLCBzaGFwZShudWxsLCBpdGVtKSk7XG4gIH1cblxuICBmdW5jdGlvbiBib3VuZChib3VuZHMsIGl0ZW0pIHtcbiAgICBzaGFwZShib3VuZENvbnRleHQoYm91bmRzLCBpdGVtLmFuZ2xlKSwgaXRlbSk7XG4gICAgcmV0dXJuIGJvdW5kU3Ryb2tlKGJvdW5kcywgaXRlbSkudHJhbnNsYXRlKGl0ZW0ueCB8fCAwLCBpdGVtLnkgfHwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGl0ZW0pIHtcbiAgICB2YXIgeCA9IGl0ZW0ueCB8fCAwLFxuICAgICAgICB5ID0gaXRlbS55IHx8IDAsXG4gICAgICAgIGEgPSBpdGVtLmFuZ2xlIHx8IDA7XG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgaWYgKGEpIGNvbnRleHQucm90YXRlKGEgKj0gRGVnVG9SYWQpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgc2hhcGUoY29udGV4dCwgaXRlbSk7XG4gICAgaWYgKGEpIGNvbnRleHQucm90YXRlKC1hKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRhZzogJ3BhdGgnLFxuICAgIG5lc3RlZDogZmFsc2UsXG4gICAgYXR0cjogYXR0cixcbiAgICBib3VuZDogYm91bmQsXG4gICAgZHJhdzogZHJhd0FsbChkcmF3KSxcbiAgICBwaWNrOiBwaWNrUGF0aChkcmF3KSxcbiAgICBpc2VjdDogaXNlY3QgfHwgaW50ZXJzZWN0UGF0aChkcmF3KVxuICB9O1xufVxuXG52YXIgYXJjID0gbWFya0l0ZW1QYXRoKCdhcmMnLCBhcmMkMSk7XG5cbmZ1bmN0aW9uIHBpY2tBcmVhKGEsIHApIHtcbiAgdmFyIHYgPSBhWzBdLm9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gcFsxXSA6IHBbMF0sXG4gICAgICB6ID0gYVswXS5vcmllbnQgPT09ICdob3Jpem9udGFsJyA/ICd5JyA6ICd4JyxcbiAgICAgIGkgPSBhLmxlbmd0aCxcbiAgICAgIG1pbiA9ICtJbmZpbml0eSxcbiAgICAgIGhpdCxcbiAgICAgIGQ7XG5cbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaWYgKGFbaV0uZGVmaW5lZCA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgIGQgPSBNYXRoLmFicyhhW2ldW3pdIC0gdik7XG5cbiAgICBpZiAoZCA8IG1pbikge1xuICAgICAgbWluID0gZDtcbiAgICAgIGhpdCA9IGFbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpdDtcbn1cbmZ1bmN0aW9uIHBpY2tMaW5lKGEsIHApIHtcbiAgdmFyIHQgPSBNYXRoLnBvdyhhWzBdLnN0cm9rZVdpZHRoIHx8IDEsIDIpLFxuICAgICAgaSA9IGEubGVuZ3RoLFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIGRkO1xuXG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChhW2ldLmRlZmluZWQgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICBkeCA9IGFbaV0ueCAtIHBbMF07XG4gICAgZHkgPSBhW2ldLnkgLSBwWzFdO1xuICAgIGRkID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgaWYgKGRkIDwgdCkgcmV0dXJuIGFbaV07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBpY2tUcmFpbChhLCBwKSB7XG4gIHZhciBpID0gYS5sZW5ndGgsXG4gICAgICBkeCxcbiAgICAgIGR5LFxuICAgICAgZGQ7XG5cbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaWYgKGFbaV0uZGVmaW5lZCA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgIGR4ID0gYVtpXS54IC0gcFswXTtcbiAgICBkeSA9IGFbaV0ueSAtIHBbMV07XG4gICAgZGQgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBkeCA9IGFbaV0uc2l6ZSB8fCAxO1xuICAgIGlmIChkZCA8IGR4ICogZHgpIHJldHVybiBhW2ldO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG1hcmtNdWx0aUl0ZW1QYXRoICh0eXBlLCBzaGFwZSwgdGlwKSB7XG4gIGZ1bmN0aW9uIGF0dHIoZW1pdCwgaXRlbSkge1xuICAgIHZhciBpdGVtcyA9IGl0ZW0ubWFyay5pdGVtcztcbiAgICBpZiAoaXRlbXMubGVuZ3RoKSBlbWl0KCdkJywgc2hhcGUobnVsbCwgaXRlbXMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJvdW5kKGJvdW5kcywgbWFyaykge1xuICAgIHZhciBpdGVtcyA9IG1hcmsuaXRlbXM7XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYm91bmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZShib3VuZENvbnRleHQoYm91bmRzKSwgaXRlbXMpO1xuICAgICAgcmV0dXJuIGJvdW5kU3Ryb2tlKGJvdW5kcywgaXRlbXNbMF0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgaXRlbXMpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIHNoYXBlKGNvbnRleHQsIGl0ZW1zKTtcbiAgfVxuXG4gIGNvbnN0IGhpdCA9IGhpdFBhdGgoZHJhdyk7XG5cbiAgZnVuY3Rpb24gcGljayhjb250ZXh0LCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gICAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICAgIGIgPSBzY2VuZS5ib3VuZHM7XG5cbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGggfHwgYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB4ICo9IGNvbnRleHQucGl4ZWxSYXRpbztcbiAgICB5ICo9IGNvbnRleHQucGl4ZWxSYXRpbztcbiAgICByZXR1cm4gaGl0KGNvbnRleHQsIGl0ZW1zLCB4LCB5KSA/IGl0ZW1zWzBdIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0YWc6ICdwYXRoJyxcbiAgICBuZXN0ZWQ6IHRydWUsXG4gICAgYXR0cjogYXR0cixcbiAgICBib3VuZDogYm91bmQsXG4gICAgZHJhdzogZHJhd09uZShkcmF3KSxcbiAgICBwaWNrOiBwaWNrLFxuICAgIGlzZWN0OiBpbnRlcnNlY3RQb2ludCxcbiAgICB0aXA6IHRpcFxuICB9O1xufVxuXG52YXIgYXJlYSA9IG1hcmtNdWx0aUl0ZW1QYXRoKCdhcmVhJywgYXJlYSQxLCBwaWNrQXJlYSk7XG5cbmZ1bmN0aW9uIGNsaXAgKGNvbnRleHQsIHNjZW5lKSB7XG4gIHZhciBjbGlwID0gc2NlbmUuY2xpcDtcbiAgY29udGV4dC5zYXZlKCk7XG5cbiAgaWYgKGlzRnVuY3Rpb24oY2xpcCkpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNsaXAoY29udGV4dCk7XG4gICAgY29udGV4dC5jbGlwKCk7XG4gIH0gZWxzZSB7XG4gICAgY2xpcEdyb3VwKGNvbnRleHQsIHNjZW5lLmdyb3VwKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xpcEdyb3VwKGNvbnRleHQsIGdyb3VwKSB7XG4gIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGhhc0Nvcm5lclJhZGl1cyhncm91cCkgPyByZWN0YW5nbGUoY29udGV4dCwgZ3JvdXAsIDAsIDApIDogY29udGV4dC5yZWN0KDAsIDAsIGdyb3VwLndpZHRoIHx8IDAsIGdyb3VwLmhlaWdodCB8fCAwKTtcbiAgY29udGV4dC5jbGlwKCk7XG59XG5cbmZ1bmN0aW9uIG9mZnNldCQxKGl0ZW0pIHtcbiAgY29uc3Qgc3cgPSB2YWx1ZShpdGVtLnN0cm9rZVdpZHRoLCAxKTtcbiAgcmV0dXJuIGl0ZW0uc3Ryb2tlT2Zmc2V0ICE9IG51bGwgPyBpdGVtLnN0cm9rZU9mZnNldCA6IGl0ZW0uc3Ryb2tlICYmIHN3ID4gMC41ICYmIHN3IDwgMS41ID8gMC41IC0gTWF0aC5hYnMoc3cgLSAxKSA6IDA7XG59XG5cbmZ1bmN0aW9uIGF0dHIkNShlbWl0LCBpdGVtKSB7XG4gIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZUl0ZW0oaXRlbSkpO1xufVxuXG5mdW5jdGlvbiBlbWl0UmVjdGFuZ2xlKGVtaXQsIGl0ZW0pIHtcbiAgY29uc3Qgb2ZmID0gb2Zmc2V0JDEoaXRlbSk7XG4gIGVtaXQoJ2QnLCByZWN0YW5nbGUobnVsbCwgaXRlbSwgb2ZmLCBvZmYpKTtcbn1cblxuZnVuY3Rpb24gYmFja2dyb3VuZChlbWl0LCBpdGVtKSB7XG4gIGVtaXQoJ2NsYXNzJywgJ2JhY2tncm91bmQnKTtcbiAgZW1pdCgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgZW1pdFJlY3RhbmdsZShlbWl0LCBpdGVtKTtcbn1cblxuZnVuY3Rpb24gZm9yZWdyb3VuZChlbWl0LCBpdGVtKSB7XG4gIGVtaXQoJ2NsYXNzJywgJ2ZvcmVncm91bmQnKTtcbiAgZW1pdCgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcblxuICBpZiAoaXRlbS5zdHJva2VGb3JlZ3JvdW5kKSB7XG4gICAgZW1pdFJlY3RhbmdsZShlbWl0LCBpdGVtKTtcbiAgfSBlbHNlIHtcbiAgICBlbWl0KCdkJywgJycpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnRlbnQoZW1pdCwgaXRlbSwgcmVuZGVyZXIpIHtcbiAgY29uc3QgdXJsID0gaXRlbS5jbGlwID8gY2xpcCQxKHJlbmRlcmVyLCBpdGVtLCBpdGVtKSA6IG51bGw7XG4gIGVtaXQoJ2NsaXAtcGF0aCcsIHVybCk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kJDUoYm91bmRzLCBncm91cCkge1xuICBpZiAoIWdyb3VwLmNsaXAgJiYgZ3JvdXAuaXRlbXMpIHtcbiAgICBjb25zdCBpdGVtcyA9IGdyb3VwLml0ZW1zLFxuICAgICAgICAgIG0gPSBpdGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgYm91bmRzLnVuaW9uKGl0ZW1zW2pdLmJvdW5kcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKChncm91cC5jbGlwIHx8IGdyb3VwLndpZHRoIHx8IGdyb3VwLmhlaWdodCkgJiYgIWdyb3VwLm5vQm91bmQpIHtcbiAgICBib3VuZHMuYWRkKDAsIDApLmFkZChncm91cC53aWR0aCB8fCAwLCBncm91cC5oZWlnaHQgfHwgMCk7XG4gIH1cblxuICBib3VuZFN0cm9rZShib3VuZHMsIGdyb3VwKTtcbiAgcmV0dXJuIGJvdW5kcy50cmFuc2xhdGUoZ3JvdXAueCB8fCAwLCBncm91cC55IHx8IDApO1xufVxuXG5mdW5jdGlvbiByZWN0YW5nbGVQYXRoKGNvbnRleHQsIGdyb3VwLCB4LCB5KSB7XG4gIGNvbnN0IG9mZiA9IG9mZnNldCQxKGdyb3VwKTtcbiAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcmVjdGFuZ2xlKGNvbnRleHQsIGdyb3VwLCAoeCB8fCAwKSArIG9mZiwgKHkgfHwgMCkgKyBvZmYpO1xufVxuXG5jb25zdCBoaXRCYWNrZ3JvdW5kID0gaGl0UGF0aChyZWN0YW5nbGVQYXRoKTtcbmNvbnN0IGhpdEZvcmVncm91bmQgPSBoaXRQYXRoKHJlY3RhbmdsZVBhdGgsIGZhbHNlKTtcbmNvbnN0IGhpdENvcm5lciA9IGhpdFBhdGgocmVjdGFuZ2xlUGF0aCwgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGRyYXckNChjb250ZXh0LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZpc2l0KHNjZW5lLCBncm91cCA9PiB7XG4gICAgY29uc3QgZ3ggPSBncm91cC54IHx8IDAsXG4gICAgICAgICAgZ3kgPSBncm91cC55IHx8IDAsXG4gICAgICAgICAgZm9yZSA9IGdyb3VwLnN0cm9rZUZvcmVncm91bmQsXG4gICAgICAgICAgb3BhY2l0eSA9IGdyb3VwLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBncm91cC5vcGFjaXR5OyAvLyBkcmF3IGdyb3VwIGJhY2tncm91bmRcblxuICAgIGlmICgoZ3JvdXAuc3Ryb2tlIHx8IGdyb3VwLmZpbGwpICYmIG9wYWNpdHkpIHtcbiAgICAgIHJlY3RhbmdsZVBhdGgoY29udGV4dCwgZ3JvdXAsIGd4LCBneSk7XG4gICAgICBibGVuZChjb250ZXh0LCBncm91cCk7XG5cbiAgICAgIGlmIChncm91cC5maWxsICYmIGZpbGwoY29udGV4dCwgZ3JvdXAsIG9wYWNpdHkpKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAuc3Ryb2tlICYmICFmb3JlICYmIHN0cm9rZShjb250ZXh0LCBncm91cCwgb3BhY2l0eSkpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9IC8vIHNldHVwIGdyYXBoaWNzIGNvbnRleHQsIHNldCBjbGlwIGFuZCBib3VuZHNcblxuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBpZiAoZ3JvdXAuY2xpcCkgY2xpcEdyb3VwKGNvbnRleHQsIGdyb3VwKTtcbiAgICBpZiAoYm91bmRzKSBib3VuZHMudHJhbnNsYXRlKC1neCwgLWd5KTsgLy8gZHJhdyBncm91cCBjb250ZW50c1xuXG4gICAgdmlzaXQoZ3JvdXAsIGl0ZW0gPT4ge1xuICAgICAgdGhpcy5kcmF3KGNvbnRleHQsIGl0ZW0sIGJvdW5kcyk7XG4gICAgfSk7IC8vIHJlc3RvcmUgZ3JhcGhpY3MgY29udGV4dFxuXG4gICAgaWYgKGJvdW5kcykgYm91bmRzLnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGNvbnRleHQucmVzdG9yZSgpOyAvLyBkcmF3IGdyb3VwIGZvcmVncm91bmRcblxuICAgIGlmIChmb3JlICYmIGdyb3VwLnN0cm9rZSAmJiBvcGFjaXR5KSB7XG4gICAgICByZWN0YW5nbGVQYXRoKGNvbnRleHQsIGdyb3VwLCBneCwgZ3kpO1xuICAgICAgYmxlbmQoY29udGV4dCwgZ3JvdXApO1xuXG4gICAgICBpZiAoc3Ryb2tlKGNvbnRleHQsIGdyb3VwLCBvcGFjaXR5KSkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBpY2soY29udGV4dCwgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoc2NlbmUuYm91bmRzICYmICFzY2VuZS5ib3VuZHMuY29udGFpbnMoZ3gsIGd5KSB8fCAhc2NlbmUuaXRlbXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGN4ID0geCAqIGNvbnRleHQucGl4ZWxSYXRpbyxcbiAgICAgICAgY3kgPSB5ICogY29udGV4dC5waXhlbFJhdGlvO1xuICByZXR1cm4gcGlja1Zpc2l0KHNjZW5lLCBncm91cCA9PiB7XG4gICAgbGV0IGhpdCwgZHgsIGR5OyAvLyBmaXJzdCBoaXQgdGVzdCBib3VuZGluZyBib3hcblxuICAgIGNvbnN0IGIgPSBncm91cC5ib3VuZHM7XG4gICAgaWYgKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgcmV0dXJuOyAvLyBwYXNzZWQgYm91bmRzIGNoZWNrLCB0ZXN0IHJlY3Rhbmd1bGFyIGNsaXBcblxuICAgIGR4ID0gZ3JvdXAueCB8fCAwO1xuICAgIGR5ID0gZ3JvdXAueSB8fCAwO1xuICAgIGNvbnN0IGR3ID0gZHggKyAoZ3JvdXAud2lkdGggfHwgMCksXG4gICAgICAgICAgZGggPSBkeSArIChncm91cC5oZWlnaHQgfHwgMCksXG4gICAgICAgICAgYyA9IGdyb3VwLmNsaXA7XG4gICAgaWYgKGMgJiYgKGd4IDwgZHggfHwgZ3ggPiBkdyB8fCBneSA8IGR5IHx8IGd5ID4gZGgpKSByZXR1cm47IC8vIGFkanVzdCBjb29yZGluYXRlIHN5c3RlbVxuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoZHgsIGR5KTtcbiAgICBkeCA9IGd4IC0gZHg7XG4gICAgZHkgPSBneSAtIGR5OyAvLyB0ZXN0IGJhY2tncm91bmQgZm9yIHJvdW5kZWQgY29ybmVyIGNsaXBcblxuICAgIGlmIChjICYmIGhhc0Nvcm5lclJhZGl1cyhncm91cCkgJiYgIWhpdENvcm5lcihjb250ZXh0LCBncm91cCwgY3gsIGN5KSkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JlID0gZ3JvdXAuc3Ryb2tlRm9yZWdyb3VuZCxcbiAgICAgICAgICBpeCA9IHNjZW5lLmludGVyYWN0aXZlICE9PSBmYWxzZTsgLy8gaGl0IHRlc3QgYWdhaW5zdCBncm91cCBmb3JlZ3JvdW5kXG5cbiAgICBpZiAoaXggJiYgZm9yZSAmJiBncm91cC5zdHJva2UgJiYgaGl0Rm9yZWdyb3VuZChjb250ZXh0LCBncm91cCwgY3gsIGN5KSkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSAvLyBoaXQgdGVzdCBhZ2FpbnN0IGNvbnRhaW5lZCBtYXJrc1xuXG5cbiAgICBoaXQgPSBwaWNrVmlzaXQoZ3JvdXAsIG1hcmsgPT4gcGlja01hcmsobWFyaywgZHgsIGR5KSA/IHRoaXMucGljayhtYXJrLCB4LCB5LCBkeCwgZHkpIDogbnVsbCk7IC8vIGhpdCB0ZXN0IGFnYWluc3QgZ3JvdXAgYmFja2dyb3VuZFxuXG4gICAgaWYgKCFoaXQgJiYgaXggJiYgKGdyb3VwLmZpbGwgfHwgIWZvcmUgJiYgZ3JvdXAuc3Ryb2tlKSAmJiBoaXRCYWNrZ3JvdW5kKGNvbnRleHQsIGdyb3VwLCBjeCwgY3kpKSB7XG4gICAgICBoaXQgPSBncm91cDtcbiAgICB9IC8vIHJlc3RvcmUgc3RhdGUgYW5kIHJldHVyblxuXG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICByZXR1cm4gaGl0IHx8IG51bGw7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwaWNrTWFyayhtYXJrLCB4LCB5KSB7XG4gIHJldHVybiAobWFyay5pbnRlcmFjdGl2ZSAhPT0gZmFsc2UgfHwgbWFyay5tYXJrdHlwZSA9PT0gJ2dyb3VwJykgJiYgbWFyay5ib3VuZHMgJiYgbWFyay5ib3VuZHMuY29udGFpbnMoeCwgeSk7XG59XG5cbnZhciBncm91cCA9IHtcbiAgdHlwZTogJ2dyb3VwJyxcbiAgdGFnOiAnZycsXG4gIG5lc3RlZDogZmFsc2UsXG4gIGF0dHI6IGF0dHIkNSxcbiAgYm91bmQ6IGJvdW5kJDUsXG4gIGRyYXc6IGRyYXckNCxcbiAgcGljazogcGljayxcbiAgaXNlY3Q6IGludGVyc2VjdFJlY3QsXG4gIGNvbnRlbnQ6IGNvbnRlbnQsXG4gIGJhY2tncm91bmQ6IGJhY2tncm91bmQsXG4gIGZvcmVncm91bmQ6IGZvcmVncm91bmRcbn07XG5cbnZhciBtZXRhZGF0YSA9IHtcbiAgJ3htbG5zJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgJ3htbG5zOnhsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAndmVyc2lvbic6ICcxLjEnXG59O1xuXG5mdW5jdGlvbiBnZXRJbWFnZShpdGVtLCByZW5kZXJlcikge1xuICB2YXIgaW1hZ2UgPSBpdGVtLmltYWdlO1xuXG4gIGlmICghaW1hZ2UgfHwgaXRlbS51cmwgJiYgaXRlbS51cmwgIT09IGltYWdlLnVybCkge1xuICAgIGltYWdlID0ge1xuICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHJlbmRlcmVyLmxvYWRJbWFnZShpdGVtLnVybCkudGhlbihpbWFnZSA9PiB7XG4gICAgICBpdGVtLmltYWdlID0gaW1hZ2U7XG4gICAgICBpdGVtLmltYWdlLnVybCA9IGl0ZW0udXJsO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGltYWdlO1xufVxuXG5mdW5jdGlvbiBpbWFnZVdpZHRoKGl0ZW0sIGltYWdlKSB7XG4gIHJldHVybiBpdGVtLndpZHRoICE9IG51bGwgPyBpdGVtLndpZHRoIDogIWltYWdlIHx8ICFpbWFnZS53aWR0aCA/IDAgOiBpdGVtLmFzcGVjdCAhPT0gZmFsc2UgJiYgaXRlbS5oZWlnaHQgPyBpdGVtLmhlaWdodCAqIGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0IDogaW1hZ2Uud2lkdGg7XG59XG5cbmZ1bmN0aW9uIGltYWdlSGVpZ2h0KGl0ZW0sIGltYWdlKSB7XG4gIHJldHVybiBpdGVtLmhlaWdodCAhPSBudWxsID8gaXRlbS5oZWlnaHQgOiAhaW1hZ2UgfHwgIWltYWdlLmhlaWdodCA/IDAgOiBpdGVtLmFzcGVjdCAhPT0gZmFsc2UgJiYgaXRlbS53aWR0aCA/IGl0ZW0ud2lkdGggKiBpbWFnZS5oZWlnaHQgLyBpbWFnZS53aWR0aCA6IGltYWdlLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gaW1hZ2VYT2Zmc2V0KGFsaWduLCB3KSB7XG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcicgPyB3IC8gMiA6IGFsaWduID09PSAncmlnaHQnID8gdyA6IDA7XG59XG5cbmZ1bmN0aW9uIGltYWdlWU9mZnNldChiYXNlbGluZSwgaCkge1xuICByZXR1cm4gYmFzZWxpbmUgPT09ICdtaWRkbGUnID8gaCAvIDIgOiBiYXNlbGluZSA9PT0gJ2JvdHRvbScgPyBoIDogMDtcbn1cblxuZnVuY3Rpb24gYXR0ciQ0KGVtaXQsIGl0ZW0sIHJlbmRlcmVyKSB7XG4gIGNvbnN0IGltZyA9IGdldEltYWdlKGl0ZW0sIHJlbmRlcmVyKSxcbiAgICAgICAgdyA9IGltYWdlV2lkdGgoaXRlbSwgaW1nKSxcbiAgICAgICAgaCA9IGltYWdlSGVpZ2h0KGl0ZW0sIGltZyksXG4gICAgICAgIHggPSAoaXRlbS54IHx8IDApIC0gaW1hZ2VYT2Zmc2V0KGl0ZW0uYWxpZ24sIHcpLFxuICAgICAgICB5ID0gKGl0ZW0ueSB8fCAwKSAtIGltYWdlWU9mZnNldChpdGVtLmJhc2VsaW5lLCBoKSxcbiAgICAgICAgaSA9ICFpbWcuc3JjICYmIGltZy50b0RhdGFVUkwgPyBpbWcudG9EYXRhVVJMKCkgOiBpbWcuc3JjIHx8ICcnO1xuICBlbWl0KCdocmVmJywgaSwgbWV0YWRhdGFbJ3htbG5zOnhsaW5rJ10sICd4bGluazpocmVmJyk7XG4gIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZSh4LCB5KSk7XG4gIGVtaXQoJ3dpZHRoJywgdyk7XG4gIGVtaXQoJ2hlaWdodCcsIGgpO1xuICBlbWl0KCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgaXRlbS5hc3BlY3QgPT09IGZhbHNlID8gJ25vbmUnIDogJ3hNaWRZTWlkJyk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kJDQoYm91bmRzLCBpdGVtKSB7XG4gIGNvbnN0IGltZyA9IGl0ZW0uaW1hZ2UsXG4gICAgICAgIHcgPSBpbWFnZVdpZHRoKGl0ZW0sIGltZyksXG4gICAgICAgIGggPSBpbWFnZUhlaWdodChpdGVtLCBpbWcpLFxuICAgICAgICB4ID0gKGl0ZW0ueCB8fCAwKSAtIGltYWdlWE9mZnNldChpdGVtLmFsaWduLCB3KSxcbiAgICAgICAgeSA9IChpdGVtLnkgfHwgMCkgLSBpbWFnZVlPZmZzZXQoaXRlbS5iYXNlbGluZSwgaCk7XG4gIHJldHVybiBib3VuZHMuc2V0KHgsIHksIHggKyB3LCB5ICsgaCk7XG59XG5cbmZ1bmN0aW9uIGRyYXckMyhjb250ZXh0LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZpc2l0KHNjZW5lLCBpdGVtID0+IHtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhpdGVtLmJvdW5kcykpIHJldHVybjsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBjb25zdCBpbWcgPSBnZXRJbWFnZShpdGVtLCB0aGlzKTtcbiAgICBsZXQgdyA9IGltYWdlV2lkdGgoaXRlbSwgaW1nKTtcbiAgICBsZXQgaCA9IGltYWdlSGVpZ2h0KGl0ZW0sIGltZyk7XG4gICAgaWYgKHcgPT09IDAgfHwgaCA9PT0gMCkgcmV0dXJuOyAvLyBlYXJseSBleGl0XG5cbiAgICBsZXQgeCA9IChpdGVtLnggfHwgMCkgLSBpbWFnZVhPZmZzZXQoaXRlbS5hbGlnbiwgdyksXG4gICAgICAgIHkgPSAoaXRlbS55IHx8IDApIC0gaW1hZ2VZT2Zmc2V0KGl0ZW0uYmFzZWxpbmUsIGgpLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBhcjAsXG4gICAgICAgIGFyMSxcbiAgICAgICAgdDtcblxuICAgIGlmIChpdGVtLmFzcGVjdCAhPT0gZmFsc2UpIHtcbiAgICAgIGFyMCA9IGltZy53aWR0aCAvIGltZy5oZWlnaHQ7XG4gICAgICBhcjEgPSBpdGVtLndpZHRoIC8gaXRlbS5oZWlnaHQ7XG5cbiAgICAgIGlmIChhcjAgPT09IGFyMCAmJiBhcjEgPT09IGFyMSAmJiBhcjAgIT09IGFyMSkge1xuICAgICAgICBpZiAoYXIxIDwgYXIwKSB7XG4gICAgICAgICAgdCA9IHcgLyBhcjA7XG4gICAgICAgICAgeSArPSAoaCAtIHQpIC8gMjtcbiAgICAgICAgICBoID0gdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0gaCAqIGFyMDtcbiAgICAgICAgICB4ICs9ICh3IC0gdCkgLyAyO1xuICAgICAgICAgIHcgPSB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGltZy5jb21wbGV0ZSB8fCBpbWcudG9EYXRhVVJMKSB7XG4gICAgICBibGVuZChjb250ZXh0LCBpdGVtKTtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAob3BhY2l0eSA9IGl0ZW0ub3BhY2l0eSkgIT0gbnVsbCA/IG9wYWNpdHkgOiAxO1xuICAgICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpdGVtLnNtb290aCAhPT0gZmFsc2U7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIHgsIHksIHcsIGgpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBpbWFnZSA9IHtcbiAgdHlwZTogJ2ltYWdlJyxcbiAgdGFnOiAnaW1hZ2UnLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBhdHRyOiBhdHRyJDQsXG4gIGJvdW5kOiBib3VuZCQ0LFxuICBkcmF3OiBkcmF3JDMsXG4gIHBpY2s6IHBpY2skMSgpLFxuICBpc2VjdDogdHJ1dGh5LFxuICAvLyBib3VuZHMgY2hlY2sgaXMgc3VmZmljaWVudFxuICBnZXQ6IGdldEltYWdlLFxuICB4T2Zmc2V0OiBpbWFnZVhPZmZzZXQsXG4gIHlPZmZzZXQ6IGltYWdlWU9mZnNldFxufTtcblxudmFyIGxpbmUgPSBtYXJrTXVsdGlJdGVtUGF0aCgnbGluZScsIGxpbmUkMSwgcGlja0xpbmUpO1xuXG5mdW5jdGlvbiBhdHRyJDMoZW1pdCwgaXRlbSkge1xuICB2YXIgc3ggPSBpdGVtLnNjYWxlWCB8fCAxLFxuICAgICAgc3kgPSBpdGVtLnNjYWxlWSB8fCAxO1xuXG4gIGlmIChzeCAhPT0gMSB8fCBzeSAhPT0gMSkge1xuICAgIGVtaXQoJ3ZlY3Rvci1lZmZlY3QnLCAnbm9uLXNjYWxpbmctc3Ryb2tlJyk7XG4gIH1cblxuICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1JdGVtKGl0ZW0pKTtcbiAgZW1pdCgnZCcsIGl0ZW0ucGF0aCk7XG59XG5cbmZ1bmN0aW9uIHBhdGgkMShjb250ZXh0LCBpdGVtKSB7XG4gIHZhciBwYXRoID0gaXRlbS5wYXRoO1xuICBpZiAocGF0aCA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHggPSBpdGVtLnggfHwgMCxcbiAgICAgIHkgPSBpdGVtLnkgfHwgMCxcbiAgICAgIHN4ID0gaXRlbS5zY2FsZVggfHwgMSxcbiAgICAgIHN5ID0gaXRlbS5zY2FsZVkgfHwgMSxcbiAgICAgIGEgPSAoaXRlbS5hbmdsZSB8fCAwKSAqIERlZ1RvUmFkLFxuICAgICAgY2FjaGUgPSBpdGVtLnBhdGhDYWNoZTtcblxuICBpZiAoIWNhY2hlIHx8IGNhY2hlLnBhdGggIT09IHBhdGgpIHtcbiAgICAoaXRlbS5wYXRoQ2FjaGUgPSBjYWNoZSA9IHBhdGhQYXJzZShwYXRoKSkucGF0aCA9IHBhdGg7XG4gIH1cblxuICBpZiAoYSAmJiBjb250ZXh0LnJvdGF0ZSAmJiBjb250ZXh0LnRyYW5zbGF0ZSkge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQucm90YXRlKGEpO1xuICAgIHBhdGhSZW5kZXIoY29udGV4dCwgY2FjaGUsIDAsIDAsIHN4LCBzeSk7XG4gICAgY29udGV4dC5yb3RhdGUoLWEpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aFJlbmRlcihjb250ZXh0LCBjYWNoZSwgeCwgeSwgc3gsIHN5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZCQzKGJvdW5kcywgaXRlbSkge1xuICByZXR1cm4gcGF0aCQxKGJvdW5kQ29udGV4dChib3VuZHMsIGl0ZW0uYW5nbGUpLCBpdGVtKSA/IGJvdW5kcy5zZXQoMCwgMCwgMCwgMCkgOiBib3VuZFN0cm9rZShib3VuZHMsIGl0ZW0sIHRydWUpO1xufVxuXG52YXIgcGF0aCQyID0ge1xuICB0eXBlOiAncGF0aCcsXG4gIHRhZzogJ3BhdGgnLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBhdHRyOiBhdHRyJDMsXG4gIGJvdW5kOiBib3VuZCQzLFxuICBkcmF3OiBkcmF3QWxsKHBhdGgkMSksXG4gIHBpY2s6IHBpY2tQYXRoKHBhdGgkMSksXG4gIGlzZWN0OiBpbnRlcnNlY3RQYXRoKHBhdGgkMSlcbn07XG5cbmZ1bmN0aW9uIGF0dHIkMihlbWl0LCBpdGVtKSB7XG4gIGVtaXQoJ2QnLCByZWN0YW5nbGUobnVsbCwgaXRlbSkpO1xufVxuXG5mdW5jdGlvbiBib3VuZCQyKGJvdW5kcywgaXRlbSkge1xuICB2YXIgeCwgeTtcbiAgcmV0dXJuIGJvdW5kU3Ryb2tlKGJvdW5kcy5zZXQoeCA9IGl0ZW0ueCB8fCAwLCB5ID0gaXRlbS55IHx8IDAsIHggKyBpdGVtLndpZHRoIHx8IDAsIHkgKyBpdGVtLmhlaWdodCB8fCAwKSwgaXRlbSk7XG59XG5cbmZ1bmN0aW9uIGRyYXckMihjb250ZXh0LCBpdGVtKSB7XG4gIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHJlY3RhbmdsZShjb250ZXh0LCBpdGVtKTtcbn1cblxudmFyIHJlY3QgPSB7XG4gIHR5cGU6ICdyZWN0JyxcbiAgdGFnOiAncGF0aCcsXG4gIG5lc3RlZDogZmFsc2UsXG4gIGF0dHI6IGF0dHIkMixcbiAgYm91bmQ6IGJvdW5kJDIsXG4gIGRyYXc6IGRyYXdBbGwoZHJhdyQyKSxcbiAgcGljazogcGlja1BhdGgoZHJhdyQyKSxcbiAgaXNlY3Q6IGludGVyc2VjdFJlY3Rcbn07XG5cbmZ1bmN0aW9uIGF0dHIkMShlbWl0LCBpdGVtKSB7XG4gIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZUl0ZW0oaXRlbSkpO1xuICBlbWl0KCd4MicsIGl0ZW0ueDIgIT0gbnVsbCA/IGl0ZW0ueDIgLSAoaXRlbS54IHx8IDApIDogMCk7XG4gIGVtaXQoJ3kyJywgaXRlbS55MiAhPSBudWxsID8gaXRlbS55MiAtIChpdGVtLnkgfHwgMCkgOiAwKTtcbn1cblxuZnVuY3Rpb24gYm91bmQkMShib3VuZHMsIGl0ZW0pIHtcbiAgdmFyIHgxLCB5MTtcbiAgcmV0dXJuIGJvdW5kU3Ryb2tlKGJvdW5kcy5zZXQoeDEgPSBpdGVtLnggfHwgMCwgeTEgPSBpdGVtLnkgfHwgMCwgaXRlbS54MiAhPSBudWxsID8gaXRlbS54MiA6IHgxLCBpdGVtLnkyICE9IG51bGwgPyBpdGVtLnkyIDogeTEpLCBpdGVtKTtcbn1cblxuZnVuY3Rpb24gcGF0aChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSB7XG4gIHZhciB4MSwgeTEsIHgyLCB5MjtcblxuICBpZiAoaXRlbS5zdHJva2UgJiYgc3Ryb2tlKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgeDEgPSBpdGVtLnggfHwgMDtcbiAgICB5MSA9IGl0ZW0ueSB8fCAwO1xuICAgIHgyID0gaXRlbS54MiAhPSBudWxsID8gaXRlbS54MiA6IHgxO1xuICAgIHkyID0gaXRlbS55MiAhPSBudWxsID8gaXRlbS55MiA6IHkxO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkcmF3JDEoY29udGV4dCwgc2NlbmUsIGJvdW5kcykge1xuICB2aXNpdChzY2VuZSwgaXRlbSA9PiB7XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoaXRlbS5ib3VuZHMpKSByZXR1cm47IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgdmFyIG9wYWNpdHkgPSBpdGVtLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBpdGVtLm9wYWNpdHk7XG5cbiAgICBpZiAob3BhY2l0eSAmJiBwYXRoKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgICBibGVuZChjb250ZXh0LCBpdGVtKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaGl0JDEoY29udGV4dCwgaXRlbSwgeCwgeSkge1xuICBpZiAoIWNvbnRleHQuaXNQb2ludEluU3Ryb2tlKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBwYXRoKGNvbnRleHQsIGl0ZW0sIDEpICYmIGNvbnRleHQuaXNQb2ludEluU3Ryb2tlKHgsIHkpO1xufVxuXG52YXIgcnVsZSA9IHtcbiAgdHlwZTogJ3J1bGUnLFxuICB0YWc6ICdsaW5lJyxcbiAgbmVzdGVkOiBmYWxzZSxcbiAgYXR0cjogYXR0ciQxLFxuICBib3VuZDogYm91bmQkMSxcbiAgZHJhdzogZHJhdyQxLFxuICBwaWNrOiBwaWNrJDEoaGl0JDEpLFxuICBpc2VjdDogaW50ZXJzZWN0UnVsZVxufTtcblxudmFyIHNoYXBlID0gbWFya0l0ZW1QYXRoKCdzaGFwZScsIHNoYXBlJDEpO1xuXG52YXIgc3ltYm9sID0gbWFya0l0ZW1QYXRoKCdzeW1ib2wnLCBzeW1ib2wkMSwgaW50ZXJzZWN0UG9pbnQpO1xuXG5jb25zdCB3aWR0aENhY2hlID0gbHJ1Q2FjaGUoKTtcbnZhciB0ZXh0TWV0cmljcyA9IHtcbiAgaGVpZ2h0OiBmb250U2l6ZSxcbiAgbWVhc3VyZVdpZHRoOiBtZWFzdXJlV2lkdGgsXG4gIGVzdGltYXRlV2lkdGg6IGVzdGltYXRlV2lkdGgsXG4gIHdpZHRoOiBlc3RpbWF0ZVdpZHRoLFxuICBjYW52YXM6IHVzZUNhbnZhc1xufTtcbnVzZUNhbnZhcyh0cnVlKTtcblxuZnVuY3Rpb24gdXNlQ2FudmFzKHVzZSkge1xuICB0ZXh0TWV0cmljcy53aWR0aCA9IHVzZSAmJiBjb250ZXh0ID8gbWVhc3VyZVdpZHRoIDogZXN0aW1hdGVXaWR0aDtcbn0gLy8gbWFrZSBzaW1wbGUgZXN0aW1hdGUgaWYgbm8gY2FudmFzIGlzIGF2YWlsYWJsZVxuXG5cbmZ1bmN0aW9uIGVzdGltYXRlV2lkdGgoaXRlbSwgdGV4dCkge1xuICByZXR1cm4gX2VzdGltYXRlV2lkdGgodGV4dFZhbHVlKGl0ZW0sIHRleHQpLCBmb250U2l6ZShpdGVtKSk7XG59XG5cbmZ1bmN0aW9uIF9lc3RpbWF0ZVdpZHRoKHRleHQsIGN1cnJlbnRGb250SGVpZ2h0KSB7XG4gIHJldHVybiB+figwLjggKiB0ZXh0Lmxlbmd0aCAqIGN1cnJlbnRGb250SGVpZ2h0KTtcbn0gLy8gbWVhc3VyZSB0ZXh0IHdpZHRoIGlmIGNhbnZhcyBpcyBhdmFpbGFibGVcblxuXG5mdW5jdGlvbiBtZWFzdXJlV2lkdGgoaXRlbSwgdGV4dCkge1xuICByZXR1cm4gZm9udFNpemUoaXRlbSkgPD0gMCB8fCAhKHRleHQgPSB0ZXh0VmFsdWUoaXRlbSwgdGV4dCkpID8gMCA6IF9tZWFzdXJlV2lkdGgodGV4dCwgZm9udChpdGVtKSk7XG59XG5cbmZ1bmN0aW9uIF9tZWFzdXJlV2lkdGgodGV4dCwgY3VycmVudEZvbnQpIHtcbiAgY29uc3Qga2V5ID0gYCgke2N1cnJlbnRGb250fSkgJHt0ZXh0fWA7XG4gIGxldCB3aWR0aCA9IHdpZHRoQ2FjaGUuZ2V0KGtleSk7XG5cbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICBjb250ZXh0LmZvbnQgPSBjdXJyZW50Rm9udDtcbiAgICB3aWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgd2lkdGhDYWNoZS5zZXQoa2V5LCB3aWR0aCk7XG4gIH1cblxuICByZXR1cm4gd2lkdGg7XG59XG5cbmZ1bmN0aW9uIGZvbnRTaXplKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0uZm9udFNpemUgIT0gbnVsbCA/ICtpdGVtLmZvbnRTaXplIHx8IDAgOiAxMTtcbn1cbmZ1bmN0aW9uIGxpbmVIZWlnaHQoaXRlbSkge1xuICByZXR1cm4gaXRlbS5saW5lSGVpZ2h0ICE9IG51bGwgPyBpdGVtLmxpbmVIZWlnaHQgOiBmb250U2l6ZShpdGVtKSArIDI7XG59XG5cbmZ1bmN0aW9uIGxpbmVBcnJheShfKSB7XG4gIHJldHVybiBpc0FycmF5KF8pID8gXy5sZW5ndGggPiAxID8gXyA6IF9bMF0gOiBfO1xufVxuXG5mdW5jdGlvbiB0ZXh0TGluZXMoaXRlbSkge1xuICByZXR1cm4gbGluZUFycmF5KGl0ZW0ubGluZUJyZWFrICYmIGl0ZW0udGV4dCAmJiAhaXNBcnJheShpdGVtLnRleHQpID8gaXRlbS50ZXh0LnNwbGl0KGl0ZW0ubGluZUJyZWFrKSA6IGl0ZW0udGV4dCk7XG59XG5mdW5jdGlvbiBtdWx0aUxpbmVPZmZzZXQoaXRlbSkge1xuICBjb25zdCB0bCA9IHRleHRMaW5lcyhpdGVtKTtcbiAgcmV0dXJuIChpc0FycmF5KHRsKSA/IHRsLmxlbmd0aCAtIDEgOiAwKSAqIGxpbmVIZWlnaHQoaXRlbSk7XG59XG5mdW5jdGlvbiB0ZXh0VmFsdWUoaXRlbSwgbGluZSkge1xuICBjb25zdCB0ZXh0ID0gbGluZSA9PSBudWxsID8gJycgOiAobGluZSArICcnKS50cmltKCk7XG4gIHJldHVybiBpdGVtLmxpbWl0ID4gMCAmJiB0ZXh0Lmxlbmd0aCA/IHRydW5jYXRlKGl0ZW0sIHRleHQpIDogdGV4dDtcbn1cblxuZnVuY3Rpb24gd2lkdGhHZXR0ZXIoaXRlbSkge1xuICBpZiAodGV4dE1ldHJpY3Mud2lkdGggPT09IG1lYXN1cmVXaWR0aCkge1xuICAgIC8vIHdlIGFyZSB1c2luZyBjYW52YXNcbiAgICBjb25zdCBjdXJyZW50Rm9udCA9IGZvbnQoaXRlbSk7XG4gICAgcmV0dXJuIHRleHQgPT4gX21lYXN1cmVXaWR0aCh0ZXh0LCBjdXJyZW50Rm9udCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2UgYXJlIHJlbHlpbmcgb24gZXN0aW1hdGVzXG4gICAgY29uc3QgY3VycmVudEZvbnRIZWlnaHQgPSBmb250U2l6ZShpdGVtKTtcbiAgICByZXR1cm4gdGV4dCA9PiBfZXN0aW1hdGVXaWR0aCh0ZXh0LCBjdXJyZW50Rm9udEhlaWdodCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUoaXRlbSwgdGV4dCkge1xuICB2YXIgbGltaXQgPSAraXRlbS5saW1pdCxcbiAgICAgIHdpZHRoID0gd2lkdGhHZXR0ZXIoaXRlbSk7XG4gIGlmICh3aWR0aCh0ZXh0KSA8IGxpbWl0KSByZXR1cm4gdGV4dDtcbiAgdmFyIGVsbGlwc2lzID0gaXRlbS5lbGxpcHNpcyB8fCAnXFx1MjAyNicsXG4gICAgICBydGwgPSBpdGVtLmRpciA9PT0gJ3J0bCcsXG4gICAgICBsbyA9IDAsXG4gICAgICBoaSA9IHRleHQubGVuZ3RoLFxuICAgICAgbWlkO1xuICBsaW1pdCAtPSB3aWR0aChlbGxpcHNpcyk7XG5cbiAgaWYgKHJ0bCkge1xuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgaWYgKHdpZHRoKHRleHQuc2xpY2UobWlkKSkgPiBsaW1pdCkgbG8gPSBtaWQgKyAxO2Vsc2UgaGkgPSBtaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsbGlwc2lzICsgdGV4dC5zbGljZShsbyk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIG1pZCA9IDEgKyAobG8gKyBoaSA+Pj4gMSk7XG4gICAgICBpZiAod2lkdGgodGV4dC5zbGljZSgwLCBtaWQpKSA8IGxpbWl0KSBsbyA9IG1pZDtlbHNlIGhpID0gbWlkIC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dC5zbGljZSgwLCBsbykgKyBlbGxpcHNpcztcbiAgfVxufVxuXG5mdW5jdGlvbiBmb250RmFtaWx5KGl0ZW0sIHF1b3RlKSB7XG4gIHZhciBmb250ID0gaXRlbS5mb250O1xuICByZXR1cm4gKHF1b3RlICYmIGZvbnQgPyBTdHJpbmcoZm9udCkucmVwbGFjZSgvXCIvZywgJ1xcJycpIDogZm9udCkgfHwgJ3NhbnMtc2VyaWYnO1xufVxuZnVuY3Rpb24gZm9udChpdGVtLCBxdW90ZSkge1xuICByZXR1cm4gJycgKyAoaXRlbS5mb250U3R5bGUgPyBpdGVtLmZvbnRTdHlsZSArICcgJyA6ICcnKSArIChpdGVtLmZvbnRWYXJpYW50ID8gaXRlbS5mb250VmFyaWFudCArICcgJyA6ICcnKSArIChpdGVtLmZvbnRXZWlnaHQgPyBpdGVtLmZvbnRXZWlnaHQgKyAnICcgOiAnJykgKyBmb250U2l6ZShpdGVtKSArICdweCAnICsgZm9udEZhbWlseShpdGVtLCBxdW90ZSk7XG59XG5mdW5jdGlvbiBvZmZzZXQoaXRlbSkge1xuICAvLyBwZXJmb3JtIG91ciBvd24gZm9udCBiYXNlbGluZSBjYWxjdWxhdGlvblxuICAvLyB3aHk/IG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBTVkcgMS4xICdhbGlnbm1lbnQtYmFzZWxpbmUnIDooXG4gIC8vIHRoaXMgYWxzbyBlbnN1cmVzIGNvbnNpc3RlbnQgbGF5b3V0IGFjcm9zcyByZW5kZXJlcnNcbiAgdmFyIGJhc2VsaW5lID0gaXRlbS5iYXNlbGluZSxcbiAgICAgIGggPSBmb250U2l6ZShpdGVtKTtcbiAgcmV0dXJuIE1hdGgucm91bmQoYmFzZWxpbmUgPT09ICd0b3AnID8gMC43OSAqIGggOiBiYXNlbGluZSA9PT0gJ21pZGRsZScgPyAwLjMwICogaCA6IGJhc2VsaW5lID09PSAnYm90dG9tJyA/IC0wLjIxICogaCA6IGJhc2VsaW5lID09PSAnbGluZS10b3AnID8gMC4yOSAqIGggKyAwLjUgKiBsaW5lSGVpZ2h0KGl0ZW0pIDogYmFzZWxpbmUgPT09ICdsaW5lLWJvdHRvbScgPyAwLjI5ICogaCAtIDAuNSAqIGxpbmVIZWlnaHQoaXRlbSkgOiAwKTtcbn1cblxuY29uc3QgdGV4dEFsaWduID0ge1xuICAnbGVmdCc6ICdzdGFydCcsXG4gICdjZW50ZXInOiAnbWlkZGxlJyxcbiAgJ3JpZ2h0JzogJ2VuZCdcbn07XG5jb25zdCB0ZW1wQm91bmRzID0gbmV3IEJvdW5kcygpO1xuXG5mdW5jdGlvbiBhbmNob3JQb2ludChpdGVtKSB7XG4gIHZhciB4ID0gaXRlbS54IHx8IDAsXG4gICAgICB5ID0gaXRlbS55IHx8IDAsXG4gICAgICByID0gaXRlbS5yYWRpdXMgfHwgMCxcbiAgICAgIHQ7XG5cbiAgaWYgKHIpIHtcbiAgICB0ID0gKGl0ZW0udGhldGEgfHwgMCkgLSBIYWxmUGk7XG4gICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gIH1cblxuICB0ZW1wQm91bmRzLngxID0geDtcbiAgdGVtcEJvdW5kcy55MSA9IHk7XG4gIHJldHVybiB0ZW1wQm91bmRzO1xufVxuXG5mdW5jdGlvbiBhdHRyKGVtaXQsIGl0ZW0pIHtcbiAgdmFyIGR4ID0gaXRlbS5keCB8fCAwLFxuICAgICAgZHkgPSAoaXRlbS5keSB8fCAwKSArIG9mZnNldChpdGVtKSxcbiAgICAgIHAgPSBhbmNob3JQb2ludChpdGVtKSxcbiAgICAgIHggPSBwLngxLFxuICAgICAgeSA9IHAueTEsXG4gICAgICBhID0gaXRlbS5hbmdsZSB8fCAwLFxuICAgICAgdDtcbiAgZW1pdCgndGV4dC1hbmNob3InLCB0ZXh0QWxpZ25baXRlbS5hbGlnbl0gfHwgJ3N0YXJ0Jyk7XG5cbiAgaWYgKGEpIHtcbiAgICB0ID0gdHJhbnNsYXRlKHgsIHkpICsgJyAnICsgcm90YXRlKGEpO1xuICAgIGlmIChkeCB8fCBkeSkgdCArPSAnICcgKyB0cmFuc2xhdGUoZHgsIGR5KTtcbiAgfSBlbHNlIHtcbiAgICB0ID0gdHJhbnNsYXRlKHggKyBkeCwgeSArIGR5KTtcbiAgfVxuXG4gIGVtaXQoJ3RyYW5zZm9ybScsIHQpO1xufVxuXG5mdW5jdGlvbiBib3VuZChib3VuZHMsIGl0ZW0sIG1vZGUpIHtcbiAgdmFyIGggPSB0ZXh0TWV0cmljcy5oZWlnaHQoaXRlbSksXG4gICAgICBhID0gaXRlbS5hbGlnbixcbiAgICAgIHAgPSBhbmNob3JQb2ludChpdGVtKSxcbiAgICAgIHggPSBwLngxLFxuICAgICAgeSA9IHAueTEsXG4gICAgICBkeCA9IGl0ZW0uZHggfHwgMCxcbiAgICAgIGR5ID0gKGl0ZW0uZHkgfHwgMCkgKyBvZmZzZXQoaXRlbSkgLSBNYXRoLnJvdW5kKDAuOCAqIGgpLFxuICAgICAgLy8gdXNlIDQvNSBvZmZzZXRcbiAgdGwgPSB0ZXh0TGluZXMoaXRlbSksXG4gICAgICB3OyAvLyBnZXQgZGltZW5zaW9uc1xuXG4gIGlmIChpc0FycmF5KHRsKSkge1xuICAgIC8vIG11bHRpLWxpbmUgdGV4dFxuICAgIGggKz0gbGluZUhlaWdodChpdGVtKSAqICh0bC5sZW5ndGggLSAxKTtcbiAgICB3ID0gdGwucmVkdWNlKCh3LCB0KSA9PiBNYXRoLm1heCh3LCB0ZXh0TWV0cmljcy53aWR0aChpdGVtLCB0KSksIDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHNpbmdsZS1saW5lIHRleHRcbiAgICB3ID0gdGV4dE1ldHJpY3Mud2lkdGgoaXRlbSwgdGwpO1xuICB9IC8vIGhvcml6b250YWwgYWxpZ25tZW50XG5cblxuICBpZiAoYSA9PT0gJ2NlbnRlcicpIHtcbiAgICBkeCAtPSB3IC8gMjtcbiAgfSBlbHNlIGlmIChhID09PSAncmlnaHQnKSB7XG4gICAgZHggLT0gdztcbiAgfSBlbHNlIDtcblxuICBib3VuZHMuc2V0KGR4ICs9IHgsIGR5ICs9IHksIGR4ICsgdywgZHkgKyBoKTtcblxuICBpZiAoaXRlbS5hbmdsZSAmJiAhbW9kZSkge1xuICAgIGJvdW5kcy5yb3RhdGUoaXRlbS5hbmdsZSAqIERlZ1RvUmFkLCB4LCB5KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAyKSB7XG4gICAgcmV0dXJuIGJvdW5kcy5yb3RhdGVkUG9pbnRzKGl0ZW0uYW5nbGUgKiBEZWdUb1JhZCwgeCwgeSk7XG4gIH1cblxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNjZW5lLCBib3VuZHMpIHtcbiAgdmlzaXQoc2NlbmUsIGl0ZW0gPT4ge1xuICAgIHZhciBvcGFjaXR5ID0gaXRlbS5vcGFjaXR5ID09IG51bGwgPyAxIDogaXRlbS5vcGFjaXR5LFxuICAgICAgICBwLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBpLFxuICAgICAgICBsaCxcbiAgICAgICAgdGwsXG4gICAgICAgIHN0cjtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhpdGVtLmJvdW5kcykgfHwgLy8gYm91bmRzIGNoZWNrXG4gICAgb3BhY2l0eSA9PT0gMCB8fCBpdGVtLmZvbnRTaXplIDw9IDAgfHwgaXRlbS50ZXh0ID09IG51bGwgfHwgaXRlbS50ZXh0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQoaXRlbSk7XG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSBpdGVtLmFsaWduIHx8ICdsZWZ0JztcbiAgICBwID0gYW5jaG9yUG9pbnQoaXRlbSk7XG4gICAgeCA9IHAueDEsIHkgPSBwLnkxO1xuXG4gICAgaWYgKGl0ZW0uYW5nbGUpIHtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjb250ZXh0LnJvdGF0ZShpdGVtLmFuZ2xlICogRGVnVG9SYWQpO1xuICAgICAgeCA9IHkgPSAwOyAvLyByZXNldCB4LCB5XG4gICAgfVxuXG4gICAgeCArPSBpdGVtLmR4IHx8IDA7XG4gICAgeSArPSAoaXRlbS5keSB8fCAwKSArIG9mZnNldChpdGVtKTtcbiAgICB0bCA9IHRleHRMaW5lcyhpdGVtKTtcbiAgICBibGVuZChjb250ZXh0LCBpdGVtKTtcblxuICAgIGlmIChpc0FycmF5KHRsKSkge1xuICAgICAgbGggPSBsaW5lSGVpZ2h0KGl0ZW0pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgc3RyID0gdGV4dFZhbHVlKGl0ZW0sIHRsW2ldKTtcblxuICAgICAgICBpZiAoaXRlbS5maWxsICYmIGZpbGwoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkpIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHN0ciwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS5zdHJva2UgJiYgc3Ryb2tlKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHN0ciwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB5ICs9IGxoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSB0ZXh0VmFsdWUoaXRlbSwgdGwpO1xuXG4gICAgICBpZiAoaXRlbS5maWxsICYmIGZpbGwoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkpIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChzdHIsIHgsIHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbS5zdHJva2UgJiYgc3Ryb2tlKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChzdHIsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpdGVtLmFuZ2xlKSBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpdChjb250ZXh0LCBpdGVtLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKGl0ZW0uZm9udFNpemUgPD0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWl0ZW0uYW5nbGUpIHJldHVybiB0cnVlOyAvLyBib3VuZHMgc3VmZmljaWVudCBpZiBubyByb3RhdGlvblxuICAvLyBwcm9qZWN0IHBvaW50IGludG8gc3BhY2Ugb2YgdW5yb3RhdGVkIGJvdW5kc1xuXG4gIHZhciBwID0gYW5jaG9yUG9pbnQoaXRlbSksXG4gICAgICBheCA9IHAueDEsXG4gICAgICBheSA9IHAueTEsXG4gICAgICBiID0gYm91bmQodGVtcEJvdW5kcywgaXRlbSwgMSksXG4gICAgICBhID0gLWl0ZW0uYW5nbGUgKiBEZWdUb1JhZCxcbiAgICAgIGNvcyA9IE1hdGguY29zKGEpLFxuICAgICAgc2luID0gTWF0aC5zaW4oYSksXG4gICAgICBweCA9IGNvcyAqIGd4IC0gc2luICogZ3kgKyAoYXggLSBjb3MgKiBheCArIHNpbiAqIGF5KSxcbiAgICAgIHB5ID0gc2luICogZ3ggKyBjb3MgKiBneSArIChheSAtIHNpbiAqIGF4IC0gY29zICogYXkpO1xuICByZXR1cm4gYi5jb250YWlucyhweCwgcHkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RUZXh0KGl0ZW0sIGJveCkge1xuICBjb25zdCBwID0gYm91bmQodGVtcEJvdW5kcywgaXRlbSwgMik7XG4gIHJldHVybiBpbnRlcnNlY3RCb3hMaW5lKGJveCwgcFswXSwgcFsxXSwgcFsyXSwgcFszXSkgfHwgaW50ZXJzZWN0Qm94TGluZShib3gsIHBbMF0sIHBbMV0sIHBbNF0sIHBbNV0pIHx8IGludGVyc2VjdEJveExpbmUoYm94LCBwWzRdLCBwWzVdLCBwWzZdLCBwWzddKSB8fCBpbnRlcnNlY3RCb3hMaW5lKGJveCwgcFsyXSwgcFszXSwgcFs2XSwgcFs3XSk7XG59XG5cbnZhciB0ZXh0ID0ge1xuICB0eXBlOiAndGV4dCcsXG4gIHRhZzogJ3RleHQnLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBhdHRyOiBhdHRyLFxuICBib3VuZDogYm91bmQsXG4gIGRyYXc6IGRyYXcsXG4gIHBpY2s6IHBpY2skMShoaXQpLFxuICBpc2VjdDogaW50ZXJzZWN0VGV4dFxufTtcblxudmFyIHRyYWlsID0gbWFya011bHRpSXRlbVBhdGgoJ3RyYWlsJywgdHJhaWwkMSwgcGlja1RyYWlsKTtcblxudmFyIE1hcmtzID0ge1xuICBhcmM6IGFyYyxcbiAgYXJlYTogYXJlYSxcbiAgZ3JvdXA6IGdyb3VwLFxuICBpbWFnZTogaW1hZ2UsXG4gIGxpbmU6IGxpbmUsXG4gIHBhdGg6IHBhdGgkMixcbiAgcmVjdDogcmVjdCxcbiAgcnVsZTogcnVsZSxcbiAgc2hhcGU6IHNoYXBlLFxuICBzeW1ib2w6IHN5bWJvbCxcbiAgdGV4dDogdGV4dCxcbiAgdHJhaWw6IHRyYWlsXG59O1xuXG5mdW5jdGlvbiBib3VuZEl0ZW0gKGl0ZW0sIGZ1bmMsIG9wdCkge1xuICB2YXIgdHlwZSA9IE1hcmtzW2l0ZW0ubWFyay5tYXJrdHlwZV0sXG4gICAgICBib3VuZCA9IGZ1bmMgfHwgdHlwZS5ib3VuZDtcbiAgaWYgKHR5cGUubmVzdGVkKSBpdGVtID0gaXRlbS5tYXJrO1xuICByZXR1cm4gYm91bmQoaXRlbS5ib3VuZHMgfHwgKGl0ZW0uYm91bmRzID0gbmV3IEJvdW5kcygpKSwgaXRlbSwgb3B0KTtcbn1cblxudmFyIERVTU1ZID0ge1xuICBtYXJrOiBudWxsXG59O1xuZnVuY3Rpb24gYm91bmRNYXJrIChtYXJrLCBib3VuZHMsIG9wdCkge1xuICB2YXIgdHlwZSA9IE1hcmtzW21hcmsubWFya3R5cGVdLFxuICAgICAgYm91bmQgPSB0eXBlLmJvdW5kLFxuICAgICAgaXRlbXMgPSBtYXJrLml0ZW1zLFxuICAgICAgaGFzSXRlbXMgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIGl0ZW0sXG4gICAgICBiO1xuXG4gIGlmICh0eXBlLm5lc3RlZCkge1xuICAgIGlmIChoYXNJdGVtcykge1xuICAgICAgaXRlbSA9IGl0ZW1zWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBpdGVtcywgZmFrZSBpdFxuICAgICAgRFVNTVkubWFyayA9IG1hcms7XG4gICAgICBpdGVtID0gRFVNTVk7XG4gICAgfVxuXG4gICAgYiA9IGJvdW5kSXRlbShpdGVtLCBib3VuZCwgb3B0KTtcbiAgICBib3VuZHMgPSBib3VuZHMgJiYgYm91bmRzLnVuaW9uKGIpIHx8IGI7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGJvdW5kcyA9IGJvdW5kcyB8fCBtYXJrLmJvdW5kcyAmJiBtYXJrLmJvdW5kcy5jbGVhcigpIHx8IG5ldyBCb3VuZHMoKTtcblxuICBpZiAoaGFzSXRlbXMpIHtcbiAgICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBib3VuZHMudW5pb24oYm91bmRJdGVtKGl0ZW1zW2ldLCBib3VuZCwgb3B0KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hcmsuYm91bmRzID0gYm91bmRzO1xufVxuXG5jb25zdCBrZXlzID0gWydtYXJrdHlwZScsICduYW1lJywgJ3JvbGUnLCAnaW50ZXJhY3RpdmUnLCAnY2xpcCcsICdpdGVtcycsICd6aW5kZXgnLCAneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdhbGlnbicsICdiYXNlbGluZScsIC8vIGxheW91dFxuJ2ZpbGwnLCAnZmlsbE9wYWNpdHknLCAnb3BhY2l0eScsICdibGVuZCcsIC8vIGZpbGxcbidzdHJva2UnLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXaWR0aCcsICdzdHJva2VDYXAnLCAvLyBzdHJva2VcbidzdHJva2VEYXNoJywgJ3N0cm9rZURhc2hPZmZzZXQnLCAvLyBzdHJva2UgZGFzaFxuJ3N0cm9rZUZvcmVncm91bmQnLCAnc3Ryb2tlT2Zmc2V0JywgLy8gZ3JvdXBcbidzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgLy8gYXJjXG4nY29ybmVyUmFkaXVzJywgJ3BhZEFuZ2xlJywgLy8gYXJjLCByZWN0XG4nY29ybmVyUmFkaXVzVG9wTGVmdCcsICdjb3JuZXJSYWRpdXNUb3BSaWdodCcsIC8vIHJlY3QsIGdyb3VwXG4nY29ybmVyUmFkaXVzQm90dG9tTGVmdCcsICdjb3JuZXJSYWRpdXNCb3R0b21SaWdodCcsICdpbnRlcnBvbGF0ZScsICd0ZW5zaW9uJywgJ29yaWVudCcsICdkZWZpbmVkJywgLy8gYXJlYSwgbGluZVxuJ3VybCcsICdhc3BlY3QnLCAnc21vb3RoJywgLy8gaW1hZ2VcbidwYXRoJywgJ3NjYWxlWCcsICdzY2FsZVknLCAvLyBwYXRoXG4neDInLCAneTInLCAvLyBydWxlXG4nc2l6ZScsICdzaGFwZScsIC8vIHN5bWJvbFxuJ3RleHQnLCAnYW5nbGUnLCAndGhldGEnLCAncmFkaXVzJywgJ2RpcicsICdkeCcsICdkeScsIC8vIHRleHRcbidlbGxpcHNpcycsICdsaW1pdCcsICdsaW5lQnJlYWsnLCAnbGluZUhlaWdodCcsICdmb250JywgJ2ZvbnRTaXplJywgJ2ZvbnRXZWlnaHQnLCAnZm9udFN0eWxlJywgJ2ZvbnRWYXJpYW50JywgLy8gZm9udFxuJ2Rlc2NyaXB0aW9uJywgJ2FyaWEnLCAnYXJpYVJvbGUnLCAnYXJpYVJvbGVEZXNjcmlwdGlvbicgLy8gYXJpYVxuXTtcbmZ1bmN0aW9uIHNjZW5lVG9KU09OKHNjZW5lLCBpbmRlbnQpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNjZW5lLCBrZXlzLCBpbmRlbnQpO1xufVxuZnVuY3Rpb24gc2NlbmVGcm9tSlNPTihqc29uKSB7XG4gIGNvbnN0IHNjZW5lID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG4gIHJldHVybiBpbml0aWFsaXplKHNjZW5lKTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShzY2VuZSkge1xuICB2YXIgdHlwZSA9IHNjZW5lLm1hcmt0eXBlLFxuICAgICAgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIHBhcmVudCxcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIGlmIChpdGVtcykge1xuICAgIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHBhcmVudCA9IHR5cGUgPyAnbWFyaycgOiAnZ3JvdXAnO1xuICAgICAgaXRlbXNbaV1bcGFyZW50XSA9IHNjZW5lO1xuICAgICAgaWYgKGl0ZW1zW2ldLnppbmRleCkgaXRlbXNbaV1bcGFyZW50XS56ZGlydHkgPSB0cnVlO1xuICAgICAgaWYgKCdncm91cCcgPT09ICh0eXBlIHx8IHBhcmVudCkpIGluaXRpYWxpemUoaXRlbXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlKSBib3VuZE1hcmsoc2NlbmUpO1xuICByZXR1cm4gc2NlbmU7XG59XG5cbmZ1bmN0aW9uIFNjZW5lZ3JhcGgoc2NlbmUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLnJvb3QgPSBzY2VuZUZyb21KU09OKHNjZW5lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJvb3QgPSBjcmVhdGVNYXJrKHtcbiAgICAgIG1hcmt0eXBlOiAnZ3JvdXAnLFxuICAgICAgbmFtZTogJ3Jvb3QnLFxuICAgICAgcm9sZTogJ2ZyYW1lJ1xuICAgIH0pO1xuICAgIHRoaXMucm9vdC5pdGVtcyA9IFtuZXcgR3JvdXBJdGVtKHRoaXMucm9vdCldO1xuICB9XG59XG5TY2VuZWdyYXBoLnByb3RvdHlwZSA9IHtcbiAgdG9KU09OKGluZGVudCkge1xuICAgIHJldHVybiBzY2VuZVRvSlNPTih0aGlzLnJvb3QsIGluZGVudCB8fCAwKTtcbiAgfSxcblxuICBtYXJrKG1hcmtkZWYsIGdyb3VwLCBpbmRleCkge1xuICAgIGdyb3VwID0gZ3JvdXAgfHwgdGhpcy5yb290Lml0ZW1zWzBdO1xuICAgIGNvbnN0IG1hcmsgPSBjcmVhdGVNYXJrKG1hcmtkZWYsIGdyb3VwKTtcbiAgICBncm91cC5pdGVtc1tpbmRleF0gPSBtYXJrO1xuICAgIGlmIChtYXJrLnppbmRleCkgbWFyay5ncm91cC56ZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiBtYXJrO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmsoZGVmLCBncm91cCkge1xuICBjb25zdCBtYXJrID0ge1xuICAgIGJvdW5kczogbmV3IEJvdW5kcygpLFxuICAgIGNsaXA6ICEhZGVmLmNsaXAsXG4gICAgZ3JvdXA6IGdyb3VwLFxuICAgIGludGVyYWN0aXZlOiBkZWYuaW50ZXJhY3RpdmUgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlLFxuICAgIGl0ZW1zOiBbXSxcbiAgICBtYXJrdHlwZTogZGVmLm1hcmt0eXBlLFxuICAgIG5hbWU6IGRlZi5uYW1lIHx8IHVuZGVmaW5lZCxcbiAgICByb2xlOiBkZWYucm9sZSB8fCB1bmRlZmluZWQsXG4gICAgemluZGV4OiBkZWYuemluZGV4IHx8IDBcbiAgfTsgLy8gYWRkIGFjY2Vzc2liaWxpdHkgcHJvcGVydGllcyBpZiBkZWZpbmVkXG5cbiAgaWYgKGRlZi5hcmlhICE9IG51bGwpIHtcbiAgICBtYXJrLmFyaWEgPSBkZWYuYXJpYTtcbiAgfVxuXG4gIGlmIChkZWYuZGVzY3JpcHRpb24pIHtcbiAgICBtYXJrLmRlc2NyaXB0aW9uID0gZGVmLmRlc2NyaXB0aW9uO1xuICB9XG5cbiAgcmV0dXJuIG1hcms7XG59XG5cbi8vIGNyZWF0ZSBhIG5ldyBET00gZWxlbWVudFxuZnVuY3Rpb24gZG9tQ3JlYXRlKGRvYywgdGFnLCBucykge1xuICBpZiAoIWRvYyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpIHtcbiAgICBkb2MgPSBkb2N1bWVudDtcbiAgfVxuXG4gIHJldHVybiBkb2MgPyBucyA/IGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcpIDogbnVsbDtcbn0gLy8gZmluZCBmaXJzdCBjaGlsZCBlbGVtZW50IHdpdGggbWF0Y2hpbmcgdGFnXG5cbmZ1bmN0aW9uIGRvbUZpbmQoZWwsIHRhZykge1xuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdmFyIG5vZGVzID0gZWwuY2hpbGROb2RlcyxcbiAgICAgIGkgPSAwLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKDsgaSA8IG47ICsraSkgaWYgKG5vZGVzW2ldLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG5vZGVzW2ldO1xuICB9XG59IC8vIHJldHJpZXZlIGNoaWxkIGVsZW1lbnQgYXQgZ2l2ZW4gaW5kZXhcbi8vIGNyZWF0ZSAmIGluc2VydCBpZiBkb2Vzbid0IGV4aXN0IG9yIGlmIHRhZ3MgZG8gbm90IG1hdGNoXG5cbmZ1bmN0aW9uIGRvbUNoaWxkKGVsLCBpbmRleCwgdGFnLCBucykge1xuICB2YXIgYSA9IGVsLmNoaWxkTm9kZXNbaW5kZXhdLFxuICAgICAgYjtcblxuICBpZiAoIWEgfHwgYS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgYiA9IGEgfHwgbnVsbDtcbiAgICBhID0gZG9tQ3JlYXRlKGVsLm93bmVyRG9jdW1lbnQsIHRhZywgbnMpO1xuICAgIGVsLmluc2VydEJlZm9yZShhLCBiKTtcbiAgfVxuXG4gIHJldHVybiBhO1xufSAvLyByZW1vdmUgYWxsIGNoaWxkIGVsZW1lbnRzIGF0IG9yIGFib3ZlIHRoZSBnaXZlbiBpbmRleFxuXG5mdW5jdGlvbiBkb21DbGVhcihlbCwgaW5kZXgpIHtcbiAgdmFyIG5vZGVzID0gZWwuY2hpbGROb2RlcyxcbiAgICAgIGN1cnIgPSBub2Rlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKGN1cnIgPiBpbmRleCkgZWwucmVtb3ZlQ2hpbGQobm9kZXNbLS1jdXJyXSk7XG5cbiAgcmV0dXJuIGVsO1xufSAvLyBnZW5lcmF0ZSBjc3MgY2xhc3MgbmFtZSBmb3IgbWFya1xuXG5mdW5jdGlvbiBjc3NDbGFzcyhtYXJrKSB7XG4gIHJldHVybiAnbWFyay0nICsgbWFyay5tYXJrdHlwZSArIChtYXJrLnJvbGUgPyAnIHJvbGUtJyArIG1hcmsucm9sZSA6ICcnKSArIChtYXJrLm5hbWUgPyAnICcgKyBtYXJrLm5hbWUgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50IChldmVudCwgZWwpIHtcbiAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSAoZWwuY2xpZW50TGVmdCB8fCAwKSwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gKGVsLmNsaWVudFRvcCB8fCAwKV07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJdGVtIChpdGVtLCBldmVudCwgZWwsIG9yaWdpbikge1xuICB2YXIgbWFyayA9IGl0ZW0gJiYgaXRlbS5tYXJrLFxuICAgICAgbWRlZixcbiAgICAgIHA7XG5cbiAgaWYgKG1hcmsgJiYgKG1kZWYgPSBNYXJrc1ttYXJrLm1hcmt0eXBlXSkudGlwKSB7XG4gICAgcCA9IHBvaW50KGV2ZW50LCBlbCk7XG4gICAgcFswXSAtPSBvcmlnaW5bMF07XG4gICAgcFsxXSAtPSBvcmlnaW5bMV07XG5cbiAgICB3aGlsZSAoaXRlbSA9IGl0ZW0ubWFyay5ncm91cCkge1xuICAgICAgcFswXSAtPSBpdGVtLnggfHwgMDtcbiAgICAgIHBbMV0gLT0gaXRlbS55IHx8IDA7XG4gICAgfVxuXG4gICAgaXRlbSA9IG1kZWYudGlwKG1hcmsuaXRlbXMsIHApO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEhhbmRsZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge29iamVjdH0gW2N1c3RvbUxvYWRlcl0gLSBPcHRpb25hbCBsb2FkZXIgaW5zdGFuY2UgZm9yXG4gKiAgIGhyZWYgVVJMIHNhbml0aXphdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgYSBzdGFuZGFyZCBsb2FkZXJcbiAqICAgaW5zdGFuY2Ugd2lsbCBiZSBnZW5lcmF0ZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY3VzdG9tVG9vbHRpcF0gLSBPcHRpb25hbCB0b29sdGlwIGhhbmRsZXJcbiAqICAgZnVuY3Rpb24gZm9yIGN1c3RvbSB0b29sdGlwIGRpc3BsYXkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBIYW5kbGVyKGN1c3RvbUxvYWRlciwgY3VzdG9tVG9vbHRpcCkge1xuICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICB0aGlzLl9sb2FkZXIgPSBjdXN0b21Mb2FkZXIgfHwgbG9hZGVyKCk7XG4gIHRoaXMuX3Rvb2x0aXAgPSBjdXN0b21Ub29sdGlwIHx8IGRlZmF1bHRUb29sdGlwO1xufSAvLyBUaGUgZGVmYXVsdCB0b29sdGlwIGRpc3BsYXkgaGFuZGxlci5cbi8vIFNldHMgdGhlIEhUTUwgdGl0bGUgYXR0cmlidXRlIG9uIHRoZSB2aXN1YWxpemF0aW9uIGNvbnRhaW5lci5cblxuZnVuY3Rpb24gZGVmYXVsdFRvb2x0aXAoaGFuZGxlciwgZXZlbnQsIGl0ZW0sIHZhbHVlKSB7XG4gIGhhbmRsZXIuZWxlbWVudCgpLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB2YWx1ZSB8fCAnJyk7XG59XG5cbkhhbmRsZXIucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBIYW5kbGVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsIC0gVGhlIGNvbnRhaW5pbmcgRE9NIGVsZW1lbnQgZm9yIHRoZSBkaXNwbGF5LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogICBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRoaXMgcG9pbnQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb2JqXSAtIE9wdGlvbmFsIGNvbnRleHQgb2JqZWN0IHRoYXQgc2hvdWxkIHNlcnZlIGFzXG4gICAqICAgdGhlIFwidGhpc1wiIGNvbnRleHQgZm9yIGV2ZW50IGNhbGxiYWNrcy5cbiAgICogQHJldHVybiB7SGFuZGxlcn0gLSBUaGlzIGhhbmRsZXIgaW5zdGFuY2UuXG4gICAqL1xuICBpbml0aWFsaXplKGVsLCBvcmlnaW4sIG9iaikge1xuICAgIHRoaXMuX2VsID0gZWw7XG4gICAgdGhpcy5fb2JqID0gb2JqIHx8IG51bGw7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luKG9yaWdpbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBjb250YWluZXIgZWxlbWVudCBmb3IgYSB2aXN1YWxpemF0aW9uLlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSAtIFRoZSBjb250YWluaW5nIERPTSBlbGVtZW50LlxuICAgKi9cbiAgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjZW5lIGVsZW1lbnQgKGUuZy4sIGNhbnZhcyBvciBTVkcpIG9mIHRoZSB2aXN1YWxpemF0aW9uXG4gICAqIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBpZiB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IHRoZSBzY2VuZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSAtIFRoZSBzY2VuZSAoZS5nLiwgY2FudmFzIG9yIFNWRykgZWxlbWVudC5cbiAgICovXG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZWwgJiYgdGhpcy5fZWwuZmlyc3RDaGlsZDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IC8gc2V0IHRoZSBvcmlnaW4gY29vcmRpbmF0ZXMgb2YgdGhlIHZpc3VhbGl6YXRpb24uXG4gICAqL1xuICBvcmlnaW4ob3JpZ2luKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX29yaWdpbiA9IG9yaWdpbiB8fCBbMCwgMF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbi5zbGljZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IC8gc2V0IHRoZSBzY2VuZWdyYXBoIHJvb3QuXG4gICAqL1xuICBzY2VuZShzY2VuZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NjZW5lO1xuICAgIHRoaXMuX3NjZW5lID0gc2NlbmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBoYW5kbGVyLiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZC5cbiAgICovXG4gIG9uKClcbiAgLyp0eXBlLCBoYW5kbGVyKi9cbiAge30sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBoYW5kbGVyLiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZC5cbiAgICovXG4gIG9mZigpXG4gIC8qdHlwZSwgaGFuZGxlciovXG4gIHt9LFxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgZmluZGluZyB0aGUgYXJyYXkgaW5kZXggb2YgYW4gZXZlbnQgaGFuZGxlci5cbiAgICogQHBhcmFtIHtBcnJheX0gaCAtIEFuIGFycmF5IG9mIHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBUaGUgZXZlbnQgaGFuZGxlciBpbnN0YW5jZSB0byBmaW5kLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGhhbmRsZXIncyBhcnJheSBpbmRleCBvciAtMSBpZiBub3QgcmVnaXN0ZXJlZC5cbiAgICovXG4gIF9oYW5kbGVySW5kZXgoaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAobGV0IGkgPSBoID8gaC5sZW5ndGggOiAwOyAtLWkgPj0gMDspIHtcbiAgICAgIGlmIChoW2ldLnR5cGUgPT09IHR5cGUgJiYgKCFoYW5kbGVyIHx8IGhbaV0uaGFuZGxlciA9PT0gaGFuZGxlcikpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIFRoZSBldmVudCB0eXBlIHRvIHF1ZXJ5LiBBbnkgYW5ub3RhdGlvbnNcbiAgICogICBhcmUgaWdub3JlZDsgZm9yIGV4YW1wbGUsIGZvciB0aGUgYXJndW1lbnQgXCJjbGljay5mb29cIiwgXCIuZm9vXCIgd2lsbFxuICAgKiAgIGJlIGlnbm9yZWQgYW5kIHRoZSBtZXRob2QgcmV0dXJucyBhbGwgXCJjbGlja1wiIGhhbmRsZXJzLiBJZiB0eXBlIGlzXG4gICAqICAgbnVsbCBvciB1bnNwZWNpZmllZCwgdGhpcyBtZXRob2QgcmV0dXJucyBoYW5kbGVycyBmb3IgYWxsIHR5cGVzLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBBIG5ldyBhcnJheSBjb250YWluaW5nIGFsbCByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJzLlxuICAgKi9cbiAgaGFuZGxlcnModHlwZSkge1xuICAgIGNvbnN0IGggPSB0aGlzLl9oYW5kbGVycyxcbiAgICAgICAgICBhID0gW107XG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgYS5wdXNoKC4uLmhbdGhpcy5ldmVudE5hbWUodHlwZSldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBrIGluIGgpIHtcbiAgICAgICAgYS5wdXNoKC4uLmhba10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gZXZlbnQgbmFtZSBzdHJpbmcgdG8gcmV0dXJuIHRoZSBzcGVjaWZpYyBldmVudCB0eXBlLlxuICAgKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gXCJjbGljay5mb29cIiByZXR1cm5zIFwiY2xpY2tcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBpbnB1dCBldmVudCB0eXBlIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSAtIEEgc3RyaW5nIHdpdGggdGhlIGV2ZW50IHR5cGUgb25seS5cbiAgICovXG4gIGV2ZW50TmFtZShuYW1lKSB7XG4gICAgY29uc3QgaSA9IG5hbWUuaW5kZXhPZignLicpO1xuICAgIHJldHVybiBpIDwgMCA/IG5hbWUgOiBuYW1lLnNsaWNlKDAsIGkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGUgaHlwZXJsaW5rIG5hdmlnYXRpb24gaW4gcmVzcG9uc2UgdG8gYW4gaXRlbS5ocmVmIHZhbHVlLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCB0cmlnZ2VyaW5nIGh5cGVybGluayBuYXZpZ2F0aW9uLlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgc2NlbmVncmFwaCBpdGVtLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiAtIFRoZSBVUkwgdG8gbmF2aWdhdGUgdG8uXG4gICAqL1xuICBoYW5kbGVIcmVmKGV2ZW50LCBpdGVtLCBocmVmKSB7XG4gICAgdGhpcy5fbG9hZGVyLnNhbml0aXplKGhyZWYsIHtcbiAgICAgIGNvbnRleHQ6ICdocmVmJ1xuICAgIH0pLnRoZW4ob3B0ID0+IHtcbiAgICAgIGNvbnN0IGUgPSBuZXcgTW91c2VFdmVudChldmVudC50eXBlLCBldmVudCksXG4gICAgICAgICAgICBhID0gZG9tQ3JlYXRlKG51bGwsICdhJyk7XG5cbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvcHQpIGEuc2V0QXR0cmlidXRlKG5hbWUsIG9wdFtuYW1lXSk7XG5cbiAgICAgIGEuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0b29sdGlwIGRpc3BsYXkgaW4gcmVzcG9uc2UgdG8gYW4gaXRlbS50b29sdGlwIHZhbHVlLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCB0cmlnZ2VyaW5nIHRvb2x0aXAgZGlzcGxheS5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIHNjZW5lZ3JhcGggaXRlbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG93IC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAqICAgdG8gc2hvdyBvciBoaWRlIGEgdG9vbHRpcCBmb3IgdGhlIGdpdmVuIGl0ZW0uXG4gICAqL1xuICBoYW5kbGVUb29sdGlwKGV2ZW50LCBpdGVtLCBzaG93KSB7XG4gICAgaWYgKGl0ZW0gJiYgaXRlbS50b29sdGlwICE9IG51bGwpIHtcbiAgICAgIGl0ZW0gPSByZXNvbHZlSXRlbShpdGVtLCBldmVudCwgdGhpcy5jYW52YXMoKSwgdGhpcy5fb3JpZ2luKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gc2hvdyAmJiBpdGVtICYmIGl0ZW0udG9vbHRpcCB8fCBudWxsO1xuXG4gICAgICB0aGlzLl90b29sdGlwLmNhbGwodGhpcy5fb2JqLCB0aGlzLCBldmVudCwgaXRlbSwgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiBhIHNjZW5lZ3JhcGggaXRlbSBhbmQgaXRzIHBvc2l0aW9uIHJlbGF0aXZlXG4gICAqIHRvIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIHNjZW5lZ3JhcGggaXRlbS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAtIEEgYm91bmRpbmcgYm94IG9iamVjdCAoY29tcGF0aWJsZSB3aXRoIHRoZVxuICAgKiAgIERPTVJlY3QgdHlwZSkgY29uc2lzdGluZyBvZiB4LCB5LCB3aWR0aCwgaGVpZ2gsIHRvcCwgbGVmdCxcbiAgICogICByaWdodCwgYW5kIGJvdHRvbSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgZ2V0SXRlbUJvdW5kaW5nQ2xpZW50UmVjdChpdGVtKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmNhbnZhcygpO1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgb3JpZ2luID0gdGhpcy5fb3JpZ2luLFxuICAgICAgICAgIGJvdW5kcyA9IGl0ZW0uYm91bmRzLFxuICAgICAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoKCksXG4gICAgICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodCgpO1xuICAgIGxldCB4ID0gYm91bmRzLngxICsgb3JpZ2luWzBdICsgcmVjdC5sZWZ0LFxuICAgICAgICB5ID0gYm91bmRzLnkxICsgb3JpZ2luWzFdICsgcmVjdC50b3A7IC8vIHRyYW5zbGF0ZSBjb29yZGluYXRlIGZvciBlYWNoIHBhcmVudCBncm91cFxuXG4gICAgd2hpbGUgKGl0ZW0ubWFyayAmJiAoaXRlbSA9IGl0ZW0ubWFyay5ncm91cCkpIHtcbiAgICAgIHggKz0gaXRlbS54IHx8IDA7XG4gICAgICB5ICs9IGl0ZW0ueSB8fCAwO1xuICAgIH0gLy8gcmV0dXJuIERPTVJlY3QtY29tcGF0aWJsZSBib3VuZGluZyBib3hcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5LFxuICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICAgIGJvdHRvbTogeSArIGhlaWdodFxuICAgIH07XG4gIH1cblxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgUmVuZGVyZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge29iamVjdH0gW2xvYWRlcl0gLSBPcHRpb25hbCBsb2FkZXIgaW5zdGFuY2UgZm9yXG4gKiAgIGltYWdlIGFuZCBocmVmIFVSTCBzYW5pdGl6YXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIGFcbiAqICAgc3RhbmRhcmQgbG9hZGVyIGluc3RhbmNlIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyZXIobG9hZGVyKSB7XG4gIHRoaXMuX2VsID0gbnVsbDtcbiAgdGhpcy5fYmdjb2xvciA9IG51bGw7XG4gIHRoaXMuX2xvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcihsb2FkZXIpO1xufVxuUmVuZGVyZXIucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBSZW5kZXJlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbCAtIFRoZSBjb250YWluaW5nIERPTSBlbGVtZW50IGZvciB0aGUgZGlzcGxheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIGNvb3JkaW5hdGUgd2lkdGggb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBjb29yZGluYXRlIGhlaWdodCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogICBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRoaXMgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVGYWN0b3I9MV0gLSBPcHRpb25hbCBzY2FsZUZhY3RvciBieSB3aGljaCB0byBtdWx0aXBseVxuICAgKiAgIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGRldGVybWluZSB0aGUgZmluYWwgcGl4ZWwgc2l6ZS5cbiAgICogQHJldHVybiB7UmVuZGVyZXJ9IC0gVGhpcyByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIGluaXRpYWxpemUoZWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpIHtcbiAgICB0aGlzLl9lbCA9IGVsO1xuICAgIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFyZW50IGNvbnRhaW5lciBlbGVtZW50IGZvciBhIHZpc3VhbGl6YXRpb24uXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IC0gVGhlIGNvbnRhaW5pbmcgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBlbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9lbDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2NlbmUgZWxlbWVudCAoZS5nLiwgY2FudmFzIG9yIFNWRykgb2YgdGhlIHZpc3VhbGl6YXRpb25cbiAgICogU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGlmIHRoZSBmaXJzdCBjaGlsZCBpcyBub3QgdGhlIHNjZW5lIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IC0gVGhlIHNjZW5lIChlLmcuLCBjYW52YXMgb3IgU1ZHKSBlbGVtZW50LlxuICAgKi9cbiAgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLl9lbCAmJiB0aGlzLl9lbC5maXJzdENoaWxkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgLyBzZXQgdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAqL1xuICBiYWNrZ3JvdW5kKGJnY29sb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2JnY29sb3I7XG4gICAgdGhpcy5fYmdjb2xvciA9IGJnY29sb3I7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgZGlzcGxheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyBjb29yZGluYXRlIHdpZHRoIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGNvb3JkaW5hdGUgaGVpZ2h0IG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb3JpZ2luIC0gVGhlIG5ldyBvcmlnaW4gb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogICBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRoaXMgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVGYWN0b3I9MV0gLSBPcHRpb25hbCBzY2FsZUZhY3RvciBieSB3aGljaCB0byBtdWx0aXBseVxuICAgKiAgIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGRldGVybWluZSB0aGUgZmluYWwgcGl4ZWwgc2l6ZS5cbiAgICogQHJldHVybiB7UmVuZGVyZXJ9IC0gVGhpcyByZW5kZXJlciBpbnN0YW5jZTtcbiAgICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKSB7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luIHx8IFswLCAwXTtcbiAgICB0aGlzLl9zY2FsZSA9IHNjYWxlRmFjdG9yIHx8IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcG9ydCBhIGRpcnR5IGl0ZW0gd2hvc2UgYm91bmRzIHNob3VsZCBiZSByZWRyYXduLlxuICAgKiBUaGlzIGJhc2UgY2xhc3MgbWV0aG9kIGRvZXMgbm90aGluZy4gU3ViY2xhc3NlcyB0aGF0IHBlcmZvcm1cbiAgICogaW5jcmVtZW50YWwgc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZC5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIGRpcnR5IGl0ZW0gd2hvc2UgYm91bmRzIHNob3VsZCBiZSByZWRyYXduLlxuICAgKi9cbiAgZGlydHkoKVxuICAvKml0ZW0qL1xuICB7fSxcblxuICAvKipcbiAgICogUmVuZGVyIGFuIGlucHV0IHNjZW5lZ3JhcGgsIHBvdGVudGlhbGx5IHdpdGggYSBzZXQgb2YgZGlydHkgaXRlbXMuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgcGVyZm9ybSBhbiBpbW1lZGlhdGUgcmVuZGVyaW5nIHdpdGggYXZhaWxhYmxlIHJlc291cmNlcy5cbiAgICogVGhlIHJlbmRlcmVyIG1heSBhbHNvIG5lZWQgdG8gcGVyZm9ybSBpbWFnZSBsb2FkaW5nIHRvIHBlcmZvcm0gYSBjb21wbGV0ZVxuICAgKiByZW5kZXIuIFRoaXMgcHJvY2VzcyBjYW4gbGVhZCB0byBhc3luY2hyb25vdXMgcmUtcmVuZGVyaW5nIG9mIHRoZSBzY2VuZVxuICAgKiBhZnRlciB0aGlzIG1ldGhvZCByZXR1cm5zLiBUbyByZWNlaXZlIG5vdGlmaWNhdGlvbiB3aGVuIHJlbmRlcmluZyBpc1xuICAgKiBjb21wbGV0ZSwgdXNlIHRoZSByZW5kZXJBc3luYyBtZXRob2QgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIHJvb3QgbWFyayBvZiBhIHNjZW5lZ3JhcGggdG8gcmVuZGVyLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJlcn0gLSBUaGlzIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgcmVuZGVyKHNjZW5lKSB7XG4gICAgY29uc3QgciA9IHRoaXM7IC8vIGJpbmQgYXJndW1lbnRzIGludG8gYSByZW5kZXIgY2FsbCwgYW5kIGNhY2hlIGl0XG4gICAgLy8gdGhpcyBmdW5jdGlvbiBtYXkgYmUgc3Vic2VxdWVudGx5IGNhbGxlZCBmb3IgYXN5bmMgcmVkcmF3XG5cbiAgICByLl9jYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgci5fcmVuZGVyKHNjZW5lKTtcbiAgICB9OyAvLyBpbnZva2UgdGhlIHJlbmRlcmVyXG5cblxuICAgIHIuX2NhbGwoKTsgLy8gY2xlYXIgdGhlIGNhY2hlZCBjYWxsIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAvLyBhc3luYyByZWRyYXdzIHdpbGwgc3Rhc2ggdGhlaXIgb3duIGNvcHlcblxuXG4gICAgci5fY2FsbCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVybmFsIHJlbmRlcmluZyBtZXRob2QuIFJlbmRlcmVyIHN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXNcbiAgICogbWV0aG9kIHRvIGFjdHVhbGx5IHBlcmZvcm0gcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgcm9vdCBtYXJrIG9mIGEgc2NlbmVncmFwaCB0byByZW5kZXIuXG4gICAqL1xuICBfcmVuZGVyKClcbiAgLypzY2VuZSovXG4gIHsvLyBzdWJjbGFzc2VzIHRvIG92ZXJyaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyByZW5kZXJpbmcgbWV0aG9kLiBTaW1pbGFyIHRvIHJlbmRlciwgYnV0IHJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgcmVuZGVyaW5nIGlzIGNvbXBsZXRlZC4gU29tZXRpbWVzIGEgcmVuZGVyZXIgbXVzdFxuICAgKiBwZXJmb3JtIGltYWdlIGxvYWRpbmcgdG8gZ2V0IGEgY29tcGxldGUgcmVuZGVyaW5nLiBUaGUgcmV0dXJuZWRcbiAgICogUHJvbWlzZSB3aWxsIG5vdCByZXNvbHZlIHVudGlsIHRoaXMgcHJvY2VzcyBjb21wbGV0ZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSByb290IG1hcmsgb2YgYSBzY2VuZWdyYXBoIHRvIHJlbmRlci5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHJlbmRlcmluZyBpcyBjb21wbGV0ZS5cbiAgICovXG4gIHJlbmRlckFzeW5jKHNjZW5lKSB7XG4gICAgY29uc3QgciA9IHRoaXMucmVuZGVyKHNjZW5lKTtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHkgPyB0aGlzLl9yZWFkeS50aGVuKCgpID0+IHIpIDogUHJvbWlzZS5yZXNvbHZlKHIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgZm9yIGFzeW5jaHJvbm91cyByZXNvdXJjZSBsb2FkaW5nLlxuICAgKiBQcm94aWVzIG1ldGhvZCBjYWxscyB0byB0aGUgSW1hZ2VMb2FkZXIsIGFuZCB0cmFja3MgbG9hZGluZ1xuICAgKiBwcm9ncmVzcyB0byBpbnZva2UgYSByZS1yZW5kZXIgb25jZSBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCAtIFRoZSBtZXRob2QgbmFtZSB0byBpbnZva2Ugb24gdGhlIEltYWdlTG9hZGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpIC0gVGhlIFVSSSBmb3IgdGhlIHJlcXVlc3RlZCByZXNvdXJjZS5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVxdWVzdGVkIHJlc291cmNlLlxuICAgKi9cbiAgX2xvYWQobWV0aG9kLCB1cmkpIHtcbiAgICB2YXIgciA9IHRoaXMsXG4gICAgICAgIHAgPSByLl9sb2FkZXJbbWV0aG9kXSh1cmkpO1xuXG4gICAgaWYgKCFyLl9yZWFkeSkge1xuICAgICAgLy8gcmUtcmVuZGVyIHRoZSBzY2VuZSB3aGVuIGxvYWRpbmcgY29tcGxldGVzXG4gICAgICBjb25zdCBjYWxsID0gci5fY2FsbDtcbiAgICAgIHIuX3JlYWR5ID0gci5fbG9hZGVyLnJlYWR5KCkudGhlbihyZWRyYXcgPT4ge1xuICAgICAgICBpZiAocmVkcmF3KSBjYWxsKCk7XG4gICAgICAgIHIuX3JlYWR5ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW5pdGl6ZSBhIFVSTCB0byBpbmNsdWRlIGFzIGEgaHlwZXJsaW5rIGluIHRoZSByZW5kZXJlZCBzY2VuZS5cbiAgICogVGhpcyBtZXRob2QgcHJveGllcyBhIGNhbGwgdG8gSW1hZ2VMb2FkZXIuc2FuaXRpemVVUkwsIGJ1dCBhbHNvIHRyYWNrc1xuICAgKiBpbWFnZSBsb2FkaW5nIHByb2dyZXNzIGFuZCBpbnZva2VzIGEgcmUtcmVuZGVyIG9uY2UgY29tcGxldGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgVVJJIHN0cmluZyB0byBzYW5pdGl6ZS5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc2FuaXRpemVkIFVSTC5cbiAgICovXG4gIHNhbml0aXplVVJMKHVyaSkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkKCdzYW5pdGl6ZVVSTCcsIHVyaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFuIGltYWdlIHRvIGluY2x1ZGUgaW4gdGhlIHJlbmRlcmVkIHNjZW5lLlxuICAgKiBUaGlzIG1ldGhvZCBwcm94aWVzIGEgY2FsbCB0byBJbWFnZUxvYWRlci5sb2FkSW1hZ2UsIGJ1dCBhbHNvIHRyYWNrc1xuICAgKiBpbWFnZSBsb2FkaW5nIHByb2dyZXNzIGFuZCBpbnZva2VzIGEgcmUtcmVuZGVyIG9uY2UgY29tcGxldGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgVVJJIHN0cmluZyBvZiB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxvYWRlZCBJbWFnZS5cbiAgICovXG4gIGxvYWRJbWFnZSh1cmkpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCgnbG9hZEltYWdlJywgdXJpKTtcbiAgfVxuXG59O1xuXG5jb25zdCBLZXlEb3duRXZlbnQgPSAna2V5ZG93bic7XG5jb25zdCBLZXlQcmVzc0V2ZW50ID0gJ2tleXByZXNzJztcbmNvbnN0IEtleVVwRXZlbnQgPSAna2V5dXAnO1xuY29uc3QgRHJhZ0VudGVyRXZlbnQgPSAnZHJhZ2VudGVyJztcbmNvbnN0IERyYWdMZWF2ZUV2ZW50ID0gJ2RyYWdsZWF2ZSc7XG5jb25zdCBEcmFnT3ZlckV2ZW50ID0gJ2RyYWdvdmVyJztcbmNvbnN0IE1vdXNlRG93bkV2ZW50ID0gJ21vdXNlZG93bic7XG5jb25zdCBNb3VzZVVwRXZlbnQgPSAnbW91c2V1cCc7XG5jb25zdCBNb3VzZU1vdmVFdmVudCA9ICdtb3VzZW1vdmUnO1xuY29uc3QgTW91c2VPdXRFdmVudCA9ICdtb3VzZW91dCc7XG5jb25zdCBNb3VzZU92ZXJFdmVudCA9ICdtb3VzZW92ZXInO1xuY29uc3QgQ2xpY2tFdmVudCA9ICdjbGljayc7XG5jb25zdCBEb3VibGVDbGlja0V2ZW50ID0gJ2RibGNsaWNrJztcbmNvbnN0IFdoZWVsRXZlbnQgPSAnd2hlZWwnO1xuY29uc3QgTW91c2VXaGVlbEV2ZW50ID0gJ21vdXNld2hlZWwnO1xuY29uc3QgVG91Y2hTdGFydEV2ZW50ID0gJ3RvdWNoc3RhcnQnO1xuY29uc3QgVG91Y2hNb3ZlRXZlbnQgPSAndG91Y2htb3ZlJztcbmNvbnN0IFRvdWNoRW5kRXZlbnQgPSAndG91Y2hlbmQnO1xuY29uc3QgRXZlbnRzID0gW0tleURvd25FdmVudCwgS2V5UHJlc3NFdmVudCwgS2V5VXBFdmVudCwgRHJhZ0VudGVyRXZlbnQsIERyYWdMZWF2ZUV2ZW50LCBEcmFnT3ZlckV2ZW50LCBNb3VzZURvd25FdmVudCwgTW91c2VVcEV2ZW50LCBNb3VzZU1vdmVFdmVudCwgTW91c2VPdXRFdmVudCwgTW91c2VPdmVyRXZlbnQsIENsaWNrRXZlbnQsIERvdWJsZUNsaWNrRXZlbnQsIFdoZWVsRXZlbnQsIE1vdXNlV2hlZWxFdmVudCwgVG91Y2hTdGFydEV2ZW50LCBUb3VjaE1vdmVFdmVudCwgVG91Y2hFbmRFdmVudF07XG5jb25zdCBUb29sdGlwU2hvd0V2ZW50ID0gTW91c2VNb3ZlRXZlbnQ7XG5jb25zdCBUb29sdGlwSGlkZUV2ZW50ID0gTW91c2VPdXRFdmVudDtcbmNvbnN0IEhyZWZFdmVudCA9IENsaWNrRXZlbnQ7XG5cbmZ1bmN0aW9uIENhbnZhc0hhbmRsZXIobG9hZGVyLCB0b29sdGlwKSB7XG4gIEhhbmRsZXIuY2FsbCh0aGlzLCBsb2FkZXIsIHRvb2x0aXApO1xuICB0aGlzLl9kb3duID0gbnVsbDtcbiAgdGhpcy5fdG91Y2ggPSBudWxsO1xuICB0aGlzLl9maXJzdCA9IHRydWU7XG4gIHRoaXMuX2V2ZW50cyA9IHt9O1xufVxuXG5jb25zdCBldmVudEJ1bmRsZSA9IHR5cGUgPT4gdHlwZSA9PT0gVG91Y2hTdGFydEV2ZW50IHx8IHR5cGUgPT09IFRvdWNoTW92ZUV2ZW50IHx8IHR5cGUgPT09IFRvdWNoRW5kRXZlbnQgPyBbVG91Y2hTdGFydEV2ZW50LCBUb3VjaE1vdmVFdmVudCwgVG91Y2hFbmRFdmVudF0gOiBbdHlwZV07IC8vIGxhemlseSBhZGQgbGlzdGVuZXJzIHRvIHRoZSBjYW52YXMgYXMgbmVlZGVkXG5cblxuZnVuY3Rpb24gZXZlbnRMaXN0ZW5lckNoZWNrKGhhbmRsZXIsIHR5cGUpIHtcbiAgZXZlbnRCdW5kbGUodHlwZSkuZm9yRWFjaChfID0+IGFkZEV2ZW50TGlzdGVuZXIoaGFuZGxlciwgXykpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGhhbmRsZXIsIHR5cGUpIHtcbiAgY29uc3QgY2FudmFzID0gaGFuZGxlci5jYW52YXMoKTtcblxuICBpZiAoY2FudmFzICYmICFoYW5kbGVyLl9ldmVudHNbdHlwZV0pIHtcbiAgICBoYW5kbGVyLl9ldmVudHNbdHlwZV0gPSAxO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXJbdHlwZV0gPyBldnQgPT4gaGFuZGxlclt0eXBlXShldnQpIDogZXZ0ID0+IGhhbmRsZXIuZmlyZSh0eXBlLCBldnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlKG1vdmVFdmVudCwgb3ZlckV2ZW50LCBvdXRFdmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2dCkge1xuICAgIGNvbnN0IGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICAgICAgcCA9IHRoaXMucGlja0V2ZW50KGV2dCk7XG5cbiAgICBpZiAocCA9PT0gYSkge1xuICAgICAgLy8gYWN0aXZlIGl0ZW0gYW5kIHBpY2tlZCBpdGVtIGFyZSB0aGUgc2FtZVxuICAgICAgdGhpcy5maXJlKG1vdmVFdmVudCwgZXZ0KTsgLy8gZmlyZSBtb3ZlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFjdGl2ZSBpdGVtIGFuZCBwaWNrZWQgaXRlbSBhcmUgZGlmZmVyZW50XG4gICAgICBpZiAoIWEgfHwgIWEuZXhpdCkge1xuICAgICAgICAvLyBmaXJlIG91dCBmb3IgcHJpb3IgYWN0aXZlIGl0ZW1cbiAgICAgICAgLy8gc3VwcHJlc3MgaWYgYWN0aXZlIGl0ZW0gd2FzIHJlbW92ZWQgZnJvbSBzY2VuZVxuICAgICAgICB0aGlzLmZpcmUob3V0RXZlbnQsIGV2dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHA7IC8vIHNldCBuZXcgYWN0aXZlIGl0ZW1cblxuICAgICAgdGhpcy5maXJlKG92ZXJFdmVudCwgZXZ0KTsgLy8gZmlyZSBvdmVyIGZvciBuZXcgYWN0aXZlIGl0ZW1cblxuICAgICAgdGhpcy5maXJlKG1vdmVFdmVudCwgZXZ0KTsgLy8gZmlyZSBtb3ZlIGZvciBuZXcgYWN0aXZlIGl0ZW1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluYWN0aXZlKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldnQpIHtcbiAgICB0aGlzLmZpcmUodHlwZSwgZXZ0KTtcbiAgICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuICB9O1xufVxuXG5pbmhlcml0cyhDYW52YXNIYW5kbGVyLCBIYW5kbGVyLCB7XG4gIGluaXRpYWxpemUoZWwsIG9yaWdpbiwgb2JqKSB7XG4gICAgdGhpcy5fY2FudmFzID0gZWwgJiYgZG9tRmluZChlbCwgJ2NhbnZhcycpOyAvLyBhZGQgbWluaW1hbCBldmVudHMgcmVxdWlyZWQgZm9yIHByb3BlciBzdGF0ZSBtYW5hZ2VtZW50XG5cbiAgICBbQ2xpY2tFdmVudCwgTW91c2VEb3duRXZlbnQsIE1vdXNlTW92ZUV2ZW50LCBNb3VzZU91dEV2ZW50LCBEcmFnTGVhdmVFdmVudF0uZm9yRWFjaCh0eXBlID0+IGV2ZW50TGlzdGVuZXJDaGVjayh0aGlzLCB0eXBlKSk7XG4gICAgcmV0dXJuIEhhbmRsZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBlbCwgb3JpZ2luLCBvYmopO1xuICB9LFxuXG4gIC8vIHJldHVybiB0aGUgYmFja2luZyBjYW52YXMgaW5zdGFuY2VcbiAgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gIH0sXG5cbiAgLy8gcmV0cmlldmUgdGhlIGN1cnJlbnQgY2FudmFzIGNvbnRleHRcbiAgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIH0sXG5cbiAgLy8gc3VwcG9ydGVkIGV2ZW50c1xuICBldmVudHM6IEV2ZW50cyxcblxuICAvLyB0byBrZWVwIG9sZCB2ZXJzaW9ucyBvZiBmaXJlZm94IGhhcHB5XG4gIERPTU1vdXNlU2Nyb2xsKGV2dCkge1xuICAgIHRoaXMuZmlyZShNb3VzZVdoZWVsRXZlbnQsIGV2dCk7XG4gIH0sXG5cbiAgbW91c2Vtb3ZlOiBtb3ZlKE1vdXNlTW92ZUV2ZW50LCBNb3VzZU92ZXJFdmVudCwgTW91c2VPdXRFdmVudCksXG4gIGRyYWdvdmVyOiBtb3ZlKERyYWdPdmVyRXZlbnQsIERyYWdFbnRlckV2ZW50LCBEcmFnTGVhdmVFdmVudCksXG4gIG1vdXNlb3V0OiBpbmFjdGl2ZShNb3VzZU91dEV2ZW50KSxcbiAgZHJhZ2xlYXZlOiBpbmFjdGl2ZShEcmFnTGVhdmVFdmVudCksXG5cbiAgbW91c2Vkb3duKGV2dCkge1xuICAgIHRoaXMuX2Rvd24gPSB0aGlzLl9hY3RpdmU7XG4gICAgdGhpcy5maXJlKE1vdXNlRG93bkV2ZW50LCBldnQpO1xuICB9LFxuXG4gIGNsaWNrKGV2dCkge1xuICAgIGlmICh0aGlzLl9kb3duID09PSB0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuZmlyZShDbGlja0V2ZW50LCBldnQpO1xuICAgICAgdGhpcy5fZG93biA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIHRvdWNoc3RhcnQoZXZ0KSB7XG4gICAgdGhpcy5fdG91Y2ggPSB0aGlzLnBpY2tFdmVudChldnQuY2hhbmdlZFRvdWNoZXNbMF0pO1xuXG4gICAgaWYgKHRoaXMuX2ZpcnN0KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl90b3VjaDtcbiAgICAgIHRoaXMuX2ZpcnN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5maXJlKFRvdWNoU3RhcnRFdmVudCwgZXZ0LCB0cnVlKTtcbiAgfSxcblxuICB0b3VjaG1vdmUoZXZ0KSB7XG4gICAgdGhpcy5maXJlKFRvdWNoTW92ZUV2ZW50LCBldnQsIHRydWUpO1xuICB9LFxuXG4gIHRvdWNoZW5kKGV2dCkge1xuICAgIHRoaXMuZmlyZShUb3VjaEVuZEV2ZW50LCBldnQsIHRydWUpO1xuICAgIHRoaXMuX3RvdWNoID0gbnVsbDtcbiAgfSxcblxuICAvLyBmaXJlIGFuIGV2ZW50XG4gIGZpcmUodHlwZSwgZXZ0LCB0b3VjaCkge1xuICAgIGNvbnN0IGEgPSB0b3VjaCA/IHRoaXMuX3RvdWNoIDogdGhpcy5fYWN0aXZlLFxuICAgICAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1t0eXBlXTsgLy8gc2V0IGV2ZW50IHR5cGUgcmVsYXRpdmUgdG8gc2NlbmVncmFwaCBpdGVtc1xuXG4gICAgZXZ0LnZlZ2FUeXBlID0gdHlwZTsgLy8gaGFuZGxlIGh5cGVybGlua3MgYW5kIHRvb2x0aXBzIGZpcnN0XG5cbiAgICBpZiAodHlwZSA9PT0gSHJlZkV2ZW50ICYmIGEgJiYgYS5ocmVmKSB7XG4gICAgICB0aGlzLmhhbmRsZUhyZWYoZXZ0LCBhLCBhLmhyZWYpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9vbHRpcFNob3dFdmVudCB8fCB0eXBlID09PSBUb29sdGlwSGlkZUV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZVRvb2x0aXAoZXZ0LCBhLCB0eXBlICE9PSBUb29sdGlwSGlkZUV2ZW50KTtcbiAgICB9IC8vIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBoYW5kbGVyc1xuXG5cbiAgICBpZiAoaCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaFtpXS5oYW5kbGVyLmNhbGwodGhpcy5fb2JqLCBldnQsIGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxuICBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuZXZlbnROYW1lKHR5cGUpLFxuICAgICAgICAgIGggPSB0aGlzLl9oYW5kbGVycyxcbiAgICAgICAgICBpID0gdGhpcy5faGFuZGxlckluZGV4KGhbbmFtZV0sIHR5cGUsIGhhbmRsZXIpO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBldmVudExpc3RlbmVyQ2hlY2sodGhpcywgdHlwZSk7XG4gICAgICAoaFtuYW1lXSB8fCAoaFtuYW1lXSA9IFtdKSkucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG4gIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuZXZlbnROYW1lKHR5cGUpLFxuICAgICAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXSxcbiAgICAgICAgICBpID0gdGhpcy5faGFuZGxlckluZGV4KGgsIHR5cGUsIGhhbmRsZXIpO1xuXG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgaC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcGlja0V2ZW50KGV2dCkge1xuICAgIGNvbnN0IHAgPSBwb2ludChldnQsIHRoaXMuX2NhbnZhcyksXG4gICAgICAgICAgbyA9IHRoaXMuX29yaWdpbjtcbiAgICByZXR1cm4gdGhpcy5waWNrKHRoaXMuX3NjZW5lLCBwWzBdLCBwWzFdLCBwWzBdIC0gb1swXSwgcFsxXSAtIG9bMV0pO1xuICB9LFxuXG4gIC8vIGZpbmQgdGhlIHNjZW5lZ3JhcGggaXRlbSBhdCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuICAvLyB4LCB5IC0tIHRoZSBhYnNvbHV0ZSB4LCB5IG1vdXNlIGNvb3JkaW5hdGVzIG9uIHRoZSBjYW52YXMgZWxlbWVudFxuICAvLyBneCwgZ3kgLS0gdGhlIHJlbGF0aXZlIGNvb3JkaW5hdGVzIHdpdGhpbiB0aGUgY3VycmVudCBncm91cFxuICBwaWNrKHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICBjb25zdCBnID0gdGhpcy5jb250ZXh0KCksXG4gICAgICAgICAgbWFyayA9IE1hcmtzW3NjZW5lLm1hcmt0eXBlXTtcbiAgICByZXR1cm4gbWFyay5waWNrLmNhbGwodGhpcywgZywgc2NlbmUsIHgsIHksIGd4LCBneSk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIGRldmljZVBpeGVsUmF0aW8oKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEgOiAxO1xufVxuXG52YXIgcGl4ZWxSYXRpbyA9IGRldmljZVBpeGVsUmF0aW8oKTtcbmZ1bmN0aW9uIHJlc2l6ZSAoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yLCBvcHQpIHtcbiAgY29uc3QgaW5ET00gPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGNhbnZhcy5wYXJlbnROb2RlICE9IG51bGwsXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgcmF0aW8gPSBpbkRPTSA/IHBpeGVsUmF0aW8gOiBzY2FsZUZhY3RvcjtcbiAgY2FudmFzLndpZHRoID0gd2lkdGggKiByYXRpbztcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHJhdGlvO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIG9wdCkge1xuICAgIGNvbnRleHRba2V5XSA9IG9wdFtrZXldO1xuICB9XG5cbiAgaWYgKGluRE9NICYmIHJhdGlvICE9PSAxKSB7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG5cbiAgY29udGV4dC5waXhlbFJhdGlvID0gcmF0aW87XG4gIGNvbnRleHQuc2V0VHJhbnNmb3JtKHJhdGlvLCAwLCAwLCByYXRpbywgcmF0aW8gKiBvcmlnaW5bMF0sIHJhdGlvICogb3JpZ2luWzFdKTtcbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIobG9hZGVyKSB7XG4gIFJlbmRlcmVyLmNhbGwodGhpcywgbG9hZGVyKTtcbiAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICB0aGlzLl9yZWRyYXcgPSBmYWxzZTtcbiAgdGhpcy5fZGlydHkgPSBuZXcgQm91bmRzKCk7XG4gIHRoaXMuX3RlbXBiID0gbmV3IEJvdW5kcygpO1xufVxuY29uc3QgYmFzZSQxID0gUmVuZGVyZXIucHJvdG90eXBlO1xuXG5jb25zdCB2aWV3Qm91bmRzID0gKG9yaWdpbiwgd2lkdGgsIGhlaWdodCkgPT4gbmV3IEJvdW5kcygpLnNldCgwLCAwLCB3aWR0aCwgaGVpZ2h0KS50cmFuc2xhdGUoLW9yaWdpblswXSwgLW9yaWdpblsxXSk7XG5cbmZ1bmN0aW9uIGNsaXBUb0JvdW5kcyhnLCBiLCBvcmlnaW4pIHtcbiAgLy8gZXhwYW5kIGJvdW5kcyBieSAxIHBpeGVsLCB0aGVuIHJvdW5kIHRvIHBpeGVsIGJvdW5kYXJpZXNcbiAgYi5leHBhbmQoMSkucm91bmQoKTsgLy8gYWxpZ24gdG8gYmFzZSBwaXhlbCBncmlkIGluIGNhc2Ugb2Ygbm9uLWludGVnZXIgc2NhbGluZyAoIzI0MjUpXG5cbiAgaWYgKGcucGl4ZWxSYXRpbyAlIDEpIHtcbiAgICBiLnNjYWxlKGcucGl4ZWxSYXRpbykucm91bmQoKS5zY2FsZSgxIC8gZy5waXhlbFJhdGlvKTtcbiAgfSAvLyB0byBhdm9pZCBhcnRpZmFjdHMgdHJhbnNsYXRlIGlmIG9yaWdpbiBoYXMgZnJhY3Rpb25hbCBwaXhlbHNcblxuXG4gIGIudHJhbnNsYXRlKC0ob3JpZ2luWzBdICUgMSksIC0ob3JpZ2luWzFdICUgMSkpOyAvLyBzZXQgY2xpcCBwYXRoXG5cbiAgZy5iZWdpblBhdGgoKTtcbiAgZy5yZWN0KGIueDEsIGIueTEsIGIud2lkdGgoKSwgYi5oZWlnaHQoKSk7XG4gIGcuY2xpcCgpO1xuICByZXR1cm4gYjtcbn1cblxuaW5oZXJpdHMoQ2FudmFzUmVuZGVyZXIsIFJlbmRlcmVyLCB7XG4gIGluaXRpYWxpemUoZWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IsIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9jYW52YXMgPSB0aGlzLl9vcHRpb25zLmV4dGVybmFsQ29udGV4dCA/IG51bGwgOiBjYW52YXMoMSwgMSwgdGhpcy5fb3B0aW9ucy50eXBlKTsgLy8gaW5zdGFudGlhdGUgYSBzbWFsbCBjYW52YXNcblxuICAgIGlmIChlbCAmJiB0aGlzLl9jYW52YXMpIHtcbiAgICAgIGRvbUNsZWFyKGVsLCAwKS5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xuXG4gICAgICB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKCdjbGFzcycsICdtYXJrcycpO1xuICAgIH0gLy8gdGhpcyBtZXRob2Qgd2lsbCBpbnZva2UgcmVzaXplIHRvIHNpemUgdGhlIGNhbnZhcyBhcHByb3ByaWF0ZWx5XG5cblxuICAgIHJldHVybiBiYXNlJDEuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVsLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKTtcbiAgfSxcblxuICByZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcikge1xuICAgIGJhc2UkMS5yZXNpemUuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKTtcblxuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIC8vIGNvbmZpZ3VyZSBjYW52YXMgc2l6ZSBhbmQgdHJhbnNmb3JtXG4gICAgICByZXNpemUodGhpcy5fY2FudmFzLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCB0aGlzLl9vcmlnaW4sIHRoaXMuX3NjYWxlLCB0aGlzLl9vcHRpb25zLmNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleHRlcm5hbCBjb250ZXh0IG5lZWRzIHRvIGJlIHNjYWxlZCBhbmQgcG9zaXRpb25lZCB0byBvcmlnaW5cbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX29wdGlvbnMuZXh0ZXJuYWxDb250ZXh0O1xuICAgICAgaWYgKCFjdHgpIGVycm9yKCdDYW52YXNSZW5kZXJlciBpcyBtaXNzaW5nIGEgdmFsaWQgY2FudmFzIG9yIGNvbnRleHQnKTtcbiAgICAgIGN0eC5zY2FsZSh0aGlzLl9zY2FsZSwgdGhpcy5fc2NhbGUpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLl9vcmlnaW5bMF0sIHRoaXMuX29yaWdpblsxXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVkcmF3ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgfSxcblxuICBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmV4dGVybmFsQ29udGV4dCB8fCAodGhpcy5fY2FudmFzID8gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJykgOiBudWxsKTtcbiAgfSxcblxuICBkaXJ0eShpdGVtKSB7XG4gICAgY29uc3QgYiA9IHRoaXMuX3RlbXBiLmNsZWFyKCkudW5pb24oaXRlbS5ib3VuZHMpO1xuXG4gICAgbGV0IGcgPSBpdGVtLm1hcmsuZ3JvdXA7XG5cbiAgICB3aGlsZSAoZykge1xuICAgICAgYi50cmFuc2xhdGUoZy54IHx8IDAsIGcueSB8fCAwKTtcbiAgICAgIGcgPSBnLm1hcmsuZ3JvdXA7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkudW5pb24oYik7XG4gIH0sXG5cbiAgX3JlbmRlcihzY2VuZSkge1xuICAgIGNvbnN0IGcgPSB0aGlzLmNvbnRleHQoKSxcbiAgICAgICAgICBvID0gdGhpcy5fb3JpZ2luLFxuICAgICAgICAgIHcgPSB0aGlzLl93aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5faGVpZ2h0LFxuICAgICAgICAgIGRiID0gdGhpcy5fZGlydHksXG4gICAgICAgICAgdmIgPSB2aWV3Qm91bmRzKG8sIHcsIGgpOyAvLyBzZXR1cFxuXG4gICAgZy5zYXZlKCk7XG4gICAgY29uc3QgYiA9IHRoaXMuX3JlZHJhdyB8fCBkYi5lbXB0eSgpID8gKHRoaXMuX3JlZHJhdyA9IGZhbHNlLCB2Yi5leHBhbmQoMSkpIDogY2xpcFRvQm91bmRzKGcsIHZiLmludGVyc2VjdChkYiksIG8pO1xuICAgIHRoaXMuY2xlYXIoLW9bMF0sIC1vWzFdLCB3LCBoKTsgLy8gcmVuZGVyXG5cbiAgICB0aGlzLmRyYXcoZywgc2NlbmUsIGIpOyAvLyB0YWtlZG93blxuXG4gICAgZy5yZXN0b3JlKCk7XG4gICAgZGIuY2xlYXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBkcmF3KGN0eCwgc2NlbmUsIGJvdW5kcykge1xuICAgIGNvbnN0IG1hcmsgPSBNYXJrc1tzY2VuZS5tYXJrdHlwZV07XG4gICAgaWYgKHNjZW5lLmNsaXApIGNsaXAoY3R4LCBzY2VuZSk7XG4gICAgbWFyay5kcmF3LmNhbGwodGhpcywgY3R4LCBzY2VuZSwgYm91bmRzKTtcbiAgICBpZiAoc2NlbmUuY2xpcCkgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICBjbGVhcih4LCB5LCB3LCBoKSB7XG4gICAgY29uc3Qgb3B0ID0gdGhpcy5fb3B0aW9ucyxcbiAgICAgICAgICBnID0gdGhpcy5jb250ZXh0KCk7XG5cbiAgICBpZiAob3B0LnR5cGUgIT09ICdwZGYnICYmICFvcHQuZXh0ZXJuYWxDb250ZXh0KSB7XG4gICAgICAvLyBjYWxsaW5nIGNsZWFyIHJlY3Qgdm9pZHMgdmVjdG9yIG91dHB1dCBpbiBwZGYgbW9kZVxuICAgICAgLy8gYW5kIGNvdWxkIHJlbW92ZSBleHRlcm5hbCBjb250ZXh0IGNvbnRlbnQgKCMyNjE1KVxuICAgICAgZy5jbGVhclJlY3QoeCwgeSwgdywgaCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2JnY29sb3IgIT0gbnVsbCkge1xuICAgICAgZy5maWxsU3R5bGUgPSB0aGlzLl9iZ2NvbG9yO1xuICAgICAgZy5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIFNWR0hhbmRsZXIobG9hZGVyLCB0b29sdGlwKSB7XG4gIEhhbmRsZXIuY2FsbCh0aGlzLCBsb2FkZXIsIHRvb2x0aXApO1xuICBjb25zdCBoID0gdGhpcztcbiAgaC5faHJlZkhhbmRsZXIgPSBsaXN0ZW5lcihoLCAoZXZ0LCBpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0gJiYgaXRlbS5ocmVmKSBoLmhhbmRsZUhyZWYoZXZ0LCBpdGVtLCBpdGVtLmhyZWYpO1xuICB9KTtcbiAgaC5fdG9vbHRpcEhhbmRsZXIgPSBsaXN0ZW5lcihoLCAoZXZ0LCBpdGVtKSA9PiB7XG4gICAgaC5oYW5kbGVUb29sdGlwKGV2dCwgaXRlbSwgZXZ0LnR5cGUgIT09IFRvb2x0aXBIaWRlRXZlbnQpO1xuICB9KTtcbn0gLy8gd3JhcCBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIFNWRyBET01cblxuY29uc3QgbGlzdGVuZXIgPSAoY29udGV4dCwgaGFuZGxlcikgPT4gZXZ0ID0+IHtcbiAgbGV0IGl0ZW0gPSBldnQudGFyZ2V0Ll9fZGF0YV9fO1xuICBpdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IGl0ZW1bMF0gOiBpdGVtO1xuICBldnQudmVnYVR5cGUgPSBldnQudHlwZTtcbiAgaGFuZGxlci5jYWxsKGNvbnRleHQuX29iaiwgZXZ0LCBpdGVtKTtcbn07XG5cbmluaGVyaXRzKFNWR0hhbmRsZXIsIEhhbmRsZXIsIHtcbiAgaW5pdGlhbGl6ZShlbCwgb3JpZ2luLCBvYmopIHtcbiAgICBsZXQgc3ZnID0gdGhpcy5fc3ZnO1xuXG4gICAgaWYgKHN2Zykge1xuICAgICAgc3ZnLnJlbW92ZUV2ZW50TGlzdGVuZXIoSHJlZkV2ZW50LCB0aGlzLl9ocmVmSGFuZGxlcik7XG4gICAgICBzdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihUb29sdGlwU2hvd0V2ZW50LCB0aGlzLl90b29sdGlwSGFuZGxlcik7XG4gICAgICBzdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihUb29sdGlwSGlkZUV2ZW50LCB0aGlzLl90b29sdGlwSGFuZGxlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fc3ZnID0gc3ZnID0gZWwgJiYgZG9tRmluZChlbCwgJ3N2ZycpO1xuXG4gICAgaWYgKHN2Zykge1xuICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoSHJlZkV2ZW50LCB0aGlzLl9ocmVmSGFuZGxlcik7XG4gICAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcihUb29sdGlwU2hvd0V2ZW50LCB0aGlzLl90b29sdGlwSGFuZGxlcik7XG4gICAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcihUb29sdGlwSGlkZUV2ZW50LCB0aGlzLl90b29sdGlwSGFuZGxlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIEhhbmRsZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBlbCwgb3JpZ2luLCBvYmopO1xuICB9LFxuXG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ZnO1xuICB9LFxuXG4gIC8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG4gIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzLFxuICAgICAgICAgIGkgPSB0aGlzLl9oYW5kbGVySW5kZXgoaFtuYW1lXSwgdHlwZSwgaGFuZGxlcik7XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGNvbnN0IHggPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGhhbmRsZXIsXG4gICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcih0aGlzLCBoYW5kbGVyKVxuICAgICAgfTtcbiAgICAgIChoW25hbWVdIHx8IChoW25hbWVdID0gW10pKS5wdXNoKHgpO1xuXG4gICAgICBpZiAodGhpcy5fc3ZnKSB7XG4gICAgICAgIHRoaXMuX3N2Zy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHgubGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG4gIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuZXZlbnROYW1lKHR5cGUpLFxuICAgICAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXSxcbiAgICAgICAgICBpID0gdGhpcy5faGFuZGxlckluZGV4KGgsIHR5cGUsIGhhbmRsZXIpO1xuXG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgaWYgKHRoaXMuX3N2Zykge1xuICAgICAgICB0aGlzLl9zdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoW2ldLmxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgaC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSk7XG5cbmNvbnN0IEFSSUFfSElEREVOID0gJ2FyaWEtaGlkZGVuJztcbmNvbnN0IEFSSUFfTEFCRUwgPSAnYXJpYS1sYWJlbCc7XG5jb25zdCBBUklBX1JPTEUgPSAncm9sZSc7XG5jb25zdCBBUklBX1JPTEVERVNDUklQVElPTiA9ICdhcmlhLXJvbGVkZXNjcmlwdGlvbic7XG5jb25zdCBHUkFQSElDU19PQkpFQ1QgPSAnZ3JhcGhpY3Mtb2JqZWN0JztcbmNvbnN0IEdSQVBISUNTX1NZTUJPTCA9ICdncmFwaGljcy1zeW1ib2wnO1xuXG5jb25zdCBidW5kbGUgPSAocm9sZSwgcm9sZWRlc2MsIGxhYmVsKSA9PiAoe1xuICBbQVJJQV9ST0xFXTogcm9sZSxcbiAgW0FSSUFfUk9MRURFU0NSSVBUSU9OXTogcm9sZWRlc2MsXG4gIFtBUklBX0xBQkVMXTogbGFiZWwgfHwgdW5kZWZpbmVkXG59KTsgLy8gdGhlc2Ugcm9sZXMgYXJlIGNvdmVyZWQgYnkgcmVsYXRlZCByb2xlc1xuLy8gd2UgY2FuIGlnbm9yZSB0aGVtLCBubyBuZWVkIHRvIGdlbmVyYXRlIGF0dHJpYnV0ZXNcblxuXG5jb25zdCBBcmlhSWdub3JlID0gdG9TZXQoWydheGlzLWRvbWFpbicsICdheGlzLWdyaWQnLCAnYXhpcy1sYWJlbCcsICdheGlzLXRpY2snLCAnYXhpcy10aXRsZScsICdsZWdlbmQtYmFuZCcsICdsZWdlbmQtZW50cnknLCAnbGVnZW5kLWdyYWRpZW50JywgJ2xlZ2VuZC1sYWJlbCcsICdsZWdlbmQtdGl0bGUnLCAnbGVnZW5kLXN5bWJvbCcsICd0aXRsZSddKTsgLy8gYXJpYSBhdHRyaWJ1dGUgZ2VuZXJhdG9ycyBmb3IgZ3VpZGUgcm9sZXNcblxuY29uc3QgQXJpYUd1aWRlcyA9IHtcbiAgJ2F4aXMnOiB7XG4gICAgZGVzYzogJ2F4aXMnLFxuICAgIGNhcHRpb246IGF4aXNDYXB0aW9uXG4gIH0sXG4gICdsZWdlbmQnOiB7XG4gICAgZGVzYzogJ2xlZ2VuZCcsXG4gICAgY2FwdGlvbjogbGVnZW5kQ2FwdGlvblxuICB9LFxuICAndGl0bGUtdGV4dCc6IHtcbiAgICBkZXNjOiAndGl0bGUnLFxuICAgIGNhcHRpb246IGl0ZW0gPT4gYFRpdGxlIHRleHQgJyR7dGl0bGVDYXB0aW9uKGl0ZW0pfSdgXG4gIH0sXG4gICd0aXRsZS1zdWJ0aXRsZSc6IHtcbiAgICBkZXNjOiAnc3VidGl0bGUnLFxuICAgIGNhcHRpb246IGl0ZW0gPT4gYFN1YnRpdGxlIHRleHQgJyR7dGl0bGVDYXB0aW9uKGl0ZW0pfSdgXG4gIH1cbn07IC8vIGFyaWEgcHJvcGVydGllcyBnZW5lcmF0ZWQgZm9yIG1hcmsgaXRlbSBlbmNvZGluZyBjaGFubmVsc1xuXG5jb25zdCBBcmlhRW5jb2RlID0ge1xuICBhcmlhUm9sZTogQVJJQV9ST0xFLFxuICBhcmlhUm9sZURlc2NyaXB0aW9uOiBBUklBX1JPTEVERVNDUklQVElPTixcbiAgZGVzY3JpcHRpb246IEFSSUFfTEFCRUxcbn07XG5mdW5jdGlvbiBhcmlhSXRlbUF0dHJpYnV0ZXMoZW1pdCwgaXRlbSkge1xuICBjb25zdCBoaWRlID0gaXRlbS5hcmlhID09PSBmYWxzZTtcbiAgZW1pdChBUklBX0hJRERFTiwgaGlkZSB8fCB1bmRlZmluZWQpO1xuXG4gIGlmIChoaWRlIHx8IGl0ZW0uZGVzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBBcmlhRW5jb2RlKSB7XG4gICAgICBlbWl0KEFyaWFFbmNvZGVbcHJvcF0sIHVuZGVmaW5lZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHR5cGUgPSBpdGVtLm1hcmsubWFya3R5cGU7XG4gICAgZW1pdChBUklBX0xBQkVMLCBpdGVtLmRlc2NyaXB0aW9uKTtcbiAgICBlbWl0KEFSSUFfUk9MRSwgaXRlbS5hcmlhUm9sZSB8fCAodHlwZSA9PT0gJ2dyb3VwJyA/IEdSQVBISUNTX09CSkVDVCA6IEdSQVBISUNTX1NZTUJPTCkpO1xuICAgIGVtaXQoQVJJQV9ST0xFREVTQ1JJUFRJT04sIGl0ZW0uYXJpYVJvbGVEZXNjcmlwdGlvbiB8fCBgJHt0eXBlfSBtYXJrYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFyaWFNYXJrQXR0cmlidXRlcyhtYXJrKSB7XG4gIHJldHVybiBtYXJrLmFyaWEgPT09IGZhbHNlID8ge1xuICAgIFtBUklBX0hJRERFTl06IHRydWVcbiAgfSA6IEFyaWFJZ25vcmVbbWFyay5yb2xlXSA/IG51bGwgOiBBcmlhR3VpZGVzW21hcmsucm9sZV0gPyBhcmlhR3VpZGUobWFyaywgQXJpYUd1aWRlc1ttYXJrLnJvbGVdKSA6IGFyaWFNYXJrKG1hcmspO1xufVxuXG5mdW5jdGlvbiBhcmlhTWFyayhtYXJrKSB7XG4gIGNvbnN0IHR5cGUgPSBtYXJrLm1hcmt0eXBlO1xuICBjb25zdCByZWN1cnNlID0gdHlwZSA9PT0gJ2dyb3VwJyB8fCB0eXBlID09PSAndGV4dCcgfHwgbWFyay5pdGVtcy5zb21lKF8gPT4gXy5kZXNjcmlwdGlvbiAhPSBudWxsICYmIF8uYXJpYSAhPT0gZmFsc2UpO1xuICByZXR1cm4gYnVuZGxlKHJlY3Vyc2UgPyBHUkFQSElDU19PQkpFQ1QgOiBHUkFQSElDU19TWU1CT0wsIGAke3R5cGV9IG1hcmsgY29udGFpbmVyYCwgbWFyay5kZXNjcmlwdGlvbik7XG59XG5cbmZ1bmN0aW9uIGFyaWFHdWlkZShtYXJrLCBvcHQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBpdGVtID0gbWFyay5pdGVtc1swXSxcbiAgICAgICAgICBjYXB0aW9uID0gb3B0LmNhcHRpb24gfHwgKCgpID0+ICcnKTtcblxuICAgIHJldHVybiBidW5kbGUob3B0LnJvbGUgfHwgR1JBUEhJQ1NfU1lNQk9MLCBvcHQuZGVzYywgaXRlbS5kZXNjcmlwdGlvbiB8fCBjYXB0aW9uKGl0ZW0pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGl0bGVDYXB0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5KGl0ZW0udGV4dCkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiBheGlzQ2FwdGlvbihpdGVtKSB7XG4gIGNvbnN0IGRhdHVtID0gaXRlbS5kYXR1bSxcbiAgICAgICAgb3JpZW50ID0gaXRlbS5vcmllbnQsXG4gICAgICAgIHRpdGxlID0gZGF0dW0udGl0bGUgPyBleHRyYWN0VGl0bGUoaXRlbSkgOiBudWxsLFxuICAgICAgICBjdHggPSBpdGVtLmNvbnRleHQsXG4gICAgICAgIHNjYWxlID0gY3R4LnNjYWxlc1tkYXR1bS5zY2FsZV0udmFsdWUsXG4gICAgICAgIGxvY2FsZSA9IGN0eC5kYXRhZmxvdy5sb2NhbGUoKSxcbiAgICAgICAgdHlwZSA9IHNjYWxlLnR5cGUsXG4gICAgICAgIHh5ID0gb3JpZW50ID09PSAnbGVmdCcgfHwgb3JpZW50ID09PSAncmlnaHQnID8gJ1knIDogJ1gnO1xuICByZXR1cm4gYCR7eHl9LWF4aXNgICsgKHRpdGxlID8gYCB0aXRsZWQgJyR7dGl0bGV9J2AgOiAnJykgKyBgIGZvciBhICR7aXNEaXNjcmV0ZSh0eXBlKSA/ICdkaXNjcmV0ZScgOiB0eXBlfSBzY2FsZWAgKyBgIHdpdGggJHtkb21haW5DYXB0aW9uKGxvY2FsZSwgc2NhbGUsIGl0ZW0pfWA7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZENhcHRpb24oaXRlbSkge1xuICBjb25zdCBkYXR1bSA9IGl0ZW0uZGF0dW0sXG4gICAgICAgIHRpdGxlID0gZGF0dW0udGl0bGUgPyBleHRyYWN0VGl0bGUoaXRlbSkgOiBudWxsLFxuICAgICAgICB0eXBlID0gYCR7ZGF0dW0udHlwZSB8fCAnJ30gbGVnZW5kYC50cmltKCksXG4gICAgICAgIHNjYWxlcyA9IGRhdHVtLnNjYWxlcyxcbiAgICAgICAgcHJvcHMgPSBPYmplY3Qua2V5cyhzY2FsZXMpLFxuICAgICAgICBjdHggPSBpdGVtLmNvbnRleHQsXG4gICAgICAgIHNjYWxlID0gY3R4LnNjYWxlc1tzY2FsZXNbcHJvcHNbMF1dXS52YWx1ZSxcbiAgICAgICAgbG9jYWxlID0gY3R4LmRhdGFmbG93LmxvY2FsZSgpO1xuICByZXR1cm4gY2FwaXRhbGl6ZSh0eXBlKSArICh0aXRsZSA/IGAgdGl0bGVkICcke3RpdGxlfSdgIDogJycpICsgYCBmb3IgJHtjaGFubmVsQ2FwdGlvbihwcm9wcyl9YCArIGAgd2l0aCAke2RvbWFpbkNhcHRpb24obG9jYWxlLCBzY2FsZSwgaXRlbSl9YDtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRpdGxlKGl0ZW0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXJyYXkocGVlayhpdGVtLml0ZW1zKS5pdGVtc1swXS50ZXh0KS5qb2luKCcgJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoYW5uZWxDYXB0aW9uKHByb3BzKSB7XG4gIHByb3BzID0gcHJvcHMubWFwKHAgPT4gcCArIChwID09PSAnZmlsbCcgfHwgcCA9PT0gJ3N0cm9rZScgPyAnIGNvbG9yJyA6ICcnKSk7XG4gIHJldHVybiBwcm9wcy5sZW5ndGggPCAyID8gcHJvcHNbMF0gOiBwcm9wcy5zbGljZSgwLCAtMSkuam9pbignLCAnKSArICcgYW5kICcgKyBwZWVrKHByb3BzKTtcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzKSB7XG4gIHJldHVybiBzLmxlbmd0aCA/IHNbMF0udG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSkgOiBzO1xufVxuXG5jb25zdCBpbm5lclRleHQgPSB2YWwgPT4gKHZhbCArICcnKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG5cbmNvbnN0IGF0dHJUZXh0ID0gdmFsID0+IGlubmVyVGV4dCh2YWwpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC9cXHQvZywgJyYjeDk7JykucmVwbGFjZSgvXFxuL2csICcmI3hBOycpLnJlcGxhY2UoL1xcci9nLCAnJiN4RDsnKTtcblxuZnVuY3Rpb24gbWFya3VwKCkge1xuICBsZXQgYnVmID0gJycsXG4gICAgICBvdXRlciA9ICcnLFxuICAgICAgaW5uZXIgPSAnJztcblxuICBjb25zdCBzdGFjayA9IFtdLFxuICAgICAgICBjbGVhciA9ICgpID0+IG91dGVyID0gaW5uZXIgPSAnJyxcbiAgICAgICAgcHVzaCA9IHRhZyA9PiB7XG4gICAgaWYgKG91dGVyKSB7XG4gICAgICBidWYgKz0gYCR7b3V0ZXJ9PiR7aW5uZXJ9YDtcbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh0YWcpO1xuICB9LFxuICAgICAgICBhdHRyID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIG91dGVyICs9IGAgJHtuYW1lfT1cIiR7YXR0clRleHQodmFsdWUpfVwiYDtcbiAgICByZXR1cm4gbTtcbiAgfSxcbiAgICAgICAgbSA9IHtcbiAgICBvcGVuKHRhZywgLi4uYXR0cnMpIHtcbiAgICAgIHB1c2godGFnKTtcbiAgICAgIG91dGVyID0gJzwnICsgdGFnO1xuXG4gICAgICBmb3IgKGNvbnN0IHNldCBvZiBhdHRycykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzZXQpIGF0dHIoa2V5LCBzZXRba2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtO1xuICAgIH0sXG5cbiAgICBjbG9zZSgpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICBpZiAob3V0ZXIpIHtcbiAgICAgICAgYnVmICs9IG91dGVyICsgKGlubmVyID8gYD4ke2lubmVyfTwvJHt0YWd9PmAgOiAnLz4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZiArPSBgPC8ke3RhZ30+YDtcbiAgICAgIH1cblxuICAgICAgY2xlYXIoKTtcbiAgICAgIHJldHVybiBtO1xuICAgIH0sXG5cbiAgICBhdHRyLFxuICAgIHRleHQ6IHQgPT4gKGlubmVyICs9IGlubmVyVGV4dCh0KSwgbSksXG4gICAgdG9TdHJpbmc6ICgpID0+IGJ1ZlxuICB9O1xuXG4gIHJldHVybiBtO1xufVxuY29uc3Qgc2VyaWFsaXplWE1MID0gbm9kZSA9PiBfc2VyaWFsaXplKG1hcmt1cCgpLCBub2RlKSArICcnO1xuXG5mdW5jdGlvbiBfc2VyaWFsaXplKG0sIG5vZGUpIHtcbiAgbS5vcGVuKG5vZGUudGFnTmFtZSk7XG5cbiAgaWYgKG5vZGUuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgY29uc3QgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgbiA9IGF0dHJzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBtLmF0dHIoYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0udmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICAgIG4gPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNoaWxkLm5vZGVUeXBlID09PSAzIC8vIHRleHQgbm9kZVxuICAgICAgPyBtLnRleHQoY2hpbGQubm9kZVZhbHVlKSA6IF9zZXJpYWxpemUobSwgY2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtLmNsb3NlKCk7XG59XG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgc3Ryb2tlQ2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICBzdHJva2VKb2luOiAnc3Ryb2tlLWxpbmVqb2luJyxcbiAgc3Ryb2tlRGFzaDogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICBzdHJva2VEYXNoT2Zmc2V0OiAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICBzdHJva2VNaXRlckxpbWl0OiAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIGJsZW5kOiAnbWl4LWJsZW5kLW1vZGUnXG59OyAvLyBlbnN1cmUgbWl0ZXIgbGltaXQgZGVmYXVsdCBpcyBjb25zaXN0ZW50IHdpdGggY2FudmFzICgjMjQ5OClcblxuY29uc3Qgcm9vdEF0dHJpYnV0ZXMgPSB7XG4gICdmaWxsJzogJ25vbmUnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAxMFxufTtcblxuY29uc3QgUm9vdEluZGV4ID0gMCxcbiAgICAgIHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJyxcbiAgICAgIHN2Z25zID0gbWV0YWRhdGEueG1sbnM7XG5mdW5jdGlvbiBTVkdSZW5kZXJlcihsb2FkZXIpIHtcbiAgUmVuZGVyZXIuY2FsbCh0aGlzLCBsb2FkZXIpO1xuICB0aGlzLl9kaXJ0eUlEID0gMDtcbiAgdGhpcy5fZGlydHkgPSBbXTtcbiAgdGhpcy5fc3ZnID0gbnVsbDtcbiAgdGhpcy5fcm9vdCA9IG51bGw7XG4gIHRoaXMuX2RlZnMgPSBudWxsO1xufVxuY29uc3QgYmFzZSA9IFJlbmRlcmVyLnByb3RvdHlwZTtcbmluaGVyaXRzKFNWR1JlbmRlcmVyLCBSZW5kZXJlciwge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBTVkdSZW5kZXJlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbCAtIFRoZSBjb250YWluaW5nIERPTSBlbGVtZW50IGZvciB0aGUgZGlzcGxheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIGNvb3JkaW5hdGUgd2lkdGggb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBjb29yZGluYXRlIGhlaWdodCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogICBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRoaXMgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVGYWN0b3I9MV0gLSBPcHRpb25hbCBzY2FsZUZhY3RvciBieSB3aGljaCB0byBtdWx0aXBseVxuICAgKiAgIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGRldGVybWluZSB0aGUgZmluYWwgcGl4ZWwgc2l6ZS5cbiAgICogQHJldHVybiB7U1ZHUmVuZGVyZXJ9IC0gVGhpcyByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIGluaXRpYWxpemUoZWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpIHtcbiAgICAvLyBjcmVhdGUgdGhlIHN2ZyBkZWZpbml0aW9ucyBjYWNoZVxuICAgIHRoaXMuX2RlZnMgPSB7fTtcblxuICAgIHRoaXMuX2NsZWFyRGVmcygpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICB0aGlzLl9zdmcgPSBkb21DaGlsZChlbCwgMCwgJ3N2ZycsIHN2Z25zKTtcblxuICAgICAgdGhpcy5fc3ZnLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCAneG1sbnMnLCBzdmducyk7XG5cbiAgICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGVOUyh4bWxucywgJ3htbG5zOnhsaW5rJywgbWV0YWRhdGFbJ3htbG5zOnhsaW5rJ10pO1xuXG4gICAgICB0aGlzLl9zdmcuc2V0QXR0cmlidXRlKCd2ZXJzaW9uJywgbWV0YWRhdGFbJ3ZlcnNpb24nXSk7XG5cbiAgICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ21hcmtzJyk7XG5cbiAgICAgIGRvbUNsZWFyKGVsLCAxKTsgLy8gc2V0IHRoZSBzdmcgcm9vdCBncm91cFxuXG4gICAgICB0aGlzLl9yb290ID0gZG9tQ2hpbGQodGhpcy5fc3ZnLCBSb290SW5kZXgsICdnJywgc3ZnbnMpO1xuICAgICAgc2V0QXR0cmlidXRlcyh0aGlzLl9yb290LCByb290QXR0cmlidXRlcyk7IC8vIGVuc3VyZSBubyBhZGRpdGlvbmFsIGNoaWxkIGVsZW1lbnRzXG5cbiAgICAgIGRvbUNsZWFyKHRoaXMuX3N2ZywgUm9vdEluZGV4ICsgMSk7XG4gICAgfSAvLyBzZXQgYmFja2dyb3VuZCBjb2xvciBpZiBkZWZpbmVkXG5cblxuICAgIHRoaXMuYmFja2dyb3VuZCh0aGlzLl9iZ2NvbG9yKTtcbiAgICByZXR1cm4gYmFzZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgLyBzZXQgdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAqL1xuICBiYWNrZ3JvdW5kKGJnY29sb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiB0aGlzLl9zdmcpIHtcbiAgICAgIHRoaXMuX3N2Zy5zdHlsZS5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicsIGJnY29sb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlLmJhY2tncm91bmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzaXplIHRoZSBkaXNwbGF5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgbmV3IGNvb3JkaW5hdGUgd2lkdGggb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgY29vcmRpbmF0ZSBoZWlnaHQgb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBvcmlnaW4gLSBUaGUgbmV3IG9yaWdpbiBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiAgIFRoZSBjb29yZGluYXRlIHN5c3RlbSB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdGhpcyBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZUZhY3Rvcj0xXSAtIE9wdGlvbmFsIHNjYWxlRmFjdG9yIGJ5IHdoaWNoIHRvIG11bHRpcGx5XG4gICAqICAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgdG8gZGV0ZXJtaW5lIHRoZSBmaW5hbCBwaXhlbCBzaXplLlxuICAgKiBAcmV0dXJuIHtTVkdSZW5kZXJlcn0gLSBUaGlzIHJlbmRlcmVyIGluc3RhbmNlO1xuICAgKi9cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpIHtcbiAgICBiYXNlLnJlc2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpO1xuXG4gICAgaWYgKHRoaXMuX3N2Zykge1xuICAgICAgc2V0QXR0cmlidXRlcyh0aGlzLl9zdmcsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuX3dpZHRoICogdGhpcy5fc2NhbGUsXG4gICAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0ICogdGhpcy5fc2NhbGUsXG4gICAgICAgIHZpZXdCb3g6IGAwIDAgJHt0aGlzLl93aWR0aH0gJHt0aGlzLl9oZWlnaHR9YFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3Jvb3Quc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5fb3JpZ2lufSlgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaXJ0eSA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBTVkcgZWxlbWVudCBvZiB0aGUgdmlzdWFsaXphdGlvbi5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gLSBUaGUgU1ZHIGVsZW1lbnQuXG4gICAqL1xuICBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N2ZztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBTVkcgdGV4dCBzdHJpbmcgZm9yIHRoZSByZW5kZXJlZCBjb250ZW50LFxuICAgKiBvciBudWxsIGlmIHRoaXMgcmVuZGVyZXIgaXMgY3VycmVudGx5IGhlYWRsZXNzLlxuICAgKi9cbiAgc3ZnKCkge1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuX3N2ZyxcbiAgICAgICAgICBiZyA9IHRoaXMuX2JnY29sb3I7XG4gICAgaWYgKCFzdmcpIHJldHVybiBudWxsO1xuICAgIGxldCBub2RlO1xuXG4gICAgaWYgKGJnKSB7XG4gICAgICBzdmcucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgbm9kZSA9IGRvbUNoaWxkKHN2ZywgUm9vdEluZGV4LCAncmVjdCcsIHN2Z25zKTtcbiAgICAgIHNldEF0dHJpYnV0ZXMobm9kZSwge1xuICAgICAgICB3aWR0aDogdGhpcy5fd2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0LFxuICAgICAgICBmaWxsOiBiZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IHNlcmlhbGl6ZVhNTChzdmcpO1xuXG4gICAgaWYgKGJnKSB7XG4gICAgICBzdmcucmVtb3ZlQ2hpbGQobm9kZSk7XG5cbiAgICAgIHRoaXMuX3N2Zy5zdHlsZS5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicsIGJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgcmVuZGVyaW5nIG1ldGhvZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIHJvb3QgbWFyayBvZiBhIHNjZW5lZ3JhcGggdG8gcmVuZGVyLlxuICAgKi9cbiAgX3JlbmRlcihzY2VuZSkge1xuICAgIC8vIHBlcmZvcm0gc3BvdCB1cGRhdGVzIGFuZCByZS1yZW5kZXIgbWFya3VwXG4gICAgaWYgKHRoaXMuX2RpcnR5Q2hlY2soKSkge1xuICAgICAgaWYgKHRoaXMuX2RpcnR5QWxsKSB0aGlzLl9jbGVhckRlZnMoKTtcbiAgICAgIHRoaXMubWFyayh0aGlzLl9yb290LCBzY2VuZSk7XG4gICAgICBkb21DbGVhcih0aGlzLl9yb290LCAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlZnMoKTtcbiAgICB0aGlzLl9kaXJ0eSA9IFtdO1xuICAgICsrdGhpcy5fZGlydHlJRDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyAtLSBNYW5hZ2UgcmVuZGVyaW5nIG9mIGl0ZW1zIG1hcmtlZCBhcyBkaXJ0eSAtLVxuXG4gIC8qKlxuICAgKiBGbGFnIGEgbWFyayBpdGVtIGFzIGRpcnR5LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKi9cbiAgZGlydHkoaXRlbSkge1xuICAgIGlmIChpdGVtLmRpcnR5ICE9PSB0aGlzLl9kaXJ0eUlEKSB7XG4gICAgICBpdGVtLmRpcnR5ID0gdGhpcy5fZGlydHlJRDtcblxuICAgICAgdGhpcy5fZGlydHkucHVzaChpdGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgbWFyayBpdGVtIGlzIGNvbnNpZGVyZWQgZGlydHkuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBtYXJrIGl0ZW0uXG4gICAqL1xuICBpc0RpcnR5KGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHlBbGwgfHwgIWl0ZW0uX3N2ZyB8fCBpdGVtLmRpcnR5ID09PSB0aGlzLl9kaXJ0eUlEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY2hlY2sgZGlydHkgc3RhdHVzIGFuZCwgaWYgcG9zc2libGUsXG4gICAqIG1ha2UgdGFyZ2V0dGVkIHVwZGF0ZXMgd2l0aG91dCBhIGZ1bGwgcmVuZGVyaW5nIHBhc3MuXG4gICAqL1xuICBfZGlydHlDaGVjaygpIHtcbiAgICB0aGlzLl9kaXJ0eUFsbCA9IHRydWU7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9kaXJ0eTtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCB8fCAhdGhpcy5fZGlydHlJRCkgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgaWQgPSArK3RoaXMuX2RpcnR5SUQ7XG4gICAgbGV0IGl0ZW0sIG1hcmssIHR5cGUsIG1kZWYsIGksIG4sIG87XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICBtYXJrID0gaXRlbS5tYXJrO1xuXG4gICAgICBpZiAobWFyay5tYXJrdHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAvLyBtZW1vaXplIG1hcmsgaW5zdGFuY2UgbG9va3VwXG4gICAgICAgIHR5cGUgPSBtYXJrLm1hcmt0eXBlO1xuICAgICAgICBtZGVmID0gTWFya3NbdHlwZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrLnpkaXJ0eSAmJiBtYXJrLmRpcnR5ICE9PSBpZCkge1xuICAgICAgICB0aGlzLl9kaXJ0eUFsbCA9IGZhbHNlO1xuICAgICAgICBkaXJ0eVBhcmVudHMoaXRlbSwgaWQpO1xuICAgICAgICBtYXJrLml0ZW1zLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgaS5kaXJ0eSA9IGlkO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmsuemRpcnR5KSBjb250aW51ZTsgLy8gaGFuZGxlIGluIHN0YW5kYXJkIGRyYXdpbmcgcGFzc1xuXG4gICAgICBpZiAoaXRlbS5leGl0KSB7XG4gICAgICAgIC8vIEVYSVRcbiAgICAgICAgaWYgKG1kZWYubmVzdGVkICYmIG1hcmsuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gaWYgbmVzdGVkIG1hcmsgd2l0aCByZW1haW5pbmcgcG9pbnRzLCB1cGRhdGUgaW5zdGVhZFxuICAgICAgICAgIG8gPSBtYXJrLml0ZW1zWzBdO1xuICAgICAgICAgIGlmIChvLl9zdmcpIHRoaXMuX3VwZGF0ZShtZGVmLCBvLl9zdmcsIG8pO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uX3N2Zykge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSByZW1vdmUgZnJvbSBET01cbiAgICAgICAgICBvID0gaXRlbS5fc3ZnLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKG8pIG8ucmVtb3ZlQ2hpbGQoaXRlbS5fc3ZnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0uX3N2ZyA9IG51bGw7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpdGVtID0gbWRlZi5uZXN0ZWQgPyBtYXJrLml0ZW1zWzBdIDogaXRlbTtcbiAgICAgIGlmIChpdGVtLl91cGRhdGUgPT09IGlkKSBjb250aW51ZTsgLy8gYWxyZWFkeSB2aXNpdGVkXG5cbiAgICAgIGlmICghaXRlbS5fc3ZnIHx8ICFpdGVtLl9zdmcub3duZXJTVkdFbGVtZW50KSB7XG4gICAgICAgIC8vIEVOVEVSXG4gICAgICAgIHRoaXMuX2RpcnR5QWxsID0gZmFsc2U7XG4gICAgICAgIGRpcnR5UGFyZW50cyhpdGVtLCBpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJTi1QTEFDRSBVUERBVEVcbiAgICAgICAgdGhpcy5fdXBkYXRlKG1kZWYsIGl0ZW0uX3N2ZywgaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGl0ZW0uX3VwZGF0ZSA9IGlkO1xuICAgIH1cblxuICAgIHJldHVybiAhdGhpcy5fZGlydHlBbGw7XG4gIH0sXG5cbiAgLy8gLS0gQ29uc3RydWN0ICYgbWFpbnRhaW4gc2NlbmVncmFwaCB0byBTVkcgbWFwcGluZyAtLS1cblxuICAvKipcbiAgICogUmVuZGVyIGEgc2V0IG9mIG1hcmsgaXRlbXMuXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWwgLSBUaGUgcGFyZW50IGVsZW1lbnQgaW4gdGhlIFNWRyB0cmVlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgbWFyayBwYXJlbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IHByZXYgLSBUaGUgcHJldmlvdXMgc2libGluZyBpbiB0aGUgU1ZHIHRyZWUuXG4gICAqL1xuICBtYXJrKGVsLCBzY2VuZSwgcHJldikge1xuICAgIGlmICghdGhpcy5pc0RpcnR5KHNjZW5lKSkgcmV0dXJuIHNjZW5lLl9zdmc7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgICAgIG1kZWYgPSBNYXJrc1tzY2VuZS5tYXJrdHlwZV0sXG4gICAgICAgICAgZXZlbnRzID0gc2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlID8gJ25vbmUnIDogbnVsbCxcbiAgICAgICAgICBpc0dyb3VwID0gbWRlZi50YWcgPT09ICdnJztcbiAgICBsZXQgc2libGluZyA9IG51bGwsXG4gICAgICAgIGkgPSAwO1xuICAgIGNvbnN0IHBhcmVudCA9IGJpbmQoc2NlbmUsIGVsLCBwcmV2LCAnZycsIHN2Zyk7XG4gICAgcGFyZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjc3NDbGFzcyhzY2VuZSkpOyAvLyBhcHBseSBhcmlhIGF0dHJpYnV0ZXMgdG8gcGFyZW50IGNvbnRhaW5lciBlbGVtZW50XG5cbiAgICBjb25zdCBhcmlhID0gYXJpYU1hcmtBdHRyaWJ1dGVzKHNjZW5lKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGFyaWEpIHNldEF0dHJpYnV0ZShwYXJlbnQsIGtleSwgYXJpYVtrZXldKTtcblxuICAgIGlmICghaXNHcm91cCkge1xuICAgICAgc2V0QXR0cmlidXRlKHBhcmVudCwgJ3BvaW50ZXItZXZlbnRzJywgZXZlbnRzKTtcbiAgICB9XG5cbiAgICBzZXRBdHRyaWJ1dGUocGFyZW50LCAnY2xpcC1wYXRoJywgc2NlbmUuY2xpcCA/IGNsaXAkMSh0aGlzLCBzY2VuZSwgc2NlbmUuZ3JvdXApIDogbnVsbCk7XG5cbiAgICBjb25zdCBwcm9jZXNzID0gaXRlbSA9PiB7XG4gICAgICBjb25zdCBkaXJ0eSA9IHRoaXMuaXNEaXJ0eShpdGVtKSxcbiAgICAgICAgICAgIG5vZGUgPSBiaW5kKGl0ZW0sIHBhcmVudCwgc2libGluZywgbWRlZi50YWcsIHN2Zyk7XG5cbiAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICB0aGlzLl91cGRhdGUobWRlZiwgbm9kZSwgaXRlbSk7XG5cbiAgICAgICAgaWYgKGlzR3JvdXApIHJlY3Vyc2UodGhpcywgbm9kZSwgaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHNpYmxpbmcgPSBub2RlO1xuICAgICAgKytpO1xuICAgIH07XG5cbiAgICBpZiAobWRlZi5uZXN0ZWQpIHtcbiAgICAgIGlmIChzY2VuZS5pdGVtcy5sZW5ndGgpIHByb2Nlc3Moc2NlbmUuaXRlbXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aXNpdChzY2VuZSwgcHJvY2Vzcyk7XG4gICAgfVxuXG4gICAgZG9tQ2xlYXIocGFyZW50LCBpKTtcbiAgICByZXR1cm4gcGFyZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgYW4gU1ZHIGVsZW1lbnQgZm9yIGEgbWFyayBpdGVtLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbWRlZiAtIFRoZSBtYXJrIGRlZmluaXRpb24gb2JqZWN0XG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWwgLSBUaGUgU1ZHIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBtYXJrIGl0ZW0uXG4gICAqL1xuICBfdXBkYXRlKG1kZWYsIGVsLCBpdGVtKSB7XG4gICAgLy8gc2V0IGRvbSBlbGVtZW50IGFuZCB2YWx1ZXMgY2FjaGVcbiAgICAvLyBwcm92aWRlcyBhY2Nlc3MgdG8gZW1pdCBtZXRob2RcbiAgICBlbGVtZW50ID0gZWw7XG4gICAgdmFsdWVzID0gZWwuX192YWx1ZXNfXzsgLy8gYXBwbHkgYXJpYS1zcGVjaWZpYyBwcm9wZXJ0aWVzXG5cbiAgICBhcmlhSXRlbUF0dHJpYnV0ZXMoZW1pdCwgaXRlbSk7IC8vIGFwcGx5IHN2ZyBhdHRyaWJ1dGVzXG5cbiAgICBtZGVmLmF0dHIoZW1pdCwgaXRlbSwgdGhpcyk7IC8vIHNvbWUgbWFya3MgbmVlZCBzcGVjaWFsIHRyZWF0bWVudFxuXG4gICAgY29uc3QgZXh0cmEgPSBtYXJrX2V4dHJhc1ttZGVmLnR5cGVdO1xuICAgIGlmIChleHRyYSkgZXh0cmEuY2FsbCh0aGlzLCBtZGVmLCBlbCwgaXRlbSk7IC8vIGFwcGx5IHN2ZyBzdHlsZSBhdHRyaWJ1dGVzXG4gICAgLy8gbm90ZTogZWxlbWVudCBzdGF0ZSBtYXkgaGF2ZSBiZWVuIG1vZGlmaWVkIGJ5ICdleHRyYScgbWV0aG9kXG5cbiAgICBpZiAoZWxlbWVudCkgdGhpcy5zdHlsZShlbGVtZW50LCBpdGVtKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwcmVzZW50YXRpb24gYXR0cmlidXRlcyBvZiBhbiBTVkcgZWxlbWVudCBmb3IgYSBtYXJrIGl0ZW0uXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWwgLSBUaGUgU1ZHIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBtYXJrIGl0ZW0uXG4gICAqL1xuICBzdHlsZShlbCwgaXRlbSkge1xuICAgIGlmIChpdGVtID09IG51bGwpIHJldHVybjtcblxuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzdHlsZXMpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHByb3AgPT09ICdmb250JyA/IGZvbnRGYW1pbHkoaXRlbSkgOiBpdGVtW3Byb3BdO1xuICAgICAgaWYgKHZhbHVlID09PSB2YWx1ZXNbcHJvcF0pIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbmFtZSA9IHN0eWxlc1twcm9wXTtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzR3JhZGllbnQodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBncmFkaWVudFJlZih2YWx1ZSwgdGhpcy5fZGVmcy5ncmFkaWVudCwgaHJlZigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSArICcnKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVzW3Byb3BdID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgU1ZHIGRlZnMsIGFzIG5lZWRlZC5cbiAgICogTXVzdCBiZSBjYWxsZWQgKmFmdGVyKiBtYXJrcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHRvIGVuc3VyZSB0aGVcbiAgICogY29sbGVjdGVkIHN0YXRlIGlzIGN1cnJlbnQgYW5kIGFjY3VyYXRlLlxuICAgKi9cbiAgZGVmcygpIHtcbiAgICBjb25zdCBzdmcgPSB0aGlzLl9zdmcsXG4gICAgICAgICAgZGVmcyA9IHRoaXMuX2RlZnM7XG4gICAgbGV0IGVsID0gZGVmcy5lbCxcbiAgICAgICAgaW5kZXggPSAwO1xuXG4gICAgZm9yIChjb25zdCBpZCBpbiBkZWZzLmdyYWRpZW50KSB7XG4gICAgICBpZiAoIWVsKSBkZWZzLmVsID0gZWwgPSBkb21DaGlsZChzdmcsIFJvb3RJbmRleCArIDEsICdkZWZzJywgc3ZnbnMpO1xuICAgICAgaW5kZXggPSB1cGRhdGVHcmFkaWVudChlbCwgZGVmcy5ncmFkaWVudFtpZF0sIGluZGV4KTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGlkIGluIGRlZnMuY2xpcHBpbmcpIHtcbiAgICAgIGlmICghZWwpIGRlZnMuZWwgPSBlbCA9IGRvbUNoaWxkKHN2ZywgUm9vdEluZGV4ICsgMSwgJ2RlZnMnLCBzdmducyk7XG4gICAgICBpbmRleCA9IHVwZGF0ZUNsaXBwaW5nKGVsLCBkZWZzLmNsaXBwaW5nW2lkXSwgaW5kZXgpO1xuICAgIH0gLy8gY2xlYW4tdXBcblxuXG4gICAgaWYgKGVsKSB7XG4gICAgICBpbmRleCA9PT0gMCA/IChzdmcucmVtb3ZlQ2hpbGQoZWwpLCBkZWZzLmVsID0gbnVsbCkgOiBkb21DbGVhcihlbCwgaW5kZXgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgZGVmcyBjYWNoZXMuXG4gICAqL1xuICBfY2xlYXJEZWZzKCkge1xuICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZnM7XG4gICAgZGVmLmdyYWRpZW50ID0ge307XG4gICAgZGVmLmNsaXBwaW5nID0ge307XG4gIH1cblxufSk7IC8vIG1hcmsgYW5jZXN0b3IgY2hhaW4gd2l0aCBhIGRpcnR5IGlkXG5cbmZ1bmN0aW9uIGRpcnR5UGFyZW50cyhpdGVtLCBpZCkge1xuICBmb3IgKDsgaXRlbSAmJiBpdGVtLmRpcnR5ICE9PSBpZDsgaXRlbSA9IGl0ZW0ubWFyay5ncm91cCkge1xuICAgIGl0ZW0uZGlydHkgPSBpZDtcblxuICAgIGlmIChpdGVtLm1hcmsgJiYgaXRlbS5tYXJrLmRpcnR5ICE9PSBpZCkge1xuICAgICAgaXRlbS5tYXJrLmRpcnR5ID0gaWQ7XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfVxufSAvLyB1cGRhdGUgZ3JhZGllbnQgZGVmaW5pdGlvbnNcblxuXG5mdW5jdGlvbiB1cGRhdGVHcmFkaWVudChlbCwgZ3JhZCwgaW5kZXgpIHtcbiAgbGV0IGksIG4sIHN0b3A7XG5cbiAgaWYgKGdyYWQuZ3JhZGllbnQgPT09ICdyYWRpYWwnKSB7XG4gICAgLy8gU1ZHIHJhZGlhbCBncmFkaWVudHMgYXV0b21hdGljYWxseSB0cmFuc2Zvcm0gdG8gbm9ybWFsaXplZCBiYm94XG4gICAgLy8gY29vcmRpbmF0ZXMsIGluIGEgd2F5IHRoYXQgaXMgY3VtYmVyc29tZSB0byByZXBsaWNhdGUgaW4gY2FudmFzLlxuICAgIC8vIFdlIHdyYXAgdGhlIHJhZGlhbCBncmFkaWVudCBpbiBhIHBhdHRlcm4gZWxlbWVudCwgYWxsb3dpbmcgdXMgdG9cbiAgICAvLyBtYWludGFpbiBhIGNpcmN1bGFyIGdyYWRpZW50IHRoYXQgbWF0Y2hlcyB3aGF0IGNhbnZhcyBwcm92aWRlcy5cbiAgICBsZXQgcHQgPSBkb21DaGlsZChlbCwgaW5kZXgrKywgJ3BhdHRlcm4nLCBzdmducyk7XG4gICAgc2V0QXR0cmlidXRlcyhwdCwge1xuICAgICAgaWQ6IHBhdHRlcm5QcmVmaXggKyBncmFkLmlkLFxuICAgICAgdmlld0JveDogJzAsMCwxLDEnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3hNaWRZTWlkIHNsaWNlJ1xuICAgIH0pO1xuICAgIHB0ID0gZG9tQ2hpbGQocHQsIDAsICdyZWN0Jywgc3ZnbnMpO1xuICAgIHNldEF0dHJpYnV0ZXMocHQsIHtcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgaGVpZ2h0OiAxLFxuICAgICAgZmlsbDogYHVybCgke2hyZWYoKX0jJHtncmFkLmlkfSlgXG4gICAgfSk7XG4gICAgZWwgPSBkb21DaGlsZChlbCwgaW5kZXgrKywgJ3JhZGlhbEdyYWRpZW50Jywgc3ZnbnMpO1xuICAgIHNldEF0dHJpYnV0ZXMoZWwsIHtcbiAgICAgIGlkOiBncmFkLmlkLFxuICAgICAgZng6IGdyYWQueDEsXG4gICAgICBmeTogZ3JhZC55MSxcbiAgICAgIGZyOiBncmFkLnIxLFxuICAgICAgY3g6IGdyYWQueDIsXG4gICAgICBjeTogZ3JhZC55MixcbiAgICAgIHI6IGdyYWQucjJcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBlbCA9IGRvbUNoaWxkKGVsLCBpbmRleCsrLCAnbGluZWFyR3JhZGllbnQnLCBzdmducyk7XG4gICAgc2V0QXR0cmlidXRlcyhlbCwge1xuICAgICAgaWQ6IGdyYWQuaWQsXG4gICAgICB4MTogZ3JhZC54MSxcbiAgICAgIHgyOiBncmFkLngyLFxuICAgICAgeTE6IGdyYWQueTEsXG4gICAgICB5MjogZ3JhZC55MlxuICAgIH0pO1xuICB9XG5cbiAgZm9yIChpID0gMCwgbiA9IGdyYWQuc3RvcHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgc3RvcCA9IGRvbUNoaWxkKGVsLCBpLCAnc3RvcCcsIHN2Z25zKTtcbiAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0JywgZ3JhZC5zdG9wc1tpXS5vZmZzZXQpO1xuICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgZ3JhZC5zdG9wc1tpXS5jb2xvcik7XG4gIH1cblxuICBkb21DbGVhcihlbCwgaSk7XG4gIHJldHVybiBpbmRleDtcbn0gLy8gdXBkYXRlIGNsaXBwaW5nIHBhdGggZGVmaW5pdGlvbnNcblxuXG5mdW5jdGlvbiB1cGRhdGVDbGlwcGluZyhlbCwgY2xpcCwgaW5kZXgpIHtcbiAgbGV0IG1hc2s7XG4gIGVsID0gZG9tQ2hpbGQoZWwsIGluZGV4LCAnY2xpcFBhdGgnLCBzdmducyk7XG4gIGVsLnNldEF0dHJpYnV0ZSgnaWQnLCBjbGlwLmlkKTtcblxuICBpZiAoY2xpcC5wYXRoKSB7XG4gICAgbWFzayA9IGRvbUNoaWxkKGVsLCAwLCAncGF0aCcsIHN2Z25zKTtcbiAgICBtYXNrLnNldEF0dHJpYnV0ZSgnZCcsIGNsaXAucGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgbWFzayA9IGRvbUNoaWxkKGVsLCAwLCAncmVjdCcsIHN2Z25zKTtcbiAgICBzZXRBdHRyaWJ1dGVzKG1hc2ssIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGNsaXAud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNsaXAuaGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICBkb21DbGVhcihlbCwgMSk7XG4gIHJldHVybiBpbmRleCArIDE7XG59IC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgZ3JvdXAgY29udGVudHMuXG5cblxuZnVuY3Rpb24gcmVjdXJzZShyZW5kZXJlciwgZWwsIGdyb3VwKSB7XG4gIGVsID0gZWwubGFzdENoaWxkLnByZXZpb3VzU2libGluZztcbiAgbGV0IHByZXYsXG4gICAgICBpZHggPSAwO1xuICB2aXNpdChncm91cCwgaXRlbSA9PiB7XG4gICAgcHJldiA9IHJlbmRlcmVyLm1hcmsoZWwsIGl0ZW0sIHByZXYpO1xuICAgICsraWR4O1xuICB9KTsgLy8gcmVtb3ZlIGFueSBleHRyYW5lb3VzIERPTSBlbGVtZW50c1xuXG4gIGRvbUNsZWFyKGVsLCAxICsgaWR4KTtcbn0gLy8gQmluZCBhIHNjZW5lZ3JhcGggaXRlbSB0byBhbiBTVkcgRE9NIGVsZW1lbnQuXG4vLyBDcmVhdGUgbmV3IFNWRyBlbGVtZW50cyBhcyBuZWVkZWQuXG5cblxuZnVuY3Rpb24gYmluZChpdGVtLCBlbCwgc2libGluZywgdGFnLCBzdmcpIHtcbiAgbGV0IG5vZGUgPSBpdGVtLl9zdmcsXG4gICAgICBkb2M7IC8vIGNyZWF0ZSBhIG5ldyBkb20gbm9kZSBpZiBuZWVkZWRcblxuICBpZiAoIW5vZGUpIHtcbiAgICBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICAgIG5vZGUgPSBkb21DcmVhdGUoZG9jLCB0YWcsIHN2Z25zKTtcbiAgICBpdGVtLl9zdmcgPSBub2RlO1xuXG4gICAgaWYgKGl0ZW0ubWFyaykge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGl0ZW07XG4gICAgICBub2RlLl9fdmFsdWVzX18gPSB7XG4gICAgICAgIGZpbGw6ICdkZWZhdWx0J1xuICAgICAgfTsgLy8gaWYgZ3JvdXAsIGNyZWF0ZSBiYWNrZ3JvdW5kLCBjb250ZW50LCBhbmQgZm9yZWdyb3VuZCBlbGVtZW50c1xuXG4gICAgICBpZiAodGFnID09PSAnZycpIHtcbiAgICAgICAgY29uc3QgYmcgPSBkb21DcmVhdGUoZG9jLCAncGF0aCcsIHN2Z25zKTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChiZyk7XG4gICAgICAgIGJnLl9fZGF0YV9fID0gaXRlbTtcbiAgICAgICAgY29uc3QgY2cgPSBkb21DcmVhdGUoZG9jLCAnZycsIHN2Z25zKTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjZyk7XG4gICAgICAgIGNnLl9fZGF0YV9fID0gaXRlbTtcbiAgICAgICAgY29uc3QgZmcgPSBkb21DcmVhdGUoZG9jLCAncGF0aCcsIHN2Z25zKTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChmZyk7XG4gICAgICAgIGZnLl9fZGF0YV9fID0gaXRlbTtcbiAgICAgICAgZmcuX192YWx1ZXNfXyA9IHtcbiAgICAgICAgICBmaWxsOiAnZGVmYXVsdCdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gKHJlLSlpbnNlcnQgaWYgKGEpIG5vdCBjb250YWluZWQgaW4gU1ZHIG9yIChiKSBzaWJsaW5nIG9yZGVyIGhhcyBjaGFuZ2VkXG5cblxuICBpZiAobm9kZS5vd25lclNWR0VsZW1lbnQgIT09IHN2ZyB8fCBzaWJsaW5nQ2hlY2sobm9kZSwgc2libGluZykpIHtcbiAgICBlbC5pbnNlcnRCZWZvcmUobm9kZSwgc2libGluZyA/IHNpYmxpbmcubmV4dFNpYmxpbmcgOiBlbC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSAvLyBjaGVjayBpZiB0d28gbm9kZXMgYXJlIG9yZGVyZWQgc2libGluZ3NcblxuXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2sobm9kZSwgc2libGluZykge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgJiYgbm9kZS5wcmV2aW91c1NpYmxpbmcgIT0gc2libGluZzsgLy8gdHJlYXQgbnVsbC91bmRlZmluZWQgdGhlIHNhbWVcbn0gLy8gLS0gU2V0IGF0dHJpYnV0ZXMgJiBzdHlsZXMgb24gU1ZHIGVsZW1lbnRzIC0tLVxuXG5cbmxldCBlbGVtZW50ID0gbnVsbCxcbiAgICAvLyB0ZW1wIHZhciBmb3IgY3VycmVudCBTVkcgZWxlbWVudFxudmFsdWVzID0gbnVsbDsgLy8gdGVtcCB2YXIgZm9yIGN1cnJlbnQgdmFsdWVzIGhhc2hcbi8vIEV4dHJhIGNvbmZpZ3VyYXRpb24gZm9yIGNlcnRhaW4gbWFyayB0eXBlc1xuXG5jb25zdCBtYXJrX2V4dHJhcyA9IHtcbiAgZ3JvdXAobWRlZiwgZWwsIGl0ZW0pIHtcbiAgICBjb25zdCBmZyA9IGVsZW1lbnQgPSBlbC5jaGlsZE5vZGVzWzJdO1xuICAgIHZhbHVlcyA9IGZnLl9fdmFsdWVzX187XG4gICAgbWRlZi5mb3JlZ3JvdW5kKGVtaXQsIGl0ZW0sIHRoaXMpO1xuICAgIHZhbHVlcyA9IGVsLl9fdmFsdWVzX187IC8vIHVzZSBwYXJlbnQncyB2YWx1ZXMgaGFzaFxuXG4gICAgZWxlbWVudCA9IGVsLmNoaWxkTm9kZXNbMV07XG4gICAgbWRlZi5jb250ZW50KGVtaXQsIGl0ZW0sIHRoaXMpO1xuICAgIGNvbnN0IGJnID0gZWxlbWVudCA9IGVsLmNoaWxkTm9kZXNbMF07XG4gICAgbWRlZi5iYWNrZ3JvdW5kKGVtaXQsIGl0ZW0sIHRoaXMpO1xuICAgIGNvbnN0IHZhbHVlID0gaXRlbS5tYXJrLmludGVyYWN0aXZlID09PSBmYWxzZSA/ICdub25lJyA6IG51bGw7XG5cbiAgICBpZiAodmFsdWUgIT09IHZhbHVlcy5ldmVudHMpIHtcbiAgICAgIHNldEF0dHJpYnV0ZShmZywgJ3BvaW50ZXItZXZlbnRzJywgdmFsdWUpO1xuICAgICAgc2V0QXR0cmlidXRlKGJnLCAncG9pbnRlci1ldmVudHMnLCB2YWx1ZSk7XG4gICAgICB2YWx1ZXMuZXZlbnRzID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uc3Ryb2tlRm9yZWdyb3VuZCAmJiBpdGVtLnN0cm9rZSkge1xuICAgICAgY29uc3QgZmlsbCA9IGl0ZW0uZmlsbDtcbiAgICAgIHNldEF0dHJpYnV0ZShmZywgJ2Rpc3BsYXknLCBudWxsKTsgLy8gc2V0IHN0eWxlIG9mIGJhY2tncm91bmRcblxuICAgICAgdGhpcy5zdHlsZShiZywgaXRlbSk7XG4gICAgICBzZXRBdHRyaWJ1dGUoYmcsICdzdHJva2UnLCBudWxsKTsgLy8gc2V0IHN0eWxlIG9mIGZvcmVncm91bmRcblxuICAgICAgaWYgKGZpbGwpIGl0ZW0uZmlsbCA9IG51bGw7XG4gICAgICB2YWx1ZXMgPSBmZy5fX3ZhbHVlc19fO1xuICAgICAgdGhpcy5zdHlsZShmZywgaXRlbSk7XG4gICAgICBpZiAoZmlsbCkgaXRlbS5maWxsID0gZmlsbDsgLy8gbGVhdmUgZWxlbWVudCBudWxsIHRvIHByZXZlbnQgZG93bnN0cmVhbSBzdHlsaW5nXG5cbiAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgZm9yZWdyb3VuZCBpcyBpZ25vcmVkXG4gICAgICBzZXRBdHRyaWJ1dGUoZmcsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB9XG4gIH0sXG5cbiAgaW1hZ2UobWRlZiwgZWwsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5zbW9vdGggPT09IGZhbHNlKSB7XG4gICAgICBzZXRTdHlsZShlbCwgJ2ltYWdlLXJlbmRlcmluZycsICdvcHRpbWl6ZVNwZWVkJyk7XG4gICAgICBzZXRTdHlsZShlbCwgJ2ltYWdlLXJlbmRlcmluZycsICdwaXhlbGF0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3R5bGUoZWwsICdpbWFnZS1yZW5kZXJpbmcnLCBudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgdGV4dChtZGVmLCBlbCwgaXRlbSkge1xuICAgIGNvbnN0IHRsID0gdGV4dExpbmVzKGl0ZW0pO1xuICAgIGxldCBrZXksIHZhbHVlLCBkb2MsIGxoO1xuXG4gICAgaWYgKGlzQXJyYXkodGwpKSB7XG4gICAgICAvLyBtdWx0aS1saW5lIHRleHRcbiAgICAgIHZhbHVlID0gdGwubWFwKF8gPT4gdGV4dFZhbHVlKGl0ZW0sIF8pKTtcbiAgICAgIGtleSA9IHZhbHVlLmpvaW4oJ1xcbicpOyAvLyBjb250ZW50IGNhY2hlIGtleVxuXG4gICAgICBpZiAoa2V5ICE9PSB2YWx1ZXMudGV4dCkge1xuICAgICAgICBkb21DbGVhcihlbCwgMCk7XG4gICAgICAgIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGxoID0gbGluZUhlaWdodChpdGVtKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgodCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRzID0gZG9tQ3JlYXRlKGRvYywgJ3RzcGFuJywgc3ZnbnMpO1xuICAgICAgICAgIHRzLl9fZGF0YV9fID0gaXRlbTsgLy8gZGF0YSBiaW5kaW5nXG5cbiAgICAgICAgICB0cy50ZXh0Q29udGVudCA9IHQ7XG5cbiAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgdHMuc2V0QXR0cmlidXRlKCd4JywgMCk7XG4gICAgICAgICAgICB0cy5zZXRBdHRyaWJ1dGUoJ2R5JywgbGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbHVlcy50ZXh0ID0ga2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzaW5nbGUtbGluZSB0ZXh0XG4gICAgICB2YWx1ZSA9IHRleHRWYWx1ZShpdGVtLCB0bCk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWVzLnRleHQpIHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgdmFsdWVzLnRleHQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRBdHRyaWJ1dGUoZWwsICdmb250LWZhbWlseScsIGZvbnRGYW1pbHkoaXRlbSkpO1xuICAgIHNldEF0dHJpYnV0ZShlbCwgJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKGl0ZW0pICsgJ3B4Jyk7XG4gICAgc2V0QXR0cmlidXRlKGVsLCAnZm9udC1zdHlsZScsIGl0ZW0uZm9udFN0eWxlKTtcbiAgICBzZXRBdHRyaWJ1dGUoZWwsICdmb250LXZhcmlhbnQnLCBpdGVtLmZvbnRWYXJpYW50KTtcbiAgICBzZXRBdHRyaWJ1dGUoZWwsICdmb250LXdlaWdodCcsIGl0ZW0uZm9udFdlaWdodCk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gZW1pdChuYW1lLCB2YWx1ZSwgbnMpIHtcbiAgLy8gZWFybHkgZXhpdCBpZiB2YWx1ZSBpcyB1bmNoYW5nZWRcbiAgaWYgKHZhbHVlID09PSB2YWx1ZXNbbmFtZV0pIHJldHVybjsgLy8gdXNlIGFwcHJvcHJpYXRlIG1ldGhvZCBnaXZlbiBuYW1lc3BhY2UgKG5zKVxuXG4gIGlmIChucykge1xuICAgIHNldEF0dHJpYnV0ZU5TKGVsZW1lbnQsIG5hbWUsIHZhbHVlLCBucyk7XG4gIH0gZWxzZSB7XG4gICAgc2V0QXR0cmlidXRlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgfSAvLyBub3RlIGN1cnJlbnQgdmFsdWUgZm9yIGZ1dHVyZSBjb21wYXJpc29uXG5cblxuICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPT0gdmFsdWVzW25hbWVdKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSArICcnKTtcbiAgICB9XG5cbiAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsLCBhdHRycykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIHNldEF0dHJpYnV0ZShlbCwga2V5LCBhdHRyc1trZXldKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gaWYgdmFsdWUgaXMgcHJvdmlkZWQsIHVwZGF0ZSBET00gYXR0cmlidXRlXG4gICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHJlbW92ZSBET00gYXR0cmlidXRlXG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZU5TKGVsLCBuYW1lLCB2YWx1ZSwgbnMpIHtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBpZiB2YWx1ZSBpcyBwcm92aWRlZCwgdXBkYXRlIERPTSBhdHRyaWJ1dGVcbiAgICBlbC5zZXRBdHRyaWJ1dGVOUyhucywgbmFtZSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgcmVtb3ZlIERPTSBhdHRyaWJ1dGVcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyhucywgbmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaHJlZigpIHtcbiAgbGV0IGxvYztcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJycgOiAobG9jID0gd2luZG93LmxvY2F0aW9uKS5oYXNoID8gbG9jLmhyZWYuc2xpY2UoMCwgLWxvYy5oYXNoLmxlbmd0aCkgOiBsb2MuaHJlZjtcbn1cblxuZnVuY3Rpb24gU1ZHU3RyaW5nUmVuZGVyZXIobG9hZGVyKSB7XG4gIFJlbmRlcmVyLmNhbGwodGhpcywgbG9hZGVyKTtcbiAgdGhpcy5fdGV4dCA9IG51bGw7XG4gIHRoaXMuX2RlZnMgPSB7XG4gICAgZ3JhZGllbnQ6IHt9LFxuICAgIGNsaXBwaW5nOiB7fVxuICB9O1xufVxuaW5oZXJpdHMoU1ZHU3RyaW5nUmVuZGVyZXIsIFJlbmRlcmVyLCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZW5kZXJlZCBTVkcgdGV4dCBzdHJpbmcsXG4gICAqIG9yIG51bGwgaWYgcmVuZGVyaW5nIGhhcyBub3QgeWV0IG9jY3VycmVkLlxuICAgKi9cbiAgc3ZnKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCByZW5kZXJpbmcgbWV0aG9kLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgcm9vdCBtYXJrIG9mIGEgc2NlbmVncmFwaCB0byByZW5kZXIuXG4gICAqL1xuICBfcmVuZGVyKHNjZW5lKSB7XG4gICAgY29uc3QgbSA9IG1hcmt1cCgpOyAvLyBzdmcgdGFnXG5cbiAgICBtLm9wZW4oJ3N2ZycsIGV4dGVuZCh7fSwgbWV0YWRhdGEsIHtcbiAgICAgIGNsYXNzOiAnbWFya3MnLFxuICAgICAgd2lkdGg6IHRoaXMuX3dpZHRoICogdGhpcy5fc2NhbGUsXG4gICAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodCAqIHRoaXMuX3NjYWxlLFxuICAgICAgdmlld0JveDogYDAgMCAke3RoaXMuX3dpZHRofSAke3RoaXMuX2hlaWdodH1gXG4gICAgfSkpOyAvLyBiYWNrZ3JvdW5kLCBpZiBkZWZpbmVkXG5cbiAgICBjb25zdCBiZyA9IHRoaXMuX2JnY29sb3I7XG5cbiAgICBpZiAoYmcgJiYgYmcgIT09ICd0cmFuc3BhcmVudCcgJiYgYmcgIT09ICdub25lJykge1xuICAgICAgbS5vcGVuKCdyZWN0Jywge1xuICAgICAgICB3aWR0aDogdGhpcy5fd2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0LFxuICAgICAgICBmaWxsOiBiZ1xuICAgICAgfSkuY2xvc2UoKTtcbiAgICB9IC8vIHJvb3QgY29udGVudCBncm91cFxuXG5cbiAgICBtLm9wZW4oJ2cnLCByb290QXR0cmlidXRlcywge1xuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyB0aGlzLl9vcmlnaW4gKyAnKSdcbiAgICB9KTtcbiAgICB0aGlzLm1hcmsobSwgc2NlbmUpO1xuICAgIG0uY2xvc2UoKTsgLy8gPC9nPlxuICAgIC8vIGRlZnNcblxuICAgIHRoaXMuZGVmcyhtKTsgLy8gZ2V0IFNWRyB0ZXh0IHN0cmluZ1xuXG4gICAgdGhpcy5fdGV4dCA9IG0uY2xvc2UoKSArICcnO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBzZXQgb2YgbWFyayBpdGVtcy5cbiAgICogQHBhcmFtIHtvYmplY3R9IG0gLSBUaGUgbWFya3VwIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSBtYXJrIHBhcmVudCB0byByZW5kZXIuXG4gICAqL1xuICBtYXJrKG0sIHNjZW5lKSB7XG4gICAgY29uc3QgbWRlZiA9IE1hcmtzW3NjZW5lLm1hcmt0eXBlXSxcbiAgICAgICAgICB0YWcgPSBtZGVmLnRhZyxcbiAgICAgICAgICBhdHRyTGlzdCA9IFthcmlhSXRlbUF0dHJpYnV0ZXMsIG1kZWYuYXR0cl07IC8vIHJlbmRlciBvcGVuaW5nIGdyb3VwIHRhZ1xuXG4gICAgbS5vcGVuKCdnJywge1xuICAgICAgJ2NsYXNzJzogY3NzQ2xhc3Moc2NlbmUpLFxuICAgICAgJ2NsaXAtcGF0aCc6IHNjZW5lLmNsaXAgPyBjbGlwJDEodGhpcywgc2NlbmUsIHNjZW5lLmdyb3VwKSA6IG51bGxcbiAgICB9LCBhcmlhTWFya0F0dHJpYnV0ZXMoc2NlbmUpLCB7XG4gICAgICAncG9pbnRlci1ldmVudHMnOiB0YWcgIT09ICdnJyAmJiBzY2VuZS5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsXG4gICAgfSk7IC8vIHJlbmRlciBjb250YWluZWQgZWxlbWVudHNcblxuICAgIGNvbnN0IHByb2Nlc3MgPSBpdGVtID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSB0aGlzLmhyZWYoaXRlbSk7XG4gICAgICBpZiAoaHJlZikgbS5vcGVuKCdhJywgaHJlZik7XG4gICAgICBtLm9wZW4odGFnLCB0aGlzLmF0dHIoc2NlbmUsIGl0ZW0sIGF0dHJMaXN0LCB0YWcgIT09ICdnJyA/IHRhZyA6IG51bGwpKTtcblxuICAgICAgaWYgKHRhZyA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnN0IHRsID0gdGV4dExpbmVzKGl0ZW0pO1xuXG4gICAgICAgIGlmIChpc0FycmF5KHRsKSkge1xuICAgICAgICAgIC8vIG11bHRpLWxpbmUgdGV4dFxuICAgICAgICAgIGNvbnN0IGF0dHJzID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIGR5OiBsaW5lSGVpZ2h0KGl0ZW0pXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG0ub3BlbigndHNwYW4nLCBpID8gYXR0cnMgOiBudWxsKS50ZXh0KHRleHRWYWx1ZShpdGVtLCB0bFtpXSkpLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNpbmdsZS1saW5lIHRleHRcbiAgICAgICAgICBtLnRleHQodGV4dFZhbHVlKGl0ZW0sIHRsKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSAnZycpIHtcbiAgICAgICAgY29uc3QgZm9yZSA9IGl0ZW0uc3Ryb2tlRm9yZWdyb3VuZCxcbiAgICAgICAgICAgICAgZmlsbCA9IGl0ZW0uZmlsbCxcbiAgICAgICAgICAgICAgc3Ryb2tlID0gaXRlbS5zdHJva2U7XG5cbiAgICAgICAgaWYgKGZvcmUgJiYgc3Ryb2tlKSB7XG4gICAgICAgICAgaXRlbS5zdHJva2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbS5vcGVuKCdwYXRoJywgdGhpcy5hdHRyKHNjZW5lLCBpdGVtLCBtZGVmLmJhY2tncm91bmQsICdiZ3JlY3QnKSkuY2xvc2UoKTsgLy8gcmVjdXJzZSBmb3IgZ3JvdXAgY29udGVudFxuXG4gICAgICAgIG0ub3BlbignZycsIHRoaXMuYXR0cihzY2VuZSwgaXRlbSwgbWRlZi5jb250ZW50KSk7XG4gICAgICAgIHZpc2l0KGl0ZW0sIHNjZW5lID0+IHRoaXMubWFyayhtLCBzY2VuZSkpO1xuICAgICAgICBtLmNsb3NlKCk7XG5cbiAgICAgICAgaWYgKGZvcmUgJiYgc3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGZpbGwpIGl0ZW0uZmlsbCA9IG51bGw7XG4gICAgICAgICAgaXRlbS5zdHJva2UgPSBzdHJva2U7XG4gICAgICAgICAgbS5vcGVuKCdwYXRoJywgdGhpcy5hdHRyKHNjZW5lLCBpdGVtLCBtZGVmLmZvcmVncm91bmQsICdiZ3JlY3QnKSkuY2xvc2UoKTtcbiAgICAgICAgICBpZiAoZmlsbCkgaXRlbS5maWxsID0gZmlsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtLm9wZW4oJ3BhdGgnLCB0aGlzLmF0dHIoc2NlbmUsIGl0ZW0sIG1kZWYuZm9yZWdyb3VuZCwgJ2JnZm9yZScpKS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG0uY2xvc2UoKTsgLy8gPC90YWc+XG5cbiAgICAgIGlmIChocmVmKSBtLmNsb3NlKCk7IC8vIDwvYT5cbiAgICB9O1xuXG4gICAgaWYgKG1kZWYubmVzdGVkKSB7XG4gICAgICBpZiAoc2NlbmUuaXRlbXMgJiYgc2NlbmUuaXRlbXMubGVuZ3RoKSBwcm9jZXNzKHNjZW5lLml0ZW1zWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlzaXQoc2NlbmUsIHByb2Nlc3MpO1xuICAgIH0gLy8gcmVuZGVyIGNsb3NpbmcgZ3JvdXAgdGFnXG5cblxuICAgIHJldHVybiBtLmNsb3NlKCk7IC8vIDwvZz5cbiAgfSxcblxuICAvKipcbiAgICogR2V0IGhyZWYgYXR0cmlidXRlcyBmb3IgYSBoeXBlcmxpbmtlZCBtYXJrIGl0ZW0uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBtYXJrIGl0ZW0uXG4gICAqL1xuICBocmVmKGl0ZW0pIHtcbiAgICBjb25zdCBocmVmID0gaXRlbS5ocmVmO1xuICAgIGxldCBhdHRyO1xuXG4gICAgaWYgKGhyZWYpIHtcbiAgICAgIGlmIChhdHRyID0gdGhpcy5faHJlZnMgJiYgdGhpcy5faHJlZnNbaHJlZl0pIHtcbiAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNhbml0aXplVVJMKGhyZWYpLnRoZW4oYXR0ciA9PiB7XG4gICAgICAgICAgLy8gcmV3cml0ZSB0byB1c2UgeGxpbmsgbmFtZXNwYWNlXG4gICAgICAgICAgYXR0clsneGxpbms6aHJlZiddID0gYXR0ci5ocmVmO1xuICAgICAgICAgIGF0dHIuaHJlZiA9IG51bGw7XG4gICAgICAgICAgKHRoaXMuX2hyZWZzIHx8ICh0aGlzLl9ocmVmcyA9IHt9KSlbaHJlZl0gPSBhdHRyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBvZiBTVkcgYXR0cmlidXRlcyBmb3IgYSBtYXJrIGl0ZW0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSBtYXJrIHBhcmVudC5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIG1hcmsgaXRlbS5cbiAgICogQHBhcmFtIHthcnJheXxmdW5jdGlvbn0gYXR0cnMgLSBPbmUgb3IgbW9yZSBhdHRyaWJ1dGUgZW1pdHRlcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgLSBUaGUgdGFnIGJlaW5nIHJlbmRlcmVkLlxuICAgKi9cbiAgYXR0cihzY2VuZSwgaXRlbSwgYXR0cnMsIHRhZykge1xuICAgIGNvbnN0IG9iamVjdCA9IHt9LFxuICAgICAgICAgIGVtaXQgPSAobmFtZSwgdmFsdWUsIG5zLCBwcmVmaXhlZCkgPT4ge1xuICAgICAgb2JqZWN0W3ByZWZpeGVkIHx8IG5hbWVdID0gdmFsdWU7XG4gICAgfTsgLy8gYXBwbHkgbWFyayBzcGVjaWZpYyBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgYXR0cnMuZm9yRWFjaChmbiA9PiBmbihlbWl0LCBpdGVtLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJzKGVtaXQsIGl0ZW0sIHRoaXMpO1xuICAgIH0gLy8gYXBwbHkgc3R5bGUgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAodGFnKSB7XG4gICAgICBzdHlsZShvYmplY3QsIGl0ZW0sIHNjZW5lLCB0YWcsIHRoaXMuX2RlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBTVkcgZGVmcywgYXMgbmVlZGVkLlxuICAgKiBNdXN0IGJlIGNhbGxlZCAqYWZ0ZXIqIG1hcmtzIGhhdmUgYmVlbiBwcm9jZXNzZWQgdG8gZW5zdXJlIHRoZVxuICAgKiBjb2xsZWN0ZWQgc3RhdGUgaXMgY3VycmVudCBhbmQgYWNjdXJhdGUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtIC0gVGhlIG1hcmt1cCBjb250ZXh0LlxuICAgKi9cbiAgZGVmcyhtKSB7XG4gICAgY29uc3QgZ3JhZGllbnQgPSB0aGlzLl9kZWZzLmdyYWRpZW50LFxuICAgICAgICAgIGNsaXBwaW5nID0gdGhpcy5fZGVmcy5jbGlwcGluZyxcbiAgICAgICAgICBjb3VudCA9IE9iamVjdC5rZXlzKGdyYWRpZW50KS5sZW5ndGggKyBPYmplY3Qua2V5cyhjbGlwcGluZykubGVuZ3RoO1xuICAgIGlmIChjb3VudCA9PT0gMCkgcmV0dXJuOyAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICBtLm9wZW4oJ2RlZnMnKTtcblxuICAgIGZvciAoY29uc3QgaWQgaW4gZ3JhZGllbnQpIHtcbiAgICAgIGNvbnN0IGRlZiA9IGdyYWRpZW50W2lkXSxcbiAgICAgICAgICAgIHN0b3BzID0gZGVmLnN0b3BzO1xuXG4gICAgICBpZiAoZGVmLmdyYWRpZW50ID09PSAncmFkaWFsJykge1xuICAgICAgICAvLyBTVkcgcmFkaWFsIGdyYWRpZW50cyBhdXRvbWF0aWNhbGx5IHRyYW5zZm9ybSB0byBub3JtYWxpemVkIGJib3hcbiAgICAgICAgLy8gY29vcmRpbmF0ZXMsIGluIGEgd2F5IHRoYXQgaXMgY3VtYmVyc29tZSB0byByZXBsaWNhdGUgaW4gY2FudmFzLlxuICAgICAgICAvLyBXZSB3cmFwIHRoZSByYWRpYWwgZ3JhZGllbnQgaW4gYSBwYXR0ZXJuIGVsZW1lbnQsIGFsbG93aW5nIHVzIHRvXG4gICAgICAgIC8vIG1haW50YWluIGEgY2lyY3VsYXIgZ3JhZGllbnQgdGhhdCBtYXRjaGVzIHdoYXQgY2FudmFzIHByb3ZpZGVzLlxuICAgICAgICBtLm9wZW4oJ3BhdHRlcm4nLCB7XG4gICAgICAgICAgaWQ6IHBhdHRlcm5QcmVmaXggKyBpZCxcbiAgICAgICAgICB2aWV3Qm94OiAnMCwwLDEsMScsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaWQgc2xpY2UnXG4gICAgICAgIH0pO1xuICAgICAgICBtLm9wZW4oJ3JlY3QnLCB7XG4gICAgICAgICAgd2lkdGg6ICcxJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxJyxcbiAgICAgICAgICBmaWxsOiAndXJsKCMnICsgaWQgKyAnKSdcbiAgICAgICAgfSkuY2xvc2UoKTtcbiAgICAgICAgbS5jbG9zZSgpOyAvLyA8L3BhdHRlcm4+XG5cbiAgICAgICAgbS5vcGVuKCdyYWRpYWxHcmFkaWVudCcsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgZng6IGRlZi54MSxcbiAgICAgICAgICBmeTogZGVmLnkxLFxuICAgICAgICAgIGZyOiBkZWYucjEsXG4gICAgICAgICAgY3g6IGRlZi54MixcbiAgICAgICAgICBjeTogZGVmLnkyLFxuICAgICAgICAgIHI6IGRlZi5yMlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0ub3BlbignbGluZWFyR3JhZGllbnQnLCB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHgxOiBkZWYueDEsXG4gICAgICAgICAgeDI6IGRlZi54MixcbiAgICAgICAgICB5MTogZGVmLnkxLFxuICAgICAgICAgIHkyOiBkZWYueTJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbS5vcGVuKCdzdG9wJywge1xuICAgICAgICAgIG9mZnNldDogc3RvcHNbaV0ub2Zmc2V0LFxuICAgICAgICAgICdzdG9wLWNvbG9yJzogc3RvcHNbaV0uY29sb3JcbiAgICAgICAgfSkuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgbS5jbG9zZSgpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaWQgaW4gY2xpcHBpbmcpIHtcbiAgICAgIGNvbnN0IGRlZiA9IGNsaXBwaW5nW2lkXTtcbiAgICAgIG0ub3BlbignY2xpcFBhdGgnLCB7XG4gICAgICAgIGlkOiBpZFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChkZWYucGF0aCkge1xuICAgICAgICBtLm9wZW4oJ3BhdGgnLCB7XG4gICAgICAgICAgZDogZGVmLnBhdGhcbiAgICAgICAgfSkuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0ub3BlbigncmVjdCcsIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IGRlZi53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGRlZi5oZWlnaHRcbiAgICAgICAgfSkuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgbS5jbG9zZSgpO1xuICAgIH1cblxuICAgIG0uY2xvc2UoKTtcbiAgfVxuXG59KTsgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBhdHRyIGZvciBzdHlsZSBwcmVzZW50YXRpb24gYXR0cmlidXRlc1xuXG5mdW5jdGlvbiBzdHlsZShzLCBpdGVtLCBzY2VuZSwgdGFnLCBkZWZzKSB7XG4gIGlmIChpdGVtID09IG51bGwpIHJldHVybiBzO1xuXG4gIGlmICh0YWcgPT09ICdiZ3JlY3QnICYmIHNjZW5lLmludGVyYWN0aXZlID09PSBmYWxzZSkge1xuICAgIHNbJ3BvaW50ZXItZXZlbnRzJ10gPSAnbm9uZSc7XG4gIH1cblxuICBpZiAodGFnID09PSAnYmdmb3JlJykge1xuICAgIGlmIChzY2VuZS5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHNbJ3BvaW50ZXItZXZlbnRzJ10gPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgcy5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmIChpdGVtLmZpbGwgIT09IG51bGwpIHJldHVybiBzO1xuICB9XG5cbiAgaWYgKHRhZyA9PT0gJ2ltYWdlJyAmJiBpdGVtLnNtb290aCA9PT0gZmFsc2UpIHtcbiAgICBzLnN0eWxlID0gJ2ltYWdlLXJlbmRlcmluZzogb3B0aW1pemVTcGVlZDsgaW1hZ2UtcmVuZGVyaW5nOiBwaXhlbGF0ZWQ7JztcbiAgfVxuXG4gIGlmICh0YWcgPT09ICd0ZXh0Jykge1xuICAgIHNbJ2ZvbnQtZmFtaWx5J10gPSBmb250RmFtaWx5KGl0ZW0pO1xuICAgIHNbJ2ZvbnQtc2l6ZSddID0gZm9udFNpemUoaXRlbSkgKyAncHgnO1xuICAgIHNbJ2ZvbnQtc3R5bGUnXSA9IGl0ZW0uZm9udFN0eWxlO1xuICAgIHNbJ2ZvbnQtdmFyaWFudCddID0gaXRlbS5mb250VmFyaWFudDtcbiAgICBzWydmb250LXdlaWdodCddID0gaXRlbS5mb250V2VpZ2h0O1xuICB9XG5cbiAgZm9yIChjb25zdCBwcm9wIGluIHN0eWxlcykge1xuICAgIGxldCB2YWx1ZSA9IGl0ZW1bcHJvcF07XG4gICAgY29uc3QgbmFtZSA9IHN0eWxlc1twcm9wXTtcblxuICAgIGlmICh2YWx1ZSA9PT0gJ3RyYW5zcGFyZW50JyAmJiAobmFtZSA9PT0gJ2ZpbGwnIHx8IG5hbWUgPT09ICdzdHJva2UnKSkgOyBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNHcmFkaWVudCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBncmFkaWVudFJlZih2YWx1ZSwgZGVmcy5ncmFkaWVudCwgJycpO1xuICAgICAgfVxuXG4gICAgICBzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHM7XG59XG5cbmNvbnN0IENhbnZhcyA9ICdjYW52YXMnO1xuY29uc3QgUE5HID0gJ3BuZyc7XG5jb25zdCBTVkcgPSAnc3ZnJztcbmNvbnN0IE5vbmUgPSAnbm9uZSc7XG5jb25zdCBSZW5kZXJUeXBlID0ge1xuICBDYW52YXM6IENhbnZhcyxcbiAgUE5HOiBQTkcsXG4gIFNWRzogU1ZHLFxuICBOb25lOiBOb25lXG59O1xuY29uc3QgbW9kdWxlcyA9IHt9O1xubW9kdWxlc1tDYW52YXNdID0gbW9kdWxlc1tQTkddID0ge1xuICByZW5kZXJlcjogQ2FudmFzUmVuZGVyZXIsXG4gIGhlYWRsZXNzOiBDYW52YXNSZW5kZXJlcixcbiAgaGFuZGxlcjogQ2FudmFzSGFuZGxlclxufTtcbm1vZHVsZXNbU1ZHXSA9IHtcbiAgcmVuZGVyZXI6IFNWR1JlbmRlcmVyLFxuICBoZWFkbGVzczogU1ZHU3RyaW5nUmVuZGVyZXIsXG4gIGhhbmRsZXI6IFNWR0hhbmRsZXJcbn07XG5tb2R1bGVzW05vbmVdID0ge307XG5mdW5jdGlvbiByZW5kZXJNb2R1bGUobmFtZSwgXykge1xuICBuYW1lID0gU3RyaW5nKG5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgbW9kdWxlc1tuYW1lXSA9IF87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1vZHVsZXNbbmFtZV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0KHNjZW5lLCBib3VuZHMsIGZpbHRlcikge1xuICBjb25zdCBoaXRzID0gW10sXG4gICAgICAgIC8vIGludGVyc2VjdGlvbiByZXN1bHRzXG4gIGJveCA9IG5ldyBCb3VuZHMoKS51bmlvbihib3VuZHMpLFxuICAgICAgICAvLyBkZWZlbnNpdmUgY29weVxuICB0eXBlID0gc2NlbmUubWFya3R5cGU7XG4gIHJldHVybiB0eXBlID8gaW50ZXJzZWN0TWFyayhzY2VuZSwgYm94LCBmaWx0ZXIsIGhpdHMpIDogdHlwZSA9PT0gJ2dyb3VwJyA/IGludGVyc2VjdEdyb3VwKHNjZW5lLCBib3gsIGZpbHRlciwgaGl0cykgOiBlcnJvcignSW50ZXJzZWN0IHNjZW5lIG11c3QgYmUgbWFyayBub2RlIG9yIGdyb3VwIGl0ZW0uJyk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdE1hcmsobWFyaywgYm94LCBmaWx0ZXIsIGhpdHMpIHtcbiAgaWYgKHZpc2l0TWFyayhtYXJrLCBib3gsIGZpbHRlcikpIHtcbiAgICBjb25zdCBpdGVtcyA9IG1hcmsuaXRlbXMsXG4gICAgICAgICAgdHlwZSA9IG1hcmsubWFya3R5cGUsXG4gICAgICAgICAgbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaW50ZXJzZWN0R3JvdXAoaXRlbXNbaV0sIGJveCwgZmlsdGVyLCBoaXRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCB0ZXN0ID0gTWFya3NbdHlwZV0uaXNlY3Q7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaW50ZXJzZWN0SXRlbShpdGVtLCBib3gsIHRlc3QpKSBoaXRzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpdHM7XG59XG5cbmZ1bmN0aW9uIHZpc2l0TWFyayhtYXJrLCBib3gsIGZpbHRlcikge1xuICAvLyBwcm9jZXNzIGlmIGJvdW5kcyBpbnRlcnNlY3QgYW5kIGlmXG4gIC8vICgxKSBtYXJrIGlzIGEgZ3JvdXAgbWFyayAoc28gd2UgbXVzdCByZWN1cnNlKSwgb3JcbiAgLy8gKDIpIG1hcmsgaXMgaW50ZXJhY3RpdmUgYW5kIHBhc3NlcyBmaWx0ZXJcbiAgcmV0dXJuIG1hcmsuYm91bmRzICYmIGJveC5pbnRlcnNlY3RzKG1hcmsuYm91bmRzKSAmJiAobWFyay5tYXJrdHlwZSA9PT0gJ2dyb3VwJyB8fCBtYXJrLmludGVyYWN0aXZlICE9PSBmYWxzZSAmJiAoIWZpbHRlciB8fCBmaWx0ZXIobWFyaykpKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0R3JvdXAoZ3JvdXAsIGJveCwgZmlsdGVyLCBoaXRzKSB7XG4gIC8vIHRlc3QgaW50ZXJzZWN0IGFnYWluc3QgZ3JvdXBcbiAgLy8gc2tpcCBncm91cHMgYnkgZGVmYXVsdCB1bmxlc3MgZmlsdGVyIHNheXMgb3RoZXJ3aXNlXG4gIGlmIChmaWx0ZXIgJiYgZmlsdGVyKGdyb3VwLm1hcmspICYmIGludGVyc2VjdEl0ZW0oZ3JvdXAsIGJveCwgTWFya3MuZ3JvdXAuaXNlY3QpKSB7XG4gICAgaGl0cy5wdXNoKGdyb3VwKTtcbiAgfSAvLyByZWN1cnNpdmVseSB0ZXN0IGNoaWxkcmVuIG1hcmtzXG4gIC8vIHRyYW5zbGF0ZSBib3ggdG8gZ3JvdXAgY29vcmRpbmF0ZSBzcGFjZVxuXG5cbiAgY29uc3QgbWFya3MgPSBncm91cC5pdGVtcyxcbiAgICAgICAgbiA9IG1hcmtzICYmIG1hcmtzLmxlbmd0aDtcblxuICBpZiAobikge1xuICAgIGNvbnN0IHggPSBncm91cC54IHx8IDAsXG4gICAgICAgICAgeSA9IGdyb3VwLnkgfHwgMDtcbiAgICBib3gudHJhbnNsYXRlKC14LCAteSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaW50ZXJzZWN0TWFyayhtYXJrc1tpXSwgYm94LCBmaWx0ZXIsIGhpdHMpO1xuICAgIH1cblxuICAgIGJveC50cmFuc2xhdGUoeCwgeSk7XG4gIH1cblxuICByZXR1cm4gaGl0cztcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0SXRlbShpdGVtLCBib3gsIHRlc3QpIHtcbiAgLy8gdGVzdCBib3VuZHMgZW5jbG9zdXJlLCBib3VuZHMgaW50ZXJzZWN0aW9uLCB0aGVuIGRldGFpbGVkIHRlc3RcbiAgY29uc3QgYm91bmRzID0gaXRlbS5ib3VuZHM7XG4gIHJldHVybiBib3guZW5jbG9zZXMoYm91bmRzKSB8fCBib3guaW50ZXJzZWN0cyhib3VuZHMpICYmIHRlc3QoaXRlbSwgYm94KTtcbn1cblxuY29uc3QgY2xpcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbmZ1bmN0aW9uIGJvdW5kQ2xpcCAobWFyaykge1xuICBjb25zdCBjbGlwID0gbWFyay5jbGlwO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGNsaXApKSB7XG4gICAgY2xpcChib3VuZENvbnRleHQoY2xpcEJvdW5kcy5jbGVhcigpKSk7XG4gIH0gZWxzZSBpZiAoY2xpcCkge1xuICAgIGNsaXBCb3VuZHMuc2V0KDAsIDAsIG1hcmsuZ3JvdXAud2lkdGgsIG1hcmsuZ3JvdXAuaGVpZ2h0KTtcbiAgfSBlbHNlIHJldHVybjtcblxuICBtYXJrLmJvdW5kcy5pbnRlcnNlY3QoY2xpcEJvdW5kcyk7XG59XG5cbmNvbnN0IFRPTEVSQU5DRSA9IDFlLTk7XG5mdW5jdGlvbiBzY2VuZUVxdWFsKGEsIGIsIGtleSkge1xuICByZXR1cm4gYSA9PT0gYiA/IHRydWUgOiBrZXkgPT09ICdwYXRoJyA/IHBhdGhFcXVhbChhLCBiKSA6IGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlID8gK2EgPT09ICtiIDogaXNOdW1iZXIoYSkgJiYgaXNOdW1iZXIoYikgPyBNYXRoLmFicyhhIC0gYikgPD0gVE9MRVJBTkNFIDogIWEgfHwgIWIgfHwgIWlzT2JqZWN0KGEpICYmICFpc09iamVjdChiKSA/IGEgPT0gYiA6IG9iamVjdEVxdWFsKGEsIGIpO1xufVxuZnVuY3Rpb24gcGF0aEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIHNjZW5lRXF1YWwocGF0aFBhcnNlKGEpLCBwYXRoUGFyc2UoYikpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RFcXVhbChhLCBiKSB7XG4gIHZhciBrYSA9IE9iamVjdC5rZXlzKGEpLFxuICAgICAga2IgPSBPYmplY3Qua2V5cyhiKSxcbiAgICAgIGtleSxcbiAgICAgIGk7XG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcblxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIXNjZW5lRXF1YWwoYVtrZXldLCBiW2tleV0sIGtleSkpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG5cbmZ1bmN0aW9uIHJlc2V0U1ZHRGVmSWRzKCkge1xuICByZXNldFNWR0NsaXBJZCgpO1xuICByZXNldFNWR0dyYWRpZW50SWQoKTtcbn1cblxuZXhwb3J0IHsgQm91bmRzLCBDYW52YXNIYW5kbGVyLCBDYW52YXNSZW5kZXJlciwgR3JhZGllbnQsIEdyb3VwSXRlbSwgSGFuZGxlciwgSXRlbSwgTWFya3MsIFJlbmRlclR5cGUsIFJlbmRlcmVyLCBSZXNvdXJjZUxvYWRlciwgU1ZHSGFuZGxlciwgU1ZHUmVuZGVyZXIsIFNWR1N0cmluZ1JlbmRlcmVyLCBTY2VuZWdyYXBoLCBib3VuZENsaXAsIGJvdW5kQ29udGV4dCwgYm91bmRJdGVtLCBib3VuZE1hcmssIGJvdW5kU3Ryb2tlLCBkb21DaGlsZCwgZG9tQ2xlYXIsIGRvbUNyZWF0ZSwgZG9tRmluZCwgZm9udCwgZm9udEZhbWlseSwgZm9udFNpemUsIGludGVyc2VjdCwgaW50ZXJzZWN0Qm94TGluZSwgaW50ZXJzZWN0UGF0aCwgaW50ZXJzZWN0UG9pbnQsIGludGVyc2VjdFJ1bGUsIGxpbmVIZWlnaHQsIG1hcmt1cCwgbXVsdGlMaW5lT2Zmc2V0LCBjdXJ2ZXMgYXMgcGF0aEN1cnZlcywgcGF0aEVxdWFsLCBwYXRoUGFyc2UsIHZnX3JlY3QgYXMgcGF0aFJlY3RhbmdsZSwgcGF0aFJlbmRlciwgc3ltYm9scyBhcyBwYXRoU3ltYm9scywgdmdfdHJhaWwgYXMgcGF0aFRyYWlsLCBwb2ludCwgcmVuZGVyTW9kdWxlLCByZXNldFNWR0NsaXBJZCwgcmVzZXRTVkdEZWZJZHMsIHNjZW5lRXF1YWwsIHNjZW5lRnJvbUpTT04sIHBpY2tWaXNpdCBhcyBzY2VuZVBpY2tWaXNpdCwgc2NlbmVUb0pTT04sIHZpc2l0IGFzIHNjZW5lVmlzaXQsIHpvcmRlciBhcyBzY2VuZVpPcmRlciwgc2VyaWFsaXplWE1MLCB0ZXh0TWV0cmljcyB9O1xuIiwiaW1wb3J0IHsgZmllbGQsIGlzRGF0ZSwgdG9OdW1iZXIsIGlzQXJyYXksIGlucmFuZ2UsIGV4dGVuZCwgYXJyYXksIGVycm9yLCBwZWVrLCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBMaXRlcmFsIH0gZnJvbSAndmVnYS1leHByZXNzaW9uJztcblxuZnVuY3Rpb24gYXNjZW5kaW5nIChhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cblxuZnVuY3Rpb24gYmlzZWN0b3IgKGYpIHtcbiAgbGV0IGRlbHRhID0gZjtcbiAgbGV0IGNvbXBhcmUgPSBmO1xuXG4gIGlmIChmLmxlbmd0aCA9PT0gMSkge1xuICAgIGRlbHRhID0gKGQsIHgpID0+IGYoZCkgLSB4O1xuXG4gICAgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoZik7XG4gIH1cblxuICBmdW5jdGlvbiBsZWZ0KGEsIHgsIGxvLCBoaSkge1xuICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7ZWxzZSBoaSA9IG1pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiByaWdodChhLCB4LCBsbywgaGkpIHtcbiAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIGNvbnN0IG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkgaGkgPSBtaWQ7ZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudGVyKGEsIHgsIGxvLCBoaSkge1xuICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgY29uc3QgaSA9IGxlZnQoYSwgeCwgbG8sIGhpIC0gMSk7XG4gICAgcmV0dXJuIGkgPiBsbyAmJiBkZWx0YShhW2kgLSAxXSwgeCkgPiAtZGVsdGEoYVtpXSwgeCkgPyBpIC0gMSA6IGk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlZnQsXG4gICAgY2VudGVyLFxuICAgIHJpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZ0NvbXBhcmF0b3IoZikge1xuICByZXR1cm4gKGQsIHgpID0+IGFzY2VuZGluZyhmKGQpLCB4KTtcbn1cblxuY29uc3QgSW50ZXJzZWN0ID0gJ2ludGVyc2VjdCc7XG5jb25zdCBVbmlvbiA9ICd1bmlvbic7XG5jb25zdCBWbE11bHRpID0gJ3ZsTXVsdGknO1xuY29uc3QgVmxQb2ludCA9ICd2bFBvaW50JztcbmNvbnN0IE9yID0gJ29yJztcbmNvbnN0IEFuZCA9ICdhbmQnO1xuXG5jb25zdCBTRUxFQ1RJT05fSUQgPSAnX3Znc2lkXycsXG4gICAgICBUWVBFX0VOVU0gPSAnRScsXG4gICAgICBUWVBFX1JBTkdFX0lOQyA9ICdSJyxcbiAgICAgIFRZUEVfUkFOR0VfRVhDID0gJ1ItRScsXG4gICAgICBUWVBFX1JBTkdFX0xFID0gJ1ItTEUnLFxuICAgICAgVFlQRV9SQU5HRV9SRSA9ICdSLVJFJyxcbiAgICAgIFVOSVRfSU5ERVggPSAnaW5kZXg6dW5pdCc7IC8vIFRPRE86IHJldmlzaXQgZGF0ZSBjb2VyY2lvbj9cblxuZnVuY3Rpb24gdGVzdFBvaW50KGRhdHVtLCBlbnRyeSkge1xuICB2YXIgZmllbGRzID0gZW50cnkuZmllbGRzLFxuICAgICAgdmFsdWVzID0gZW50cnkudmFsdWVzLFxuICAgICAgbiA9IGZpZWxkcy5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGR2YWwsXG4gICAgICBmO1xuXG4gIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgZiA9IGZpZWxkc1tpXTtcbiAgICBmLmdldHRlciA9IGZpZWxkLmdldHRlciB8fCBmaWVsZChmLmZpZWxkKTtcbiAgICBkdmFsID0gZi5nZXR0ZXIoZGF0dW0pO1xuICAgIGlmIChpc0RhdGUoZHZhbCkpIGR2YWwgPSB0b051bWJlcihkdmFsKTtcbiAgICBpZiAoaXNEYXRlKHZhbHVlc1tpXSkpIHZhbHVlc1tpXSA9IHRvTnVtYmVyKHZhbHVlc1tpXSk7XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZXNbaV1bMF0pKSB2YWx1ZXNbaV0gPSB2YWx1ZXNbaV0ubWFwKHRvTnVtYmVyKTtcblxuICAgIGlmIChmLnR5cGUgPT09IFRZUEVfRU5VTSkge1xuICAgICAgLy8gRW51bWVyYXRlZCBmaWVsZHMgY2FuIGVpdGhlciBzcGVjaWZ5IGluZGl2aWR1YWwgdmFsdWVzIChzaW5nbGUvbXVsdGkgc2VsZWN0aW9ucylcbiAgICAgIC8vIG9yIGFuIGFycmF5IG9mIHZhbHVlcyAoaW50ZXJ2YWwgc2VsZWN0aW9ucykuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZXNbaV0pID8gdmFsdWVzW2ldLmluZGV4T2YoZHZhbCkgPCAwIDogZHZhbCAhPT0gdmFsdWVzW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGYudHlwZSA9PT0gVFlQRV9SQU5HRV9JTkMpIHtcbiAgICAgICAgaWYgKCFpbnJhbmdlKGR2YWwsIHZhbHVlc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSBUWVBFX1JBTkdFX1JFKSB7XG4gICAgICAgIC8vIERpc2NyZXRlIHNlbGVjdGlvbiBvZiBiaW5zIHRlc3Qgd2l0aGluIHRoZSByYW5nZSBbYmluX3N0YXJ0LCBiaW5fZW5kKS5cbiAgICAgICAgaWYgKCFpbnJhbmdlKGR2YWwsIHZhbHVlc1tpXSwgdHJ1ZSwgZmFsc2UpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGYudHlwZSA9PT0gVFlQRV9SQU5HRV9FWEMpIHtcbiAgICAgICAgLy8gJ1ItRScvJ1ItTEUnIGluY2x1ZGVkIGZvciBjb21wbGV0ZW5lc3MuXG4gICAgICAgIGlmICghaW5yYW5nZShkdmFsLCB2YWx1ZXNbaV0sIGZhbHNlLCBmYWxzZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSBUWVBFX1JBTkdFX0xFKSB7XG4gICAgICAgIGlmICghaW5yYW5nZShkdmFsLCB2YWx1ZXNbaV0sIGZhbHNlLCB0cnVlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBUZXN0cyBpZiBhIHR1cGxlIGlzIGNvbnRhaW5lZCB3aXRoaW4gYW4gaW50ZXJhY3RpdmUgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZGF0YSBzZXQgcmVwcmVzZW50aW5nIHRoZSBzZWxlY3Rpb24uXG4gKiAgVHVwbGVzIGluIHRoZSBkYXRhc2V0IGFyZSBvZiB0aGUgZm9ybVxuICogIHt1bml0OiBzdHJpbmcsIGZpZWxkczogYXJyYXk8ZmllbGRkZWY+LCB2YWx1ZXM6IGFycmF5PCo+fS5cbiAqICBGaWVsZGRlZiBpcyBvZiB0aGUgZm9ybVxuICogIHtmaWVsZDogc3RyaW5nLCBjaGFubmVsOiBzdHJpbmcsIHR5cGU6ICdFJyB8ICdSJ30gd2hlcmVcbiAqICAndHlwZScgaWRlbnRpZmllcyB3aGV0aGVyIHR1cGxlcyBpbiB0aGUgZGF0YXNldCBlbnVtZXJhdGVcbiAqICB2YWx1ZXMgZm9yIHRoZSBmaWVsZCwgb3Igc3BlY2lmeSBhIGNvbnRpbnVvdXMgcmFuZ2UuXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0dW0gLSBUaGUgdHVwbGUgdG8gdGVzdCBmb3IgaW5jbHVzaW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wIC0gVGhlIHNldCBvcGVyYXRpb24gZm9yIGNvbWJpbmluZyBzZWxlY3Rpb25zLlxuICogICBPbmUgb2YgJ2ludGVyc2VjdCcgb3IgJ3VuaW9uJyAoZGVmYXVsdCkuXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGRhdHVtIGlzIGluIHRoZSBzZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNlbGVjdGlvblRlc3QobmFtZSwgZGF0dW0sIG9wKSB7XG4gIHZhciBkYXRhID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV0sXG4gICAgICBlbnRyaWVzID0gZGF0YSA/IGRhdGEudmFsdWVzLnZhbHVlIDogW10sXG4gICAgICB1bml0SWR4ID0gZGF0YSA/IGRhdGFbVU5JVF9JTkRFWF0gJiYgZGF0YVtVTklUX0lOREVYXS52YWx1ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGludGVyc2VjdCA9IG9wID09PSBJbnRlcnNlY3QsXG4gICAgICBuID0gZW50cmllcy5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGVudHJ5LFxuICAgICAgbWlzcyxcbiAgICAgIGNvdW50LFxuICAgICAgdW5pdCxcbiAgICAgIGI7XG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBlbnRyeSA9IGVudHJpZXNbaV07XG5cbiAgICBpZiAodW5pdElkeCAmJiBpbnRlcnNlY3QpIHtcbiAgICAgIC8vIG11bHRpIHNlbGVjdGlvbnMgdW5pb24gd2l0aGluIHRoZSBzYW1lIHVuaXQgYW5kIGludGVyc2VjdCBhY3Jvc3MgdW5pdHMuXG4gICAgICBtaXNzID0gbWlzcyB8fCB7fTtcbiAgICAgIGNvdW50ID0gbWlzc1t1bml0ID0gZW50cnkudW5pdF0gfHwgMDsgLy8gaWYgd2UndmUgYWxyZWFkeSBtYXRjaGVkIHRoaXMgdW5pdCwgc2tpcC5cblxuICAgICAgaWYgKGNvdW50ID09PSAtMSkgY29udGludWU7XG4gICAgICBiID0gdGVzdFBvaW50KGRhdHVtLCBlbnRyeSk7XG4gICAgICBtaXNzW3VuaXRdID0gYiA/IC0xIDogKytjb3VudDsgLy8gaWYgd2UgbWF0Y2ggYW5kIHRoZXJlIGFyZSBubyBvdGhlciB1bml0cyByZXR1cm4gdHJ1ZVxuICAgICAgLy8gaWYgd2UndmUgbWlzc2VkIGFnYWluc3QgYWxsIHR1cGxlcyBpbiB0aGlzIHVuaXQgcmV0dXJuIGZhbHNlXG5cbiAgICAgIGlmIChiICYmIHVuaXRJZHguc2l6ZSA9PT0gMSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoIWIgJiYgY291bnQgPT09IHVuaXRJZHguZ2V0KHVuaXQpLmNvdW50KSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0ZXN0UG9pbnQoZGF0dW0sIGVudHJ5KTsgLy8gaWYgd2UgZmluZCBhIG1pc3MgYW5kIHdlIGRvIHJlcXVpcmUgaW50ZXJzZWN0aW9uIHJldHVybiBmYWxzZVxuICAgICAgLy8gaWYgd2UgZmluZCBhIG1hdGNoIGFuZCB3ZSBkb24ndCByZXF1aXJlIGludGVyc2VjdGlvbiByZXR1cm4gdHJ1ZVxuXG4gICAgICBpZiAoaW50ZXJzZWN0IF4gYikgcmV0dXJuIGI7XG4gICAgfVxuICB9IC8vIGlmIGludGVyc2VjdGluZyBhbmQgd2UgbWFkZSBpdCBoZXJlLCB0aGVuIHdlIHNhdyBubyBtaXNzZXNcbiAgLy8gaWYgbm90IGludGVyc2VjdGluZywgdGhlbiB3ZSBzYXcgbm8gbWF0Y2hlc1xuICAvLyBpZiBubyBhY3RpdmUgc2VsZWN0aW9ucywgcmV0dXJuIGZhbHNlXG5cblxuICByZXR1cm4gbiAmJiBpbnRlcnNlY3Q7XG59XG5jb25zdCBzZWxlY3Rpb25JZCA9IGZpZWxkKFNFTEVDVElPTl9JRCksXG4gICAgICBiaXNlY3QgPSBiaXNlY3RvcihzZWxlY3Rpb25JZCksXG4gICAgICBiaXNlY3RMZWZ0ID0gYmlzZWN0LmxlZnQsXG4gICAgICBiaXNlY3RSaWdodCA9IGJpc2VjdC5yaWdodDtcbmZ1bmN0aW9uIHNlbGVjdGlvbklkVGVzdChuYW1lLCBkYXR1bSwgb3ApIHtcbiAgY29uc3QgZGF0YSA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdLFxuICAgICAgICBlbnRyaWVzID0gZGF0YSA/IGRhdGEudmFsdWVzLnZhbHVlIDogW10sXG4gICAgICAgIHVuaXRJZHggPSBkYXRhID8gZGF0YVtVTklUX0lOREVYXSAmJiBkYXRhW1VOSVRfSU5ERVhdLnZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgICBpbnRlcnNlY3QgPSBvcCA9PT0gSW50ZXJzZWN0LFxuICAgICAgICB2YWx1ZSA9IHNlbGVjdGlvbklkKGRhdHVtKSxcbiAgICAgICAgaW5kZXggPSBiaXNlY3RMZWZ0KGVudHJpZXMsIHZhbHVlKTtcbiAgaWYgKGluZGV4ID09PSBlbnRyaWVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2VsZWN0aW9uSWQoZW50cmllc1tpbmRleF0pICE9PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh1bml0SWR4ICYmIGludGVyc2VjdCkge1xuICAgIGlmICh1bml0SWR4LnNpemUgPT09IDEpIHJldHVybiB0cnVlO1xuICAgIGlmIChiaXNlY3RSaWdodChlbnRyaWVzLCB2YWx1ZSkgLSBpbmRleCA8IHVuaXRJZHguc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogTWFwcyBhbiBhcnJheSBvZiBzY2VuZSBncmFwaCBpdGVtcyB0byBhbiBhcnJheSBvZiBzZWxlY3Rpb24gdHVwbGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgIC0gVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgcmVwcmVzZW50aW5nIHRoZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAgLSBUaGUgbmFtZSBvZiB0aGUgdW5pdCB2aWV3LlxuICpcbiAqIEByZXR1cm5zIHthcnJheX0gQW4gYXJyYXkgb2Ygc2VsZWN0aW9uIGVudHJpZXMgZm9yIHRoZSBnaXZlbiB1bml0LlxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdGlvblR1cGxlcyhhcnJheSwgYmFzZSkge1xuICByZXR1cm4gYXJyYXkubWFwKHggPT4gZXh0ZW5kKHtcbiAgICB2YWx1ZXM6IGJhc2UuZmllbGRzLm1hcChmID0+IChmLmdldHRlciB8fCAoZi5nZXR0ZXIgPSBmaWVsZChmLmZpZWxkKSkpKHguZGF0dW0pKVxuICB9LCBiYXNlKSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgc2VsZWN0aW9uIGZvciB1c2UgYXMgYSBzY2FsZSBkb21haW4gb3IgcmVhZHMgdmlhIHRoZSBBUEkuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0IHJlcHJlc2VudGluZyB0aGUgc2VsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wPSd1bmlvbiddIC0gVGhlIHNldCBvcGVyYXRpb24gZm9yIGNvbWJpbmluZyBzZWxlY3Rpb25zLlxuICogICAgICAgICAgICAgICAgIE9uZSBvZiAnaW50ZXJzZWN0JyBvciAndW5pb24nIChkZWZhdWx0KS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNdWx0aSAtIElkZW50aWZpZXMgYSBcIm11bHRpXCIgc2VsZWN0aW9uIHRvIHBlcmZvcm0gbW9yZVxuICogICAgICAgICAgICAgICAgIGV4cGVuc2l2ZSByZXNvbHV0aW9uIGNvbXB1dGF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSB2bDUgLSBXaXRoIFZlZ2EtTGl0ZSB2NSwgXCJtdWx0aVwiIHNlbGVjdGlvbnMgYXJlIG5vdyBjYWxsZWQgXCJwb2ludFwiXG4gKiAgICAgICAgICAgICAgICAgc2VsZWN0aW9ucywgYW5kIHRodXMgdGhlIHJlc29sdmVkIHR1cGxlIHNob3VsZCByZWZsZWN0IHRoaXMgbmFtZS5cbiAqICAgICAgICAgICAgICAgICBUaGlzIHBhcmFtZXRlciBhbGxvd3MgdXMgdG8gcmVmbGVjdCB0aGlzIGNoYW5nZSB3aXRob3V0IHRyaWdnZXJpbmdcbiAqICAgICAgICAgICAgICAgICBhIG1ham9yIHZlcnNpb24gYnVtcCBmb3IgVmVnYS5cbiAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCBvZiBzZWxlY3RlZCBmaWVsZHMgYW5kIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3Rpb25SZXNvbHZlKG5hbWUsIG9wLCBpc011bHRpLCB2bDUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLmNvbnRleHQuZGF0YVtuYW1lXSxcbiAgICAgIGVudHJpZXMgPSBkYXRhID8gZGF0YS52YWx1ZXMudmFsdWUgOiBbXSxcbiAgICAgIHJlc29sdmVkID0ge30sXG4gICAgICBtdWx0aVJlcyA9IHt9LFxuICAgICAgdHlwZXMgPSB7fSxcbiAgICAgIGVudHJ5LFxuICAgICAgZmllbGRzLFxuICAgICAgdmFsdWVzLFxuICAgICAgdW5pdCxcbiAgICAgIGZpZWxkLFxuICAgICAgcmVzLFxuICAgICAgcmVzVW5pdCxcbiAgICAgIHR5cGUsXG4gICAgICB1bmlvbixcbiAgICAgIG4gPSBlbnRyaWVzLmxlbmd0aCxcbiAgICAgIGkgPSAwLFxuICAgICAgaixcbiAgICAgIG07IC8vIEZpcnN0IHVuaW9uIGFsbCBlbnRyaWVzIHdpdGhpbiB0aGUgc2FtZSB1bml0LlxuXG4gIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgIHVuaXQgPSBlbnRyeS51bml0O1xuICAgIGZpZWxkcyA9IGVudHJ5LmZpZWxkcztcbiAgICB2YWx1ZXMgPSBlbnRyeS52YWx1ZXM7XG5cbiAgICBmb3IgKGogPSAwLCBtID0gZmllbGRzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICByZXMgPSByZXNvbHZlZFtmaWVsZC5maWVsZF0gfHwgKHJlc29sdmVkW2ZpZWxkLmZpZWxkXSA9IHt9KTtcbiAgICAgIHJlc1VuaXQgPSByZXNbdW5pdF0gfHwgKHJlc1t1bml0XSA9IFtdKTtcbiAgICAgIHR5cGVzW2ZpZWxkLmZpZWxkXSA9IHR5cGUgPSBmaWVsZC50eXBlLmNoYXJBdCgwKTtcbiAgICAgIHVuaW9uID0gb3BzW3R5cGUgKyAnX3VuaW9uJ107XG4gICAgICByZXNbdW5pdF0gPSB1bmlvbihyZXNVbml0LCBhcnJheSh2YWx1ZXNbal0pKTtcbiAgICB9IC8vIElmIHRoZSBzYW1lIG11bHRpLXNlbGVjdGlvbiBpcyByZXBlYXRlZCBvdmVyIHZpZXdzIGFuZCBwcm9qZWN0ZWQgb3ZlclxuICAgIC8vIGFuIGVuY29kaW5nLCBpdCBtYXkgb3BlcmF0ZSBvdmVyIGRpZmZlcmVudCBmaWVsZHMgbWFraW5nIGl0IGVzcGVjaWFsbHlcbiAgICAvLyB0cmlja3kgdG8gcmVsaWFibHkgcmVzb2x2ZSBpdC4gQXQgYmVzdCwgd2UgY2FuIGRlLWR1cGUgaWRlbnRpY2FsIGVudHJpZXNcbiAgICAvLyBidXQgZG9pbmcgc28gbWF5IGJlIG1vcmUgY29tcHV0YXRpb25hbGx5IGV4cGVuc2l2ZSB0aGFuIGl0IGlzIHdvcnRoLlxuICAgIC8vIEluc3RlYWQsIGZvciBub3csIHdlIHNpbXBseSB0cmFuc2Zvcm0gb3VyIHN0b3JlIHJlcHJlc2VudGF0aW9uIGludG9cbiAgICAvLyBhIG1vcmUgaHVtYW4tZnJpZW5kbHkgb25lLlxuXG5cbiAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgcmVzVW5pdCA9IG11bHRpUmVzW3VuaXRdIHx8IChtdWx0aVJlc1t1bml0XSA9IFtdKTtcbiAgICAgIHJlc1VuaXQucHVzaChhcnJheSh2YWx1ZXMpLnJlZHVjZSgob2JqLCBjdXJyLCBqKSA9PiAob2JqW2ZpZWxkc1tqXS5maWVsZF0gPSBjdXJyLCBvYmopLCB7fSkpO1xuICAgIH1cbiAgfSAvLyBUaGVuIHJlc29sdmUgZmllbGRzIGFjcm9zcyB1bml0cyBhcyBwZXIgdGhlIG9wLlxuXG5cbiAgb3AgPSBvcCB8fCBVbmlvbjtcbiAgT2JqZWN0LmtleXMocmVzb2x2ZWQpLmZvckVhY2goZmllbGQgPT4ge1xuICAgIHJlc29sdmVkW2ZpZWxkXSA9IE9iamVjdC5rZXlzKHJlc29sdmVkW2ZpZWxkXSkubWFwKHVuaXQgPT4gcmVzb2x2ZWRbZmllbGRdW3VuaXRdKS5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjID09PSB1bmRlZmluZWQgPyBjdXJyIDogb3BzW3R5cGVzW2ZpZWxkXSArICdfJyArIG9wXShhY2MsIGN1cnIpKTtcbiAgfSk7XG4gIGVudHJpZXMgPSBPYmplY3Qua2V5cyhtdWx0aVJlcyk7XG5cbiAgaWYgKGlzTXVsdGkgJiYgZW50cmllcy5sZW5ndGgpIHtcbiAgICBjb25zdCBrZXkgPSB2bDUgPyBWbFBvaW50IDogVmxNdWx0aTtcbiAgICByZXNvbHZlZFtrZXldID0gb3AgPT09IFVuaW9uID8ge1xuICAgICAgW09yXTogZW50cmllcy5yZWR1Y2UoKGFjYywgaykgPT4gKGFjYy5wdXNoKC4uLm11bHRpUmVzW2tdKSwgYWNjKSwgW10pXG4gICAgfSA6IHtcbiAgICAgIFtBbmRdOiBlbnRyaWVzLm1hcChrID0+ICh7XG4gICAgICAgIFtPcl06IG11bHRpUmVzW2tdXG4gICAgICB9KSlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHJlc29sdmVkO1xufVxudmFyIG9wcyA9IHtcbiAgRV91bmlvbjogZnVuY3Rpb24gKGJhc2UsIHZhbHVlKSB7XG4gICAgaWYgKCFiYXNlLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbiA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbjsgKytpKSBpZiAoYmFzZS5pbmRleE9mKHZhbHVlW2ldKSA8IDApIGJhc2UucHVzaCh2YWx1ZVtpXSk7XG5cbiAgICByZXR1cm4gYmFzZTtcbiAgfSxcbiAgRV9pbnRlcnNlY3Q6IGZ1bmN0aW9uIChiYXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiAhYmFzZS5sZW5ndGggPyB2YWx1ZSA6IGJhc2UuZmlsdGVyKHYgPT4gdmFsdWUuaW5kZXhPZih2KSA+PSAwKTtcbiAgfSxcbiAgUl91bmlvbjogZnVuY3Rpb24gKGJhc2UsIHZhbHVlKSB7XG4gICAgdmFyIGxvID0gdG9OdW1iZXIodmFsdWVbMF0pLFxuICAgICAgICBoaSA9IHRvTnVtYmVyKHZhbHVlWzFdKTtcblxuICAgIGlmIChsbyA+IGhpKSB7XG4gICAgICBsbyA9IHZhbHVlWzFdO1xuICAgICAgaGkgPSB2YWx1ZVswXTtcbiAgICB9XG5cbiAgICBpZiAoIWJhc2UubGVuZ3RoKSByZXR1cm4gW2xvLCBoaV07XG4gICAgaWYgKGJhc2VbMF0gPiBsbykgYmFzZVswXSA9IGxvO1xuICAgIGlmIChiYXNlWzFdIDwgaGkpIGJhc2VbMV0gPSBoaTtcbiAgICByZXR1cm4gYmFzZTtcbiAgfSxcbiAgUl9pbnRlcnNlY3Q6IGZ1bmN0aW9uIChiYXNlLCB2YWx1ZSkge1xuICAgIHZhciBsbyA9IHRvTnVtYmVyKHZhbHVlWzBdKSxcbiAgICAgICAgaGkgPSB0b051bWJlcih2YWx1ZVsxXSk7XG5cbiAgICBpZiAobG8gPiBoaSkge1xuICAgICAgbG8gPSB2YWx1ZVsxXTtcbiAgICAgIGhpID0gdmFsdWVbMF07XG4gICAgfVxuXG4gICAgaWYgKCFiYXNlLmxlbmd0aCkgcmV0dXJuIFtsbywgaGldO1xuXG4gICAgaWYgKGhpIDwgYmFzZVswXSB8fCBiYXNlWzFdIDwgbG8pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGJhc2VbMF0gPCBsbykgYmFzZVswXSA9IGxvO1xuICAgICAgaWYgKGJhc2VbMV0gPiBoaSkgYmFzZVsxXSA9IGhpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xuICB9XG59O1xuXG5jb25zdCBEYXRhUHJlZml4ID0gJzonLFxuICAgICAgSW5kZXhQcmVmaXggPSAnQCc7XG5mdW5jdGlvbiBzZWxlY3Rpb25WaXNpdG9yKG5hbWUsIGFyZ3MsIHNjb3BlLCBwYXJhbXMpIHtcbiAgaWYgKGFyZ3NbMF0udHlwZSAhPT0gTGl0ZXJhbCkgZXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHNlbGVjdGlvbiBmdW5jdGlvbnMgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLicpO1xuICBjb25zdCBkYXRhID0gYXJnc1swXS52YWx1ZSxcbiAgICAgICAgb3AgPSBhcmdzLmxlbmd0aCA+PSAyICYmIHBlZWsoYXJncykudmFsdWUsXG4gICAgICAgIGZpZWxkID0gJ3VuaXQnLFxuICAgICAgICBpbmRleE5hbWUgPSBJbmRleFByZWZpeCArIGZpZWxkLFxuICAgICAgICBkYXRhTmFtZSA9IERhdGFQcmVmaXggKyBkYXRhOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5cbiAgaWYgKG9wID09PSBJbnRlcnNlY3QgJiYgIWhhc093blByb3BlcnR5KHBhcmFtcywgaW5kZXhOYW1lKSkge1xuICAgIHBhcmFtc1tpbmRleE5hbWVdID0gc2NvcGUuZ2V0RGF0YShkYXRhKS5pbmRhdGFSZWYoc2NvcGUsIGZpZWxkKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5cblxuICBpZiAoIWhhc093blByb3BlcnR5KHBhcmFtcywgZGF0YU5hbWUpKSB7XG4gICAgcGFyYW1zW2RhdGFOYW1lXSA9IHNjb3BlLmdldERhdGEoZGF0YSkudHVwbGVzUmVmKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgc2VsZWN0aW9uSWRUZXN0LCBzZWxlY3Rpb25SZXNvbHZlLCBzZWxlY3Rpb25UZXN0LCBzZWxlY3Rpb25UdXBsZXMsIHNlbGVjdGlvblZpc2l0b3IgfTtcbiIsImltcG9ydCB7IGFzY2VuZGluZywgcXVhbnRpbGVTb3J0ZWQsIGRldmlhdGlvbiwgcXVhbnRpbGUsIG1lZGlhbiB9IGZyb20gJ2QzLWFycmF5JztcblxuZnVuY3Rpb24qIG51bWJlcnMgKHZhbHVlcywgdmFsdWVvZikge1xuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG5cbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICcnICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlcyAoYXJyYXksIHAsIGYpIHtcbiAgY29uc3QgdmFsdWVzID0gRmxvYXQ2NEFycmF5LmZyb20obnVtYmVycyhhcnJheSwgZikpOyAvLyBkb24ndCBkZXBlbmQgb24gcmV0dXJuIHZhbHVlIGZyb20gdHlwZWQgYXJyYXkgc29ydCBjYWxsXG4gIC8vIHByb3RlY3RzIGFnYWluc3QgdW5kZWZpbmVkIHNvcnQgcmVzdWx0cyBpbiBTYWZhcmkgKHZlZ2EvdmVnYS1saXRlIzQ5NjQpXG5cbiAgdmFsdWVzLnNvcnQoYXNjZW5kaW5nKTtcbiAgcmV0dXJuIHAubWFwKF8gPT4gcXVhbnRpbGVTb3J0ZWQodmFsdWVzLCBfKSk7XG59XG5cbmZ1bmN0aW9uIHF1YXJ0aWxlcyAoYXJyYXksIGYpIHtcbiAgcmV0dXJuIHF1YW50aWxlcyhhcnJheSwgWzAuMjUsIDAuNTAsIDAuNzVdLCBmKTtcbn1cblxuLy8gVGhlb3J5LCBQcmFjdGljZSwgYW5kIFZpc3VhbGl6YXRpb24uIFdpbGV5LlxuXG5mdW5jdGlvbiBlc3RpbWF0ZUJhbmR3aWR0aCAoYXJyYXksIGYpIHtcbiAgY29uc3QgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgZCA9IGRldmlhdGlvbihhcnJheSwgZiksXG4gICAgICAgIHEgPSBxdWFydGlsZXMoYXJyYXksIGYpLFxuICAgICAgICBoID0gKHFbMl0gLSBxWzBdKSAvIDEuMzQsXG4gICAgICAgIHYgPSBNYXRoLm1pbihkLCBoKSB8fCBkIHx8IE1hdGguYWJzKHFbMF0pIHx8IDE7XG4gIHJldHVybiAxLjA2ICogdiAqIE1hdGgucG93KG4sIC0wLjIpO1xufVxuXG5mdW5jdGlvbiBiaW4gKF8pIHtcbiAgLy8gZGV0ZXJtaW5lIHJhbmdlXG4gIGNvbnN0IG1heGIgPSBfLm1heGJpbnMgfHwgMjAsXG4gICAgICAgIGJhc2UgPSBfLmJhc2UgfHwgMTAsXG4gICAgICAgIGxvZ2IgPSBNYXRoLmxvZyhiYXNlKSxcbiAgICAgICAgZGl2ID0gXy5kaXZpZGUgfHwgWzUsIDJdO1xuICBsZXQgbWluID0gXy5leHRlbnRbMF0sXG4gICAgICBtYXggPSBfLmV4dGVudFsxXSxcbiAgICAgIHN0ZXAsXG4gICAgICBsZXZlbCxcbiAgICAgIG1pbnN0ZXAsXG4gICAgICB2LFxuICAgICAgaSxcbiAgICAgIG47XG4gIGNvbnN0IHNwYW4gPSBfLnNwYW4gfHwgbWF4IC0gbWluIHx8IE1hdGguYWJzKG1pbikgfHwgMTtcblxuICBpZiAoXy5zdGVwKSB7XG4gICAgLy8gaWYgc3RlcCBzaXplIGlzIGV4cGxpY2l0bHkgZ2l2ZW4sIHVzZSB0aGF0XG4gICAgc3RlcCA9IF8uc3RlcDtcbiAgfSBlbHNlIGlmIChfLnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICB2ID0gc3BhbiAvIG1heGI7XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gXy5zdGVwcy5sZW5ndGg7IGkgPCBuICYmIF8uc3RlcHNbaV0gPCB2OyArK2kpO1xuXG4gICAgc3RlcCA9IF8uc3RlcHNbTWF0aC5tYXgoMCwgaSAtIDEpXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHVzZSBzcGFuIHRvIGRldGVybWluZSBzdGVwIHNpemVcbiAgICBsZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZyhtYXhiKSAvIGxvZ2IpO1xuICAgIG1pbnN0ZXAgPSBfLm1pbnN0ZXAgfHwgMDtcbiAgICBzdGVwID0gTWF0aC5tYXgobWluc3RlcCwgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpKTsgLy8gaW5jcmVhc2Ugc3RlcCBzaXplIGlmIHRvbyBtYW55IGJpbnNcblxuICAgIHdoaWxlIChNYXRoLmNlaWwoc3BhbiAvIHN0ZXApID4gbWF4Yikge1xuICAgICAgc3RlcCAqPSBiYXNlO1xuICAgIH0gLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcblxuXG4gICAgZm9yIChpID0gMCwgbiA9IGRpdi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHYgPSBzdGVwIC8gZGl2W2ldO1xuICAgICAgaWYgKHYgPj0gbWluc3RlcCAmJiBzcGFuIC8gdiA8PSBtYXhiKSBzdGVwID0gdjtcbiAgICB9XG4gIH0gLy8gdXBkYXRlIHByZWNpc2lvbiwgbWluIGFuZCBtYXhcblxuXG4gIHYgPSBNYXRoLmxvZyhzdGVwKTtcbiAgY29uc3QgcHJlY2lzaW9uID0gdiA+PSAwID8gMCA6IH5+KC12IC8gbG9nYikgKyAxLFxuICAgICAgICBlcHMgPSBNYXRoLnBvdyhiYXNlLCAtcHJlY2lzaW9uIC0gMSk7XG5cbiAgaWYgKF8ubmljZSB8fCBfLm5pY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHYgPSBNYXRoLmZsb29yKG1pbiAvIHN0ZXAgKyBlcHMpICogc3RlcDtcbiAgICBtaW4gPSBtaW4gPCB2ID8gdiAtIHN0ZXAgOiB2O1xuICAgIG1heCA9IE1hdGguY2VpbChtYXggLyBzdGVwKSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogbWF4ID09PSBtaW4gPyBtaW4gKyBzdGVwIDogbWF4LFxuICAgIHN0ZXA6IHN0ZXBcbiAgfTtcbn1cblxudmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuZnVuY3Rpb24gc2V0UmFuZG9tKHIpIHtcbiAgcmFuZG9tID0gcjtcbn1cblxuZnVuY3Rpb24gYm9vdHN0cmFwQ0kgKGFycmF5LCBzYW1wbGVzLCBhbHBoYSwgZikge1xuICBpZiAoIWFycmF5Lmxlbmd0aCkgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gIGNvbnN0IHZhbHVlcyA9IEZsb2F0NjRBcnJheS5mcm9tKG51bWJlcnMoYXJyYXksIGYpKSxcbiAgICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG0gPSBzYW1wbGVzO1xuICBsZXQgYSwgaSwgaiwgbXU7XG5cbiAgZm9yIChqID0gMCwgbXUgPSBBcnJheShtKTsgaiA8IG07ICsraikge1xuICAgIGZvciAoYSA9IDAsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBhICs9IHZhbHVlc1t+fihyYW5kb20oKSAqIG4pXTtcbiAgICB9XG5cbiAgICBtdVtqXSA9IGEgLyBuO1xuICB9XG5cbiAgbXUuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gW3F1YW50aWxlKG11LCBhbHBoYSAvIDIpLCBxdWFudGlsZShtdSwgMSAtIGFscGhhIC8gMildO1xufVxuXG4vLyBEb3QgZGVuc2l0eSBiaW5uaW5nIGZvciBkb3QgcGxvdCBjb25zdHJ1Y3Rpb24uXG4vLyBCYXNlZCBvbiBMZWxhbmQgV2lsa2luc29uLCBEb3QgUGxvdHMsIFRoZSBBbWVyaWNhbiBTdGF0aXN0aWNpYW4sIDE5OTkuXG4vLyBodHRwczovL3d3dy5jcy51aWMuZWR1L353aWxraW5zb24vUHVibGljYXRpb25zL2RvdHBsb3RzLnBkZlxuZnVuY3Rpb24gZG90YmluIChhcnJheSwgc3RlcCwgc21vb3RoLCBmKSB7XG4gIGYgPSBmIHx8IChfID0+IF8pO1xuXG4gIGNvbnN0IG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHYgPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICBsZXQgaSA9IDAsXG4gICAgICBqID0gMSxcbiAgICAgIGEgPSBmKGFycmF5WzBdKSxcbiAgICAgIGIgPSBhLFxuICAgICAgdyA9IGEgKyBzdGVwLFxuICAgICAgeDtcblxuICBmb3IgKDsgaiA8IG47ICsraikge1xuICAgIHggPSBmKGFycmF5W2pdKTtcblxuICAgIGlmICh4ID49IHcpIHtcbiAgICAgIGIgPSAoYSArIGIpIC8gMjtcblxuICAgICAgZm9yICg7IGkgPCBqOyArK2kpIHZbaV0gPSBiO1xuXG4gICAgICB3ID0geCArIHN0ZXA7XG4gICAgICBhID0geDtcbiAgICB9XG5cbiAgICBiID0geDtcbiAgfVxuXG4gIGIgPSAoYSArIGIpIC8gMjtcblxuICBmb3IgKDsgaSA8IGo7ICsraSkgdltpXSA9IGI7XG5cbiAgcmV0dXJuIHNtb290aCA/IHNtb290aGluZyh2LCBzdGVwICsgc3RlcCAvIDQpIDogdjtcbn0gLy8gcGVyZm9ybSBzbW9vdGhpbmcgdG8gcmVkdWNlIHZhcmlhbmNlXG4vLyBzd2FwIHBvaW50cyBiZXR3ZWVuIFwiYWRqYWNlbnRcIiBzdGFja3Ncbi8vIFdpbGtpbnNvbiBkZWZpbmVzIGFkamFjZW50IGFzIHdpdGhpbiBzdGVwLzQgdW5pdHNcblxuZnVuY3Rpb24gc21vb3RoaW5nKHYsIHRocmVzaCkge1xuICBjb25zdCBuID0gdi5sZW5ndGg7XG4gIGxldCBhID0gMCxcbiAgICAgIGIgPSAxLFxuICAgICAgYyxcbiAgICAgIGQ7IC8vIGdldCBsZWZ0IHN0YWNrXG5cbiAgd2hpbGUgKHZbYV0gPT09IHZbYl0pICsrYjtcblxuICB3aGlsZSAoYiA8IG4pIHtcbiAgICAvLyBnZXQgcmlnaHQgc3RhY2tcbiAgICBjID0gYiArIDE7XG5cbiAgICB3aGlsZSAodltiXSA9PT0gdltjXSkgKytjOyAvLyBhcmUgc3RhY2tzIGFkamFjZW50P1xuICAgIC8vIGlmIHNvLCBjb21wYXJlIHNpemVzIGFuZCBzd2FwIGFzIG5lZWRlZFxuXG5cbiAgICBpZiAodltiXSAtIHZbYiAtIDFdIDwgdGhyZXNoKSB7XG4gICAgICBkID0gYiArIChhICsgYyAtIGIgLSBiID4+IDEpO1xuXG4gICAgICB3aGlsZSAoZCA8IGIpIHZbZCsrXSA9IHZbYl07XG5cbiAgICAgIHdoaWxlIChkID4gYikgdltkLS1dID0gdlthXTtcbiAgICB9IC8vIHVwZGF0ZSBsZWZ0IHN0YWNrIGluZGljZXNcblxuXG4gICAgYSA9IGI7XG4gICAgYiA9IGM7XG4gIH1cblxuICByZXR1cm4gdjtcbn1cblxuZnVuY3Rpb24gbGNnIChzZWVkKSB7XG4gIC8vIFJhbmRvbSBudW1iZXJzIHVzaW5nIGEgTGluZWFyIENvbmdydWVudGlhbCBHZW5lcmF0b3Igd2l0aCBzZWVkIHZhbHVlXG4gIC8vIFVzZXMgZ2xpYmMgdmFsdWVzIGZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2NvbmdydWVudGlhbF9nZW5lcmF0b3JcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzZWVkID0gKDExMDM1MTUyNDUgKiBzZWVkICsgMTIzNDUpICUgMjE0NzQ4MzY0NztcbiAgICByZXR1cm4gc2VlZCAvIDIxNDc0ODM2NDc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludGVnZXIgKG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT0gbnVsbCkge1xuICAgIG1heCA9IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG5cbiAgbGV0IGEsIGIsIGQ7XG4gIGNvbnN0IGRpc3QgPSB7XG4gICAgbWluKF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGEgPSBfIHx8IDA7XG4gICAgICAgIGQgPSBiIC0gYTtcbiAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbWF4KF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGIgPSBfIHx8IDA7XG4gICAgICAgIGQgPSBiIC0gYTtcbiAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2FtcGxlKCkge1xuICAgICAgcmV0dXJuIGEgKyBNYXRoLmZsb29yKGQgKiByYW5kb20oKSk7XG4gICAgfSxcblxuICAgIHBkZih4KSB7XG4gICAgICByZXR1cm4geCA9PT0gTWF0aC5mbG9vcih4KSAmJiB4ID49IGEgJiYgeCA8IGIgPyAxIC8gZCA6IDA7XG4gICAgfSxcblxuICAgIGNkZih4KSB7XG4gICAgICBjb25zdCB2ID0gTWF0aC5mbG9vcih4KTtcbiAgICAgIHJldHVybiB2IDwgYSA/IDAgOiB2ID49IGIgPyAxIDogKHYgLSBhICsgMSkgLyBkO1xuICAgIH0sXG5cbiAgICBpY2RmKHApIHtcbiAgICAgIHJldHVybiBwID49IDAgJiYgcCA8PSAxID8gYSAtIDEgKyBNYXRoLmZsb29yKHAgKiBkKSA6IE5hTjtcbiAgICB9XG5cbiAgfTtcbiAgcmV0dXJuIGRpc3QubWluKG1pbikubWF4KG1heCk7XG59XG5cbmNvbnN0IFNRUlQyUEkgPSBNYXRoLnNxcnQoMiAqIE1hdGguUEkpO1xuY29uc3QgU1FSVDIgPSBNYXRoLlNRUlQyO1xuXG5sZXQgbmV4dFNhbXBsZSA9IE5hTjtcbmZ1bmN0aW9uIHNhbXBsZU5vcm1hbChtZWFuLCBzdGRldikge1xuICBtZWFuID0gbWVhbiB8fCAwO1xuICBzdGRldiA9IHN0ZGV2ID09IG51bGwgPyAxIDogc3RkZXY7XG4gIGxldCB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgcmRzLFxuICAgICAgYztcblxuICBpZiAobmV4dFNhbXBsZSA9PT0gbmV4dFNhbXBsZSkge1xuICAgIHggPSBuZXh0U2FtcGxlO1xuICAgIG5leHRTYW1wbGUgPSBOYU47XG4gIH0gZWxzZSB7XG4gICAgZG8ge1xuICAgICAgeCA9IHJhbmRvbSgpICogMiAtIDE7XG4gICAgICB5ID0gcmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgIHJkcyA9IHggKiB4ICsgeSAqIHk7XG4gICAgfSB3aGlsZSAocmRzID09PSAwIHx8IHJkcyA+IDEpO1xuXG4gICAgYyA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHJkcykgLyByZHMpOyAvLyBCb3gtTXVsbGVyIHRyYW5zZm9ybVxuXG4gICAgeCAqPSBjO1xuICAgIG5leHRTYW1wbGUgPSB5ICogYztcbiAgfVxuXG4gIHJldHVybiBtZWFuICsgeCAqIHN0ZGV2O1xufVxuZnVuY3Rpb24gZGVuc2l0eU5vcm1hbCh2YWx1ZSwgbWVhbiwgc3RkZXYpIHtcbiAgc3RkZXYgPSBzdGRldiA9PSBudWxsID8gMSA6IHN0ZGV2O1xuICBjb25zdCB6ID0gKHZhbHVlIC0gKG1lYW4gfHwgMCkpIC8gc3RkZXY7XG4gIHJldHVybiBNYXRoLmV4cCgtMC41ICogeiAqIHopIC8gKHN0ZGV2ICogU1FSVDJQSSk7XG59IC8vIEFwcHJveGltYXRpb24gZnJvbSBXZXN0ICgyMDA5KVxuLy8gQmV0dGVyIEFwcHJveGltYXRpb25zIHRvIEN1bXVsYXRpdmUgTm9ybWFsIEZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBjdW11bGF0aXZlTm9ybWFsKHZhbHVlLCBtZWFuLCBzdGRldikge1xuICBtZWFuID0gbWVhbiB8fCAwO1xuICBzdGRldiA9IHN0ZGV2ID09IG51bGwgPyAxIDogc3RkZXY7XG4gIGNvbnN0IHogPSAodmFsdWUgLSBtZWFuKSAvIHN0ZGV2LFxuICAgICAgICBaID0gTWF0aC5hYnMoeik7XG4gIGxldCBjZDtcblxuICBpZiAoWiA+IDM3KSB7XG4gICAgY2QgPSAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGV4cCA9IE1hdGguZXhwKC1aICogWiAvIDIpO1xuICAgIGxldCBzdW07XG5cbiAgICBpZiAoWiA8IDcuMDcxMDY3ODExODY1NDcpIHtcbiAgICAgIHN1bSA9IDMuNTI2MjQ5NjU5OTg5MTFlLTAyICogWiArIDAuNzAwMzgzMDY0NDQzNjg4O1xuICAgICAgc3VtID0gc3VtICogWiArIDYuMzczOTYyMjAzNTMxNjU7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMzMuOTEyODY2MDc4MzgzO1xuICAgICAgc3VtID0gc3VtICogWiArIDExMi4wNzkyOTE0OTc4NzE7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMjIxLjIxMzU5NjE2OTkzMTtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyAyMjAuMjA2ODY3OTEyMzc2O1xuICAgICAgY2QgPSBleHAgKiBzdW07XG4gICAgICBzdW0gPSA4LjgzODgzNDc2NDgzMTg0ZS0wMiAqIFogKyAxLjc1NTY2NzE2MzE4MjY0O1xuICAgICAgc3VtID0gc3VtICogWiArIDE2LjA2NDE3NzU3OTIwNztcbiAgICAgIHN1bSA9IHN1bSAqIFogKyA4Ni43ODA3MzIyMDI5NDYxO1xuICAgICAgc3VtID0gc3VtICogWiArIDI5Ni41NjQyNDg3Nzk2NzQ7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgNjM3LjMzMzYzMzM3ODgzMTtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyA3OTMuODI2NTEyNTE5OTQ4O1xuICAgICAgc3VtID0gc3VtICogWiArIDQ0MC40MTM3MzU4MjQ3NTI7XG4gICAgICBjZCA9IGNkIC8gc3VtO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdW0gPSBaICsgMC42NTtcbiAgICAgIHN1bSA9IFogKyA0IC8gc3VtO1xuICAgICAgc3VtID0gWiArIDMgLyBzdW07XG4gICAgICBzdW0gPSBaICsgMiAvIHN1bTtcbiAgICAgIHN1bSA9IFogKyAxIC8gc3VtO1xuICAgICAgY2QgPSBleHAgLyBzdW0gLyAyLjUwNjYyODI3NDYzMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4geiA+IDAgPyAxIC0gY2QgOiBjZDtcbn0gLy8gQXBwcm94aW1hdGlvbiBvZiBQcm9iaXQgZnVuY3Rpb24gdXNpbmcgaW52ZXJzZSBlcnJvciBmdW5jdGlvbi5cblxuZnVuY3Rpb24gcXVhbnRpbGVOb3JtYWwocCwgbWVhbiwgc3RkZXYpIHtcbiAgaWYgKHAgPCAwIHx8IHAgPiAxKSByZXR1cm4gTmFOO1xuICByZXR1cm4gKG1lYW4gfHwgMCkgKyAoc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldikgKiBTUVJUMiAqIGVyZmludigyICogcCAtIDEpO1xufSAvLyBBcHByb3hpbWF0ZSBpbnZlcnNlIGVycm9yIGZ1bmN0aW9uLiBJbXBsZW1lbnRhdGlvbiBmcm9tIFwiQXBwcm94aW1hdGluZ1xuLy8gdGhlIGVyZmludiBmdW5jdGlvblwiIGJ5IE1pa2UgR2lsZXMsIEdQVSBDb21wdXRpbmcgR2Vtcywgdm9sdW1lIDIsIDIwMTAuXG4vLyBQb3J0ZWQgZnJvbSBBcGFjaGUgQ29tbW9ucyBNYXRoLCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuZnVuY3Rpb24gZXJmaW52KHgpIHtcbiAgLy8gYmV3YXJlIHRoYXQgdGhlIGxvZ2FyaXRobSBhcmd1bWVudCBtdXN0IGJlXG4gIC8vIGNvbW1wdXRlZCBhcyAoMS4wIC0geCkgKiAoMS4wICsgeCksXG4gIC8vIGl0IG11c3QgTk9UIGJlIHNpbXBsaWZpZWQgYXMgMS4wIC0geCAqIHggYXMgdGhpc1xuICAvLyB3b3VsZCBpbmR1Y2Ugcm91bmRpbmcgZXJyb3JzIG5lYXIgdGhlIGJvdW5kYXJpZXMgKy8tMVxuICBsZXQgdyA9IC1NYXRoLmxvZygoMSAtIHgpICogKDEgKyB4KSksXG4gICAgICBwO1xuXG4gIGlmICh3IDwgNi4yNSkge1xuICAgIHcgLT0gMy4xMjU7XG4gICAgcCA9IC0zLjY0NDQxMjA2NDAxNzgxOTY5OTZlLTIxO1xuICAgIHAgPSAtMS42ODUwNTkxMzgxODIwMTY1ODllLTE5ICsgcCAqIHc7XG4gICAgcCA9IDEuMjg1ODQ4MDcxNTI1NjQwMDE2N2UtMTggKyBwICogdztcbiAgICBwID0gMS4xMTU3ODc3Njc4MDI1MTgwOTZlLTE3ICsgcCAqIHc7XG4gICAgcCA9IC0xLjMzMzE3MTY2Mjg1NDYyMDkwNmUtMTYgKyBwICogdztcbiAgICBwID0gMi4wOTcyNzY3ODc1OTY4NTYxNjM3ZS0xNyArIHAgKiB3O1xuICAgIHAgPSA2LjYzNzYzODEzNDM1ODMyMzgzMjVlLTE1ICsgcCAqIHc7XG4gICAgcCA9IC00LjA1NDU2NjI3Mjk3NTIwNjg2MzllLTE0ICsgcCAqIHc7XG4gICAgcCA9IC04LjE1MTkzNDE5NzYwNTQ3MjE1MjJlLTE0ICsgcCAqIHc7XG4gICAgcCA9IDIuNjMzNTA5MzE1MzA4MjMyMjk3N2UtMTIgKyBwICogdztcbiAgICBwID0gLTEuMjk3NTEzMzI1MzQ1MzUzMjQ5OGUtMTEgKyBwICogdztcbiAgICBwID0gLTUuNDE1NDEyMDU0Mjk0NjI3OTMxN2UtMTEgKyBwICogdztcbiAgICBwID0gMS4wNTEyMTIyNzMzMjE1MzIyODVlLTA5ICsgcCAqIHc7XG4gICAgcCA9IC00LjExMjYzMzk4MDM0Njk4MzY5NzZlLTA5ICsgcCAqIHc7XG4gICAgcCA9IC0yLjkwNzAzNjk5NTc4ODIwMDUwODZlLTA4ICsgcCAqIHc7XG4gICAgcCA9IDQuMjM0Nzg3NzgyNzkzMjQwMzUxOGUtMDcgKyBwICogdztcbiAgICBwID0gLTEuMzY1NDY5MjAwMDgzNDY3ODY0NWUtMDYgKyBwICogdztcbiAgICBwID0gLTEuMzg4MjUyMzM2Mjc4NjQ2ODcxOWUtMDUgKyBwICogdztcbiAgICBwID0gMC4wMDAxODY3MzQyMDgwMzQwNTcxMzUyICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwMDc0MDcwMjUzNDE2NjI2Njk3NTEyICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwNjAzMzY3MDg3MTQzMDE0OTA1MzMgKyBwICogdztcbiAgICBwID0gMC4yNDAxNTgxODI0MjU1ODk2MTY5MyArIHAgKiB3O1xuICAgIHAgPSAxLjY1MzY1NDU2MjY4MzEwMjczNTYgKyBwICogdztcbiAgfSBlbHNlIGlmICh3IDwgMTYuMCkge1xuICAgIHcgPSBNYXRoLnNxcnQodykgLSAzLjI1O1xuICAgIHAgPSAyLjIxMzczNzY5MjE3NzU3ODcwNDllLTA5O1xuICAgIHAgPSA5LjA3NTY1NjE5Mzg4ODUzOTA5NzllLTA4ICsgcCAqIHc7XG4gICAgcCA9IC0yLjc1MTc0MDYyOTcwNjQ1NDU0MjhlLTA3ICsgcCAqIHc7XG4gICAgcCA9IDEuODIzOTYyOTIxNDM4OTIyNzc1NWUtMDggKyBwICogdztcbiAgICBwID0gMS41MDI3NDAzOTY4OTA5ODI3NjI3ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAtNC4wMTM4Njc1MjY5ODE1NDU5NjllLTA2ICsgcCAqIHc7XG4gICAgcCA9IDIuOTIzNDQ0OTA4OTk1NTQ0NjA0NGUtMDYgKyBwICogdztcbiAgICBwID0gMS4yNDc1MzA0NDgxNjcxNzc4NzIzZS0wNSArIHAgKiB3O1xuICAgIHAgPSAtNC43MzE4MjI5MDA5MDU1NzMzOTgxZS0wNSArIHAgKiB3O1xuICAgIHAgPSA2LjgyODQ4NTE0NTk1NzMxNzU0NDhlLTA1ICsgcCAqIHc7XG4gICAgcCA9IDIuNDAzMTExMDM4NzA5Nzg5Mzk5OWUtMDUgKyBwICogdztcbiAgICBwID0gLTAuMDAwMzU1MDM3NTIwMzYyODQ3NDc5NiArIHAgKiB3O1xuICAgIHAgPSAwLjAwMDk1MzI4OTM3OTczNzM4MDQ5NzAzICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwMTY4ODI3NTU1NjAyMzUwNDczMTMgKyBwICogdztcbiAgICBwID0gMC4wMDI0OTE0NDIwOTYxMDc4NTA4MDY2ICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwMzc1MTIwODUwNzU2OTI0MTIxMDcgKyBwICogdztcbiAgICBwID0gMC4wMDUzNzA5MTQ1NTM1OTAwNjM2MTcgKyBwICogdztcbiAgICBwID0gMS4wMDUyNTg5Njc2OTQxNTkyMzM0ICsgcCAqIHc7XG4gICAgcCA9IDMuMDgzODg1NjEwNDkyMjIwNzYzNSArIHAgKiB3O1xuICB9IGVsc2UgaWYgKE51bWJlci5pc0Zpbml0ZSh3KSkge1xuICAgIHcgPSBNYXRoLnNxcnQodykgLSA1LjA7XG4gICAgcCA9IC0yLjcxMDk5MjA2MTY0Mzg1NzMyNDNlLTExO1xuICAgIHAgPSAtMi41NTU2NDE4MTY5OTY1MjUyMDU1ZS0xMCArIHAgKiB3O1xuICAgIHAgPSAxLjUwNzY1NzI2OTM1MDA1NDgwODNlLTA5ICsgcCAqIHc7XG4gICAgcCA9IC0zLjc4OTQ2NTQ0MDEyNjczNjk5MzdlLTA5ICsgcCAqIHc7XG4gICAgcCA9IDcuNjE1NzAxMjA4MDc4MzM5MzgwNGUtMDkgKyBwICogdztcbiAgICBwID0gLTEuNDk2MDAyNjYyNzE0OTI0MDQ3OGUtMDggKyBwICogdztcbiAgICBwID0gMi45MTQ3OTUzNDUwOTAxMDgwODI2ZS0wOCArIHAgKiB3O1xuICAgIHAgPSAtNi43NzExOTk3NzU4NDUyMzM5NDk4ZS0wOCArIHAgKiB3O1xuICAgIHAgPSAyLjI5MDA0ODIyMjgwMjY2NTQ3MTdlLTA3ICsgcCAqIHc7XG4gICAgcCA9IC05LjkyOTgyNzI5NDIzMTcwMDI1MzllLTA3ICsgcCAqIHc7XG4gICAgcCA9IDQuNTI2MDYyNTk3MjIzMTUzNzAzOWUtMDYgKyBwICogdztcbiAgICBwID0gLTEuOTY4MTc3ODEwNTUzMTY3MDU2N2UtMDUgKyBwICogdztcbiAgICBwID0gNy41OTk1Mjc3MDMwMDE3NzYxMTM5ZS0wNSArIHAgKiB3O1xuICAgIHAgPSAtMC4wMDAyMTUwMzAxMTkzMDA0NDQ3NzM0NyArIHAgKiB3O1xuICAgIHAgPSAtMC4wMDAxMzg3MTkzMTgzMzYyMzEyMjAyNiArIHAgKiB3O1xuICAgIHAgPSAxLjAxMDMwMDQ2NDg2NDUzNDM5NzcgKyBwICogdztcbiAgICBwID0gNC44NDk5MDY0MDE0MDg1ODQ0MjIxICsgcCAqIHc7XG4gIH0gZWxzZSB7XG4gICAgcCA9IEluZmluaXR5O1xuICB9XG5cbiAgcmV0dXJuIHAgKiB4O1xufVxuXG5mdW5jdGlvbiBnYXVzc2lhbiAobWVhbiwgc3RkZXYpIHtcbiAgbGV0IG11LCBzaWdtYTtcbiAgY29uc3QgZGlzdCA9IHtcbiAgICBtZWFuKF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIG11ID0gXyB8fCAwO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtdTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RkZXYoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgc2lnbWEgPSBfID09IG51bGwgPyAxIDogXztcbiAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnbWE7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNhbXBsZTogKCkgPT4gc2FtcGxlTm9ybWFsKG11LCBzaWdtYSksXG4gICAgcGRmOiB2YWx1ZSA9PiBkZW5zaXR5Tm9ybWFsKHZhbHVlLCBtdSwgc2lnbWEpLFxuICAgIGNkZjogdmFsdWUgPT4gY3VtdWxhdGl2ZU5vcm1hbCh2YWx1ZSwgbXUsIHNpZ21hKSxcbiAgICBpY2RmOiBwID0+IHF1YW50aWxlTm9ybWFsKHAsIG11LCBzaWdtYSlcbiAgfTtcbiAgcmV0dXJuIGRpc3QubWVhbihtZWFuKS5zdGRldihzdGRldik7XG59XG5cbmZ1bmN0aW9uIGtkZSAoc3VwcG9ydCwgYmFuZHdpZHRoKSB7XG4gIGNvbnN0IGtlcm5lbCA9IGdhdXNzaWFuKCk7XG4gIGxldCBuID0gMDtcbiAgY29uc3QgZGlzdCA9IHtcbiAgICBkYXRhKF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHN1cHBvcnQgPSBfO1xuICAgICAgICBuID0gXyA/IF8ubGVuZ3RoIDogMDtcbiAgICAgICAgcmV0dXJuIGRpc3QuYmFuZHdpZHRoKGJhbmR3aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VwcG9ydDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYmFuZHdpZHRoKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJhbmR3aWR0aDtcbiAgICAgIGJhbmR3aWR0aCA9IF87XG4gICAgICBpZiAoIWJhbmR3aWR0aCAmJiBzdXBwb3J0KSBiYW5kd2lkdGggPSBlc3RpbWF0ZUJhbmR3aWR0aChzdXBwb3J0KTtcbiAgICAgIHJldHVybiBkaXN0O1xuICAgIH0sXG5cbiAgICBzYW1wbGUoKSB7XG4gICAgICByZXR1cm4gc3VwcG9ydFt+fihyYW5kb20oKSAqIG4pXSArIGJhbmR3aWR0aCAqIGtlcm5lbC5zYW1wbGUoKTtcbiAgICB9LFxuXG4gICAgcGRmKHgpIHtcbiAgICAgIGxldCB5ID0gMCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgeSArPSBrZXJuZWwucGRmKCh4IC0gc3VwcG9ydFtpXSkgLyBiYW5kd2lkdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geSAvIGJhbmR3aWR0aCAvIG47XG4gICAgfSxcblxuICAgIGNkZih4KSB7XG4gICAgICBsZXQgeSA9IDAsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHkgKz0ga2VybmVsLmNkZigoeCAtIHN1cHBvcnRbaV0pIC8gYmFuZHdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHkgLyBuO1xuICAgIH0sXG5cbiAgICBpY2RmKCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0tERSBpY2RmIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gIH07XG4gIHJldHVybiBkaXN0LmRhdGEoc3VwcG9ydCk7XG59XG5cbmZ1bmN0aW9uIHNhbXBsZUxvZ05vcm1hbChtZWFuLCBzdGRldikge1xuICBtZWFuID0gbWVhbiB8fCAwO1xuICBzdGRldiA9IHN0ZGV2ID09IG51bGwgPyAxIDogc3RkZXY7XG4gIHJldHVybiBNYXRoLmV4cChtZWFuICsgc2FtcGxlTm9ybWFsKCkgKiBzdGRldik7XG59XG5mdW5jdGlvbiBkZW5zaXR5TG9nTm9ybWFsKHZhbHVlLCBtZWFuLCBzdGRldikge1xuICBpZiAodmFsdWUgPD0gMCkgcmV0dXJuIDA7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgY29uc3QgeiA9IChNYXRoLmxvZyh2YWx1ZSkgLSBtZWFuKSAvIHN0ZGV2O1xuICByZXR1cm4gTWF0aC5leHAoLTAuNSAqIHogKiB6KSAvIChzdGRldiAqIFNRUlQyUEkgKiB2YWx1ZSk7XG59XG5mdW5jdGlvbiBjdW11bGF0aXZlTG9nTm9ybWFsKHZhbHVlLCBtZWFuLCBzdGRldikge1xuICByZXR1cm4gY3VtdWxhdGl2ZU5vcm1hbChNYXRoLmxvZyh2YWx1ZSksIG1lYW4sIHN0ZGV2KTtcbn1cbmZ1bmN0aW9uIHF1YW50aWxlTG9nTm9ybWFsKHAsIG1lYW4sIHN0ZGV2KSB7XG4gIHJldHVybiBNYXRoLmV4cChxdWFudGlsZU5vcm1hbChwLCBtZWFuLCBzdGRldikpO1xufVxuZnVuY3Rpb24gbG9nbm9ybWFsIChtZWFuLCBzdGRldikge1xuICBsZXQgbXUsIHNpZ21hO1xuICBjb25zdCBkaXN0ID0ge1xuICAgIG1lYW4oXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgbXUgPSBfIHx8IDA7XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG11O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGRldihfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBzaWdtYSA9IF8gPT0gbnVsbCA/IDEgOiBfO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWdtYTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2FtcGxlOiAoKSA9PiBzYW1wbGVMb2dOb3JtYWwobXUsIHNpZ21hKSxcbiAgICBwZGY6IHZhbHVlID0+IGRlbnNpdHlMb2dOb3JtYWwodmFsdWUsIG11LCBzaWdtYSksXG4gICAgY2RmOiB2YWx1ZSA9PiBjdW11bGF0aXZlTG9nTm9ybWFsKHZhbHVlLCBtdSwgc2lnbWEpLFxuICAgIGljZGY6IHAgPT4gcXVhbnRpbGVMb2dOb3JtYWwocCwgbXUsIHNpZ21hKVxuICB9O1xuICByZXR1cm4gZGlzdC5tZWFuKG1lYW4pLnN0ZGV2KHN0ZGV2KTtcbn1cblxuZnVuY3Rpb24gbWl4dHVyZSAoZGlzdHMsIHdlaWdodHMpIHtcbiAgbGV0IG0gPSAwLFxuICAgICAgdztcblxuICBmdW5jdGlvbiBub3JtYWxpemUoeCkge1xuICAgIGNvbnN0IHcgPSBbXTtcbiAgICBsZXQgc3VtID0gMCxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgIHN1bSArPSB3W2ldID0geFtpXSA9PSBudWxsID8gMSA6ICt4W2ldO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgIHdbaV0gLz0gc3VtO1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgY29uc3QgZGlzdCA9IHtcbiAgICB3ZWlnaHRzKF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHcgPSBub3JtYWxpemUod2VpZ2h0cyA9IF8gfHwgW10pO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdlaWdodHM7XG4gICAgfSxcblxuICAgIGRpc3RyaWJ1dGlvbnMoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKF8pIHtcbiAgICAgICAgICBtID0gXy5sZW5ndGg7XG4gICAgICAgICAgZGlzdHMgPSBfO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgIGRpc3RzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlzdC53ZWlnaHRzKHdlaWdodHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlzdHM7XG4gICAgfSxcblxuICAgIHNhbXBsZSgpIHtcbiAgICAgIGNvbnN0IHIgPSByYW5kb20oKTtcbiAgICAgIGxldCBkID0gZGlzdHNbbSAtIDFdLFxuICAgICAgICAgIHYgPSB3WzBdLFxuICAgICAgICAgIGkgPSAwOyAvLyBmaXJzdCBzZWxlY3QgZGlzdHJpYnV0aW9uXG5cbiAgICAgIGZvciAoOyBpIDwgbSAtIDE7IHYgKz0gd1srK2ldKSB7XG4gICAgICAgIGlmIChyIDwgdikge1xuICAgICAgICAgIGQgPSBkaXN0c1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyB0aGVuIHNhbXBsZSBmcm9tIGl0XG5cblxuICAgICAgcmV0dXJuIGQuc2FtcGxlKCk7XG4gICAgfSxcblxuICAgIHBkZih4KSB7XG4gICAgICBsZXQgcCA9IDAsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIHAgKz0gd1tpXSAqIGRpc3RzW2ldLnBkZih4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGNkZih4KSB7XG4gICAgICBsZXQgcCA9IDAsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIHAgKz0gd1tpXSAqIGRpc3RzW2ldLmNkZih4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGljZGYoKSB7XG4gICAgICB0aHJvdyBFcnJvcignTWl4dHVyZSBpY2RmIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gIH07XG4gIHJldHVybiBkaXN0LmRpc3RyaWJ1dGlvbnMoZGlzdHMpLndlaWdodHMod2VpZ2h0cyk7XG59XG5cbmZ1bmN0aW9uIHNhbXBsZVVuaWZvcm0obWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gbWluID09IG51bGwgPyAxIDogbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cblxuICByZXR1cm4gbWluICsgKG1heCAtIG1pbikgKiByYW5kb20oKTtcbn1cbmZ1bmN0aW9uIGRlbnNpdHlVbmlmb3JtKHZhbHVlLCBtaW4sIG1heCkge1xuICBpZiAobWF4ID09IG51bGwpIHtcbiAgICBtYXggPSBtaW4gPT0gbnVsbCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4ID8gMSAvIChtYXggLSBtaW4pIDogMDtcbn1cbmZ1bmN0aW9uIGN1bXVsYXRpdmVVbmlmb3JtKHZhbHVlLCBtaW4sIG1heCkge1xuICBpZiAobWF4ID09IG51bGwpIHtcbiAgICBtYXggPSBtaW4gPT0gbnVsbCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSA8IG1pbiA/IDAgOiB2YWx1ZSA+IG1heCA/IDEgOiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG59XG5mdW5jdGlvbiBxdWFudGlsZVVuaWZvcm0ocCwgbWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gbWluID09IG51bGwgPyAxIDogbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cblxuICByZXR1cm4gcCA+PSAwICYmIHAgPD0gMSA/IG1pbiArIHAgKiAobWF4IC0gbWluKSA6IE5hTjtcbn1cbmZ1bmN0aW9uIHVuaWZvcm0gKG1pbiwgbWF4KSB7XG4gIGxldCBhLCBiO1xuICBjb25zdCBkaXN0ID0ge1xuICAgIG1pbihfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBhID0gXyB8fCAwO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBtYXgoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYiA9IF8gPT0gbnVsbCA/IDEgOiBfO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzYW1wbGU6ICgpID0+IHNhbXBsZVVuaWZvcm0oYSwgYiksXG4gICAgcGRmOiB2YWx1ZSA9PiBkZW5zaXR5VW5pZm9ybSh2YWx1ZSwgYSwgYiksXG4gICAgY2RmOiB2YWx1ZSA9PiBjdW11bGF0aXZlVW5pZm9ybSh2YWx1ZSwgYSwgYiksXG4gICAgaWNkZjogcCA9PiBxdWFudGlsZVVuaWZvcm0ocCwgYSwgYilcbiAgfTtcblxuICBpZiAobWF4ID09IG51bGwpIHtcbiAgICBtYXggPSBtaW4gPT0gbnVsbCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuXG4gIHJldHVybiBkaXN0Lm1pbihtaW4pLm1heChtYXgpO1xufVxuXG4vLyBPcmRpbmFyeSBMZWFzdCBTcXVhcmVzXG5mdW5jdGlvbiBvbHMgKHVYLCB1WSwgdVhZLCB1WDIpIHtcbiAgY29uc3QgZGVsdGEgPSB1WDIgLSB1WCAqIHVYLFxuICAgICAgICBzbG9wZSA9IE1hdGguYWJzKGRlbHRhKSA8IDFlLTI0ID8gMCA6ICh1WFkgLSB1WCAqIHVZKSAvIGRlbHRhLFxuICAgICAgICBpbnRlcmNlcHQgPSB1WSAtIHNsb3BlICogdVg7XG4gIHJldHVybiBbaW50ZXJjZXB0LCBzbG9wZV07XG59XG5cbmZ1bmN0aW9uIHBvaW50cyhkYXRhLCB4LCB5LCBzb3J0KSB7XG4gIGRhdGEgPSBkYXRhLmZpbHRlcihkID0+IHtcbiAgICBsZXQgdSA9IHgoZCksXG4gICAgICAgIHYgPSB5KGQpO1xuICAgIHJldHVybiB1ICE9IG51bGwgJiYgKHUgPSArdSkgPj0gdSAmJiB2ICE9IG51bGwgJiYgKHYgPSArdikgPj0gdjtcbiAgfSk7XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBkYXRhLnNvcnQoKGEsIGIpID0+IHgoYSkgLSB4KGIpKTtcbiAgfVxuXG4gIGNvbnN0IG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgWCA9IG5ldyBGbG9hdDY0QXJyYXkobiksXG4gICAgICAgIFkgPSBuZXcgRmxvYXQ2NEFycmF5KG4pOyAvLyBleHRyYWN0IHZhbHVlcywgY2FsY3VsYXRlIG1lYW5zXG5cbiAgbGV0IGkgPSAwLFxuICAgICAgdXggPSAwLFxuICAgICAgdXkgPSAwLFxuICAgICAgeHYsXG4gICAgICB5dixcbiAgICAgIGQ7XG5cbiAgZm9yIChkIG9mIGRhdGEpIHtcbiAgICBYW2ldID0geHYgPSAreChkKTtcbiAgICBZW2ldID0geXYgPSAreShkKTtcbiAgICArK2k7XG4gICAgdXggKz0gKHh2IC0gdXgpIC8gaTtcbiAgICB1eSArPSAoeXYgLSB1eSkgLyBpO1xuICB9IC8vIG1lYW4gY2VudGVyIHRoZSBkYXRhXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgWFtpXSAtPSB1eDtcbiAgICBZW2ldIC09IHV5O1xuICB9XG5cbiAgcmV0dXJuIFtYLCBZLCB1eCwgdXldO1xufVxuZnVuY3Rpb24gdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgY2FsbGJhY2spIHtcbiAgbGV0IGkgPSAtMSxcbiAgICAgIHUsXG4gICAgICB2O1xuXG4gIGZvciAoY29uc3QgZCBvZiBkYXRhKSB7XG4gICAgdSA9IHgoZCk7XG4gICAgdiA9IHkoZCk7XG5cbiAgICBpZiAodSAhPSBudWxsICYmICh1ID0gK3UpID49IHUgJiYgdiAhPSBudWxsICYmICh2ID0gK3YpID49IHYpIHtcbiAgICAgIGNhbGxiYWNrKHUsIHYsICsraSk7XG4gICAgfVxuICB9XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9IYXJyeVN0ZXZlbnMvZDMtcmVncmVzc2lvbi9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmZ1bmN0aW9uIHJTcXVhcmVkIChkYXRhLCB4LCB5LCB1WSwgcHJlZGljdCkge1xuICBsZXQgU1NFID0gMCxcbiAgICAgIFNTVCA9IDA7XG4gIHZpc2l0UG9pbnRzKGRhdGEsIHgsIHksIChkeCwgZHkpID0+IHtcbiAgICBjb25zdCBzc2UgPSBkeSAtIHByZWRpY3QoZHgpLFxuICAgICAgICAgIHNzdCA9IGR5IC0gdVk7XG4gICAgU1NFICs9IHNzZSAqIHNzZTtcbiAgICBTU1QgKz0gc3N0ICogc3N0O1xuICB9KTtcbiAgcmV0dXJuIDEgLSBTU0UgLyBTU1Q7XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9IYXJyeVN0ZXZlbnMvZDMtcmVncmVzc2lvbi9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmZ1bmN0aW9uIGxpbmVhciAoZGF0YSwgeCwgeSkge1xuICBsZXQgWCA9IDAsXG4gICAgICBZID0gMCxcbiAgICAgIFhZID0gMCxcbiAgICAgIFgyID0gMCxcbiAgICAgIG4gPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCAoZHgsIGR5KSA9PiB7XG4gICAgKytuO1xuICAgIFggKz0gKGR4IC0gWCkgLyBuO1xuICAgIFkgKz0gKGR5IC0gWSkgLyBuO1xuICAgIFhZICs9IChkeCAqIGR5IC0gWFkpIC8gbjtcbiAgICBYMiArPSAoZHggKiBkeCAtIFgyKSAvIG47XG4gIH0pO1xuXG4gIGNvbnN0IGNvZWYgPSBvbHMoWCwgWSwgWFksIFgyKSxcbiAgICAgICAgcHJlZGljdCA9IHggPT4gY29lZlswXSArIGNvZWZbMV0gKiB4O1xuXG4gIHJldHVybiB7XG4gICAgY29lZjogY29lZixcbiAgICBwcmVkaWN0OiBwcmVkaWN0LFxuICAgIHJTcXVhcmVkOiByU3F1YXJlZChkYXRhLCB4LCB5LCBZLCBwcmVkaWN0KVxuICB9O1xufVxuXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vSGFycnlTdGV2ZW5zL2QzLXJlZ3Jlc3Npb24vYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG5mdW5jdGlvbiBsb2cgKGRhdGEsIHgsIHkpIHtcbiAgbGV0IFggPSAwLFxuICAgICAgWSA9IDAsXG4gICAgICBYWSA9IDAsXG4gICAgICBYMiA9IDAsXG4gICAgICBuID0gMDtcbiAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgKGR4LCBkeSkgPT4ge1xuICAgICsrbjtcbiAgICBkeCA9IE1hdGgubG9nKGR4KTtcbiAgICBYICs9IChkeCAtIFgpIC8gbjtcbiAgICBZICs9IChkeSAtIFkpIC8gbjtcbiAgICBYWSArPSAoZHggKiBkeSAtIFhZKSAvIG47XG4gICAgWDIgKz0gKGR4ICogZHggLSBYMikgLyBuO1xuICB9KTtcblxuICBjb25zdCBjb2VmID0gb2xzKFgsIFksIFhZLCBYMiksXG4gICAgICAgIHByZWRpY3QgPSB4ID0+IGNvZWZbMF0gKyBjb2VmWzFdICogTWF0aC5sb2coeCk7XG5cbiAgcmV0dXJuIHtcbiAgICBjb2VmOiBjb2VmLFxuICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgclNxdWFyZWQ6IHJTcXVhcmVkKGRhdGEsIHgsIHksIFksIHByZWRpY3QpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cCAoZGF0YSwgeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5KTtcbiAgbGV0IFlMID0gMCxcbiAgICAgIFhZID0gMCxcbiAgICAgIFhZTCA9IDAsXG4gICAgICBYMlkgPSAwLFxuICAgICAgbiA9IDAsXG4gICAgICBkeCxcbiAgICAgIGx5LFxuICAgICAgeHk7XG4gIHZpc2l0UG9pbnRzKGRhdGEsIHgsIHksIChfLCBkeSkgPT4ge1xuICAgIGR4ID0geHZbbisrXTtcbiAgICBseSA9IE1hdGgubG9nKGR5KTtcbiAgICB4eSA9IGR4ICogZHk7XG4gICAgWUwgKz0gKGR5ICogbHkgLSBZTCkgLyBuO1xuICAgIFhZICs9ICh4eSAtIFhZKSAvIG47XG4gICAgWFlMICs9ICh4eSAqIGx5IC0gWFlMKSAvIG47XG4gICAgWDJZICs9IChkeCAqIHh5IC0gWDJZKSAvIG47XG4gIH0pO1xuXG4gIGNvbnN0IFtjMCwgYzFdID0gb2xzKFhZIC8gdXksIFlMIC8gdXksIFhZTCAvIHV5LCBYMlkgLyB1eSksXG4gICAgICAgIHByZWRpY3QgPSB4ID0+IE1hdGguZXhwKGMwICsgYzEgKiAoeCAtIHV4KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjb2VmOiBbTWF0aC5leHAoYzAgLSBjMSAqIHV4KSwgYzFdLFxuICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgclNxdWFyZWQ6IHJTcXVhcmVkKGRhdGEsIHgsIHksIHV5LCBwcmVkaWN0KVxuICB9O1xufVxuXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vSGFycnlTdGV2ZW5zL2QzLXJlZ3Jlc3Npb24vYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG5mdW5jdGlvbiBwb3cgKGRhdGEsIHgsIHkpIHtcbiAgbGV0IFggPSAwLFxuICAgICAgWSA9IDAsXG4gICAgICBYWSA9IDAsXG4gICAgICBYMiA9IDAsXG4gICAgICBZUyA9IDAsXG4gICAgICBuID0gMDtcbiAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgKGR4LCBkeSkgPT4ge1xuICAgIGNvbnN0IGx4ID0gTWF0aC5sb2coZHgpLFxuICAgICAgICAgIGx5ID0gTWF0aC5sb2coZHkpO1xuICAgICsrbjtcbiAgICBYICs9IChseCAtIFgpIC8gbjtcbiAgICBZICs9IChseSAtIFkpIC8gbjtcbiAgICBYWSArPSAobHggKiBseSAtIFhZKSAvIG47XG4gICAgWDIgKz0gKGx4ICogbHggLSBYMikgLyBuO1xuICAgIFlTICs9IChkeSAtIFlTKSAvIG47XG4gIH0pO1xuXG4gIGNvbnN0IGNvZWYgPSBvbHMoWCwgWSwgWFksIFgyKSxcbiAgICAgICAgcHJlZGljdCA9IHggPT4gY29lZlswXSAqIE1hdGgucG93KHgsIGNvZWZbMV0pO1xuXG4gIGNvZWZbMF0gPSBNYXRoLmV4cChjb2VmWzBdKTtcbiAgcmV0dXJuIHtcbiAgICBjb2VmOiBjb2VmLFxuICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgclNxdWFyZWQ6IHJTcXVhcmVkKGRhdGEsIHgsIHksIFlTLCBwcmVkaWN0KVxuICB9O1xufVxuXG5mdW5jdGlvbiBxdWFkIChkYXRhLCB4LCB5KSB7XG4gIGNvbnN0IFt4diwgeXYsIHV4LCB1eV0gPSBwb2ludHMoZGF0YSwgeCwgeSksXG4gICAgICAgIG4gPSB4di5sZW5ndGg7XG4gIGxldCBYMiA9IDAsXG4gICAgICBYMyA9IDAsXG4gICAgICBYNCA9IDAsXG4gICAgICBYWSA9IDAsXG4gICAgICBYMlkgPSAwLFxuICAgICAgaSxcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICB4MjtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjspIHtcbiAgICBkeCA9IHh2W2ldO1xuICAgIGR5ID0geXZbaSsrXTtcbiAgICB4MiA9IGR4ICogZHg7XG4gICAgWDIgKz0gKHgyIC0gWDIpIC8gaTtcbiAgICBYMyArPSAoeDIgKiBkeCAtIFgzKSAvIGk7XG4gICAgWDQgKz0gKHgyICogeDIgLSBYNCkgLyBpO1xuICAgIFhZICs9IChkeCAqIGR5IC0gWFkpIC8gaTtcbiAgICBYMlkgKz0gKHgyICogZHkgLSBYMlkpIC8gaTtcbiAgfVxuXG4gIGNvbnN0IFgyWDIgPSBYNCAtIFgyICogWDIsXG4gICAgICAgIGQgPSBYMiAqIFgyWDIgLSBYMyAqIFgzLFxuICAgICAgICBhID0gKFgyWSAqIFgyIC0gWFkgKiBYMykgLyBkLFxuICAgICAgICBiID0gKFhZICogWDJYMiAtIFgyWSAqIFgzKSAvIGQsXG4gICAgICAgIGMgPSAtYSAqIFgyLFxuICAgICAgICBwcmVkaWN0ID0geCA9PiB7XG4gICAgeCA9IHggLSB1eDtcbiAgICByZXR1cm4gYSAqIHggKiB4ICsgYiAqIHggKyBjICsgdXk7XG4gIH07IC8vIHRyYW5zZm9ybSBjb2VmZmljaWVudHMgYmFjayBmcm9tIG1lYW4tY2VudGVyZWQgc3BhY2VcblxuXG4gIHJldHVybiB7XG4gICAgY29lZjogW2MgLSBiICogdXggKyBhICogdXggKiB1eCArIHV5LCBiIC0gMiAqIGEgKiB1eCwgYV0sXG4gICAgcHJlZGljdDogcHJlZGljdCxcbiAgICByU3F1YXJlZDogclNxdWFyZWQoZGF0YSwgeCwgeSwgdXksIHByZWRpY3QpXG4gIH07XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9IYXJyeVN0ZXZlbnMvZDMtcmVncmVzc2lvbi9ibG9iL21hc3Rlci9MSUNFTlNFXG4vLyAuLi4gd2hpY2ggd2FzIGFkYXB0ZWQgZnJvbSByZWdyZXNzaW9uLWpzIGJ5IFRvbSBBbGV4YW5kZXJcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL1RvbS1BbGV4YW5kZXIvcmVncmVzc2lvbi1qcy9ibG9iL21hc3Rlci9zcmMvcmVncmVzc2lvbi5qcyNMMjQ2XG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vVG9tLUFsZXhhbmRlci9yZWdyZXNzaW9uLWpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuZnVuY3Rpb24gcG9seSAoZGF0YSwgeCwgeSwgb3JkZXIpIHtcbiAgLy8gdXNlIG1vcmUgZWZmaWNpZW50IG1ldGhvZHMgZm9yIGxvd2VyIG9yZGVyc1xuICBpZiAob3JkZXIgPT09IDEpIHJldHVybiBsaW5lYXIoZGF0YSwgeCwgeSk7XG4gIGlmIChvcmRlciA9PT0gMikgcmV0dXJuIHF1YWQoZGF0YSwgeCwgeSk7XG4gIGNvbnN0IFt4diwgeXYsIHV4LCB1eV0gPSBwb2ludHMoZGF0YSwgeCwgeSksXG4gICAgICAgIG4gPSB4di5sZW5ndGgsXG4gICAgICAgIGxocyA9IFtdLFxuICAgICAgICByaHMgPSBbXSxcbiAgICAgICAgayA9IG9yZGVyICsgMTtcbiAgbGV0IGksIGosIGwsIHYsIGM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGs7ICsraSkge1xuICAgIGZvciAobCA9IDAsIHYgPSAwOyBsIDwgbjsgKytsKSB7XG4gICAgICB2ICs9IE1hdGgucG93KHh2W2xdLCBpKSAqIHl2W2xdO1xuICAgIH1cblxuICAgIGxocy5wdXNoKHYpO1xuICAgIGMgPSBuZXcgRmxvYXQ2NEFycmF5KGspO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGs7ICsraikge1xuICAgICAgZm9yIChsID0gMCwgdiA9IDA7IGwgPCBuOyArK2wpIHtcbiAgICAgICAgdiArPSBNYXRoLnBvdyh4dltsXSwgaSArIGopO1xuICAgICAgfVxuXG4gICAgICBjW2pdID0gdjtcbiAgICB9XG5cbiAgICByaHMucHVzaChjKTtcbiAgfVxuXG4gIHJocy5wdXNoKGxocyk7XG5cbiAgY29uc3QgY29lZiA9IGdhdXNzaWFuRWxpbWluYXRpb24ocmhzKSxcbiAgICAgICAgcHJlZGljdCA9IHggPT4ge1xuICAgIHggLT0gdXg7XG4gICAgbGV0IHkgPSB1eSArIGNvZWZbMF0gKyBjb2VmWzFdICogeCArIGNvZWZbMl0gKiB4ICogeDtcblxuICAgIGZvciAoaSA9IDM7IGkgPCBrOyArK2kpIHkgKz0gY29lZltpXSAqIE1hdGgucG93KHgsIGkpO1xuXG4gICAgcmV0dXJuIHk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjb2VmOiB1bmNlbnRlcihrLCBjb2VmLCAtdXgsIHV5KSxcbiAgICBwcmVkaWN0OiBwcmVkaWN0LFxuICAgIHJTcXVhcmVkOiByU3F1YXJlZChkYXRhLCB4LCB5LCB1eSwgcHJlZGljdClcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5jZW50ZXIoaywgYSwgeCwgeSkge1xuICBjb25zdCB6ID0gQXJyYXkoayk7XG4gIGxldCBpLCBqLCB2LCBjOyAvLyBpbml0aWFsaXplIHRvIHplcm9cblxuICBmb3IgKGkgPSAwOyBpIDwgazsgKytpKSB6W2ldID0gMDsgLy8gcG9seW5vbWlhbCBleHBhbnNpb25cblxuXG4gIGZvciAoaSA9IGsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIHYgPSBhW2ldO1xuICAgIGMgPSAxO1xuICAgIHpbaV0gKz0gdjtcblxuICAgIGZvciAoaiA9IDE7IGogPD0gaTsgKytqKSB7XG4gICAgICBjICo9IChpICsgMSAtIGopIC8gajsgLy8gYmlub21pYWwgY29lZmZpY2VudFxuXG4gICAgICB6W2kgLSBqXSArPSB2ICogTWF0aC5wb3coeCwgaikgKiBjO1xuICAgIH1cbiAgfSAvLyBiaWFzIHRlcm1cblxuXG4gIHpbMF0gKz0geTtcbiAgcmV0dXJuIHo7XG59IC8vIEdpdmVuIGFuIGFycmF5IGZvciBhIHR3by1kaW1lbnNpb25hbCBtYXRyaXggYW5kIHRoZSBwb2x5bm9taWFsIG9yZGVyLFxuLy8gc29sdmUgQSAqIHggPSBiIHVzaW5nIEdhdXNzaWFuIGVsaW1pbmF0aW9uLlxuXG5cbmZ1bmN0aW9uIGdhdXNzaWFuRWxpbWluYXRpb24obWF0cml4KSB7XG4gIGNvbnN0IG4gPSBtYXRyaXgubGVuZ3RoIC0gMSxcbiAgICAgICAgY29lZiA9IFtdO1xuICBsZXQgaSwgaiwgaywgciwgdDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgciA9IGk7IC8vIG1heCByb3dcblxuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICBpZiAoTWF0aC5hYnMobWF0cml4W2ldW2pdKSA+IE1hdGguYWJzKG1hdHJpeFtpXVtyXSkpIHtcbiAgICAgICAgciA9IGo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrID0gaTsgayA8IG4gKyAxOyArK2spIHtcbiAgICAgIHQgPSBtYXRyaXhba11baV07XG4gICAgICBtYXRyaXhba11baV0gPSBtYXRyaXhba11bcl07XG4gICAgICBtYXRyaXhba11bcl0gPSB0O1xuICAgIH1cblxuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICBmb3IgKGsgPSBuOyBrID49IGk7IGstLSkge1xuICAgICAgICBtYXRyaXhba11bal0gLT0gbWF0cml4W2tdW2ldICogbWF0cml4W2ldW2pdIC8gbWF0cml4W2ldW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoaiA9IG4gLSAxOyBqID49IDA7IC0taikge1xuICAgIHQgPSAwO1xuXG4gICAgZm9yIChrID0gaiArIDE7IGsgPCBuOyArK2spIHtcbiAgICAgIHQgKz0gbWF0cml4W2tdW2pdICogY29lZltrXTtcbiAgICB9XG5cbiAgICBjb2VmW2pdID0gKG1hdHJpeFtuXVtqXSAtIHQpIC8gbWF0cml4W2pdW2pdO1xuICB9XG5cbiAgcmV0dXJuIGNvZWY7XG59XG5cbmNvbnN0IG1heGl0ZXJzID0gMixcbiAgICAgIGVwc2lsb24gPSAxZS0xMjsgLy8gQWRhcHRlZCBmcm9tIHNjaWVuY2UuanMgYnkgSmFzb24gRGF2aWVzXG4vLyBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNvbmRhdmllcy9zY2llbmNlLmpzL2Jsb2IvbWFzdGVyL3NyYy9zdGF0cy9sb2Vzcy5qc1xuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL2phc29uZGF2aWVzL3NjaWVuY2UuanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG5mdW5jdGlvbiBsb2VzcyAoZGF0YSwgeCwgeSwgYmFuZHdpZHRoKSB7XG4gIGNvbnN0IFt4diwgeXYsIHV4LCB1eV0gPSBwb2ludHMoZGF0YSwgeCwgeSwgdHJ1ZSksXG4gICAgICAgIG4gPSB4di5sZW5ndGgsXG4gICAgICAgIGJ3ID0gTWF0aC5tYXgoMiwgfn4oYmFuZHdpZHRoICogbikpLFxuICAgICAgICAvLyAjIG5lYXJlc3QgbmVpZ2hib3JzXG4gIHloYXQgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLFxuICAgICAgICByZXNpZHVhbHMgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLFxuICAgICAgICByb2J1c3RXZWlnaHRzID0gbmV3IEZsb2F0NjRBcnJheShuKS5maWxsKDEpO1xuXG4gIGZvciAobGV0IGl0ZXIgPSAtMTsgKytpdGVyIDw9IG1heGl0ZXJzOykge1xuICAgIGNvbnN0IGludGVydmFsID0gWzAsIGJ3IC0gMV07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgZHggPSB4dltpXSxcbiAgICAgICAgICAgIGkwID0gaW50ZXJ2YWxbMF0sXG4gICAgICAgICAgICBpMSA9IGludGVydmFsWzFdLFxuICAgICAgICAgICAgZWRnZSA9IGR4IC0geHZbaTBdID4geHZbaTFdIC0gZHggPyBpMCA6IGkxO1xuICAgICAgbGV0IFcgPSAwLFxuICAgICAgICAgIFggPSAwLFxuICAgICAgICAgIFkgPSAwLFxuICAgICAgICAgIFhZID0gMCxcbiAgICAgICAgICBYMiA9IDA7XG4gICAgICBjb25zdCBkZW5vbSA9IDEgLyBNYXRoLmFicyh4dltlZGdlXSAtIGR4IHx8IDEpOyAvLyBhdm9pZCBzaW5ndWxhcml0eSFcblxuICAgICAgZm9yIChsZXQgayA9IGkwOyBrIDw9IGkxOyArK2spIHtcbiAgICAgICAgY29uc3QgeGsgPSB4dltrXSxcbiAgICAgICAgICAgICAgeWsgPSB5dltrXSxcbiAgICAgICAgICAgICAgdyA9IHRyaWN1YmUoTWF0aC5hYnMoZHggLSB4aykgKiBkZW5vbSkgKiByb2J1c3RXZWlnaHRzW2tdLFxuICAgICAgICAgICAgICB4a3cgPSB4ayAqIHc7XG4gICAgICAgIFcgKz0gdztcbiAgICAgICAgWCArPSB4a3c7XG4gICAgICAgIFkgKz0geWsgKiB3O1xuICAgICAgICBYWSArPSB5ayAqIHhrdztcbiAgICAgICAgWDIgKz0geGsgKiB4a3c7XG4gICAgICB9IC8vIGxpbmVhciByZWdyZXNzaW9uIGZpdFxuXG5cbiAgICAgIGNvbnN0IFthLCBiXSA9IG9scyhYIC8gVywgWSAvIFcsIFhZIC8gVywgWDIgLyBXKTtcbiAgICAgIHloYXRbaV0gPSBhICsgYiAqIGR4O1xuICAgICAgcmVzaWR1YWxzW2ldID0gTWF0aC5hYnMoeXZbaV0gLSB5aGF0W2ldKTtcbiAgICAgIHVwZGF0ZUludGVydmFsKHh2LCBpICsgMSwgaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIGlmIChpdGVyID09PSBtYXhpdGVycykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgbWVkaWFuUmVzaWR1YWwgPSBtZWRpYW4ocmVzaWR1YWxzKTtcbiAgICBpZiAoTWF0aC5hYnMobWVkaWFuUmVzaWR1YWwpIDwgZXBzaWxvbikgYnJlYWs7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgYXJnLCB3OyBpIDwgbjsgKytpKSB7XG4gICAgICBhcmcgPSByZXNpZHVhbHNbaV0gLyAoNiAqIG1lZGlhblJlc2lkdWFsKTsgLy8gZGVmYXVsdCB0byBlcHNpbG9uIChyYXRoZXIgdGhhbiB6ZXJvKSBmb3IgbGFyZ2UgZGV2aWF0aW9uc1xuICAgICAgLy8ga2VlcGluZyB3ZWlnaHRzIHRpbnkgYnV0IG5vbi16ZXJvIHByZXZlbnRzIHNpbmd1bGFyaXRlc1xuXG4gICAgICByb2J1c3RXZWlnaHRzW2ldID0gYXJnID49IDEgPyBlcHNpbG9uIDogKHcgPSAxIC0gYXJnICogYXJnKSAqIHc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dCh4diwgeWhhdCwgdXgsIHV5KTtcbn0gLy8gd2VpZ2h0aW5nIGtlcm5lbCBmb3IgbG9jYWwgcmVncmVzc2lvblxuXG5mdW5jdGlvbiB0cmljdWJlKHgpIHtcbiAgcmV0dXJuICh4ID0gMSAtIHggKiB4ICogeCkgKiB4ICogeDtcbn0gLy8gYWR2YW5jZSBzbGlkaW5nIHdpbmRvdyBpbnRlcnZhbCBvZiBuZWFyZXN0IG5laWdoYm9yc1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZUludGVydmFsKHh2LCBpLCBpbnRlcnZhbCkge1xuICBjb25zdCB2YWwgPSB4dltpXTtcbiAgbGV0IGxlZnQgPSBpbnRlcnZhbFswXSxcbiAgICAgIHJpZ2h0ID0gaW50ZXJ2YWxbMV0gKyAxO1xuICBpZiAocmlnaHQgPj0geHYubGVuZ3RoKSByZXR1cm47IC8vIHN0ZXAgcmlnaHQgaWYgZGlzdGFuY2UgdG8gbmV3IHJpZ2h0IGVkZ2UgaXMgPD0gZGlzdGFuY2UgdG8gb2xkIGxlZnQgZWRnZVxuICAvLyBzdGVwIHdoZW4gZGlzdGFuY2UgaXMgZXF1YWwgdG8gZW5zdXJlIG1vdmVtZW50IG92ZXIgZHVwbGljYXRlIHggdmFsdWVzXG5cbiAgd2hpbGUgKGkgPiBsZWZ0ICYmIHh2W3JpZ2h0XSAtIHZhbCA8PSB2YWwgLSB4dltsZWZ0XSkge1xuICAgIGludGVydmFsWzBdID0gKytsZWZ0O1xuICAgIGludGVydmFsWzFdID0gcmlnaHQ7XG4gICAgKytyaWdodDtcbiAgfVxufSAvLyBnZW5lcmF0ZSBzbW9vdGhlZCBvdXRwdXQgcG9pbnRzXG4vLyBhdmVyYWdlIHBvaW50cyB3aXRoIHJlcGVhdGVkIHggdmFsdWVzXG5cblxuZnVuY3Rpb24gb3V0cHV0KHh2LCB5aGF0LCB1eCwgdXkpIHtcbiAgY29uc3QgbiA9IHh2Lmxlbmd0aCxcbiAgICAgICAgb3V0ID0gW107XG4gIGxldCBpID0gMCxcbiAgICAgIGNudCA9IDAsXG4gICAgICBwcmV2ID0gW10sXG4gICAgICB2O1xuXG4gIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgdiA9IHh2W2ldICsgdXg7XG5cbiAgICBpZiAocHJldlswXSA9PT0gdikge1xuICAgICAgLy8gYXZlcmFnZSBvdXRwdXQgdmFsdWVzIHZpYSBvbmxpbmUgdXBkYXRlXG4gICAgICBwcmV2WzFdICs9ICh5aGF0W2ldIC0gcHJldlsxXSkgLyArK2NudDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWRkIG5ldyBvdXRwdXQgcG9pbnRcbiAgICAgIGNudCA9IDA7XG4gICAgICBwcmV2WzFdICs9IHV5O1xuICAgICAgcHJldiA9IFt2LCB5aGF0W2ldXTtcbiAgICAgIG91dC5wdXNoKHByZXYpO1xuICAgIH1cbiAgfVxuXG4gIHByZXZbMV0gKz0gdXk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIHN1YmRpdmlkZSB1cCB0byBhY2N1cmFjeSBvZiAwLjUgZGVncmVlc1xuY29uc3QgTUlOX1JBRElBTlMgPSAwLjUgKiBNYXRoLlBJIC8gMTgwOyAvLyBBZGFwdGl2ZWx5IHNhbXBsZSBhbiBpbnRlcnBvbGF0ZWQgZnVuY3Rpb24gb3ZlciBhIGRvbWFpbiBleHRlbnRcblxuZnVuY3Rpb24gc2FtcGxlQ3VydmUgKGYsIGV4dGVudCwgbWluU3RlcHMsIG1heFN0ZXBzKSB7XG4gIG1pblN0ZXBzID0gbWluU3RlcHMgfHwgMjU7XG4gIG1heFN0ZXBzID0gTWF0aC5tYXgobWluU3RlcHMsIG1heFN0ZXBzIHx8IDIwMCk7XG5cbiAgY29uc3QgcG9pbnQgPSB4ID0+IFt4LCBmKHgpXSxcbiAgICAgICAgbWluWCA9IGV4dGVudFswXSxcbiAgICAgICAgbWF4WCA9IGV4dGVudFsxXSxcbiAgICAgICAgc3BhbiA9IG1heFggLSBtaW5YLFxuICAgICAgICBzdG9wID0gc3BhbiAvIG1heFN0ZXBzLFxuICAgICAgICBwcmV2ID0gW3BvaW50KG1pblgpXSxcbiAgICAgICAgbmV4dCA9IFtdO1xuXG4gIGlmIChtaW5TdGVwcyA9PT0gbWF4U3RlcHMpIHtcbiAgICAvLyBubyBhZGFwdGF0aW9uLCBzYW1wbGUgdW5pZm9ybSBncmlkIGRpcmVjdGx5IGFuZCByZXR1cm5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1heFN0ZXBzOyArK2kpIHtcbiAgICAgIHByZXYucHVzaChwb2ludChtaW5YICsgaSAvIG1pblN0ZXBzICogc3BhbikpO1xuICAgIH1cblxuICAgIHByZXYucHVzaChwb2ludChtYXhYKSk7XG4gICAgcmV0dXJuIHByZXY7XG4gIH0gZWxzZSB7XG4gICAgLy8gc2FtcGxlIG1pbmltdW0gcG9pbnRzIG9uIHVuaWZvcm0gZ3JpZFxuICAgIC8vIHRoZW4gbW92ZSBvbiB0byBwZXJmb3JtIGFkYXB0aXZlIHJlZmluZW1lbnRcbiAgICBuZXh0LnB1c2gocG9pbnQobWF4WCkpO1xuXG4gICAgZm9yIChsZXQgaSA9IG1pblN0ZXBzOyAtLWkgPiAwOykge1xuICAgICAgbmV4dC5wdXNoKHBvaW50KG1pblggKyBpIC8gbWluU3RlcHMgKiBzcGFuKSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHAwID0gcHJldlswXTtcbiAgbGV0IHAxID0gbmV4dFtuZXh0Lmxlbmd0aCAtIDFdO1xuICBjb25zdCBzeCA9IDEgLyBzcGFuO1xuICBjb25zdCBzeSA9IHNjYWxlWShwMFsxXSwgbmV4dCk7XG5cbiAgd2hpbGUgKHAxKSB7XG4gICAgLy8gbWlkcG9pbnQgZm9yIHBvdGVudGlhbCBjdXJ2ZSBzdWJkaXZpc2lvblxuICAgIGNvbnN0IHBtID0gcG9pbnQoKHAwWzBdICsgcDFbMF0pIC8gMik7XG4gICAgY29uc3QgZHggPSBwbVswXSAtIHAwWzBdID49IHN0b3A7XG5cbiAgICBpZiAoZHggJiYgYW5nbGVEZWx0YShwMCwgcG0sIHAxLCBzeCwgc3kpID4gTUlOX1JBRElBTlMpIHtcbiAgICAgIC8vIG1heGltdW0gcmVzb2x1dGlvbiBoYXMgbm90IHlldCBiZWVuIG1ldCwgYW5kXG4gICAgICAvLyBzdWJkaXZpc2lvbiBtaWRwb2ludCBpcyBzdWZmaWNpZW50bHkgZGlmZmVyZW50IGZyb20gZW5kcG9pbnRcbiAgICAgIC8vIHNhdmUgc3ViZGl2aXNpb24sIHB1c2ggbWlkcG9pbnQgb250byB0aGUgdmlzaXRhdGlvbiBzdGFja1xuICAgICAgbmV4dC5wdXNoKHBtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3ViZGl2aXNpb24gbWlkcG9pbnQgc3VmZmljaWVudGx5IHNpbWlsYXIgdG8gZW5kcG9pbnRcbiAgICAgIC8vIHNraXAgc3ViZGl2aXNpb24sIHN0b3JlIGVuZHBvaW50LCBtb3ZlIHRvIG5leHQgcG9pbnQgb24gdGhlIHN0YWNrXG4gICAgICBwMCA9IHAxO1xuICAgICAgcHJldi5wdXNoKHAxKTtcbiAgICAgIG5leHQucG9wKCk7XG4gICAgfVxuXG4gICAgcDEgPSBuZXh0W25leHQubGVuZ3RoIC0gMV07XG4gIH1cblxuICByZXR1cm4gcHJldjtcbn1cblxuZnVuY3Rpb24gc2NhbGVZKGluaXQsIHBvaW50cykge1xuICBsZXQgeW1pbiA9IGluaXQ7XG4gIGxldCB5bWF4ID0gaW5pdDtcbiAgY29uc3QgbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCB5ID0gcG9pbnRzW2ldWzFdO1xuICAgIGlmICh5IDwgeW1pbikgeW1pbiA9IHk7XG4gICAgaWYgKHkgPiB5bWF4KSB5bWF4ID0geTtcbiAgfVxuXG4gIHJldHVybiAxIC8gKHltYXggLSB5bWluKTtcbn1cblxuZnVuY3Rpb24gYW5nbGVEZWx0YShwLCBxLCByLCBzeCwgc3kpIHtcbiAgY29uc3QgYTAgPSBNYXRoLmF0YW4yKHN5ICogKHJbMV0gLSBwWzFdKSwgc3ggKiAoclswXSAtIHBbMF0pKSxcbiAgICAgICAgYTEgPSBNYXRoLmF0YW4yKHN5ICogKHFbMV0gLSBwWzFdKSwgc3ggKiAocVswXSAtIHBbMF0pKTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYTEpO1xufVxuXG5leHBvcnQgeyBlc3RpbWF0ZUJhbmR3aWR0aCBhcyBiYW5kd2lkdGhOUkQsIGJpbiwgYm9vdHN0cmFwQ0ksIGN1bXVsYXRpdmVMb2dOb3JtYWwsIGN1bXVsYXRpdmVOb3JtYWwsIGN1bXVsYXRpdmVVbmlmb3JtLCBkZW5zaXR5TG9nTm9ybWFsLCBkZW5zaXR5Tm9ybWFsLCBkZW5zaXR5VW5pZm9ybSwgZG90YmluLCBxdWFudGlsZUxvZ05vcm1hbCwgcXVhbnRpbGVOb3JtYWwsIHF1YW50aWxlVW5pZm9ybSwgcXVhbnRpbGVzLCBxdWFydGlsZXMsIHJhbmRvbSwgaW50ZWdlciBhcyByYW5kb21JbnRlZ2VyLCBrZGUgYXMgcmFuZG9tS0RFLCBsY2cgYXMgcmFuZG9tTENHLCBsb2dub3JtYWwgYXMgcmFuZG9tTG9nTm9ybWFsLCBtaXh0dXJlIGFzIHJhbmRvbU1peHR1cmUsIGdhdXNzaWFuIGFzIHJhbmRvbU5vcm1hbCwgdW5pZm9ybSBhcyByYW5kb21Vbmlmb3JtLCBleHAgYXMgcmVncmVzc2lvbkV4cCwgbGluZWFyIGFzIHJlZ3Jlc3Npb25MaW5lYXIsIGxvZXNzIGFzIHJlZ3Jlc3Npb25Mb2VzcywgbG9nIGFzIHJlZ3Jlc3Npb25Mb2csIHBvbHkgYXMgcmVncmVzc2lvblBvbHksIHBvdyBhcyByZWdyZXNzaW9uUG93LCBxdWFkIGFzIHJlZ3Jlc3Npb25RdWFkLCBzYW1wbGVDdXJ2ZSwgc2FtcGxlTG9nTm9ybWFsLCBzYW1wbGVOb3JtYWwsIHNhbXBsZVVuaWZvcm0sIHNldFJhbmRvbSB9O1xuIiwiaW1wb3J0IHsgYXJyYXksIGVycm9yLCBoYXNPd25Qcm9wZXJ0eSwgZXh0ZW5kLCBwZWVrLCB0b1NldCwgY29uc3RhbnQsIHplcm8sIG9uZSwgc3BhbiB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyB0aW1lRGF5LCB0aW1lV2VlaywgdXRjRGF5LCB1dGNXZWVrLCB0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lSG91ciwgdGltZU1pbnV0ZSwgdGltZVNlY29uZCwgdGltZU1pbGxpc2Vjb25kLCB1dGNZZWFyLCB1dGNNb250aCwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y01pbGxpc2Vjb25kIH0gZnJvbSAnZDMtdGltZSc7XG5pbXBvcnQgeyBiaXNlY3RvciwgdGlja1N0ZXAgfSBmcm9tICdkMy1hcnJheSc7XG5cbmNvbnN0IFlFQVIgPSAneWVhcic7XG5jb25zdCBRVUFSVEVSID0gJ3F1YXJ0ZXInO1xuY29uc3QgTU9OVEggPSAnbW9udGgnO1xuY29uc3QgV0VFSyA9ICd3ZWVrJztcbmNvbnN0IERBVEUgPSAnZGF0ZSc7XG5jb25zdCBEQVkgPSAnZGF5JztcbmNvbnN0IERBWU9GWUVBUiA9ICdkYXlvZnllYXInO1xuY29uc3QgSE9VUlMgPSAnaG91cnMnO1xuY29uc3QgTUlOVVRFUyA9ICdtaW51dGVzJztcbmNvbnN0IFNFQ09ORFMgPSAnc2Vjb25kcyc7XG5jb25zdCBNSUxMSVNFQ09ORFMgPSAnbWlsbGlzZWNvbmRzJztcbmNvbnN0IFRJTUVfVU5JVFMgPSBbWUVBUiwgUVVBUlRFUiwgTU9OVEgsIFdFRUssIERBVEUsIERBWSwgREFZT0ZZRUFSLCBIT1VSUywgTUlOVVRFUywgU0VDT05EUywgTUlMTElTRUNPTkRTXTtcbmNvbnN0IFVOSVRTID0gVElNRV9VTklUUy5yZWR1Y2UoKG8sIHUsIGkpID0+IChvW3VdID0gMSArIGksIG8pLCB7fSk7XG5mdW5jdGlvbiB0aW1lVW5pdHModW5pdHMpIHtcbiAgY29uc3QgdSA9IGFycmF5KHVuaXRzKS5zbGljZSgpLFxuICAgICAgICBtID0ge307IC8vIGNoZWNrIHZhbGlkaXR5XG5cbiAgaWYgKCF1Lmxlbmd0aCkgZXJyb3IoJ01pc3NpbmcgdGltZSB1bml0LicpO1xuICB1LmZvckVhY2godW5pdCA9PiB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KFVOSVRTLCB1bml0KSkge1xuICAgICAgbVt1bml0XSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKFwiSW52YWxpZCB0aW1lIHVuaXQ6IFwiLmNvbmNhdCh1bml0LCBcIi5cIikpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG51bVR5cGVzID0gKG1bV0VFS10gfHwgbVtEQVldID8gMSA6IDApICsgKG1bUVVBUlRFUl0gfHwgbVtNT05USF0gfHwgbVtEQVRFXSA/IDEgOiAwKSArIChtW0RBWU9GWUVBUl0gPyAxIDogMCk7XG5cbiAgaWYgKG51bVR5cGVzID4gMSkge1xuICAgIGVycm9yKFwiSW5jb21wYXRpYmxlIHRpbWUgdW5pdHM6IFwiLmNvbmNhdCh1bml0cykpO1xuICB9IC8vIGVuc3VyZSBwcm9wZXIgc29ydCBvcmRlclxuXG5cbiAgdS5zb3J0KChhLCBiKSA9PiBVTklUU1thXSAtIFVOSVRTW2JdKTtcbiAgcmV0dXJuIHU7XG59XG5jb25zdCBkZWZhdWx0U3BlY2lmaWVycyA9IHtcbiAgW1lFQVJdOiAnJVkgJyxcbiAgW1FVQVJURVJdOiAnUSVxICcsXG4gIFtNT05USF06ICclYiAnLFxuICBbREFURV06ICclZCAnLFxuICBbV0VFS106ICdXJVUgJyxcbiAgW0RBWV06ICclYSAnLFxuICBbREFZT0ZZRUFSXTogJyVqICcsXG4gIFtIT1VSU106ICclSDowMCcsXG4gIFtNSU5VVEVTXTogJzAwOiVNJyxcbiAgW1NFQ09ORFNdOiAnOiVTJyxcbiAgW01JTExJU0VDT05EU106ICcuJUwnLFxuICBbXCJcIi5jb25jYXQoWUVBUiwgXCItXCIpLmNvbmNhdChNT05USCldOiAnJVktJW0gJyxcbiAgW1wiXCIuY29uY2F0KFlFQVIsIFwiLVwiKS5jb25jYXQoTU9OVEgsIFwiLVwiKS5jb25jYXQoREFURSldOiAnJVktJW0tJWQgJyxcbiAgW1wiXCIuY29uY2F0KEhPVVJTLCBcIi1cIikuY29uY2F0KE1JTlVURVMpXTogJyVIOiVNJ1xufTtcbmZ1bmN0aW9uIHRpbWVVbml0U3BlY2lmaWVyKHVuaXRzLCBzcGVjaWZpZXJzKSB7XG4gIGNvbnN0IHMgPSBleHRlbmQoe30sIGRlZmF1bHRTcGVjaWZpZXJzLCBzcGVjaWZpZXJzKSxcbiAgICAgICAgdSA9IHRpbWVVbml0cyh1bml0cyksXG4gICAgICAgIG4gPSB1Lmxlbmd0aDtcbiAgbGV0IGZtdCA9ICcnLFxuICAgICAgc3RhcnQgPSAwLFxuICAgICAgZW5kLFxuICAgICAga2V5O1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IG47KSB7XG4gICAgZm9yIChlbmQgPSB1Lmxlbmd0aDsgZW5kID4gc3RhcnQ7IC0tZW5kKSB7XG4gICAgICBrZXkgPSB1LnNsaWNlKHN0YXJ0LCBlbmQpLmpvaW4oJy0nKTtcblxuICAgICAgaWYgKHNba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIGZtdCArPSBzW2tleV07XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm10LnRyaW0oKTtcbn1cblxuY29uc3QgdDAgPSBuZXcgRGF0ZSgpO1xuXG5mdW5jdGlvbiBsb2NhbFllYXIoeSkge1xuICB0MC5zZXRGdWxsWWVhcih5KTtcbiAgdDAuc2V0TW9udGgoMCk7XG4gIHQwLnNldERhdGUoMSk7XG4gIHQwLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gdDA7XG59XG5cbmZ1bmN0aW9uIGRheW9meWVhcihkKSB7XG4gIHJldHVybiBsb2NhbERheU9mWWVhcihuZXcgRGF0ZShkKSk7XG59XG5mdW5jdGlvbiB3ZWVrKGQpIHtcbiAgcmV0dXJuIGxvY2FsV2Vla051bShuZXcgRGF0ZShkKSk7XG59XG5mdW5jdGlvbiBsb2NhbERheU9mWWVhcihkKSB7XG4gIHJldHVybiB0aW1lRGF5LmNvdW50KGxvY2FsWWVhcihkLmdldEZ1bGxZZWFyKCkpIC0gMSwgZCk7XG59XG5mdW5jdGlvbiBsb2NhbFdlZWtOdW0oZCkge1xuICByZXR1cm4gdGltZVdlZWsuY291bnQobG9jYWxZZWFyKGQuZ2V0RnVsbFllYXIoKSkgLSAxLCBkKTtcbn1cbmZ1bmN0aW9uIGxvY2FsRmlyc3QoeSkge1xuICByZXR1cm4gbG9jYWxZZWFyKHkpLmdldERheSgpO1xufVxuZnVuY3Rpb24gbG9jYWxEYXRlKHksIG0sIGQsIEgsIE0sIFMsIEwpIHtcbiAgaWYgKDAgPD0geSAmJiB5IDwgMTAwKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKC0xLCBtLCBkLCBILCBNLCBTLCBMKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQsIEgsIE0sIFMsIEwpO1xufVxuZnVuY3Rpb24gdXRjZGF5b2Z5ZWFyKGQpIHtcbiAgcmV0dXJuIHV0Y0RheU9mWWVhcihuZXcgRGF0ZShkKSk7XG59XG5mdW5jdGlvbiB1dGN3ZWVrKGQpIHtcbiAgcmV0dXJuIHV0Y1dlZWtOdW0obmV3IERhdGUoZCkpO1xufVxuZnVuY3Rpb24gdXRjRGF5T2ZZZWFyKGQpIHtcbiAgY29uc3QgeSA9IERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSk7XG4gIHJldHVybiB1dGNEYXkuY291bnQoeSAtIDEsIGQpO1xufVxuZnVuY3Rpb24gdXRjV2Vla051bShkKSB7XG4gIGNvbnN0IHkgPSBEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpO1xuICByZXR1cm4gdXRjV2Vlay5jb3VudCh5IC0gMSwgZCk7XG59XG5mdW5jdGlvbiB1dGNGaXJzdCh5KSB7XG4gIHQwLnNldFRpbWUoRGF0ZS5VVEMoeSwgMCwgMSkpO1xuICByZXR1cm4gdDAuZ2V0VVRDRGF5KCk7XG59XG5mdW5jdGlvbiB1dGNEYXRlKHksIG0sIGQsIEgsIE0sIFMsIEwpIHtcbiAgaWYgKDAgPD0geSAmJiB5IDwgMTAwKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKC0xLCBtLCBkLCBILCBNLCBTLCBMKSk7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkLnkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHksIG0sIGQsIEgsIE0sIFMsIEwpKTtcbn1cblxuZnVuY3Rpb24gZmxvb3IodW5pdHMsIHN0ZXAsIGdldCwgaW52LCBuZXdEYXRlKSB7XG4gIGNvbnN0IHMgPSBzdGVwIHx8IDEsXG4gICAgICAgIGIgPSBwZWVrKHVuaXRzKSxcbiAgICAgICAgXyA9ICh1bml0LCBwLCBrZXkpID0+IHtcbiAgICBrZXkgPSBrZXkgfHwgdW5pdDtcbiAgICByZXR1cm4gZ2V0VW5pdChnZXRba2V5XSwgaW52W2tleV0sIHVuaXQgPT09IGIgJiYgcywgcCk7XG4gIH07XG5cbiAgY29uc3QgdCA9IG5ldyBEYXRlKCksXG4gICAgICAgIHUgPSB0b1NldCh1bml0cyksXG4gICAgICAgIHkgPSB1W1lFQVJdID8gXyhZRUFSKSA6IGNvbnN0YW50KDIwMTIpLFxuICAgICAgICBtID0gdVtNT05USF0gPyBfKE1PTlRIKSA6IHVbUVVBUlRFUl0gPyBfKFFVQVJURVIpIDogemVybyxcbiAgICAgICAgZCA9IHVbV0VFS10gJiYgdVtEQVldID8gXyhEQVksIDEsIFdFRUsgKyBEQVkpIDogdVtXRUVLXSA/IF8oV0VFSywgMSkgOiB1W0RBWV0gPyBfKERBWSwgMSkgOiB1W0RBVEVdID8gXyhEQVRFLCAxKSA6IHVbREFZT0ZZRUFSXSA/IF8oREFZT0ZZRUFSLCAxKSA6IG9uZSxcbiAgICAgICAgSCA9IHVbSE9VUlNdID8gXyhIT1VSUykgOiB6ZXJvLFxuICAgICAgICBNID0gdVtNSU5VVEVTXSA/IF8oTUlOVVRFUykgOiB6ZXJvLFxuICAgICAgICBTID0gdVtTRUNPTkRTXSA/IF8oU0VDT05EUykgOiB6ZXJvLFxuICAgICAgICBMID0gdVtNSUxMSVNFQ09ORFNdID8gXyhNSUxMSVNFQ09ORFMpIDogemVybztcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgdC5zZXRUaW1lKCt2KTtcbiAgICBjb25zdCB5ZWFyID0geSh0KTtcbiAgICByZXR1cm4gbmV3RGF0ZSh5ZWFyLCBtKHQpLCBkKHQsIHllYXIpLCBIKHQpLCBNKHQpLCBTKHQpLCBMKHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VW5pdChmLCBpbnYsIHN0ZXAsIHBoYXNlKSB7XG4gIGNvbnN0IHUgPSBzdGVwIDw9IDEgPyBmIDogcGhhc2UgPyAoZCwgeSkgPT4gcGhhc2UgKyBzdGVwICogTWF0aC5mbG9vcigoZihkLCB5KSAtIHBoYXNlKSAvIHN0ZXApIDogKGQsIHkpID0+IHN0ZXAgKiBNYXRoLmZsb29yKGYoZCwgeSkgLyBzdGVwKTtcbiAgcmV0dXJuIGludiA/IChkLCB5KSA9PiBpbnYodShkLCB5KSwgeSkgOiB1O1xufSAvLyByZXR1cm5zIHRoZSBkYXkgb2YgdGhlIHllYXIgYmFzZWQgb24gd2VlayBudW1iZXIsIGRheSBvZiB3ZWVrLFxuLy8gYW5kIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHllYXJcblxuXG5mdW5jdGlvbiB3ZWVrZGF5KHdlZWssIGRheSwgZmlyc3REYXkpIHtcbiAgcmV0dXJuIGRheSArIHdlZWsgKiA3IC0gKGZpcnN0RGF5ICsgNikgJSA3O1xufSAvLyAtLSBMT0NBTCBUSU1FIC0tXG5cblxuY29uc3QgbG9jYWxHZXQgPSB7XG4gIFtZRUFSXTogZCA9PiBkLmdldEZ1bGxZZWFyKCksXG4gIFtRVUFSVEVSXTogZCA9PiBNYXRoLmZsb29yKGQuZ2V0TW9udGgoKSAvIDMpLFxuICBbTU9OVEhdOiBkID0+IGQuZ2V0TW9udGgoKSxcbiAgW0RBVEVdOiBkID0+IGQuZ2V0RGF0ZSgpLFxuICBbSE9VUlNdOiBkID0+IGQuZ2V0SG91cnMoKSxcbiAgW01JTlVURVNdOiBkID0+IGQuZ2V0TWludXRlcygpLFxuICBbU0VDT05EU106IGQgPT4gZC5nZXRTZWNvbmRzKCksXG4gIFtNSUxMSVNFQ09ORFNdOiBkID0+IGQuZ2V0TWlsbGlzZWNvbmRzKCksXG4gIFtEQVlPRllFQVJdOiBkID0+IGxvY2FsRGF5T2ZZZWFyKGQpLFxuICBbV0VFS106IGQgPT4gbG9jYWxXZWVrTnVtKGQpLFxuICBbV0VFSyArIERBWV06IChkLCB5KSA9PiB3ZWVrZGF5KGxvY2FsV2Vla051bShkKSwgZC5nZXREYXkoKSwgbG9jYWxGaXJzdCh5KSksXG4gIFtEQVldOiAoZCwgeSkgPT4gd2Vla2RheSgxLCBkLmdldERheSgpLCBsb2NhbEZpcnN0KHkpKVxufTtcbmNvbnN0IGxvY2FsSW52ID0ge1xuICBbUVVBUlRFUl06IHEgPT4gMyAqIHEsXG4gIFtXRUVLXTogKHcsIHkpID0+IHdlZWtkYXkodywgMCwgbG9jYWxGaXJzdCh5KSlcbn07XG5mdW5jdGlvbiB0aW1lRmxvb3IodW5pdHMsIHN0ZXApIHtcbiAgcmV0dXJuIGZsb29yKHVuaXRzLCBzdGVwIHx8IDEsIGxvY2FsR2V0LCBsb2NhbEludiwgbG9jYWxEYXRlKTtcbn0gLy8gLS0gVVRDIFRJTUUgLS1cblxuY29uc3QgdXRjR2V0ID0ge1xuICBbWUVBUl06IGQgPT4gZC5nZXRVVENGdWxsWWVhcigpLFxuICBbUVVBUlRFUl06IGQgPT4gTWF0aC5mbG9vcihkLmdldFVUQ01vbnRoKCkgLyAzKSxcbiAgW01PTlRIXTogZCA9PiBkLmdldFVUQ01vbnRoKCksXG4gIFtEQVRFXTogZCA9PiBkLmdldFVUQ0RhdGUoKSxcbiAgW0hPVVJTXTogZCA9PiBkLmdldFVUQ0hvdXJzKCksXG4gIFtNSU5VVEVTXTogZCA9PiBkLmdldFVUQ01pbnV0ZXMoKSxcbiAgW1NFQ09ORFNdOiBkID0+IGQuZ2V0VVRDU2Vjb25kcygpLFxuICBbTUlMTElTRUNPTkRTXTogZCA9PiBkLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICBbREFZT0ZZRUFSXTogZCA9PiB1dGNEYXlPZlllYXIoZCksXG4gIFtXRUVLXTogZCA9PiB1dGNXZWVrTnVtKGQpLFxuICBbREFZXTogKGQsIHkpID0+IHdlZWtkYXkoMSwgZC5nZXRVVENEYXkoKSwgdXRjRmlyc3QoeSkpLFxuICBbV0VFSyArIERBWV06IChkLCB5KSA9PiB3ZWVrZGF5KHV0Y1dlZWtOdW0oZCksIGQuZ2V0VVRDRGF5KCksIHV0Y0ZpcnN0KHkpKVxufTtcbmNvbnN0IHV0Y0ludiA9IHtcbiAgW1FVQVJURVJdOiBxID0+IDMgKiBxLFxuICBbV0VFS106ICh3LCB5KSA9PiB3ZWVrZGF5KHcsIDAsIHV0Y0ZpcnN0KHkpKVxufTtcbmZ1bmN0aW9uIHV0Y0Zsb29yKHVuaXRzLCBzdGVwKSB7XG4gIHJldHVybiBmbG9vcih1bml0cywgc3RlcCB8fCAxLCB1dGNHZXQsIHV0Y0ludiwgdXRjRGF0ZSk7XG59XG5cbmNvbnN0IHRpbWVJbnRlcnZhbHMgPSB7XG4gIFtZRUFSXTogdGltZVllYXIsXG4gIFtRVUFSVEVSXTogdGltZU1vbnRoLmV2ZXJ5KDMpLFxuICBbTU9OVEhdOiB0aW1lTW9udGgsXG4gIFtXRUVLXTogdGltZVdlZWssXG4gIFtEQVRFXTogdGltZURheSxcbiAgW0RBWV06IHRpbWVEYXksXG4gIFtEQVlPRllFQVJdOiB0aW1lRGF5LFxuICBbSE9VUlNdOiB0aW1lSG91cixcbiAgW01JTlVURVNdOiB0aW1lTWludXRlLFxuICBbU0VDT05EU106IHRpbWVTZWNvbmQsXG4gIFtNSUxMSVNFQ09ORFNdOiB0aW1lTWlsbGlzZWNvbmRcbn07XG5jb25zdCB1dGNJbnRlcnZhbHMgPSB7XG4gIFtZRUFSXTogdXRjWWVhcixcbiAgW1FVQVJURVJdOiB1dGNNb250aC5ldmVyeSgzKSxcbiAgW01PTlRIXTogdXRjTW9udGgsXG4gIFtXRUVLXTogdXRjV2VlayxcbiAgW0RBVEVdOiB1dGNEYXksXG4gIFtEQVldOiB1dGNEYXksXG4gIFtEQVlPRllFQVJdOiB1dGNEYXksXG4gIFtIT1VSU106IHV0Y0hvdXIsXG4gIFtNSU5VVEVTXTogdXRjTWludXRlLFxuICBbU0VDT05EU106IHV0Y1NlY29uZCxcbiAgW01JTExJU0VDT05EU106IHV0Y01pbGxpc2Vjb25kXG59O1xuZnVuY3Rpb24gdGltZUludGVydmFsKHVuaXQpIHtcbiAgcmV0dXJuIHRpbWVJbnRlcnZhbHNbdW5pdF07XG59XG5mdW5jdGlvbiB1dGNJbnRlcnZhbCh1bml0KSB7XG4gIHJldHVybiB1dGNJbnRlcnZhbHNbdW5pdF07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChpdmFsLCBkYXRlLCBzdGVwKSB7XG4gIHJldHVybiBpdmFsID8gaXZhbC5vZmZzZXQoZGF0ZSwgc3RlcCkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHRpbWVPZmZzZXQodW5pdCwgZGF0ZSwgc3RlcCkge1xuICByZXR1cm4gb2Zmc2V0KHRpbWVJbnRlcnZhbCh1bml0KSwgZGF0ZSwgc3RlcCk7XG59XG5mdW5jdGlvbiB1dGNPZmZzZXQodW5pdCwgZGF0ZSwgc3RlcCkge1xuICByZXR1cm4gb2Zmc2V0KHV0Y0ludGVydmFsKHVuaXQpLCBkYXRlLCBzdGVwKTtcbn1cblxuZnVuY3Rpb24gc2VxdWVuY2UoaXZhbCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgcmV0dXJuIGl2YWwgPyBpdmFsLnJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gdGltZVNlcXVlbmNlKHVuaXQsIHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIHJldHVybiBzZXF1ZW5jZSh0aW1lSW50ZXJ2YWwodW5pdCksIHN0YXJ0LCBzdG9wLCBzdGVwKTtcbn1cbmZ1bmN0aW9uIHV0Y1NlcXVlbmNlKHVuaXQsIHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIHJldHVybiBzZXF1ZW5jZSh1dGNJbnRlcnZhbCh1bml0KSwgc3RhcnQsIHN0b3AsIHN0ZXApO1xufVxuXG5jb25zdCBkdXJhdGlvblNlY29uZCA9IDEwMDAsXG4gICAgICBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjAsXG4gICAgICBkdXJhdGlvbkhvdXIgPSBkdXJhdGlvbk1pbnV0ZSAqIDYwLFxuICAgICAgZHVyYXRpb25EYXkgPSBkdXJhdGlvbkhvdXIgKiAyNCxcbiAgICAgIGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNyxcbiAgICAgIGR1cmF0aW9uTW9udGggPSBkdXJhdGlvbkRheSAqIDMwLFxuICAgICAgZHVyYXRpb25ZZWFyID0gZHVyYXRpb25EYXkgKiAzNjU7XG5jb25zdCBNaWxsaSA9IFtZRUFSLCBNT05USCwgREFURSwgSE9VUlMsIE1JTlVURVMsIFNFQ09ORFMsIE1JTExJU0VDT05EU10sXG4gICAgICBTZWNvbmRzID0gTWlsbGkuc2xpY2UoMCwgLTEpLFxuICAgICAgTWludXRlcyA9IFNlY29uZHMuc2xpY2UoMCwgLTEpLFxuICAgICAgSG91cnMgPSBNaW51dGVzLnNsaWNlKDAsIC0xKSxcbiAgICAgIERheSA9IEhvdXJzLnNsaWNlKDAsIC0xKSxcbiAgICAgIFdlZWsgPSBbWUVBUiwgV0VFS10sXG4gICAgICBNb250aCA9IFtZRUFSLCBNT05USF0sXG4gICAgICBZZWFyID0gW1lFQVJdO1xuY29uc3QgaW50ZXJ2YWxzID0gW1tTZWNvbmRzLCAxLCBkdXJhdGlvblNlY29uZF0sIFtTZWNvbmRzLCA1LCA1ICogZHVyYXRpb25TZWNvbmRdLCBbU2Vjb25kcywgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLCBbU2Vjb25kcywgMzAsIDMwICogZHVyYXRpb25TZWNvbmRdLCBbTWludXRlcywgMSwgZHVyYXRpb25NaW51dGVdLCBbTWludXRlcywgNSwgNSAqIGR1cmF0aW9uTWludXRlXSwgW01pbnV0ZXMsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSwgW01pbnV0ZXMsIDMwLCAzMCAqIGR1cmF0aW9uTWludXRlXSwgW0hvdXJzLCAxLCBkdXJhdGlvbkhvdXJdLCBbSG91cnMsIDMsIDMgKiBkdXJhdGlvbkhvdXJdLCBbSG91cnMsIDYsIDYgKiBkdXJhdGlvbkhvdXJdLCBbSG91cnMsIDEyLCAxMiAqIGR1cmF0aW9uSG91cl0sIFtEYXksIDEsIGR1cmF0aW9uRGF5XSwgW1dlZWssIDEsIGR1cmF0aW9uV2Vla10sIFtNb250aCwgMSwgZHVyYXRpb25Nb250aF0sIFtNb250aCwgMywgMyAqIGR1cmF0aW9uTW9udGhdLCBbWWVhciwgMSwgZHVyYXRpb25ZZWFyXV07XG5mdW5jdGlvbiBiaW4gKG9wdCkge1xuICBjb25zdCBleHQgPSBvcHQuZXh0ZW50LFxuICAgICAgICBtYXggPSBvcHQubWF4YmlucyB8fCA0MCxcbiAgICAgICAgdGFyZ2V0ID0gTWF0aC5hYnMoc3BhbihleHQpKSAvIG1heDtcbiAgbGV0IGkgPSBiaXNlY3RvcihpID0+IGlbMl0pLnJpZ2h0KGludGVydmFscywgdGFyZ2V0KSxcbiAgICAgIHVuaXRzLFxuICAgICAgc3RlcDtcblxuICBpZiAoaSA9PT0gaW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgIHVuaXRzID0gWWVhciwgc3RlcCA9IHRpY2tTdGVwKGV4dFswXSAvIGR1cmF0aW9uWWVhciwgZXh0WzFdIC8gZHVyYXRpb25ZZWFyLCBtYXgpO1xuICB9IGVsc2UgaWYgKGkpIHtcbiAgICBpID0gaW50ZXJ2YWxzW3RhcmdldCAvIGludGVydmFsc1tpIC0gMV1bMl0gPCBpbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgIHVuaXRzID0gaVswXTtcbiAgICBzdGVwID0gaVsxXTtcbiAgfSBlbHNlIHtcbiAgICB1bml0cyA9IE1pbGxpO1xuICAgIHN0ZXAgPSBNYXRoLm1heCh0aWNrU3RlcChleHRbMF0sIGV4dFsxXSwgbWF4KSwgMSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVuaXRzLFxuICAgIHN0ZXBcbiAgfTtcbn1cblxuZXhwb3J0IHsgREFURSwgREFZLCBEQVlPRllFQVIsIEhPVVJTLCBNSUxMSVNFQ09ORFMsIE1JTlVURVMsIE1PTlRILCBRVUFSVEVSLCBTRUNPTkRTLCBUSU1FX1VOSVRTLCBXRUVLLCBZRUFSLCBkYXlvZnllYXIsIGJpbiBhcyB0aW1lQmluLCB0aW1lRmxvb3IsIHRpbWVJbnRlcnZhbCwgdGltZU9mZnNldCwgdGltZVNlcXVlbmNlLCB0aW1lVW5pdFNwZWNpZmllciwgdGltZVVuaXRzLCB1dGNGbG9vciwgdXRjSW50ZXJ2YWwsIHV0Y09mZnNldCwgdXRjU2VxdWVuY2UsIHV0Y2RheW9meWVhciwgdXRjd2Vlaywgd2VlayB9O1xuIiwiaW1wb3J0IHsgZXh0ZW5kLCBpZGVudGl0eSwgZmllbGQsIGhhc093blByb3BlcnR5LCBleHRlbnRJbmRleCwgaW5oZXJpdHMsIGFycmF5LCBhY2Nlc3Nvck5hbWUsIGVycm9yLCBhY2Nlc3NvckZpZWxkcywgYWNjZXNzb3IsIHRvTnVtYmVyLCBtZXJnZSwgY29tcGFyZSwgdHJ1dGh5LCBleHRlbnQsIHNwYW4sIGZhc3RtYXAsIGlzQXJyYXksIGtleSwgYXNjZW5kaW5nLCBwZWVrLCB6ZXJvLCBjb25zdGFudCB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyB0dXBsZWlkLCBUcmFuc2Zvcm0sIHJlcGxhY2UsIGluZ2VzdCwgc3RhYmxlQ29tcGFyZSwgT3BlcmF0b3IsIGRlcml2ZSwgcmVkZXJpdmUgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IHF1YXJ0aWxlcywgYm9vdHN0cmFwQ0ksIGJpbiwgcmFuZG9tS0RFLCByYW5kb21NaXh0dXJlLCByYW5kb21Ob3JtYWwsIHJhbmRvbUxvZ05vcm1hbCwgcmFuZG9tVW5pZm9ybSwgc2FtcGxlQ3VydmUsIGRvdGJpbiwgcXVhbnRpbGVzLCByYW5kb20gfSBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuaW1wb3J0IHsgbWVkaWFuLCBtZWFuLCBtaW4sIG1heCwgcmFuZ2UsIGJpc2VjdG9yIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgVElNRV9VTklUUywgdXRjSW50ZXJ2YWwsIHRpbWVJbnRlcnZhbCwgdGltZUJpbiwgdGltZVVuaXRzLCB1dGNGbG9vciwgdGltZUZsb29yIH0gZnJvbSAndmVnYS10aW1lJztcblxuZnVuY3Rpb24gbXVsdGlrZXkoZikge1xuICByZXR1cm4geCA9PiB7XG4gICAgY29uc3QgbiA9IGYubGVuZ3RoO1xuICAgIGxldCBpID0gMSxcbiAgICAgICAgayA9IFN0cmluZyhmWzBdKHgpKTtcblxuICAgIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgICBrICs9ICd8JyArIGZbaV0oeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGs7XG4gIH07XG59XG5mdW5jdGlvbiBncm91cGtleShmaWVsZHMpIHtcbiAgcmV0dXJuICFmaWVsZHMgfHwgIWZpZWxkcy5sZW5ndGggPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IDogZmllbGRzLmxlbmd0aCA9PT0gMSA/IGZpZWxkc1swXSA6IG11bHRpa2V5KGZpZWxkcyk7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVOYW1lKG9wLCBmaWVsZCwgYXMpIHtcbiAgcmV0dXJuIGFzIHx8IG9wICsgKCFmaWVsZCA/ICcnIDogJ18nICsgZmllbGQpO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbmNvbnN0IGJhc2Vfb3AgPSB7XG4gIGluaXQ6IG5vb3AsXG4gIGFkZDogbm9vcCxcbiAgcmVtOiBub29wLFxuICBpZHg6IDBcbn07XG5jb25zdCBBZ2dyZWdhdGVPcHMgPSB7XG4gIHZhbHVlczoge1xuICAgIGluaXQ6IG0gPT4gbS5jZWxsLnN0b3JlID0gdHJ1ZSxcbiAgICB2YWx1ZTogbSA9PiBtLmNlbGwuZGF0YS52YWx1ZXMoKSxcbiAgICBpZHg6IC0xXG4gIH0sXG4gIGNvdW50OiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLm51bVxuICB9LFxuICBfX2NvdW50X186IHtcbiAgICB2YWx1ZTogbSA9PiBtLm1pc3NpbmcgKyBtLnZhbGlkXG4gIH0sXG4gIG1pc3Npbmc6IHtcbiAgICB2YWx1ZTogbSA9PiBtLm1pc3NpbmdcbiAgfSxcbiAgdmFsaWQ6IHtcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkXG4gIH0sXG4gIHN1bToge1xuICAgIGluaXQ6IG0gPT4gbS5zdW0gPSAwLFxuICAgIHZhbHVlOiBtID0+IG0uc3VtLFxuICAgIGFkZDogKG0sIHYpID0+IG0uc3VtICs9ICt2LFxuICAgIHJlbTogKG0sIHYpID0+IG0uc3VtIC09IHZcbiAgfSxcbiAgcHJvZHVjdDoge1xuICAgIGluaXQ6IG0gPT4gbS5wcm9kdWN0ID0gMSxcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID8gbS5wcm9kdWN0IDogdW5kZWZpbmVkLFxuICAgIGFkZDogKG0sIHYpID0+IG0ucHJvZHVjdCAqPSB2LFxuICAgIHJlbTogKG0sIHYpID0+IG0ucHJvZHVjdCAvPSB2XG4gIH0sXG4gIG1lYW46IHtcbiAgICBpbml0OiBtID0+IG0ubWVhbiA9IDAsXG4gICAgdmFsdWU6IG0gPT4gbS52YWxpZCA/IG0ubWVhbiA6IHVuZGVmaW5lZCxcbiAgICBhZGQ6IChtLCB2KSA9PiAobS5tZWFuX2QgPSB2IC0gbS5tZWFuLCBtLm1lYW4gKz0gbS5tZWFuX2QgLyBtLnZhbGlkKSxcbiAgICByZW06IChtLCB2KSA9PiAobS5tZWFuX2QgPSB2IC0gbS5tZWFuLCBtLm1lYW4gLT0gbS52YWxpZCA/IG0ubWVhbl9kIC8gbS52YWxpZCA6IG0ubWVhbilcbiAgfSxcbiAgYXZlcmFnZToge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPyBtLm1lYW4gOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ21lYW4nXSxcbiAgICBpZHg6IDFcbiAgfSxcbiAgdmFyaWFuY2U6IHtcbiAgICBpbml0OiBtID0+IG0uZGV2ID0gMCxcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID4gMSA/IG0uZGV2IC8gKG0udmFsaWQgLSAxKSA6IHVuZGVmaW5lZCxcbiAgICBhZGQ6IChtLCB2KSA9PiBtLmRldiArPSBtLm1lYW5fZCAqICh2IC0gbS5tZWFuKSxcbiAgICByZW06IChtLCB2KSA9PiBtLmRldiAtPSBtLm1lYW5fZCAqICh2IC0gbS5tZWFuKSxcbiAgICByZXE6IFsnbWVhbiddLFxuICAgIGlkeDogMVxuICB9LFxuICB2YXJpYW5jZXA6IHtcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID4gMSA/IG0uZGV2IC8gbS52YWxpZCA6IHVuZGVmaW5lZCxcbiAgICByZXE6IFsndmFyaWFuY2UnXSxcbiAgICBpZHg6IDJcbiAgfSxcbiAgc3RkZXY6IHtcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID4gMSA/IE1hdGguc3FydChtLmRldiAvIChtLnZhbGlkIC0gMSkpIDogdW5kZWZpbmVkLFxuICAgIHJlcTogWyd2YXJpYW5jZSddLFxuICAgIGlkeDogMlxuICB9LFxuICBzdGRldnA6IHtcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID4gMSA/IE1hdGguc3FydChtLmRldiAvIG0udmFsaWQpIDogdW5kZWZpbmVkLFxuICAgIHJlcTogWyd2YXJpYW5jZSddLFxuICAgIGlkeDogMlxuICB9LFxuICBzdGRlcnI6IHtcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID4gMSA/IE1hdGguc3FydChtLmRldiAvIChtLnZhbGlkICogKG0udmFsaWQgLSAxKSkpIDogdW5kZWZpbmVkLFxuICAgIHJlcTogWyd2YXJpYW5jZSddLFxuICAgIGlkeDogMlxuICB9LFxuICBkaXN0aW5jdDoge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLmRpc3RpbmN0KG0uZ2V0KSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIGNpMDoge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLmNpMChtLmdldCksXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogM1xuICB9LFxuICBjaTE6IHtcbiAgICB2YWx1ZTogbSA9PiBtLmNlbGwuZGF0YS5jaTEobS5nZXQpLFxuICAgIHJlcTogWyd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgbWVkaWFuOiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEucTIobS5nZXQpLFxuICAgIHJlcTogWyd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgcTE6IHtcbiAgICB2YWx1ZTogbSA9PiBtLmNlbGwuZGF0YS5xMShtLmdldCksXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogM1xuICB9LFxuICBxMzoge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLnEzKG0uZ2V0KSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIG1pbjoge1xuICAgIGluaXQ6IG0gPT4gbS5taW4gPSB1bmRlZmluZWQsXG4gICAgdmFsdWU6IG0gPT4gbS5taW4gPSBOdW1iZXIuaXNOYU4obS5taW4pID8gbS5jZWxsLmRhdGEubWluKG0uZ2V0KSA6IG0ubWluLFxuICAgIGFkZDogKG0sIHYpID0+IHtcbiAgICAgIGlmICh2IDwgbS5taW4gfHwgbS5taW4gPT09IHVuZGVmaW5lZCkgbS5taW4gPSB2O1xuICAgIH0sXG4gICAgcmVtOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPD0gbS5taW4pIG0ubWluID0gTmFOO1xuICAgIH0sXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogNFxuICB9LFxuICBtYXg6IHtcbiAgICBpbml0OiBtID0+IG0ubWF4ID0gdW5kZWZpbmVkLFxuICAgIHZhbHVlOiBtID0+IG0ubWF4ID0gTnVtYmVyLmlzTmFOKG0ubWF4KSA/IG0uY2VsbC5kYXRhLm1heChtLmdldCkgOiBtLm1heCxcbiAgICBhZGQ6IChtLCB2KSA9PiB7XG4gICAgICBpZiAodiA+IG0ubWF4IHx8IG0ubWF4ID09PSB1bmRlZmluZWQpIG0ubWF4ID0gdjtcbiAgICB9LFxuICAgIHJlbTogKG0sIHYpID0+IHtcbiAgICAgIGlmICh2ID49IG0ubWF4KSBtLm1heCA9IE5hTjtcbiAgICB9LFxuICAgIHJlcTogWyd2YWx1ZXMnXSxcbiAgICBpZHg6IDRcbiAgfSxcbiAgYXJnbWluOiB7XG4gICAgaW5pdDogbSA9PiBtLmFyZ21pbiA9IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbSA9PiBtLmFyZ21pbiB8fCBtLmNlbGwuZGF0YS5hcmdtaW4obS5nZXQpLFxuICAgIGFkZDogKG0sIHYsIHQpID0+IHtcbiAgICAgIGlmICh2IDwgbS5taW4pIG0uYXJnbWluID0gdDtcbiAgICB9LFxuICAgIHJlbTogKG0sIHYpID0+IHtcbiAgICAgIGlmICh2IDw9IG0ubWluKSBtLmFyZ21pbiA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHJlcTogWydtaW4nLCAndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIGFyZ21heDoge1xuICAgIGluaXQ6IG0gPT4gbS5hcmdtYXggPSB1bmRlZmluZWQsXG4gICAgdmFsdWU6IG0gPT4gbS5hcmdtYXggfHwgbS5jZWxsLmRhdGEuYXJnbWF4KG0uZ2V0KSxcbiAgICBhZGQ6IChtLCB2LCB0KSA9PiB7XG4gICAgICBpZiAodiA+IG0ubWF4KSBtLmFyZ21heCA9IHQ7XG4gICAgfSxcbiAgICByZW06IChtLCB2KSA9PiB7XG4gICAgICBpZiAodiA+PSBtLm1heCkgbS5hcmdtYXggPSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICByZXE6IFsnbWF4JywgJ3ZhbHVlcyddLFxuICAgIGlkeDogM1xuICB9XG59O1xuY29uc3QgVmFsaWRBZ2dyZWdhdGVPcHMgPSBPYmplY3Qua2V5cyhBZ2dyZWdhdGVPcHMpO1xuXG5mdW5jdGlvbiBtZWFzdXJlKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIG91dCA9PiBleHRlbmQoe1xuICAgIG5hbWU6IGtleSxcbiAgICBvdXQ6IG91dCB8fCBrZXlcbiAgfSwgYmFzZV9vcCwgdmFsdWUpO1xufVxuXG5WYWxpZEFnZ3JlZ2F0ZU9wcy5mb3JFYWNoKGtleSA9PiB7XG4gIEFnZ3JlZ2F0ZU9wc1trZXldID0gbWVhc3VyZShrZXksIEFnZ3JlZ2F0ZU9wc1trZXldKTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlTWVhc3VyZShvcCwgbmFtZSkge1xuICByZXR1cm4gQWdncmVnYXRlT3BzW29wXShuYW1lKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUluZGV4KGEsIGIpIHtcbiAgcmV0dXJuIGEuaWR4IC0gYi5pZHg7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYWdnKSB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBhZ2cuZm9yRWFjaChhID0+IG1hcFthLm5hbWVdID0gYSk7XG5cbiAgY29uc3QgZ2V0cmVxcyA9IGEgPT4ge1xuICAgIGlmICghYS5yZXEpIHJldHVybjtcbiAgICBhLnJlcS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIW1hcFtrZXldKSBnZXRyZXFzKG1hcFtrZXldID0gQWdncmVnYXRlT3BzW2tleV0oKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgYWdnLmZvckVhY2goZ2V0cmVxcyk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKG1hcCkuc29ydChjb21wYXJlSW5kZXgpO1xufVxuXG5mdW5jdGlvbiBpbml0KCkge1xuICB0aGlzLnZhbGlkID0gMDtcbiAgdGhpcy5taXNzaW5nID0gMDtcblxuICB0aGlzLl9vcHMuZm9yRWFjaChvcCA9PiBvcC5pbml0KHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gYWRkKHYsIHQpIHtcbiAgaWYgKHYgPT0gbnVsbCB8fCB2ID09PSAnJykge1xuICAgICsrdGhpcy5taXNzaW5nO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh2ICE9PSB2KSByZXR1cm47XG4gICsrdGhpcy52YWxpZDtcblxuICB0aGlzLl9vcHMuZm9yRWFjaChvcCA9PiBvcC5hZGQodGhpcywgdiwgdCkpO1xufVxuXG5mdW5jdGlvbiByZW0odiwgdCkge1xuICBpZiAodiA9PSBudWxsIHx8IHYgPT09ICcnKSB7XG4gICAgLS10aGlzLm1pc3Npbmc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHYgIT09IHYpIHJldHVybjtcbiAgLS10aGlzLnZhbGlkO1xuXG4gIHRoaXMuX29wcy5mb3JFYWNoKG9wID0+IG9wLnJlbSh0aGlzLCB2LCB0KSk7XG59XG5cbmZ1bmN0aW9uIHNldCh0KSB7XG4gIHRoaXMuX291dC5mb3JFYWNoKG9wID0+IHRbb3Aub3V0XSA9IG9wLnZhbHVlKHRoaXMpKTtcblxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gY29tcGlsZU1lYXN1cmVzKGFnZywgZmllbGQpIHtcbiAgY29uc3QgZ2V0ID0gZmllbGQgfHwgaWRlbnRpdHksXG4gICAgICAgIG9wcyA9IHJlc29sdmUoYWdnKSxcbiAgICAgICAgb3V0ID0gYWdnLnNsaWNlKCkuc29ydChjb21wYXJlSW5kZXgpO1xuXG4gIGZ1bmN0aW9uIGN0cihjZWxsKSB7XG4gICAgdGhpcy5fb3BzID0gb3BzO1xuICAgIHRoaXMuX291dCA9IG91dDtcbiAgICB0aGlzLmNlbGwgPSBjZWxsO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgY3RyLnByb3RvdHlwZS5pbml0ID0gaW5pdDtcbiAgY3RyLnByb3RvdHlwZS5hZGQgPSBhZGQ7XG4gIGN0ci5wcm90b3R5cGUucmVtID0gcmVtO1xuICBjdHIucHJvdG90eXBlLnNldCA9IHNldDtcbiAgY3RyLnByb3RvdHlwZS5nZXQgPSBnZXQ7XG4gIGN0ci5maWVsZHMgPSBhZ2cubWFwKG9wID0+IG9wLm91dCk7XG4gIHJldHVybiBjdHI7XG59XG5cbmZ1bmN0aW9uIFR1cGxlU3RvcmUoa2V5KSB7XG4gIHRoaXMuX2tleSA9IGtleSA/IGZpZWxkKGtleSkgOiB0dXBsZWlkO1xuICB0aGlzLnJlc2V0KCk7XG59XG5jb25zdCBwcm90b3R5cGUkMSA9IFR1cGxlU3RvcmUucHJvdG90eXBlO1xuXG5wcm90b3R5cGUkMS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWRkID0gW107XG4gIHRoaXMuX3JlbSA9IFtdO1xuICB0aGlzLl9leHQgPSBudWxsO1xuICB0aGlzLl9nZXQgPSBudWxsO1xuICB0aGlzLl9xID0gbnVsbDtcbn07XG5cbnByb3RvdHlwZSQxLmFkZCA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuX2FkZC5wdXNoKHYpO1xufTtcblxucHJvdG90eXBlJDEucmVtID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5fcmVtLnB1c2godik7XG59O1xuXG5wcm90b3R5cGUkMS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2dldCA9IG51bGw7XG4gIGlmICh0aGlzLl9yZW0ubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fYWRkO1xuICBjb25zdCBhID0gdGhpcy5fYWRkLFxuICAgICAgICByID0gdGhpcy5fcmVtLFxuICAgICAgICBrID0gdGhpcy5fa2V5LFxuICAgICAgICBuID0gYS5sZW5ndGgsXG4gICAgICAgIG0gPSByLmxlbmd0aCxcbiAgICAgICAgeCA9IEFycmF5KG4gLSBtKSxcbiAgICAgICAgbWFwID0ge307XG4gIGxldCBpLCBqLCB2OyAvLyB1c2UgdW5pcXVlIGtleSBmaWVsZCB0byBjbGVhciByZW1vdmVkIHZhbHVlc1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICBtYXBbayhyW2ldKV0gPSAxO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAobWFwW2sodiA9IGFbaV0pXSkge1xuICAgICAgbWFwW2sodildID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeFtqKytdID0gdjtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9yZW0gPSBbXTtcbiAgcmV0dXJuIHRoaXMuX2FkZCA9IHg7XG59OyAvLyBtZW1vaXppbmcgc3RhdGlzdGljcyBtZXRob2RzXG5cblxucHJvdG90eXBlJDEuZGlzdGluY3QgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIGNvbnN0IHYgPSB0aGlzLnZhbHVlcygpLFxuICAgICAgICBtYXAgPSB7fTtcbiAgbGV0IG4gPSB2Lmxlbmd0aCxcbiAgICAgIGNvdW50ID0gMCxcbiAgICAgIHM7XG5cbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgcyA9IGdldCh2W25dKSArICcnO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShtYXAsIHMpKSB7XG4gICAgICBtYXBbc10gPSAxO1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG59O1xuXG5wcm90b3R5cGUkMS5leHRlbnQgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIGlmICh0aGlzLl9nZXQgIT09IGdldCB8fCAhdGhpcy5fZXh0KSB7XG4gICAgY29uc3QgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICAgICAgaSA9IGV4dGVudEluZGV4KHYsIGdldCk7XG4gICAgdGhpcy5fZXh0ID0gW3ZbaVswXV0sIHZbaVsxXV1dO1xuICAgIHRoaXMuX2dldCA9IGdldDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9leHQ7XG59O1xuXG5wcm90b3R5cGUkMS5hcmdtaW4gPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzBdIHx8IHt9O1xufTtcblxucHJvdG90eXBlJDEuYXJnbWF4ID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gdGhpcy5leHRlbnQoZ2V0KVsxXSB8fCB7fTtcbn07XG5cbnByb3RvdHlwZSQxLm1pbiA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgY29uc3QgbSA9IHRoaXMuZXh0ZW50KGdldClbMF07XG4gIHJldHVybiBtICE9IG51bGwgPyBnZXQobSkgOiB1bmRlZmluZWQ7XG59O1xuXG5wcm90b3R5cGUkMS5tYXggPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIGNvbnN0IG0gPSB0aGlzLmV4dGVudChnZXQpWzFdO1xuICByZXR1cm4gbSAhPSBudWxsID8gZ2V0KG0pIDogdW5kZWZpbmVkO1xufTtcblxucHJvdG90eXBlJDEucXVhcnRpbGUgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIGlmICh0aGlzLl9nZXQgIT09IGdldCB8fCAhdGhpcy5fcSkge1xuICAgIHRoaXMuX3EgPSBxdWFydGlsZXModGhpcy52YWx1ZXMoKSwgZ2V0KTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fcTtcbn07XG5cbnByb3RvdHlwZSQxLnExID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShnZXQpWzBdO1xufTtcblxucHJvdG90eXBlJDEucTIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiB0aGlzLnF1YXJ0aWxlKGdldClbMV07XG59O1xuXG5wcm90b3R5cGUkMS5xMyA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVsyXTtcbn07XG5cbnByb3RvdHlwZSQxLmNpID0gZnVuY3Rpb24gKGdldCkge1xuICBpZiAodGhpcy5fZ2V0ICE9PSBnZXQgfHwgIXRoaXMuX2NpKSB7XG4gICAgdGhpcy5fY2kgPSBib290c3RyYXBDSSh0aGlzLnZhbHVlcygpLCAxMDAwLCAwLjA1LCBnZXQpO1xuICAgIHRoaXMuX2dldCA9IGdldDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jaTtcbn07XG5cbnByb3RvdHlwZSQxLmNpMCA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMuY2koZ2V0KVswXTtcbn07XG5cbnByb3RvdHlwZSQxLmNpMSA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMuY2koZ2V0KVsxXTtcbn07XG5cbi8qKlxuICogR3JvdXAtYnkgYWdncmVnYXRpb24gb3BlcmF0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnMgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZmllbGRzXSAtIEFuIGFycmF5IG9mIGFjY2Vzc29ycyB0byBhZ2dyZWdhdGUuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMub3BzXSAtIEFuIGFycmF5IG9mIHN0cmluZ3MgaW5kaWNhdGluZyBhZ2dyZWdhdGlvbiBvcGVyYXRpb25zLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbcGFyYW1zLmFzXSAtIEFuIGFycmF5IG9mIG91dHB1dCBmaWVsZCBuYW1lcyBmb3IgYWdncmVnYXRlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuY3Jvc3M9ZmFsc2VdIC0gQSBmbGFnIGluZGljYXRpbmcgdGhhdCB0aGUgZnVsbFxuICogICBjcm9zcy1wcm9kdWN0IG9mIGdyb3VwYnkgdmFsdWVzIHNob3VsZCBiZSBnZW5lcmF0ZWQsIGluY2x1ZGluZyBlbXB0eSBjZWxscy5cbiAqICAgSWYgdHJ1ZSwgdGhlIGRyb3AgcGFyYW1ldGVyIGlzIGlnbm9yZWQgYW5kIGVtcHR5IGNlbGxzIGFyZSByZXRhaW5lZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5kcm9wPXRydWVdIC0gQSBmbGFnIGluZGljYXRpbmcgaWYgZW1wdHkgY2VsbHMgc2hvdWxkIGJlIHJlbW92ZWQuXG4gKi9cblxuZnVuY3Rpb24gQWdncmVnYXRlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xuICB0aGlzLl9hZGRzID0gW107IC8vIGFycmF5IG9mIGFkZGVkIG91dHB1dCB0dXBsZXNcblxuICB0aGlzLl9tb2RzID0gW107IC8vIGFycmF5IG9mIG1vZGlmaWVkIG91dHB1dCB0dXBsZXNcblxuICB0aGlzLl9hbGVuID0gMDsgLy8gbnVtYmVyIG9mIGFjdGl2ZSBhZGRlZCB0dXBsZXNcblxuICB0aGlzLl9tbGVuID0gMDsgLy8gbnVtYmVyIG9mIGFjdGl2ZSBtb2RpZmllZCB0dXBsZXNcblxuICB0aGlzLl9kcm9wID0gdHJ1ZTsgLy8gc2hvdWxkIGVtcHR5IGFnZ3JlZ2F0aW9uIGNlbGxzIGJlIHJlbW92ZWRcblxuICB0aGlzLl9jcm9zcyA9IGZhbHNlOyAvLyBwcm9kdWNlIGZ1bGwgY3Jvc3MtcHJvZHVjdCBvZiBncm91cC1ieSB2YWx1ZXNcblxuICB0aGlzLl9kaW1zID0gW107IC8vIGdyb3VwLWJ5IGRpbWVuc2lvbiBhY2Nlc3NvcnNcblxuICB0aGlzLl9kbmFtZXMgPSBbXTsgLy8gZ3JvdXAtYnkgZGltZW5zaW9uIG5hbWVzXG5cbiAgdGhpcy5fbWVhc3VyZXMgPSBbXTsgLy8gY29sbGVjdGlvbiBvZiBhZ2dyZWdhdGlvbiBtb25vaWRzXG5cbiAgdGhpcy5fY291bnRPbmx5ID0gZmFsc2U7IC8vIGZsYWcgaW5kaWNhdGluZyBvbmx5IGNvdW50IGFnZ3JlZ2F0aW9uXG5cbiAgdGhpcy5fY291bnRzID0gbnVsbDsgLy8gY29sbGVjdGlvbiBvZiBjb3VudCBmaWVsZHNcblxuICB0aGlzLl9wcmV2ID0gbnVsbDsgLy8gcHJldmlvdXMgYWdncmVnYXRpb24gY2VsbHNcblxuICB0aGlzLl9pbnB1dHMgPSBudWxsOyAvLyBhcnJheSBvZiBkZXBlbmRlbnQgaW5wdXQgdHVwbGUgZmllbGQgbmFtZXNcblxuICB0aGlzLl9vdXRwdXRzID0gbnVsbDsgLy8gYXJyYXkgb2Ygb3V0cHV0IHR1cGxlIGZpZWxkIG5hbWVzXG59XG5BZ2dyZWdhdGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnQWdncmVnYXRlJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlLFxuICAgICdjaGFuZ2VzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3BzJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICd2YWx1ZXMnOiBWYWxpZEFnZ3JlZ2F0ZU9wc1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdkcm9wJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2Nyb3NzJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IGZhbHNlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdrZXknLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9XVxufTtcbmluaGVyaXRzKEFnZ3JlZ2F0ZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGFnZ3IgPSB0aGlzLFxuICAgICAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSxcbiAgICAgICAgICBtb2QgPSBfLm1vZGlmaWVkKCk7XG5cbiAgICBhZ2dyLnN0YW1wID0gb3V0LnN0YW1wO1xuXG4gICAgaWYgKGFnZ3IudmFsdWUgJiYgKG1vZCB8fCBwdWxzZS5tb2RpZmllZChhZ2dyLl9pbnB1dHMsIHRydWUpKSkge1xuICAgICAgYWdnci5fcHJldiA9IGFnZ3IudmFsdWU7XG4gICAgICBhZ2dyLnZhbHVlID0gbW9kID8gYWdnci5pbml0KF8pIDoge307XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4gYWdnci5hZGQodCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZ2dyLnZhbHVlID0gYWdnci52YWx1ZSB8fCBhZ2dyLmluaXQoXyk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4gYWdnci5yZW0odCkpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IGFnZ3IuYWRkKHQpKTtcbiAgICB9IC8vIEluZGljYXRlIG91dHB1dCBmaWVsZHMgYW5kIHJldHVybiBhZ2dyZWdhdGUgdHVwbGVzLlxuXG5cbiAgICBvdXQubW9kaWZpZXMoYWdnci5fb3V0cHV0cyk7IC8vIFNob3VsZCBlbXB0eSBjZWxscyBiZSBkcm9wcGVkP1xuXG4gICAgYWdnci5fZHJvcCA9IF8uZHJvcCAhPT0gZmFsc2U7IC8vIElmIGRvbWFpbiBjcm9zcy1wcm9kdWN0IHJlcXVlc3RlZCwgZ2VuZXJhdGUgZW1wdHkgY2VsbHMgYXMgbmVlZGVkXG4gICAgLy8gYW5kIGVuc3VyZSB0aGF0IGVtcHR5IGNlbGxzIGFyZSBub3QgZHJvcHBlZFxuXG4gICAgaWYgKF8uY3Jvc3MgJiYgYWdnci5fZGltcy5sZW5ndGggPiAxKSB7XG4gICAgICBhZ2dyLl9kcm9wID0gZmFsc2U7XG4gICAgICBhZ2dyLmNyb3NzKCk7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLmNsZWFuKCkgJiYgYWdnci5fZHJvcCkge1xuICAgICAgb3V0LmNsZWFuKHRydWUpLnJ1bkFmdGVyKCgpID0+IHRoaXMuY2xlYW4oKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFnZ3IuY2hhbmdlcyhvdXQpO1xuICB9LFxuXG4gIGNyb3NzKCkge1xuICAgIGNvbnN0IGFnZ3IgPSB0aGlzLFxuICAgICAgICAgIGN1cnIgPSBhZ2dyLnZhbHVlLFxuICAgICAgICAgIGRpbXMgPSBhZ2dyLl9kbmFtZXMsXG4gICAgICAgICAgdmFscyA9IGRpbXMubWFwKCgpID0+ICh7fSkpLFxuICAgICAgICAgIG4gPSBkaW1zLmxlbmd0aDsgLy8gY29sbGVjdCBhbGwgZ3JvdXAtYnkgZG9tYWluIHZhbHVlc1xuXG4gICAgZnVuY3Rpb24gY29sbGVjdChjZWxscykge1xuICAgICAgbGV0IGtleSwgaSwgdCwgdjtcblxuICAgICAgZm9yIChrZXkgaW4gY2VsbHMpIHtcbiAgICAgICAgdCA9IGNlbGxzW2tleV0udHVwbGU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHZhbHNbaV1bdiA9IHRbZGltc1tpXV1dID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbGxlY3QoYWdnci5fcHJldik7XG4gICAgY29sbGVjdChjdXJyKTsgLy8gaXRlcmF0ZSBvdmVyIGtleSBjcm9zcy1wcm9kdWN0LCBjcmVhdGUgY2VsbHMgYXMgbmVlZGVkXG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZShiYXNlLCB0dXBsZSwgaW5kZXgpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBkaW1zW2luZGV4XSxcbiAgICAgICAgICAgIHYgPSB2YWxzW2luZGV4KytdO1xuXG4gICAgICBmb3IgKGNvbnN0IGsgaW4gdikge1xuICAgICAgICBjb25zdCBrZXkgPSBiYXNlID8gYmFzZSArICd8JyArIGsgOiBrO1xuICAgICAgICB0dXBsZVtuYW1lXSA9IHZba107XG4gICAgICAgIGlmIChpbmRleCA8IG4pIGdlbmVyYXRlKGtleSwgdHVwbGUsIGluZGV4KTtlbHNlIGlmICghY3VycltrZXldKSBhZ2dyLmNlbGwoa2V5LCB0dXBsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2VuZXJhdGUoJycsIHt9LCAwKTtcbiAgfSxcblxuICBpbml0KF8pIHtcbiAgICAvLyBpbml0aWFsaXplIGlucHV0IGFuZCBvdXRwdXQgZmllbGRzXG4gICAgY29uc3QgaW5wdXRzID0gdGhpcy5faW5wdXRzID0gW10sXG4gICAgICAgICAgb3V0cHV0cyA9IHRoaXMuX291dHB1dHMgPSBbXSxcbiAgICAgICAgICBpbnB1dE1hcCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaW5wdXRWaXNpdChnZXQpIHtcbiAgICAgIGNvbnN0IGZpZWxkcyA9IGFycmF5KGFjY2Vzc29yRmllbGRzKGdldCkpLFxuICAgICAgICAgICAgbiA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgZjtcblxuICAgICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCFpbnB1dE1hcFtmID0gZmllbGRzW2ldXSkge1xuICAgICAgICAgIGlucHV0TWFwW2ZdID0gMTtcbiAgICAgICAgICBpbnB1dHMucHVzaChmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gaW5pdGlhbGl6ZSBncm91cC1ieSBkaW1lbnNpb25zXG5cblxuICAgIHRoaXMuX2RpbXMgPSBhcnJheShfLmdyb3VwYnkpO1xuICAgIHRoaXMuX2RuYW1lcyA9IHRoaXMuX2RpbXMubWFwKGQgPT4ge1xuICAgICAgY29uc3QgZG5hbWUgPSBhY2Nlc3Nvck5hbWUoZCk7XG4gICAgICBpbnB1dFZpc2l0KGQpO1xuICAgICAgb3V0cHV0cy5wdXNoKGRuYW1lKTtcbiAgICAgIHJldHVybiBkbmFtZTtcbiAgICB9KTtcbiAgICB0aGlzLmNlbGxrZXkgPSBfLmtleSA/IF8ua2V5IDogZ3JvdXBrZXkodGhpcy5fZGltcyk7IC8vIGluaXRpYWxpemUgYWdncmVnYXRlIG1lYXN1cmVzXG5cbiAgICB0aGlzLl9jb3VudE9ubHkgPSB0cnVlO1xuICAgIHRoaXMuX2NvdW50cyA9IFtdO1xuICAgIHRoaXMuX21lYXN1cmVzID0gW107XG4gICAgY29uc3QgZmllbGRzID0gXy5maWVsZHMgfHwgW251bGxdLFxuICAgICAgICAgIG9wcyA9IF8ub3BzIHx8IFsnY291bnQnXSxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgW10sXG4gICAgICAgICAgbiA9IGZpZWxkcy5sZW5ndGgsXG4gICAgICAgICAgbWFwID0ge307XG4gICAgbGV0IGZpZWxkLCBvcCwgbSwgbW5hbWUsIG91dG5hbWUsIGk7XG5cbiAgICBpZiAobiAhPT0gb3BzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1VubWF0Y2hlZCBudW1iZXIgb2YgZmllbGRzIGFuZCBhZ2dyZWdhdGUgb3BzLicpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgb3AgPSBvcHNbaV07XG5cbiAgICAgIGlmIChmaWVsZCA9PSBudWxsICYmIG9wICE9PSAnY291bnQnKSB7XG4gICAgICAgIGVycm9yKCdOdWxsIGFnZ3JlZ2F0ZSBmaWVsZCBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIG1uYW1lID0gYWNjZXNzb3JOYW1lKGZpZWxkKTtcbiAgICAgIG91dG5hbWUgPSBtZWFzdXJlTmFtZShvcCwgbW5hbWUsIGFzW2ldKTtcbiAgICAgIG91dHB1dHMucHVzaChvdXRuYW1lKTtcblxuICAgICAgaWYgKG9wID09PSAnY291bnQnKSB7XG4gICAgICAgIHRoaXMuX2NvdW50cy5wdXNoKG91dG5hbWUpO1xuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBtID0gbWFwW21uYW1lXTtcblxuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIGlucHV0VmlzaXQoZmllbGQpO1xuICAgICAgICBtID0gbWFwW21uYW1lXSA9IFtdO1xuICAgICAgICBtLmZpZWxkID0gZmllbGQ7XG5cbiAgICAgICAgdGhpcy5fbWVhc3VyZXMucHVzaChtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wICE9PSAnY291bnQnKSB0aGlzLl9jb3VudE9ubHkgPSBmYWxzZTtcbiAgICAgIG0ucHVzaChjcmVhdGVNZWFzdXJlKG9wLCBvdXRuYW1lKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWVhc3VyZXMgPSB0aGlzLl9tZWFzdXJlcy5tYXAobSA9PiBjb21waWxlTWVhc3VyZXMobSwgbS5maWVsZCkpO1xuICAgIHJldHVybiB7fTsgLy8gYWdncmVnYXRpb24gY2VsbHMgKHRoaXMudmFsdWUpXG4gIH0sXG5cbiAgLy8gLS0gQ2VsbCBNYW5hZ2VtZW50IC0tLS0tXG4gIGNlbGxrZXk6IGdyb3Vwa2V5KCksXG5cbiAgY2VsbChrZXksIHQpIHtcbiAgICBsZXQgY2VsbCA9IHRoaXMudmFsdWVba2V5XTtcblxuICAgIGlmICghY2VsbCkge1xuICAgICAgY2VsbCA9IHRoaXMudmFsdWVba2V5XSA9IHRoaXMubmV3Y2VsbChrZXksIHQpO1xuICAgICAgdGhpcy5fYWRkc1t0aGlzLl9hbGVuKytdID0gY2VsbDtcbiAgICB9IGVsc2UgaWYgKGNlbGwubnVtID09PSAwICYmIHRoaXMuX2Ryb3AgJiYgY2VsbC5zdGFtcCA8IHRoaXMuc3RhbXApIHtcbiAgICAgIGNlbGwuc3RhbXAgPSB0aGlzLnN0YW1wO1xuICAgICAgdGhpcy5fYWRkc1t0aGlzLl9hbGVuKytdID0gY2VsbDtcbiAgICB9IGVsc2UgaWYgKGNlbGwuc3RhbXAgPCB0aGlzLnN0YW1wKSB7XG4gICAgICBjZWxsLnN0YW1wID0gdGhpcy5zdGFtcDtcbiAgICAgIHRoaXMuX21vZHNbdGhpcy5fbWxlbisrXSA9IGNlbGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGw7XG4gIH0sXG5cbiAgbmV3Y2VsbChrZXksIHQpIHtcbiAgICBjb25zdCBjZWxsID0ge1xuICAgICAga2V5OiBrZXksXG4gICAgICBudW06IDAsXG4gICAgICBhZ2c6IG51bGwsXG4gICAgICB0dXBsZTogdGhpcy5uZXd0dXBsZSh0LCB0aGlzLl9wcmV2ICYmIHRoaXMuX3ByZXZba2V5XSksXG4gICAgICBzdGFtcDogdGhpcy5zdGFtcCxcbiAgICAgIHN0b3JlOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuX2NvdW50T25seSkge1xuICAgICAgY29uc3QgbWVhc3VyZXMgPSB0aGlzLl9tZWFzdXJlcyxcbiAgICAgICAgICAgIG4gPSBtZWFzdXJlcy5sZW5ndGg7XG4gICAgICBjZWxsLmFnZyA9IEFycmF5KG4pO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjZWxsLmFnZ1tpXSA9IG5ldyBtZWFzdXJlc1tpXShjZWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2VsbC5zdG9yZSkge1xuICAgICAgY2VsbC5kYXRhID0gbmV3IFR1cGxlU3RvcmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VsbDtcbiAgfSxcblxuICBuZXd0dXBsZSh0LCBwKSB7XG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLl9kbmFtZXMsXG4gICAgICAgICAgZGltcyA9IHRoaXMuX2RpbXMsXG4gICAgICAgICAgbiA9IGRpbXMubGVuZ3RoLFxuICAgICAgICAgIHggPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB4W25hbWVzW2ldXSA9IGRpbXNbaV0odCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAgPyByZXBsYWNlKHAudHVwbGUsIHgpIDogaW5nZXN0KHgpO1xuICB9LFxuXG4gIGNsZWFuKCkge1xuICAgIGNvbnN0IGNlbGxzID0gdGhpcy52YWx1ZTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGNlbGxzKSB7XG4gICAgICBpZiAoY2VsbHNba2V5XS5udW0gPT09IDApIHtcbiAgICAgICAgZGVsZXRlIGNlbGxzW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIC0tIFByb2Nlc3MgVHVwbGVzIC0tLS0tXG4gIGFkZCh0KSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5jZWxsa2V5KHQpLFxuICAgICAgICAgIGNlbGwgPSB0aGlzLmNlbGwoa2V5LCB0KTtcbiAgICBjZWxsLm51bSArPSAxO1xuICAgIGlmICh0aGlzLl9jb3VudE9ubHkpIHJldHVybjtcbiAgICBpZiAoY2VsbC5zdG9yZSkgY2VsbC5kYXRhLmFkZCh0KTtcbiAgICBjb25zdCBhZ2cgPSBjZWxsLmFnZztcblxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gYWdnLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgYWdnW2ldLmFkZChhZ2dbaV0uZ2V0KHQpLCB0KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtKHQpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmNlbGxrZXkodCksXG4gICAgICAgICAgY2VsbCA9IHRoaXMuY2VsbChrZXksIHQpO1xuICAgIGNlbGwubnVtIC09IDE7XG4gICAgaWYgKHRoaXMuX2NvdW50T25seSkgcmV0dXJuO1xuICAgIGlmIChjZWxsLnN0b3JlKSBjZWxsLmRhdGEucmVtKHQpO1xuICAgIGNvbnN0IGFnZyA9IGNlbGwuYWdnO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhZ2cubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBhZ2dbaV0ucmVtKGFnZ1tpXS5nZXQodCksIHQpO1xuICAgIH1cbiAgfSxcblxuICBjZWxsdHVwbGUoY2VsbCkge1xuICAgIGNvbnN0IHR1cGxlID0gY2VsbC50dXBsZSxcbiAgICAgICAgICBjb3VudHMgPSB0aGlzLl9jb3VudHM7IC8vIGNvbnNvbGlkYXRlIHN0b3JlZCB2YWx1ZXNcblxuICAgIGlmIChjZWxsLnN0b3JlKSB7XG4gICAgICBjZWxsLmRhdGEudmFsdWVzKCk7XG4gICAgfSAvLyB1cGRhdGUgdHVwbGUgcHJvcGVydGllc1xuXG5cbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNvdW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHR1cGxlW2NvdW50c1tpXV0gPSBjZWxsLm51bTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2NvdW50T25seSkge1xuICAgICAgY29uc3QgYWdnID0gY2VsbC5hZ2c7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gYWdnLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBhZ2dbaV0uc2V0KHR1cGxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHVwbGU7XG4gIH0sXG5cbiAgY2hhbmdlcyhvdXQpIHtcbiAgICBjb25zdCBhZGRzID0gdGhpcy5fYWRkcyxcbiAgICAgICAgICBtb2RzID0gdGhpcy5fbW9kcyxcbiAgICAgICAgICBwcmV2ID0gdGhpcy5fcHJldixcbiAgICAgICAgICBkcm9wID0gdGhpcy5fZHJvcCxcbiAgICAgICAgICBhZGQgPSBvdXQuYWRkLFxuICAgICAgICAgIHJlbSA9IG91dC5yZW0sXG4gICAgICAgICAgbW9kID0gb3V0Lm1vZDtcbiAgICBsZXQgY2VsbCwga2V5LCBpLCBuO1xuICAgIGlmIChwcmV2KSBmb3IgKGtleSBpbiBwcmV2KSB7XG4gICAgICBjZWxsID0gcHJldltrZXldO1xuICAgICAgaWYgKCFkcm9wIHx8IGNlbGwubnVtKSByZW0ucHVzaChjZWxsLnR1cGxlKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gdGhpcy5fYWxlbjsgaSA8IG47ICsraSkge1xuICAgICAgYWRkLnB1c2godGhpcy5jZWxsdHVwbGUoYWRkc1tpXSkpO1xuICAgICAgYWRkc1tpXSA9IG51bGw7IC8vIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gdGhpcy5fbWxlbjsgaSA8IG47ICsraSkge1xuICAgICAgY2VsbCA9IG1vZHNbaV07XG4gICAgICAoY2VsbC5udW0gPT09IDAgJiYgZHJvcCA/IHJlbSA6IG1vZCkucHVzaCh0aGlzLmNlbGx0dXBsZShjZWxsKSk7XG4gICAgICBtb2RzW2ldID0gbnVsbDsgLy8gZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIH1cblxuICAgIHRoaXMuX2FsZW4gPSB0aGlzLl9tbGVuID0gMDsgLy8gcmVzZXQgbGlzdCBvZiBhY3RpdmUgY2VsbHNcblxuICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmNvbnN0IEVQU0lMT04kMSA9IDFlLTE0O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBiaW5uaW5nIGZ1bmN0aW9uIGZvciBkaXNjcmV0aXppbmcgZGF0YS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLiBUaGVcbiAqICAgcHJvdmlkZWQgdmFsdWVzIHNob3VsZCBiZSB2YWxpZCBvcHRpb25zIGZvciB0aGUge0BsaW5rIGJpbn0gZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSBkYXRhIGZpZWxkIHRvIGJpbi5cbiAqL1xuXG5mdW5jdGlvbiBCaW4ocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5CaW4uRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnQmluJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdpbnRlcnZhbCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhbmNob3InLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ21heGJpbnMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAyMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnYmFzZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDEwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdkaXZpZGUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6IFs1LCAyXVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3BhbicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcHMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWluc3RlcCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ25pY2UnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnbmFtZScsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsnYmluMCcsICdiaW4xJ11cbiAgfV1cbn07XG5pbmhlcml0cyhCaW4sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBiYW5kID0gXy5pbnRlcnZhbCAhPT0gZmFsc2UsXG4gICAgICAgICAgYmlucyA9IHRoaXMuX2JpbnMoXyksXG4gICAgICAgICAgc3RhcnQgPSBiaW5zLnN0YXJ0LFxuICAgICAgICAgIHN0ZXAgPSBiaW5zLnN0ZXAsXG4gICAgICAgICAgYXMgPSBfLmFzIHx8IFsnYmluMCcsICdiaW4xJ10sXG4gICAgICAgICAgYjAgPSBhc1swXSxcbiAgICAgICAgICBiMSA9IGFzWzFdO1xuXG4gICAgbGV0IGZsYWc7XG5cbiAgICBpZiAoXy5tb2RpZmllZCgpKSB7XG4gICAgICBwdWxzZSA9IHB1bHNlLnJlZmxvdyh0cnVlKTtcbiAgICAgIGZsYWcgPSBwdWxzZS5TT1VSQ0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWcgPSBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyhfLmZpZWxkKSkgPyBwdWxzZS5BRERfTU9EIDogcHVsc2UuQUREO1xuICAgIH1cblxuICAgIHB1bHNlLnZpc2l0KGZsYWcsIGJhbmQgPyB0ID0+IHtcbiAgICAgIGNvbnN0IHYgPSBiaW5zKHQpOyAvLyBtaW5pbXVtIGJpbiB2YWx1ZSAoaW5jbHVzaXZlKVxuXG4gICAgICB0W2IwXSA9IHY7IC8vIG1heGltdW0gYmluIHZhbHVlIChleGNsdXNpdmUpXG4gICAgICAvLyB1c2UgY29udm9sdXRlZCBtYXRoIGZvciBiZXR0ZXIgZmxvYXRpbmcgcG9pbnQgYWdyZWVtZW50XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS9pc3N1ZXMvODMwXG4gICAgICAvLyBpbmZpbml0ZSB2YWx1ZXMgcHJvcGFnYXRlIHRocm91Z2ggdGhpcyBmb3JtdWxhISAjMjIyN1xuXG4gICAgICB0W2IxXSA9IHYgPT0gbnVsbCA/IG51bGwgOiBzdGFydCArIHN0ZXAgKiAoMSArICh2IC0gc3RhcnQpIC8gc3RlcCk7XG4gICAgfSA6IHQgPT4gdFtiMF0gPSBiaW5zKHQpKTtcbiAgICByZXR1cm4gcHVsc2UubW9kaWZpZXMoYmFuZCA/IGFzIDogYjApO1xuICB9LFxuXG4gIF9iaW5zKF8pIHtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZCA9IF8uZmllbGQsXG4gICAgICAgICAgYmlucyA9IGJpbihfKSxcbiAgICAgICAgICBzdGVwID0gYmlucy5zdGVwO1xuICAgIGxldCBzdGFydCA9IGJpbnMuc3RhcnQsXG4gICAgICAgIHN0b3AgPSBzdGFydCArIE1hdGguY2VpbCgoYmlucy5zdG9wIC0gc3RhcnQpIC8gc3RlcCkgKiBzdGVwLFxuICAgICAgICBhLFxuICAgICAgICBkO1xuXG4gICAgaWYgKChhID0gXy5hbmNob3IpICE9IG51bGwpIHtcbiAgICAgIGQgPSBhIC0gKHN0YXJ0ICsgc3RlcCAqIE1hdGguZmxvb3IoKGEgLSBzdGFydCkgLyBzdGVwKSk7XG4gICAgICBzdGFydCArPSBkO1xuICAgICAgc3RvcCArPSBkO1xuICAgIH1cblxuICAgIGNvbnN0IGYgPSBmdW5jdGlvbiAodCkge1xuICAgICAgbGV0IHYgPSB0b051bWJlcihmaWVsZCh0KSk7XG4gICAgICByZXR1cm4gdiA9PSBudWxsID8gbnVsbCA6IHYgPCBzdGFydCA/IC1JbmZpbml0eSA6IHYgPiBzdG9wID8gK0luZmluaXR5IDogKHYgPSBNYXRoLm1heChzdGFydCwgTWF0aC5taW4odiwgc3RvcCAtIHN0ZXApKSwgc3RhcnQgKyBzdGVwICogTWF0aC5mbG9vcihFUFNJTE9OJDEgKyAodiAtIHN0YXJ0KSAvIHN0ZXApKTtcbiAgICB9O1xuXG4gICAgZi5zdGFydCA9IHN0YXJ0O1xuICAgIGYuc3RvcCA9IGJpbnMuc3RvcDtcbiAgICBmLnN0ZXAgPSBzdGVwO1xuICAgIHJldHVybiB0aGlzLnZhbHVlID0gYWNjZXNzb3IoZiwgYWNjZXNzb3JGaWVsZHMoZmllbGQpLCBfLm5hbWUgfHwgJ2Jpbl8nICsgYWNjZXNzb3JOYW1lKGZpZWxkKSk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIFNvcnRlZExpc3QgKGlkRnVuYywgc291cmNlLCBpbnB1dCkge1xuICBjb25zdCAkID0gaWRGdW5jO1xuICBsZXQgZGF0YSA9IHNvdXJjZSB8fCBbXSxcbiAgICAgIGFkZCA9IGlucHV0IHx8IFtdLFxuICAgICAgcmVtID0ge30sXG4gICAgICBjbnQgPSAwO1xuICByZXR1cm4ge1xuICAgIGFkZDogdCA9PiBhZGQucHVzaCh0KSxcbiAgICByZW1vdmU6IHQgPT4gcmVtWyQodCldID0gKytjbnQsXG4gICAgc2l6ZTogKCkgPT4gZGF0YS5sZW5ndGgsXG4gICAgZGF0YTogKGNvbXBhcmUsIHJlc29ydCkgPT4ge1xuICAgICAgaWYgKGNudCkge1xuICAgICAgICBkYXRhID0gZGF0YS5maWx0ZXIodCA9PiAhcmVtWyQodCldKTtcbiAgICAgICAgcmVtID0ge307XG4gICAgICAgIGNudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNvcnQgJiYgY29tcGFyZSkge1xuICAgICAgICBkYXRhLnNvcnQoY29tcGFyZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGQubGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBjb21wYXJlID8gbWVyZ2UoY29tcGFyZSwgZGF0YSwgYWRkLnNvcnQoY29tcGFyZSkpIDogZGF0YS5jb25jYXQoYWRkKTtcbiAgICAgICAgYWRkID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0cyBhbGwgZGF0YSB0dXBsZXMgdGhhdCBwYXNzIHRocm91Z2ggdGhpcyBvcGVyYXRvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCopOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBbiBvcHRpb25hbFxuICogICBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsbHkgc29ydGluZyB0aGUgY29sbGVjdGVkIHR1cGxlcy5cbiAqL1xuXG5mdW5jdGlvbiBDb2xsZWN0KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbn1cbkNvbGxlY3QuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnQ29sbGVjdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnc291cmNlJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9XVxufTtcbmluaGVyaXRzKENvbGxlY3QsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFMTCksXG4gICAgICAgICAgbGlzdCA9IFNvcnRlZExpc3QodHVwbGVpZCwgdGhpcy52YWx1ZSwgb3V0Lm1hdGVyaWFsaXplKG91dC5BREQpLmFkZCksXG4gICAgICAgICAgc29ydCA9IF8uc29ydCxcbiAgICAgICAgICBtb2QgPSBwdWxzZS5jaGFuZ2VkKCkgfHwgc29ydCAmJiAoXy5tb2RpZmllZCgnc29ydCcpIHx8IHB1bHNlLm1vZGlmaWVkKHNvcnQuZmllbGRzKSk7XG4gICAgb3V0LnZpc2l0KG91dC5SRU0sIGxpc3QucmVtb3ZlKTtcbiAgICB0aGlzLm1vZGlmaWVkKG1vZCk7XG4gICAgdGhpcy52YWx1ZSA9IG91dC5zb3VyY2UgPSBsaXN0LmRhdGEoc3RhYmxlQ29tcGFyZShzb3J0KSwgbW9kKTsgLy8gcHJvcGFnYXRlIHRyZWUgcm9vdCBpZiBkZWZpbmVkXG5cbiAgICBpZiAocHVsc2Uuc291cmNlICYmIHB1bHNlLnNvdXJjZS5yb290KSB7XG4gICAgICB0aGlzLnZhbHVlLnJvb3QgPSBwdWxzZS5zb3VyY2Uucm9vdDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfGZ1bmN0aW9uPn0gcGFyYW1zLmZpZWxkcyAtIFRoZSBmaWVsZHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5vcmRlcnNdIC0gVGhlIHNvcnQgb3JkZXJzLlxuICogICBFYWNoIGVudHJ5IHNob3VsZCBiZSBvbmUgb2YgXCJhc2NlbmRpbmdcIiAoZGVmYXVsdCkgb3IgXCJkZXNjZW5kaW5nXCIuXG4gKi9cblxuZnVuY3Rpb24gQ29tcGFyZShwYXJhbXMpIHtcbiAgT3BlcmF0b3IuY2FsbCh0aGlzLCBudWxsLCB1cGRhdGUkNSwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKENvbXBhcmUsIE9wZXJhdG9yKTtcblxuZnVuY3Rpb24gdXBkYXRlJDUoXykge1xuICByZXR1cm4gdGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpID8gdGhpcy52YWx1ZSA6IGNvbXBhcmUoXy5maWVsZHMsIF8ub3JkZXJzKTtcbn1cblxuLyoqXG4gKiBDb3VudCByZWdleHAtZGVmaW5lZCBwYXR0ZXJuIG9jY3VycmVuY2VzIGluIGEgdGV4dCBmaWVsZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBBbiBhY2Nlc3NvciBmb3IgdGhlIHRleHQgZmllbGQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5wYXR0ZXJuXSAtIFJlZ0V4cCBzdHJpbmcgZGVmaW5pbmcgdGhlIHRleHQgcGF0dGVybi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmNhc2VdIC0gT25lIG9mICdsb3dlcicsICd1cHBlcicgb3IgbnVsbCAobWl4ZWQpIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5zdG9wd29yZHNdIC0gUmVnRXhwIHN0cmluZyBvZiB3b3JkcyB0byBpZ25vcmUuXG4gKi9cblxuZnVuY3Rpb24gQ291bnRQYXR0ZXJuKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuQ291bnRQYXR0ZXJuLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0NvdW50UGF0dGVybicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdjYXNlJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAndmFsdWVzJzogWyd1cHBlcicsICdsb3dlcicsICdtaXhlZCddLFxuICAgICdkZWZhdWx0JzogJ21peGVkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAncGF0dGVybicsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdbXFxcXHdcIl0rJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RvcHdvcmRzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJydcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBbJ3RleHQnLCAnY291bnQnXVxuICB9XVxufTtcblxuZnVuY3Rpb24gdG9rZW5pemUodGV4dCwgdGNhc2UsIG1hdGNoKSB7XG4gIHN3aXRjaCAodGNhc2UpIHtcbiAgICBjYXNlICd1cHBlcic6XG4gICAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsb3dlcic6XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdGV4dC5tYXRjaChtYXRjaCk7XG59XG5cbmluaGVyaXRzKENvdW50UGF0dGVybiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IHByb2Nlc3MgPSB1cGRhdGUgPT4gdHVwbGUgPT4ge1xuICAgICAgdmFyIHRva2VucyA9IHRva2VuaXplKGdldCh0dXBsZSksIF8uY2FzZSwgbWF0Y2gpIHx8IFtdLFxuICAgICAgICAgIHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG9rZW5zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoIXN0b3AudGVzdCh0ID0gdG9rZW5zW2ldKSkgdXBkYXRlKHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpbml0ID0gdGhpcy5fcGFyYW1ldGVyQ2hlY2soXywgcHVsc2UpLFxuICAgICAgICAgIGNvdW50cyA9IHRoaXMuX2NvdW50cyxcbiAgICAgICAgICBtYXRjaCA9IHRoaXMuX21hdGNoLFxuICAgICAgICAgIHN0b3AgPSB0aGlzLl9zdG9wLFxuICAgICAgICAgIGdldCA9IF8uZmllbGQsXG4gICAgICAgICAgYXMgPSBfLmFzIHx8IFsndGV4dCcsICdjb3VudCddLFxuICAgICAgICAgIGFkZCA9IHByb2Nlc3ModCA9PiBjb3VudHNbdF0gPSAxICsgKGNvdW50c1t0XSB8fCAwKSksXG4gICAgICAgICAgcmVtID0gcHJvY2Vzcyh0ID0+IGNvdW50c1t0XSAtPSAxKTtcblxuICAgIGlmIChpbml0KSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIGFkZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgYWRkKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgcmVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZmluaXNoKHB1bHNlLCBhcyk7IC8vIGdlbmVyYXRlIG91dHB1dCB0dXBsZXNcbiAgfSxcblxuICBfcGFyYW1ldGVyQ2hlY2soXywgcHVsc2UpIHtcbiAgICBsZXQgaW5pdCA9IGZhbHNlO1xuXG4gICAgaWYgKF8ubW9kaWZpZWQoJ3N0b3B3b3JkcycpIHx8ICF0aGlzLl9zdG9wKSB7XG4gICAgICB0aGlzLl9zdG9wID0gbmV3IFJlZ0V4cCgnXicgKyAoXy5zdG9wd29yZHMgfHwgJycpICsgJyQnLCAnaScpO1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKF8ubW9kaWZpZWQoJ3BhdHRlcm4nKSB8fCAhdGhpcy5fbWF0Y2gpIHtcbiAgICAgIHRoaXMuX21hdGNoID0gbmV3IFJlZ0V4cChfLnBhdHRlcm4gfHwgJ1tcXFxcd1xcJ10rJywgJ2cnKTtcbiAgICAgIGluaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChfLm1vZGlmaWVkKCdmaWVsZCcpIHx8IHB1bHNlLm1vZGlmaWVkKF8uZmllbGQuZmllbGRzKSkge1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGluaXQpIHRoaXMuX2NvdW50cyA9IHt9O1xuICAgIHJldHVybiBpbml0O1xuICB9LFxuXG4gIF9maW5pc2gocHVsc2UsIGFzKSB7XG4gICAgY29uc3QgY291bnRzID0gdGhpcy5fY291bnRzLFxuICAgICAgICAgIHR1cGxlcyA9IHRoaXMuX3R1cGxlcyB8fCAodGhpcy5fdHVwbGVzID0ge30pLFxuICAgICAgICAgIHRleHQgPSBhc1swXSxcbiAgICAgICAgICBjb3VudCA9IGFzWzFdLFxuICAgICAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcbiAgICBsZXQgdywgdCwgYztcblxuICAgIGZvciAodyBpbiBjb3VudHMpIHtcbiAgICAgIHQgPSB0dXBsZXNbd107XG4gICAgICBjID0gY291bnRzW3ddIHx8IDA7XG5cbiAgICAgIGlmICghdCAmJiBjKSB7XG4gICAgICAgIHR1cGxlc1t3XSA9IHQgPSBpbmdlc3Qoe30pO1xuICAgICAgICB0W3RleHRdID0gdztcbiAgICAgICAgdFtjb3VudF0gPSBjO1xuICAgICAgICBvdXQuYWRkLnB1c2godCk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IDApIHtcbiAgICAgICAgaWYgKHQpIG91dC5yZW0ucHVzaCh0KTtcbiAgICAgICAgY291bnRzW3ddID0gbnVsbDtcbiAgICAgICAgdHVwbGVzW3ddID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodFtjb3VudF0gIT09IGMpIHtcbiAgICAgICAgdFtjb3VudF0gPSBjO1xuICAgICAgICBvdXQubW9kLnB1c2godCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogUGVyZm9ybSBhIGNyb3NzLXByb2R1Y3Qgb2YgYSB0dXBsZSBzdHJlYW0gd2l0aCBpdHNlbGYuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTpib29sZWFufSBbcGFyYW1zLmZpbHRlcl0gLSBBbiBvcHRpb25hbCBmaWx0ZXJcbiAqICAgZnVuY3Rpb24gZm9yIHNlbGVjdGl2ZWx5IGluY2x1ZGluZyB0dXBsZXMgaW4gdGhlIGNyb3NzIHByb2R1Y3QuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gVGhlIG5hbWVzIG9mIHRoZSBvdXRwdXQgZmllbGRzLlxuICovXG5cbmZ1bmN0aW9uIENyb3NzKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuQ3Jvc3MuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnQ3Jvc3MnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmlsdGVyJyxcbiAgICAndHlwZSc6ICdleHByJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsnYScsICdiJ11cbiAgfV1cbn07XG5pbmhlcml0cyhDcm9zcywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKSxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgWydhJywgJ2InXSxcbiAgICAgICAgICBhID0gYXNbMF0sXG4gICAgICAgICAgYiA9IGFzWzFdLFxuICAgICAgICAgIHJlc2V0ID0gIXRoaXMudmFsdWUgfHwgcHVsc2UuY2hhbmdlZChwdWxzZS5BRERfUkVNKSB8fCBfLm1vZGlmaWVkKCdhcycpIHx8IF8ubW9kaWZpZWQoJ2ZpbHRlcicpO1xuXG4gICAgbGV0IGRhdGEgPSB0aGlzLnZhbHVlO1xuXG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICBpZiAoZGF0YSkgb3V0LnJlbSA9IGRhdGE7XG4gICAgICBkYXRhID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2U7XG4gICAgICBvdXQuYWRkID0gdGhpcy52YWx1ZSA9IGNyb3NzKGRhdGEsIGEsIGIsIF8uZmlsdGVyIHx8IHRydXRoeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5tb2QgPSBkYXRhO1xuICAgIH1cblxuICAgIG91dC5zb3VyY2UgPSB0aGlzLnZhbHVlO1xuICAgIHJldHVybiBvdXQubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBjcm9zcyhpbnB1dCwgYSwgYiwgZmlsdGVyKSB7XG4gIHZhciBkYXRhID0gW10sXG4gICAgICB0ID0ge30sXG4gICAgICBuID0gaW5wdXQubGVuZ3RoLFxuICAgICAgaSA9IDAsXG4gICAgICBqLFxuICAgICAgbGVmdDtcblxuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIHRbYV0gPSBsZWZ0ID0gaW5wdXRbaV07XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICB0W2JdID0gaW5wdXRbal07XG5cbiAgICAgIGlmIChmaWx0ZXIodCkpIHtcbiAgICAgICAgZGF0YS5wdXNoKGluZ2VzdCh0KSk7XG4gICAgICAgIHQgPSB7fTtcbiAgICAgICAgdFthXSA9IGxlZnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmNvbnN0IERpc3RyaWJ1dGlvbnMgPSB7XG4gIGtkZTogcmFuZG9tS0RFLFxuICBtaXh0dXJlOiByYW5kb21NaXh0dXJlLFxuICBub3JtYWw6IHJhbmRvbU5vcm1hbCxcbiAgbG9nbm9ybWFsOiByYW5kb21Mb2dOb3JtYWwsXG4gIHVuaWZvcm06IHJhbmRvbVVuaWZvcm1cbn07XG5jb25zdCBESVNUUklCVVRJT05TID0gJ2Rpc3RyaWJ1dGlvbnMnLFxuICAgICAgRlVOQ1RJT04gPSAnZnVuY3Rpb24nLFxuICAgICAgRklFTEQgPSAnZmllbGQnO1xuLyoqXG4gKiBQYXJzZSBhIHBhcmFtZXRlciBvYmplY3QgZm9yIGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IGRlZiAtIFRoZSBkaXN0cmlidXRpb24gcGFyYW1ldGVyIG9iamVjdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpBcnJheTxvYmplY3Q+fSAtIEEgbWV0aG9kIGZvciByZXF1ZXN0aW5nXG4gKiAgIHNvdXJjZSBkYXRhLiBVc2VkIGZvciBkaXN0cmlidXRpb25zIChzdWNoIGFzIEtERSkgdGhhdFxuICogICByZXF1aXJlIHNhbXBsZSBkYXRhIHBvaW50cy4gVGhpcyBtZXRob2Qgd2lsbCBvbmx5IGJlXG4gKiAgIGludm9rZWQgaWYgdGhlICdmcm9tJyBwYXJhbWV0ZXIgZm9yIGEgdGFyZ2V0IGRhdGEgc291cmNlXG4gKiAgIGlzIG5vdCBwcm92aWRlZC4gVHlwaWNhbGx5IHRoaXMgbWV0aG9kIHJldHVybnMgYmFja2luZ1xuICogICBzb3VyY2UgZGF0YSBmb3IgYSBQdWxzZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIG91dHB1dCBkaXN0cmlidXRpb24gb2JqZWN0LlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKGRlZiwgZGF0YSkge1xuICBjb25zdCBmdW5jID0gZGVmW0ZVTkNUSU9OXTtcblxuICBpZiAoIWhhc093blByb3BlcnR5KERpc3RyaWJ1dGlvbnMsIGZ1bmMpKSB7XG4gICAgZXJyb3IoJ1Vua25vd24gZGlzdHJpYnV0aW9uIGZ1bmN0aW9uOiAnICsgZnVuYyk7XG4gIH1cblxuICBjb25zdCBkID0gRGlzdHJpYnV0aW9uc1tmdW5jXSgpO1xuXG4gIGZvciAoY29uc3QgbmFtZSBpbiBkZWYpIHtcbiAgICAvLyBpZiBkYXRhIGZpZWxkLCBleHRyYWN0IHZhbHVlc1xuICAgIGlmIChuYW1lID09PSBGSUVMRCkge1xuICAgICAgZC5kYXRhKChkZWYuZnJvbSB8fCBkYXRhKCkpLm1hcChkZWZbbmFtZV0pKTtcbiAgICB9IC8vIGlmIGRpc3RyaWJ1dGlvbiBtaXh0dXJlLCByZWN1cnNlIHRvIHBhcnNlIGVhY2ggZGVmaW5pdGlvblxuICAgIGVsc2UgaWYgKG5hbWUgPT09IERJU1RSSUJVVElPTlMpIHtcbiAgICAgICAgZFtuYW1lXShkZWZbbmFtZV0ubWFwKF8gPT4gcGFyc2UoXywgZGF0YSkpKTtcbiAgICAgIH0gLy8gb3RoZXJ3aXNlLCBzaW1wbHkgc2V0IHRoZSBwYXJhbWV0ZXJcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkW25hbWVdID09PSBGVU5DVElPTikge1xuICAgICAgICAgIGRbbmFtZV0oZGVmW25hbWVdKTtcbiAgICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGQ7XG59XG5cbi8qKlxuICogR3JpZCBzYW1wbGUgcG9pbnRzIGZvciBhIHByb2JhYmlsaXR5IGRlbnNpdHkuIEdpdmVuIGEgZGlzdHJpYnV0aW9uIGFuZFxuICogYSBzYW1wbGluZyBleHRlbnQsIHdpbGwgZ2VuZXJhdGUgcG9pbnRzIHN1aXRhYmxlIGZvciBwbG90dGluZyBlaXRoZXJcbiAqIFBERiAocHJvYmFiaWxpdHkgZGVuc2l0eSBmdW5jdGlvbikgb3IgQ0RGIChjdW11bGF0aXZlIGRpc3RyaWJ1dGlvblxuICogZnVuY3Rpb24pIGN1cnZlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5kaXN0cmlidXRpb24gLSBUaGUgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uLiBUaGlzXG4gKiAgIGlzIGFuIG9iamVjdCBwYXJhbWV0ZXIgZGVwZW5kZW50IG9uIHRoZSBkaXN0cmlidXRpb24gdHlwZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLm1ldGhvZD0ncGRmJ10gLSBUaGUgZGlzdHJpYnV0aW9uIG1ldGhvZCB0byBzYW1wbGUuXG4gKiAgIE9uZSBvZiAncGRmJyBvciAnY2RmJy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5leHRlbnRdIC0gVGhlIFttaW4sIG1heF0gZXh0ZW50IG92ZXIgd2hpY2hcbiAqICAgdG8gc2FtcGxlIHRoZSBkaXN0cmlidXRpb24uIFRoaXMgYXJndW1lbnQgaXMgcmVxdWlyZWQgaW4gbW9zdCBjYXNlcywgYnV0XG4gKiAgIGNhbiBiZSBvbWl0dGVkIGlmIHRoZSBkaXN0cmlidXRpb24gKGUuZy4sICdrZGUnKSBzdXBwb3J0cyBhICdkYXRhJyBtZXRob2RcbiAqICAgdGhhdCByZXR1cm5zIG51bWVyaWNhbCBzYW1wbGUgcG9pbnRzIGZyb20gd2hpY2ggdGhlIGV4dGVudCBjYW4gYmUgZGVkdWNlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLm1pbnN0ZXBzPTI1XSAtIFRoZSBtaW5pbXVtIG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVzXG4gKiAgIGZvciBwbG90dGluZyB0aGUgZGVuc2l0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLm1heHN0ZXBzPTIwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgY3VydmUgc2FtcGxlc1xuICogICBmb3IgcGxvdHRpbmcgdGhlIGRlbnNpdHkuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5zdGVwc10gLSBUaGUgZXhhY3QgbnVtYmVyIG9mIGN1cnZlIHNhbXBsZXMgZm9yXG4gKiAgIHBsb3R0aW5nIHRoZSBkZW5zaXR5LiBJZiBzcGVjaWZpZWQsIG92ZXJyaWRlcyBib3RoIG1pbnN0ZXBzIGFuZCBtYXhzdGVwc1xuICogICB0byBzZXQgYW4gZXhhY3QgbnVtYmVyIG9mIHVuaWZvcm0gc2FtcGxlcy4gVXNlZnVsIGluIGNvbmp1bmN0aW9uIHdpdGhcbiAqICAgYSBmaXhlZCBleHRlbnQgdG8gZW5zdXJlIGNvbnNpc3RlbnQgc2FtcGxlIHBvaW50cyBmb3Igc3RhY2tlZCBkZW5zaXRpZXMuXG4gKi9cblxuZnVuY3Rpb24gRGVuc2l0eShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmNvbnN0IGRpc3RyaWJ1dGlvbnMgPSBbe1xuICAna2V5Jzoge1xuICAgICdmdW5jdGlvbic6ICdub3JtYWwnXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ21lYW4nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGRldicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDFcbiAgfV1cbn0sIHtcbiAgJ2tleSc6IHtcbiAgICAnZnVuY3Rpb24nOiAnbG9nbm9ybWFsJ1xuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdtZWFuJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RkZXYnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxXG4gIH1dXG59LCB7XG4gICdrZXknOiB7XG4gICAgJ2Z1bmN0aW9uJzogJ3VuaWZvcm0nXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ21pbicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ21heCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDFcbiAgfV1cbn0sIHtcbiAgJ2tleSc6IHtcbiAgICAnZnVuY3Rpb24nOiAna2RlJ1xuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2Zyb20nLFxuICAgICd0eXBlJzogJ2RhdGEnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdiYW5kd2lkdGgnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH1dXG59XTtcbmNvbnN0IG1peHR1cmUgPSB7XG4gICdrZXknOiB7XG4gICAgJ2Z1bmN0aW9uJzogJ21peHR1cmUnXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2Rpc3RyaWJ1dGlvbnMnLFxuICAgICd0eXBlJzogJ3BhcmFtJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdwYXJhbXMnOiBkaXN0cmlidXRpb25zXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd3ZWlnaHRzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfV1cbn07XG5EZW5zaXR5LkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0RlbnNpdHknLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtaW5zdGVwcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDI1XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtYXhzdGVwcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDIwMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ3BkZicsXG4gICAgJ3ZhbHVlcyc6IFsncGRmJywgJ2NkZiddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdkaXN0cmlidXRpb24nLFxuICAgICd0eXBlJzogJ3BhcmFtJyxcbiAgICAncGFyYW1zJzogZGlzdHJpYnV0aW9ucy5jb25jYXQobWl4dHVyZSlcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiBbJ3ZhbHVlJywgJ2RlbnNpdHknXVxuICB9XVxufTtcbmluaGVyaXRzKERlbnNpdHksIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG5cbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgcHVsc2UuY2hhbmdlZCgpIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgY29uc3QgZGlzdCA9IHBhcnNlKF8uZGlzdHJpYnV0aW9uLCBzb3VyY2UocHVsc2UpKSxcbiAgICAgICAgICAgIG1pbnN0ZXBzID0gXy5zdGVwcyB8fCBfLm1pbnN0ZXBzIHx8IDI1LFxuICAgICAgICAgICAgbWF4c3RlcHMgPSBfLnN0ZXBzIHx8IF8ubWF4c3RlcHMgfHwgMjAwO1xuICAgICAgbGV0IG1ldGhvZCA9IF8ubWV0aG9kIHx8ICdwZGYnO1xuXG4gICAgICBpZiAobWV0aG9kICE9PSAncGRmJyAmJiBtZXRob2QgIT09ICdjZGYnKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGRlbnNpdHkgbWV0aG9kOiAnICsgbWV0aG9kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmV4dGVudCAmJiAhZGlzdC5kYXRhKSB7XG4gICAgICAgIGVycm9yKCdNaXNzaW5nIGRlbnNpdHkgZXh0ZW50IHBhcmFtZXRlci4nKTtcbiAgICAgIH1cblxuICAgICAgbWV0aG9kID0gZGlzdFttZXRob2RdO1xuICAgICAgY29uc3QgYXMgPSBfLmFzIHx8IFsndmFsdWUnLCAnZGVuc2l0eSddLFxuICAgICAgICAgICAgZG9tYWluID0gXy5leHRlbnQgfHwgZXh0ZW50KGRpc3QuZGF0YSgpKSxcbiAgICAgICAgICAgIHZhbHVlcyA9IHNhbXBsZUN1cnZlKG1ldGhvZCwgZG9tYWluLCBtaW5zdGVwcywgbWF4c3RlcHMpLm1hcCh2ID0+IHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSB7fTtcbiAgICAgICAgdHVwbGVbYXNbMF1dID0gdlswXTtcbiAgICAgICAgdHVwbGVbYXNbMV1dID0gdlsxXTtcbiAgICAgICAgcmV0dXJuIGluZ2VzdCh0dXBsZSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSBvdXQuYWRkID0gb3V0LnNvdXJjZSA9IHZhbHVlcztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzb3VyY2UocHVsc2UpIHtcbiAgcmV0dXJuICgpID0+IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlO1xufVxuXG5mdW5jdGlvbiBmaWVsZE5hbWVzKGZpZWxkcywgYXMpIHtcbiAgaWYgKCFmaWVsZHMpIHJldHVybiBudWxsO1xuICByZXR1cm4gZmllbGRzLm1hcCgoZiwgaSkgPT4gYXNbaV0gfHwgYWNjZXNzb3JOYW1lKGYpKTtcbn1cbmZ1bmN0aW9uIHBhcnRpdGlvbiQxKGRhdGEsIGdyb3VwYnksIGZpZWxkKSB7XG4gIGNvbnN0IGdyb3VwcyA9IFtdLFxuICAgICAgICBnZXQgPSBmID0+IGYodCk7XG5cbiAgbGV0IG1hcCwgaSwgbiwgdCwgaywgZzsgLy8gcGFydGl0aW9uIGRhdGEgcG9pbnRzIGludG8gZ3JvdXBzXG5cbiAgaWYgKGdyb3VwYnkgPT0gbnVsbCkge1xuICAgIGdyb3Vwcy5wdXNoKGRhdGEubWFwKGZpZWxkKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXAgPSB7fSwgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IGRhdGFbaV07XG4gICAgICBrID0gZ3JvdXBieS5tYXAoZ2V0KTtcbiAgICAgIGcgPSBtYXBba107XG5cbiAgICAgIGlmICghZykge1xuICAgICAgICBtYXBba10gPSBnID0gW107XG4gICAgICAgIGcuZGltcyA9IGs7XG4gICAgICAgIGdyb3Vwcy5wdXNoKGcpO1xuICAgICAgfVxuXG4gICAgICBnLnB1c2goZmllbGQodCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBncm91cHM7XG59XG5cbmNvbnN0IE91dHB1dCA9ICdiaW4nO1xuLyoqXG4gKiBEb3QgZGVuc2l0eSBiaW5uaW5nIGZvciBkb3QgcGxvdCBjb25zdHJ1Y3Rpb24uXG4gKiBCYXNlZCBvbiBMZWxhbmQgV2lsa2luc29uLCBEb3QgUGxvdHMsIFRoZSBBbWVyaWNhbiBTdGF0aXN0aWNpYW4sIDE5OTkuXG4gKiBodHRwczovL3d3dy5jcy51aWMuZWR1L353aWxraW5zb24vUHVibGljYXRpb25zL2RvdHBsb3RzLnBkZlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBiaW4uXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5zdGVwXSAtIFRoZSBzdGVwIHNpemUgKGJpbiB3aWR0aCkgd2l0aGluIHdoaWNoIGRvdHMgc2hvdWxkIGJlXG4gKiAgIHN0YWNrZWQuIERlZmF1bHRzIHRvIDEvMzAgb2YgdGhlIGV4dGVudCBvZiB0aGUgZGF0YSAqZmllbGQqLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLnNtb290aD1mYWxzZV0gLSBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIGRvdCBkZW5zaXR5XG4gKiAgIHN0YWNrcyBzaG91bGQgYmUgc21vb3RoZWQgdG8gcmVkdWNlIHZhcmlhbmNlLlxuICovXG5cbmZ1bmN0aW9uIERvdEJpbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkRvdEJpbi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdEb3RCaW4nLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzbW9vdGgnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogT3V0cHV0XG4gIH1dXG59O1xuXG5jb25zdCBhdXRvc3RlcCA9IChkYXRhLCBmaWVsZCkgPT4gc3BhbihleHRlbnQoZGF0YSwgZmllbGQpKSAvIDMwO1xuXG5pbmhlcml0cyhEb3RCaW4sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhKF8ubW9kaWZpZWQoKSB8fCBwdWxzZS5jaGFuZ2VkKCkpKSB7XG4gICAgICByZXR1cm4gcHVsc2U7IC8vIGVhcmx5IGV4aXRcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgICAgICBncm91cHMgPSBwYXJ0aXRpb24kMShwdWxzZS5zb3VyY2UsIF8uZ3JvdXBieSwgaWRlbnRpdHkpLFxuICAgICAgICAgIHNtb290aCA9IF8uc21vb3RoIHx8IGZhbHNlLFxuICAgICAgICAgIGZpZWxkID0gXy5maWVsZCxcbiAgICAgICAgICBzdGVwID0gXy5zdGVwIHx8IGF1dG9zdGVwKHNvdXJjZSwgZmllbGQpLFxuICAgICAgICAgIHNvcnQgPSBzdGFibGVDb21wYXJlKChhLCBiKSA9PiBmaWVsZChhKSAtIGZpZWxkKGIpKSxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgT3V0cHV0LFxuICAgICAgICAgIG4gPSBncm91cHMubGVuZ3RoOyAvLyBjb21wdXRlIGRvdHBsb3QgYmlucyBwZXIgZ3JvdXBcblxuICAgIGxldCBtaW4gPSBJbmZpbml0eSxcbiAgICAgICAgbWF4ID0gLUluZmluaXR5LFxuICAgICAgICBpID0gMCxcbiAgICAgICAgajtcblxuICAgIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBnID0gZ3JvdXBzW2ldLnNvcnQoc29ydCk7XG4gICAgICBqID0gLTE7XG5cbiAgICAgIGZvciAoY29uc3QgdiBvZiBkb3RiaW4oZywgc3RlcCwgc21vb3RoLCBmaWVsZCkpIHtcbiAgICAgICAgaWYgKHYgPCBtaW4pIG1pbiA9IHY7XG4gICAgICAgIGlmICh2ID4gbWF4KSBtYXggPSB2O1xuICAgICAgICBnWysral1bYXNdID0gdjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0ge1xuICAgICAgc3RhcnQ6IG1pbixcbiAgICAgIHN0b3A6IG1heCxcbiAgICAgIHN0ZXA6IHN0ZXBcbiAgICB9O1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3codHJ1ZSkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFdyYXBzIGFuIGV4cHJlc3Npb24gZnVuY3Rpb24gd2l0aCBhY2Nlc3MgdG8gZXh0ZXJuYWwgcGFyYW1ldGVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcGFyYW1zLmV4cHIgLSBUaGUgZXhwcmVzc2lvbiBmdW5jdGlvbi4gVGhlXG4gKiAgZnVuY3Rpb24gc2hvdWxkIGFjY2VwdCBib3RoIGEgZGF0dW0gYW5kIGEgcGFyYW1ldGVyIG9iamVjdC5cbiAqICBUaGlzIG9wZXJhdG9yJ3MgdmFsdWUgd2lsbCBiZSBhIG5ldyBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZVxuICogIGV4cHJlc3Npb24gZnVuY3Rpb24gd2l0aCBhY2Nlc3MgdG8gdGhpcyBvcGVyYXRvcidzIHBhcmFtZXRlcnMuXG4gKi9cblxuZnVuY3Rpb24gRXhwcmVzc2lvbihwYXJhbXMpIHtcbiAgT3BlcmF0b3IuY2FsbCh0aGlzLCBudWxsLCB1cGRhdGUkNCwgcGFyYW1zKTtcbiAgdGhpcy5tb2RpZmllZCh0cnVlKTtcbn1cbmluaGVyaXRzKEV4cHJlc3Npb24sIE9wZXJhdG9yKTtcblxuZnVuY3Rpb24gdXBkYXRlJDQoXykge1xuICBjb25zdCBleHByID0gXy5leHByO1xuICByZXR1cm4gdGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgnZXhwcicpID8gdGhpcy52YWx1ZSA6IGFjY2Vzc29yKGRhdHVtID0+IGV4cHIoZGF0dW0sIF8pLCBhY2Nlc3NvckZpZWxkcyhleHByKSwgYWNjZXNzb3JOYW1lKGV4cHIpKTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBleHRlbnRzIChtaW4vbWF4KSBmb3IgYSBkYXRhIGZpZWxkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSBmaWVsZCBvdmVyIHdoaWNoIHRvIGNvbXB1dGUgZXh0ZW5kcy5cbiAqL1xuXG5mdW5jdGlvbiBFeHRlbnQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFt1bmRlZmluZWQsIHVuZGVmaW5lZF0sIHBhcmFtcyk7XG59XG5FeHRlbnQuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnRXh0ZW50JyxcbiAgJ21ldGFkYXRhJzoge30sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKEV4dGVudCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGV4dGVudCA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgZmllbGQgPSBfLmZpZWxkLFxuICAgICAgICAgIG1vZCA9IHB1bHNlLmNoYW5nZWQoKSB8fCBwdWxzZS5tb2RpZmllZChmaWVsZC5maWVsZHMpIHx8IF8ubW9kaWZpZWQoJ2ZpZWxkJyk7XG5cbiAgICBsZXQgbWluID0gZXh0ZW50WzBdLFxuICAgICAgICBtYXggPSBleHRlbnRbMV07XG5cbiAgICBpZiAobW9kIHx8IG1pbiA9PSBudWxsKSB7XG4gICAgICBtaW4gPSArSW5maW5pdHk7XG4gICAgICBtYXggPSAtSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQobW9kID8gcHVsc2UuU09VUkNFIDogcHVsc2UuQURELCB0ID0+IHtcbiAgICAgIGNvbnN0IHYgPSB0b051bWJlcihmaWVsZCh0KSk7XG5cbiAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgLy8gTmFOcyB3aWxsIGZhaWwgYWxsIGNvbXBhcmlzb25zIVxuICAgICAgICBpZiAodiA8IG1pbikgbWluID0gdjtcbiAgICAgICAgaWYgKHYgPiBtYXgpIG1heCA9IHY7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShtaW4pIHx8ICFOdW1iZXIuaXNGaW5pdGUobWF4KSkge1xuICAgICAgbGV0IG5hbWUgPSBhY2Nlc3Nvck5hbWUoZmllbGQpO1xuICAgICAgaWYgKG5hbWUpIG5hbWUgPSBgIGZvciBmaWVsZCBcIiR7bmFtZX1cImA7XG4gICAgICBwdWxzZS5kYXRhZmxvdy53YXJuKGBJbmZpbml0ZSBleHRlbnQke25hbWV9OiBbJHttaW59LCAke21heH1dYCk7XG4gICAgICBtaW4gPSBtYXggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IFttaW4sIG1heF07XG4gIH1cblxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBicmlkZ2UgYmV0d2VlbiBhIHBhcmVudCB0cmFuc2Zvcm0gYW5kIGEgdGFyZ2V0IHN1YmZsb3cgdGhhdFxuICogY29uc3VtZXMgb25seSBhIHN1YnNldCBvZiB0aGUgdHVwbGVzIHRoYXQgcGFzcyB0aHJvdWdoIHRoZSBwYXJlbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gQSBwdWxzZSB0byB1c2UgYXMgdGhlIHZhbHVlIG9mIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gcGFyZW50IC0gVGhlIHBhcmVudCB0cmFuc2Zvcm0gKHR5cGljYWxseSBhIEZhY2V0IGluc3RhbmNlKS5cbiAqL1xuXG5mdW5jdGlvbiBTdWJmbG93KHB1bHNlLCBwYXJlbnQpIHtcbiAgT3BlcmF0b3IuY2FsbCh0aGlzLCBwdWxzZSk7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbmluaGVyaXRzKFN1YmZsb3csIE9wZXJhdG9yLCB7XG4gIC8qKlxuICAgKiBSb3V0ZXMgcHVsc2VzIGZyb20gdGhpcyBzdWJmbG93IHRvIGEgdGFyZ2V0IHRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtUcmFuc2Zvcm19IHRhcmdldCAtIEEgdHJhbnNmb3JtIHRoYXQgcmVjZWl2ZXMgdGhlIHN1YmZsb3cgb2YgdHVwbGVzLlxuICAgKi9cbiAgY29ubmVjdCh0YXJnZXQpIHtcbiAgICB0aGlzLmRldGFjaFN1YmZsb3cgPSB0YXJnZXQuZGV0YWNoU3ViZmxvdztcbiAgICB0aGlzLnRhcmdldHMoKS5hZGQodGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0LnNvdXJjZSA9IHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhbiAnYWRkJyB0dXBsZSB0byB0aGUgc3ViZmxvdyBwdWxzZS5cbiAgICogQHBhcmFtIHtUdXBsZX0gdCAtIFRoZSB0dXBsZSBiZWluZyBhZGRlZC5cbiAgICovXG4gIGFkZCh0KSB7XG4gICAgdGhpcy5jb3VudCArPSAxO1xuICAgIHRoaXMudmFsdWUuYWRkLnB1c2godCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhICdyZW0nIHR1cGxlIHRvIHRoZSBzdWJmbG93IHB1bHNlLlxuICAgKiBAcGFyYW0ge1R1cGxlfSB0IC0gVGhlIHR1cGxlIGJlaW5nIHJlbW92ZWQuXG4gICAqL1xuICByZW0odCkge1xuICAgIHRoaXMuY291bnQgLT0gMTtcbiAgICB0aGlzLnZhbHVlLnJlbS5wdXNoKHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYSAnbW9kJyB0dXBsZSB0byB0aGUgc3ViZmxvdyBwdWxzZS5cbiAgICogQHBhcmFtIHtUdXBsZX0gdCAtIFRoZSB0dXBsZSBiZWluZyBtb2RpZmllZC5cbiAgICovXG4gIG1vZCh0KSB7XG4gICAgdGhpcy52YWx1ZS5tb2QucHVzaCh0KTtcbiAgfSxcblxuICAvKipcbiAgICogUmUtaW5pdGlhbGl6ZSB0aGlzIG9wZXJhdG9yJ3MgcHVsc2UgdmFsdWUuXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gVGhlIHB1bHNlIHRvIGNvcHkgZnJvbS5cbiAgICogQHNlZSBQdWxzZS5pbml0XG4gICAqL1xuICBpbml0KHB1bHNlKSB7XG4gICAgdGhpcy52YWx1ZS5pbml0KHB1bHNlLCBwdWxzZS5OT19TT1VSQ0UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGlzIG9wZXJhdG9yLiBUaGlzIG1ldGhvZCBvdmVycmlkZXMgdGhlXG4gICAqIGRlZmF1bHQgYmVoYXZpb3IgdG8gc2ltcGx5IHJldHVybiB0aGUgY29udGFpbmVkIHB1bHNlIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtQdWxzZX1cbiAgICovXG4gIGV2YWx1YXRlKCkge1xuICAgIC8vIGFzc2VydDogdGhpcy52YWx1ZS5zdGFtcCA9PT0gcHVsc2Uuc3RhbXBcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBGYWNldHMgYSBkYXRhZmxvdyBpbnRvIGEgc2V0IG9mIHN1YmZsb3dzIGJhc2VkIG9uIGEga2V5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFmbG93LCBzdHJpbmcpOiBPcGVyYXRvcn0gcGFyYW1zLnN1YmZsb3cgLSBBIGZ1bmN0aW9uXG4gKiAgIHRoYXQgZ2VuZXJhdGVzIGEgc3ViZmxvdyBvZiBvcGVyYXRvcnMgYW5kIHJldHVybnMgaXRzIHJvb3Qgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5rZXkgLSBUaGUga2V5IGZpZWxkIHRvIGZhY2V0IGJ5LlxuICovXG5cbmZ1bmN0aW9uIEZhY2V0KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7fSwgcGFyYW1zKTtcbiAgdGhpcy5fa2V5cyA9IGZhc3RtYXAoKTsgLy8gY2FjaGUgcHJldmlvdXNseSBjYWxjdWxhdGVkIGtleSB2YWx1ZXNcbiAgLy8ga2VlcCB0cmFjayBvZiBhY3RpdmUgc3ViZmxvd3MsIHVzZSBhcyB0YXJnZXRzIGFycmF5IGZvciBsaXN0ZW5lcnNcbiAgLy8gdGhpcyBhbGxvd3MgdXMgdG8gbGltaXQgcHJvcGFnYXRpb24gdG8gb25seSB1cGRhdGVkIHN1YmZsb3dzXG5cbiAgY29uc3QgYSA9IHRoaXMuX3RhcmdldHMgPSBbXTtcbiAgYS5hY3RpdmUgPSAwO1xuXG4gIGEuZm9yRWFjaCA9IGYgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gYS5hY3RpdmU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGYoYVtpXSwgaSwgYSk7XG4gICAgfVxuICB9O1xufVxuaW5oZXJpdHMoRmFjZXQsIFRyYW5zZm9ybSwge1xuICBhY3RpdmF0ZShmbG93KSB7XG4gICAgdGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmFjdGl2ZSsrXSA9IGZsb3c7XG4gIH0sXG5cbiAgLy8gcGFyZW50IGFyZ3VtZW50IHByb3ZpZGVkIGJ5IFByZUZhY2V0IHN1YmNsYXNzXG4gIHN1YmZsb3coa2V5LCBmbG93LCBwdWxzZSwgcGFyZW50KSB7XG4gICAgY29uc3QgZmxvd3MgPSB0aGlzLnZhbHVlO1xuICAgIGxldCBzZiA9IGhhc093blByb3BlcnR5KGZsb3dzLCBrZXkpICYmIGZsb3dzW2tleV0sXG4gICAgICAgIGRmLFxuICAgICAgICBwO1xuXG4gICAgaWYgKCFzZikge1xuICAgICAgcCA9IHBhcmVudCB8fCAocCA9IHRoaXMuX2dyb3VwW2tleV0pICYmIHAudHVwbGU7XG4gICAgICBkZiA9IHB1bHNlLmRhdGFmbG93O1xuICAgICAgc2YgPSBuZXcgU3ViZmxvdyhwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksIHRoaXMpO1xuICAgICAgZGYuYWRkKHNmKS5jb25uZWN0KGZsb3coZGYsIGtleSwgcCkpO1xuICAgICAgZmxvd3Nba2V5XSA9IHNmO1xuICAgICAgdGhpcy5hY3RpdmF0ZShzZik7XG4gICAgfSBlbHNlIGlmIChzZi52YWx1ZS5zdGFtcCA8IHB1bHNlLnN0YW1wKSB7XG4gICAgICBzZi5pbml0KHB1bHNlKTtcbiAgICAgIHRoaXMuYWN0aXZhdGUoc2YpO1xuICAgIH1cblxuICAgIHJldHVybiBzZjtcbiAgfSxcblxuICBjbGVhbigpIHtcbiAgICBjb25zdCBmbG93cyA9IHRoaXMudmFsdWU7XG4gICAgbGV0IGRldGFjaGVkID0gMDtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGZsb3dzKSB7XG4gICAgICBpZiAoZmxvd3Nba2V5XS5jb3VudCA9PT0gMCkge1xuICAgICAgICBjb25zdCBkZXRhY2ggPSBmbG93c1trZXldLmRldGFjaFN1YmZsb3c7XG4gICAgICAgIGlmIChkZXRhY2gpIGRldGFjaCgpO1xuICAgICAgICBkZWxldGUgZmxvd3Nba2V5XTtcbiAgICAgICAgKytkZXRhY2hlZDtcbiAgICAgIH1cbiAgICB9IC8vIHJlbW92ZSBpbmFjdGl2ZSB0YXJnZXRzIGZyb20gdGhlIGFjdGl2ZSB0YXJnZXRzIGFycmF5XG5cblxuICAgIGlmIChkZXRhY2hlZCkge1xuICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5fdGFyZ2V0cy5maWx0ZXIoc2YgPT4gc2YgJiYgc2YuY291bnQgPiAwKTtcblxuICAgICAgdGhpcy5pbml0VGFyZ2V0cyhhY3RpdmUpO1xuICAgIH1cbiAgfSxcblxuICBpbml0VGFyZ2V0cyhhY3QpIHtcbiAgICBjb25zdCBhID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAgICBuID0gYS5sZW5ndGgsXG4gICAgICAgICAgbSA9IGFjdCA/IGFjdC5sZW5ndGggOiAwO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbTsgKytpKSB7XG4gICAgICBhW2ldID0gYWN0W2ldO1xuICAgIH1cblxuICAgIGZvciAoOyBpIDwgbiAmJiBhW2ldICE9IG51bGw7ICsraSkge1xuICAgICAgYVtpXSA9IG51bGw7IC8vIGVuc3VyZSBvbGQgZmxvd3MgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgfVxuXG4gICAgYS5hY3RpdmUgPSBtO1xuICB9LFxuXG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGRmID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICAgICAga2V5ID0gXy5rZXksXG4gICAgICAgICAgZmxvdyA9IF8uc3ViZmxvdyxcbiAgICAgICAgICBjYWNoZSA9IHRoaXMuX2tleXMsXG4gICAgICAgICAgcmVrZXkgPSBfLm1vZGlmaWVkKCdrZXknKSxcbiAgICAgICAgICBzdWJmbG93ID0ga2V5ID0+IHRoaXMuc3ViZmxvdyhrZXksIGZsb3csIHB1bHNlKTtcblxuICAgIHRoaXMuX2dyb3VwID0gXy5ncm91cCB8fCB7fTtcbiAgICB0aGlzLmluaXRUYXJnZXRzKCk7IC8vIHJlc2V0IGxpc3Qgb2YgYWN0aXZlIHN1YmZsb3dzXG5cbiAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpLFxuICAgICAgICAgICAgayA9IGNhY2hlLmdldChpZCk7XG5cbiAgICAgIGlmIChrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FjaGUuZGVsZXRlKGlkKTtcbiAgICAgICAgc3ViZmxvdyhrKS5yZW0odCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgIGNvbnN0IGsgPSBrZXkodCk7XG4gICAgICBjYWNoZS5zZXQodHVwbGVpZCh0KSwgayk7XG4gICAgICBzdWJmbG93KGspLmFkZCh0KTtcbiAgICB9KTtcblxuICAgIGlmIChyZWtleSB8fCBwdWxzZS5tb2RpZmllZChrZXkuZmllbGRzKSkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpLFxuICAgICAgICAgICAgICBrMCA9IGNhY2hlLmdldChpZCksXG4gICAgICAgICAgICAgIGsxID0ga2V5KHQpO1xuXG4gICAgICAgIGlmIChrMCA9PT0gazEpIHtcbiAgICAgICAgICBzdWJmbG93KGsxKS5tb2QodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGUuc2V0KGlkLCBrMSk7XG4gICAgICAgICAgc3ViZmxvdyhrMCkucmVtKHQpO1xuICAgICAgICAgIHN1YmZsb3coazEpLmFkZCh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwdWxzZS5jaGFuZ2VkKHB1bHNlLk1PRCkpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiB7XG4gICAgICAgIHN1YmZsb3coY2FjaGUuZ2V0KHR1cGxlaWQodCkpKS5tb2QodCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVrZXkpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFRkxPVywgdCA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gdHVwbGVpZCh0KSxcbiAgICAgICAgICAgICAgazAgPSBjYWNoZS5nZXQoaWQpLFxuICAgICAgICAgICAgICBrMSA9IGtleSh0KTtcblxuICAgICAgICBpZiAoazAgIT09IGsxKSB7XG4gICAgICAgICAgY2FjaGUuc2V0KGlkLCBrMSk7XG4gICAgICAgICAgc3ViZmxvdyhrMCkucmVtKHQpO1xuICAgICAgICAgIHN1YmZsb3coazEpLmFkZCh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLmNsZWFuKCkpIHtcbiAgICAgIGRmLnJ1bkFmdGVyKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhbigpO1xuICAgICAgICBjYWNoZS5jbGVhbigpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjYWNoZS5lbXB0eSA+IGRmLmNsZWFuVGhyZXNob2xkKSB7XG4gICAgICBkZi5ydW5BZnRlcihjYWNoZS5jbGVhbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bHNlO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBvbmUgb3IgbW9yZSBmaWVsZCBhY2Nlc3NvciBmdW5jdGlvbnMuXG4gKiBJZiB0aGUgJ25hbWUnIHBhcmFtZXRlciBpcyBhbiBhcnJheSwgYW4gYXJyYXkgb2YgZmllbGQgYWNjZXNzb3JzXG4gKiB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSAnYXMnIHBhcmFtZXRlciB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubmFtZSAtIFRoZSBmaWVsZCBuYW1lKHMpIHRvIGFjY2Vzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYXMgLSBUaGUgYWNjZXNzb3IgZnVuY3Rpb24gbmFtZS5cbiAqL1xuXG5mdW5jdGlvbiBGaWVsZChwYXJhbXMpIHtcbiAgT3BlcmF0b3IuY2FsbCh0aGlzLCBudWxsLCB1cGRhdGUkMywgcGFyYW1zKTtcbn1cbmluaGVyaXRzKEZpZWxkLCBPcGVyYXRvcik7XG5cbmZ1bmN0aW9uIHVwZGF0ZSQzKF8pIHtcbiAgcmV0dXJuIHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSA/IHRoaXMudmFsdWUgOiBpc0FycmF5KF8ubmFtZSkgPyBhcnJheShfLm5hbWUpLm1hcChmID0+IGZpZWxkKGYpKSA6IGZpZWxkKF8ubmFtZSwgXy5hcyk7XG59XG5cbi8qKlxuICogRmlsdGVycyBkYXRhIHR1cGxlcyBhY2NvcmRpbmcgdG8gYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmV4cHIgLSBUaGUgcHJlZGljYXRlIGV4cHJlc3Npb24gZnVuY3Rpb25cbiAqICAgdGhhdCBkZXRlcm1pbmVzIGEgdHVwbGUncyBmaWx0ZXIgc3RhdHVzLiBUcnV0aHkgdmFsdWVzIHBhc3MgdGhlIGZpbHRlci5cbiAqL1xuXG5mdW5jdGlvbiBGaWx0ZXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIGZhc3RtYXAoKSwgcGFyYW1zKTtcbn1cbkZpbHRlci5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdGaWx0ZXInLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2V4cHInLFxuICAgICd0eXBlJzogJ2V4cHInLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhGaWx0ZXIsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBkZiA9IHB1bHNlLmRhdGFmbG93LFxuICAgICAgICAgIGNhY2hlID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICAvLyBjYWNoZSBpZHMgb2YgZmlsdGVyZWQgdHVwbGVzXG4gICAgb3V0cHV0ID0gcHVsc2UuZm9yaygpLFxuICAgICAgICAgIGFkZCA9IG91dHB1dC5hZGQsXG4gICAgICAgICAgcmVtID0gb3V0cHV0LnJlbSxcbiAgICAgICAgICBtb2QgPSBvdXRwdXQubW9kLFxuICAgICAgICAgIHRlc3QgPSBfLmV4cHI7XG4gICAgbGV0IGlzTW9kID0gdHJ1ZTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpO1xuICAgICAgaWYgKCFjYWNoZS5oYXMoaWQpKSByZW0ucHVzaCh0KTtlbHNlIGNhY2hlLmRlbGV0ZShpZCk7XG4gICAgfSk7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgIGlmICh0ZXN0KHQsIF8pKSBhZGQucHVzaCh0KTtlbHNlIGNhY2hlLnNldCh0dXBsZWlkKHQpLCAxKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJldmlzaXQodCkge1xuICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpLFxuICAgICAgICAgICAgYiA9IHRlc3QodCwgXyksXG4gICAgICAgICAgICBzID0gY2FjaGUuZ2V0KGlkKTtcblxuICAgICAgaWYgKGIgJiYgcykge1xuICAgICAgICBjYWNoZS5kZWxldGUoaWQpO1xuICAgICAgICBhZGQucHVzaCh0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWIgJiYgIXMpIHtcbiAgICAgICAgY2FjaGUuc2V0KGlkLCAxKTtcbiAgICAgICAgcmVtLnB1c2godCk7XG4gICAgICB9IGVsc2UgaWYgKGlzTW9kICYmIGIgJiYgIXMpIHtcbiAgICAgICAgbW9kLnB1c2godCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCByZXZpc2l0KTtcblxuICAgIGlmIChfLm1vZGlmaWVkKCkpIHtcbiAgICAgIGlzTW9kID0gZmFsc2U7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRUZMT1csIHJldmlzaXQpO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5lbXB0eSA+IGRmLmNsZWFuVGhyZXNob2xkKSBkZi5ydW5BZnRlcihjYWNoZS5jbGVhbik7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBGbGF0dGVucyBhcnJheS10eXBlZCBmaWVsZCB2YWx1ZXMgaW50byBuZXcgZGF0YSBvYmplY3RzLlxuICogSWYgbXVsdGlwbGUgZmllbGRzIGFyZSBzcGVjaWZpZWQsIHRoZXkgYXJlIHRyZWF0ZWQgYXMgcGFyYWxsZWwgYXJyYXlzLFxuICogd2l0aCBvdXRwdXQgdmFsdWVzIGluY2x1ZGVkIGZvciBlYWNoIG1hdGNoaW5nIGluZGV4IChvciBudWxsIGlmIG1pc3NpbmcpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBwYXJhbXMuZmllbGRzIC0gQW4gYXJyYXkgb2YgZmllbGRcbiAqICAgYWNjZXNzb3JzIGZvciB0aGUgdHVwbGUgZmllbGRzIHRoYXQgc2hvdWxkIGJlIGZsYXR0ZW5lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmluZGV4XSAtIE9wdGlvbmFsIG91dHB1dCBmaWVsZCBuYW1lIGZvciBpbmRleFxuICogICB2YWx1ZS4gSWYgdW5zcGVjaWZpZWQsIG5vIGluZGV4IGZpZWxkIGlzIGluY2x1ZGVkIGluIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gT3V0cHV0IGZpZWxkIG5hbWVzIGZvciBmbGF0dGVuZWRcbiAqICAgYXJyYXkgZmllbGRzLiBBbnkgdW5zcGVjaWZpZWQgZmllbGRzIHdpbGwgdXNlIHRoZSBmaWVsZCBuYW1lIHByb3ZpZGVkXG4gKiAgIGJ5IHRoZSBmaWVsZHMgYWNjZXNzb3JzLlxuICovXG5cbmZ1bmN0aW9uIEZsYXR0ZW4ocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuRmxhdHRlbi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdGbGF0dGVuJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaW5kZXgnLFxuICAgICd0eXBlJzogJ3N0cmluZydcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhGbGF0dGVuLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpLFxuICAgICAgICAgIGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgICAgIGFzID0gZmllbGROYW1lcyhmaWVsZHMsIF8uYXMgfHwgW10pLFxuICAgICAgICAgIGluZGV4ID0gXy5pbmRleCB8fCBudWxsLFxuICAgICAgICAgIG0gPSBhcy5sZW5ndGg7IC8vIHJlbW92ZSBhbnkgcHJldmlvdXMgcmVzdWx0c1xuXG4gICAgb3V0LnJlbSA9IHRoaXMudmFsdWU7IC8vIGdlbmVyYXRlIGZsYXR0ZW5lZCB0dXBsZXNcblxuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiB7XG4gICAgICBjb25zdCBhcnJheXMgPSBmaWVsZHMubWFwKGYgPT4gZih0KSksXG4gICAgICAgICAgICBtYXhsZW4gPSBhcnJheXMucmVkdWNlKChsLCBhKSA9PiBNYXRoLm1heChsLCBhLmxlbmd0aCksIDApO1xuICAgICAgbGV0IGkgPSAwLFxuICAgICAgICAgIGosXG4gICAgICAgICAgZCxcbiAgICAgICAgICB2O1xuXG4gICAgICBmb3IgKDsgaSA8IG1heGxlbjsgKytpKSB7XG4gICAgICAgIGQgPSBkZXJpdmUodCk7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICAgIGRbYXNbal1dID0gKHYgPSBhcnJheXNbal1baV0pID09IG51bGwgPyBudWxsIDogdjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgIGRbaW5kZXhdID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5hZGQucHVzaChkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IG91dC5hZGQ7XG4gICAgaWYgKGluZGV4KSBvdXQubW9kaWZpZXMoaW5kZXgpO1xuICAgIHJldHVybiBvdXQubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEZvbGRzIG9uZSBtb3JlIHR1cGxlIGZpZWxkcyBpbnRvIG11bHRpcGxlIHR1cGxlcyBpbiB3aGljaCB0aGUgZmllbGRcbiAqIG5hbWUgYW5kIHZhbHVlcyBhcmUgYXZhaWxhYmxlIHVuZGVyIG5ldyAna2V5JyBhbmQgJ3ZhbHVlJyBmaWVsZHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkcyAtIEFuIGFycmF5IG9mIGZpZWxkIGFjY2Vzc29yc1xuICogICBmb3IgdGhlIHR1cGxlIGZpZWxkcyB0aGF0IHNob3VsZCBiZSBmb2xkZWQuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gT3V0cHV0IGZpZWxkIG5hbWVzIGZvciBmb2xkZWQga2V5XG4gKiAgIGFuZCB2YWx1ZSBmaWVsZHMsIGRlZmF1bHRzIHRvIFsna2V5JywgJ3ZhbHVlJ10uXG4gKi9cblxuZnVuY3Rpb24gRm9sZChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG59XG5Gb2xkLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0ZvbGQnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWydrZXknLCAndmFsdWUnXVxuICB9XVxufTtcbmluaGVyaXRzKEZvbGQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksXG4gICAgICAgICAgZmllbGRzID0gXy5maWVsZHMsXG4gICAgICAgICAgZm5hbWVzID0gZmllbGRzLm1hcChhY2Nlc3Nvck5hbWUpLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgICAgIGsgPSBhc1swXSxcbiAgICAgICAgICB2ID0gYXNbMV0sXG4gICAgICAgICAgbiA9IGZpZWxkcy5sZW5ndGg7XG4gICAgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBkOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGQgPSBkZXJpdmUodCk7XG4gICAgICAgIGRba10gPSBmbmFtZXNbaV07XG4gICAgICAgIGRbdl0gPSBmaWVsZHNbaV0odCk7XG4gICAgICAgIG91dC5hZGQucHVzaChkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IG91dC5hZGQ7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogSW52b2tlcyBhIGZ1bmN0aW9uIGZvciBlYWNoIGRhdGEgdHVwbGUgYW5kIHNhdmVzIHRoZSByZXN1bHRzIGFzIGEgbmV3IGZpZWxkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5leHByIC0gVGhlIGZvcm11bGEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIHR1cGxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hcyAtIFRoZSBmaWVsZCBuYW1lIHVuZGVyIHdoaWNoIHRvIHNhdmUgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5pbml0b25seT1mYWxzZV0gLSBJZiB0cnVlLCB0aGUgZm9ybXVsYSBpcyBhcHBsaWVkIHRvXG4gKiAgIGFkZGVkIHR1cGxlcyBvbmx5LCBhbmQgZG9lcyBub3QgdXBkYXRlIGluIHJlc3BvbnNlIHRvIG1vZGlmaWNhdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gRm9ybXVsYShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkZvcm11bGEuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnRm9ybXVsYScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2V4cHInLFxuICAgICd0eXBlJzogJ2V4cHInLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2luaXRvbmx5JyxcbiAgICAndHlwZSc6ICdib29sZWFuJ1xuICB9XVxufTtcbmluaGVyaXRzKEZvcm11bGEsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBmdW5jID0gXy5leHByLFxuICAgICAgICAgIGFzID0gXy5hcyxcbiAgICAgICAgICBtb2QgPSBfLm1vZGlmaWVkKCksXG4gICAgICAgICAgZmxhZyA9IF8uaW5pdG9ubHkgPyBwdWxzZS5BREQgOiBtb2QgPyBwdWxzZS5TT1VSQ0UgOiBwdWxzZS5tb2RpZmllZChmdW5jLmZpZWxkcykgfHwgcHVsc2UubW9kaWZpZWQoYXMpID8gcHVsc2UuQUREX01PRCA6IHB1bHNlLkFERDtcblxuICAgIGlmIChtb2QpIHtcbiAgICAgIC8vIHBhcmFtZXRlcnMgdXBkYXRlZCwgbmVlZCB0byByZWZsb3dcbiAgICAgIHB1bHNlID0gcHVsc2UubWF0ZXJpYWxpemUoKS5yZWZsb3codHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmluaXRvbmx5KSB7XG4gICAgICBwdWxzZS5tb2RpZmllcyhhcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bHNlLnZpc2l0KGZsYWcsIHQgPT4gdFthc10gPSBmdW5jKHQsIF8pKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgZGF0YSB0dXBsZXMgdXNpbmcgYSBwcm92aWRlZCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUGFyYW1ldGVycyk6IG9iamVjdH0gcGFyYW1zLmdlbmVyYXRvciAtIEEgdHVwbGUgZ2VuZXJhdG9yXG4gKiAgIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIGlzIGdpdmVuIHRoZSBvcGVyYXRvciBwYXJhbWV0ZXJzIGFzIGlucHV0LlxuICogICBDaGFuZ2VzIHRvIGFueSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgd2lsbCBub3QgdHJpZ2dlciByZS1jYWxjdWxhdGlvblxuICogICBvZiBwcmV2aW91c2x5IGdlbmVyYXRlZCB0dXBsZXMuIE9ubHkgZnV0dXJlIHR1cGxlcyBhcmUgYWZmZWN0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnNpemUgLSBUaGUgbnVtYmVyIG9mIHR1cGxlcyB0byBwcm9kdWNlLlxuICovXG5cbmZ1bmN0aW9uIEdlbmVyYXRlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKEdlbmVyYXRlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLFxuICAgICAgICAgIGdlbiA9IF8uZ2VuZXJhdG9yO1xuICAgIGxldCBkYXRhID0gdGhpcy52YWx1ZSxcbiAgICAgICAgbnVtID0gXy5zaXplIC0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGFkZCxcbiAgICAgICAgcmVtLFxuICAgICAgICB0O1xuXG4gICAgaWYgKG51bSA+IDApIHtcbiAgICAgIC8vIG5lZWQgbW9yZSB0dXBsZXMsIGdlbmVyYXRlIGFuZCBhZGRcbiAgICAgIGZvciAoYWRkID0gW107IC0tbnVtID49IDA7KSB7XG4gICAgICAgIGFkZC5wdXNoKHQgPSBpbmdlc3QoZ2VuKF8pKSk7XG4gICAgICAgIGRhdGEucHVzaCh0KTtcbiAgICAgIH1cblxuICAgICAgb3V0LmFkZCA9IG91dC5hZGQubGVuZ3RoID8gb3V0Lm1hdGVyaWFsaXplKG91dC5BREQpLmFkZC5jb25jYXQoYWRkKSA6IGFkZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmVlZCBmZXdlciB0dXBsZXMsIHJlbW92ZVxuICAgICAgcmVtID0gZGF0YS5zbGljZSgwLCAtbnVtKTtcbiAgICAgIG91dC5yZW0gPSBvdXQucmVtLmxlbmd0aCA/IG91dC5tYXRlcmlhbGl6ZShvdXQuUkVNKS5yZW0uY29uY2F0KHJlbSkgOiByZW07XG4gICAgICBkYXRhID0gZGF0YS5zbGljZSgtbnVtKTtcbiAgICB9XG5cbiAgICBvdXQuc291cmNlID0gdGhpcy52YWx1ZSA9IGRhdGE7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuY29uc3QgTWV0aG9kcyA9IHtcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIG1lZGlhbjogbWVkaWFuLFxuICBtZWFuOiBtZWFuLFxuICBtaW46IG1pbixcbiAgbWF4OiBtYXhcbn07XG5jb25zdCBFbXB0eSA9IFtdO1xuLyoqXG4gKiBJbXB1dGUgbWlzc2luZyB2YWx1ZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIGltcHV0ZS5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZlxuICogICBhY2Nlc3NvcnMgdG8gZGV0ZXJtaW5lIHNlcmllcyB3aXRoaW4gd2hpY2ggdG8gcGVyZm9ybSBpbXB1dGF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMua2V5IC0gQW4gYWNjZXNzb3IgZm9yIGEga2V5IHZhbHVlLlxuICogICBFYWNoIGtleSB2YWx1ZSBzaG91bGQgYmUgdW5pcXVlIHdpdGhpbiBhIGdyb3VwLiBOZXcgdHVwbGVzIHdpbGwgYmVcbiAqICAgaW1wdXRlZCBmb3IgYW55IGtleSB2YWx1ZXMgdGhhdCBhcmUgbm90IGZvdW5kIHdpdGhpbiBhIGdyb3VwLlxuICogQHBhcmFtIHtBcnJheTwqPn0gW3BhcmFtcy5rZXl2YWxzXSAtIE9wdGlvbmFsIGFycmF5IG9mIHJlcXVpcmVkIGtleVxuICogICB2YWx1ZXMuIE5ldyB0dXBsZXMgd2lsbCBiZSBpbXB1dGVkIGZvciBhbnkga2V5IHZhbHVlcyB0aGF0IGFyZSBub3RcbiAqICAgZm91bmQgd2l0aGluIGEgZ3JvdXAuIEluIGFkZGl0aW9uLCB0aGVzZSB2YWx1ZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5XG4gKiAgIGF1Z21lbnRlZCB3aXRoIHRoZSBrZXkgdmFsdWVzIG9ic2VydmVkIGluIHRoZSBpbnB1dCBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2Q9J3ZhbHVlJ10gLSBUaGUgaW1wdXRhdGlvbiBtZXRob2QgdG8gdXNlLiBPbmUgb2ZcbiAqICAgJ3ZhbHVlJywgJ21lYW4nLCAnbWVkaWFuJywgJ21heCcsICdtaW4nLlxuICogQHBhcmFtIHsqfSBbdmFsdWU9MF0gLSBUaGUgY29uc3RhbnQgdmFsdWUgdG8gdXNlIGZvciBpbXB1dGF0aW9uXG4gKiAgIHdoZW4gdXNpbmcgbWV0aG9kICd2YWx1ZScuXG4gKi9cblxuZnVuY3Rpb24gSW1wdXRlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbn1cbkltcHV0ZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdJbXB1dGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAna2V5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAna2V5dmFscycsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ21ldGhvZCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAndmFsdWUnLFxuICAgICd2YWx1ZXMnOiBbJ3ZhbHVlJywgJ21lYW4nLCAnbWVkaWFuJywgJ21heCcsICdtaW4nXVxuICB9LCB7XG4gICAgJ25hbWUnOiAndmFsdWUnLFxuICAgICdkZWZhdWx0JzogMFxuICB9XVxufTtcblxuZnVuY3Rpb24gZ2V0VmFsdWUoXykge1xuICB2YXIgbSA9IF8ubWV0aG9kIHx8IE1ldGhvZHMudmFsdWUsXG4gICAgICB2O1xuXG4gIGlmIChNZXRob2RzW21dID09IG51bGwpIHtcbiAgICBlcnJvcignVW5yZWNvZ25pemVkIGltcHV0YXRpb24gbWV0aG9kOiAnICsgbSk7XG4gIH0gZWxzZSBpZiAobSA9PT0gTWV0aG9kcy52YWx1ZSkge1xuICAgIHYgPSBfLnZhbHVlICE9PSB1bmRlZmluZWQgPyBfLnZhbHVlIDogMDtcbiAgICByZXR1cm4gKCkgPT4gdjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWV0aG9kc1ttXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaWVsZChfKSB7XG4gIGNvbnN0IGYgPSBfLmZpZWxkO1xuICByZXR1cm4gdCA9PiB0ID8gZih0KSA6IE5hTjtcbn1cblxuaW5oZXJpdHMoSW1wdXRlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUxMKSxcbiAgICAgICAgaW1wdXRlID0gZ2V0VmFsdWUoXyksXG4gICAgICAgIGZpZWxkID0gZ2V0RmllbGQoXyksXG4gICAgICAgIGZOYW1lID0gYWNjZXNzb3JOYW1lKF8uZmllbGQpLFxuICAgICAgICBrTmFtZSA9IGFjY2Vzc29yTmFtZShfLmtleSksXG4gICAgICAgIGdOYW1lcyA9IChfLmdyb3VwYnkgfHwgW10pLm1hcChhY2Nlc3Nvck5hbWUpLFxuICAgICAgICBncm91cHMgPSBwYXJ0aXRpb24ocHVsc2Uuc291cmNlLCBfLmdyb3VwYnksIF8ua2V5LCBfLmtleXZhbHMpLFxuICAgICAgICBjdXJyID0gW10sXG4gICAgICAgIHByZXYgPSB0aGlzLnZhbHVlLFxuICAgICAgICBtID0gZ3JvdXBzLmRvbWFpbi5sZW5ndGgsXG4gICAgICAgIGdyb3VwLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZ1ZhbHMsXG4gICAgICAgIGtWYWwsXG4gICAgICAgIGcsXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIGwsXG4gICAgICAgIG4sXG4gICAgICAgIHQ7XG5cbiAgICBmb3IgKGcgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgZyA8IGw7ICsrZykge1xuICAgICAgZ3JvdXAgPSBncm91cHNbZ107XG4gICAgICBnVmFscyA9IGdyb3VwLnZhbHVlcztcbiAgICAgIHZhbHVlID0gTmFOOyAvLyBhZGQgdHVwbGVzIGZvciBtaXNzaW5nIHZhbHVlc1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGlmIChncm91cFtqXSAhPSBudWxsKSBjb250aW51ZTtcbiAgICAgICAga1ZhbCA9IGdyb3Vwcy5kb21haW5bal07XG4gICAgICAgIHQgPSB7XG4gICAgICAgICAgX2ltcHV0ZTogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSBnVmFscy5sZW5ndGg7IGkgPCBuOyArK2kpIHRbZ05hbWVzW2ldXSA9IGdWYWxzW2ldO1xuXG4gICAgICAgIHRba05hbWVdID0ga1ZhbDtcbiAgICAgICAgdFtmTmFtZV0gPSBOdW1iZXIuaXNOYU4odmFsdWUpID8gdmFsdWUgPSBpbXB1dGUoZ3JvdXAsIGZpZWxkKSA6IHZhbHVlO1xuICAgICAgICBjdXJyLnB1c2goaW5nZXN0KHQpKTtcbiAgICAgIH1cbiAgICB9IC8vIHVwZGF0ZSBwdWxzZSB3aXRoIGltcHV0ZWQgdHVwbGVzXG5cblxuICAgIGlmIChjdXJyLmxlbmd0aCkgb3V0LmFkZCA9IG91dC5tYXRlcmlhbGl6ZShvdXQuQUREKS5hZGQuY29uY2F0KGN1cnIpO1xuICAgIGlmIChwcmV2Lmxlbmd0aCkgb3V0LnJlbSA9IG91dC5tYXRlcmlhbGl6ZShvdXQuUkVNKS5yZW0uY29uY2F0KHByZXYpO1xuICAgIHRoaXMudmFsdWUgPSBjdXJyO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihkYXRhLCBncm91cGJ5LCBrZXksIGtleXZhbHMpIHtcbiAgdmFyIGdldCA9IGYgPT4gZih0KSxcbiAgICAgIGdyb3VwcyA9IFtdLFxuICAgICAgZG9tYWluID0ga2V5dmFscyA/IGtleXZhbHMuc2xpY2UoKSA6IFtdLFxuICAgICAga01hcCA9IHt9LFxuICAgICAgZ01hcCA9IHt9LFxuICAgICAgZ1ZhbHMsXG4gICAgICBnS2V5LFxuICAgICAgZ3JvdXAsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIGssXG4gICAgICBuLFxuICAgICAgdDtcblxuICBkb21haW4uZm9yRWFjaCgoaywgaSkgPT4ga01hcFtrXSA9IGkgKyAxKTtcblxuICBmb3IgKGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB0ID0gZGF0YVtpXTtcbiAgICBrID0ga2V5KHQpO1xuICAgIGogPSBrTWFwW2tdIHx8IChrTWFwW2tdID0gZG9tYWluLnB1c2goaykpO1xuICAgIGdLZXkgPSAoZ1ZhbHMgPSBncm91cGJ5ID8gZ3JvdXBieS5tYXAoZ2V0KSA6IEVtcHR5KSArICcnO1xuXG4gICAgaWYgKCEoZ3JvdXAgPSBnTWFwW2dLZXldKSkge1xuICAgICAgZ3JvdXAgPSBnTWFwW2dLZXldID0gW107XG4gICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICBncm91cC52YWx1ZXMgPSBnVmFscztcbiAgICB9XG5cbiAgICBncm91cFtqIC0gMV0gPSB0O1xuICB9XG5cbiAgZ3JvdXBzLmRvbWFpbiA9IGRvbWFpbjtcbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxuLyoqXG4gKiBFeHRlbmQgaW5wdXQgdHVwbGVzIHdpdGggYWdncmVnYXRlIHZhbHVlcy5cbiAqIENhbGN1YXRlcyBhZ2dyZWdhdGUgdmFsdWVzIGFuZCBqb2lucyB0aGVtIHdpdGggdGhlIGlucHV0IHN0cmVhbS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIEpvaW5BZ2dyZWdhdGUocGFyYW1zKSB7XG4gIEFnZ3JlZ2F0ZS5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5Kb2luQWdncmVnYXRlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0pvaW5BZ2dyZWdhdGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ29wcycsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAndmFsdWVzJzogVmFsaWRBZ2dyZWdhdGVPcHNcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdrZXknLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9XVxufTtcbmluaGVyaXRzKEpvaW5BZ2dyZWdhdGUsIEFnZ3JlZ2F0ZSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBhZ2dyID0gdGhpcyxcbiAgICAgICAgICBtb2QgPSBfLm1vZGlmaWVkKCk7XG5cbiAgICBsZXQgY2VsbHM7IC8vIHByb2Nlc3MgYWxsIGlucHV0IHR1cGxlcyB0byBjYWxjdWxhdGUgYWdncmVnYXRlc1xuXG4gICAgaWYgKGFnZ3IudmFsdWUgJiYgKG1vZCB8fCBwdWxzZS5tb2RpZmllZChhZ2dyLl9pbnB1dHMsIHRydWUpKSkge1xuICAgICAgY2VsbHMgPSBhZ2dyLnZhbHVlID0gbW9kID8gYWdnci5pbml0KF8pIDoge307XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4gYWdnci5hZGQodCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxscyA9IGFnZ3IudmFsdWUgPSBhZ2dyLnZhbHVlIHx8IHRoaXMuaW5pdChfKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiBhZ2dyLnJlbSh0KSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gYWdnci5hZGQodCkpO1xuICAgIH0gLy8gdXBkYXRlIGFnZ3JlZ2F0aW9uIGNlbGxzXG5cblxuICAgIGFnZ3IuY2hhbmdlcygpOyAvLyB3cml0ZSBhZ2dyZWdhdGUgdmFsdWVzIHRvIGlucHV0IHR1cGxlc1xuXG4gICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IHtcbiAgICAgIGV4dGVuZCh0LCBjZWxsc1thZ2dyLmNlbGxrZXkodCldLnR1cGxlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KG1vZCkubW9kaWZpZXModGhpcy5fb3V0cHV0cyk7XG4gIH0sXG5cbiAgY2hhbmdlcygpIHtcbiAgICBjb25zdCBhZGRzID0gdGhpcy5fYWRkcyxcbiAgICAgICAgICBtb2RzID0gdGhpcy5fbW9kcztcbiAgICBsZXQgaSwgbjtcblxuICAgIGZvciAoaSA9IDAsIG4gPSB0aGlzLl9hbGVuOyBpIDwgbjsgKytpKSB7XG4gICAgICB0aGlzLmNlbGx0dXBsZShhZGRzW2ldKTtcbiAgICAgIGFkZHNbaV0gPSBudWxsOyAvLyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbiA9IHRoaXMuX21sZW47IGkgPCBuOyArK2kpIHtcbiAgICAgIHRoaXMuY2VsbHR1cGxlKG1vZHNbaV0pO1xuICAgICAgbW9kc1tpXSA9IG51bGw7IC8vIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICB9XG5cbiAgICB0aGlzLl9hbGVuID0gdGhpcy5fbWxlbiA9IDA7IC8vIHJlc2V0IGxpc3Qgb2YgYWN0aXZlIGNlbGxzXG4gIH1cblxufSk7XG5cbi8qKlxuICogQ29tcHV0ZSBrZXJuZWwgZGVuc2l0eSBlc3RpbWF0ZXMgKEtERSkgZm9yIG9uZSBvciBtb3JlIGRhdGEgZ3JvdXBzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzXG4gKiAgIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIEFuIGFjY2Vzc29yIGZvciB0aGUgZGF0YSBmaWVsZFxuICogICB0byBlc3RpbWF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmJhbmR3aWR0aD0wXSAtIFRoZSBLREUga2VybmVsIGJhbmR3aWR0aC5cbiAqICAgSWYgemVybyBvciB1bnNwZWNpZmllZCwgdGhlIGJhbmR3aWR0aCBpcyBhdXRvbWF0aWNhbGx5IGRldGVybWluZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuY291bnRzPWZhbHNlXSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlXG4gKiAgIG91dHB1dCB2YWx1ZXMgc2hvdWxkIGJlIHByb2JhYmlsaXR5IGVzdGltYXRlcyAoZmFsc2UsIGRlZmF1bHQpIG9yXG4gKiAgIHNtb290aGVkIGNvdW50cyAodHJ1ZSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5jdW11bGF0aXZlPWZhbHNlXSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgYVxuICogICBkZW5zaXR5IChmYWxzZSkgb3IgY3VtdWxhdGl2ZSBkaXN0cmlidXRpb24gKHRydWUpIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMuZXh0ZW50XSAtIFRoZSBkb21haW4gZXh0ZW50IG92ZXIgd2hpY2ggdG9cbiAqICAgcGxvdCB0aGUgZGVuc2l0eS4gSWYgdW5zcGVjaWZpZWQsIHRoZSBbbWluLCBtYXhdIGRhdGEgZXh0ZW50IGlzIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5yZXNvbHZlPSdpbmRlcGVuZGVudCddIC0gSW5kaWNhdGVzIGhvdyBwYXJhbWV0ZXJzIGZvclxuICogICBtdWx0aXBsZSBkZW5zaXRpZXMgc2hvdWxkIGJlIHJlc29sdmVkLiBJZiBcImluZGVwZW5kZW50XCIgKHRoZSBkZWZhdWx0KSwgZWFjaFxuICogICBkZW5zaXR5IG1heSBoYXZlIGl0cyBvd24gZG9tYWluIGV4dGVudCBhbmQgZHluYW1pYyBudW1iZXIgb2YgY3VydmUgc2FtcGxlXG4gKiAgIHN0ZXBzLiBJZiBcInNoYXJlZFwiLCB0aGUgS0RFIHRyYW5zZm9ybSB3aWxsIGVuc3VyZSB0aGF0IGFsbCBkZW5zaXRpZXMgYXJlXG4gKiAgIGRlZmluZWQgb3ZlciBhIHNoYXJlZCBkb21haW4gYW5kIGN1cnZlIHN0ZXBzLCBlbmFibGluZyBzdGFja2luZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLm1pbnN0ZXBzPTI1XSAtIFRoZSBtaW5pbXVtIG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVzXG4gKiAgIGZvciBwbG90dGluZyB0aGUgZGVuc2l0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLm1heHN0ZXBzPTIwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgY3VydmUgc2FtcGxlc1xuICogICBmb3IgcGxvdHRpbmcgdGhlIGRlbnNpdHkuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5zdGVwc10gLSBUaGUgZXhhY3QgbnVtYmVyIG9mIGN1cnZlIHNhbXBsZXMgZm9yXG4gKiAgIHBsb3R0aW5nIHRoZSBkZW5zaXR5LiBJZiBzcGVjaWZpZWQsIG92ZXJyaWRlcyBib3RoIG1pbnN0ZXBzIGFuZCBtYXhzdGVwc1xuICogICB0byBzZXQgYW4gZXhhY3QgbnVtYmVyIG9mIHVuaWZvcm0gc2FtcGxlcy4gVXNlZnVsIGluIGNvbmp1bmN0aW9uIHdpdGhcbiAqICAgYSBmaXhlZCBleHRlbnQgdG8gZW5zdXJlIGNvbnNpc3RlbnQgc2FtcGxlIHBvaW50cyBmb3Igc3RhY2tlZCBkZW5zaXRpZXMuXG4gKi9cblxuZnVuY3Rpb24gS0RFKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuS0RFLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0tERScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdjdW11bGF0aXZlJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IGZhbHNlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdjb3VudHMnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2JhbmR3aWR0aCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyZXNvbHZlJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAndmFsdWVzJzogWydzaGFyZWQnLCAnaW5kZXBlbmRlbnQnXSxcbiAgICAnZGVmYXVsdCc6ICdpbmRlcGVuZGVudCdcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtaW5zdGVwcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDI1XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtYXhzdGVwcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDIwMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6IFsndmFsdWUnLCAnZGVuc2l0eSddXG4gIH1dXG59O1xuaW5oZXJpdHMoS0RFLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpO1xuXG4gICAgaWYgKCF0aGlzLnZhbHVlIHx8IHB1bHNlLmNoYW5nZWQoKSB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICAgICAgZ3JvdXBzID0gcGFydGl0aW9uJDEoc291cmNlLCBfLmdyb3VwYnksIF8uZmllbGQpLFxuICAgICAgICAgICAgbmFtZXMgPSAoXy5ncm91cGJ5IHx8IFtdKS5tYXAoYWNjZXNzb3JOYW1lKSxcbiAgICAgICAgICAgIGJhbmR3aWR0aCA9IF8uYmFuZHdpZHRoLFxuICAgICAgICAgICAgbWV0aG9kID0gXy5jdW11bGF0aXZlID8gJ2NkZicgOiAncGRmJyxcbiAgICAgICAgICAgIGFzID0gXy5hcyB8fCBbJ3ZhbHVlJywgJ2RlbnNpdHknXSxcbiAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgbGV0IGRvbWFpbiA9IF8uZXh0ZW50LFxuICAgICAgICAgIG1pbnN0ZXBzID0gXy5zdGVwcyB8fCBfLm1pbnN0ZXBzIHx8IDI1LFxuICAgICAgICAgIG1heHN0ZXBzID0gXy5zdGVwcyB8fCBfLm1heHN0ZXBzIHx8IDIwMDtcblxuICAgICAgaWYgKG1ldGhvZCAhPT0gJ3BkZicgJiYgbWV0aG9kICE9PSAnY2RmJykge1xuICAgICAgICBlcnJvcignSW52YWxpZCBkZW5zaXR5IG1ldGhvZDogJyArIG1ldGhvZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLnJlc29sdmUgPT09ICdzaGFyZWQnKSB7XG4gICAgICAgIGlmICghZG9tYWluKSBkb21haW4gPSBleHRlbnQoc291cmNlLCBfLmZpZWxkKTtcbiAgICAgICAgbWluc3RlcHMgPSBtYXhzdGVwcyA9IF8uc3RlcHMgfHwgbWF4c3RlcHM7XG4gICAgICB9XG5cbiAgICAgIGdyb3Vwcy5mb3JFYWNoKGcgPT4ge1xuICAgICAgICBjb25zdCBkZW5zaXR5ID0gcmFuZG9tS0RFKGcsIGJhbmR3aWR0aClbbWV0aG9kXSxcbiAgICAgICAgICAgICAgc2NhbGUgPSBfLmNvdW50cyA/IGcubGVuZ3RoIDogMSxcbiAgICAgICAgICAgICAgbG9jYWwgPSBkb21haW4gfHwgZXh0ZW50KGcpO1xuICAgICAgICBzYW1wbGVDdXJ2ZShkZW5zaXR5LCBsb2NhbCwgbWluc3RlcHMsIG1heHN0ZXBzKS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgIGNvbnN0IHQgPSB7fTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRbbmFtZXNbaV1dID0gZy5kaW1zW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRbYXNbMF1dID0gdlswXTtcbiAgICAgICAgICB0W2FzWzFdXSA9IHZbMV0gKiBzY2FsZTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChpbmdlc3QodCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IG91dC5hZGQgPSBvdXQuc291cmNlID0gdmFsdWVzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEga2V5IGZ1bmN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHBhcmFtcy5maWVsZHMgLSBUaGUgZmllbGQgbmFtZShzKSBmb3IgdGhlIGtleSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmZsYXQgLSBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBmaWVsZCBuYW1lc1xuICogIHNob3VsZCBiZSB0cmVhdGVkIGFzIGZsYXQgcHJvcGVydHkgbmFtZXMsIHNpZGUtc3RlcHBpbmcgbmVzdGVkIGZpZWxkXG4gKiAgbG9va3VwcyBub3JtYWxseSBpbmRpY2F0ZWQgYnkgZG90IG9yIGJyYWNrZXQgbm90YXRpb24uXG4gKi9cblxuZnVuY3Rpb24gS2V5KHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIG51bGwsIHVwZGF0ZSQyLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoS2V5LCBPcGVyYXRvcik7XG5cbmZ1bmN0aW9uIHVwZGF0ZSQyKF8pIHtcbiAgcmV0dXJuIHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSA/IHRoaXMudmFsdWUgOiBrZXkoXy5maWVsZHMsIF8uZmxhdCk7XG59XG5cbi8qKlxuICogTG9hZCBhbmQgcGFyc2UgZGF0YSBmcm9tIGFuIGV4dGVybmFsIHNvdXJjZS4gTWFyc2hhbGxzIHBhcmFtZXRlclxuICogdmFsdWVzIGFuZCB0aGVuIGludm9rZXMgdGhlIERhdGFmbG93IHJlcXVlc3QgbWV0aG9kLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnVybCAtIFRoZSBVUkwgdG8gbG9hZCBmcm9tLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5mb3JtYXQgLSBUaGUgZGF0YSBmb3JtYXQgb3B0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBMb2FkKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbiAgdGhpcy5fcGVuZGluZyA9IG51bGw7XG59XG5pbmhlcml0cyhMb2FkLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZGYgPSBwdWxzZS5kYXRhZmxvdztcblxuICAgIGlmICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAvLyB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiBwdWxzZVxuICAgICAgcmV0dXJuIG91dHB1dCh0aGlzLCBwdWxzZSwgdGhpcy5fcGVuZGluZyk7XG4gICAgfVxuXG4gICAgaWYgKHN0b3AoXykpIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG5cbiAgICBpZiAoXy52YWx1ZXMpIHtcbiAgICAgIC8vIHBhcnNlIGFuZCBpbmdlc3QgdmFsdWVzLCByZXR1cm4gb3V0cHV0IHB1bHNlXG4gICAgICByZXR1cm4gb3V0cHV0KHRoaXMsIHB1bHNlLCBkZi5wYXJzZShfLnZhbHVlcywgXy5mb3JtYXQpKTtcbiAgICB9IGVsc2UgaWYgKF8uYXN5bmMpIHtcbiAgICAgIC8vIHJldHVybiBwcm9taXNlIGZvciBub24tYmxvY2tpbmcgYXN5bmMgbG9hZGluZ1xuICAgICAgY29uc3QgcCA9IGRmLnJlcXVlc3QoXy51cmwsIF8uZm9ybWF0KS50aGVuKHJlcyA9PiB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmcgPSBhcnJheShyZXMuZGF0YSk7XG4gICAgICAgIHJldHVybiBkZiA9PiBkZi50b3VjaCh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmM6IHBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBwcm9taXNlIGZvciBzeW5jaHJvbm91cyBsb2FkaW5nXG4gICAgICByZXR1cm4gZGYucmVxdWVzdChfLnVybCwgXy5mb3JtYXQpLnRoZW4ocmVzID0+IG91dHB1dCh0aGlzLCBwdWxzZSwgYXJyYXkocmVzLmRhdGEpKSk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzdG9wKF8pIHtcbiAgcmV0dXJuIF8ubW9kaWZpZWQoJ2FzeW5jJykgJiYgIShfLm1vZGlmaWVkKCd2YWx1ZXMnKSB8fCBfLm1vZGlmaWVkKCd1cmwnKSB8fCBfLm1vZGlmaWVkKCdmb3JtYXQnKSk7XG59XG5cbmZ1bmN0aW9uIG91dHB1dChvcCwgcHVsc2UsIGRhdGEpIHtcbiAgZGF0YS5mb3JFYWNoKGluZ2VzdCk7XG4gIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fRklFTERTICYgcHVsc2UuTk9fU09VUkNFKTtcbiAgb3V0LnJlbSA9IG9wLnZhbHVlO1xuICBvcC52YWx1ZSA9IG91dC5zb3VyY2UgPSBvdXQuYWRkID0gZGF0YTtcbiAgb3AuX3BlbmRpbmcgPSBudWxsO1xuICBpZiAob3V0LnJlbS5sZW5ndGgpIG91dC5jbGVhbih0cnVlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBFeHRlbmQgdHVwbGVzIGJ5IGpvaW5pbmcgdGhlbSB3aXRoIHZhbHVlcyBmcm9tIGEgbG9va3VwIHRhYmxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge01hcH0gcGFyYW1zLmluZGV4IC0gVGhlIGxvb2t1cCB0YWJsZSBtYXAuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZHMgLSBUaGUgZmllbGRzIHRvIGxvb2t1cC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcGFyYW1zLmFzIC0gT3V0cHV0IGZpZWxkIG5hbWVzIGZvciBlYWNoIGxvb2t1cCB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gW3BhcmFtcy5kZWZhdWx0XSAtIEEgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgbG9va3VwIGZhaWxzLlxuICovXG5cbmZ1bmN0aW9uIExvb2t1cChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywge30sIHBhcmFtcyk7XG59XG5Mb29rdXAuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnTG9va3VwJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnaW5kZXgnLFxuICAgICd0eXBlJzogJ2luZGV4JyxcbiAgICAncGFyYW1zJzogW3tcbiAgICAgICduYW1lJzogJ2Zyb20nLFxuICAgICAgJ3R5cGUnOiAnZGF0YScsXG4gICAgICAncmVxdWlyZWQnOiB0cnVlXG4gICAgfSwge1xuICAgICAgJ25hbWUnOiAna2V5JyxcbiAgICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAgICdyZXF1aXJlZCc6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgJ25hbWUnOiAndmFsdWVzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdkZWZhdWx0JyxcbiAgICAnZGVmYXVsdCc6IG51bGxcbiAgfV1cbn07XG5pbmhlcml0cyhMb29rdXAsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBrZXlzID0gXy5maWVsZHMsXG4gICAgICAgICAgaW5kZXggPSBfLmluZGV4LFxuICAgICAgICAgIHZhbHVlcyA9IF8udmFsdWVzLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IF8uZGVmYXVsdCA9PSBudWxsID8gbnVsbCA6IF8uZGVmYXVsdCxcbiAgICAgICAgICByZXNldCA9IF8ubW9kaWZpZWQoKSxcbiAgICAgICAgICBuID0ga2V5cy5sZW5ndGg7XG5cbiAgICBsZXQgZmxhZyA9IHJlc2V0ID8gcHVsc2UuU09VUkNFIDogcHVsc2UuQURELFxuICAgICAgICBvdXQgPSBwdWxzZSxcbiAgICAgICAgYXMgPSBfLmFzLFxuICAgICAgICBzZXQsXG4gICAgICAgIG0sXG4gICAgICAgIG1vZHM7XG5cbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICBtID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKG4gPiAxICYmICFhcykge1xuICAgICAgICBlcnJvcignTXVsdGktZmllbGQgbG9va3VwIHJlcXVpcmVzIGV4cGxpY2l0IFwiYXNcIiBwYXJhbWV0ZXIuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcyAmJiBhcy5sZW5ndGggIT09IG4gKiBtKSB7XG4gICAgICAgIGVycm9yKCdUaGUgXCJhc1wiIHBhcmFtZXRlciBoYXMgdG9vIGZldyBvdXRwdXQgZmllbGQgbmFtZXMuJyk7XG4gICAgICB9XG5cbiAgICAgIGFzID0gYXMgfHwgdmFsdWVzLm1hcChhY2Nlc3Nvck5hbWUpO1xuXG4gICAgICBzZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgayA9IDAsIGosIHY7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICB2ID0gaW5kZXguZ2V0KGtleXNbaV0odCkpO1xuICAgICAgICAgIGlmICh2ID09IG51bGwpIGZvciAoaiA9IDA7IGogPCBtOyArK2osICsraykgdFthc1trXV0gPSBkZWZhdWx0VmFsdWU7ZWxzZSBmb3IgKGogPSAwOyBqIDwgbTsgKytqLCArK2spIHRbYXNba11dID0gdmFsdWVzW2pdKHYpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWFzKSB7XG4gICAgICAgIGVycm9yKCdNaXNzaW5nIG91dHB1dCBmaWVsZCBuYW1lcy4nKTtcbiAgICAgIH1cblxuICAgICAgc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHY7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICB2ID0gaW5kZXguZ2V0KGtleXNbaV0odCkpO1xuICAgICAgICAgIHRbYXNbaV1dID0gdiA9PSBudWxsID8gZGVmYXVsdFZhbHVlIDogdjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAocmVzZXQpIHtcbiAgICAgIG91dCA9IHB1bHNlLnJlZmxvdyh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kcyA9IGtleXMuc29tZShrID0+IHB1bHNlLm1vZGlmaWVkKGsuZmllbGRzKSk7XG4gICAgICBmbGFnIHw9IG1vZHMgPyBwdWxzZS5NT0QgOiAwO1xuICAgIH1cblxuICAgIHB1bHNlLnZpc2l0KGZsYWcsIHNldCk7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQ29tcHV0ZXMgZ2xvYmFsIG1pbi9tYXggZXh0ZW50cyBvdmVyIGEgY29sbGVjdGlvbiBvZiBleHRlbnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwYXJhbXMuZXh0ZW50cyAtIFRoZSBpbnB1dCBleHRlbnRzLlxuICovXG5cbmZ1bmN0aW9uIE11bHRpRXh0ZW50KHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIG51bGwsIHVwZGF0ZSQxLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoTXVsdGlFeHRlbnQsIE9wZXJhdG9yKTtcblxuZnVuY3Rpb24gdXBkYXRlJDEoXykge1xuICBpZiAodGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICBjb25zdCBleHQgPSBfLmV4dGVudHMsXG4gICAgICAgIG4gPSBleHQubGVuZ3RoO1xuICBsZXQgbWluID0gK0luZmluaXR5LFxuICAgICAgbWF4ID0gLUluZmluaXR5LFxuICAgICAgaSxcbiAgICAgIGU7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGUgPSBleHRbaV07XG4gICAgaWYgKGVbMF0gPCBtaW4pIG1pbiA9IGVbMF07XG4gICAgaWYgKGVbMV0gPiBtYXgpIG1heCA9IGVbMV07XG4gIH1cblxuICByZXR1cm4gW21pbiwgbWF4XTtcbn1cblxuLyoqXG4gKiBNZXJnZSBhIGNvbGxlY3Rpb24gb2YgdmFsdWUgYXJyYXlzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PCo+Pn0gcGFyYW1zLnZhbHVlcyAtIFRoZSBpbnB1dCB2YWx1ZSBhcnJyYXlzLlxuICovXG5cbmZ1bmN0aW9uIE11bHRpVmFsdWVzKHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIG51bGwsIHVwZGF0ZSwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKE11bHRpVmFsdWVzLCBPcGVyYXRvcik7XG5cbmZ1bmN0aW9uIHVwZGF0ZShfKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkgPyB0aGlzLnZhbHVlIDogXy52YWx1ZXMucmVkdWNlKChkYXRhLCBfKSA9PiBkYXRhLmNvbmNhdChfKSwgW10pO1xufVxuXG4vKipcbiAqIE9wZXJhdG9yIHdob3NlIHZhbHVlIGlzIHNpbXBseSBpdHMgcGFyYW1ldGVyIGhhc2guIFRoaXMgb3BlcmF0b3IgaXNcbiAqIHVzZWZ1bCBmb3IgZW5hYmxpbmcgcmVhY3RpdmUgdXBkYXRlcyB0byB2YWx1ZXMgb2YgbmVzdGVkIG9iamVjdHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqL1xuXG5mdW5jdGlvbiBQYXJhbXMocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhQYXJhbXMsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB0aGlzLm1vZGlmaWVkKF8ubW9kaWZpZWQoKSk7XG4gICAgdGhpcy52YWx1ZSA9IF87XG4gICAgcmV0dXJuIHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTsgLy8gZG8gbm90IHBhc3MgdHVwbGVzXG4gIH1cblxufSk7XG5cbi8qKlxuICogQWdncmVnYXRlIGFuZCBwaXZvdCBzZWxlY3RlZCBmaWVsZCB2YWx1ZXMgdG8gYmVjb21lIG5ldyBmaWVsZHMuXG4gKiBUaGlzIG9wZXJhdG9yIGlzIHVzZWZ1bCB0byBjb25zdHJ1Y3Rpb24gY3Jvc3MtdGFidWxhdGlvbnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnNcbiAqICB0byBncm91cGJ5LiBUaGVzZSBmaWVsZHMgYWN0IGp1c3QgbGlrZSBncm91cGJ5IGZpZWxkcyBvZiBhbiBBZ2dyZWdhdGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgZmllbGQgdG8gcGl2b3Qgb24uIFRoZSB1bmlxdWVcbiAqICB2YWx1ZXMgb2YgdGhpcyBmaWVsZCBiZWNvbWUgbmV3IGZpZWxkIG5hbWVzIGluIHRoZSBvdXRwdXQgc3RyZWFtLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMudmFsdWUgLSBUaGUgZmllbGQgdG8gcG9wdWxhdGUgcGl2b3RlZCBmaWVsZHMuXG4gKiAgVGhlIGFnZ3JlZ2F0ZSB2YWx1ZXMgb2YgdGhpcyBmaWVsZCBiZWNvbWUgdGhlIHZhbHVlcyBvZiB0aGUgbmV3IHBpdm90ZWQgZmllbGRzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMub3BdIC0gVGhlIGFnZ3JlZ2F0aW9uIG9wZXJhdGlvbiBmb3IgdGhlIHZhbHVlIGZpZWxkLFxuICogIGFwcGxpZWQgcGVyIGNlbGwgaW4gdGhlIG91dHB1dCBzdHJlYW0uIFRoZSBkZWZhdWx0IGlzIFwic3VtXCIuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5saW1pdF0gLSBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyB0aGUgbWF4aW11bVxuICogIG51bWJlciBvZiBwaXZvdGVkIGZpZWxkcyB0byBnZW5lcmF0ZS4gVGhlIHBpdm90ZWQgZmllbGQgbmFtZXMgYXJlIHNvcnRlZCBpblxuICogIGFzY2VuZGluZyBvcmRlciBwcmlvciB0byBlbmZvcmNpbmcgdGhlIGxpbWl0LlxuICovXG5cbmZ1bmN0aW9uIFBpdm90KHBhcmFtcykge1xuICBBZ2dyZWdhdGUuY2FsbCh0aGlzLCBwYXJhbXMpO1xufVxuUGl2b3QuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUGl2b3QnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3ZhbHVlJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3AnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBWYWxpZEFnZ3JlZ2F0ZU9wcyxcbiAgICAnZGVmYXVsdCc6ICdzdW0nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdsaW1pdCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ2tleScsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH1dXG59O1xuaW5oZXJpdHMoUGl2b3QsIEFnZ3JlZ2F0ZSwge1xuICBfdHJhbnNmb3JtOiBBZ2dyZWdhdGUucHJvdG90eXBlLnRyYW5zZm9ybSxcblxuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtKGFnZ3JlZ2F0ZVBhcmFtcyhfLCBwdWxzZSksIHB1bHNlKTtcbiAgfVxuXG59KTsgLy8gU2hvZWhvcm4gYSBwaXZvdCB0cmFuc2Zvcm0gaW50byBhbiBhZ2dyZWdhdGUgdHJhbnNmb3JtIVxuLy8gRmlyc3QgY29sbGVjdCBhbGwgdW5pcXVlIHBpdm90IGZpZWxkIHZhbHVlcy5cbi8vIFRoZW4gZ2VuZXJhdGUgYWdncmVnYXRlIGZpZWxkcyBmb3IgZWFjaCBvdXRwdXQgcGl2b3QgZmllbGQuXG5cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZVBhcmFtcyhfLCBwdWxzZSkge1xuICBjb25zdCBrZXkgPSBfLmZpZWxkLFxuICAgICAgICB2YWx1ZSA9IF8udmFsdWUsXG4gICAgICAgIG9wID0gKF8ub3AgPT09ICdjb3VudCcgPyAnX19jb3VudF9fJyA6IF8ub3ApIHx8ICdzdW0nLFxuICAgICAgICBmaWVsZHMgPSBhY2Nlc3NvckZpZWxkcyhrZXkpLmNvbmNhdChhY2Nlc3NvckZpZWxkcyh2YWx1ZSkpLFxuICAgICAgICBrZXlzID0gcGl2b3RLZXlzKGtleSwgXy5saW1pdCB8fCAwLCBwdWxzZSk7IC8vIGlmIGRhdGEgc3RyZWFtIGNvbnRlbnQgY2hhbmdlcywgcGl2b3QgZmllbGRzIG1heSBjaGFuZ2VcbiAgLy8gZmxhZyBwYXJhbWV0ZXIgbW9kaWZpY2F0aW9uIHRvIGVuc3VyZSByZS1pbml0aWFsaXphdGlvblxuXG4gIGlmIChwdWxzZS5jaGFuZ2VkKCkpIF8uc2V0KCdfX3Bpdm90X18nLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IF8ua2V5LFxuICAgIGdyb3VwYnk6IF8uZ3JvdXBieSxcbiAgICBvcHM6IGtleXMubWFwKCgpID0+IG9wKSxcbiAgICBmaWVsZHM6IGtleXMubWFwKGsgPT4gZ2V0KGssIGtleSwgdmFsdWUsIGZpZWxkcykpLFxuICAgIGFzOiBrZXlzLm1hcChrID0+IGsgKyAnJyksXG4gICAgbW9kaWZpZWQ6IF8ubW9kaWZpZWQuYmluZChfKVxuICB9O1xufSAvLyBHZW5lcmF0ZSBhZ2dyZWdhdGUgZmllbGQgYWNjZXNzb3IuXG4vLyBPdXRwdXQgTmFOIGZvciBub24tZXhpc3RlbnQgdmFsdWVzOyBhZ2dyZWdhdG9yIHdpbGwgaWdub3JlIVxuXG5cbmZ1bmN0aW9uIGdldChrLCBrZXksIHZhbHVlLCBmaWVsZHMpIHtcbiAgcmV0dXJuIGFjY2Vzc29yKGQgPT4ga2V5KGQpID09PSBrID8gdmFsdWUoZCkgOiBOYU4sIGZpZWxkcywgayArICcnKTtcbn0gLy8gQ29sbGVjdCAoYW5kIG9wdGlvbmFsbHkgbGltaXQpIGFsbCB1bmlxdWUgcGl2b3QgdmFsdWVzLlxuXG5cbmZ1bmN0aW9uIHBpdm90S2V5cyhrZXksIGxpbWl0LCBwdWxzZSkge1xuICBjb25zdCBtYXAgPSB7fSxcbiAgICAgICAgbGlzdCA9IFtdO1xuICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgIGNvbnN0IGsgPSBrZXkodCk7XG5cbiAgICBpZiAoIW1hcFtrXSkge1xuICAgICAgbWFwW2tdID0gMTtcbiAgICAgIGxpc3QucHVzaChrKTtcbiAgICB9XG4gIH0pO1xuICBsaXN0LnNvcnQoYXNjZW5kaW5nKTtcbiAgcmV0dXJuIGxpbWl0ID8gbGlzdC5zbGljZSgwLCBsaW1pdCkgOiBsaXN0O1xufVxuXG4vKipcbiAqIFBhcnRpdGlvbnMgcHJlLWZhY2V0ZWQgZGF0YSBpbnRvIHR1cGxlIHN1YmZsb3dzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFmbG93LCBzdHJpbmcpOiBPcGVyYXRvcn0gcGFyYW1zLnN1YmZsb3cgLSBBIGZ1bmN0aW9uXG4gKiAgIHRoYXQgZ2VuZXJhdGVzIGEgc3ViZmxvdyBvZiBvcGVyYXRvcnMgYW5kIHJldHVybnMgaXRzIHJvb3Qgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IEFycmF5PG9iamVjdD59IHBhcmFtcy5maWVsZCAtIFRoZSBmaWVsZFxuICogICBhY2Nlc3NvciBmb3IgYW4gYXJyYXkgb2Ygc3ViZmxvdyB0dXBsZSBvYmplY3RzLlxuICovXG5cbmZ1bmN0aW9uIFByZUZhY2V0KHBhcmFtcykge1xuICBGYWNldC5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhQcmVGYWNldCwgRmFjZXQsIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZmxvdyA9IF8uc3ViZmxvdyxcbiAgICAgICAgICBmaWVsZCA9IF8uZmllbGQsXG4gICAgICAgICAgc3ViZmxvdyA9IHQgPT4gdGhpcy5zdWJmbG93KHR1cGxlaWQodCksIGZsb3csIHB1bHNlLCB0KTtcblxuICAgIGlmIChfLm1vZGlmaWVkKCdmaWVsZCcpIHx8IGZpZWxkICYmIHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKGZpZWxkKSkpIHtcbiAgICAgIGVycm9yKCdQcmVGYWNldCBkb2VzIG5vdCBzdXBwb3J0IGZpZWxkIG1vZGlmaWNhdGlvbi4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRUYXJnZXRzKCk7IC8vIHJlc2V0IGxpc3Qgb2YgYWN0aXZlIHN1YmZsb3dzXG5cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiB7XG4gICAgICAgIGNvbnN0IHNmID0gc3ViZmxvdyh0KTtcbiAgICAgICAgZmllbGQodCkuZm9yRWFjaChfID0+IHNmLm1vZChfKSk7XG4gICAgICB9KTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiB7XG4gICAgICAgIGNvbnN0IHNmID0gc3ViZmxvdyh0KTtcbiAgICAgICAgZmllbGQodCkuZm9yRWFjaChfID0+IHNmLmFkZChpbmdlc3QoXykpKTtcbiAgICAgIH0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHtcbiAgICAgICAgY29uc3Qgc2YgPSBzdWJmbG93KHQpO1xuICAgICAgICBmaWVsZCh0KS5mb3JFYWNoKF8gPT4gc2YucmVtKF8pKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4gc3ViZmxvdyh0KS5tb2QodCkpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHN1YmZsb3codCkuYWRkKHQpKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiBzdWJmbG93KHQpLnJlbSh0KSk7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLmNsZWFuKCkpIHtcbiAgICAgIHB1bHNlLnJ1bkFmdGVyKCgpID0+IHRoaXMuY2xlYW4oKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bHNlO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgcmVsYXRpb25hbCBwcm9qZWN0aW9uLCBjb3B5aW5nIHNlbGVjdGVkIGZpZWxkcyBmcm9tIHNvdXJjZVxuICogdHVwbGVzIHRvIGEgbmV3IHNldCBvZiBkZXJpdmVkIHR1cGxlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGRzIC0gVGhlIGZpZWxkcyB0byBwcm9qZWN0LFxuICogICBhcyBhbiBhcnJheSBvZiBmaWVsZCBhY2Nlc3NvcnMuIElmIHVuc3BlY2lmaWVkLCBhbGwgZmllbGRzIHdpbGwgYmVcbiAqICAgY29waWVkIHdpdGggbmFtZXMgdW5jaGFuZ2VkLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbcGFyYW1zLmFzXSAtIE91dHB1dCBmaWVsZCBuYW1lcyBmb3IgZWFjaCBwcm9qZWN0ZWRcbiAqICAgZmllbGQuIEFueSB1bnNwZWNpZmllZCBmaWVsZHMgd2lsbCB1c2UgdGhlIGZpZWxkIG5hbWUgcHJvdmlkZWQgYnlcbiAqICAgdGhlIGZpZWxkIGFjY2Vzc29yLlxuICovXG5cbmZ1bmN0aW9uIFByb2plY3QocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Qcm9qZWN0LkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1Byb2plY3QnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoUHJvamVjdCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKSxcbiAgICAgICAgICBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgICAgICBhcyA9IGZpZWxkTmFtZXMoXy5maWVsZHMsIF8uYXMgfHwgW10pLFxuICAgICAgICAgIGRlcml2ZSA9IGZpZWxkcyA/IChzLCB0KSA9PiBwcm9qZWN0KHMsIHQsIGZpZWxkcywgYXMpIDogcmVkZXJpdmU7XG4gICAgbGV0IGx1dDtcblxuICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICBsdXQgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWxzZSA9IHB1bHNlLmFkZEFsbCgpO1xuICAgICAgbHV0ID0gdGhpcy52YWx1ZSA9IHt9O1xuICAgIH1cblxuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCk7XG4gICAgICBvdXQucmVtLnB1c2gobHV0W2lkXSk7XG4gICAgICBsdXRbaWRdID0gbnVsbDtcbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgY29uc3QgZHQgPSBkZXJpdmUodCwgaW5nZXN0KHt9KSk7XG4gICAgICBsdXRbdHVwbGVpZCh0KV0gPSBkdDtcbiAgICAgIG91dC5hZGQucHVzaChkdCk7XG4gICAgfSk7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHtcbiAgICAgIG91dC5tb2QucHVzaChkZXJpdmUodCwgbHV0W3R1cGxlaWQodCldKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gcHJvamVjdChzLCB0LCBmaWVsZHMsIGFzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBuID0gZmllbGRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHRbYXNbaV1dID0gZmllbGRzW2ldKHMpO1xuICB9XG5cbiAgcmV0dXJuIHQ7XG59XG5cbi8qKlxuICogUHJveHkgdGhlIHZhbHVlIG9mIGFub3RoZXIgb3BlcmF0b3IgYXMgYSBwdXJlIHNpZ25hbCB2YWx1ZS5cbiAqIEVuc3VyZXMgbm8gdHVwbGVzIGFyZSBwcm9wYWdhdGVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0geyp9IHBhcmFtcy52YWx1ZSAtIFRoZSB2YWx1ZSB0byBwcm94eSwgYmVjb21lcyB0aGUgdmFsdWUgb2YgdGhpcyBvcGVyYXRvci5cbiAqL1xuXG5mdW5jdGlvbiBQcm94eShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFByb3h5LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdGhpcy52YWx1ZSA9IF8udmFsdWU7XG4gICAgcmV0dXJuIF8ubW9kaWZpZWQoJ3ZhbHVlJykgPyBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUykgOiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gIH1cblxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIHNhbXBsZSBxdWFudGlsZSB2YWx1ZXMgZnJvbSBhbiBpbnB1dCBkYXRhIHN0cmVhbS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBBbiBhY2Nlc3NvciBmb3IgdGhlIGRhdGEgZmllbGRcbiAqICAgb3ZlciB3aGljaCB0byBjYWxjdWxhdGUgcXVhbnRpbGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29yc1xuICogICB0byBncm91cGJ5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLnByb2JzXSAtIEFuIGFycmF5IG9mIHByb2JhYmlsaXRpZXMgaW5cbiAqICAgdGhlIHJhbmdlICgwLCAxKSBmb3Igd2hpY2ggdG8gY29tcHV0ZSBxdWFudGlsZSB2YWx1ZXMuIElmIG5vdCBzcGVjaWZpZWQsXG4gKiAgIHRoZSAqc3RlcCogcGFyYW1ldGVyIHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5zdGVwPTAuMDFdIC0gQSBwcm9iYWJpbGl0eSBzdGVwIHNpemUgZm9yXG4gKiAgIHNhbXBsaW5nIHF1YW50aWxlIHZhbHVlcy4gQWxsIHZhbHVlcyBmcm9tIG9uZS1oYWxmIHRoZSBzdGVwIHNpemUgdXAgdG9cbiAqICAgMSAoZXhjbHVzaXZlKSB3aWxsIGJlIHNhbXBsZWQuIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCBpZiB0aGVcbiAqICAgKnF1YW50aWxlcyogcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZC5cbiAqL1xuXG5mdW5jdGlvbiBRdWFudGlsZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblF1YW50aWxlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1F1YW50aWxlJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlLFxuICAgICdjaGFuZ2VzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwcm9icycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMC4wMVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6IFsncHJvYicsICd2YWx1ZSddXG4gIH1dXG59O1xuY29uc3QgRVBTSUxPTiA9IDFlLTE0O1xuaW5oZXJpdHMoUXVhbnRpbGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyksXG4gICAgICAgICAgYXMgPSBfLmFzIHx8IFsncHJvYicsICd2YWx1ZSddO1xuXG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSAmJiAhcHVsc2UuY2hhbmdlZCgpKSB7XG4gICAgICBvdXQuc291cmNlID0gdGhpcy52YWx1ZTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgICAgZ3JvdXBzID0gcGFydGl0aW9uJDEoc291cmNlLCBfLmdyb3VwYnksIF8uZmllbGQpLFxuICAgICAgICAgIG5hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgICAgc3RlcCA9IF8uc3RlcCB8fCAwLjAxLFxuICAgICAgICAgIHAgPSBfLnByb2JzIHx8IHJhbmdlKHN0ZXAgLyAyLCAxIC0gRVBTSUxPTiwgc3RlcCksXG4gICAgICAgICAgbiA9IHAubGVuZ3RoO1xuICAgIGdyb3Vwcy5mb3JFYWNoKGcgPT4ge1xuICAgICAgY29uc3QgcSA9IHF1YW50aWxlcyhnLCBwKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgdCA9IHt9O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0W25hbWVzW2ldXSA9IGcuZGltc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRbYXNbMF1dID0gcFtpXTtcbiAgICAgICAgdFthc1sxXV0gPSBxW2ldO1xuICAgICAgICB2YWx1ZXMucHVzaChpbmdlc3QodCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLnZhbHVlKSBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LmFkZCA9IG91dC5zb3VyY2UgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBSZWxheXMgYSBkYXRhIHN0cmVhbSBiZXR3ZWVuIGRhdGEgcHJvY2Vzc2luZyBwaXBlbGluZXMuXG4gKiBJZiB0aGUgZGVyaXZlIHBhcmFtZXRlciBpcyBzZXQsIHRoaXMgdHJhbnNmb3JtIHdpbGwgY3JlYXRlIGRlcml2ZWRcbiAqIGNvcGllcyBvZiBvYnNlcnZlZCB0dXBsZXMuIFRoaXMgcHJvdmlkZXMgZGVyaXZlZCBkYXRhIHN0cmVhbXMgaW4gd2hpY2hcbiAqIG1vZGlmaWNhdGlvbnMgdG8gdGhlIHR1cGxlcyBkbyBub3QgcG9sbHV0ZSBhbiB1cHN0cmVhbSBkYXRhIHNvdXJjZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmRlcml2ZT1mYWxzZV0gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZlxuICogICB0aGUgdHJhbnNmb3JtIHNob3VsZCBtYWtlIGRlcml2ZWQgY29waWVzIG9mIGluY29taW5nIHR1cGxlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIFJlbGF5KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoUmVsYXksIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBsZXQgb3V0LCBsdXQ7XG5cbiAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgbHV0ID0gdGhpcy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gcHVsc2UgPSBwdWxzZS5hZGRBbGwoKTtcbiAgICAgIGx1dCA9IHRoaXMudmFsdWUgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoXy5kZXJpdmUpIHtcbiAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gdHVwbGVpZCh0KTtcbiAgICAgICAgb3V0LnJlbS5wdXNoKGx1dFtpZF0pO1xuICAgICAgICBsdXRbaWRdID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgICAgY29uc3QgZHQgPSBkZXJpdmUodCk7XG4gICAgICAgIGx1dFt0dXBsZWlkKHQpXSA9IGR0O1xuICAgICAgICBvdXQuYWRkLnB1c2goZHQpO1xuICAgICAgfSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgICBjb25zdCBkdCA9IGx1dFt0dXBsZWlkKHQpXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdCkge1xuICAgICAgICAgIGR0W2tdID0gdFtrXTsgLy8gZG93biBzdHJlYW0gd3JpdGVzIG1heSBvdmVyd3JpdGUgcmUtZGVyaXZlZCB0dXBsZXNcbiAgICAgICAgICAvLyBjb25zZXJ2YXRpdmVseSBtYXJrIGFsbCBzb3VyY2UgZmllbGRzIGFzIG1vZGlmaWVkXG5cbiAgICAgICAgICBvdXQubW9kaWZpZXMoayk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQubW9kLnB1c2goZHQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBTYW1wbGVzIHR1cGxlcyBwYXNzaW5nIHRocm91Z2ggdGhpcyBvcGVyYXRvci5cbiAqIFVzZXMgcmVzZXJ2b2lyIHNhbXBsaW5nIHRvIG1haW50YWluIGEgcmVwcmVzZW50YXRpdmUgc2FtcGxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5zaXplPTEwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNhbXBsZXMuXG4gKi9cblxuZnVuY3Rpb24gU2FtcGxlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5TYW1wbGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnU2FtcGxlJyxcbiAgJ21ldGFkYXRhJzoge30sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxMDAwXG4gIH1dXG59O1xuaW5oZXJpdHMoU2FtcGxlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpLFxuICAgICAgICAgIG1vZCA9IF8ubW9kaWZpZWQoJ3NpemUnKSxcbiAgICAgICAgICBudW0gPSBfLnNpemUsXG4gICAgICAgICAgbWFwID0gdGhpcy52YWx1ZS5yZWR1Y2UoKG0sIHQpID0+IChtW3R1cGxlaWQodCldID0gMSwgbSksIHt9KTtcblxuICAgIGxldCByZXMgPSB0aGlzLnZhbHVlLFxuICAgICAgICBjbnQgPSB0aGlzLmNvdW50LFxuICAgICAgICBjYXAgPSAwOyAvLyBzYW1wbGUgcmVzZXJ2b2lyIHVwZGF0ZSBmdW5jdGlvblxuXG4gICAgZnVuY3Rpb24gdXBkYXRlKHQpIHtcbiAgICAgIGxldCBwLCBpZHg7XG5cbiAgICAgIGlmIChyZXMubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIHJlcy5wdXNoKHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWR4ID0gfn4oKGNudCArIDEpICogcmFuZG9tKCkpO1xuXG4gICAgICAgIGlmIChpZHggPCByZXMubGVuZ3RoICYmIGlkeCA+PSBjYXApIHtcbiAgICAgICAgICBwID0gcmVzW2lkeF07XG4gICAgICAgICAgaWYgKG1hcFt0dXBsZWlkKHApXSkgb3V0LnJlbS5wdXNoKHApOyAvLyBldmljdGlvblxuXG4gICAgICAgICAgcmVzW2lkeF0gPSB0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICsrY250O1xuICAgIH1cblxuICAgIGlmIChwdWxzZS5yZW0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaW5kIGFsbCB0dXBsZXMgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCwgYWRkIHRvIG91dHB1dFxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpO1xuXG4gICAgICAgIGlmIChtYXBbaWRdKSB7XG4gICAgICAgICAgbWFwW2lkXSA9IC0xO1xuICAgICAgICAgIG91dC5yZW0ucHVzaCh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tY250O1xuICAgICAgfSk7IC8vIGZpbHRlciByZW1vdmVkIHR1cGxlcyBvdXQgb2YgdGhlIHNhbXBsZSByZXNlcnZvaXJcblxuICAgICAgcmVzID0gcmVzLmZpbHRlcih0ID0+IG1hcFt0dXBsZWlkKHQpXSAhPT0gLTEpO1xuICAgIH1cblxuICAgIGlmICgocHVsc2UucmVtLmxlbmd0aCB8fCBtb2QpICYmIHJlcy5sZW5ndGggPCBudW0gJiYgcHVsc2Uuc291cmNlKSB7XG4gICAgICAvLyByZXBsZW5pc2ggc2FtcGxlIGlmIGJhY2tpbmcgZGF0YSBzb3VyY2UgaXMgYXZhaWxhYmxlXG4gICAgICBjYXAgPSBjbnQgPSByZXMubGVuZ3RoO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IHtcbiAgICAgICAgLy8gdXBkYXRlLCBidXQgc2tpcCBwcmV2aW91c2x5IHNhbXBsZWQgdHVwbGVzXG4gICAgICAgIGlmICghbWFwW3R1cGxlaWQodCldKSB1cGRhdGUodCk7XG4gICAgICB9KTtcbiAgICAgIGNhcCA9IC0xO1xuICAgIH1cblxuICAgIGlmIChtb2QgJiYgcmVzLmxlbmd0aCA+IG51bSkge1xuICAgICAgY29uc3QgbiA9IHJlcy5sZW5ndGggLSBudW07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG1hcFt0dXBsZWlkKHJlc1tpXSldID0gLTE7XG4gICAgICAgIG91dC5yZW0ucHVzaChyZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXMgPSByZXMuc2xpY2Uobik7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLm1vZC5sZW5ndGgpIHtcbiAgICAgIC8vIHByb3BhZ2F0ZSBtb2RpZmllZCB0dXBsZXMgaW4gdGhlIHNhbXBsZSByZXNlcnZvaXJcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiB7XG4gICAgICAgIGlmIChtYXBbdHVwbGVpZCh0KV0pIG91dC5tb2QucHVzaCh0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwdWxzZS5hZGQubGVuZ3RoKSB7XG4gICAgICAvLyB1cGRhdGUgc2FtcGxlIHJlc2Vydm9pclxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB1cGRhdGUpO1xuICAgIH1cblxuICAgIGlmIChwdWxzZS5hZGQubGVuZ3RoIHx8IGNhcCA8IDApIHtcbiAgICAgIC8vIG91dHB1dCBuZXdseSBhZGRlZCB0dXBsZXNcbiAgICAgIG91dC5hZGQgPSByZXMuZmlsdGVyKHQgPT4gIW1hcFt0dXBsZWlkKHQpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb3VudCA9IGNudDtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IHJlcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBkYXRhIHR1cGxlcyBmb3IgYSBzcGVjaWZpZWQgc2VxdWVuY2UgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIFRoZSBmaXJzdCBudW1iZXIgaW4gdGhlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdG9wIC0gVGhlIGxhc3QgbnVtYmVyIChleGNsdXNpdmUpIGluIHRoZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXA9MV0gLSBUaGUgc3RlcCBzaXplIGJldHdlZW4gbnVtYmVycyBpbiB0aGUgc2VxdWVuY2UuXG4gKi9cblxuZnVuY3Rpb24gU2VxdWVuY2UocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5TZXF1ZW5jZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdTZXF1ZW5jZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc3RhcnQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RvcCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAnZGF0YSdcbiAgfV1cbn07XG5pbmhlcml0cyhTZXF1ZW5jZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkpIHJldHVybjtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5tYXRlcmlhbGl6ZSgpLmZvcmsocHVsc2UuTU9EKSxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgJ2RhdGEnO1xuICAgIG91dC5yZW0gPSB0aGlzLnZhbHVlID8gcHVsc2UucmVtLmNvbmNhdCh0aGlzLnZhbHVlKSA6IHB1bHNlLnJlbTtcbiAgICB0aGlzLnZhbHVlID0gcmFuZ2UoXy5zdGFydCwgXy5zdG9wLCBfLnN0ZXAgfHwgMSkubWFwKHYgPT4ge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgdFthc10gPSB2O1xuICAgICAgcmV0dXJuIGluZ2VzdCh0KTtcbiAgICB9KTtcbiAgICBvdXQuYWRkID0gcHVsc2UuYWRkLmNvbmNhdCh0aGlzLnZhbHVlKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFByb3BhZ2F0ZXMgYSBuZXcgcHVsc2Ugd2l0aG91dCBhbnkgdHVwbGVzIHNvIGxvbmcgYXMgdGhlIGlucHV0XG4gKiBwdWxzZSBjb250YWlucyBzb21lIGFkZGVkLCByZW1vdmVkIG9yIG1vZGlmaWVkIHR1cGxlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIFNpZXZlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xuICB0aGlzLm1vZGlmaWVkKHRydWUpOyAvLyBhbHdheXMgdHJlYXQgYXMgbW9kaWZpZWRcbn1cbmluaGVyaXRzKFNpZXZlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHB1bHNlLnNvdXJjZTtcbiAgICByZXR1cm4gcHVsc2UuY2hhbmdlZCgpID8gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpIDogcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIERpc2NyZXRpemUgZGF0ZXMgdG8gc3BlY2lmaWMgdGltZSB1bml0cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgZGF0YSBmaWVsZCBjb250YWluaW5nIGRhdGUvdGltZSB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gVGltZVVuaXQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5jb25zdCBPVVRQVVQgPSBbJ3VuaXQwJywgJ3VuaXQxJ107XG5UaW1lVW5pdC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdUaW1lVW5pdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaW50ZXJ2YWwnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAndW5pdHMnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBUSU1FX1VOSVRTLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXAnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtYXhiaW5zJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogNDBcbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudCcsXG4gICAgJ3R5cGUnOiAnZGF0ZScsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAndGltZXpvbmUnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICdkZWZhdWx0JzogJ2xvY2FsJyxcbiAgICAndmFsdWVzJzogWydsb2NhbCcsICd1dGMnXVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IE9VVFBVVFxuICB9XVxufTtcbmluaGVyaXRzKFRpbWVVbml0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZmllbGQgPSBfLmZpZWxkLFxuICAgICAgICAgIGJhbmQgPSBfLmludGVydmFsICE9PSBmYWxzZSxcbiAgICAgICAgICB1dGMgPSBfLnRpbWV6b25lID09PSAndXRjJyxcbiAgICAgICAgICBmbG9vciA9IHRoaXMuX2Zsb29yKF8sIHB1bHNlKSxcbiAgICAgICAgICBvZmZzZXQgPSAodXRjID8gdXRjSW50ZXJ2YWwgOiB0aW1lSW50ZXJ2YWwpKGZsb29yLnVuaXQpLm9mZnNldCxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgT1VUUFVULFxuICAgICAgICAgIHUwID0gYXNbMF0sXG4gICAgICAgICAgdTEgPSBhc1sxXSxcbiAgICAgICAgICBzdGVwID0gZmxvb3Iuc3RlcDtcblxuICAgIGxldCBtaW4gPSBmbG9vci5zdGFydCB8fCBJbmZpbml0eSxcbiAgICAgICAgbWF4ID0gZmxvb3Iuc3RvcCB8fCAtSW5maW5pdHksXG4gICAgICAgIGZsYWcgPSBwdWxzZS5BREQ7XG5cbiAgICBpZiAoXy5tb2RpZmllZCgpIHx8IHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKGZpZWxkKSkpIHtcbiAgICAgIHB1bHNlID0gcHVsc2UucmVmbG93KHRydWUpO1xuICAgICAgZmxhZyA9IHB1bHNlLlNPVVJDRTtcbiAgICAgIG1pbiA9IEluZmluaXR5O1xuICAgICAgbWF4ID0gLUluZmluaXR5O1xuICAgIH1cblxuICAgIHB1bHNlLnZpc2l0KGZsYWcsIHQgPT4ge1xuICAgICAgY29uc3QgdiA9IGZpZWxkKHQpO1xuICAgICAgbGV0IGEsIGI7XG5cbiAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgdFt1MF0gPSBudWxsO1xuICAgICAgICBpZiAoYmFuZCkgdFt1MV0gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdFt1MF0gPSBhID0gYiA9IGZsb29yKHYpO1xuICAgICAgICBpZiAoYmFuZCkgdFt1MV0gPSBiID0gb2Zmc2V0KGEsIHN0ZXApO1xuICAgICAgICBpZiAoYSA8IG1pbikgbWluID0gYTtcbiAgICAgICAgaWYgKGIgPiBtYXgpIG1heCA9IGI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmxvb3Iuc3RhcnQgPSBtaW47XG4gICAgZmxvb3Iuc3RvcCA9IG1heDtcbiAgICByZXR1cm4gcHVsc2UubW9kaWZpZXMoYmFuZCA/IGFzIDogdTApO1xuICB9LFxuXG4gIF9mbG9vcihfLCBwdWxzZSkge1xuICAgIGNvbnN0IHV0YyA9IF8udGltZXpvbmUgPT09ICd1dGMnOyAvLyBnZXQgcGFyYW1ldGVyc1xuXG4gICAgY29uc3Qge1xuICAgICAgdW5pdHMsXG4gICAgICBzdGVwXG4gICAgfSA9IF8udW5pdHMgPyB7XG4gICAgICB1bml0czogXy51bml0cyxcbiAgICAgIHN0ZXA6IF8uc3RlcCB8fCAxXG4gICAgfSA6IHRpbWVCaW4oe1xuICAgICAgZXh0ZW50OiBfLmV4dGVudCB8fCBleHRlbnQocHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsIF8uZmllbGQpLFxuICAgICAgbWF4YmluczogXy5tYXhiaW5zXG4gICAgfSk7IC8vIGNoZWNrIC8gc3RhbmRhcmRpemUgdGltZSB1bml0c1xuXG4gICAgY29uc3QgdHVuaXRzID0gdGltZVVuaXRzKHVuaXRzKSxcbiAgICAgICAgICBwcmV2ID0gdGhpcy52YWx1ZSB8fCB7fSxcbiAgICAgICAgICBmbG9vciA9ICh1dGMgPyB1dGNGbG9vciA6IHRpbWVGbG9vcikodHVuaXRzLCBzdGVwKTtcbiAgICBmbG9vci51bml0ID0gcGVlayh0dW5pdHMpO1xuICAgIGZsb29yLnVuaXRzID0gdHVuaXRzO1xuICAgIGZsb29yLnN0ZXAgPSBzdGVwO1xuICAgIGZsb29yLnN0YXJ0ID0gcHJldi5zdGFydDtcbiAgICBmbG9vci5zdG9wID0gcHJldi5zdG9wO1xuICAgIHJldHVybiB0aGlzLnZhbHVlID0gZmxvb3I7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQW4gaW5kZXggdGhhdCBtYXBzIGZyb20gdW5pcXVlLCBzdHJpbmctY29lcmNlZCwgZmllbGQgdmFsdWVzIHRvIHR1cGxlcy5cbiAqIEFzc3VtZXMgdGhhdCB0aGUgZmllbGQgc2VydmVzIGFzIGEgdW5pcXVlIGtleSB3aXRoIG5vIGR1cGxpY2F0ZSB2YWx1ZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIGZpZWxkIGFjY2Vzc29yIHRvIGluZGV4LlxuICovXG5cbmZ1bmN0aW9uIFR1cGxlSW5kZXgocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIGZhc3RtYXAoKSwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFR1cGxlSW5kZXgsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBkZiA9IHB1bHNlLmRhdGFmbG93LFxuICAgICAgICAgIGZpZWxkID0gXy5maWVsZCxcbiAgICAgICAgICBpbmRleCA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgc2V0ID0gdCA9PiBpbmRleC5zZXQoZmllbGQodCksIHQpO1xuXG4gICAgbGV0IG1vZCA9IHRydWU7XG5cbiAgICBpZiAoXy5tb2RpZmllZCgnZmllbGQnKSB8fCBwdWxzZS5tb2RpZmllZChmaWVsZC5maWVsZHMpKSB7XG4gICAgICBpbmRleC5jbGVhcigpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCBzZXQpO1xuICAgIH0gZWxzZSBpZiAocHVsc2UuY2hhbmdlZCgpKSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4gaW5kZXguZGVsZXRlKGZpZWxkKHQpKSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMubW9kaWZpZWQobW9kKTtcbiAgICBpZiAoaW5kZXguZW1wdHkgPiBkZi5jbGVhblRocmVzaG9sZCkgZGYucnVuQWZ0ZXIoaW5kZXguY2xlYW4pO1xuICAgIHJldHVybiBwdWxzZS5mb3JrKCk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogRXh0cmFjdHMgYW4gYXJyYXkgb2YgdmFsdWVzLiBBc3N1bWVzIHRoZSBzb3VyY2UgZGF0YSBoYXMgYWxyZWFkeSBiZWVuXG4gKiByZWR1Y2VkIGFzIG5lZWRlZCAoZS5nLiwgYnkgYW4gdXBzdHJlYW0gQWdncmVnYXRlIHRyYW5zZm9ybSkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIGRvbWFpbiBmaWVsZCB0byBleHRyYWN0LlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCopOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBbiBvcHRpb25hbFxuICogICBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBzb3J0aW5nIHRoZSB2YWx1ZXMuIFRoZSBjb21wYXJhdG9yIHdpbGwgYmVcbiAqICAgYXBwbGllZCB0byBiYWNraW5nIHR1cGxlcyBwcmlvciB0byB2YWx1ZSBleHRyYWN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIFZhbHVlcyhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFZhbHVlcywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IHJ1biA9ICF0aGlzLnZhbHVlIHx8IF8ubW9kaWZpZWQoJ2ZpZWxkJykgfHwgXy5tb2RpZmllZCgnc29ydCcpIHx8IHB1bHNlLmNoYW5nZWQoKSB8fCBfLnNvcnQgJiYgcHVsc2UubW9kaWZpZWQoXy5zb3J0LmZpZWxkcyk7XG5cbiAgICBpZiAocnVuKSB7XG4gICAgICB0aGlzLnZhbHVlID0gKF8uc29ydCA/IHB1bHNlLnNvdXJjZS5zbGljZSgpLnNvcnQoc3RhYmxlQ29tcGFyZShfLnNvcnQpKSA6IHB1bHNlLnNvdXJjZSkubWFwKF8uZmllbGQpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gV2luZG93T3Aob3AsIGZpZWxkLCBwYXJhbSwgYXMpIHtcbiAgY29uc3QgZm4gPSBXaW5kb3dPcHNbb3BdKGZpZWxkLCBwYXJhbSk7XG4gIHJldHVybiB7XG4gICAgaW5pdDogZm4uaW5pdCB8fCB6ZXJvLFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHcsIHQpIHtcbiAgICAgIHRbYXNdID0gZm4ubmV4dCh3KTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBXaW5kb3dPcHMgPSB7XG4gIHJvd19udW1iZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogdyA9PiB3LmluZGV4ICsgMVxuICAgIH07XG4gIH0sXG4gIHJhbms6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmFuaztcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogKCkgPT4gcmFuayA9IDEsXG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHcuaW5kZXgsXG4gICAgICAgICAgICAgIGRhdGEgPSB3LmRhdGE7XG4gICAgICAgIHJldHVybiBpICYmIHcuY29tcGFyZShkYXRhW2kgLSAxXSwgZGF0YVtpXSkgPyByYW5rID0gaSArIDEgOiByYW5rO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGRlbnNlX3Jhbms6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgZHJhbms7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6ICgpID0+IGRyYW5rID0gMSxcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCBpID0gdy5pbmRleCxcbiAgICAgICAgICAgICAgZCA9IHcuZGF0YTtcbiAgICAgICAgcmV0dXJuIGkgJiYgdy5jb21wYXJlKGRbaSAtIDFdLCBkW2ldKSA/ICsrZHJhbmsgOiBkcmFuaztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwZXJjZW50X3Jhbms6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCByYW5rID0gV2luZG93T3BzLnJhbmsoKSxcbiAgICAgICAgICBuZXh0ID0gcmFuay5uZXh0O1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiByYW5rLmluaXQsXG4gICAgICBuZXh0OiB3ID0+IChuZXh0KHcpIC0gMSkgLyAody5kYXRhLmxlbmd0aCAtIDEpXG4gICAgfTtcbiAgfSxcbiAgY3VtZV9kaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGN1bWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6ICgpID0+IGN1bWUgPSAwLFxuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSB3LmRhdGEsXG4gICAgICAgICAgICAgIGMgPSB3LmNvbXBhcmU7XG4gICAgICAgIGxldCBpID0gdy5pbmRleDtcblxuICAgICAgICBpZiAoY3VtZSA8IGkpIHtcbiAgICAgICAgICB3aGlsZSAoaSArIDEgPCBkLmxlbmd0aCAmJiAhYyhkW2ldLCBkW2kgKyAxXSkpICsraTtcblxuICAgICAgICAgIGN1bWUgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgxICsgY3VtZSkgLyBkLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBudGlsZTogZnVuY3Rpb24gKGZpZWxkLCBudW0pIHtcbiAgICBudW0gPSArbnVtO1xuICAgIGlmICghKG51bSA+IDApKSBlcnJvcignbnRpbGUgbnVtIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uJyk7XG4gICAgY29uc3QgY3VtZSA9IFdpbmRvd09wcy5jdW1lX2Rpc3QoKSxcbiAgICAgICAgICBuZXh0ID0gY3VtZS5uZXh0O1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiBjdW1lLmluaXQsXG4gICAgICBuZXh0OiB3ID0+IE1hdGguY2VpbChudW0gKiBuZXh0KHcpKVxuICAgIH07XG4gIH0sXG4gIGxhZzogZnVuY3Rpb24gKGZpZWxkLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSArb2Zmc2V0IHx8IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCBpID0gdy5pbmRleCAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGkgPj0gMCA/IGZpZWxkKHcuZGF0YVtpXSkgOiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGxlYWQ6IGZ1bmN0aW9uIChmaWVsZCwgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gK29mZnNldCB8fCAxO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHcuaW5kZXggKyBvZmZzZXQsXG4gICAgICAgICAgICAgIGQgPSB3LmRhdGE7XG4gICAgICAgIHJldHVybiBpIDwgZC5sZW5ndGggPyBmaWVsZChkW2ldKSA6IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZmlyc3RfdmFsdWU6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IGZpZWxkKHcuZGF0YVt3LmkwXSlcbiAgICB9O1xuICB9LFxuICBsYXN0X3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogdyA9PiBmaWVsZCh3LmRhdGFbdy5pMSAtIDFdKVxuICAgIH07XG4gIH0sXG4gIG50aF92YWx1ZTogZnVuY3Rpb24gKGZpZWxkLCBudGgpIHtcbiAgICBudGggPSArbnRoO1xuICAgIGlmICghKG50aCA+IDApKSBlcnJvcignbnRoX3ZhbHVlIG50aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLicpO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHcuaTAgKyAobnRoIC0gMSk7XG4gICAgICAgIHJldHVybiBpIDwgdy5pMSA/IGZpZWxkKHcuZGF0YVtpXSkgOiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHByZXZfdmFsdWU6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGxldCBwcmV2O1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiAoKSA9PiBwcmV2ID0gbnVsbCxcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCB2ID0gZmllbGQody5kYXRhW3cuaW5kZXhdKTtcbiAgICAgICAgcmV0dXJuIHYgIT0gbnVsbCA/IHByZXYgPSB2IDogcHJldjtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBuZXh0X3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICBsZXQgdiwgaTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogKCkgPT4gKHYgPSBudWxsLCBpID0gLTEpLFxuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSB3LmRhdGE7XG4gICAgICAgIHJldHVybiB3LmluZGV4IDw9IGkgPyB2IDogKGkgPSBmaW5kKGZpZWxkLCBkLCB3LmluZGV4KSkgPCAwID8gKGkgPSBkLmxlbmd0aCwgdiA9IG51bGwpIDogdiA9IGZpZWxkKGRbaV0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmQoZmllbGQsIGRhdGEsIGluZGV4KSB7XG4gIGZvciAobGV0IG4gPSBkYXRhLmxlbmd0aDsgaW5kZXggPCBuOyArK2luZGV4KSB7XG4gICAgY29uc3QgdiA9IGZpZWxkKGRhdGFbaW5kZXhdKTtcbiAgICBpZiAodiAhPSBudWxsKSByZXR1cm4gaW5kZXg7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmNvbnN0IFZhbGlkV2luZG93T3BzID0gT2JqZWN0LmtleXMoV2luZG93T3BzKTtcblxuZnVuY3Rpb24gV2luZG93U3RhdGUoXykge1xuICBjb25zdCBvcHMgPSBhcnJheShfLm9wcyksXG4gICAgICAgIGZpZWxkcyA9IGFycmF5KF8uZmllbGRzKSxcbiAgICAgICAgcGFyYW1zID0gYXJyYXkoXy5wYXJhbXMpLFxuICAgICAgICBhcyA9IGFycmF5KF8uYXMpLFxuICAgICAgICBvdXRwdXRzID0gdGhpcy5vdXRwdXRzID0gW10sXG4gICAgICAgIHdpbmRvd3MgPSB0aGlzLndpbmRvd3MgPSBbXSxcbiAgICAgICAgaW5wdXRzID0ge30sXG4gICAgICAgIG1hcCA9IHt9LFxuICAgICAgICBjb3VudHMgPSBbXSxcbiAgICAgICAgbWVhc3VyZXMgPSBbXTtcbiAgbGV0IGNvdW50T25seSA9IHRydWU7XG5cbiAgZnVuY3Rpb24gdmlzaXRJbnB1dHMoZikge1xuICAgIGFycmF5KGFjY2Vzc29yRmllbGRzKGYpKS5mb3JFYWNoKF8gPT4gaW5wdXRzW19dID0gMSk7XG4gIH1cblxuICB2aXNpdElucHV0cyhfLnNvcnQpO1xuICBvcHMuZm9yRWFjaCgob3AsIGkpID0+IHtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tpXSxcbiAgICAgICAgICBtbmFtZSA9IGFjY2Vzc29yTmFtZShmaWVsZCksXG4gICAgICAgICAgbmFtZSA9IG1lYXN1cmVOYW1lKG9wLCBtbmFtZSwgYXNbaV0pO1xuICAgIHZpc2l0SW5wdXRzKGZpZWxkKTtcbiAgICBvdXRwdXRzLnB1c2gobmFtZSk7IC8vIFdpbmRvdyBvcGVyYXRpb25cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShXaW5kb3dPcHMsIG9wKSkge1xuICAgICAgd2luZG93cy5wdXNoKFdpbmRvd09wKG9wLCBmaWVsZHNbaV0sIHBhcmFtc1tpXSwgbmFtZSkpO1xuICAgIH0gLy8gQWdncmVnYXRlIG9wZXJhdGlvblxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCAmJiBvcCAhPT0gJ2NvdW50Jykge1xuICAgICAgICAgIGVycm9yKCdOdWxsIGFnZ3JlZ2F0ZSBmaWVsZCBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3AgPT09ICdjb3VudCcpIHtcbiAgICAgICAgICBjb3VudHMucHVzaChuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudE9ubHkgPSBmYWxzZTtcbiAgICAgICAgbGV0IG0gPSBtYXBbbW5hbWVdO1xuXG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgIG0gPSBtYXBbbW5hbWVdID0gW107XG4gICAgICAgICAgbS5maWVsZCA9IGZpZWxkO1xuICAgICAgICAgIG1lYXN1cmVzLnB1c2gobSk7XG4gICAgICAgIH1cblxuICAgICAgICBtLnB1c2goY3JlYXRlTWVhc3VyZShvcCwgbmFtZSkpO1xuICAgICAgfVxuICB9KTtcblxuICBpZiAoY291bnRzLmxlbmd0aCB8fCBtZWFzdXJlcy5sZW5ndGgpIHtcbiAgICB0aGlzLmNlbGwgPSBjZWxsKG1lYXN1cmVzLCBjb3VudHMsIGNvdW50T25seSk7XG4gIH1cblxuICB0aGlzLmlucHV0cyA9IE9iamVjdC5rZXlzKGlucHV0cyk7XG59XG5jb25zdCBwcm90b3R5cGUgPSBXaW5kb3dTdGF0ZS5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndpbmRvd3MuZm9yRWFjaChfID0+IF8uaW5pdCgpKTtcbiAgaWYgKHRoaXMuY2VsbCkgdGhpcy5jZWxsLmluaXQoKTtcbn07XG5cbnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodywgdCkge1xuICBjb25zdCBjZWxsID0gdGhpcy5jZWxsLFxuICAgICAgICB3aW5kID0gdGhpcy53aW5kb3dzLFxuICAgICAgICBkYXRhID0gdy5kYXRhLFxuICAgICAgICBtID0gd2luZCAmJiB3aW5kLmxlbmd0aDtcbiAgbGV0IGo7XG5cbiAgaWYgKGNlbGwpIHtcbiAgICBmb3IgKGogPSB3LnAwOyBqIDwgdy5pMDsgKytqKSBjZWxsLnJlbShkYXRhW2pdKTtcblxuICAgIGZvciAoaiA9IHcucDE7IGogPCB3LmkxOyArK2opIGNlbGwuYWRkKGRhdGFbal0pO1xuXG4gICAgY2VsbC5zZXQodCk7XG4gIH1cblxuICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB3aW5kW2pdLnVwZGF0ZSh3LCB0KTtcbn07XG5cbmZ1bmN0aW9uIGNlbGwobWVhc3VyZXMsIGNvdW50cywgY291bnRPbmx5KSB7XG4gIG1lYXN1cmVzID0gbWVhc3VyZXMubWFwKG0gPT4gY29tcGlsZU1lYXN1cmVzKG0sIG0uZmllbGQpKTtcbiAgY29uc3QgY2VsbCA9IHtcbiAgICBudW06IDAsXG4gICAgYWdnOiBudWxsLFxuICAgIHN0b3JlOiBmYWxzZSxcbiAgICBjb3VudDogY291bnRzXG4gIH07XG5cbiAgaWYgKCFjb3VudE9ubHkpIHtcbiAgICB2YXIgbiA9IG1lYXN1cmVzLmxlbmd0aCxcbiAgICAgICAgYSA9IGNlbGwuYWdnID0gQXJyYXkobiksXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBuOyArK2kpIGFbaV0gPSBuZXcgbWVhc3VyZXNbaV0oY2VsbCk7XG4gIH1cblxuICBpZiAoY2VsbC5zdG9yZSkge1xuICAgIHZhciBzdG9yZSA9IGNlbGwuZGF0YSA9IG5ldyBUdXBsZVN0b3JlKCk7XG4gIH1cblxuICBjZWxsLmFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgY2VsbC5udW0gKz0gMTtcbiAgICBpZiAoY291bnRPbmx5KSByZXR1cm47XG4gICAgaWYgKHN0b3JlKSBzdG9yZS5hZGQodCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgYVtpXS5hZGQoYVtpXS5nZXQodCksIHQpO1xuICAgIH1cbiAgfTtcblxuICBjZWxsLnJlbSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgY2VsbC5udW0gLT0gMTtcbiAgICBpZiAoY291bnRPbmx5KSByZXR1cm47XG4gICAgaWYgKHN0b3JlKSBzdG9yZS5yZW0odCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgYVtpXS5yZW0oYVtpXS5nZXQodCksIHQpO1xuICAgIH1cbiAgfTtcblxuICBjZWxsLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgbGV0IGksIG47IC8vIGNvbnNvbGlkYXRlIHN0b3JlZCB2YWx1ZXNcblxuICAgIGlmIChzdG9yZSkgc3RvcmUudmFsdWVzKCk7IC8vIHVwZGF0ZSB0dXBsZSBwcm9wZXJ0aWVzXG5cbiAgICBmb3IgKGkgPSAwLCBuID0gY291bnRzLmxlbmd0aDsgaSA8IG47ICsraSkgdFtjb3VudHNbaV1dID0gY2VsbC5udW07XG5cbiAgICBpZiAoIWNvdW50T25seSkgZm9yIChpID0gMCwgbiA9IGEubGVuZ3RoOyBpIDwgbjsgKytpKSBhW2ldLnNldCh0KTtcbiAgfTtcblxuICBjZWxsLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2VsbC5udW0gPSAwO1xuICAgIGlmIChzdG9yZSkgc3RvcmUucmVzZXQoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBhW2ldLmluaXQoKTtcbiAgfTtcblxuICByZXR1cm4gY2VsbDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIHdpbmRvdyBjYWxjdWxhdGlvbnMgYW5kIHdyaXRlIHJlc3VsdHMgdG8gdGhlIGlucHV0IHN0cmVhbS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCopOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBIGNvbXBhcmF0b3IgZnVuY3Rpb24gZm9yIHNvcnRpbmcgdHVwbGVzIHdpdGhpbiBhIHdpbmRvdy5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnMgYnkgd2hpY2ggdG8gcGFydGl0aW9uIHR1cGxlcyBpbnRvIHNlcGFyYXRlIHdpbmRvd3MuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHBhcmFtcy5vcHMgLSBBbiBhcnJheSBvZiBzdHJpbmdzIGluZGljYXRpbmcgd2luZG93IG9wZXJhdGlvbnMgdG8gcGVyZm9ybS5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZmllbGRzXSAtIEFuIGFycmF5IG9mIGFjY2Vzc29yc1xuICogICBmb3IgZGF0YSBmaWVsZHMgdG8gdXNlIGFzIGlucHV0cyB0byB3aW5kb3cgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IFtwYXJhbXMucGFyYW1zXSAtIEFuIGFycmF5IG9mIHBhcmFtZXRlciB2YWx1ZXMgZm9yIHdpbmRvdyBvcGVyYXRpb25zLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbcGFyYW1zLmFzXSAtIEFuIGFycmF5IG9mIG91dHB1dCBmaWVsZCBuYW1lcyBmb3Igd2luZG93IG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMuZnJhbWVdIC0gV2luZG93IGZyYW1lIGRlZmluaXRpb24gYXMgdHdvLWVsZW1lbnQgYXJyYXkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuaWdub3JlUGVlcnM9ZmFsc2VdIC0gSWYgdHJ1ZSwgYmFzZSB3aW5kb3cgZnJhbWUgYm91bmRhcmllcyBvbiByb3dcbiAqICAgbnVtYmVyIGFsb25lLCBpZ25vcmluZyBwZWVycyB3aXRoIGlkZW50aWNhbCBzb3J0IHZhbHVlcy4gSWYgZmFsc2UgKGRlZmF1bHQpLFxuICogICB0aGUgd2luZG93IGJvdW5kYXJpZXMgd2lsbCBiZSBhZGp1c3RlZCB0byBpbmNsdWRlIHBlZXIgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIFdpbmRvdyhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywge30sIHBhcmFtcyk7XG4gIHRoaXMuX21sZW4gPSAwO1xuICB0aGlzLl9tb2RzID0gW107XG59XG5XaW5kb3cuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnV2luZG93JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcHMnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3ZhbHVlcyc6IFZhbGlkV2luZG93T3BzLmNvbmNhdChWYWxpZEFnZ3JlZ2F0ZU9wcylcbiAgfSwge1xuICAgICduYW1lJzogJ3BhcmFtcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmcmFtZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFtudWxsLCAwXVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaWdub3JlUGVlcnMnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfV1cbn07XG5pbmhlcml0cyhXaW5kb3csIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB0aGlzLnN0YW1wID0gcHVsc2Uuc3RhbXA7XG5cbiAgICBjb25zdCBtb2QgPSBfLm1vZGlmaWVkKCksXG4gICAgICAgICAgY21wID0gc3RhYmxlQ29tcGFyZShfLnNvcnQpLFxuICAgICAgICAgIGtleSA9IGdyb3Vwa2V5KF8uZ3JvdXBieSksXG4gICAgICAgICAgZ3JvdXAgPSB0ID0+IHRoaXMuZ3JvdXAoa2V5KHQpKTsgLy8gaW5pdGlhbGl6ZSB3aW5kb3cgc3RhdGVcblxuXG4gICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmICghc3RhdGUgfHwgbW9kKSB7XG4gICAgICBzdGF0ZSA9IHRoaXMuc3RhdGUgPSBuZXcgV2luZG93U3RhdGUoXyk7XG4gICAgfSAvLyBwYXJ0aXRpb24gaW5wdXQgdHVwbGVzXG5cblxuICAgIGlmIChtb2QgfHwgcHVsc2UubW9kaWZpZWQoc3RhdGUuaW5wdXRzKSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHt9O1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IGdyb3VwKHQpLmFkZCh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiBncm91cCh0KS5yZW1vdmUodCkpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IGdyb3VwKHQpLmFkZCh0KSk7XG4gICAgfSAvLyBwZXJmb3JtIHdpbmRvdyBjYWxjdWxhdGlvbnMgZm9yIGVhY2ggbW9kaWZpZWQgcGFydGl0aW9uXG5cblxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fbWxlbjsgaSA8IG47ICsraSkge1xuICAgICAgcHJvY2Vzc1BhcnRpdGlvbih0aGlzLl9tb2RzW2ldLCBzdGF0ZSwgY21wLCBfKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tbGVuID0gMDtcbiAgICB0aGlzLl9tb2RzID0gW107IC8vIFRPRE8gZG9uJ3QgcmVmbG93IGV2ZXJ5dGhpbmc/XG5cbiAgICByZXR1cm4gcHVsc2UucmVmbG93KG1vZCkubW9kaWZpZXMoc3RhdGUub3V0cHV0cyk7XG4gIH0sXG5cbiAgZ3JvdXAoa2V5KSB7XG4gICAgbGV0IGdyb3VwID0gdGhpcy52YWx1ZVtrZXldO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgZ3JvdXAgPSB0aGlzLnZhbHVlW2tleV0gPSBTb3J0ZWRMaXN0KHR1cGxlaWQpO1xuICAgICAgZ3JvdXAuc3RhbXAgPSAtMTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc3RhbXAgPCB0aGlzLnN0YW1wKSB7XG4gICAgICBncm91cC5zdGFtcCA9IHRoaXMuc3RhbXA7XG4gICAgICB0aGlzLl9tb2RzW3RoaXMuX21sZW4rK10gPSBncm91cDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHByb2Nlc3NQYXJ0aXRpb24obGlzdCwgc3RhdGUsIGNtcCwgXykge1xuICBjb25zdCBzb3J0ID0gXy5zb3J0LFxuICAgICAgICByYW5nZSA9IHNvcnQgJiYgIV8uaWdub3JlUGVlcnMsXG4gICAgICAgIGZyYW1lID0gXy5mcmFtZSB8fCBbbnVsbCwgMF0sXG4gICAgICAgIGRhdGEgPSBsaXN0LmRhdGEoY21wKSxcbiAgICAgICAgLy8gdXNlIGNtcCBmb3Igc3RhYmxlIHNvcnRcbiAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBiID0gcmFuZ2UgPyBiaXNlY3Rvcihzb3J0KSA6IG51bGwsXG4gICAgICAgIHcgPSB7XG4gICAgaTA6IDAsXG4gICAgaTE6IDAsXG4gICAgcDA6IDAsXG4gICAgcDE6IDAsXG4gICAgaW5kZXg6IDAsXG4gICAgZGF0YTogZGF0YSxcbiAgICBjb21wYXJlOiBzb3J0IHx8IGNvbnN0YW50KC0xKVxuICB9O1xuICBzdGF0ZS5pbml0KCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzZXRXaW5kb3codywgZnJhbWUsIGksIG4pO1xuICAgIGlmIChyYW5nZSkgYWRqdXN0UmFuZ2UodywgYik7XG4gICAgc3RhdGUudXBkYXRlKHcsIGRhdGFbaV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFdpbmRvdyh3LCBmLCBpLCBuKSB7XG4gIHcucDAgPSB3LmkwO1xuICB3LnAxID0gdy5pMTtcbiAgdy5pMCA9IGZbMF0gPT0gbnVsbCA/IDAgOiBNYXRoLm1heCgwLCBpIC0gTWF0aC5hYnMoZlswXSkpO1xuICB3LmkxID0gZlsxXSA9PSBudWxsID8gbiA6IE1hdGgubWluKG4sIGkgKyBNYXRoLmFicyhmWzFdKSArIDEpO1xuICB3LmluZGV4ID0gaTtcbn0gLy8gaWYgZnJhbWUgdHlwZSBpcyAncmFuZ2UnLCBhZGp1c3Qgd2luZG93IGZvciBwZWVyIHZhbHVlc1xuXG5cbmZ1bmN0aW9uIGFkanVzdFJhbmdlKHcsIGJpc2VjdCkge1xuICBjb25zdCByMCA9IHcuaTAsXG4gICAgICAgIHIxID0gdy5pMSAtIDEsXG4gICAgICAgIGMgPSB3LmNvbXBhcmUsXG4gICAgICAgIGQgPSB3LmRhdGEsXG4gICAgICAgIG4gPSBkLmxlbmd0aCAtIDE7XG4gIGlmIChyMCA+IDAgJiYgIWMoZFtyMF0sIGRbcjAgLSAxXSkpIHcuaTAgPSBiaXNlY3QubGVmdChkLCBkW3IwXSk7XG4gIGlmIChyMSA8IG4gJiYgIWMoZFtyMV0sIGRbcjEgKyAxXSkpIHcuaTEgPSBiaXNlY3QucmlnaHQoZCwgZFtyMV0pO1xufVxuXG5leHBvcnQgeyBBZ2dyZWdhdGUgYXMgYWdncmVnYXRlLCBCaW4gYXMgYmluLCBDb2xsZWN0IGFzIGNvbGxlY3QsIENvbXBhcmUgYXMgY29tcGFyZSwgQ291bnRQYXR0ZXJuIGFzIGNvdW50cGF0dGVybiwgQ3Jvc3MgYXMgY3Jvc3MsIERlbnNpdHkgYXMgZGVuc2l0eSwgRG90QmluIGFzIGRvdGJpbiwgRXhwcmVzc2lvbiBhcyBleHByZXNzaW9uLCBFeHRlbnQgYXMgZXh0ZW50LCBGYWNldCBhcyBmYWNldCwgRmllbGQgYXMgZmllbGQsIEZpbHRlciBhcyBmaWx0ZXIsIEZsYXR0ZW4gYXMgZmxhdHRlbiwgRm9sZCBhcyBmb2xkLCBGb3JtdWxhIGFzIGZvcm11bGEsIEdlbmVyYXRlIGFzIGdlbmVyYXRlLCBJbXB1dGUgYXMgaW1wdXRlLCBKb2luQWdncmVnYXRlIGFzIGpvaW5hZ2dyZWdhdGUsIEtERSBhcyBrZGUsIEtleSBhcyBrZXksIExvYWQgYXMgbG9hZCwgTG9va3VwIGFzIGxvb2t1cCwgTXVsdGlFeHRlbnQgYXMgbXVsdGlleHRlbnQsIE11bHRpVmFsdWVzIGFzIG11bHRpdmFsdWVzLCBQYXJhbXMgYXMgcGFyYW1zLCBQaXZvdCBhcyBwaXZvdCwgUHJlRmFjZXQgYXMgcHJlZmFjZXQsIFByb2plY3QgYXMgcHJvamVjdCwgUHJveHkgYXMgcHJveHksIFF1YW50aWxlIGFzIHF1YW50aWxlLCBSZWxheSBhcyByZWxheSwgU2FtcGxlIGFzIHNhbXBsZSwgU2VxdWVuY2UgYXMgc2VxdWVuY2UsIFNpZXZlIGFzIHNpZXZlLCBTdWJmbG93IGFzIHN1YmZsb3csIFRpbWVVbml0IGFzIHRpbWV1bml0LCBUdXBsZUluZGV4IGFzIHR1cGxlaW5kZXgsIFZhbHVlcyBhcyB2YWx1ZXMsIFdpbmRvdyBhcyB3aW5kb3cgfTtcbiIsImltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgTWFya3MsIGJvdW5kQ2xpcCwgR3JvdXBJdGVtLCBJdGVtLCBCb3VuZHMsIG11bHRpTGluZU9mZnNldCwgYm91bmRTdHJva2UgfSBmcm9tICd2ZWdhLXNjZW5lZ3JhcGgnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIHBlZWssIGlzT2JqZWN0IH0gZnJvbSAndmVnYS11dGlsJztcblxuY29uc3QgVG9wID0gJ3RvcCc7XG5jb25zdCBMZWZ0ID0gJ2xlZnQnO1xuY29uc3QgUmlnaHQgPSAncmlnaHQnO1xuY29uc3QgQm90dG9tID0gJ2JvdHRvbSc7XG5jb25zdCBUb3BMZWZ0ID0gJ3RvcC1sZWZ0JztcbmNvbnN0IFRvcFJpZ2h0ID0gJ3RvcC1yaWdodCc7XG5jb25zdCBCb3R0b21MZWZ0ID0gJ2JvdHRvbS1sZWZ0JztcbmNvbnN0IEJvdHRvbVJpZ2h0ID0gJ2JvdHRvbS1yaWdodCc7XG5jb25zdCBTdGFydCA9ICdzdGFydCc7XG5jb25zdCBNaWRkbGUgPSAnbWlkZGxlJztcbmNvbnN0IEVuZCA9ICdlbmQnO1xuY29uc3QgWCA9ICd4JztcbmNvbnN0IFkgPSAneSc7XG5jb25zdCBHcm91cCA9ICdncm91cCc7XG5jb25zdCBBeGlzUm9sZSA9ICdheGlzJztcbmNvbnN0IFRpdGxlUm9sZSA9ICd0aXRsZSc7XG5jb25zdCBGcmFtZVJvbGUgPSAnZnJhbWUnO1xuY29uc3QgU2NvcGVSb2xlID0gJ3Njb3BlJztcbmNvbnN0IExlZ2VuZFJvbGUgPSAnbGVnZW5kJztcbmNvbnN0IFJvd0hlYWRlciA9ICdyb3ctaGVhZGVyJztcbmNvbnN0IFJvd0Zvb3RlciA9ICdyb3ctZm9vdGVyJztcbmNvbnN0IFJvd1RpdGxlID0gJ3Jvdy10aXRsZSc7XG5jb25zdCBDb2xIZWFkZXIgPSAnY29sdW1uLWhlYWRlcic7XG5jb25zdCBDb2xGb290ZXIgPSAnY29sdW1uLWZvb3Rlcic7XG5jb25zdCBDb2xUaXRsZSA9ICdjb2x1bW4tdGl0bGUnO1xuY29uc3QgUGFkZGluZyA9ICdwYWRkaW5nJztcbmNvbnN0IFN5bWJvbHMgPSAnc3ltYm9sJztcbmNvbnN0IEZpdCA9ICdmaXQnO1xuY29uc3QgRml0WCA9ICdmaXQteCc7XG5jb25zdCBGaXRZID0gJ2ZpdC15JztcbmNvbnN0IFBhZCA9ICdwYWQnO1xuY29uc3QgTm9uZSA9ICdub25lJztcbmNvbnN0IEFsbCA9ICdhbGwnO1xuY29uc3QgRWFjaCA9ICdlYWNoJztcbmNvbnN0IEZsdXNoID0gJ2ZsdXNoJztcbmNvbnN0IENvbHVtbiA9ICdjb2x1bW4nO1xuY29uc3QgUm93ID0gJ3Jvdyc7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGJvdW5kaW5nIGJveGVzIGZvciBzY2VuZWdyYXBoIGl0ZW1zLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1hcmsgLSBUaGUgc2NlbmVncmFwaCBtYXJrIGluc3RhbmNlIHRvIGJvdW5kLlxuICovXG5cbmZ1bmN0aW9uIEJvdW5kKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoQm91bmQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCB2aWV3ID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICAgICAgbWFyayA9IF8ubWFyayxcbiAgICAgICAgICB0eXBlID0gbWFyay5tYXJrdHlwZSxcbiAgICAgICAgICBlbnRyeSA9IE1hcmtzW3R5cGVdLFxuICAgICAgICAgIGJvdW5kID0gZW50cnkuYm91bmQ7XG4gICAgbGV0IG1hcmtCb3VuZHMgPSBtYXJrLmJvdW5kcyxcbiAgICAgICAgcmVib3VuZDtcblxuICAgIGlmIChlbnRyeS5uZXN0ZWQpIHtcbiAgICAgIC8vIG11bHRpLWl0ZW0gbWFya3MgaGF2ZSBhIHNpbmdsZSBib3VuZHMgaW5zdGFuY2VcbiAgICAgIGlmIChtYXJrLml0ZW1zLmxlbmd0aCkgdmlldy5kaXJ0eShtYXJrLml0ZW1zWzBdKTtcbiAgICAgIG1hcmtCb3VuZHMgPSBib3VuZEl0ZW0obWFyaywgYm91bmQpO1xuICAgICAgbWFyay5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpdGVtLmJvdW5kcy5jbGVhcigpLnVuaW9uKG1hcmtCb3VuZHMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBHcm91cCB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIC8vIG9wZXJhdG9yIHBhcmFtZXRlcnMgbW9kaWZpZWQgLT4gcmUtYm91bmQgYWxsIGl0ZW1zXG4gICAgICAvLyB1cGRhdGVzIGdyb3VwIGJvdW5kcyBpbiByZXNwb25zZSB0byBtb2RpZmllZCBncm91cCBjb250ZW50XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIGl0ZW0gPT4gdmlldy5kaXJ0eShpdGVtKSk7XG4gICAgICBtYXJrQm91bmRzLmNsZWFyKCk7XG4gICAgICBtYXJrLml0ZW1zLmZvckVhY2goaXRlbSA9PiBtYXJrQm91bmRzLnVuaW9uKGJvdW5kSXRlbShpdGVtLCBib3VuZCkpKTsgLy8gZm9yY2UgcmVmbG93IGZvciBheGVzL2xlZ2VuZHMvdGl0bGVzIHRvIHByb3BhZ2F0ZSBhbnkgbGF5b3V0IGNoYW5nZXNcblxuICAgICAgc3dpdGNoIChtYXJrLnJvbGUpIHtcbiAgICAgICAgY2FzZSBBeGlzUm9sZTpcbiAgICAgICAgY2FzZSBMZWdlbmRSb2xlOlxuICAgICAgICBjYXNlIFRpdGxlUm9sZTpcbiAgICAgICAgICBwdWxzZS5yZWZsb3coKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5jcmVtZW50YWxseSB1cGRhdGUgYm91bmRzLCByZS1ib3VuZCBtYXJrIGFzIG5lZWRlZFxuICAgICAgcmVib3VuZCA9IHB1bHNlLmNoYW5nZWQocHVsc2UuUkVNKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgaXRlbSA9PiB7XG4gICAgICAgIG1hcmtCb3VuZHMudW5pb24oYm91bmRJdGVtKGl0ZW0sIGJvdW5kKSk7XG4gICAgICB9KTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgaXRlbSA9PiB7XG4gICAgICAgIHJlYm91bmQgPSByZWJvdW5kIHx8IG1hcmtCb3VuZHMuYWxpZ25zV2l0aChpdGVtLmJvdW5kcyk7XG4gICAgICAgIHZpZXcuZGlydHkoaXRlbSk7XG4gICAgICAgIG1hcmtCb3VuZHMudW5pb24oYm91bmRJdGVtKGl0ZW0sIGJvdW5kKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlYm91bmQpIHtcbiAgICAgICAgbWFya0JvdW5kcy5jbGVhcigpO1xuICAgICAgICBtYXJrLml0ZW1zLmZvckVhY2goaXRlbSA9PiBtYXJrQm91bmRzLnVuaW9uKGl0ZW0uYm91bmRzKSk7XG4gICAgICB9XG4gICAgfSAvLyBlbnN1cmUgbWFyayBib3VuZHMgZG8gbm90IGV4Y2VlZCBhbnkgY2xpcHBpbmcgcmVnaW9uXG5cblxuICAgIGJvdW5kQ2xpcChtYXJrKTtcbiAgICByZXR1cm4gcHVsc2UubW9kaWZpZXMoJ2JvdW5kcycpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBib3VuZEl0ZW0oaXRlbSwgYm91bmQsIG9wdCkge1xuICByZXR1cm4gYm91bmQoaXRlbS5ib3VuZHMuY2xlYXIoKSwgaXRlbSwgb3B0KTtcbn1cblxuY29uc3QgQ09VTlRFUl9OQU1FID0gJzp2ZWdhX2lkZW50aWZpZXI6Jztcbi8qKlxuICogQWRkcyBhIHVuaXF1ZSBpZGVudGlmaWVyIHRvIGFsbCBhZGRlZCB0dXBsZXMuXG4gKiBUaGlzIHRyYW5zZm9ybSBjcmVhdGVzIGEgbmV3IHNpZ25hbCB0aGF0IHNlcnZlcyBhcyBhbiBpZCBjb3VudGVyLlxuICogQXMgYSByZXN1bHQsIHRoZSBpZCBjb3VudGVyIGlzIHNoYXJlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcyBvZiB0aGlzXG4gKiB0cmFuc2Zvcm0sIGdlbmVyYXRpbmcgdW5pcXVlIGlkcyBhY3Jvc3MgbXVsdGlwbGUgZGF0YSBzdHJlYW1zLiBJblxuICogYWRkaXRpb24sIHRoaXMgc2lnbmFsIHZhbHVlIGNhbiBiZSBpbmNsdWRlZCBpbiBhIHNuYXBzaG90IG9mIHRoZVxuICogZGF0YWZsb3cgc3RhdGUsIGVuYWJsaW5nIGNvcnJlY3QgcmVzdW1wdGlvbiBvZiBpZCBhbGxvY2F0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFzIC0gVGhlIGZpZWxkIG5hbWUgZm9yIHRoZSBnZW5lcmF0ZWQgaWRlbnRpZmllci5cbiAqL1xuXG5mdW5jdGlvbiBJZGVudGlmaWVyKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCAwLCBwYXJhbXMpO1xufVxuSWRlbnRpZmllci5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdJZGVudGlmaWVyJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKElkZW50aWZpZXIsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBjb3VudGVyID0gZ2V0Q291bnRlcihwdWxzZS5kYXRhZmxvdyksXG4gICAgICAgICAgYXMgPSBfLmFzO1xuICAgIGxldCBpZCA9IGNvdW50ZXIudmFsdWU7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHRbYXNdID0gdFthc10gfHwgKytpZCk7XG4gICAgY291bnRlci5zZXQodGhpcy52YWx1ZSA9IGlkKTtcbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIGdldENvdW50ZXIodmlldykge1xuICByZXR1cm4gdmlldy5fc2lnbmFsc1tDT1VOVEVSX05BTUVdIHx8ICh2aWV3Ll9zaWduYWxzW0NPVU5URVJfTkFNRV0gPSB2aWV3LmFkZCgwKSk7XG59XG5cbi8qKlxuICogQmluZCBzY2VuZWdyYXBoIGl0ZW1zIHRvIGEgc2NlbmVncmFwaCBtYXJrIGluc3RhbmNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1hcmtkZWYgLSBUaGUgbWFyayBkZWZpbml0aW9uIGZvciBjcmVhdGluZyB0aGUgbWFyay5cbiAqICAgVGhpcyBpcyBhbiBvYmplY3Qgb2YgbGVnYWwgc2NlbmVncmFwaCBtYXJrIHByb3BlcnRpZXMgd2hpY2ggKm11c3QqIGluY2x1ZGVcbiAqICAgdGhlICdtYXJrdHlwZScgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gTWFyayhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKE1hcmssIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBsZXQgbWFyayA9IHRoaXMudmFsdWU7IC8vIGFjcXVpcmUgbWFyayBvbiBmaXJzdCBpbnZvY2F0aW9uLCBiaW5kIGNvbnRleHQgYW5kIGdyb3VwXG5cbiAgICBpZiAoIW1hcmspIHtcbiAgICAgIG1hcmsgPSBwdWxzZS5kYXRhZmxvdy5zY2VuZWdyYXBoKCkubWFyayhfLm1hcmtkZWYsIGxvb2t1cChfKSwgXy5pbmRleCk7XG4gICAgICBtYXJrLmdyb3VwLmNvbnRleHQgPSBfLmNvbnRleHQ7XG4gICAgICBpZiAoIV8uY29udGV4dC5ncm91cCkgXy5jb250ZXh0Lmdyb3VwID0gbWFyay5ncm91cDtcbiAgICAgIG1hcmsuc291cmNlID0gdGhpcy5zb3VyY2U7IC8vIHBvaW50IHRvIHVwc3RyZWFtIGNvbGxlY3RvclxuXG4gICAgICBtYXJrLmNsaXAgPSBfLmNsaXA7XG4gICAgICBtYXJrLmludGVyYWN0aXZlID0gXy5pbnRlcmFjdGl2ZTtcbiAgICAgIHRoaXMudmFsdWUgPSBtYXJrO1xuICAgIH0gLy8gaW5pdGlhbGl6ZSBlbnRlcmluZyBpdGVtc1xuXG5cbiAgICBjb25zdCBJbml0ID0gbWFyay5tYXJrdHlwZSA9PT0gR3JvdXAgPyBHcm91cEl0ZW0gOiBJdGVtO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgaXRlbSA9PiBJbml0LmNhbGwoaXRlbSwgbWFyaykpOyAvLyB1cGRhdGUgY2xpcHBpbmcgYW5kL29yIGludGVyYWN0aXZlIHN0YXR1c1xuXG4gICAgaWYgKF8ubW9kaWZpZWQoJ2NsaXAnKSB8fCBfLm1vZGlmaWVkKCdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICBtYXJrLmNsaXAgPSBfLmNsaXA7XG4gICAgICBtYXJrLmludGVyYWN0aXZlID0gISFfLmludGVyYWN0aXZlO1xuICAgICAgbWFyay56ZGlydHkgPSB0cnVlOyAvLyBmb3JjZSBzY2VuZWdyYXBoIHJlLWV2YWxcblxuICAgICAgcHVsc2UucmVmbG93KCk7XG4gICAgfSAvLyBiaW5kIGl0ZW1zIGFycmF5IHRvIHNjZW5lZ3JhcGggbWFya1xuXG5cbiAgICBtYXJrLml0ZW1zID0gcHVsc2Uuc291cmNlO1xuICAgIHJldHVybiBwdWxzZTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gbG9va3VwKF8pIHtcbiAgY29uc3QgZyA9IF8uZ3JvdXBzLFxuICAgICAgICBwID0gXy5wYXJlbnQ7XG4gIHJldHVybiBnICYmIGcuc2l6ZSA9PT0gMSA/IGcuZ2V0KE9iamVjdC5rZXlzKGcub2JqZWN0KVswXSkgOiBnICYmIHAgPyBnLmxvb2t1cChwKSA6IG51bGw7XG59XG5cbi8qKlxuICogQW5hbHl6ZSBpdGVtcyBmb3Igb3ZlcmxhcCwgY2hhbmdpbmcgb3BhY2l0eSB0byBoaWRlIGl0ZW1zIHdpdGhcbiAqIG92ZXJsYXBwaW5nIGJvdW5kaW5nIGJveGVzLiBUaGlzIHRyYW5zZm9ybSB3aWxsIHByZXNlcnZlIGF0IGxlYXN0XG4gKiB0d28gaXRlbXMgKGUuZy4sIGZpcnN0IGFuZCBsYXN0KSBldmVuIGlmIG92ZXJsYXAgcGVyc2lzdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEEgY29tcGFyYXRvclxuICogICBmdW5jdGlvbiBmb3Igc29ydGluZyBpdGVtcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLm1ldGhvZF0gLSBUaGUgb3ZlcmxhcCByZW1vdmFsIG1ldGhvZCB0byBhcHBseS5cbiAqICAgT25lIG9mICdwYXJpdHknIChkZWZhdWx0LCBoaWRlIGV2ZXJ5IG90aGVyIGl0ZW0gdW50aWwgdGhlcmUgaXMgbm9cbiAqICAgbW9yZSBvdmVybGFwKSBvciAnZ3JlZWR5JyAoc2VxdWVudGlhbGx5IHNjYW4gYW5kIGhpZGUgYW5kIGl0ZW1zIHRoYXRcbiAqICAgb3ZlcmxhcCB3aXRoIHRoZSBsYXN0IHZpc2libGUgaXRlbSkuXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcy5ib3VuZFNjYWxlXSAtIEEgc2NhbGUgd2hvc2UgcmFuZ2Ugc2hvdWxkIGJlIHVzZWRcbiAqICAgdG8gYm91bmQgdGhlIGl0ZW1zLiBJdGVtcyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiB0aGUgc2NhbGUgcmFuZ2VcbiAqICAgd2lsbCBiZSB0cmVhdGVkIGFzIG92ZXJsYXBwaW5nLiBJZiBudWxsIG9yIHVuZGVmaW5lZCwgbm8gYm91bmRzIGNoZWNrXG4gKiAgIHdpbGwgYmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLmJvdW5kT3JpZW50XSAtIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc2NhbGVcbiAqICAgKHRvcCwgYm90dG9tLCBsZWZ0LCBvciByaWdodCkgdXNlZCB0byBib3VuZCBpdGVtcy4gVGhpcyBwYXJhbWV0ZXIgaXNcbiAqICAgaWdub3JlZCBpZiBib3VuZFNjYWxlIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXMuYm91bmRUb2xlcmFuY2VdIC0gVGhlIHRvbGVyYW5jZSBpbiBwaXhlbHMgZm9yXG4gKiAgIGJvdW5kIGluY2x1c2lvbiB0ZXN0aW5nIChkZWZhdWx0IDEpLiBUaGlzIHNwZWNpZmllcyBieSBob3cgbWFueSBwaXhlbHNcbiAqICAgYW4gaXRlbSdzIGJvdW5kcyBtYXkgZXhjZWVkIHRoZSBzY2FsZSByYW5nZSBib3VuZHMgYW5kIG5vdCBiZSBjdWxsZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBPdmVybGFwKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuY29uc3QgbWV0aG9kcyA9IHtcbiAgcGFyaXR5OiBpdGVtcyA9PiBpdGVtcy5maWx0ZXIoKGl0ZW0sIGkpID0+IGkgJSAyID8gaXRlbS5vcGFjaXR5ID0gMCA6IDEpLFxuICBncmVlZHk6IChpdGVtcywgc2VwKSA9PiB7XG4gICAgbGV0IGE7XG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoYiwgaSkgPT4gIWkgfHwgIWludGVyc2VjdChhLmJvdW5kcywgYi5ib3VuZHMsIHNlcCkgPyAoYSA9IGIsIDEpIDogYi5vcGFjaXR5ID0gMCk7XG4gIH1cbn07IC8vIGNvbXB1dGUgYm91bmRpbmcgYm94IGludGVyc2VjdGlvblxuLy8gaW5jbHVkaW5nIHBhZGRpbmcgcGl4ZWxzIG9mIHNlcGFyYXRpb25cblxuY29uc3QgaW50ZXJzZWN0ID0gKGEsIGIsIHNlcCkgPT4gc2VwID4gTWF0aC5tYXgoYi54MSAtIGEueDIsIGEueDEgLSBiLngyLCBiLnkxIC0gYS55MiwgYS55MSAtIGIueTIpO1xuXG5jb25zdCBoYXNPdmVybGFwID0gKGl0ZW1zLCBwYWQpID0+IHtcbiAgZm9yICh2YXIgaSA9IDEsIG4gPSBpdGVtcy5sZW5ndGgsIGEgPSBpdGVtc1swXS5ib3VuZHMsIGI7IGkgPCBuOyBhID0gYiwgKytpKSB7XG4gICAgaWYgKGludGVyc2VjdChhLCBiID0gaXRlbXNbaV0uYm91bmRzLCBwYWQpKSByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuY29uc3QgaGFzQm91bmRzID0gaXRlbSA9PiB7XG4gIGNvbnN0IGIgPSBpdGVtLmJvdW5kcztcbiAgcmV0dXJuIGIud2lkdGgoKSA+IDEgJiYgYi5oZWlnaHQoKSA+IDE7XG59O1xuXG5jb25zdCBib3VuZFRlc3QgPSAoc2NhbGUsIG9yaWVudCwgdG9sZXJhbmNlKSA9PiB7XG4gIHZhciByYW5nZSA9IHNjYWxlLnJhbmdlKCksXG4gICAgICBiID0gbmV3IEJvdW5kcygpO1xuXG4gIGlmIChvcmllbnQgPT09IFRvcCB8fCBvcmllbnQgPT09IEJvdHRvbSkge1xuICAgIGIuc2V0KHJhbmdlWzBdLCAtSW5maW5pdHksIHJhbmdlWzFdLCArSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIGIuc2V0KC1JbmZpbml0eSwgcmFuZ2VbMF0sICtJbmZpbml0eSwgcmFuZ2VbMV0pO1xuICB9XG5cbiAgYi5leHBhbmQodG9sZXJhbmNlIHx8IDEpO1xuICByZXR1cm4gaXRlbSA9PiBiLmVuY2xvc2VzKGl0ZW0uYm91bmRzKTtcbn07IC8vIHJlc2V0IGFsbCBpdGVtcyB0byBiZSBmdWxseSBvcGFxdWVcblxuXG5jb25zdCByZXNldCA9IHNvdXJjZSA9PiB7XG4gIHNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5vcGFjaXR5ID0gMSk7XG4gIHJldHVybiBzb3VyY2U7XG59OyAvLyBhZGQgYWxsIHR1cGxlcyB0byBtb2QsIGZvcmsgcHVsc2UgaWYgcGFyYW1ldGVycyB3ZXJlIG1vZGlmaWVkXG4vLyBmb3JrIHByZXZlbnRzIGNyb3NzLXN0cmVhbSB0dXBsZSBwb2xsdXRpb24gKGUuZy4sIHB1bHNlIGZyb20gc2NhbGUpXG5cblxuY29uc3QgcmVmbG93ID0gKHB1bHNlLCBfKSA9PiBwdWxzZS5yZWZsb3coXy5tb2RpZmllZCgpKS5tb2RpZmllcygnb3BhY2l0eScpO1xuXG5pbmhlcml0cyhPdmVybGFwLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgcmVkdWNlID0gbWV0aG9kc1tfLm1ldGhvZF0gfHwgbWV0aG9kcy5wYXJpdHksXG4gICAgICAgICAgc2VwID0gXy5zZXBhcmF0aW9uIHx8IDA7XG4gICAgbGV0IHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgdGVzdDtcbiAgICBpZiAoIXNvdXJjZSB8fCAhc291cmNlLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgaWYgKCFfLm1ldGhvZCkge1xuICAgICAgLy8gZWFybHkgZXhpdCBpZiBtZXRob2QgaXMgZmFsc3lcbiAgICAgIGlmIChfLm1vZGlmaWVkKCdtZXRob2QnKSkge1xuICAgICAgICByZXNldChzb3VyY2UpO1xuICAgICAgICBwdWxzZSA9IHJlZmxvdyhwdWxzZSwgXyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdWxzZTtcbiAgICB9IC8vIHNraXAgbGFiZWxzIHdpdGggbm8gY29udGVudFxuXG5cbiAgICBzb3VyY2UgPSBzb3VyY2UuZmlsdGVyKGhhc0JvdW5kcyk7IC8vIGVhcmx5IGV4aXQsIG5vdGhpbmcgdG8gZG9cblxuICAgIGlmICghc291cmNlLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgaWYgKF8uc29ydCkge1xuICAgICAgc291cmNlID0gc291cmNlLnNsaWNlKCkuc29ydChfLnNvcnQpO1xuICAgIH1cblxuICAgIGl0ZW1zID0gcmVzZXQoc291cmNlKTtcbiAgICBwdWxzZSA9IHJlZmxvdyhwdWxzZSwgXyk7XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID49IDMgJiYgaGFzT3ZlcmxhcChpdGVtcywgc2VwKSkge1xuICAgICAgZG8ge1xuICAgICAgICBpdGVtcyA9IHJlZHVjZShpdGVtcywgc2VwKTtcbiAgICAgIH0gd2hpbGUgKGl0ZW1zLmxlbmd0aCA+PSAzICYmIGhhc092ZXJsYXAoaXRlbXMsIHNlcCkpO1xuXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMyAmJiAhcGVlayhzb3VyY2UpLm9wYWNpdHkpIHtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDEpIHBlZWsoaXRlbXMpLm9wYWNpdHkgPSAwO1xuICAgICAgICBwZWVrKHNvdXJjZSkub3BhY2l0eSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF8uYm91bmRTY2FsZSAmJiBfLmJvdW5kVG9sZXJhbmNlID49IDApIHtcbiAgICAgIHRlc3QgPSBib3VuZFRlc3QoXy5ib3VuZFNjYWxlLCBfLmJvdW5kT3JpZW50LCArXy5ib3VuZFRvbGVyYW5jZSk7XG4gICAgICBzb3VyY2UuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKCF0ZXN0KGl0ZW0pKSBpdGVtLm9wYWNpdHkgPSAwO1xuICAgICAgfSk7XG4gICAgfSAvLyByZS1jYWxjdWxhdGUgbWFyayBib3VuZHNcblxuXG4gICAgY29uc3QgYm91bmRzID0gaXRlbXNbMF0ubWFyay5ib3VuZHMuY2xlYXIoKTtcbiAgICBzb3VyY2UuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmIChpdGVtLm9wYWNpdHkpIGJvdW5kcy51bmlvbihpdGVtLmJvdW5kcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHB1bHNlO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFF1ZXVlIG1vZGlmaWVkIHNjZW5lZ3JhcGggaXRlbXMgZm9yIHJlbmRlcmluZy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIFJlbmRlcihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFJlbmRlciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IHZpZXcgPSBwdWxzZS5kYXRhZmxvdztcbiAgICBwdWxzZS52aXNpdChwdWxzZS5BTEwsIGl0ZW0gPT4gdmlldy5kaXJ0eShpdGVtKSk7IC8vIHNldCB6LWluZGV4IGRpcnR5IGZsYWcgYXMgbmVlZGVkXG5cbiAgICBpZiAocHVsc2UuZmllbGRzICYmIHB1bHNlLmZpZWxkc1snemluZGV4J10pIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBwdWxzZS5zb3VyY2UgJiYgcHVsc2Uuc291cmNlWzBdO1xuICAgICAgaWYgKGl0ZW0pIGl0ZW0ubWFyay56ZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59KTtcblxuY29uc3QgdGVtcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbmZ1bmN0aW9uIHNldChpdGVtLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIGl0ZW1bcHJvcGVydHldID09PSB2YWx1ZSA/IDAgOiAoaXRlbVtwcm9wZXJ0eV0gPSB2YWx1ZSwgMSk7XG59XG5cbmZ1bmN0aW9uIGlzWUF4aXMobWFyaykge1xuICB2YXIgb3JpZW50ID0gbWFyay5pdGVtc1swXS5vcmllbnQ7XG4gIHJldHVybiBvcmllbnQgPT09IExlZnQgfHwgb3JpZW50ID09PSBSaWdodDtcbn1cblxuZnVuY3Rpb24gYXhpc0luZGljZXMoZGF0dW0pIHtcbiAgbGV0IGluZGV4ID0gK2RhdHVtLmdyaWQ7XG4gIHJldHVybiBbZGF0dW0udGlja3MgPyBpbmRleCsrIDogLTEsIC8vIHRpY2tzIGluZGV4XG4gIGRhdHVtLmxhYmVscyA/IGluZGV4KysgOiAtMSwgLy8gbGFiZWxzIGluZGV4XG4gIGluZGV4ICsgK2RhdHVtLmRvbWFpbiAvLyB0aXRsZSBpbmRleFxuICBdO1xufVxuXG5mdW5jdGlvbiBheGlzTGF5b3V0KHZpZXcsIGF4aXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGl0ZW0gPSBheGlzLml0ZW1zWzBdLFxuICAgICAgZGF0dW0gPSBpdGVtLmRhdHVtLFxuICAgICAgZGVsdGEgPSBpdGVtLnRyYW5zbGF0ZSAhPSBudWxsID8gaXRlbS50cmFuc2xhdGUgOiAwLjUsXG4gICAgICBvcmllbnQgPSBpdGVtLm9yaWVudCxcbiAgICAgIGluZGljZXMgPSBheGlzSW5kaWNlcyhkYXR1bSksXG4gICAgICByYW5nZSA9IGl0ZW0ucmFuZ2UsXG4gICAgICBvZmZzZXQgPSBpdGVtLm9mZnNldCxcbiAgICAgIHBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbixcbiAgICAgIG1pbkV4dGVudCA9IGl0ZW0ubWluRXh0ZW50LFxuICAgICAgbWF4RXh0ZW50ID0gaXRlbS5tYXhFeHRlbnQsXG4gICAgICB0aXRsZSA9IGRhdHVtLnRpdGxlICYmIGl0ZW0uaXRlbXNbaW5kaWNlc1syXV0uaXRlbXNbMF0sXG4gICAgICB0aXRsZVBhZGRpbmcgPSBpdGVtLnRpdGxlUGFkZGluZyxcbiAgICAgIGJvdW5kcyA9IGl0ZW0uYm91bmRzLFxuICAgICAgZGwgPSB0aXRsZSAmJiBtdWx0aUxpbmVPZmZzZXQodGl0bGUpLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMCxcbiAgICAgIGksXG4gICAgICBzO1xuICB0ZW1wQm91bmRzLmNsZWFyKCkudW5pb24oYm91bmRzKTtcbiAgYm91bmRzLmNsZWFyKCk7XG4gIGlmICgoaSA9IGluZGljZXNbMF0pID4gLTEpIGJvdW5kcy51bmlvbihpdGVtLml0ZW1zW2ldLmJvdW5kcyk7XG4gIGlmICgoaSA9IGluZGljZXNbMV0pID4gLTEpIGJvdW5kcy51bmlvbihpdGVtLml0ZW1zW2ldLmJvdW5kcyk7IC8vIHBvc2l0aW9uIGF4aXMgZ3JvdXAgYW5kIHRpdGxlXG5cbiAgc3dpdGNoIChvcmllbnQpIHtcbiAgICBjYXNlIFRvcDpcbiAgICAgIHggPSBwb3NpdGlvbiB8fCAwO1xuICAgICAgeSA9IC1vZmZzZXQ7XG4gICAgICBzID0gTWF0aC5tYXgobWluRXh0ZW50LCBNYXRoLm1pbihtYXhFeHRlbnQsIC1ib3VuZHMueTEpKTtcbiAgICAgIGJvdW5kcy5hZGQoMCwgLXMpLmFkZChyYW5nZSwgMCk7XG4gICAgICBpZiAodGl0bGUpIGF4aXNUaXRsZUxheW91dCh2aWV3LCB0aXRsZSwgcywgdGl0bGVQYWRkaW5nLCBkbCwgMCwgLTEsIGJvdW5kcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTGVmdDpcbiAgICAgIHggPSAtb2Zmc2V0O1xuICAgICAgeSA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICBzID0gTWF0aC5tYXgobWluRXh0ZW50LCBNYXRoLm1pbihtYXhFeHRlbnQsIC1ib3VuZHMueDEpKTtcbiAgICAgIGJvdW5kcy5hZGQoLXMsIDApLmFkZCgwLCByYW5nZSk7XG4gICAgICBpZiAodGl0bGUpIGF4aXNUaXRsZUxheW91dCh2aWV3LCB0aXRsZSwgcywgdGl0bGVQYWRkaW5nLCBkbCwgMSwgLTEsIGJvdW5kcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUmlnaHQ6XG4gICAgICB4ID0gd2lkdGggKyBvZmZzZXQ7XG4gICAgICB5ID0gcG9zaXRpb24gfHwgMDtcbiAgICAgIHMgPSBNYXRoLm1heChtaW5FeHRlbnQsIE1hdGgubWluKG1heEV4dGVudCwgYm91bmRzLngyKSk7XG4gICAgICBib3VuZHMuYWRkKDAsIDApLmFkZChzLCByYW5nZSk7XG4gICAgICBpZiAodGl0bGUpIGF4aXNUaXRsZUxheW91dCh2aWV3LCB0aXRsZSwgcywgdGl0bGVQYWRkaW5nLCBkbCwgMSwgMSwgYm91bmRzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBCb3R0b206XG4gICAgICB4ID0gcG9zaXRpb24gfHwgMDtcbiAgICAgIHkgPSBoZWlnaHQgKyBvZmZzZXQ7XG4gICAgICBzID0gTWF0aC5tYXgobWluRXh0ZW50LCBNYXRoLm1pbihtYXhFeHRlbnQsIGJvdW5kcy55MikpO1xuICAgICAgYm91bmRzLmFkZCgwLCAwKS5hZGQocmFuZ2UsIHMpO1xuICAgICAgaWYgKHRpdGxlKSBheGlzVGl0bGVMYXlvdXQodmlldywgdGl0bGUsIHMsIHRpdGxlUGFkZGluZywgMCwgMCwgMSwgYm91bmRzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHggPSBpdGVtLng7XG4gICAgICB5ID0gaXRlbS55O1xuICB9IC8vIHVwZGF0ZSBib3VuZHNcblxuXG4gIGJvdW5kU3Ryb2tlKGJvdW5kcy50cmFuc2xhdGUoeCwgeSksIGl0ZW0pO1xuXG4gIGlmIChzZXQoaXRlbSwgJ3gnLCB4ICsgZGVsdGEpIHwgc2V0KGl0ZW0sICd5JywgeSArIGRlbHRhKSkge1xuICAgIGl0ZW0uYm91bmRzID0gdGVtcEJvdW5kcztcbiAgICB2aWV3LmRpcnR5KGl0ZW0pO1xuICAgIGl0ZW0uYm91bmRzID0gYm91bmRzO1xuICAgIHZpZXcuZGlydHkoaXRlbSk7XG4gIH1cblxuICByZXR1cm4gaXRlbS5tYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIGF4aXNUaXRsZUxheW91dCh2aWV3LCB0aXRsZSwgb2Zmc2V0LCBwYWQsIGRsLCBpc1lBeGlzLCBzaWduLCBib3VuZHMpIHtcbiAgY29uc3QgYiA9IHRpdGxlLmJvdW5kcztcblxuICBpZiAodGl0bGUuYXV0bykge1xuICAgIGNvbnN0IHYgPSBzaWduICogKG9mZnNldCArIGRsICsgcGFkKTtcbiAgICBsZXQgZHggPSAwLFxuICAgICAgICBkeSA9IDA7XG4gICAgdmlldy5kaXJ0eSh0aXRsZSk7XG4gICAgaXNZQXhpcyA/IGR4ID0gKHRpdGxlLnggfHwgMCkgLSAodGl0bGUueCA9IHYpIDogZHkgPSAodGl0bGUueSB8fCAwKSAtICh0aXRsZS55ID0gdik7XG4gICAgdGl0bGUubWFyay5ib3VuZHMuY2xlYXIoKS51bmlvbihiLnRyYW5zbGF0ZSgtZHgsIC1keSkpO1xuICAgIHZpZXcuZGlydHkodGl0bGUpO1xuICB9XG5cbiAgYm91bmRzLnVuaW9uKGIpO1xufVxuXG5jb25zdCBtaW4gPSAoYSwgYikgPT4gTWF0aC5mbG9vcihNYXRoLm1pbihhLCBiKSk7XG5cbmNvbnN0IG1heCA9IChhLCBiKSA9PiBNYXRoLmNlaWwoTWF0aC5tYXgoYSwgYikpO1xuXG5mdW5jdGlvbiBncmlkTGF5b3V0R3JvdXBzKGdyb3VwKSB7XG4gIHZhciBncm91cHMgPSBncm91cC5pdGVtcyxcbiAgICAgIG4gPSBncm91cHMubGVuZ3RoLFxuICAgICAgaSA9IDAsXG4gICAgICBtYXJrLFxuICAgICAgaXRlbXM7XG4gIGNvbnN0IHZpZXdzID0ge1xuICAgIG1hcmtzOiBbXSxcbiAgICByb3doZWFkZXJzOiBbXSxcbiAgICByb3dmb290ZXJzOiBbXSxcbiAgICBjb2xoZWFkZXJzOiBbXSxcbiAgICBjb2xmb290ZXJzOiBbXSxcbiAgICByb3d0aXRsZTogbnVsbCxcbiAgICBjb2x0aXRsZTogbnVsbFxuICB9OyAvLyBsYXlvdXQgYXhlcywgZ2F0aGVyIGxlZ2VuZHMsIGNvbGxlY3QgYm91bmRzXG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBtYXJrID0gZ3JvdXBzW2ldO1xuICAgIGl0ZW1zID0gbWFyay5pdGVtcztcblxuICAgIGlmIChtYXJrLm1hcmt0eXBlID09PSBHcm91cCkge1xuICAgICAgc3dpdGNoIChtYXJrLnJvbGUpIHtcbiAgICAgICAgY2FzZSBBeGlzUm9sZTpcbiAgICAgICAgY2FzZSBMZWdlbmRSb2xlOlxuICAgICAgICBjYXNlIFRpdGxlUm9sZTpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJvd0hlYWRlcjpcbiAgICAgICAgICB2aWV3cy5yb3doZWFkZXJzLnB1c2goLi4uaXRlbXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUm93Rm9vdGVyOlxuICAgICAgICAgIHZpZXdzLnJvd2Zvb3RlcnMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDb2xIZWFkZXI6XG4gICAgICAgICAgdmlld3MuY29saGVhZGVycy5wdXNoKC4uLml0ZW1zKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENvbEZvb3RlcjpcbiAgICAgICAgICB2aWV3cy5jb2xmb290ZXJzLnB1c2goLi4uaXRlbXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUm93VGl0bGU6XG4gICAgICAgICAgdmlld3Mucm93dGl0bGUgPSBpdGVtc1swXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENvbFRpdGxlOlxuICAgICAgICAgIHZpZXdzLmNvbHRpdGxlID0gaXRlbXNbMF07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2aWV3cy5tYXJrcy5wdXNoKC4uLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmlld3M7XG59XG5cbmZ1bmN0aW9uIGJib3hGbHVzaChpdGVtKSB7XG4gIHJldHVybiBuZXcgQm91bmRzKCkuc2V0KDAsIDAsIGl0ZW0ud2lkdGggfHwgMCwgaXRlbS5oZWlnaHQgfHwgMCk7XG59XG5cbmZ1bmN0aW9uIGJib3hGdWxsKGl0ZW0pIHtcbiAgY29uc3QgYiA9IGl0ZW0uYm91bmRzLmNsb25lKCk7XG4gIHJldHVybiBiLmVtcHR5KCkgPyBiLnNldCgwLCAwLCAwLCAwKSA6IGIudHJhbnNsYXRlKC0oaXRlbS54IHx8IDApLCAtKGl0ZW0ueSB8fCAwKSk7XG59XG5cbmZ1bmN0aW9uIGdldChvcHQsIGtleSwgZCkge1xuICBjb25zdCB2ID0gaXNPYmplY3Qob3B0KSA/IG9wdFtrZXldIDogb3B0O1xuICByZXR1cm4gdiAhPSBudWxsID8gdiA6IGQgIT09IHVuZGVmaW5lZCA/IGQgOiAwO1xufVxuXG5mdW5jdGlvbiBvZmZzZXRWYWx1ZSh2KSB7XG4gIHJldHVybiB2IDwgMCA/IE1hdGguY2VpbCgtdikgOiAwO1xufVxuXG5mdW5jdGlvbiBncmlkTGF5b3V0KHZpZXcsIGdyb3Vwcywgb3B0KSB7XG4gIHZhciBkaXJ0eSA9ICFvcHQubm9kaXJ0eSxcbiAgICAgIGJib3ggPSBvcHQuYm91bmRzID09PSBGbHVzaCA/IGJib3hGbHVzaCA6IGJib3hGdWxsLFxuICAgICAgYm91bmRzID0gdGVtcEJvdW5kcy5zZXQoMCwgMCwgMCwgMCksXG4gICAgICBhbGlnbkNvbCA9IGdldChvcHQuYWxpZ24sIENvbHVtbiksXG4gICAgICBhbGlnblJvdyA9IGdldChvcHQuYWxpZ24sIFJvdyksXG4gICAgICBwYWRDb2wgPSBnZXQob3B0LnBhZGRpbmcsIENvbHVtbiksXG4gICAgICBwYWRSb3cgPSBnZXQob3B0LnBhZGRpbmcsIFJvdyksXG4gICAgICBuY29scyA9IG9wdC5jb2x1bW5zIHx8IGdyb3Vwcy5sZW5ndGgsXG4gICAgICBucm93cyA9IG5jb2xzIDw9IDAgPyAxIDogTWF0aC5jZWlsKGdyb3Vwcy5sZW5ndGggLyBuY29scyksXG4gICAgICBuID0gZ3JvdXBzLmxlbmd0aCxcbiAgICAgIHhPZmZzZXQgPSBBcnJheShuKSxcbiAgICAgIHhFeHRlbnQgPSBBcnJheShuY29scyksXG4gICAgICB4TWF4ID0gMCxcbiAgICAgIHlPZmZzZXQgPSBBcnJheShuKSxcbiAgICAgIHlFeHRlbnQgPSBBcnJheShucm93cyksXG4gICAgICB5TWF4ID0gMCxcbiAgICAgIGR4ID0gQXJyYXkobiksXG4gICAgICBkeSA9IEFycmF5KG4pLFxuICAgICAgYm94ZXMgPSBBcnJheShuKSxcbiAgICAgIG0sXG4gICAgICBpLFxuICAgICAgYyxcbiAgICAgIHIsXG4gICAgICBiLFxuICAgICAgZyxcbiAgICAgIHB4LFxuICAgICAgcHksXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIG9mZnNldDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbmNvbHM7ICsraSkgeEV4dGVudFtpXSA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5yb3dzOyArK2kpIHlFeHRlbnRbaV0gPSAwOyAvLyBkZXRlcm1pbmUgb2Zmc2V0cyBmb3IgZWFjaCBncm91cFxuXG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGcgPSBncm91cHNbaV07XG4gICAgYiA9IGJveGVzW2ldID0gYmJveChnKTtcbiAgICBnLnggPSBnLnggfHwgMDtcbiAgICBkeFtpXSA9IDA7XG4gICAgZy55ID0gZy55IHx8IDA7XG4gICAgZHlbaV0gPSAwO1xuICAgIGMgPSBpICUgbmNvbHM7XG4gICAgciA9IH5+KGkgLyBuY29scyk7XG4gICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIHB4ID0gTWF0aC5jZWlsKGIueDIpKTtcbiAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCwgcHkgPSBNYXRoLmNlaWwoYi55MikpO1xuICAgIHhFeHRlbnRbY10gPSBNYXRoLm1heCh4RXh0ZW50W2NdLCBweCk7XG4gICAgeUV4dGVudFtyXSA9IE1hdGgubWF4KHlFeHRlbnRbcl0sIHB5KTtcbiAgICB4T2Zmc2V0W2ldID0gcGFkQ29sICsgb2Zmc2V0VmFsdWUoYi54MSk7XG4gICAgeU9mZnNldFtpXSA9IHBhZFJvdyArIG9mZnNldFZhbHVlKGIueTEpO1xuICAgIGlmIChkaXJ0eSkgdmlldy5kaXJ0eShncm91cHNbaV0pO1xuICB9IC8vIHNldCBpbml0aWFsIGFsaWdubWVudCBvZmZzZXRzXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGkgJSBuY29scyA9PT0gMCkgeE9mZnNldFtpXSA9IDA7XG4gICAgaWYgKGkgPCBuY29scykgeU9mZnNldFtpXSA9IDA7XG4gIH0gLy8gZW5mb3JjZSBjb2x1bW4gYWxpZ25tZW50IGNvbnN0cmFpbnRzXG5cblxuICBpZiAoYWxpZ25Db2wgPT09IEVhY2gpIHtcbiAgICBmb3IgKGMgPSAxOyBjIDwgbmNvbHM7ICsrYykge1xuICAgICAgZm9yIChvZmZzZXQgPSAwLCBpID0gYzsgaSA8IG47IGkgKz0gbmNvbHMpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IHhPZmZzZXRbaV0pIG9mZnNldCA9IHhPZmZzZXRbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IGM7IGkgPCBuOyBpICs9IG5jb2xzKSB7XG4gICAgICAgIHhPZmZzZXRbaV0gPSBvZmZzZXQgKyB4RXh0ZW50W2MgLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYWxpZ25Db2wgPT09IEFsbCkge1xuICAgIGZvciAob2Zmc2V0ID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChpICUgbmNvbHMgJiYgb2Zmc2V0IDwgeE9mZnNldFtpXSkgb2Zmc2V0ID0geE9mZnNldFtpXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoaSAlIG5jb2xzKSB4T2Zmc2V0W2ldID0gb2Zmc2V0ICsgeE1heDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChhbGlnbkNvbCA9IGZhbHNlLCBjID0gMTsgYyA8IG5jb2xzOyArK2MpIHtcbiAgICAgIGZvciAoaSA9IGM7IGkgPCBuOyBpICs9IG5jb2xzKSB7XG4gICAgICAgIHhPZmZzZXRbaV0gKz0geEV4dGVudFtjIC0gMV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIGVuZm9yY2Ugcm93IGFsaWdubWVudCBjb25zdHJhaW50c1xuXG5cbiAgaWYgKGFsaWduUm93ID09PSBFYWNoKSB7XG4gICAgZm9yIChyID0gMTsgciA8IG5yb3dzOyArK3IpIHtcbiAgICAgIGZvciAob2Zmc2V0ID0gMCwgaSA9IHIgKiBuY29scywgbSA9IGkgKyBuY29sczsgaSA8IG07ICsraSkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgeU9mZnNldFtpXSkgb2Zmc2V0ID0geU9mZnNldFtpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gciAqIG5jb2xzOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIHlPZmZzZXRbaV0gPSBvZmZzZXQgKyB5RXh0ZW50W3IgLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYWxpZ25Sb3cgPT09IEFsbCkge1xuICAgIGZvciAob2Zmc2V0ID0gMCwgaSA9IG5jb2xzOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAob2Zmc2V0IDwgeU9mZnNldFtpXSkgb2Zmc2V0ID0geU9mZnNldFtpXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBuY29sczsgaSA8IG47ICsraSkge1xuICAgICAgeU9mZnNldFtpXSA9IG9mZnNldCArIHlNYXg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoYWxpZ25Sb3cgPSBmYWxzZSwgciA9IDE7IHIgPCBucm93czsgKytyKSB7XG4gICAgICBmb3IgKGkgPSByICogbmNvbHMsIG0gPSBpICsgbmNvbHM7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgeU9mZnNldFtpXSArPSB5RXh0ZW50W3IgLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gcGVyZm9ybSBob3Jpem9udGFsIGdyaWQgbGF5b3V0XG5cblxuICBmb3IgKHggPSAwLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHggPSB4T2Zmc2V0W2ldICsgKGkgJSBuY29scyA/IHggOiAwKTtcbiAgICBkeFtpXSArPSB4IC0gZ3JvdXBzW2ldLng7XG4gIH0gLy8gcGVyZm9ybSB2ZXJ0aWNhbCBncmlkIGxheW91dFxuXG5cbiAgZm9yIChjID0gMDsgYyA8IG5jb2xzOyArK2MpIHtcbiAgICBmb3IgKHkgPSAwLCBpID0gYzsgaSA8IG47IGkgKz0gbmNvbHMpIHtcbiAgICAgIHkgKz0geU9mZnNldFtpXTtcbiAgICAgIGR5W2ldICs9IHkgLSBncm91cHNbaV0ueTtcbiAgICB9XG4gIH0gLy8gcGVyZm9ybSBob3Jpem9udGFsIGNlbnRlcmluZ1xuXG5cbiAgaWYgKGFsaWduQ29sICYmIGdldChvcHQuY2VudGVyLCBDb2x1bW4pICYmIG5yb3dzID4gMSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGIgPSBhbGlnbkNvbCA9PT0gQWxsID8geE1heCA6IHhFeHRlbnRbaSAlIG5jb2xzXTtcbiAgICAgIHggPSBiIC0gYm94ZXNbaV0ueDIgLSBncm91cHNbaV0ueCAtIGR4W2ldO1xuICAgICAgaWYgKHggPiAwKSBkeFtpXSArPSB4IC8gMjtcbiAgICB9XG4gIH0gLy8gcGVyZm9ybSB2ZXJ0aWNhbCBjZW50ZXJpbmdcblxuXG4gIGlmIChhbGlnblJvdyAmJiBnZXQob3B0LmNlbnRlciwgUm93KSAmJiBuY29scyAhPT0gMSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGIgPSBhbGlnblJvdyA9PT0gQWxsID8geU1heCA6IHlFeHRlbnRbfn4oaSAvIG5jb2xzKV07XG4gICAgICB5ID0gYiAtIGJveGVzW2ldLnkyIC0gZ3JvdXBzW2ldLnkgLSBkeVtpXTtcbiAgICAgIGlmICh5ID4gMCkgZHlbaV0gKz0geSAvIDI7XG4gICAgfVxuICB9IC8vIHBvc2l0aW9uIGdyaWQgcmVsYXRpdmUgdG8gYW5jaG9yXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgYm91bmRzLnVuaW9uKGJveGVzW2ldLnRyYW5zbGF0ZShkeFtpXSwgZHlbaV0pKTtcbiAgfVxuXG4gIHggPSBnZXQob3B0LmFuY2hvciwgWCk7XG4gIHkgPSBnZXQob3B0LmFuY2hvciwgWSk7XG5cbiAgc3dpdGNoIChnZXQob3B0LmFuY2hvciwgQ29sdW1uKSkge1xuICAgIGNhc2UgRW5kOlxuICAgICAgeCAtPSBib3VuZHMud2lkdGgoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBNaWRkbGU6XG4gICAgICB4IC09IGJvdW5kcy53aWR0aCgpIC8gMjtcbiAgfVxuXG4gIHN3aXRjaCAoZ2V0KG9wdC5hbmNob3IsIFJvdykpIHtcbiAgICBjYXNlIEVuZDpcbiAgICAgIHkgLT0gYm91bmRzLmhlaWdodCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE1pZGRsZTpcbiAgICAgIHkgLT0gYm91bmRzLmhlaWdodCgpIC8gMjtcbiAgfVxuXG4gIHggPSBNYXRoLnJvdW5kKHgpO1xuICB5ID0gTWF0aC5yb3VuZCh5KTsgLy8gdXBkYXRlIG1hcmsgcG9zaXRpb25zLCBib3VuZHMsIGRpcnR5XG5cbiAgYm91bmRzLmNsZWFyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGdyb3Vwc1tpXS5tYXJrLmJvdW5kcy5jbGVhcigpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGcgPSBncm91cHNbaV07XG4gICAgZy54ICs9IGR4W2ldICs9IHg7XG4gICAgZy55ICs9IGR5W2ldICs9IHk7XG4gICAgYm91bmRzLnVuaW9uKGcubWFyay5ib3VuZHMudW5pb24oZy5ib3VuZHMudHJhbnNsYXRlKGR4W2ldLCBkeVtpXSkpKTtcbiAgICBpZiAoZGlydHkpIHZpZXcuZGlydHkoZyk7XG4gIH1cblxuICByZXR1cm4gYm91bmRzO1xufVxuZnVuY3Rpb24gdHJlbGxpc0xheW91dCh2aWV3LCBncm91cCwgb3B0KSB7XG4gIHZhciB2aWV3cyA9IGdyaWRMYXlvdXRHcm91cHMoZ3JvdXApLFxuICAgICAgZ3JvdXBzID0gdmlld3MubWFya3MsXG4gICAgICBiYm94ID0gb3B0LmJvdW5kcyA9PT0gRmx1c2ggPyBib3VuZEZsdXNoIDogYm91bmRGdWxsLFxuICAgICAgb2ZmID0gb3B0Lm9mZnNldCxcbiAgICAgIG5jb2xzID0gb3B0LmNvbHVtbnMgfHwgZ3JvdXBzLmxlbmd0aCxcbiAgICAgIG5yb3dzID0gbmNvbHMgPD0gMCA/IDEgOiBNYXRoLmNlaWwoZ3JvdXBzLmxlbmd0aCAvIG5jb2xzKSxcbiAgICAgIGNlbGxzID0gbnJvd3MgKiBuY29scyxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeDIsXG4gICAgICB5MixcbiAgICAgIGFuY2hvcixcbiAgICAgIGJhbmQsXG4gICAgICBvZmZzZXQ7IC8vIC0tIGluaXRpYWwgZ3JpZCBsYXlvdXRcblxuICBjb25zdCBib3VuZHMgPSBncmlkTGF5b3V0KHZpZXcsIGdyb3Vwcywgb3B0KTtcbiAgaWYgKGJvdW5kcy5lbXB0eSgpKSBib3VuZHMuc2V0KDAsIDAsIDAsIDApOyAvLyBlbXB0eSBncmlkXG4gIC8vIC0tIGxheW91dCBncmlkIGhlYWRlcnMgYW5kIGZvb3RlcnMgLS1cbiAgLy8gcGVyZm9ybSByb3cgaGVhZGVyIGxheW91dFxuXG4gIGlmICh2aWV3cy5yb3doZWFkZXJzKSB7XG4gICAgYmFuZCA9IGdldChvcHQuaGVhZGVyQmFuZCwgUm93LCBudWxsKTtcbiAgICB4ID0gbGF5b3V0SGVhZGVycyh2aWV3LCB2aWV3cy5yb3doZWFkZXJzLCBncm91cHMsIG5jb2xzLCBucm93cywgLWdldChvZmYsICdyb3dIZWFkZXInKSwgbWluLCAwLCBiYm94LCAneDEnLCAwLCBuY29scywgMSwgYmFuZCk7XG4gIH0gLy8gcGVyZm9ybSBjb2x1bW4gaGVhZGVyIGxheW91dFxuXG5cbiAgaWYgKHZpZXdzLmNvbGhlYWRlcnMpIHtcbiAgICBiYW5kID0gZ2V0KG9wdC5oZWFkZXJCYW5kLCBDb2x1bW4sIG51bGwpO1xuICAgIHkgPSBsYXlvdXRIZWFkZXJzKHZpZXcsIHZpZXdzLmNvbGhlYWRlcnMsIGdyb3VwcywgbmNvbHMsIG5jb2xzLCAtZ2V0KG9mZiwgJ2NvbHVtbkhlYWRlcicpLCBtaW4sIDEsIGJib3gsICd5MScsIDAsIDEsIG5jb2xzLCBiYW5kKTtcbiAgfSAvLyBwZXJmb3JtIHJvdyBmb290ZXIgbGF5b3V0XG5cblxuICBpZiAodmlld3Mucm93Zm9vdGVycykge1xuICAgIGJhbmQgPSBnZXQob3B0LmZvb3RlckJhbmQsIFJvdywgbnVsbCk7XG4gICAgeDIgPSBsYXlvdXRIZWFkZXJzKHZpZXcsIHZpZXdzLnJvd2Zvb3RlcnMsIGdyb3VwcywgbmNvbHMsIG5yb3dzLCBnZXQob2ZmLCAncm93Rm9vdGVyJyksIG1heCwgMCwgYmJveCwgJ3gyJywgbmNvbHMgLSAxLCBuY29scywgMSwgYmFuZCk7XG4gIH0gLy8gcGVyZm9ybSBjb2x1bW4gZm9vdGVyIGxheW91dFxuXG5cbiAgaWYgKHZpZXdzLmNvbGZvb3RlcnMpIHtcbiAgICBiYW5kID0gZ2V0KG9wdC5mb290ZXJCYW5kLCBDb2x1bW4sIG51bGwpO1xuICAgIHkyID0gbGF5b3V0SGVhZGVycyh2aWV3LCB2aWV3cy5jb2xmb290ZXJzLCBncm91cHMsIG5jb2xzLCBuY29scywgZ2V0KG9mZiwgJ2NvbHVtbkZvb3RlcicpLCBtYXgsIDEsIGJib3gsICd5MicsIGNlbGxzIC0gbmNvbHMsIDEsIG5jb2xzLCBiYW5kKTtcbiAgfSAvLyBwZXJmb3JtIHJvdyB0aXRsZSBsYXlvdXRcblxuXG4gIGlmICh2aWV3cy5yb3d0aXRsZSkge1xuICAgIGFuY2hvciA9IGdldChvcHQudGl0bGVBbmNob3IsIFJvdyk7XG4gICAgb2Zmc2V0ID0gZ2V0KG9mZiwgJ3Jvd1RpdGxlJyk7XG4gICAgb2Zmc2V0ID0gYW5jaG9yID09PSBFbmQgPyB4MiArIG9mZnNldCA6IHggLSBvZmZzZXQ7XG4gICAgYmFuZCA9IGdldChvcHQudGl0bGVCYW5kLCBSb3csIDAuNSk7XG4gICAgbGF5b3V0VGl0bGUodmlldywgdmlld3Mucm93dGl0bGUsIG9mZnNldCwgMCwgYm91bmRzLCBiYW5kKTtcbiAgfSAvLyBwZXJmb3JtIGNvbHVtbiB0aXRsZSBsYXlvdXRcblxuXG4gIGlmICh2aWV3cy5jb2x0aXRsZSkge1xuICAgIGFuY2hvciA9IGdldChvcHQudGl0bGVBbmNob3IsIENvbHVtbik7XG4gICAgb2Zmc2V0ID0gZ2V0KG9mZiwgJ2NvbHVtblRpdGxlJyk7XG4gICAgb2Zmc2V0ID0gYW5jaG9yID09PSBFbmQgPyB5MiArIG9mZnNldCA6IHkgLSBvZmZzZXQ7XG4gICAgYmFuZCA9IGdldChvcHQudGl0bGVCYW5kLCBDb2x1bW4sIDAuNSk7XG4gICAgbGF5b3V0VGl0bGUodmlldywgdmlld3MuY29sdGl0bGUsIG9mZnNldCwgMSwgYm91bmRzLCBiYW5kKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZEZsdXNoKGl0ZW0sIGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZCA9PT0gJ3gxJyA/IGl0ZW0ueCB8fCAwIDogZmllbGQgPT09ICd5MScgPyBpdGVtLnkgfHwgMCA6IGZpZWxkID09PSAneDInID8gKGl0ZW0ueCB8fCAwKSArIChpdGVtLndpZHRoIHx8IDApIDogZmllbGQgPT09ICd5MicgPyAoaXRlbS55IHx8IDApICsgKGl0ZW0uaGVpZ2h0IHx8IDApIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBib3VuZEZ1bGwoaXRlbSwgZmllbGQpIHtcbiAgcmV0dXJuIGl0ZW0uYm91bmRzW2ZpZWxkXTtcbn1cblxuZnVuY3Rpb24gbGF5b3V0SGVhZGVycyh2aWV3LCBoZWFkZXJzLCBncm91cHMsIG5jb2xzLCBsaW1pdCwgb2Zmc2V0LCBhZ2csIGlzWCwgYm91bmQsIGJmLCBzdGFydCwgc3RyaWRlLCBiYWNrLCBiYW5kKSB7XG4gIHZhciBuID0gZ3JvdXBzLmxlbmd0aCxcbiAgICAgIGluaXQgPSAwLFxuICAgICAgZWRnZSA9IDAsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIGssXG4gICAgICBtLFxuICAgICAgYixcbiAgICAgIGgsXG4gICAgICBnLFxuICAgICAgeCxcbiAgICAgIHk7IC8vIGlmIG5vIGdyb3VwcywgZWFybHkgZXhpdCBhbmQgcmV0dXJuIDBcblxuICBpZiAoIW4pIHJldHVybiBpbml0OyAvLyBjb21wdXRlIG1hcmdpblxuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgbjsgaSArPSBzdHJpZGUpIHtcbiAgICBpZiAoZ3JvdXBzW2ldKSBpbml0ID0gYWdnKGluaXQsIGJvdW5kKGdyb3Vwc1tpXSwgYmYpKTtcbiAgfSAvLyBpZiBubyBoZWFkZXJzLCByZXR1cm4gbWFyZ2luIGNhbGN1bGF0aW9uXG5cblxuICBpZiAoIWhlYWRlcnMubGVuZ3RoKSByZXR1cm4gaW5pdDsgLy8gY2hlY2sgaWYgbnVtYmVyIG9mIGhlYWRlcnMgZXhjZWVkcyBudW1iZXIgb2Ygcm93cyBvciBjb2x1bW5zXG5cbiAgaWYgKGhlYWRlcnMubGVuZ3RoID4gbGltaXQpIHtcbiAgICB2aWV3Lndhcm4oJ0dyaWQgaGVhZGVycyBleGNlZWQgbGltaXQ6ICcgKyBsaW1pdCk7XG4gICAgaGVhZGVycyA9IGhlYWRlcnMuc2xpY2UoMCwgbGltaXQpO1xuICB9IC8vIGFwcGx5IG9mZnNldFxuXG5cbiAgaW5pdCArPSBvZmZzZXQ7IC8vIGNsZWFyIG1hcmsgYm91bmRzIGZvciBhbGwgaGVhZGVyc1xuXG4gIGZvciAoaiA9IDAsIG0gPSBoZWFkZXJzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIHZpZXcuZGlydHkoaGVhZGVyc1tqXSk7XG4gICAgaGVhZGVyc1tqXS5tYXJrLmJvdW5kcy5jbGVhcigpO1xuICB9IC8vIGxheW91dCBlYWNoIGhlYWRlclxuXG5cbiAgZm9yIChpID0gc3RhcnQsIGogPSAwLCBtID0gaGVhZGVycy5sZW5ndGg7IGogPCBtOyArK2osIGkgKz0gc3RyaWRlKSB7XG4gICAgaCA9IGhlYWRlcnNbal07XG4gICAgYiA9IGgubWFyay5ib3VuZHM7IC8vIHNlYXJjaCBmb3IgbmVhcmVzdCBncm91cCB0byBhbGlnbiB0b1xuICAgIC8vIG5lY2Vzc2FyeSBpZiB0YWJsZSBoYXMgZW1wdHkgY2VsbHNcblxuICAgIGZvciAoayA9IGk7IGsgPj0gMCAmJiAoZyA9IGdyb3Vwc1trXSkgPT0gbnVsbDsgayAtPSBiYWNrKTsgLy8gYXNzaWduIGNvb3JkaW5hdGVzIGFuZCB1cGRhdGUgYm91bmRzXG5cblxuICAgIGlmIChpc1gpIHtcbiAgICAgIHggPSBiYW5kID09IG51bGwgPyBnLnggOiBNYXRoLnJvdW5kKGcuYm91bmRzLngxICsgYmFuZCAqIGcuYm91bmRzLndpZHRoKCkpO1xuICAgICAgeSA9IGluaXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBpbml0O1xuICAgICAgeSA9IGJhbmQgPT0gbnVsbCA/IGcueSA6IE1hdGgucm91bmQoZy5ib3VuZHMueTEgKyBiYW5kICogZy5ib3VuZHMuaGVpZ2h0KCkpO1xuICAgIH1cblxuICAgIGIudW5pb24oaC5ib3VuZHMudHJhbnNsYXRlKHggLSAoaC54IHx8IDApLCB5IC0gKGgueSB8fCAwKSkpO1xuICAgIGgueCA9IHg7XG4gICAgaC55ID0geTtcbiAgICB2aWV3LmRpcnR5KGgpOyAvLyB1cGRhdGUgY3VycmVudCBlZGdlIG9mIGxheW91dCBib3VuZHNcblxuICAgIGVkZ2UgPSBhZ2coZWRnZSwgYltiZl0pO1xuICB9XG5cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmZ1bmN0aW9uIGxheW91dFRpdGxlKHZpZXcsIGcsIG9mZnNldCwgaXNYLCBib3VuZHMsIGJhbmQpIHtcbiAgaWYgKCFnKSByZXR1cm47XG4gIHZpZXcuZGlydHkoZyk7IC8vIGNvbXB1dGUgdGl0bGUgY29vcmRpbmF0ZXNcblxuICB2YXIgeCA9IG9mZnNldCxcbiAgICAgIHkgPSBvZmZzZXQ7XG4gIGlzWCA/IHggPSBNYXRoLnJvdW5kKGJvdW5kcy54MSArIGJhbmQgKiBib3VuZHMud2lkdGgoKSkgOiB5ID0gTWF0aC5yb3VuZChib3VuZHMueTEgKyBiYW5kICogYm91bmRzLmhlaWdodCgpKTsgLy8gYXNzaWduIGNvb3JkaW5hdGVzIGFuZCB1cGRhdGUgYm91bmRzXG5cbiAgZy5ib3VuZHMudHJhbnNsYXRlKHggLSAoZy54IHx8IDApLCB5IC0gKGcueSB8fCAwKSk7XG4gIGcubWFyay5ib3VuZHMuY2xlYXIoKS51bmlvbihnLmJvdW5kcyk7XG4gIGcueCA9IHg7XG4gIGcueSA9IHk7IC8vIHF1ZXVlIHRpdGxlIGZvciByZWRyYXdcblxuICB2aWV3LmRpcnR5KGcpO1xufVxuXG5mdW5jdGlvbiBsb29rdXAkMShjb25maWcsIG9yaWVudCkge1xuICBjb25zdCBvcHQgPSBjb25maWdbb3JpZW50XSB8fCB7fTtcbiAgcmV0dXJuIChrZXksIGQpID0+IG9wdFtrZXldICE9IG51bGwgPyBvcHRba2V5XSA6IGNvbmZpZ1trZXldICE9IG51bGwgPyBjb25maWdba2V5XSA6IGQ7XG59IC8vIGlmIGxlZ2VuZHMgc3BlY2lmeSBvZmZzZXQgZGlyZWN0bHksIHVzZSB0aGUgbWF4aW11bSBzcGVjaWZpZWQgdmFsdWVcblxuXG5mdW5jdGlvbiBvZmZzZXRzKGxlZ2VuZHMsIHZhbHVlKSB7XG4gIGxldCBtYXggPSAtSW5maW5pdHk7XG4gIGxlZ2VuZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpZiAoaXRlbS5vZmZzZXQgIT0gbnVsbCkgbWF4ID0gTWF0aC5tYXgobWF4LCBpdGVtLm9mZnNldCk7XG4gIH0pO1xuICByZXR1cm4gbWF4ID4gLUluZmluaXR5ID8gbWF4IDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZFBhcmFtcyhnLCBvcmllbnQsIGNvbmZpZywgeGIsIHliLCB3LCBoKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAkMShjb25maWcsIG9yaWVudCksXG4gICAgICAgIG9mZnNldCA9IG9mZnNldHMoZywgXygnb2Zmc2V0JywgMCkpLFxuICAgICAgICBhbmNob3IgPSBfKCdhbmNob3InLCBTdGFydCksXG4gICAgICAgIG11bHQgPSBhbmNob3IgPT09IEVuZCA/IDEgOiBhbmNob3IgPT09IE1pZGRsZSA/IDAuNSA6IDA7XG5cbiAgY29uc3QgcCA9IHtcbiAgICBhbGlnbjogRWFjaCxcbiAgICBib3VuZHM6IF8oJ2JvdW5kcycsIEZsdXNoKSxcbiAgICBjb2x1bW5zOiBfKCdkaXJlY3Rpb24nKSA9PT0gJ3ZlcnRpY2FsJyA/IDEgOiBnLmxlbmd0aCxcbiAgICBwYWRkaW5nOiBfKCdtYXJnaW4nLCA4KSxcbiAgICBjZW50ZXI6IF8oJ2NlbnRlcicpLFxuICAgIG5vZGlydHk6IHRydWVcbiAgfTtcblxuICBzd2l0Y2ggKG9yaWVudCkge1xuICAgIGNhc2UgTGVmdDpcbiAgICAgIHAuYW5jaG9yID0ge1xuICAgICAgICB4OiBNYXRoLmZsb29yKHhiLngxKSAtIG9mZnNldCxcbiAgICAgICAgY29sdW1uOiBFbmQsXG4gICAgICAgIHk6IG11bHQgKiAoaCB8fCB4Yi5oZWlnaHQoKSArIDIgKiB4Yi55MSksXG4gICAgICAgIHJvdzogYW5jaG9yXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJpZ2h0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IE1hdGguY2VpbCh4Yi54MikgKyBvZmZzZXQsXG4gICAgICAgIHk6IG11bHQgKiAoaCB8fCB4Yi5oZWlnaHQoKSArIDIgKiB4Yi55MSksXG4gICAgICAgIHJvdzogYW5jaG9yXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRvcDpcbiAgICAgIHAuYW5jaG9yID0ge1xuICAgICAgICB5OiBNYXRoLmZsb29yKHliLnkxKSAtIG9mZnNldCxcbiAgICAgICAgcm93OiBFbmQsXG4gICAgICAgIHg6IG11bHQgKiAodyB8fCB5Yi53aWR0aCgpICsgMiAqIHliLngxKSxcbiAgICAgICAgY29sdW1uOiBhbmNob3JcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQm90dG9tOlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHk6IE1hdGguY2VpbCh5Yi55MikgKyBvZmZzZXQsXG4gICAgICAgIHg6IG11bHQgKiAodyB8fCB5Yi53aWR0aCgpICsgMiAqIHliLngxKSxcbiAgICAgICAgY29sdW1uOiBhbmNob3JcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVG9wTGVmdDpcbiAgICAgIHAuYW5jaG9yID0ge1xuICAgICAgICB4OiBvZmZzZXQsXG4gICAgICAgIHk6IG9mZnNldFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUb3BSaWdodDpcbiAgICAgIHAuYW5jaG9yID0ge1xuICAgICAgICB4OiB3IC0gb2Zmc2V0LFxuICAgICAgICB5OiBvZmZzZXQsXG4gICAgICAgIGNvbHVtbjogRW5kXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEJvdHRvbUxlZnQ6XG4gICAgICBwLmFuY2hvciA9IHtcbiAgICAgICAgeDogb2Zmc2V0LFxuICAgICAgICB5OiBoIC0gb2Zmc2V0LFxuICAgICAgICByb3c6IEVuZFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBCb3R0b21SaWdodDpcbiAgICAgIHAuYW5jaG9yID0ge1xuICAgICAgICB4OiB3IC0gb2Zmc2V0LFxuICAgICAgICB5OiBoIC0gb2Zmc2V0LFxuICAgICAgICBjb2x1bW46IEVuZCxcbiAgICAgICAgcm93OiBFbmRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gbGVnZW5kTGF5b3V0KHZpZXcsIGxlZ2VuZCkge1xuICB2YXIgaXRlbSA9IGxlZ2VuZC5pdGVtc1swXSxcbiAgICAgIGRhdHVtID0gaXRlbS5kYXR1bSxcbiAgICAgIG9yaWVudCA9IGl0ZW0ub3JpZW50LFxuICAgICAgYm91bmRzID0gaXRlbS5ib3VuZHMsXG4gICAgICB4ID0gaXRlbS54LFxuICAgICAgeSA9IGl0ZW0ueSxcbiAgICAgIHcsXG4gICAgICBoOyAvLyBjYWNoZSBjdXJyZW50IGJvdW5kcyBmb3IgbGF0ZXIgY29tcGFyaXNvblxuXG4gIGl0ZW0uX2JvdW5kcyA/IGl0ZW0uX2JvdW5kcy5jbGVhcigpLnVuaW9uKGJvdW5kcykgOiBpdGVtLl9ib3VuZHMgPSBib3VuZHMuY2xvbmUoKTtcbiAgYm91bmRzLmNsZWFyKCk7IC8vIGFkanVzdCBsZWdlbmQgdG8gYWNjb21tb2RhdGUgcGFkZGluZyBhbmQgdGl0bGVcblxuICBsZWdlbmRHcm91cExheW91dCh2aWV3LCBpdGVtLCBpdGVtLml0ZW1zWzBdLml0ZW1zWzBdKTsgLy8gYWdncmVnYXRlIGJvdW5kcyB0byBkZXRlcm1pbmUgc2l6ZSwgYW5kIGluY2x1ZGUgb3JpZ2luXG5cbiAgYm91bmRzID0gbGVnZW5kQm91bmRzKGl0ZW0sIGJvdW5kcyk7XG4gIHcgPSAyICogaXRlbS5wYWRkaW5nO1xuICBoID0gMiAqIGl0ZW0ucGFkZGluZztcblxuICBpZiAoIWJvdW5kcy5lbXB0eSgpKSB7XG4gICAgdyA9IE1hdGguY2VpbChib3VuZHMud2lkdGgoKSArIHcpO1xuICAgIGggPSBNYXRoLmNlaWwoYm91bmRzLmhlaWdodCgpICsgaCk7XG4gIH1cblxuICBpZiAoZGF0dW0udHlwZSA9PT0gU3ltYm9scykge1xuICAgIGxlZ2VuZEVudHJ5TGF5b3V0KGl0ZW0uaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXMpO1xuICB9XG5cbiAgaWYgKG9yaWVudCAhPT0gTm9uZSkge1xuICAgIGl0ZW0ueCA9IHggPSAwO1xuICAgIGl0ZW0ueSA9IHkgPSAwO1xuICB9XG5cbiAgaXRlbS53aWR0aCA9IHc7XG4gIGl0ZW0uaGVpZ2h0ID0gaDtcbiAgYm91bmRTdHJva2UoYm91bmRzLnNldCh4LCB5LCB4ICsgdywgeSArIGgpLCBpdGVtKTtcbiAgaXRlbS5tYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKGJvdW5kcyk7XG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRCb3VuZHMoaXRlbSwgYikge1xuICAvLyBhZ2dyZWdhdGUgaXRlbSBib3VuZHNcbiAgaXRlbS5pdGVtcy5mb3JFYWNoKF8gPT4gYi51bmlvbihfLmJvdW5kcykpOyAvLyBhbmNob3IgdG8gbGVnZW5kIG9yaWdpblxuXG4gIGIueDEgPSBpdGVtLnBhZGRpbmc7XG4gIGIueTEgPSBpdGVtLnBhZGRpbmc7XG4gIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRHcm91cExheW91dCh2aWV3LCBpdGVtLCBlbnRyeSkge1xuICB2YXIgcGFkID0gaXRlbS5wYWRkaW5nLFxuICAgICAgZXggPSBwYWQgLSBlbnRyeS54LFxuICAgICAgZXkgPSBwYWQgLSBlbnRyeS55O1xuXG4gIGlmICghaXRlbS5kYXR1bS50aXRsZSkge1xuICAgIGlmIChleCB8fCBleSkgdHJhbnNsYXRlKHZpZXcsIGVudHJ5LCBleCwgZXkpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0aXRsZSA9IGl0ZW0uaXRlbXNbMV0uaXRlbXNbMF0sXG4gICAgICAgIGFuY2hvciA9IHRpdGxlLmFuY2hvcixcbiAgICAgICAgdHBhZCA9IGl0ZW0udGl0bGVQYWRkaW5nIHx8IDAsXG4gICAgICAgIHR4ID0gcGFkIC0gdGl0bGUueCxcbiAgICAgICAgdHkgPSBwYWQgLSB0aXRsZS55O1xuXG4gICAgc3dpdGNoICh0aXRsZS5vcmllbnQpIHtcbiAgICAgIGNhc2UgTGVmdDpcbiAgICAgICAgZXggKz0gTWF0aC5jZWlsKHRpdGxlLmJvdW5kcy53aWR0aCgpKSArIHRwYWQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJpZ2h0OlxuICAgICAgY2FzZSBCb3R0b206XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBleSArPSB0aXRsZS5ib3VuZHMuaGVpZ2h0KCkgKyB0cGFkO1xuICAgIH1cblxuICAgIGlmIChleCB8fCBleSkgdHJhbnNsYXRlKHZpZXcsIGVudHJ5LCBleCwgZXkpO1xuXG4gICAgc3dpdGNoICh0aXRsZS5vcmllbnQpIHtcbiAgICAgIGNhc2UgTGVmdDpcbiAgICAgICAgdHkgKz0gbGVnZW5kVGl0bGVPZmZzZXQoaXRlbSwgZW50cnksIHRpdGxlLCBhbmNob3IsIDEsIDEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSaWdodDpcbiAgICAgICAgdHggKz0gbGVnZW5kVGl0bGVPZmZzZXQoaXRlbSwgZW50cnksIHRpdGxlLCBFbmQsIDAsIDApICsgdHBhZDtcbiAgICAgICAgdHkgKz0gbGVnZW5kVGl0bGVPZmZzZXQoaXRlbSwgZW50cnksIHRpdGxlLCBhbmNob3IsIDEsIDEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBCb3R0b206XG4gICAgICAgIHR4ICs9IGxlZ2VuZFRpdGxlT2Zmc2V0KGl0ZW0sIGVudHJ5LCB0aXRsZSwgYW5jaG9yLCAwLCAwKTtcbiAgICAgICAgdHkgKz0gbGVnZW5kVGl0bGVPZmZzZXQoaXRlbSwgZW50cnksIHRpdGxlLCBFbmQsIC0xLCAwLCAxKSArIHRwYWQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0eCArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIGFuY2hvciwgMCwgMCk7XG4gICAgfVxuXG4gICAgaWYgKHR4IHx8IHR5KSB0cmFuc2xhdGUodmlldywgdGl0bGUsIHR4LCB0eSk7IC8vIHRyYW5zbGF0ZSBsZWdlbmQgaWYgdGl0bGUgcHVzaGVzIGludG8gbmVnYXRpdmUgY29vcmRpbmF0ZXNcblxuICAgIGlmICgodHggPSBNYXRoLnJvdW5kKHRpdGxlLmJvdW5kcy54MSAtIHBhZCkpIDwgMCkge1xuICAgICAgdHJhbnNsYXRlKHZpZXcsIGVudHJ5LCAtdHgsIDApO1xuICAgICAgdHJhbnNsYXRlKHZpZXcsIHRpdGxlLCAtdHgsIDApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIGFuY2hvciwgeSwgbHIsIG5vQmFyKSB7XG4gIGNvbnN0IGdyYWQgPSBpdGVtLmRhdHVtLnR5cGUgIT09ICdzeW1ib2wnLFxuICAgICAgICB2Z3JhZCA9IHRpdGxlLmRhdHVtLnZncmFkLFxuICAgICAgICBlID0gZ3JhZCAmJiAobHIgfHwgIXZncmFkKSAmJiAhbm9CYXIgPyBlbnRyeS5pdGVtc1swXSA6IGVudHJ5LFxuICAgICAgICBzID0gZS5ib3VuZHNbeSA/ICd5MicgOiAneDInXSAtIGl0ZW0ucGFkZGluZyxcbiAgICAgICAgdSA9IHZncmFkICYmIGxyID8gcyA6IDAsXG4gICAgICAgIHYgPSB2Z3JhZCAmJiBsciA/IDAgOiBzLFxuICAgICAgICBvID0geSA8PSAwID8gMCA6IG11bHRpTGluZU9mZnNldCh0aXRsZSk7XG4gIHJldHVybiBNYXRoLnJvdW5kKGFuY2hvciA9PT0gU3RhcnQgPyB1IDogYW5jaG9yID09PSBFbmQgPyB2IC0gbyA6IDAuNSAqIChzIC0gbykpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGUodmlldywgaXRlbSwgZHgsIGR5KSB7XG4gIGl0ZW0ueCArPSBkeDtcbiAgaXRlbS55ICs9IGR5O1xuICBpdGVtLmJvdW5kcy50cmFuc2xhdGUoZHgsIGR5KTtcbiAgaXRlbS5tYXJrLmJvdW5kcy50cmFuc2xhdGUoZHgsIGR5KTtcbiAgdmlldy5kaXJ0eShpdGVtKTtcbn1cblxuZnVuY3Rpb24gbGVnZW5kRW50cnlMYXlvdXQoZW50cmllcykge1xuICAvLyBnZXQgbWF4IHdpZHRocyBmb3IgZWFjaCBjb2x1bW5cbiAgY29uc3Qgd2lkdGhzID0gZW50cmllcy5yZWR1Y2UoKHcsIGcpID0+IHtcbiAgICB3W2cuY29sdW1uXSA9IE1hdGgubWF4KGcuYm91bmRzLngyIC0gZy54LCB3W2cuY29sdW1uXSB8fCAwKTtcbiAgICByZXR1cm4gdztcbiAgfSwge30pOyAvLyBzZXQgZGltZW5zaW9ucyBvZiBsZWdlbmQgZW50cnkgZ3JvdXBzXG5cbiAgZW50cmllcy5mb3JFYWNoKGcgPT4ge1xuICAgIGcud2lkdGggPSB3aWR0aHNbZy5jb2x1bW5dO1xuICAgIGcuaGVpZ2h0ID0gZy5ib3VuZHMueTIgLSBnLnk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0aXRsZUxheW91dCh2aWV3LCBtYXJrLCB3aWR0aCwgaGVpZ2h0LCB2aWV3Qm91bmRzKSB7XG4gIHZhciBncm91cCA9IG1hcmsuaXRlbXNbMF0sXG4gICAgICBmcmFtZSA9IGdyb3VwLmZyYW1lLFxuICAgICAgb3JpZW50ID0gZ3JvdXAub3JpZW50LFxuICAgICAgYW5jaG9yID0gZ3JvdXAuYW5jaG9yLFxuICAgICAgb2Zmc2V0ID0gZ3JvdXAub2Zmc2V0LFxuICAgICAgcGFkZGluZyA9IGdyb3VwLnBhZGRpbmcsXG4gICAgICB0aXRsZSA9IGdyb3VwLml0ZW1zWzBdLml0ZW1zWzBdLFxuICAgICAgc3VidGl0bGUgPSBncm91cC5pdGVtc1sxXSAmJiBncm91cC5pdGVtc1sxXS5pdGVtc1swXSxcbiAgICAgIGVuZCA9IG9yaWVudCA9PT0gTGVmdCB8fCBvcmllbnQgPT09IFJpZ2h0ID8gaGVpZ2h0IDogd2lkdGgsXG4gICAgICBzdGFydCA9IDAsXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgc3ggPSAwLFxuICAgICAgc3kgPSAwLFxuICAgICAgcG9zO1xuXG4gIGlmIChmcmFtZSAhPT0gR3JvdXApIHtcbiAgICBvcmllbnQgPT09IExlZnQgPyAoc3RhcnQgPSB2aWV3Qm91bmRzLnkyLCBlbmQgPSB2aWV3Qm91bmRzLnkxKSA6IG9yaWVudCA9PT0gUmlnaHQgPyAoc3RhcnQgPSB2aWV3Qm91bmRzLnkxLCBlbmQgPSB2aWV3Qm91bmRzLnkyKSA6IChzdGFydCA9IHZpZXdCb3VuZHMueDEsIGVuZCA9IHZpZXdCb3VuZHMueDIpO1xuICB9IGVsc2UgaWYgKG9yaWVudCA9PT0gTGVmdCkge1xuICAgIHN0YXJ0ID0gaGVpZ2h0LCBlbmQgPSAwO1xuICB9XG5cbiAgcG9zID0gYW5jaG9yID09PSBTdGFydCA/IHN0YXJ0IDogYW5jaG9yID09PSBFbmQgPyBlbmQgOiAoc3RhcnQgKyBlbmQpIC8gMjtcblxuICBpZiAoc3VidGl0bGUgJiYgc3VidGl0bGUudGV4dCkge1xuICAgIC8vIHBvc2l0aW9uIHN1YnRpdGxlXG4gICAgc3dpdGNoIChvcmllbnQpIHtcbiAgICAgIGNhc2UgVG9wOlxuICAgICAgY2FzZSBCb3R0b206XG4gICAgICAgIHN5ID0gdGl0bGUuYm91bmRzLmhlaWdodCgpICsgcGFkZGluZztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTGVmdDpcbiAgICAgICAgc3ggPSB0aXRsZS5ib3VuZHMud2lkdGgoKSArIHBhZGRpbmc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJpZ2h0OlxuICAgICAgICBzeCA9IC10aXRsZS5ib3VuZHMud2lkdGgoKSAtIHBhZGRpbmc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRlbXBCb3VuZHMuY2xlYXIoKS51bmlvbihzdWJ0aXRsZS5ib3VuZHMpO1xuICAgIHRlbXBCb3VuZHMudHJhbnNsYXRlKHN4IC0gKHN1YnRpdGxlLnggfHwgMCksIHN5IC0gKHN1YnRpdGxlLnkgfHwgMCkpO1xuXG4gICAgaWYgKHNldChzdWJ0aXRsZSwgJ3gnLCBzeCkgfCBzZXQoc3VidGl0bGUsICd5Jywgc3kpKSB7XG4gICAgICB2aWV3LmRpcnR5KHN1YnRpdGxlKTtcbiAgICAgIHN1YnRpdGxlLmJvdW5kcy5jbGVhcigpLnVuaW9uKHRlbXBCb3VuZHMpO1xuICAgICAgc3VidGl0bGUubWFyay5ib3VuZHMuY2xlYXIoKS51bmlvbih0ZW1wQm91bmRzKTtcbiAgICAgIHZpZXcuZGlydHkoc3VidGl0bGUpO1xuICAgIH1cblxuICAgIHRlbXBCb3VuZHMuY2xlYXIoKS51bmlvbihzdWJ0aXRsZS5ib3VuZHMpO1xuICB9IGVsc2Uge1xuICAgIHRlbXBCb3VuZHMuY2xlYXIoKTtcbiAgfVxuXG4gIHRlbXBCb3VuZHMudW5pb24odGl0bGUuYm91bmRzKTsgLy8gcG9zaXRpb24gdGl0bGUgZ3JvdXBcblxuICBzd2l0Y2ggKG9yaWVudCkge1xuICAgIGNhc2UgVG9wOlxuICAgICAgeCA9IHBvcztcbiAgICAgIHkgPSB2aWV3Qm91bmRzLnkxIC0gdGVtcEJvdW5kcy5oZWlnaHQoKSAtIG9mZnNldDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMZWZ0OlxuICAgICAgeCA9IHZpZXdCb3VuZHMueDEgLSB0ZW1wQm91bmRzLndpZHRoKCkgLSBvZmZzZXQ7XG4gICAgICB5ID0gcG9zO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJpZ2h0OlxuICAgICAgeCA9IHZpZXdCb3VuZHMueDIgKyB0ZW1wQm91bmRzLndpZHRoKCkgKyBvZmZzZXQ7XG4gICAgICB5ID0gcG9zO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEJvdHRvbTpcbiAgICAgIHggPSBwb3M7XG4gICAgICB5ID0gdmlld0JvdW5kcy55MiArIG9mZnNldDtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHggPSBncm91cC54O1xuICAgICAgeSA9IGdyb3VwLnk7XG4gIH1cblxuICBpZiAoc2V0KGdyb3VwLCAneCcsIHgpIHwgc2V0KGdyb3VwLCAneScsIHkpKSB7XG4gICAgdGVtcEJvdW5kcy50cmFuc2xhdGUoeCwgeSk7XG4gICAgdmlldy5kaXJ0eShncm91cCk7XG4gICAgZ3JvdXAuYm91bmRzLmNsZWFyKCkudW5pb24odGVtcEJvdW5kcyk7XG4gICAgbWFyay5ib3VuZHMuY2xlYXIoKS51bmlvbih0ZW1wQm91bmRzKTtcbiAgICB2aWV3LmRpcnR5KGdyb3VwKTtcbiAgfVxuXG4gIHJldHVybiBncm91cC5ib3VuZHM7XG59XG5cbi8qKlxuICogTGF5b3V0IHZpZXcgZWxlbWVudHMgc3VjaCBhcyBheGVzIGFuZCBsZWdlbmRzLlxuICogQWxzbyBwZXJmb3JtcyBzaXplIGFkanVzdG1lbnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1hcmsgLSBTY2VuZWdyYXBoIG1hcmsgb2YgZ3JvdXBzIHRvIGxheW91dC5cbiAqL1xuXG5mdW5jdGlvbiBWaWV3TGF5b3V0KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoVmlld0xheW91dCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IHZpZXcgPSBwdWxzZS5kYXRhZmxvdztcblxuICAgIF8ubWFyay5pdGVtcy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICAgIGlmIChfLmxheW91dCkgdHJlbGxpc0xheW91dCh2aWV3LCBncm91cCwgXy5sYXlvdXQpO1xuICAgICAgbGF5b3V0R3JvdXAodmlldywgZ3JvdXAsIF8pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNob3VsZFJlZmxvdyhfLm1hcmsuZ3JvdXApID8gcHVsc2UucmVmbG93KCkgOiBwdWxzZTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gc2hvdWxkUmVmbG93KGdyb3VwKSB7XG4gIC8vIFdlIHR5cGljYWxseSBzaG91bGQgcmVmbG93IGlmIGxheW91dCBpcyBpbnZva2VkICgjMjU2OCksIGFzIGNoaWxkIGl0ZW1zXG4gIC8vIG1heSBoYXZlIHJlc2l6ZWQgYW5kIHJlZmxvdyBlbnN1cmVzIGdyb3VwIGJvdW5kcyBhcmUgcmUtY2FsY3VsYXRlZC5cbiAgLy8gSG93ZXZlciwgbGVnZW5kIGVudHJpZXMgaGF2ZSBhIHNwZWNpYWwgZXhjZXB0aW9uIHRvIGF2b2lkIGluc3RhYmlsaXR5LlxuICAvLyBGb3IgZXhhbXBsZSwgaWYgYSBzZWxlY3RlZCBsZWdlbmQgc3ltYm9sIGdhaW5zIGEgc3Ryb2tlIG9uIGhvdmVyLFxuICAvLyB3ZSBkb24ndCB3YW50IHRvIHJlLXBvc2l0aW9uIHN1YnNlcXVlbnQgZWxlbWVudHMgaW4gdGhlIGxlZ2VuZC5cbiAgcmV0dXJuIGdyb3VwICYmIGdyb3VwLm1hcmsucm9sZSAhPT0gJ2xlZ2VuZC1lbnRyeSc7XG59XG5cbmZ1bmN0aW9uIGxheW91dEdyb3VwKHZpZXcsIGdyb3VwLCBfKSB7XG4gIHZhciBpdGVtcyA9IGdyb3VwLml0ZW1zLFxuICAgICAgd2lkdGggPSBNYXRoLm1heCgwLCBncm91cC53aWR0aCB8fCAwKSxcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KDAsIGdyb3VwLmhlaWdodCB8fCAwKSxcbiAgICAgIHZpZXdCb3VuZHMgPSBuZXcgQm91bmRzKCkuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgeEJvdW5kcyA9IHZpZXdCb3VuZHMuY2xvbmUoKSxcbiAgICAgIHlCb3VuZHMgPSB2aWV3Qm91bmRzLmNsb25lKCksXG4gICAgICBsZWdlbmRzID0gW10sXG4gICAgICB0aXRsZSxcbiAgICAgIG1hcmssXG4gICAgICBvcmllbnQsXG4gICAgICBiLFxuICAgICAgaSxcbiAgICAgIG47IC8vIGxheW91dCBheGVzLCBnYXRoZXIgbGVnZW5kcywgY29sbGVjdCBib3VuZHNcblxuICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgbWFyayA9IGl0ZW1zW2ldO1xuXG4gICAgc3dpdGNoIChtYXJrLnJvbGUpIHtcbiAgICAgIGNhc2UgQXhpc1JvbGU6XG4gICAgICAgIGIgPSBpc1lBeGlzKG1hcmspID8geEJvdW5kcyA6IHlCb3VuZHM7XG4gICAgICAgIGIudW5pb24oYXhpc0xheW91dCh2aWV3LCBtYXJrLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRpdGxlUm9sZTpcbiAgICAgICAgdGl0bGUgPSBtYXJrO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMZWdlbmRSb2xlOlxuICAgICAgICBsZWdlbmRzLnB1c2gobGVnZW5kTGF5b3V0KHZpZXcsIG1hcmspKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRnJhbWVSb2xlOlxuICAgICAgY2FzZSBTY29wZVJvbGU6XG4gICAgICBjYXNlIFJvd0hlYWRlcjpcbiAgICAgIGNhc2UgUm93Rm9vdGVyOlxuICAgICAgY2FzZSBSb3dUaXRsZTpcbiAgICAgIGNhc2UgQ29sSGVhZGVyOlxuICAgICAgY2FzZSBDb2xGb290ZXI6XG4gICAgICBjYXNlIENvbFRpdGxlOlxuICAgICAgICB4Qm91bmRzLnVuaW9uKG1hcmsuYm91bmRzKTtcbiAgICAgICAgeUJvdW5kcy51bmlvbihtYXJrLmJvdW5kcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2aWV3Qm91bmRzLnVuaW9uKG1hcmsuYm91bmRzKTtcbiAgICB9XG4gIH0gLy8gbGF5b3V0IGxlZ2VuZHMsIGFkanVzdCB2aWV3Qm91bmRzXG5cblxuICBpZiAobGVnZW5kcy5sZW5ndGgpIHtcbiAgICAvLyBncm91cCBsZWdlbmRzIGJ5IG9yaWVudFxuICAgIGNvbnN0IGwgPSB7fTtcbiAgICBsZWdlbmRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBvcmllbnQgPSBpdGVtLm9yaWVudCB8fCBSaWdodDtcbiAgICAgIGlmIChvcmllbnQgIT09IE5vbmUpIChsW29yaWVudF0gfHwgKGxbb3JpZW50XSA9IFtdKSkucHVzaChpdGVtKTtcbiAgICB9KTsgLy8gcGVyZm9ybSBncmlkIGxheW91dCBmb3IgZWFjaCBvcmllbnQgZ3JvdXBcblxuICAgIGZvciAoY29uc3Qgb3JpZW50IGluIGwpIHtcbiAgICAgIGNvbnN0IGcgPSBsW29yaWVudF07XG4gICAgICBncmlkTGF5b3V0KHZpZXcsIGcsIGxlZ2VuZFBhcmFtcyhnLCBvcmllbnQsIF8ubGVnZW5kcywgeEJvdW5kcywgeUJvdW5kcywgd2lkdGgsIGhlaWdodCkpO1xuICAgIH0gLy8gdXBkYXRlIHZpZXcgYm91bmRzXG5cblxuICAgIGxlZ2VuZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGNvbnN0IGIgPSBpdGVtLmJvdW5kcztcblxuICAgICAgaWYgKCFiLmVxdWFscyhpdGVtLl9ib3VuZHMpKSB7XG4gICAgICAgIGl0ZW0uYm91bmRzID0gaXRlbS5fYm91bmRzO1xuICAgICAgICB2aWV3LmRpcnR5KGl0ZW0pOyAvLyBkaXJ0eSBwcmV2aW91cyBsb2NhdGlvblxuXG4gICAgICAgIGl0ZW0uYm91bmRzID0gYjtcbiAgICAgICAgdmlldy5kaXJ0eShpdGVtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uYXV0b3NpemUgJiYgXy5hdXRvc2l6ZS50eXBlID09PSBGaXQpIHtcbiAgICAgICAgLy8gRm9yIGF1dG9zaXplIGZpdCwgaW5jb3Jwb3JhdGUgdGhlIG9ydGhvZ29uYWwgZGltZW5zaW9uIG9ubHkuXG4gICAgICAgIC8vIExlZ2VuZHMgdGhhdCBvdmVycnVuIHRoZSBjaGFydCBhcmVhIHdpbGwgdGhlbiBiZSBjbGlwcGVkO1xuICAgICAgICAvLyBvdGhlcndpc2UgdGhlIGNoYXJ0IGFyZWEgZ2V0cyByZWR1Y2VkIHRvIG5vdGhpbmchXG4gICAgICAgIHN3aXRjaCAoaXRlbS5vcmllbnQpIHtcbiAgICAgICAgICBjYXNlIExlZnQ6XG4gICAgICAgICAgY2FzZSBSaWdodDpcbiAgICAgICAgICAgIHZpZXdCb3VuZHMuYWRkKGIueDEsIDApLmFkZChiLngyLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBUb3A6XG4gICAgICAgICAgY2FzZSBCb3R0b206XG4gICAgICAgICAgICB2aWV3Qm91bmRzLmFkZCgwLCBiLnkxKS5hZGQoMCwgYi55Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXdCb3VuZHMudW5pb24oYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gLy8gY29tYmluZSBib3VuZGluZyBib3hlc1xuXG5cbiAgdmlld0JvdW5kcy51bmlvbih4Qm91bmRzKS51bmlvbih5Qm91bmRzKTsgLy8gbGF5b3V0IHRpdGxlLCBhZGp1c3QgYm91bmRzXG5cbiAgaWYgKHRpdGxlKSB7XG4gICAgdmlld0JvdW5kcy51bmlvbih0aXRsZUxheW91dCh2aWV3LCB0aXRsZSwgd2lkdGgsIGhlaWdodCwgdmlld0JvdW5kcykpO1xuICB9IC8vIG92ZXJyaWRlIGFnZ3JlZ2F0ZWQgdmlldyBib3VuZHMgaWYgY29udGVudCBpcyBjbGlwcGVkXG5cblxuICBpZiAoZ3JvdXAuY2xpcCkge1xuICAgIHZpZXdCb3VuZHMuc2V0KDAsIDAsIGdyb3VwLndpZHRoIHx8IDAsIGdyb3VwLmhlaWdodCB8fCAwKTtcbiAgfSAvLyBwZXJmb3JtIHNpemUgYWRqdXN0bWVudFxuXG5cbiAgdmlld1NpemVMYXlvdXQodmlldywgZ3JvdXAsIHZpZXdCb3VuZHMsIF8pO1xufVxuXG5mdW5jdGlvbiB2aWV3U2l6ZUxheW91dCh2aWV3LCBncm91cCwgdmlld0JvdW5kcywgXykge1xuICBjb25zdCBhdXRvID0gXy5hdXRvc2l6ZSB8fCB7fSxcbiAgICAgICAgdHlwZSA9IGF1dG8udHlwZTtcbiAgaWYgKHZpZXcuX2F1dG9zaXplIDwgMSB8fCAhdHlwZSkgcmV0dXJuO1xuICBsZXQgdmlld1dpZHRoID0gdmlldy5fd2lkdGgsXG4gICAgICB2aWV3SGVpZ2h0ID0gdmlldy5faGVpZ2h0LFxuICAgICAgd2lkdGggPSBNYXRoLm1heCgwLCBncm91cC53aWR0aCB8fCAwKSxcbiAgICAgIGxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoLXZpZXdCb3VuZHMueDEpKSxcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KDAsIGdyb3VwLmhlaWdodCB8fCAwKSxcbiAgICAgIHRvcCA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgtdmlld0JvdW5kcy55MSkpO1xuICBjb25zdCByaWdodCA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh2aWV3Qm91bmRzLngyIC0gd2lkdGgpKSxcbiAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHZpZXdCb3VuZHMueTIgLSBoZWlnaHQpKTtcblxuICBpZiAoYXV0by5jb250YWlucyA9PT0gUGFkZGluZykge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB2aWV3LnBhZGRpbmcoKTtcbiAgICB2aWV3V2lkdGggLT0gcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcbiAgICB2aWV3SGVpZ2h0IC09IHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gIH1cblxuICBpZiAodHlwZSA9PT0gTm9uZSkge1xuICAgIGxlZnQgPSAwO1xuICAgIHRvcCA9IDA7XG4gICAgd2lkdGggPSB2aWV3V2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlld0hlaWdodDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBGaXQpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHZpZXdXaWR0aCAtIGxlZnQgLSByaWdodCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgdmlld0hlaWdodCAtIHRvcCAtIGJvdHRvbSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRml0WCkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgdmlld1dpZHRoIC0gbGVmdCAtIHJpZ2h0KTtcbiAgICB2aWV3SGVpZ2h0ID0gaGVpZ2h0ICsgdG9wICsgYm90dG9tO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEZpdFkpIHtcbiAgICB2aWV3V2lkdGggPSB3aWR0aCArIGxlZnQgKyByaWdodDtcbiAgICBoZWlnaHQgPSBNYXRoLm1heCgwLCB2aWV3SGVpZ2h0IC0gdG9wIC0gYm90dG9tKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBQYWQpIHtcbiAgICB2aWV3V2lkdGggPSB3aWR0aCArIGxlZnQgKyByaWdodDtcbiAgICB2aWV3SGVpZ2h0ID0gaGVpZ2h0ICsgdG9wICsgYm90dG9tO1xuICB9XG5cbiAgdmlldy5fcmVzaXplVmlldyh2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIFtsZWZ0LCB0b3BdLCBhdXRvLnJlc2l6ZSk7XG59XG5cbmV4cG9ydCB7IEJvdW5kIGFzIGJvdW5kLCBJZGVudGlmaWVyIGFzIGlkZW50aWZpZXIsIE1hcmsgYXMgbWFyaywgT3ZlcmxhcCBhcyBvdmVybGFwLCBSZW5kZXIgYXMgcmVuZGVyLCBWaWV3TGF5b3V0IGFzIHZpZXdsYXlvdXQgfTtcbiIsImltcG9ydCB7IGlzU3RyaW5nLCBoYXNPd25Qcm9wZXJ0eSwgZXJyb3IsIHRydXRoeSwgY29uc3RhbnQsIGV4dGVuZCwgaXNBcnJheSwgdG9TZXQsIGFycmF5LCBpc09iamVjdCwgZGVib3VuY2UsIGlzRGF0ZSwgaW5oZXJpdHMsIHN0cmluZ1ZhbHVlIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGNoYW5nZXNldCwgaXNDaGFuZ2VTZXQsIEV2ZW50U3RyZWFtLCB0cmFuc2Zvcm1zLCBEYXRhZmxvdywgYXN5bmNDYWxsYmFjayB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgcG9pbnQsIHJlbmRlck1vZHVsZSwgQ2FudmFzSGFuZGxlciwgUmVuZGVyVHlwZSwgU2NlbmVncmFwaCB9IGZyb20gJ3ZlZ2Etc2NlbmVncmFwaCc7XG5pbXBvcnQgeyB0aWNrU3RlcCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IGZ1bmN0aW9uQ29udGV4dCB9IGZyb20gJ3ZlZ2EtZnVuY3Rpb25zJztcbmltcG9ydCB7IGNvbnRleHQgfSBmcm9tICd2ZWdhLXJ1bnRpbWUnO1xuaW1wb3J0IHsgaW50ZXJ2YWwgfSBmcm9tICdkMy10aW1lcic7XG5pbXBvcnQgeyBsb2NhbGUgfSBmcm9tICd2ZWdhLWZvcm1hdCc7XG5cbi8vIGluaXRpYWxpemUgYXJpYSByb2xlIGFuZCBsYWJlbCBhdHRyaWJ1dGVzXG5mdW5jdGlvbiBpbml0aWFsaXplQXJpYSh2aWV3KSB7XG4gIGNvbnN0IGVsID0gdmlldy5jb250YWluZXIoKTtcblxuICBpZiAoZWwpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JhcGhpY3MtZG9jdW1lbnQnKTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcm9sZURlc2NyaXB0aW9uJywgJ3Zpc3VhbGl6YXRpb24nKTtcbiAgICBhcmlhTGFiZWwoZWwsIHZpZXcuZGVzY3JpcHRpb24oKSk7XG4gIH1cbn0gLy8gdXBkYXRlIGFyaWEtbGFiZWwgaWYgd2UgaGF2ZSBhIERPTSBjb250YWluZXIgZWxlbWVudFxuXG5mdW5jdGlvbiBhcmlhTGFiZWwoZWwsIGRlc2MpIHtcbiAgaWYgKGVsKSBkZXNjID09IG51bGwgPyBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSA6IGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGRlc2MpO1xufVxuXG5mdW5jdGlvbiBiYWNrZ3JvdW5kICh2aWV3KSB7XG4gIC8vIHJlc3BvbmQgdG8gYmFja2dyb3VuZCBzaWduYWxcbiAgdmlldy5hZGQobnVsbCwgXyA9PiB7XG4gICAgdmlldy5fYmFja2dyb3VuZCA9IF8uYmc7XG4gICAgdmlldy5fcmVzaXplID0gMTtcbiAgICByZXR1cm4gXy5iZztcbiAgfSwge1xuICAgIGJnOiB2aWV3Ll9zaWduYWxzLmJhY2tncm91bmRcbiAgfSk7XG59XG5cbmNvbnN0IERlZmF1bHQgPSAnZGVmYXVsdCc7XG5mdW5jdGlvbiBjdXJzb3IgKHZpZXcpIHtcbiAgLy8gZ2V0IGN1cnNvciBzaWduYWwsIGFkZCB0byBkYXRhZmxvdyBpZiBuZWVkZWRcbiAgY29uc3QgY3Vyc29yID0gdmlldy5fc2lnbmFscy5jdXJzb3IgfHwgKHZpZXcuX3NpZ25hbHMuY3Vyc29yID0gdmlldy5hZGQoe1xuICAgIHVzZXI6IERlZmF1bHQsXG4gICAgaXRlbTogbnVsbFxuICB9KSk7IC8vIGV2YWx1YXRlIGN1cnNvciBvbiBlYWNoIG1vdXNlbW92ZSBldmVudFxuXG4gIHZpZXcub24odmlldy5ldmVudHMoJ3ZpZXcnLCAnbW91c2Vtb3ZlJyksIGN1cnNvciwgKF8sIGV2ZW50KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IudmFsdWUsXG4gICAgICAgICAgdXNlciA9IHZhbHVlID8gaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiB2YWx1ZS51c2VyIDogRGVmYXVsdCxcbiAgICAgICAgICBpdGVtID0gZXZlbnQuaXRlbSAmJiBldmVudC5pdGVtLmN1cnNvciB8fCBudWxsO1xuICAgIHJldHVybiB2YWx1ZSAmJiB1c2VyID09PSB2YWx1ZS51c2VyICYmIGl0ZW0gPT0gdmFsdWUuaXRlbSA/IHZhbHVlIDoge1xuICAgICAgdXNlcjogdXNlcixcbiAgICAgIGl0ZW06IGl0ZW1cbiAgICB9O1xuICB9KTsgLy8gd2hlbiBjdXJzb3Igc2lnbmFsIHVwZGF0ZXMsIHNldCB2aXNpYmxlIGN1cnNvclxuXG4gIHZpZXcuYWRkKG51bGwsIGZ1bmN0aW9uIChfKSB7XG4gICAgbGV0IHVzZXIgPSBfLmN1cnNvcixcbiAgICAgICAgaXRlbSA9IHRoaXMudmFsdWU7XG5cbiAgICBpZiAoIWlzU3RyaW5nKHVzZXIpKSB7XG4gICAgICBpdGVtID0gdXNlci5pdGVtO1xuICAgICAgdXNlciA9IHVzZXIudXNlcjtcbiAgICB9XG5cbiAgICBzZXRDdXJzb3IodmlldywgdXNlciAmJiB1c2VyICE9PSBEZWZhdWx0ID8gdXNlciA6IGl0ZW0gfHwgdXNlcik7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH0sIHtcbiAgICBjdXJzb3I6IGN1cnNvclxuICB9KTtcbn1cbmZ1bmN0aW9uIHNldEN1cnNvcih2aWV3LCBjdXJzb3IpIHtcbiAgY29uc3QgZWwgPSB2aWV3Lmdsb2JhbEN1cnNvcigpID8gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5ib2R5IDogdmlldy5jb250YWluZXIoKTtcblxuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gY3Vyc29yID09IG51bGwgPyBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY3Vyc29yJykgOiBlbC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0YXJlZih2aWV3LCBuYW1lKSB7XG4gIHZhciBkYXRhID0gdmlldy5fcnVudGltZS5kYXRhO1xuXG4gIGlmICghaGFzT3duUHJvcGVydHkoZGF0YSwgbmFtZSkpIHtcbiAgICBlcnJvcignVW5yZWNvZ25pemVkIGRhdGEgc2V0OiAnICsgbmFtZSk7XG4gIH1cblxuICByZXR1cm4gZGF0YVtuYW1lXTtcbn1cbmZ1bmN0aW9uIGRhdGEobmFtZSwgdmFsdWVzKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGRhdGFyZWYodGhpcywgbmFtZSkudmFsdWVzLnZhbHVlIDogY2hhbmdlLmNhbGwodGhpcywgbmFtZSwgY2hhbmdlc2V0KCkucmVtb3ZlKHRydXRoeSkuaW5zZXJ0KHZhbHVlcykpO1xufVxuZnVuY3Rpb24gY2hhbmdlKG5hbWUsIGNoYW5nZXMpIHtcbiAgaWYgKCFpc0NoYW5nZVNldChjaGFuZ2VzKSkge1xuICAgIGVycm9yKCdTZWNvbmQgYXJndW1lbnQgdG8gY2hhbmdlcyBtdXN0IGJlIGEgY2hhbmdlc2V0LicpO1xuICB9XG5cbiAgY29uc3QgZGF0YXNldCA9IGRhdGFyZWYodGhpcywgbmFtZSk7XG4gIGRhdGFzZXQubW9kaWZpZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcy5wdWxzZShkYXRhc2V0LmlucHV0LCBjaGFuZ2VzKTtcbn1cbmZ1bmN0aW9uIGluc2VydChuYW1lLCBfKSB7XG4gIHJldHVybiBjaGFuZ2UuY2FsbCh0aGlzLCBuYW1lLCBjaGFuZ2VzZXQoKS5pbnNlcnQoXykpO1xufVxuZnVuY3Rpb24gcmVtb3ZlKG5hbWUsIF8pIHtcbiAgcmV0dXJuIGNoYW5nZS5jYWxsKHRoaXMsIG5hbWUsIGNoYW5nZXNldCgpLnJlbW92ZShfKSk7XG59XG5cbmZ1bmN0aW9uIHdpZHRoKHZpZXcpIHtcbiAgdmFyIHBhZGRpbmcgPSB2aWV3LnBhZGRpbmcoKTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIHZpZXcuX3ZpZXdXaWR0aCArIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQpO1xufVxuZnVuY3Rpb24gaGVpZ2h0KHZpZXcpIHtcbiAgdmFyIHBhZGRpbmcgPSB2aWV3LnBhZGRpbmcoKTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIHZpZXcuX3ZpZXdIZWlnaHQgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tKTtcbn1cbmZ1bmN0aW9uIG9mZnNldCh2aWV3KSB7XG4gIHZhciBwYWRkaW5nID0gdmlldy5wYWRkaW5nKCksXG4gICAgICBvcmlnaW4gPSB2aWV3Ll9vcmlnaW47XG4gIHJldHVybiBbcGFkZGluZy5sZWZ0ICsgb3JpZ2luWzBdLCBwYWRkaW5nLnRvcCArIG9yaWdpblsxXV07XG59XG5mdW5jdGlvbiByZXNpemVSZW5kZXJlcih2aWV3KSB7XG4gIHZhciBvcmlnaW4gPSBvZmZzZXQodmlldyksXG4gICAgICB3ID0gd2lkdGgodmlldyksXG4gICAgICBoID0gaGVpZ2h0KHZpZXcpO1xuXG4gIHZpZXcuX3JlbmRlcmVyLmJhY2tncm91bmQodmlldy5iYWNrZ3JvdW5kKCkpO1xuXG4gIHZpZXcuX3JlbmRlcmVyLnJlc2l6ZSh3LCBoLCBvcmlnaW4pO1xuXG4gIHZpZXcuX2hhbmRsZXIub3JpZ2luKG9yaWdpbik7XG5cbiAgdmlldy5fcmVzaXplTGlzdGVuZXJzLmZvckVhY2goaGFuZGxlciA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGhhbmRsZXIodywgaCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHZpZXcuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogRXh0ZW5kIGFuIGV2ZW50IHdpdGggYWRkaXRpb25hbCB2aWV3LXNwZWNpZmljIG1ldGhvZHMuXG4gKiBBZGRzIGEgbmV3IHByb3BlcnR5ICgndmVnYScpIHRvIGFuIGV2ZW50IHRoYXQgcHJvdmlkZXMgYSBudW1iZXJcbiAqIG9mIG1ldGhvZHMgZm9yIHF1ZXJ5aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGludGVyYWN0aW9uLlxuICogVGhlIHZlZ2Egb2JqZWN0IHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAqICAgdmlldyAtIFJldHVybnMgdGhlIGJhY2tpbmcgVmlldyBpbnN0YW5jZS5cbiAqICAgaXRlbSAtIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2NlbmVncmFwaCBpdGVtIChpZiBhbnkpLlxuICogICBncm91cCAtIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2NlbmVncmFwaCBncm91cCAoaWYgYW55KS5cbiAqICAgICBUaGlzIG1ldGhvZCBhY2NlcHRzIGEgc2luZ2xlIHN0cmluZy10eXBlZCBhcmd1bWVudCBpbmRpY2F0aW5nIHRoZSBuYW1lXG4gKiAgICAgb2YgdGhlIGRlc2lyZWQgcGFyZW50IGdyb3VwLiBUaGUgc2NlbmVncmFwaCB3aWxsIGJlIHRyYXZlcnNlZCBmcm9tXG4gKiAgICAgdGhlIGl0ZW0gdXAgdG93YXJkcyB0aGUgcm9vdCB0byBzZWFyY2ggZm9yIGEgbWF0Y2hpbmcgZ3JvdXAuIElmIG5vXG4gKiAgICAgYXJndW1lbnQgaXMgcHJvdmlkZWQgdGhlIGVuY2xvc2luZyBncm91cCBmb3IgdGhlIGFjdGl2ZSBpdGVtIGlzXG4gKiAgICAgcmV0dXJuZWQsIHVubGVzcyB0aGUgaXRlbSBpdCBpdHNlbGYgYSBncm91cCwgaW4gd2hpY2ggY2FzZSBpdCBpc1xuICogICAgIHJldHVybmVkIGRpcmVjdGx5LlxuICogICB4eSAtIFJldHVybnMgYSB0d28tZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGZvclxuICogICAgIG1vdXNlIG9yIHRvdWNoIGV2ZW50cy4gRm9yIHRvdWNoIGV2ZW50cywgdGhpcyBpcyBiYXNlZCBvbiB0aGUgZmlyc3RcbiAqICAgICBlbGVtZW50cyBpbiB0aGUgY2hhbmdlZFRvdWNoZXMgYXJyYXkuIFRoaXMgbWV0aG9kIGFjY2VwdHMgYSBzaW5nbGVcbiAqICAgICBhcmd1bWVudDogZWl0aGVyIGFuIGl0ZW0gaW5zdGFuY2Ugb3IgbWFyayBuYW1lIHRoYXQgc2hvdWxkIHNlcnZlIGFzXG4gKiAgICAgdGhlIHJlZmVyZW5jZSBjb29yZGluYXRlIHN5c3RlbS4gSWYgbm8gYXJndW1lbnQgaXMgcHJvdmlkZWQgdGhlXG4gKiAgICAgdG9wLWxldmVsIHZpZXcgY29vcmRpbmF0ZSBzeXN0ZW0gaXMgYXNzdW1lZC5cbiAqICAgeCAtIFJldHVybnMgdGhlIGN1cnJlbnQgeC1jb29yZGluYXRlLCBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB4eS5cbiAqICAgeSAtIFJldHVybnMgdGhlIGN1cnJlbnQgeS1jb29yZGluYXRlLCBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB4eS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGlucHV0IGV2ZW50IHRvIGV4dGVuZC5cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBjdXJyZW50bHkgYWN0aXZlIHNjZW5lZ3JhcGggaXRlbSAoaWYgYW55KS5cbiAqIEByZXR1cm4ge0V2ZW50fSAtIFRoZSBleHRlbmRlZCBpbnB1dCBldmVudC5cbiAqL1xuXG5mdW5jdGlvbiBldmVudEV4dGVuZCAodmlldywgZXZlbnQsIGl0ZW0pIHtcbiAgdmFyIHIgPSB2aWV3Ll9yZW5kZXJlcixcbiAgICAgIGVsID0gciAmJiByLmNhbnZhcygpLFxuICAgICAgcCxcbiAgICAgIGUsXG4gICAgICB0cmFuc2xhdGU7XG5cbiAgaWYgKGVsKSB7XG4gICAgdHJhbnNsYXRlID0gb2Zmc2V0KHZpZXcpO1xuICAgIGUgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XG4gICAgcCA9IHBvaW50KGUsIGVsKTtcbiAgICBwWzBdIC09IHRyYW5zbGF0ZVswXTtcbiAgICBwWzFdIC09IHRyYW5zbGF0ZVsxXTtcbiAgfVxuXG4gIGV2ZW50LmRhdGFmbG93ID0gdmlldztcbiAgZXZlbnQuaXRlbSA9IGl0ZW07XG4gIGV2ZW50LnZlZ2EgPSBleHRlbnNpb24odmlldywgaXRlbSwgcCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5zaW9uKHZpZXcsIGl0ZW0sIHBvaW50KSB7XG4gIGNvbnN0IGl0ZW1Hcm91cCA9IGl0ZW0gPyBpdGVtLm1hcmsubWFya3R5cGUgPT09ICdncm91cCcgPyBpdGVtIDogaXRlbS5tYXJrLmdyb3VwIDogbnVsbDtcblxuICBmdW5jdGlvbiBncm91cChuYW1lKSB7XG4gICAgdmFyIGcgPSBpdGVtR3JvdXAsXG4gICAgICAgIGk7XG4gICAgaWYgKG5hbWUpIGZvciAoaSA9IGl0ZW07IGk7IGkgPSBpLm1hcmsuZ3JvdXApIHtcbiAgICAgIGlmIChpLm1hcmsubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBnID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnICYmIGcubWFyayAmJiBnLm1hcmsuaW50ZXJhY3RpdmUgPyBnIDoge307XG4gIH1cblxuICBmdW5jdGlvbiB4eShpdGVtKSB7XG4gICAgaWYgKCFpdGVtKSByZXR1cm4gcG9pbnQ7XG4gICAgaWYgKGlzU3RyaW5nKGl0ZW0pKSBpdGVtID0gZ3JvdXAoaXRlbSk7XG4gICAgY29uc3QgcCA9IHBvaW50LnNsaWNlKCk7XG5cbiAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgcFswXSAtPSBpdGVtLnggfHwgMDtcbiAgICAgIHBbMV0gLT0gaXRlbS55IHx8IDA7XG4gICAgICBpdGVtID0gaXRlbS5tYXJrICYmIGl0ZW0ubWFyay5ncm91cDtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmlldzogY29uc3RhbnQodmlldyksXG4gICAgaXRlbTogY29uc3RhbnQoaXRlbSB8fCB7fSksXG4gICAgZ3JvdXA6IGdyb3VwLFxuICAgIHh5OiB4eSxcbiAgICB4OiBpdGVtID0+IHh5KGl0ZW0pWzBdLFxuICAgIHk6IGl0ZW0gPT4geHkoaXRlbSlbMV1cbiAgfTtcbn1cblxuY29uc3QgVklFVyA9ICd2aWV3JyxcbiAgICAgIFRJTUVSID0gJ3RpbWVyJyxcbiAgICAgIFdJTkRPVyA9ICd3aW5kb3cnLFxuICAgICAgTk9fVFJBUCA9IHtcbiAgdHJhcDogZmFsc2Vcbn07XG4vKipcbiAqIEluaXRpYWxpemUgZXZlbnQgaGFuZGxpbmcgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBzZXR0aW5ncy5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBpbml0aWFsaXplRXZlbnRDb25maWcoY29uZmlnKSB7XG4gIGNvbnN0IGV2ZW50cyA9IGV4dGVuZCh7XG4gICAgZGVmYXVsdHM6IHt9XG4gIH0sIGNvbmZpZyk7XG5cbiAgY29uc3QgdW5wYWNrID0gKG9iaiwga2V5cykgPT4ge1xuICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIG9ialtrXSA9IHRvU2V0KG9ialtrXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdW5wYWNrKGV2ZW50cy5kZWZhdWx0cywgWydwcmV2ZW50JywgJ2FsbG93J10pO1xuICB1bnBhY2soZXZlbnRzLCBbJ3ZpZXcnLCAnd2luZG93JywgJ3NlbGVjdG9yJ10pO1xuICByZXR1cm4gZXZlbnRzO1xufVxuZnVuY3Rpb24gdHJhY2tFdmVudExpc3RlbmVyKHZpZXcsIHNvdXJjZXMsIHR5cGUsIGhhbmRsZXIpIHtcbiAgdmlldy5fZXZlbnRMaXN0ZW5lcnMucHVzaCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzb3VyY2VzOiBhcnJheShzb3VyY2VzKSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50KHZpZXcsIHR5cGUpIHtcbiAgdmFyIGRlZiA9IHZpZXcuX2V2ZW50Q29uZmlnLmRlZmF1bHRzLFxuICAgICAgcHJldmVudCA9IGRlZi5wcmV2ZW50LFxuICAgICAgYWxsb3cgPSBkZWYuYWxsb3c7XG4gIHJldHVybiBwcmV2ZW50ID09PSBmYWxzZSB8fCBhbGxvdyA9PT0gdHJ1ZSA/IGZhbHNlIDogcHJldmVudCA9PT0gdHJ1ZSB8fCBhbGxvdyA9PT0gZmFsc2UgPyB0cnVlIDogcHJldmVudCA/IHByZXZlbnRbdHlwZV0gOiBhbGxvdyA/ICFhbGxvd1t0eXBlXSA6IHZpZXcucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gcGVybWl0KHZpZXcsIGtleSwgdHlwZSkge1xuICBjb25zdCBydWxlID0gdmlldy5fZXZlbnRDb25maWcgJiYgdmlldy5fZXZlbnRDb25maWdba2V5XTtcblxuICBpZiAocnVsZSA9PT0gZmFsc2UgfHwgaXNPYmplY3QocnVsZSkgJiYgIXJ1bGVbdHlwZV0pIHtcbiAgICB2aWV3Lndhcm4oYEJsb2NrZWQgJHtrZXl9ICR7dHlwZX0gZXZlbnQgbGlzdGVuZXIuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBldmVudCBzdHJlYW0gZnJvbSBhbiBldmVudCBzb3VyY2UuXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlIC0gVGhlIGV2ZW50IHNvdXJjZSB0byBtb25pdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogYm9vbGVhbn0gW2ZpbHRlcl0gLSBFdmVudCBmaWx0ZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtFdmVudFN0cmVhbX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGV2ZW50cyhzb3VyY2UsIHR5cGUsIGZpbHRlcikge1xuICB2YXIgdmlldyA9IHRoaXMsXG4gICAgICBzID0gbmV3IEV2ZW50U3RyZWFtKGZpbHRlciksXG4gICAgICBzZW5kID0gZnVuY3Rpb24gKGUsIGl0ZW0pIHtcbiAgICB2aWV3LnJ1bkFzeW5jKG51bGwsICgpID0+IHtcbiAgICAgIGlmIChzb3VyY2UgPT09IFZJRVcgJiYgcHJldmVudCh2aWV3LCB0eXBlKSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHMucmVjZWl2ZShldmVudEV4dGVuZCh2aWV3LCBlLCBpdGVtKSk7XG4gICAgfSk7XG4gIH0sXG4gICAgICBzb3VyY2VzO1xuXG4gIGlmIChzb3VyY2UgPT09IFRJTUVSKSB7XG4gICAgaWYgKHBlcm1pdCh2aWV3LCAndGltZXInLCB0eXBlKSkge1xuICAgICAgdmlldy50aW1lcihzZW5kLCB0eXBlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc291cmNlID09PSBWSUVXKSB7XG4gICAgaWYgKHBlcm1pdCh2aWV3LCAndmlldycsIHR5cGUpKSB7XG4gICAgICAvLyBzZW5kIHRyYXBzIGVycm9ycywgc28gdXNlIHt0cmFwOiBmYWxzZX0gb3B0aW9uXG4gICAgICB2aWV3LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc2VuZCwgTk9fVFJBUCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzb3VyY2UgPT09IFdJTkRPVykge1xuICAgICAgaWYgKHBlcm1pdCh2aWV3LCAnd2luZG93JywgdHlwZSkgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc291cmNlcyA9IFt3aW5kb3ddO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHBlcm1pdCh2aWV3LCAnc2VsZWN0b3InLCB0eXBlKSkge1xuICAgICAgICBzb3VyY2VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc291cmNlcykge1xuICAgICAgdmlldy53YXJuKCdDYW4gbm90IHJlc29sdmUgZXZlbnQgc291cmNlOiAnICsgc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBzb3VyY2VzW2ldLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc2VuZCk7XG4gICAgICB9XG5cbiAgICAgIHRyYWNrRXZlbnRMaXN0ZW5lcih2aWV3LCBzb3VyY2VzLCB0eXBlLCBzZW5kKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gaXRlbUZpbHRlcihldmVudCkge1xuICByZXR1cm4gZXZlbnQuaXRlbTtcbn1cblxuZnVuY3Rpb24gbWFya1RhcmdldChldmVudCkge1xuICAvLyBncmFiIHVwc3RyZWFtIGNvbGxlY3RvciBmZWVkaW5nIHRoZSBtYXJrIG9wZXJhdG9yXG4gIHJldHVybiBldmVudC5pdGVtLm1hcmsuc291cmNlO1xufVxuXG5mdW5jdGlvbiBpbnZva2UobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKF8sIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnZlZ2EudmlldygpLmNoYW5nZXNldCgpLmVuY29kZShldmVudC5pdGVtLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaG92ZXIgKGhvdmVyU2V0LCBsZWF2ZVNldCkge1xuICBob3ZlclNldCA9IFtob3ZlclNldCB8fCAnaG92ZXInXTtcbiAgbGVhdmVTZXQgPSBbbGVhdmVTZXQgfHwgJ3VwZGF0ZScsIGhvdmVyU2V0WzBdXTsgLy8gaW52b2tlIGhvdmVyIHNldCB1cG9uIG1vdXNlb3ZlclxuXG4gIHRoaXMub24odGhpcy5ldmVudHMoJ3ZpZXcnLCAnbW91c2VvdmVyJywgaXRlbUZpbHRlciksIG1hcmtUYXJnZXQsIGludm9rZShob3ZlclNldCkpOyAvLyBpbnZva2UgbGVhdmUgc2V0IHVwb24gbW91c2VvdXRcblxuICB0aGlzLm9uKHRoaXMuZXZlbnRzKCd2aWV3JywgJ21vdXNlb3V0JywgaXRlbUZpbHRlciksIG1hcmtUYXJnZXQsIGludm9rZShsZWF2ZVNldCkpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBGaW5hbGl6ZSBhIFZpZXcgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyByZW1vdmVkLlxuICogQ2FuY2VsIGFueSBydW5uaW5nIHRpbWVycy5cbiAqIFJlbW92ZSBhbGwgZXh0ZXJuYWwgZXZlbnQgbGlzdGVuZXJzLlxuICogUmVtb3ZlIGFueSBjdXJyZW50bHkgZGlzcGxheWVkIHRvb2x0aXAuXG4gKi9cbmZ1bmN0aW9uIGZpbmFsaXplICgpIHtcbiAgdmFyIHRvb2x0aXAgPSB0aGlzLl90b29sdGlwLFxuICAgICAgdGltZXJzID0gdGhpcy5fdGltZXJzLFxuICAgICAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMsXG4gICAgICBuLFxuICAgICAgbSxcbiAgICAgIGU7XG4gIG4gPSB0aW1lcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIHRpbWVyc1tuXS5zdG9wKCk7XG4gIH1cblxuICBuID0gbGlzdGVuZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICBlID0gbGlzdGVuZXJzW25dO1xuICAgIG0gPSBlLnNvdXJjZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKC0tbSA+PSAwKSB7XG4gICAgICBlLnNvdXJjZXNbbV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLnR5cGUsIGUuaGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRvb2x0aXApIHtcbiAgICB0b29sdGlwLmNhbGwodGhpcywgdGhpcy5faGFuZGxlciwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZWxlbWVudCAodGFnLCBhdHRyLCB0ZXh0KSB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHIpIGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJba2V5XSk7XG5cbiAgaWYgKHRleHQgIT0gbnVsbCkgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICByZXR1cm4gZWw7XG59XG5cbmNvbnN0IEJpbmRDbGFzcyA9ICd2ZWdhLWJpbmQnLFxuICAgICAgTmFtZUNsYXNzID0gJ3ZlZ2EtYmluZC1uYW1lJyxcbiAgICAgIFJhZGlvQ2xhc3MgPSAndmVnYS1iaW5kLXJhZGlvJztcbi8qKlxuICogQmluZCBhIHNpZ25hbCB0byBhbiBleHRlcm5hbCBIVE1MIGlucHV0IGVsZW1lbnQuIFRoZSByZXN1bHRpbmcgdHdvLXdheVxuICogYmluZGluZyB3aWxsIHByb3BhZ2F0ZSBpbnB1dCBjaGFuZ2VzIHRvIHNpZ25hbHMsIGFuZCBwcm9wYWdhdGUgc2lnbmFsXG4gKiBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBlbGVtZW50IHN0YXRlLiBJZiB0aGlzIHZpZXcgaW5zdGFuY2UgaGFzIG5vIHBhcmVudFxuICogZWxlbWVudCwgd2UgYXNzdW1lIHRoZSB2aWV3IGlzIGhlYWRsZXNzIGFuZCBubyBiaW5kaW5ncyBhcmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IGVsIC0gVGhlIHBhcmVudCBET00gZWxlbWVudCB0byB3aGljaCB0aGUgaW5wdXRcbiAqICAgZWxlbWVudCBzaG91bGQgYmUgYXBwZW5kZWQgYXMgYSBjaGlsZC4gSWYgc3RyaW5nLXZhbHVlZCwgdGhpcyBhcmd1bWVudFxuICogICB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBDU1Mgc2VsZWN0b3IuIElmIG51bGwgb3IgdW5kZWZpbmVkLCB0aGUgcGFyZW50XG4gKiAgIGVsZW1lbnQgb2YgdGhpcyB2aWV3IHdpbGwgYmUgdXNlZCBhcyB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbSAtIFRoZSBiaW5kaW5nIHBhcmFtZXRlcnMgd2hpY2ggc3BlY2lmeSB0aGUgc2lnbmFsXG4gKiAgIHRvIGJpbmQgdG8sIHRoZSBpbnB1dCBlbGVtZW50IHR5cGUsIGFuZCB0eXBlLXNwZWNpZmljIGNvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJuIHtWaWV3fSAtIFRoaXMgdmlldyBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBiaW5kICh2aWV3LCBlbCwgYmluZGluZykge1xuICBpZiAoIWVsKSByZXR1cm47XG4gIGNvbnN0IHBhcmFtID0gYmluZGluZy5wYXJhbTtcbiAgbGV0IGJpbmQgPSBiaW5kaW5nLnN0YXRlO1xuXG4gIGlmICghYmluZCkge1xuICAgIGJpbmQgPSBiaW5kaW5nLnN0YXRlID0ge1xuICAgICAgZWxlbWVudHM6IG51bGwsXG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgc2V0OiBudWxsLFxuICAgICAgdXBkYXRlOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSB2aWV3LnNpZ25hbChwYXJhbS5zaWduYWwpKSB7XG4gICAgICAgICAgdmlldy5ydW5Bc3luYyhudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICBiaW5kLnNvdXJjZSA9IHRydWU7XG4gICAgICAgICAgICB2aWV3LnNpZ25hbChwYXJhbS5zaWduYWwsIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAocGFyYW0uZGVib3VuY2UpIHtcbiAgICAgIGJpbmQudXBkYXRlID0gZGVib3VuY2UocGFyYW0uZGVib3VuY2UsIGJpbmQudXBkYXRlKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjcmVhdGUgPSBwYXJhbS5pbnB1dCA9PSBudWxsICYmIHBhcmFtLmVsZW1lbnQgPyB0YXJnZXQgOiBnZW5lcmF0ZTtcbiAgY3JlYXRlKGJpbmQsIGVsLCBwYXJhbSwgdmlldyk7XG5cbiAgaWYgKCFiaW5kLmFjdGl2ZSkge1xuICAgIHZpZXcub24odmlldy5fc2lnbmFsc1twYXJhbS5zaWduYWxdLCBudWxsLCAoKSA9PiB7XG4gICAgICBiaW5kLnNvdXJjZSA/IGJpbmQuc291cmNlID0gZmFsc2UgOiBiaW5kLnNldCh2aWV3LnNpZ25hbChwYXJhbS5zaWduYWwpKTtcbiAgICB9KTtcbiAgICBiaW5kLmFjdGl2ZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gYmluZDtcbn1cbi8qKlxuICogQmluZCB0aGUgc2lnbmFsIHRvIGFuIGV4dGVybmFsIEV2ZW50VGFyZ2V0LlxuICovXG5cbmZ1bmN0aW9uIHRhcmdldChiaW5kLCBub2RlLCBwYXJhbSwgdmlldykge1xuICBjb25zdCB0eXBlID0gcGFyYW0uZXZlbnQgfHwgJ2lucHV0JztcblxuICBjb25zdCBoYW5kbGVyID0gKCkgPT4gYmluZC51cGRhdGUobm9kZS52YWx1ZSk7IC8vIGluaXRpYWxpemUgc2lnbmFsIHZhbHVlIHRvIGV4dGVybmFsIGlucHV0IHZhbHVlXG5cblxuICB2aWV3LnNpZ25hbChwYXJhbS5zaWduYWwsIG5vZGUudmFsdWUpOyAvLyBsaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhlIGVsZW1lbnRcblxuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7IC8vIHJlZ2lzdGVyIHdpdGggdmlldywgc28gd2UgY2FuIHJlbW92ZSBpdCB1cG9uIGZpbmFsaXphdGlvblxuXG4gIHRyYWNrRXZlbnRMaXN0ZW5lcih2aWV3LCBub2RlLCB0eXBlLCBoYW5kbGVyKTsgLy8gcHJvcGFnYXRlIGNoYW5nZSB0byBlbGVtZW50XG5cbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiB7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCh0eXBlKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV2ZW50KHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBFdmVudCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgRXZlbnQodHlwZSkgOiB7XG4gICAgdHlwZVxuICB9O1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBIVE1MIGlucHV0IGZvcm0gZWxlbWVudCBhbmQgYmluZCBpdCB0byBhIHNpZ25hbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlKGJpbmQsIGVsLCBwYXJhbSwgdmlldykge1xuICBjb25zdCB2YWx1ZSA9IHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCk7XG4gIGNvbnN0IGRpdiA9IGVsZW1lbnQoJ2RpdicsIHtcbiAgICAnY2xhc3MnOiBCaW5kQ2xhc3NcbiAgfSk7XG4gIGNvbnN0IHdyYXBwZXIgPSBwYXJhbS5pbnB1dCA9PT0gJ3JhZGlvJyA/IGRpdiA6IGRpdi5hcHBlbmRDaGlsZChlbGVtZW50KCdsYWJlbCcpKTtcbiAgd3JhcHBlci5hcHBlbmRDaGlsZChlbGVtZW50KCdzcGFuJywge1xuICAgICdjbGFzcyc6IE5hbWVDbGFzc1xuICB9LCBwYXJhbS5uYW1lIHx8IHBhcmFtLnNpZ25hbCkpO1xuICBlbC5hcHBlbmRDaGlsZChkaXYpO1xuICBsZXQgaW5wdXQgPSBmb3JtO1xuXG4gIHN3aXRjaCAocGFyYW0uaW5wdXQpIHtcbiAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICBpbnB1dCA9IGNoZWNrYm94O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5wdXQgPSBzZWxlY3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgIGlucHV0ID0gcmFkaW87XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgIGlucHV0ID0gcmFuZ2U7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlucHV0KGJpbmQsIHdyYXBwZXIsIHBhcmFtLCB2YWx1ZSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhcmJpdHJhcnkgaW5wdXQgZm9ybSBlbGVtZW50LlxuICogVGhlIGlucHV0IHR5cGUgaXMgY29udHJvbGxlZCB2aWEgdXNlci1wcm92aWRlZCBwYXJhbWV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gZm9ybShiaW5kLCBlbCwgcGFyYW0sIHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSBlbGVtZW50KCdpbnB1dCcpO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIHBhcmFtKSB7XG4gICAgaWYgKGtleSAhPT0gJ3NpZ25hbCcgJiYga2V5ICE9PSAnZWxlbWVudCcpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGtleSA9PT0gJ2lucHV0JyA/ICd0eXBlJyA6IGtleSwgcGFyYW1ba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgbm9kZS5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBwYXJhbS5zaWduYWwpO1xuICBub2RlLnZhbHVlID0gdmFsdWU7XG4gIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4gYmluZC51cGRhdGUobm9kZS52YWx1ZSkpO1xuICBiaW5kLmVsZW1lbnRzID0gW25vZGVdO1xuXG4gIGJpbmQuc2V0ID0gdmFsdWUgPT4gbm9kZS52YWx1ZSA9IHZhbHVlO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBjaGVja2JveCBpbnB1dCBlbGVtZW50LlxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tib3goYmluZCwgZWwsIHBhcmFtLCB2YWx1ZSkge1xuICBjb25zdCBhdHRyID0ge1xuICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgbmFtZTogcGFyYW0uc2lnbmFsXG4gIH07XG4gIGlmICh2YWx1ZSkgYXR0ci5jaGVja2VkID0gdHJ1ZTtcbiAgY29uc3Qgbm9kZSA9IGVsZW1lbnQoJ2lucHV0JywgYXR0cik7XG4gIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IGJpbmQudXBkYXRlKG5vZGUuY2hlY2tlZCkpO1xuICBiaW5kLmVsZW1lbnRzID0gW25vZGVdO1xuXG4gIGJpbmQuc2V0ID0gdmFsdWUgPT4gbm9kZS5jaGVja2VkID0gISF2YWx1ZSB8fCBudWxsO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzZWxlY3Rpb24gbGlzdCBpbnB1dCBlbGVtZW50LlxuICovXG5cblxuZnVuY3Rpb24gc2VsZWN0KGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IGVsZW1lbnQoJ3NlbGVjdCcsIHtcbiAgICBuYW1lOiBwYXJhbS5zaWduYWxcbiAgfSksXG4gICAgICAgIGxhYmVscyA9IHBhcmFtLmxhYmVscyB8fCBbXTtcbiAgcGFyYW0ub3B0aW9ucy5mb3JFYWNoKChvcHRpb24sIGkpID0+IHtcbiAgICBjb25zdCBhdHRyID0ge1xuICAgICAgdmFsdWU6IG9wdGlvblxuICAgIH07XG4gICAgaWYgKHZhbHVlc0VxdWFsKG9wdGlvbiwgdmFsdWUpKSBhdHRyLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGVsZW1lbnQoJ29wdGlvbicsIGF0dHIsIChsYWJlbHNbaV0gfHwgb3B0aW9uKSArICcnKSk7XG4gIH0pO1xuICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgYmluZC51cGRhdGUocGFyYW0ub3B0aW9uc1tub2RlLnNlbGVjdGVkSW5kZXhdKTtcbiAgfSk7XG4gIGJpbmQuZWxlbWVudHMgPSBbbm9kZV07XG5cbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBwYXJhbS5vcHRpb25zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKHZhbHVlc0VxdWFsKHBhcmFtLm9wdGlvbnNbaV0sIHZhbHVlKSkge1xuICAgICAgICBub2RlLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYWRpbyBidXR0b24gZ3JvdXAuXG4gKi9cblxuXG5mdW5jdGlvbiByYWRpbyhiaW5kLCBlbCwgcGFyYW0sIHZhbHVlKSB7XG4gIGNvbnN0IGdyb3VwID0gZWxlbWVudCgnc3BhbicsIHtcbiAgICAnY2xhc3MnOiBSYWRpb0NsYXNzXG4gIH0pLFxuICAgICAgICBsYWJlbHMgPSBwYXJhbS5sYWJlbHMgfHwgW107XG4gIGVsLmFwcGVuZENoaWxkKGdyb3VwKTtcbiAgYmluZC5lbGVtZW50cyA9IHBhcmFtLm9wdGlvbnMubWFwKChvcHRpb24sIGkpID0+IHtcbiAgICBjb25zdCBhdHRyID0ge1xuICAgICAgdHlwZTogJ3JhZGlvJyxcbiAgICAgIG5hbWU6IHBhcmFtLnNpZ25hbCxcbiAgICAgIHZhbHVlOiBvcHRpb25cbiAgICB9O1xuICAgIGlmICh2YWx1ZXNFcXVhbChvcHRpb24sIHZhbHVlKSkgYXR0ci5jaGVja2VkID0gdHJ1ZTtcbiAgICBjb25zdCBpbnB1dCA9IGVsZW1lbnQoJ2lucHV0JywgYXR0cik7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4gYmluZC51cGRhdGUob3B0aW9uKSk7XG4gICAgY29uc3QgbGFiZWwgPSBlbGVtZW50KCdsYWJlbCcsIHt9LCAobGFiZWxzW2ldIHx8IG9wdGlvbikgKyAnJyk7XG4gICAgbGFiZWwucHJlcGVuZChpbnB1dCk7XG4gICAgZ3JvdXAuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSk7XG5cbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiB7XG4gICAgY29uc3Qgbm9kZXMgPSBiaW5kLmVsZW1lbnRzLFxuICAgICAgICAgIG4gPSBub2Rlcy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKHZhbHVlc0VxdWFsKG5vZGVzW2ldLnZhbHVlLCB2YWx1ZSkpIG5vZGVzW2ldLmNoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgc2xpZGVyIGlucHV0IGVsZW1lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiByYW5nZShiaW5kLCBlbCwgcGFyYW0sIHZhbHVlKSB7XG4gIHZhbHVlID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogKCtwYXJhbS5tYXggKyArcGFyYW0ubWluKSAvIDI7XG4gIGNvbnN0IG1heCA9IHBhcmFtLm1heCAhPSBudWxsID8gcGFyYW0ubWF4IDogTWF0aC5tYXgoMTAwLCArdmFsdWUpIHx8IDEwMCxcbiAgICAgICAgbWluID0gcGFyYW0ubWluIHx8IE1hdGgubWluKDAsIG1heCwgK3ZhbHVlKSB8fCAwLFxuICAgICAgICBzdGVwID0gcGFyYW0uc3RlcCB8fCB0aWNrU3RlcChtaW4sIG1heCwgMTAwKTtcbiAgY29uc3Qgbm9kZSA9IGVsZW1lbnQoJ2lucHV0Jywge1xuICAgIHR5cGU6ICdyYW5nZScsXG4gICAgbmFtZTogcGFyYW0uc2lnbmFsLFxuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4LFxuICAgIHN0ZXA6IHN0ZXBcbiAgfSk7XG4gIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgY29uc3Qgc3BhbiA9IGVsZW1lbnQoJ3NwYW4nLCB7fSwgK3ZhbHVlKTtcbiAgZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIGVsLmFwcGVuZENoaWxkKHNwYW4pO1xuXG4gIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICBzcGFuLnRleHRDb250ZW50ID0gbm9kZS52YWx1ZTtcbiAgICBiaW5kLnVwZGF0ZSgrbm9kZS52YWx1ZSk7XG4gIH07IC8vIHN1YnNjcmliZSB0byBib3RoIGlucHV0IGFuZCBjaGFuZ2VcblxuXG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGUpO1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZSk7XG4gIGJpbmQuZWxlbWVudHMgPSBbbm9kZV07XG5cbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiB7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIHNwYW4udGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsdWVzRXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYiB8fCBhICsgJycgPT09IGIgKyAnJztcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlbmRlcmVyICh2aWV3LCByLCBlbCwgY29uc3RydWN0b3IsIHNjYWxlRmFjdG9yLCBvcHQpIHtcbiAgciA9IHIgfHwgbmV3IGNvbnN0cnVjdG9yKHZpZXcubG9hZGVyKCkpO1xuICByZXR1cm4gci5pbml0aWFsaXplKGVsLCB3aWR0aCh2aWV3KSwgaGVpZ2h0KHZpZXcpLCBvZmZzZXQodmlldyksIHNjYWxlRmFjdG9yLCBvcHQpLmJhY2tncm91bmQodmlldy5iYWNrZ3JvdW5kKCkpO1xufVxuXG5mdW5jdGlvbiB0cmFwICh2aWV3LCBmbikge1xuICByZXR1cm4gIWZuID8gbnVsbCA6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdmlldy5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplSGFuZGxlciAodmlldywgcHJldkhhbmRsZXIsIGVsLCBjb25zdHJ1Y3Rvcikge1xuICAvLyBpbnN0YW50aWF0ZSBzY2VuZWdyYXBoIGhhbmRsZXJcbiAgY29uc3QgaGFuZGxlciA9IG5ldyBjb25zdHJ1Y3Rvcih2aWV3LmxvYWRlcigpLCB0cmFwKHZpZXcsIHZpZXcudG9vbHRpcCgpKSkuc2NlbmUodmlldy5zY2VuZWdyYXBoKCkucm9vdCkuaW5pdGlhbGl6ZShlbCwgb2Zmc2V0KHZpZXcpLCB2aWV3KTsgLy8gdHJhbnNmZXIgZXZlbnQgaGFuZGxlcnNcblxuICBpZiAocHJldkhhbmRsZXIpIHtcbiAgICBwcmV2SGFuZGxlci5oYW5kbGVycygpLmZvckVhY2goaCA9PiB7XG4gICAgICBoYW5kbGVyLm9uKGgudHlwZSwgaC5oYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVyO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplIChlbCwgZWxCaW5kKSB7XG4gIGNvbnN0IHZpZXcgPSB0aGlzLFxuICAgICAgICB0eXBlID0gdmlldy5fcmVuZGVyVHlwZSxcbiAgICAgICAgY29uZmlnID0gdmlldy5fZXZlbnRDb25maWcuYmluZCxcbiAgICAgICAgbW9kdWxlID0gcmVuZGVyTW9kdWxlKHR5cGUpOyAvLyBjb250YWluaW5nIGRvbSBlbGVtZW50XG5cbiAgZWwgPSB2aWV3Ll9lbCA9IGVsID8gbG9va3VwKHZpZXcsIGVsLCB0cnVlKSA6IG51bGw7IC8vIGluaXRpYWxpemUgYXJpYSBhdHRyaWJ1dGVzXG5cbiAgaW5pdGlhbGl6ZUFyaWEodmlldyk7IC8vIHNlbGVjdCBhcHByb3ByaWF0ZSByZW5kZXJlciAmIGhhbmRsZXJcblxuICBpZiAoIW1vZHVsZSkgdmlldy5lcnJvcignVW5yZWNvZ25pemVkIHJlbmRlcmVyIHR5cGU6ICcgKyB0eXBlKTtcbiAgY29uc3QgSGFuZGxlciA9IG1vZHVsZS5oYW5kbGVyIHx8IENhbnZhc0hhbmRsZXIsXG4gICAgICAgIFJlbmRlcmVyID0gZWwgPyBtb2R1bGUucmVuZGVyZXIgOiBtb2R1bGUuaGVhZGxlc3M7IC8vIGluaXRpYWxpemUgcmVuZGVyZXIgYW5kIGlucHV0IGhhbmRsZXJcblxuICB2aWV3Ll9yZW5kZXJlciA9ICFSZW5kZXJlciA/IG51bGwgOiBpbml0aWFsaXplUmVuZGVyZXIodmlldywgdmlldy5fcmVuZGVyZXIsIGVsLCBSZW5kZXJlcik7XG4gIHZpZXcuX2hhbmRsZXIgPSBpbml0aWFsaXplSGFuZGxlcih2aWV3LCB2aWV3Ll9oYW5kbGVyLCBlbCwgSGFuZGxlcik7XG4gIHZpZXcuX3JlZHJhdyA9IHRydWU7IC8vIGluaXRpYWxpemUgc2lnbmFsIGJpbmRpbmdzXG5cbiAgaWYgKGVsICYmIGNvbmZpZyAhPT0gJ25vbmUnKSB7XG4gICAgZWxCaW5kID0gZWxCaW5kID8gdmlldy5fZWxCaW5kID0gbG9va3VwKHZpZXcsIGVsQmluZCwgdHJ1ZSkgOiBlbC5hcHBlbmRDaGlsZChlbGVtZW50KCdmb3JtJywge1xuICAgICAgJ2NsYXNzJzogJ3ZlZ2EtYmluZGluZ3MnXG4gICAgfSkpO1xuXG4gICAgdmlldy5fYmluZC5mb3JFYWNoKF8gPT4ge1xuICAgICAgaWYgKF8ucGFyYW0uZWxlbWVudCAmJiBjb25maWcgIT09ICdjb250YWluZXInKSB7XG4gICAgICAgIF8uZWxlbWVudCA9IGxvb2t1cCh2aWV3LCBfLnBhcmFtLmVsZW1lbnQsICEhXy5wYXJhbS5pbnB1dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2aWV3Ll9iaW5kLmZvckVhY2goXyA9PiB7XG4gICAgICBiaW5kKHZpZXcsIF8uZWxlbWVudCB8fCBlbEJpbmQsIF8pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZpZXc7XG59XG5cbmZ1bmN0aW9uIGxvb2t1cCh2aWV3LCBlbCwgY2xlYXIpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcblxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICB2aWV3LmVycm9yKCdTaWduYWwgYmluZCBlbGVtZW50IG5vdCBmb3VuZDogJyArIGVsKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuZXJyb3IoJ0RPTSBkb2N1bWVudCBpbnN0YW5jZSBub3QgZm91bmQuJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwgJiYgY2xlYXIpIHtcbiAgICB0cnkge1xuICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZWwgPSBudWxsO1xuICAgICAgdmlldy5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbmNvbnN0IG51bWJlciA9IF8gPT4gK18gfHwgMDtcblxuY29uc3QgcGFkZGluZ09iamVjdCA9IF8gPT4gKHtcbiAgdG9wOiBfLFxuICBib3R0b206IF8sXG4gIGxlZnQ6IF8sXG4gIHJpZ2h0OiBfXG59KTtcblxuZnVuY3Rpb24gcGFkZGluZyAoXykge1xuICByZXR1cm4gaXNPYmplY3QoXykgPyB7XG4gICAgdG9wOiBudW1iZXIoXy50b3ApLFxuICAgIGJvdHRvbTogbnVtYmVyKF8uYm90dG9tKSxcbiAgICBsZWZ0OiBudW1iZXIoXy5sZWZ0KSxcbiAgICByaWdodDogbnVtYmVyKF8ucmlnaHQpXG4gIH0gOiBwYWRkaW5nT2JqZWN0KG51bWJlcihfKSk7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSBjdXJyZW50IHNjZW5lIGluIGEgaGVhZGxlc3MgZmFzaGlvbi5cbiAqIFRoaXMgbWV0aG9kIGlzIGFzeW5jaHJvbm91cywgcmV0dXJuaW5nIGEgUHJvbWlzZSBpbnN0YW5jZS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSByZW5kZXJlci5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiByZW5kZXJIZWFkbGVzcyAodmlldywgdHlwZSwgc2NhbGVGYWN0b3IsIG9wdCkge1xuICBjb25zdCBtb2R1bGUgPSByZW5kZXJNb2R1bGUodHlwZSksXG4gICAgICAgIGN0ciA9IG1vZHVsZSAmJiBtb2R1bGUuaGVhZGxlc3M7XG4gIGlmICghY3RyKSBlcnJvcignVW5yZWNvZ25pemVkIHJlbmRlcmVyIHR5cGU6ICcgKyB0eXBlKTtcbiAgYXdhaXQgdmlldy5ydW5Bc3luYygpO1xuICByZXR1cm4gaW5pdGlhbGl6ZVJlbmRlcmVyKHZpZXcsIG51bGwsIG51bGwsIGN0ciwgc2NhbGVGYWN0b3IsIG9wdCkucmVuZGVyQXN5bmModmlldy5fc2NlbmVncmFwaC5yb290KTtcbn1cblxuLyoqXG4gKiBQcm9kdWNlIGFuIGltYWdlIFVSTCBmb3IgdGhlIHZpc3VhbGl6YXRpb24uIERlcGVuZGluZyBvbiB0aGUgdHlwZVxuICogcGFyYW1ldGVyLCB0aGUgZ2VuZXJhdGVkIFVSTCBjb250YWlucyBkYXRhIGZvciBlaXRoZXIgYSBQTkcgb3IgU1ZHIGltYWdlLlxuICogVGhlIFVSTCBjYW4gYmUgdXNlZCAoZm9yIGV4YW1wbGUpIHRvIGRvd25sb2FkIGltYWdlcyBvZiB0aGUgdmlzdWFsaXphdGlvbi5cbiAqIFRoaXMgbWV0aG9kIGlzIGFzeW5jaHJvbm91cywgcmV0dXJuaW5nIGEgUHJvbWlzZSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGltYWdlIHR5cGUuIE9uZSBvZiAnc3ZnJywgJ3BuZycgb3IgJ2NhbnZhcycuXG4gKiAgIFRoZSAnY2FudmFzJyBhbmQgJ3BuZycgdHlwZXMgYXJlIHN5bm9ueW1zIGZvciBhIFBORyBpbWFnZS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gaW1hZ2UgVVJMLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlclRvSW1hZ2VVUkwgKHR5cGUsIHNjYWxlRmFjdG9yKSB7XG4gIGlmICh0eXBlICE9PSBSZW5kZXJUeXBlLkNhbnZhcyAmJiB0eXBlICE9PSBSZW5kZXJUeXBlLlNWRyAmJiB0eXBlICE9PSBSZW5kZXJUeXBlLlBORykge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgaW1hZ2UgdHlwZTogJyArIHR5cGUpO1xuICB9XG5cbiAgY29uc3QgciA9IGF3YWl0IHJlbmRlckhlYWRsZXNzKHRoaXMsIHR5cGUsIHNjYWxlRmFjdG9yKTtcbiAgcmV0dXJuIHR5cGUgPT09IFJlbmRlclR5cGUuU1ZHID8gdG9CbG9iVVJMKHIuc3ZnKCksICdpbWFnZS9zdmcreG1sJykgOiByLmNhbnZhcygpLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG59XG5cbmZ1bmN0aW9uIHRvQmxvYlVSTChkYXRhLCBtaW1lKSB7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHtcbiAgICB0eXBlOiBtaW1lXG4gIH0pO1xuICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbi8qKlxuICogUHJvZHVjZSBhIENhbnZhcyBpbnN0YW5jZSBjb250YWluaW5nIGEgcmVuZGVyZWQgdmlzdWFsaXphdGlvbi5cbiAqIFRoaXMgbWV0aG9kIGlzIGFzeW5jaHJvbm91cywgcmV0dXJuaW5nIGEgUHJvbWlzZSBpbnN0YW5jZS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBDYW52YXMgaW5zdGFuY2UuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyVG9DYW52YXMgKHNjYWxlRmFjdG9yLCBvcHQpIHtcbiAgY29uc3QgciA9IGF3YWl0IHJlbmRlckhlYWRsZXNzKHRoaXMsIFJlbmRlclR5cGUuQ2FudmFzLCBzY2FsZUZhY3Rvciwgb3B0KTtcbiAgcmV0dXJuIHIuY2FudmFzKCk7XG59XG5cbi8qKlxuICogUHJvZHVjZSBhIHJlbmRlcmVkIFNWRyBzdHJpbmcgb2YgdGhlIHZpc3VhbGl6YXRpb24uXG4gKiBUaGlzIG1ldGhvZCBpcyBhc3luY2hyb25vdXMsIHJldHVybmluZyBhIFByb21pc2UgaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIFNWRyBzdHJpbmcuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyVG9TVkcgKHNjYWxlRmFjdG9yKSB7XG4gIGNvbnN0IHIgPSBhd2FpdCByZW5kZXJIZWFkbGVzcyh0aGlzLCBSZW5kZXJUeXBlLlNWRywgc2NhbGVGYWN0b3IpO1xuICByZXR1cm4gci5zdmcoKTtcbn1cblxuZnVuY3Rpb24gcnVudGltZSAodmlldywgc3BlYywgZXhwcikge1xuICByZXR1cm4gY29udGV4dCh2aWV3LCB0cmFuc2Zvcm1zLCBmdW5jdGlvbkNvbnRleHQsIGV4cHIpLnBhcnNlKHNwZWMpO1xufVxuXG5mdW5jdGlvbiBzY2FsZShuYW1lKSB7XG4gIHZhciBzY2FsZXMgPSB0aGlzLl9ydW50aW1lLnNjYWxlcztcblxuICBpZiAoIWhhc093blByb3BlcnR5KHNjYWxlcywgbmFtZSkpIHtcbiAgICBlcnJvcignVW5yZWNvZ25pemVkIHNjYWxlIG9yIHByb2plY3Rpb246ICcgKyBuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBzY2FsZXNbbmFtZV0udmFsdWU7XG59XG5cbnZhciBXaWR0aCA9ICd3aWR0aCcsXG4gICAgSGVpZ2h0ID0gJ2hlaWdodCcsXG4gICAgUGFkZGluZyA9ICdwYWRkaW5nJyxcbiAgICBTa2lwID0ge1xuICBza2lwOiB0cnVlXG59O1xuZnVuY3Rpb24gdmlld1dpZHRoKHZpZXcsIHdpZHRoKSB7XG4gIHZhciBhID0gdmlldy5hdXRvc2l6ZSgpLFxuICAgICAgcCA9IHZpZXcucGFkZGluZygpO1xuICByZXR1cm4gd2lkdGggLSAoYSAmJiBhLmNvbnRhaW5zID09PSBQYWRkaW5nID8gcC5sZWZ0ICsgcC5yaWdodCA6IDApO1xufVxuZnVuY3Rpb24gdmlld0hlaWdodCh2aWV3LCBoZWlnaHQpIHtcbiAgdmFyIGEgPSB2aWV3LmF1dG9zaXplKCksXG4gICAgICBwID0gdmlldy5wYWRkaW5nKCk7XG4gIHJldHVybiBoZWlnaHQgLSAoYSAmJiBhLmNvbnRhaW5zID09PSBQYWRkaW5nID8gcC50b3AgKyBwLmJvdHRvbSA6IDApO1xufVxuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlc2l6ZSh2aWV3KSB7XG4gIHZhciBzID0gdmlldy5fc2lnbmFscyxcbiAgICAgIHcgPSBzW1dpZHRoXSxcbiAgICAgIGggPSBzW0hlaWdodF0sXG4gICAgICBwID0gc1tQYWRkaW5nXTtcblxuICBmdW5jdGlvbiByZXNldFNpemUoKSB7XG4gICAgdmlldy5fYXV0b3NpemUgPSB2aWV3Ll9yZXNpemUgPSAxO1xuICB9IC8vIHJlc3BvbmQgdG8gd2lkdGggc2lnbmFsXG5cblxuICB2aWV3Ll9yZXNpemVXaWR0aCA9IHZpZXcuYWRkKG51bGwsIF8gPT4ge1xuICAgIHZpZXcuX3dpZHRoID0gXy5zaXplO1xuICAgIHZpZXcuX3ZpZXdXaWR0aCA9IHZpZXdXaWR0aCh2aWV3LCBfLnNpemUpO1xuICAgIHJlc2V0U2l6ZSgpO1xuICB9LCB7XG4gICAgc2l6ZTogd1xuICB9KTsgLy8gcmVzcG9uZCB0byBoZWlnaHQgc2lnbmFsXG5cbiAgdmlldy5fcmVzaXplSGVpZ2h0ID0gdmlldy5hZGQobnVsbCwgXyA9PiB7XG4gICAgdmlldy5faGVpZ2h0ID0gXy5zaXplO1xuICAgIHZpZXcuX3ZpZXdIZWlnaHQgPSB2aWV3SGVpZ2h0KHZpZXcsIF8uc2l6ZSk7XG4gICAgcmVzZXRTaXplKCk7XG4gIH0sIHtcbiAgICBzaXplOiBoXG4gIH0pOyAvLyByZXNwb25kIHRvIHBhZGRpbmcgc2lnbmFsXG5cbiAgY29uc3QgcmVzaXplUGFkZGluZyA9IHZpZXcuYWRkKG51bGwsIHJlc2V0U2l6ZSwge1xuICAgIHBhZDogcFxuICB9KTsgLy8gc2V0IHJhbmsgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHNvdXJjZSBzaWduYWxcblxuICB2aWV3Ll9yZXNpemVXaWR0aC5yYW5rID0gdy5yYW5rICsgMTtcbiAgdmlldy5fcmVzaXplSGVpZ2h0LnJhbmsgPSBoLnJhbmsgKyAxO1xuICByZXNpemVQYWRkaW5nLnJhbmsgPSBwLnJhbmsgKyAxO1xufVxuZnVuY3Rpb24gcmVzaXplVmlldyh2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgYXV0bykge1xuICB0aGlzLnJ1bkFmdGVyKHZpZXcgPT4ge1xuICAgIGxldCByZXJ1biA9IDA7IC8vIHJlc2V0IGF1dG9zaXplIGZsYWdcblxuICAgIHZpZXcuX2F1dG9zaXplID0gMDsgLy8gd2lkdGggdmFsdWUgY2hhbmdlZDogdXBkYXRlIHNpZ25hbCwgc2tpcCByZXNpemUgb3BcblxuICAgIGlmICh2aWV3LndpZHRoKCkgIT09IHdpZHRoKSB7XG4gICAgICByZXJ1biA9IDE7XG4gICAgICB2aWV3LnNpZ25hbChXaWR0aCwgd2lkdGgsIFNraXApOyAvLyBzZXQgd2lkdGgsIHNraXAgdXBkYXRlIGNhbGNcblxuICAgICAgdmlldy5fcmVzaXplV2lkdGguc2tpcCh0cnVlKTsgLy8gc2tpcCB3aWR0aCByZXNpemUgaGFuZGxlclxuXG4gICAgfSAvLyBoZWlnaHQgdmFsdWUgY2hhbmdlZDogdXBkYXRlIHNpZ25hbCwgc2tpcCByZXNpemUgb3BcblxuXG4gICAgaWYgKHZpZXcuaGVpZ2h0KCkgIT09IGhlaWdodCkge1xuICAgICAgcmVydW4gPSAxO1xuICAgICAgdmlldy5zaWduYWwoSGVpZ2h0LCBoZWlnaHQsIFNraXApOyAvLyBzZXQgaGVpZ2h0LCBza2lwIHVwZGF0ZSBjYWxjXG5cbiAgICAgIHZpZXcuX3Jlc2l6ZUhlaWdodC5za2lwKHRydWUpOyAvLyBza2lwIGhlaWdodCByZXNpemUgaGFuZGxlclxuXG4gICAgfSAvLyB2aWV3IHdpZHRoIGNoYW5nZWQ6IHVwZGF0ZSB2aWV3IHByb3BlcnR5LCBzZXQgcmVzaXplIGZsYWdcblxuXG4gICAgaWYgKHZpZXcuX3ZpZXdXaWR0aCAhPT0gdmlld1dpZHRoKSB7XG4gICAgICB2aWV3Ll9yZXNpemUgPSAxO1xuICAgICAgdmlldy5fdmlld1dpZHRoID0gdmlld1dpZHRoO1xuICAgIH0gLy8gdmlldyBoZWlnaHQgY2hhbmdlZDogdXBkYXRlIHZpZXcgcHJvcGVydHksIHNldCByZXNpemUgZmxhZ1xuXG5cbiAgICBpZiAodmlldy5fdmlld0hlaWdodCAhPT0gdmlld0hlaWdodCkge1xuICAgICAgdmlldy5fcmVzaXplID0gMTtcbiAgICAgIHZpZXcuX3ZpZXdIZWlnaHQgPSB2aWV3SGVpZ2h0O1xuICAgIH0gLy8gb3JpZ2luIGNoYW5nZWQ6IHVwZGF0ZSB2aWV3IHByb3BlcnR5LCBzZXQgcmVzaXplIGZsYWdcblxuXG4gICAgaWYgKHZpZXcuX29yaWdpblswXSAhPT0gb3JpZ2luWzBdIHx8IHZpZXcuX29yaWdpblsxXSAhPT0gb3JpZ2luWzFdKSB7XG4gICAgICB2aWV3Ll9yZXNpemUgPSAxO1xuICAgICAgdmlldy5fb3JpZ2luID0gb3JpZ2luO1xuICAgIH0gLy8gcnVuIGRhdGFmbG93IG9uIHdpZHRoL2hlaWdodCBzaWduYWwgY2hhbmdlXG5cblxuICAgIGlmIChyZXJ1bikgdmlldy5ydW4oJ2VudGVyJyk7XG4gICAgaWYgKGF1dG8pIHZpZXcucnVuQWZ0ZXIodiA9PiB2LnJlc2l6ZSgpKTtcbiAgfSwgZmFsc2UsIDEpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2aWV3IHN0YXRlLCBjb25zaXN0aW5nIG9mIHNpZ25hbCB2YWx1ZXMgYW5kL29yIGRhdGEgc2V0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZsYWdzIGluZGljYXRpbmcgd2hpY2ggc3RhdGUgdG8gZXhwb3J0LlxuICogICBJZiB1bnNwZWNpZmllZCwgYWxsIHNpZ25hbHMgYW5kIGRhdGEgc2V0cyB3aWxsIGJlIGV4cG9ydGVkLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIE9wZXJhdG9yKTpib29sZWFufSBbb3B0aW9ucy5zaWduYWxzXSAtIE9wdGlvbmFsXG4gKiAgIHByZWRpY2F0ZSBmdW5jdGlvbiBmb3IgdGVzdGluZyBpZiBhIHNpZ25hbCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlXG4gKiAgIGV4cG9ydGVkIHN0YXRlLiBJZiB1bnNwZWNpZmllZCwgYWxsIHNpZ25hbHMgd2lsbCBiZSBpbmNsdWRlZCwgZXhjZXB0IGZvclxuICogICB0aG9zZSBuYW1lZCAncGFyZW50JyBvciB0aG9zZSB3aGljaCByZWZlciB0byBhIFRyYW5zZm9ybSB2YWx1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpOmJvb2xlYW59IFtvcHRpb25zLmRhdGFdIC0gT3B0aW9uYWxcbiAqICAgcHJlZGljYXRlIGZ1bmN0aW9uIGZvciB0ZXN0aW5nIGlmIGEgZGF0YSBzZXQncyBpbnB1dCBzaG91bGQgYmUgaW5jbHVkZWRcbiAqICAgaW4gdGhlIGV4cG9ydGVkIHN0YXRlLiBJZiB1bnNwZWNpZmllZCwgYWxsIGRhdGEgc2V0cyB0aGF0IGhhdmUgYmVlblxuICogICBleHBsaWNpdGx5IG1vZGlmaWVkIHdpbGwgYmUgaW5jbHVkZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlY3Vyc2U9dHJ1ZV0gLSBGbGFnIGluZGljYXRpbmcgaWYgdGhlIGV4cG9ydGVkXG4gKiAgIHN0YXRlIHNob3VsZCByZWN1cnNpdmVseSBpbmNsdWRlIHN0YXRlIGZyb20gZ3JvdXAgbWFyayBzdWItY29udGV4dHMuXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGV4cG9ydGVkIHN0YXRlIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRTdGF0ZShvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLl9ydW50aW1lLmdldFN0YXRlKG9wdGlvbnMgfHwge1xuICAgIGRhdGE6IGRhdGFUZXN0LFxuICAgIHNpZ25hbHM6IHNpZ25hbFRlc3QsXG4gICAgcmVjdXJzZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGF0YVRlc3QobmFtZSwgZGF0YSkge1xuICByZXR1cm4gZGF0YS5tb2RpZmllZCAmJiBpc0FycmF5KGRhdGEuaW5wdXQudmFsdWUpICYmIG5hbWUuaW5kZXhPZignXzp2ZWdhOl8nKTtcbn1cblxuZnVuY3Rpb24gc2lnbmFsVGVzdChuYW1lLCBvcCkge1xuICByZXR1cm4gIShuYW1lID09PSAncGFyZW50JyB8fCBvcCBpbnN0YW5jZW9mIHRyYW5zZm9ybXMucHJveHkpO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHZpZXcgc3RhdGUgYW5kIHVwZGF0ZXMgdGhlIHZpZXcgYnkgaW52b2tpbmcgcnVuLlxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gQSBzdGF0ZSBvYmplY3QgY29udGFpbmluZyBzaWduYWwgYW5kL29yXG4gKiAgIGRhdGEgc2V0IHZhbHVlcywgZm9sbG93aW5nIHRoZSBmb3JtYXQgdXNlZCBieSB0aGUgZ2V0U3RhdGUgbWV0aG9kLlxuICogQHJldHVybiB7Vmlld30gLSBUaGlzIHZpZXcgaW5zdGFuY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICB0aGlzLnJ1bkFzeW5jKG51bGwsIHYgPT4ge1xuICAgIHYuX3RyaWdnZXIgPSBmYWxzZTtcblxuICAgIHYuX3J1bnRpbWUuc2V0U3RhdGUoc3RhdGUpO1xuICB9LCB2ID0+IHtcbiAgICB2Ll90cmlnZ2VyID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0aW1lciAoY2FsbGJhY2ssIGRlbGF5KSB7XG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIGNhbGxiYWNrKHtcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIGVsYXBzZWQ6IGVsYXBzZWRcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuX3RpbWVycy5wdXNoKGludGVydmFsKHRpY2ssIGRlbGF5KSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb29sdGlwIChoYW5kbGVyLCBldmVudCwgaXRlbSwgdmFsdWUpIHtcbiAgY29uc3QgZWwgPSBoYW5kbGVyLmVsZW1lbnQoKTtcbiAgaWYgKGVsKSBlbC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgZm9ybWF0VG9vbHRpcCh2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUb29sdGlwKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBpc0FycmF5KHZhbHVlKSA/IGZvcm1hdEFycmF5KHZhbHVlKSA6IGlzT2JqZWN0KHZhbHVlKSAmJiAhaXNEYXRlKHZhbHVlKSA/IGZvcm1hdE9iamVjdCh2YWx1ZSkgOiB2YWx1ZSArICcnO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRPYmplY3Qob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChrZXkgPT4ge1xuICAgIGNvbnN0IHYgPSBvYmpba2V5XTtcbiAgICByZXR1cm4ga2V5ICsgJzogJyArIChpc0FycmF5KHYpID8gZm9ybWF0QXJyYXkodikgOiBmb3JtYXRWYWx1ZSh2KSk7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgdmFsdWUubWFwKGZvcm1hdFZhbHVlKS5qb2luKCcsICcpICsgJ10nO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyAnW1xcdTIwMjZdJyA6IGlzT2JqZWN0KHZhbHVlKSAmJiAhaXNEYXRlKHZhbHVlKSA/ICd7XFx1MjAyNn0nIDogdmFsdWU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFZpZXcgaW5zdGFuY2UgZnJvbSBhIFZlZ2EgZGF0YWZsb3cgcnVudGltZSBzcGVjaWZpY2F0aW9uLlxuICogVGhlIGdlbmVyYXRlZCBWaWV3IHdpbGwgbm90IGltbWVkaWF0ZWx5IGJlIHJlYWR5IGZvciBkaXNwbGF5LiBDYWxsZXJzXG4gKiBzaG91bGQgYWxzbyBpbnZva2UgdGhlIGluaXRpYWxpemUgbWV0aG9kIChlLmcuLCB0byBzZXQgdGhlIHBhcmVudFxuICogRE9NIGVsZW1lbnQgaW4gYnJvd3Nlci1iYXNlZCBkZXBsb3ltZW50KSBhbmQgdGhlbiBpbnZva2UgdGhlIHJ1blxuICogbWV0aG9kIHRvIGV2YWx1YXRlIHRoZSBkYXRhZmxvdyBncmFwaC4gUmVuZGVyaW5nIHdpbGwgYXV0b21hdGljYWxseVxuICogYmUgcGVyZm9ybWVkIHVwb24gZGF0YWZsb3cgcnVucy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHNwZWMgLSBUaGUgVmVnYSBkYXRhZmxvdyBydW50aW1lIHNwZWNpZmljYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gVmlldyhzcGVjLCBvcHRpb25zKSB7XG4gIGNvbnN0IHZpZXcgPSB0aGlzO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgRGF0YWZsb3cuY2FsbCh2aWV3KTtcbiAgaWYgKG9wdGlvbnMubG9hZGVyKSB2aWV3LmxvYWRlcihvcHRpb25zLmxvYWRlcik7XG4gIGlmIChvcHRpb25zLmxvZ2dlcikgdmlldy5sb2dnZXIob3B0aW9ucy5sb2dnZXIpO1xuICBpZiAob3B0aW9ucy5sb2dMZXZlbCAhPSBudWxsKSB2aWV3LmxvZ0xldmVsKG9wdGlvbnMubG9nTGV2ZWwpO1xuXG4gIGlmIChvcHRpb25zLmxvY2FsZSB8fCBzcGVjLmxvY2FsZSkge1xuICAgIGNvbnN0IGxvYyA9IGV4dGVuZCh7fSwgc3BlYy5sb2NhbGUsIG9wdGlvbnMubG9jYWxlKTtcbiAgICB2aWV3LmxvY2FsZShsb2NhbGUobG9jLm51bWJlciwgbG9jLnRpbWUpKTtcbiAgfVxuXG4gIHZpZXcuX2VsID0gbnVsbDtcbiAgdmlldy5fZWxCaW5kID0gbnVsbDtcbiAgdmlldy5fcmVuZGVyVHlwZSA9IG9wdGlvbnMucmVuZGVyZXIgfHwgUmVuZGVyVHlwZS5DYW52YXM7XG4gIHZpZXcuX3NjZW5lZ3JhcGggPSBuZXcgU2NlbmVncmFwaCgpO1xuICBjb25zdCByb290ID0gdmlldy5fc2NlbmVncmFwaC5yb290OyAvLyBpbml0aWFsaXplIHJlbmRlcmVyLCBoYW5kbGVyIGFuZCBldmVudCBtYW5hZ2VtZW50XG5cbiAgdmlldy5fcmVuZGVyZXIgPSBudWxsO1xuICB2aWV3Ll90b29sdGlwID0gb3B0aW9ucy50b29sdGlwIHx8IGRlZmF1bHRUb29sdGlwLCB2aWV3Ll9yZWRyYXcgPSB0cnVlO1xuICB2aWV3Ll9oYW5kbGVyID0gbmV3IENhbnZhc0hhbmRsZXIoKS5zY2VuZShyb290KTtcbiAgdmlldy5fZ2xvYmFsQ3Vyc29yID0gZmFsc2U7XG4gIHZpZXcuX3ByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gIHZpZXcuX3RpbWVycyA9IFtdO1xuICB2aWV3Ll9ldmVudExpc3RlbmVycyA9IFtdO1xuICB2aWV3Ll9yZXNpemVMaXN0ZW5lcnMgPSBbXTsgLy8gaW5pdGlhbGl6ZSBldmVudCBjb25maWd1cmF0aW9uXG5cbiAgdmlldy5fZXZlbnRDb25maWcgPSBpbml0aWFsaXplRXZlbnRDb25maWcoc3BlYy5ldmVudENvbmZpZyk7XG4gIHZpZXcuZ2xvYmFsQ3Vyc29yKHZpZXcuX2V2ZW50Q29uZmlnLmdsb2JhbEN1cnNvcik7IC8vIGluaXRpYWxpemUgZGF0YWZsb3cgZ3JhcGhcblxuICBjb25zdCBjdHggPSBydW50aW1lKHZpZXcsIHNwZWMsIG9wdGlvbnMuZXhwcik7XG4gIHZpZXcuX3J1bnRpbWUgPSBjdHg7XG4gIHZpZXcuX3NpZ25hbHMgPSBjdHguc2lnbmFscztcbiAgdmlldy5fYmluZCA9IChzcGVjLmJpbmRpbmdzIHx8IFtdKS5tYXAoXyA9PiAoe1xuICAgIHN0YXRlOiBudWxsLFxuICAgIHBhcmFtOiBleHRlbmQoe30sIF8pXG4gIH0pKTsgLy8gaW5pdGlhbGl6ZSBzY2VuZWdyYXBoXG5cbiAgaWYgKGN0eC5yb290KSBjdHgucm9vdC5zZXQocm9vdCk7XG4gIHJvb3Quc291cmNlID0gY3R4LmRhdGEucm9vdC5pbnB1dDtcbiAgdmlldy5wdWxzZShjdHguZGF0YS5yb290LmlucHV0LCB2aWV3LmNoYW5nZXNldCgpLmluc2VydChyb290Lml0ZW1zKSk7IC8vIGluaXRpYWxpemUgdmlldyBzaXplXG5cbiAgdmlldy5fd2lkdGggPSB2aWV3LndpZHRoKCk7XG4gIHZpZXcuX2hlaWdodCA9IHZpZXcuaGVpZ2h0KCk7XG4gIHZpZXcuX3ZpZXdXaWR0aCA9IHZpZXdXaWR0aCh2aWV3LCB2aWV3Ll93aWR0aCk7XG4gIHZpZXcuX3ZpZXdIZWlnaHQgPSB2aWV3SGVpZ2h0KHZpZXcsIHZpZXcuX2hlaWdodCk7XG4gIHZpZXcuX29yaWdpbiA9IFswLCAwXTtcbiAgdmlldy5fcmVzaXplID0gMDtcbiAgdmlldy5fYXV0b3NpemUgPSAxO1xuICBpbml0aWFsaXplUmVzaXplKHZpZXcpOyAvLyBpbml0aWFsaXplIGJhY2tncm91bmQgY29sb3JcblxuICBiYWNrZ3JvdW5kKHZpZXcpOyAvLyBpbml0aWFsaXplIGN1cnNvclxuXG4gIGN1cnNvcih2aWV3KTsgLy8gaW5pdGlhbGl6ZSB2aWV3IGRlc2NyaXB0aW9uXG5cbiAgdmlldy5kZXNjcmlwdGlvbihzcGVjLmRlc2NyaXB0aW9uKTsgLy8gaW5pdGlhbGl6ZSBob3ZlciBwcm9lc3NpbmcsIGlmIHJlcXVlc3RlZFxuXG4gIGlmIChvcHRpb25zLmhvdmVyKSB2aWV3LmhvdmVyKCk7IC8vIGluaXRpYWxpemUgRE9NIGNvbnRhaW5lcihzKSBhbmQgcmVuZGVyZXJcblxuICBpZiAob3B0aW9ucy5jb250YWluZXIpIHZpZXcuaW5pdGlhbGl6ZShvcHRpb25zLmNvbnRhaW5lciwgb3B0aW9ucy5iaW5kKTtcbn1cblxuZnVuY3Rpb24gbG9va3VwU2lnbmFsKHZpZXcsIG5hbWUpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHZpZXcuX3NpZ25hbHMsIG5hbWUpID8gdmlldy5fc2lnbmFsc1tuYW1lXSA6IGVycm9yKCdVbnJlY29nbml6ZWQgc2lnbmFsIG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRPcGVyYXRvckhhbmRsZXIob3AsIGhhbmRsZXIpIHtcbiAgY29uc3QgaCA9IChvcC5fdGFyZ2V0cyB8fCBbXSkuZmlsdGVyKG9wID0+IG9wLl91cGRhdGUgJiYgb3AuX3VwZGF0ZS5oYW5kbGVyID09PSBoYW5kbGVyKTtcbiAgcmV0dXJuIGgubGVuZ3RoID8gaFswXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFkZE9wZXJhdG9yTGlzdGVuZXIodmlldywgbmFtZSwgb3AsIGhhbmRsZXIpIHtcbiAgbGV0IGggPSBmaW5kT3BlcmF0b3JIYW5kbGVyKG9wLCBoYW5kbGVyKTtcblxuICBpZiAoIWgpIHtcbiAgICBoID0gdHJhcCh2aWV3LCAoKSA9PiBoYW5kbGVyKG5hbWUsIG9wLnZhbHVlKSk7XG4gICAgaC5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2aWV3Lm9uKG9wLCBudWxsLCBoKTtcbiAgfVxuXG4gIHJldHVybiB2aWV3O1xufVxuXG5mdW5jdGlvbiByZW1vdmVPcGVyYXRvckxpc3RlbmVyKHZpZXcsIG9wLCBoYW5kbGVyKSB7XG4gIGNvbnN0IGggPSBmaW5kT3BlcmF0b3JIYW5kbGVyKG9wLCBoYW5kbGVyKTtcbiAgaWYgKGgpIG9wLl90YXJnZXRzLnJlbW92ZShoKTtcbiAgcmV0dXJuIHZpZXc7XG59XG5cbmluaGVyaXRzKFZpZXcsIERhdGFmbG93LCB7XG4gIC8vIC0tIERBVEFGTE9XIC8gUkVOREVSSU5HIC0tLS1cbiAgYXN5bmMgZXZhbHVhdGUoZW5jb2RlLCBwcmVydW4sIHBvc3RydW4pIHtcbiAgICAvLyBldmFsdWF0ZSBkYXRhZmxvdyBhbmQgcHJlcnVuXG4gICAgYXdhaXQgRGF0YWZsb3cucHJvdG90eXBlLmV2YWx1YXRlLmNhbGwodGhpcywgZW5jb2RlLCBwcmVydW4pOyAvLyByZW5kZXIgYXMgbmVlZGVkXG5cbiAgICBpZiAodGhpcy5fcmVkcmF3IHx8IHRoaXMuX3Jlc2l6ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplID0gMDtcbiAgICAgICAgICAgIHJlc2l6ZVJlbmRlcmVyKHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbmRlcmVyLnJlbmRlckFzeW5jKHRoaXMuX3NjZW5lZ3JhcGgucm9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWRyYXcgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgIH1cbiAgICB9IC8vIGV2YWx1YXRlIHBvc3RydW5cblxuXG4gICAgaWYgKHBvc3RydW4pIGFzeW5jQ2FsbGJhY2sodGhpcywgcG9zdHJ1bik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZGlydHkoaXRlbSkge1xuICAgIHRoaXMuX3JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy5fcmVuZGVyZXIgJiYgdGhpcy5fcmVuZGVyZXIuZGlydHkoaXRlbSk7XG4gIH0sXG5cbiAgLy8gLS0gR0VUIC8gU0VUIC0tLS1cbiAgZGVzY3JpcHRpb24odGV4dCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZXNjID0gdGV4dCAhPSBudWxsID8gdGV4dCArICcnIDogbnVsbDtcbiAgICAgIGlmIChkZXNjICE9PSB0aGlzLl9kZXNjKSBhcmlhTGFiZWwodGhpcy5fZWwsIHRoaXMuX2Rlc2MgPSBkZXNjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kZXNjO1xuICB9LFxuXG4gIGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWw7XG4gIH0sXG5cbiAgc2NlbmVncmFwaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NlbmVncmFwaDtcbiAgfSxcblxuICBvcmlnaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yaWdpbi5zbGljZSgpO1xuICB9LFxuXG4gIHNpZ25hbChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9wID0gbG9va3VwU2lnbmFsKHRoaXMsIG5hbWUpO1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gb3AudmFsdWUgOiB0aGlzLnVwZGF0ZShvcCwgdmFsdWUsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHdpZHRoKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2lnbmFsKCd3aWR0aCcsIF8pIDogdGhpcy5zaWduYWwoJ3dpZHRoJyk7XG4gIH0sXG5cbiAgaGVpZ2h0KF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2lnbmFsKCdoZWlnaHQnLCBfKSA6IHRoaXMuc2lnbmFsKCdoZWlnaHQnKTtcbiAgfSxcblxuICBwYWRkaW5nKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2lnbmFsKCdwYWRkaW5nJywgcGFkZGluZyhfKSkgOiBwYWRkaW5nKHRoaXMuc2lnbmFsKCdwYWRkaW5nJykpO1xuICB9LFxuXG4gIGF1dG9zaXplKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2lnbmFsKCdhdXRvc2l6ZScsIF8pIDogdGhpcy5zaWduYWwoJ2F1dG9zaXplJyk7XG4gIH0sXG5cbiAgYmFja2dyb3VuZChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnNpZ25hbCgnYmFja2dyb3VuZCcsIF8pIDogdGhpcy5zaWduYWwoJ2JhY2tncm91bmQnKTtcbiAgfSxcblxuICByZW5kZXJlcih0eXBlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVuZGVyVHlwZTtcbiAgICBpZiAoIXJlbmRlck1vZHVsZSh0eXBlKSkgZXJyb3IoJ1VucmVjb2duaXplZCByZW5kZXJlciB0eXBlOiAnICsgdHlwZSk7XG5cbiAgICBpZiAodHlwZSAhPT0gdGhpcy5fcmVuZGVyVHlwZSkge1xuICAgICAgdGhpcy5fcmVuZGVyVHlwZSA9IHR5cGU7XG5cbiAgICAgIHRoaXMuX3Jlc2V0UmVuZGVyZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0b29sdGlwKGhhbmRsZXIpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuXG4gICAgaWYgKGhhbmRsZXIgIT09IHRoaXMuX3Rvb2x0aXApIHtcbiAgICAgIHRoaXMuX3Rvb2x0aXAgPSBoYW5kbGVyO1xuXG4gICAgICB0aGlzLl9yZXNldFJlbmRlcmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2xvYWRlcjtcblxuICAgIGlmIChsb2FkZXIgIT09IHRoaXMuX2xvYWRlcikge1xuICAgICAgRGF0YWZsb3cucHJvdG90eXBlLmxvYWRlci5jYWxsKHRoaXMsIGxvYWRlcik7XG5cbiAgICAgIHRoaXMuX3Jlc2V0UmVuZGVyZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZXNpemUoKSB7XG4gICAgLy8gc2V0IGZsYWcgdG8gcGVyZm9ybSBhdXRvc2l6ZVxuICAgIHRoaXMuX2F1dG9zaXplID0gMTsgLy8gdG91Y2ggYXV0b3NpemUgc2lnbmFsIHRvIGVuc3VyZSB0b3AtbGV2ZWwgVmlld0xheW91dCBydW5zXG5cbiAgICByZXR1cm4gdGhpcy50b3VjaChsb29rdXBTaWduYWwodGhpcywgJ2F1dG9zaXplJykpO1xuICB9LFxuXG4gIF9yZXNldFJlbmRlcmVyKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJlcikge1xuICAgICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgICAgdGhpcy5pbml0aWFsaXplKHRoaXMuX2VsLCB0aGlzLl9lbEJpbmQpO1xuICAgIH1cbiAgfSxcblxuICAvLyAtLSBTSVpJTkcgLS0tLVxuICBfcmVzaXplVmlldzogcmVzaXplVmlldyxcblxuICAvLyAtLSBFVkVOVCBIQU5ETElORyAtLS0tXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGxldCBjYWxsYmFjayA9IGhhbmRsZXI7XG5cbiAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMudHJhcCA9PT0gZmFsc2UpKSB7XG4gICAgICAvLyB3cmFwIGNhbGxiYWNrIGluIGVycm9yIGhhbmRsZXJcbiAgICAgIGNhbGxiYWNrID0gdHJhcCh0aGlzLCBoYW5kbGVyKTtcbiAgICAgIGNhbGxiYWNrLnJhdyA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgdGhpcy5faGFuZGxlci5vbih0eXBlLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZXJzKHR5cGUpLFxuICAgICAgICBpID0gaGFuZGxlcnMubGVuZ3RoLFxuICAgICAgICBoLFxuICAgICAgICB0OyAvLyBzZWFyY2ggcmVnaXN0ZXJlZCBoYW5kbGVycywgcmVtb3ZlIGlmIG1hdGNoIGZvdW5kXG5cblxuICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgdCA9IGhhbmRsZXJzW2ldLnR5cGU7XG4gICAgICBoID0gaGFuZGxlcnNbaV0uaGFuZGxlcjtcblxuICAgICAgaWYgKHR5cGUgPT09IHQgJiYgKGhhbmRsZXIgPT09IGggfHwgaGFuZGxlciA9PT0gaC5yYXcpKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZXIub2ZmKHQsIGgpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFkZFJlc2l6ZUxpc3RlbmVyKGhhbmRsZXIpIHtcbiAgICBjb25zdCBsID0gdGhpcy5fcmVzaXplTGlzdGVuZXJzO1xuXG4gICAgaWYgKGwuaW5kZXhPZihoYW5kbGVyKSA8IDApIHtcbiAgICAgIC8vIGFkZCBoYW5kbGVyIGlmIGl0IGlzbid0IGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgLy8gbm90ZTogZXJyb3IgdHJhcHBpbmcgaGFuZGxlZCBlbHNld2hlcmUsIHNvXG4gICAgICAvLyBubyBuZWVkIHRvIHdyYXAgaGFuZGxlcnMgaGVyZVxuICAgICAgbC5wdXNoKGhhbmRsZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbW92ZVJlc2l6ZUxpc3RlbmVyKGhhbmRsZXIpIHtcbiAgICB2YXIgbCA9IHRoaXMuX3Jlc2l6ZUxpc3RlbmVycyxcbiAgICAgICAgaSA9IGwuaW5kZXhPZihoYW5kbGVyKTtcblxuICAgIGlmIChpID49IDApIHtcbiAgICAgIGwuc3BsaWNlKGksIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFkZFNpZ25hbExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gYWRkT3BlcmF0b3JMaXN0ZW5lcih0aGlzLCBuYW1lLCBsb29rdXBTaWduYWwodGhpcywgbmFtZSksIGhhbmRsZXIpO1xuICB9LFxuXG4gIHJlbW92ZVNpZ25hbExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVtb3ZlT3BlcmF0b3JMaXN0ZW5lcih0aGlzLCBsb29rdXBTaWduYWwodGhpcywgbmFtZSksIGhhbmRsZXIpO1xuICB9LFxuXG4gIGFkZERhdGFMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGFkZE9wZXJhdG9yTGlzdGVuZXIodGhpcywgbmFtZSwgZGF0YXJlZih0aGlzLCBuYW1lKS52YWx1ZXMsIGhhbmRsZXIpO1xuICB9LFxuXG4gIHJlbW92ZURhdGFMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlbW92ZU9wZXJhdG9yTGlzdGVuZXIodGhpcywgZGF0YXJlZih0aGlzLCBuYW1lKS52YWx1ZXMsIGhhbmRsZXIpO1xuICB9LFxuXG4gIGdsb2JhbEN1cnNvcihfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9nbG9iYWxDdXJzb3IgIT09ICEhXykge1xuICAgICAgICBjb25zdCBwcmV2ID0gc2V0Q3Vyc29yKHRoaXMsIG51bGwpOyAvLyBjbGVhciBwcmV2aW91cyBjdXJzb3JcblxuICAgICAgICB0aGlzLl9nbG9iYWxDdXJzb3IgPSAhIV87XG4gICAgICAgIGlmIChwcmV2KSBzZXRDdXJzb3IodGhpcywgcHJldik7IC8vIHN3YXAgY3Vyc29yXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2xvYmFsQ3Vyc29yO1xuICAgIH1cbiAgfSxcblxuICBwcmV2ZW50RGVmYXVsdChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0ID0gXztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmVudERlZmF1bHQ7XG4gICAgfVxuICB9LFxuXG4gIHRpbWVyLFxuICBldmVudHMsXG4gIGZpbmFsaXplLFxuICBob3ZlcixcbiAgLy8gLS0gREFUQSAtLS0tXG4gIGRhdGEsXG4gIGNoYW5nZSxcbiAgaW5zZXJ0LFxuICByZW1vdmUsXG4gIC8vIC0tIFNDQUxFUyAtLVxuICBzY2FsZSxcbiAgLy8gLS0gSU5JVElBTElaQVRJT04gLS0tLVxuICBpbml0aWFsaXplLFxuICAvLyAtLSBIRUFETEVTUyBSRU5ERVJJTkcgLS0tLVxuICB0b0ltYWdlVVJMOiByZW5kZXJUb0ltYWdlVVJMLFxuICB0b0NhbnZhczogcmVuZGVyVG9DYW52YXMsXG4gIHRvU1ZHOiByZW5kZXJUb1NWRyxcbiAgLy8gLS0gU0FWRSAvIFJFU1RPUkUgU1RBVEUgLS0tLVxuICBnZXRTdGF0ZSxcbiAgc2V0U3RhdGVcbn0pO1xuXG5leHBvcnQgeyBWaWV3IH07XG4iLCJpbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGluaGVyaXRzIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IERlbGF1bmF5IH0gZnJvbSAnZDMtZGVsYXVuYXknO1xuXG5mdW5jdGlvbiBWb3Jvbm9pKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuVm9yb25vaS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdWb3Jvbm9pJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAneCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3knLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzaXplJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudCcsXG4gICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBbWy0xZTUsIC0xZTVdLCBbMWU1LCAxZTVdXSxcbiAgICAnY29udGVudCc6IHtcbiAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAnYXJyYXknOiB0cnVlLFxuICAgICAgJ2xlbmd0aCc6IDJcbiAgICB9XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdwYXRoJ1xuICB9XVxufTtcbmNvbnN0IGRlZmF1bHRFeHRlbnQgPSBbLTFlNSwgLTFlNSwgMWU1LCAxZTVdO1xuaW5oZXJpdHMoVm9yb25vaSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGFzID0gXy5hcyB8fCAncGF0aCcsXG4gICAgICAgICAgZGF0YSA9IHB1bHNlLnNvdXJjZTsgLy8gbm90aGluZyB0byBkbyBpZiBubyBkYXRhXG5cbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSByZXR1cm4gcHVsc2U7IC8vIGNvbmZpZ3VyZSBhbmQgY29uc3RydWN0IHZvcm9ub2kgZGlhZ3JhbVxuXG4gICAgbGV0IHMgPSBfLnNpemU7XG4gICAgcyA9IHMgPyBbMCwgMCwgc1swXSwgc1sxXV0gOiAocyA9IF8uZXh0ZW50KSA/IFtzWzBdWzBdLCBzWzBdWzFdLCBzWzFdWzBdLCBzWzFdWzFdXSA6IGRlZmF1bHRFeHRlbnQ7XG4gICAgY29uc3Qgdm9yb25vaSA9IHRoaXMudmFsdWUgPSBEZWxhdW5heS5mcm9tKGRhdGEsIF8ueCwgXy55KS52b3Jvbm9pKHMpOyAvLyBtYXAgcG9seWdvbnMgdG8gcGF0aHNcblxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IHBvbHlnb24gPSB2b3Jvbm9pLmNlbGxQb2x5Z29uKGkpO1xuICAgICAgZGF0YVtpXVthc10gPSBwb2x5Z29uID8gdG9QYXRoU3RyaW5nKHBvbHlnb24pIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pOyAvLyBzdXBwcmVzcyBkdXBsaWNhdGVkIGVuZCBwb2ludCB2ZXJ0aWNlc1xuXG5mdW5jdGlvbiB0b1BhdGhTdHJpbmcocCkge1xuICBjb25zdCB4ID0gcFswXVswXSxcbiAgICAgICAgeSA9IHBbMF1bMV07XG4gIGxldCBuID0gcC5sZW5ndGggLSAxO1xuXG4gIGZvciAoOyBwW25dWzBdID09PSB4ICYmIHBbbl1bMV0gPT09IHk7IC0tbik7XG5cbiAgcmV0dXJuICdNJyArIHAuc2xpY2UoMCwgbiArIDEpLmpvaW4oJ0wnKSArICdaJztcbn1cblxuZXhwb3J0IHsgVm9yb25vaSBhcyB2b3Jvbm9pIH07XG4iLCJpbXBvcnQgeyBjYW52YXMgfSBmcm9tICd2ZWdhLWNhbnZhcyc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGluaGVyaXRzLCBlcnJvciwgaXNGdW5jdGlvbiwgY29uc3RhbnQsIGV4dGVudCB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBzY2FsZSB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuaW1wb3J0IHsgcmFuZG9tIH0gZnJvbSAndmVnYS1zdGF0aXN0aWNzJztcblxuLypcbkNvcHlyaWdodCAoYykgMjAxMywgSmFzb24gRGF2aWVzLlxuQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG5tb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAqIFRoZSBuYW1lIEphc29uIERhdmllcyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpBU09OIERBVklFUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxuSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG5QUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFXG5PUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGXG5BRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vLyBXb3JkIGNsb3VkIGxheW91dCBieSBKYXNvbiBEYXZpZXMsIGh0dHBzOi8vd3d3Lmphc29uZGF2aWVzLmNvbS93b3JkY2xvdWQvXG4vLyBBbGdvcml0aG0gZHVlIHRvIEpvbmF0aGFuIEZlaW5iZXJnLCBodHRwOi8vc3RhdGljLm1yZmVpbmJlcmcuY29tL2J2X2NoMDMucGRmXG5cbnZhciBjbG91ZFJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwLFxuICAgIGN3ID0gMSA8PCAxMSA+PiA1LFxuICAgIGNoID0gMSA8PCAxMTtcbmZ1bmN0aW9uIGNsb3VkICgpIHtcbiAgdmFyIHNpemUgPSBbMjU2LCAyNTZdLFxuICAgICAgdGV4dCxcbiAgICAgIGZvbnQsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZSxcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICByb3RhdGUsXG4gICAgICBwYWRkaW5nLFxuICAgICAgc3BpcmFsID0gYXJjaGltZWRlYW5TcGlyYWwsXG4gICAgICB3b3JkcyA9IFtdLFxuICAgICAgcmFuZG9tID0gTWF0aC5yYW5kb20sXG4gICAgICBjbG91ZCA9IHt9O1xuXG4gIGNsb3VkLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGV4dEFuZFJhdGlvID0gZ2V0Q29udGV4dChjYW52YXMoKSksXG4gICAgICAgIGJvYXJkID0gemVyb0FycmF5KChzaXplWzBdID4+IDUpICogc2l6ZVsxXSksXG4gICAgICAgIGJvdW5kcyA9IG51bGwsXG4gICAgICAgIG4gPSB3b3Jkcy5sZW5ndGgsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgdGFncyA9IFtdLFxuICAgICAgICBkYXRhID0gd29yZHMubWFwKGQgPT4gKHtcbiAgICAgIHRleHQ6IHRleHQoZCksXG4gICAgICBmb250OiBmb250KGQpLFxuICAgICAgc3R5bGU6IGZvbnRTdHlsZShkKSxcbiAgICAgIHdlaWdodDogZm9udFdlaWdodChkKSxcbiAgICAgIHJvdGF0ZTogcm90YXRlKGQpLFxuICAgICAgc2l6ZTogfn4oZm9udFNpemUoZCkgKyAxZS0xNCksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nKGQpLFxuICAgICAgeG9mZjogMCxcbiAgICAgIHlvZmY6IDAsXG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgeDA6IDAsXG4gICAgICB5MDogMCxcbiAgICAgIGhhc1RleHQ6IGZhbHNlLFxuICAgICAgc3ByaXRlOiBudWxsLFxuICAgICAgZGF0dW06IGRcbiAgICB9KSkuc29ydCgoYSwgYikgPT4gYi5zaXplIC0gYS5zaXplKTtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICB2YXIgZCA9IGRhdGFbaV07XG4gICAgICBkLnggPSBzaXplWzBdICogKHJhbmRvbSgpICsgLjUpID4+IDE7XG4gICAgICBkLnkgPSBzaXplWzFdICogKHJhbmRvbSgpICsgLjUpID4+IDE7XG4gICAgICBjbG91ZFNwcml0ZShjb250ZXh0QW5kUmF0aW8sIGQsIGRhdGEsIGkpO1xuXG4gICAgICBpZiAoZC5oYXNUZXh0ICYmIHBsYWNlKGJvYXJkLCBkLCBib3VuZHMpKSB7XG4gICAgICAgIHRhZ3MucHVzaChkKTtcbiAgICAgICAgaWYgKGJvdW5kcykgY2xvdWRCb3VuZHMoYm91bmRzLCBkKTtlbHNlIGJvdW5kcyA9IFt7XG4gICAgICAgICAgeDogZC54ICsgZC54MCxcbiAgICAgICAgICB5OiBkLnkgKyBkLnkwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBkLnggKyBkLngxLFxuICAgICAgICAgIHk6IGQueSArIGQueTFcbiAgICAgICAgfV07IC8vIFRlbXBvcmFyeSBoYWNrXG5cbiAgICAgICAgZC54IC09IHNpemVbMF0gPj4gMTtcbiAgICAgICAgZC55IC09IHNpemVbMV0gPj4gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFncztcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcykge1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIHZhciByYXRpbyA9IE1hdGguc3FydChjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5sZW5ndGggPj4gMik7XG4gICAgY2FudmFzLndpZHRoID0gKGN3IDw8IDUpIC8gcmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGNoIC8gcmF0aW87XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgcmF0aW86IHJhdGlvXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlKGJvYXJkLCB0YWcsIGJvdW5kcykge1xuICAgIHZhciBzdGFydFggPSB0YWcueCxcbiAgICAgICAgc3RhcnRZID0gdGFnLnksXG4gICAgICAgIG1heERlbHRhID0gTWF0aC5zcXJ0KHNpemVbMF0gKiBzaXplWzBdICsgc2l6ZVsxXSAqIHNpemVbMV0pLFxuICAgICAgICBzID0gc3BpcmFsKHNpemUpLFxuICAgICAgICBkdCA9IHJhbmRvbSgpIDwgLjUgPyAxIDogLTEsXG4gICAgICAgIHQgPSAtZHQsXG4gICAgICAgIGR4ZHksXG4gICAgICAgIGR4LFxuICAgICAgICBkeTtcblxuICAgIHdoaWxlIChkeGR5ID0gcyh0ICs9IGR0KSkge1xuICAgICAgZHggPSB+fmR4ZHlbMF07XG4gICAgICBkeSA9IH5+ZHhkeVsxXTtcbiAgICAgIGlmIChNYXRoLm1pbihNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSkgPj0gbWF4RGVsdGEpIGJyZWFrO1xuICAgICAgdGFnLnggPSBzdGFydFggKyBkeDtcbiAgICAgIHRhZy55ID0gc3RhcnRZICsgZHk7XG4gICAgICBpZiAodGFnLnggKyB0YWcueDAgPCAwIHx8IHRhZy55ICsgdGFnLnkwIDwgMCB8fCB0YWcueCArIHRhZy54MSA+IHNpemVbMF0gfHwgdGFnLnkgKyB0YWcueTEgPiBzaXplWzFdKSBjb250aW51ZTsgLy8gVE9ETyBvbmx5IGNoZWNrIGZvciBjb2xsaXNpb25zIHdpdGhpbiBjdXJyZW50IGJvdW5kcy5cblxuICAgICAgaWYgKCFib3VuZHMgfHwgIWNsb3VkQ29sbGlkZSh0YWcsIGJvYXJkLCBzaXplWzBdKSkge1xuICAgICAgICBpZiAoIWJvdW5kcyB8fCBjb2xsaWRlUmVjdHModGFnLCBib3VuZHMpKSB7XG4gICAgICAgICAgdmFyIHNwcml0ZSA9IHRhZy5zcHJpdGUsXG4gICAgICAgICAgICAgIHcgPSB0YWcud2lkdGggPj4gNSxcbiAgICAgICAgICAgICAgc3cgPSBzaXplWzBdID4+IDUsXG4gICAgICAgICAgICAgIGx4ID0gdGFnLnggLSAodyA8PCA0KSxcbiAgICAgICAgICAgICAgc3ggPSBseCAmIDB4N2YsXG4gICAgICAgICAgICAgIG1zeCA9IDMyIC0gc3gsXG4gICAgICAgICAgICAgIGggPSB0YWcueTEgLSB0YWcueTAsXG4gICAgICAgICAgICAgIHggPSAodGFnLnkgKyB0YWcueTApICogc3cgKyAobHggPj4gNSksXG4gICAgICAgICAgICAgIGxhc3Q7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGg7IGorKykge1xuICAgICAgICAgICAgbGFzdCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHc7IGkrKykge1xuICAgICAgICAgICAgICBib2FyZFt4ICsgaV0gfD0gbGFzdCA8PCBtc3ggfCAoaSA8IHcgPyAobGFzdCA9IHNwcml0ZVtqICogdyArIGldKSA+Pj4gc3ggOiAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeCArPSBzdztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWcuc3ByaXRlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNsb3VkLndvcmRzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgd29yZHMgPSBfO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd29yZHM7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLnNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBzaXplID0gWytfWzBdLCArX1sxXV07XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgfTtcblxuICBjbG91ZC5mb250ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9udCA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmb250O1xuICAgIH1cbiAgfTtcblxuICBjbG91ZC5mb250U3R5bGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250U3R5bGUgPSBmdW5jdG9yKF8pO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm9udFN0eWxlO1xuICAgIH1cbiAgfTtcblxuICBjbG91ZC5mb250V2VpZ2h0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9udFdlaWdodCA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmb250V2VpZ2h0O1xuICAgIH1cbiAgfTtcblxuICBjbG91ZC5yb3RhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByb3RhdGUgPSBmdW5jdG9yKF8pO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm90YXRlO1xuICAgIH1cbiAgfTtcblxuICBjbG91ZC50ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGV4dCA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfTtcblxuICBjbG91ZC5zcGlyYWwgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBzcGlyYWwgPSBzcGlyYWxzW19dIHx8IF87XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzcGlyYWw7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLmZvbnRTaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9udFNpemUgPSBmdW5jdG9yKF8pO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm9udFNpemU7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLnBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBwYWRkaW5nID0gZnVuY3RvcihfKTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhZGRpbmc7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLnJhbmRvbSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJhbmRvbSA9IF87XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByYW5kb207XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjbG91ZDtcbn0gLy8gRmV0Y2hlcyBhIG1vbm9jaHJvbWUgc3ByaXRlIGJpdG1hcCBmb3IgdGhlIHNwZWNpZmllZCB0ZXh0LlxuLy8gTG9hZCBpbiBiYXRjaGVzIGZvciBzcGVlZC5cblxuZnVuY3Rpb24gY2xvdWRTcHJpdGUoY29udGV4dEFuZFJhdGlvLCBkLCBkYXRhLCBkaSkge1xuICBpZiAoZC5zcHJpdGUpIHJldHVybjtcbiAgdmFyIGMgPSBjb250ZXh0QW5kUmF0aW8uY29udGV4dCxcbiAgICAgIHJhdGlvID0gY29udGV4dEFuZFJhdGlvLnJhdGlvO1xuICBjLmNsZWFyUmVjdCgwLCAwLCAoY3cgPDwgNSkgLyByYXRpbywgY2ggLyByYXRpbyk7XG4gIHZhciB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgbWF4aCA9IDAsXG4gICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICB3LFxuICAgICAgdzMyLFxuICAgICAgaCxcbiAgICAgIGksXG4gICAgICBqO1xuICAtLWRpO1xuXG4gIHdoaWxlICgrK2RpIDwgbikge1xuICAgIGQgPSBkYXRhW2RpXTtcbiAgICBjLnNhdmUoKTtcbiAgICBjLmZvbnQgPSBkLnN0eWxlICsgJyAnICsgZC53ZWlnaHQgKyAnICcgKyB+figoZC5zaXplICsgMSkgLyByYXRpbykgKyAncHggJyArIGQuZm9udDtcbiAgICB3ID0gYy5tZWFzdXJlVGV4dChkLnRleHQgKyAnbScpLndpZHRoICogcmF0aW87XG4gICAgaCA9IGQuc2l6ZSA8PCAxO1xuXG4gICAgaWYgKGQucm90YXRlKSB7XG4gICAgICB2YXIgc3IgPSBNYXRoLnNpbihkLnJvdGF0ZSAqIGNsb3VkUmFkaWFucyksXG4gICAgICAgICAgY3IgPSBNYXRoLmNvcyhkLnJvdGF0ZSAqIGNsb3VkUmFkaWFucyksXG4gICAgICAgICAgd2NyID0gdyAqIGNyLFxuICAgICAgICAgIHdzciA9IHcgKiBzcixcbiAgICAgICAgICBoY3IgPSBoICogY3IsXG4gICAgICAgICAgaHNyID0gaCAqIHNyO1xuICAgICAgdyA9IE1hdGgubWF4KE1hdGguYWJzKHdjciArIGhzciksIE1hdGguYWJzKHdjciAtIGhzcikpICsgMHgxZiA+PiA1IDw8IDU7XG4gICAgICBoID0gfn5NYXRoLm1heChNYXRoLmFicyh3c3IgKyBoY3IpLCBNYXRoLmFicyh3c3IgLSBoY3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdyA9IHcgKyAweDFmID4+IDUgPDwgNTtcbiAgICB9XG5cbiAgICBpZiAoaCA+IG1heGgpIG1heGggPSBoO1xuXG4gICAgaWYgKHggKyB3ID49IGN3IDw8IDUpIHtcbiAgICAgIHggPSAwO1xuICAgICAgeSArPSBtYXhoO1xuICAgICAgbWF4aCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHkgKyBoID49IGNoKSBicmVhaztcbiAgICBjLnRyYW5zbGF0ZSgoeCArICh3ID4+IDEpKSAvIHJhdGlvLCAoeSArIChoID4+IDEpKSAvIHJhdGlvKTtcbiAgICBpZiAoZC5yb3RhdGUpIGMucm90YXRlKGQucm90YXRlICogY2xvdWRSYWRpYW5zKTtcbiAgICBjLmZpbGxUZXh0KGQudGV4dCwgMCwgMCk7XG5cbiAgICBpZiAoZC5wYWRkaW5nKSB7XG4gICAgICBjLmxpbmVXaWR0aCA9IDIgKiBkLnBhZGRpbmc7XG4gICAgICBjLnN0cm9rZVRleHQoZC50ZXh0LCAwLCAwKTtcbiAgICB9XG5cbiAgICBjLnJlc3RvcmUoKTtcbiAgICBkLndpZHRoID0gdztcbiAgICBkLmhlaWdodCA9IGg7XG4gICAgZC54b2ZmID0geDtcbiAgICBkLnlvZmYgPSB5O1xuICAgIGQueDEgPSB3ID4+IDE7XG4gICAgZC55MSA9IGggPj4gMTtcbiAgICBkLngwID0gLWQueDE7XG4gICAgZC55MCA9IC1kLnkxO1xuICAgIGQuaGFzVGV4dCA9IHRydWU7XG4gICAgeCArPSB3O1xuICB9XG5cbiAgdmFyIHBpeGVscyA9IGMuZ2V0SW1hZ2VEYXRhKDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKS5kYXRhLFxuICAgICAgc3ByaXRlID0gW107XG5cbiAgd2hpbGUgKC0tZGkgPj0gMCkge1xuICAgIGQgPSBkYXRhW2RpXTtcbiAgICBpZiAoIWQuaGFzVGV4dCkgY29udGludWU7XG4gICAgdyA9IGQud2lkdGg7XG4gICAgdzMyID0gdyA+PiA1O1xuICAgIGggPSBkLnkxIC0gZC55MDsgLy8gWmVybyB0aGUgYnVmZmVyXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaCAqIHczMjsgaSsrKSBzcHJpdGVbaV0gPSAwO1xuXG4gICAgeCA9IGQueG9mZjtcbiAgICBpZiAoeCA9PSBudWxsKSByZXR1cm47XG4gICAgeSA9IGQueW9mZjtcbiAgICB2YXIgc2VlbiA9IDAsXG4gICAgICAgIHNlZW5Sb3cgPSAtMTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB3OyBpKyspIHtcbiAgICAgICAgdmFyIGsgPSB3MzIgKiBqICsgKGkgPj4gNSksXG4gICAgICAgICAgICBtID0gcGl4ZWxzWyh5ICsgaikgKiAoY3cgPDwgNSkgKyAoeCArIGkpIDw8IDJdID8gMSA8PCAzMSAtIGkgJSAzMiA6IDA7XG4gICAgICAgIHNwcml0ZVtrXSB8PSBtO1xuICAgICAgICBzZWVuIHw9IG07XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWVuKSBzZWVuUm93ID0gajtlbHNlIHtcbiAgICAgICAgZC55MCsrO1xuICAgICAgICBoLS07XG4gICAgICAgIGotLTtcbiAgICAgICAgeSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGQueTEgPSBkLnkwICsgc2VlblJvdztcbiAgICBkLnNwcml0ZSA9IHNwcml0ZS5zbGljZSgwLCAoZC55MSAtIGQueTApICogdzMyKTtcbiAgfVxufSAvLyBVc2UgbWFzay1iYXNlZCBjb2xsaXNpb24gZGV0ZWN0aW9uLlxuXG5cbmZ1bmN0aW9uIGNsb3VkQ29sbGlkZSh0YWcsIGJvYXJkLCBzdykge1xuICBzdyA+Pj0gNTtcbiAgdmFyIHNwcml0ZSA9IHRhZy5zcHJpdGUsXG4gICAgICB3ID0gdGFnLndpZHRoID4+IDUsXG4gICAgICBseCA9IHRhZy54IC0gKHcgPDwgNCksXG4gICAgICBzeCA9IGx4ICYgMHg3ZixcbiAgICAgIG1zeCA9IDMyIC0gc3gsXG4gICAgICBoID0gdGFnLnkxIC0gdGFnLnkwLFxuICAgICAgeCA9ICh0YWcueSArIHRhZy55MCkgKiBzdyArIChseCA+PiA1KSxcbiAgICAgIGxhc3Q7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICBsYXN0ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHc7IGkrKykge1xuICAgICAgaWYgKChsYXN0IDw8IG1zeCB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApKSAmIGJvYXJkW3ggKyBpXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgeCArPSBzdztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2xvdWRCb3VuZHMoYm91bmRzLCBkKSB7XG4gIHZhciBiMCA9IGJvdW5kc1swXSxcbiAgICAgIGIxID0gYm91bmRzWzFdO1xuICBpZiAoZC54ICsgZC54MCA8IGIwLngpIGIwLnggPSBkLnggKyBkLngwO1xuICBpZiAoZC55ICsgZC55MCA8IGIwLnkpIGIwLnkgPSBkLnkgKyBkLnkwO1xuICBpZiAoZC54ICsgZC54MSA+IGIxLngpIGIxLnggPSBkLnggKyBkLngxO1xuICBpZiAoZC55ICsgZC55MSA+IGIxLnkpIGIxLnkgPSBkLnkgKyBkLnkxO1xufVxuXG5mdW5jdGlvbiBjb2xsaWRlUmVjdHMoYSwgYikge1xuICByZXR1cm4gYS54ICsgYS54MSA+IGJbMF0ueCAmJiBhLnggKyBhLngwIDwgYlsxXS54ICYmIGEueSArIGEueTEgPiBiWzBdLnkgJiYgYS55ICsgYS55MCA8IGJbMV0ueTtcbn1cblxuZnVuY3Rpb24gYXJjaGltZWRlYW5TcGlyYWwoc2l6ZSkge1xuICB2YXIgZSA9IHNpemVbMF0gLyBzaXplWzFdO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gW2UgKiAodCAqPSAuMSkgKiBNYXRoLmNvcyh0KSwgdCAqIE1hdGguc2luKHQpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTcGlyYWwoc2l6ZSkge1xuICB2YXIgZHkgPSA0LFxuICAgICAgZHggPSBkeSAqIHNpemVbMF0gLyBzaXplWzFdLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHNpZ24gPSB0IDwgMCA/IC0xIDogMTsgLy8gU2VlIHRyaWFuZ3VsYXIgbnVtYmVyczogVF9uID0gbiAqIChuICsgMSkgLyAyLlxuXG4gICAgc3dpdGNoIChNYXRoLnNxcnQoMSArIDQgKiBzaWduICogdCkgLSBzaWduICYgMykge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB4ICs9IGR4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOlxuICAgICAgICB5ICs9IGR5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICB4IC09IGR4O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgeSAtPSBkeTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfTtcbn0gLy8gVE9ETyByZXVzZSBhcnJheXM/XG5cblxuZnVuY3Rpb24gemVyb0FycmF5KG4pIHtcbiAgdmFyIGEgPSBbXSxcbiAgICAgIGkgPSAtMTtcblxuICB3aGlsZSAoKytpIDwgbikgYVtpXSA9IDA7XG5cbiAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0b3IoZCkge1xuICByZXR1cm4gdHlwZW9mIGQgPT09ICdmdW5jdGlvbicgPyBkIDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkO1xuICB9O1xufVxuXG52YXIgc3BpcmFscyA9IHtcbiAgYXJjaGltZWRlYW46IGFyY2hpbWVkZWFuU3BpcmFsLFxuICByZWN0YW5ndWxhcjogcmVjdGFuZ3VsYXJTcGlyYWxcbn07XG5cbmNvbnN0IE91dHB1dCA9IFsneCcsICd5JywgJ2ZvbnQnLCAnZm9udFNpemUnLCAnZm9udFN0eWxlJywgJ2ZvbnRXZWlnaHQnLCAnYW5nbGUnXTtcbmNvbnN0IFBhcmFtcyA9IFsndGV4dCcsICdmb250JywgJ3JvdGF0ZScsICdmb250U2l6ZScsICdmb250U3R5bGUnLCAnZm9udFdlaWdodCddO1xuZnVuY3Rpb24gV29yZGNsb3VkKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBjbG91ZCgpLCBwYXJhbXMpO1xufVxuV29yZGNsb3VkLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1dvcmRjbG91ZCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnZm9udCcsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZXhwcic6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAnc2Fucy1zZXJpZidcbiAgfSwge1xuICAgICduYW1lJzogJ2ZvbnRTdHlsZScsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZXhwcic6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAnbm9ybWFsJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZm9udFdlaWdodCcsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZXhwcic6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAnbm9ybWFsJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZm9udFNpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2V4cHInOiB0cnVlLFxuICAgICdkZWZhdWx0JzogMTRcbiAgfSwge1xuICAgICduYW1lJzogJ2ZvbnRTaXplUmFuZ2UnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogJ251bGxhYmxlJyxcbiAgICAnZGVmYXVsdCc6IFsxMCwgNTBdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyb3RhdGUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2V4cHInOiB0cnVlLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAndGV4dCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzcGlyYWwnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ3ZhbHVlcyc6IFsnYXJjaGltZWRlYW4nLCAncmVjdGFuZ3VsYXInXVxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDcsXG4gICAgJ2RlZmF1bHQnOiBPdXRwdXRcbiAgfV1cbn07XG5pbmhlcml0cyhXb3JkY2xvdWQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAoXy5zaXplICYmICEoXy5zaXplWzBdICYmIF8uc2l6ZVsxXSkpIHtcbiAgICAgIGVycm9yKCdXb3JkY2xvdWQgc2l6ZSBkaW1lbnNpb25zIG11c3QgYmUgbm9uLXplcm8uJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9kcChwYXJhbSkge1xuICAgICAgY29uc3QgcCA9IF9bcGFyYW1dO1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ocCkgJiYgcHVsc2UubW9kaWZpZWQocC5maWVsZHMpO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZCA9IF8ubW9kaWZpZWQoKTtcblxuICAgIGlmICghKG1vZCB8fCBwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERF9SRU0pIHx8IFBhcmFtcy5zb21lKG1vZHApKSkgcmV0dXJuO1xuICAgIGNvbnN0IGRhdGEgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgICAgICBsYXlvdXQgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBPdXRwdXQ7XG4gICAgbGV0IGZvbnRTaXplID0gXy5mb250U2l6ZSB8fCAxNCxcbiAgICAgICAgcmFuZ2U7XG4gICAgaXNGdW5jdGlvbihmb250U2l6ZSkgPyByYW5nZSA9IF8uZm9udFNpemVSYW5nZSA6IGZvbnRTaXplID0gY29uc3RhbnQoZm9udFNpemUpOyAvLyBjcmVhdGUgZm9udCBzaXplIHNjYWxpbmcgZnVuY3Rpb24gYXMgbmVlZGVkXG5cbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGNvbnN0IGZzaXplID0gZm9udFNpemUsXG4gICAgICAgICAgICBzaXplU2NhbGUgPSBzY2FsZSgnc3FydCcpKCkuZG9tYWluKGV4dGVudChkYXRhLCBmc2l6ZSkpLnJhbmdlKHJhbmdlKTtcblxuICAgICAgZm9udFNpemUgPSB4ID0+IHNpemVTY2FsZShmc2l6ZSh4KSk7XG4gICAgfVxuXG4gICAgZGF0YS5mb3JFYWNoKHQgPT4ge1xuICAgICAgdFthc1swXV0gPSBOYU47XG4gICAgICB0W2FzWzFdXSA9IE5hTjtcbiAgICAgIHRbYXNbM11dID0gMDtcbiAgICB9KTsgLy8gY29uZmlndXJlIGxheW91dFxuXG4gICAgY29uc3Qgd29yZHMgPSBsYXlvdXQud29yZHMoZGF0YSkudGV4dChfLnRleHQpLnNpemUoXy5zaXplIHx8IFs1MDAsIDUwMF0pLnBhZGRpbmcoXy5wYWRkaW5nIHx8IDEpLnNwaXJhbChfLnNwaXJhbCB8fCAnYXJjaGltZWRlYW4nKS5yb3RhdGUoXy5yb3RhdGUgfHwgMCkuZm9udChfLmZvbnQgfHwgJ3NhbnMtc2VyaWYnKS5mb250U3R5bGUoXy5mb250U3R5bGUgfHwgJ25vcm1hbCcpLmZvbnRXZWlnaHQoXy5mb250V2VpZ2h0IHx8ICdub3JtYWwnKS5mb250U2l6ZShmb250U2l6ZSkucmFuZG9tKHJhbmRvbSkubGF5b3V0KCk7XG4gICAgY29uc3Qgc2l6ZSA9IGxheW91dC5zaXplKCksXG4gICAgICAgICAgZHggPSBzaXplWzBdID4+IDEsXG4gICAgICAgICAgZHkgPSBzaXplWzFdID4+IDEsXG4gICAgICAgICAgbiA9IHdvcmRzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwLCB3LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICB3ID0gd29yZHNbaV07XG4gICAgICB0ID0gdy5kYXR1bTtcbiAgICAgIHRbYXNbMF1dID0gdy54ICsgZHg7XG4gICAgICB0W2FzWzFdXSA9IHcueSArIGR5O1xuICAgICAgdFthc1syXV0gPSB3LmZvbnQ7XG4gICAgICB0W2FzWzNdXSA9IHcuc2l6ZTtcbiAgICAgIHRbYXNbNF1dID0gdy5zdHlsZTtcbiAgICAgIHRbYXNbNV1dID0gdy53ZWlnaHQ7XG4gICAgICB0W2FzWzZdXSA9IHcucm90YXRlO1xuICAgIH1cblxuICAgIHJldHVybiBwdWxzZS5yZWZsb3cobW9kKS5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbmV4cG9ydCB7IFdvcmRjbG91ZCBhcyB3b3JkY2xvdWQgfTtcbiIsImltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5leHBvcnQgKiBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgdHJhbnNmb3JtcyB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuZXhwb3J0IHsgRGF0YWZsb3csIEV2ZW50U3RyZWFtLCBNdWx0aVB1bHNlLCBPcGVyYXRvciwgUGFyYW1ldGVycywgUHVsc2UsIFRyYW5zZm9ybSwgY2hhbmdlc2V0LCBkZWZpbml0aW9uLCBpbmdlc3QsIGlzVHVwbGUsIHRyYW5zZm9ybSwgdHJhbnNmb3JtcywgdHVwbGVpZCB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0ICogYXMgdHggZnJvbSAndmVnYS10cmFuc2Zvcm1zJztcbmltcG9ydCAqIGFzIHZ0eCBmcm9tICd2ZWdhLXZpZXctdHJhbnNmb3Jtcyc7XG5pbXBvcnQgKiBhcyBlbmNvZGUgZnJvbSAndmVnYS1lbmNvZGUnO1xuaW1wb3J0ICogYXMgZ2VvIGZyb20gJ3ZlZ2EtZ2VvJztcbmltcG9ydCAqIGFzIGZvcmNlIGZyb20gJ3ZlZ2EtZm9yY2UnO1xuaW1wb3J0ICogYXMgdHJlZSBmcm9tICd2ZWdhLWhpZXJhcmNoeSc7XG5pbXBvcnQgKiBhcyBsYWJlbCBmcm9tICd2ZWdhLWxhYmVsJztcbmltcG9ydCAqIGFzIHJlZyBmcm9tICd2ZWdhLXJlZ3Jlc3Npb24nO1xuaW1wb3J0ICogYXMgdm9yb25vaSBmcm9tICd2ZWdhLXZvcm9ub2knO1xuaW1wb3J0ICogYXMgd29yZGNsb3VkIGZyb20gJ3ZlZ2Etd29yZGNsb3VkJztcbmltcG9ydCAqIGFzIHhmIGZyb20gJ3ZlZ2EtY3Jvc3NmaWx0ZXInO1xuZXhwb3J0ICogZnJvbSAndmVnYS1zdGF0aXN0aWNzJztcbmV4cG9ydCAqIGZyb20gJ3ZlZ2EtdGltZSc7XG5leHBvcnQgKiBmcm9tICd2ZWdhLWxvYWRlcic7XG5leHBvcnQgKiBmcm9tICd2ZWdhLXNjZW5lZ3JhcGgnO1xuZXhwb3J0IHsgaW50ZXJwb2xhdGUsIGludGVycG9sYXRlQ29sb3JzLCBpbnRlcnBvbGF0ZVJhbmdlLCBxdWFudGl6ZUludGVycG9sYXRvciwgc2NhbGUsIHNjaGVtZSB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuZXhwb3J0IHsgcHJvamVjdGlvbiB9IGZyb20gJ3ZlZ2EtcHJvamVjdGlvbic7XG5leHBvcnQgeyBWaWV3IH0gZnJvbSAndmVnYS12aWV3JztcbmV4cG9ydCB7IGRlZmF1bHRMb2NhbGUsIG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUgYXMgZm9ybWF0TG9jYWxlLCBsb2NhbGUsIHJlc2V0RGVmYXVsdExvY2FsZSwgdGltZUZvcm1hdERlZmF1bHRMb2NhbGUgYXMgdGltZUZvcm1hdExvY2FsZSB9IGZyb20gJ3ZlZ2EtZm9ybWF0JztcbmV4cG9ydCB7IGV4cHJlc3Npb25GdW5jdGlvbiB9IGZyb20gJ3ZlZ2EtZnVuY3Rpb25zJztcbmV4cG9ydCB7IHBhcnNlIH0gZnJvbSAndmVnYS1wYXJzZXInO1xuZXhwb3J0IHsgY29udGV4dCBhcyBydW50aW1lQ29udGV4dCB9IGZyb20gJ3ZlZ2EtcnVudGltZSc7XG5leHBvcnQgeyBjb2RlZ2VuRXhwcmVzc2lvbiwgcGFyc2VFeHByZXNzaW9uIH0gZnJvbSAndmVnYS1leHByZXNzaW9uJztcbmV4cG9ydCB7IHBhcnNlU2VsZWN0b3IgfSBmcm9tICd2ZWdhLWV2ZW50LXNlbGVjdG9yJztcblxudmFyIG5hbWUgPSBcInZlZ2FcIjtcbnZhciB2ZXJzaW9uJDEgPSBcIjUuMjEuMFwiO1xudmFyIGRlc2NyaXB0aW9uID0gXCJUaGUgVmVnYSB2aXN1YWxpemF0aW9uIGdyYW1tYXIuXCI7XG52YXIga2V5d29yZHMgPSBbXG5cdFwidmVnYVwiLFxuXHRcInZpc3VhbGl6YXRpb25cIixcblx0XCJpbnRlcmFjdGlvblwiLFxuXHRcImRhdGFmbG93XCIsXG5cdFwibGlicmFyeVwiLFxuXHRcImRhdGFcIixcblx0XCJkM1wiXG5dO1xudmFyIGxpY2Vuc2UgPSBcIkJTRC0zLUNsYXVzZVwiO1xudmFyIGF1dGhvciA9IFwiVVcgSW50ZXJhY3RpdmUgRGF0YSBMYWIgKGh0dHA6Ly9pZGwuY3Mud2FzaGluZ3Rvbi5lZHUpXCI7XG52YXIgbWFpbiA9IFwiYnVpbGQvdmVnYS1ub2RlLmpzXCI7XG52YXIgbW9kdWxlID0gXCJidWlsZC92ZWdhLm1vZHVsZS5qc1wiO1xudmFyIHVucGtnID0gXCJidWlsZC92ZWdhLm1pbi5qc1wiO1xudmFyIGpzZGVsaXZyID0gXCJidWlsZC92ZWdhLm1pbi5qc1wiO1xudmFyIHR5cGVzID0gXCJpbmRleC5kLnRzXCI7XG52YXIgcmVwb3NpdG9yeSA9IFwidmVnYS92ZWdhXCI7XG52YXIgc2NyaXB0cyA9IHtcblx0YnVuZGxlOiBcInJvbGx1cCAtYyAtLWNvbmZpZy1idW5kbGVcIixcblx0cHJlYnVpbGQ6IFwicmltcmFmIGJ1aWxkICYmIHJpbXJhZiBidWlsZC1lczVcIixcblx0YnVpbGQ6IFwicm9sbHVwIC1jIC0tY29uZmlnLWNvcmUgLS1jb25maWctYnVuZGxlIC0tY29uZmlnLWllXCIsXG5cdHBvc3RidWlsZDogXCJub2RlIHNjaGVtYS1jb3B5XCIsXG5cdHByZXRlc3Q6IFwieWFybiBidWlsZCAtLWNvbmZpZy10ZXN0XCIsXG5cdHRlc3Q6IFwiVFo9QW1lcmljYS9Mb3NfQW5nZWxlcyB0YXBlICd0ZXN0LyoqLyotdGVzdC5qcydcIixcblx0cHJlcHVibGlzaE9ubHk6IFwieWFybiB0ZXN0ICYmIHlhcm4gYnVpbGRcIixcblx0cG9zdHB1Ymxpc2g6IFwiLi9zY2hlbWEtZGVwbG95LnNoXCJcbn07XG52YXIgZGVwZW5kZW5jaWVzID0ge1xuXHRcInZlZ2EtY3Jvc3NmaWx0ZXJcIjogXCJ+NC4wLjVcIixcblx0XCJ2ZWdhLWRhdGFmbG93XCI6IFwifjUuNy40XCIsXG5cdFwidmVnYS1lbmNvZGVcIjogXCJ+NC44LjNcIixcblx0XCJ2ZWdhLWV2ZW50LXNlbGVjdG9yXCI6IFwifjMuMC4wXCIsXG5cdFwidmVnYS1leHByZXNzaW9uXCI6IFwifjUuMC4wXCIsXG5cdFwidmVnYS1mb3JjZVwiOiBcIn40LjAuN1wiLFxuXHRcInZlZ2EtZm9ybWF0XCI6IFwifjEuMC40XCIsXG5cdFwidmVnYS1mdW5jdGlvbnNcIjogXCJ+NS4xMi4xXCIsXG5cdFwidmVnYS1nZW9cIjogXCJ+NC4zLjhcIixcblx0XCJ2ZWdhLWhpZXJhcmNoeVwiOiBcIn40LjAuOVwiLFxuXHRcInZlZ2EtbGFiZWxcIjogXCJ+MS4xLjBcIixcblx0XCJ2ZWdhLWxvYWRlclwiOiBcIn40LjQuMVwiLFxuXHRcInZlZ2EtcGFyc2VyXCI6IFwifjYuMS40XCIsXG5cdFwidmVnYS1wcm9qZWN0aW9uXCI6IFwifjEuNC41XCIsXG5cdFwidmVnYS1yZWdyZXNzaW9uXCI6IFwifjEuMC45XCIsXG5cdFwidmVnYS1ydW50aW1lXCI6IFwifjYuMS4zXCIsXG5cdFwidmVnYS1zY2FsZVwiOiBcIn43LjEuMVwiLFxuXHRcInZlZ2Etc2NlbmVncmFwaFwiOiBcIn40LjkuNFwiLFxuXHRcInZlZ2Etc3RhdGlzdGljc1wiOiBcIn4xLjcuMTBcIixcblx0XCJ2ZWdhLXRpbWVcIjogXCJ+Mi4wLjRcIixcblx0XCJ2ZWdhLXRyYW5zZm9ybXNcIjogXCJ+NC45LjRcIixcblx0XCJ2ZWdhLXR5cGluZ3NcIjogXCJ+MC4yMi4wXCIsXG5cdFwidmVnYS11dGlsXCI6IFwifjEuMTcuMFwiLFxuXHRcInZlZ2Etdmlld1wiOiBcIn41LjEwLjFcIixcblx0XCJ2ZWdhLXZpZXctdHJhbnNmb3Jtc1wiOiBcIn40LjUuOFwiLFxuXHRcInZlZ2Etdm9yb25vaVwiOiBcIn40LjEuNVwiLFxuXHRcInZlZ2Etd29yZGNsb3VkXCI6IFwifjQuMS4zXCJcbn07XG52YXIgZGV2RGVwZW5kZW5jaWVzID0ge1xuXHRcInZlZ2Etc2NoZW1hXCI6IFwiKlwiXG59O1xudmFyIGdpdEhlYWQgPSBcIjc3NDE2NWUyOTg1MGI2NmVjOGI3OWJhNTJhNzk1NWYxYWI5MzZlYTZcIjtcbnZhciBwa2cgPSB7XG5cdG5hbWU6IG5hbWUsXG5cdHZlcnNpb246IHZlcnNpb24kMSxcblx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuXHRrZXl3b3Jkczoga2V5d29yZHMsXG5cdGxpY2Vuc2U6IGxpY2Vuc2UsXG5cdGF1dGhvcjogYXV0aG9yLFxuXHRtYWluOiBtYWluLFxuXHRtb2R1bGU6IG1vZHVsZSxcblx0dW5wa2c6IHVucGtnLFxuXHRqc2RlbGl2cjoganNkZWxpdnIsXG5cdHR5cGVzOiB0eXBlcyxcblx0cmVwb3NpdG9yeTogcmVwb3NpdG9yeSxcblx0c2NyaXB0czogc2NyaXB0cyxcblx0ZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMsXG5cdGRldkRlcGVuZGVuY2llczogZGV2RGVwZW5kZW5jaWVzLFxuXHRnaXRIZWFkOiBnaXRIZWFkXG59O1xuXG4vLyAtLSBUcmFuc2Zvcm1zIC0tLS0tXG5leHRlbmQodHJhbnNmb3JtcywgdHgsIHZ0eCwgZW5jb2RlLCBnZW8sIGZvcmNlLCBsYWJlbCwgdHJlZSwgcmVnLCB2b3Jvbm9pLCB3b3JkY2xvdWQsIHhmKTsgLy8gLS0gRXhwb3J0cyAtLS0tLVxuXG5jb25zdCB2ZXJzaW9uID0gcGtnLnZlcnNpb247XG5cbmV4cG9ydCB7IHZlcnNpb24gfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=